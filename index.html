<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 98vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:0;}
        .stage{width:100vw; height:100svh; position:relative;display:grid;place-items:center;background:#000;border-radius:0;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
        canvas{background:transparent;border-radius:16px;touch-action:none;cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }
        #diagBox{position:absolute;left:8px;top:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:left;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s; font-family: 'Orbitron', 'Audiowide', ui-sans-serif;}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        
        .panel{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:rgba(26,0,34,.95);
            border:1px solid var(--accent);
            border-radius:16px;
            padding:12px;
            width:min(600px, 90vw);
            backdrop-filter:blur(12px);
            color:#ffddff;
            box-shadow:0 0 40px rgba(178,102,255,.3);
            z-index:100;
        }
        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }
        .close-btn {
            position: absolute;
            top: 8px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 20px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 4px;
        }
        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        #shopPanel h2, #levelPanel h2, #scorePanel h2, #namePanel h2, #pilotPanel h2, #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }
        #shopPanel p, #levelPanel p, #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }
        #shopGrid, #scorePanel div {
            max-height: 60vh; 
            overflow-y: auto;
            padding-right: 8px;
        }
        .grid{
            display:grid;
            gap:8px;
            grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
        }
        .hide{display:none!important}
        #belowBoard{width:min(98vw,var(--maxw));margin:50px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        
        .skill-card {
            background: radial-gradient(circle, rgba(51,0,68,1) 0%, rgba(51,0,68,0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        
        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }
        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }
        .skill-title{
            font-weight:700;
            color:#c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }
        .skill-desc{
            font-size:11px;
            color:#ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }
        .skill-bonuses {
            font-size: 10px;
            color: var(--accent);
            line-height: 1.4;
            margin-top: auto;
            padding-top: 8px;
            border-top: 1px solid var(--edge);
            width: 100%;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }
        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }
        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }
        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn{
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.4;
            transition: opacity 0.3s ease-in-out;
        }
        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }
        
        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }
        #bottom-right-controls > .fixed-btn {
            position: static;
        }

        #menuBtn, #fsEnterBtn, #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }
        #pauseBtn {
            top: 50%;
            right: 15px; 
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif; box-sizing: border-box;}
        
        #abilityBar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 6; pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }
        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }
        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }
        
        .shop-item-attack { border-color: #00bfff; }
        .shop-item-health { border-color: #00ff00; }
        .shop-item-utility { border-color: #ffd700; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
            50% { box-shadow: 0 0 35px rgba(102, 255, 178, 1); }
            100% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
        }
        @keyframes pulse-glow-ability {
            0% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
            50% { box-shadow: 0 0 20px rgba(178, 102, 255, .8); }
            100% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
        }
        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(500px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
    </style>
</head>
<body>
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide"></div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card"></div>
                        <div id="hudPilotContent" class="hud-card"></div>
                        <div id="hudBossContent" class="hud-card hide"></div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide"></div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <div class="chip">v3.7.5</div>
                    <div class="chip">FPS <span id="fps">‚Äî</span></div>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üöÄ PILOT LOST üöÄ</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <button id="storyBtn" type="button">i</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">A charging juggernaut that automatically retaliates against nearby foes.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN"></div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">A master of area denial, leaving a trail of fire in his wake.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="wizard">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER"></div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">An ethereal pilot who can blink through the void itself.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                     <div id="subclassPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                            <!-- Subclass options will be injected here -->
                        </div>
                    </div>
                    <div id="storyPanel" class="panel hide">
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                        Mammalian life developed specialized spacecraft to venture within and colonize the resources of the primitive creatures.<br><br>
                        The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üíÄ CALLSIGN üíÄ</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üèÜ Aces of the Void üèÜ</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <button type="button" class="close-btn" id="closeShopTopBtn">X</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° MECH FORGE ‚ö°</h2>
                        <p style="color:#ffddff">Available Shards: <span id="shopShards">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>‚ö° Aces of the Void ‚ö°</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioHeartbeat" src="heartbeat.mp3" preload="auto"></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">‚ö° MECH FORGE</button>
        <button id="menuBtn" class="fixed-btn" type="button">üèÜ TOP PILOTS</button>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://ignored-insight-easter-scholars.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => {
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height),
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    const pointFromEvent = (e) => {
        const r = cvs.getBoundingClientRect();
        let touch = e;
        if (e.changedTouches && e.changedTouches.length > 0) {
            touch = e.changedTouches[0];
        } else if (e.touches && e.touches.length > 0) {
            touch = e.touches[0];
        }
        const cx = touch.clientX;
        const cy = touch.clientY;
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
    };


    // --- NEW FLAME PARTICLE CLASS ---
    class FlameParticle {
        constructor(x, y) {
            this.x = x + (Math.random() - 0.5) * 8;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 20;
            this.vy = -Math.random() * 80 - 40;
            this.maxLife = 10;
            this.life = this.maxLife * (0.7 + Math.random() * 0.3);
            this.size = Math.random() * 12 + 6;
            this.heat = Math.random();
            this.wobble = Math.random() * Math.PI * 2;
            this.wobbleSpeed = Math.random() * 2 + 1;
        }

        update(dt) {
            this.life -= dt;
            if (this.life <= 0) return false;
            this.y += this.vy * dt;
            this.x += this.vx * dt;
            this.vy -= 100 * dt;
            this.wobble += this.wobbleSpeed * dt;
            this.x += Math.sin(this.wobble) * 15 * dt;
            this.size *= 1 + (0.1 * dt);
            return true;
        }

        draw() {
            if (this.life <= 0) return;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const lifeRatio = this.life / this.maxLife;
            const layers = [
                { size: this.size * 2.5, alpha: lifeRatio * 0.15 },
                { size: this.size * 1.5, alpha: lifeRatio * 0.3 },
                { size: this.size, alpha: lifeRatio * 0.8 }
            ];
            layers.forEach(layer => {
                ctx.globalAlpha = layer.alpha;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, layer.size);
                if (this.heat > 0.6) {
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.2, 'rgba(200, 220, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                } else if (this.heat > 0.3) {
                    gradient.addColorStop(0, 'rgba(255, 240, 180, 1)');
                    gradient.addColorStop(0.3, 'rgba(255, 180, 50, 0.8)');
                    gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(200, 50, 0, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(255, 150, 50, 1)');
                    gradient.addColorStop(0.4, 'rgba(255, 80, 0, 0.6)');
                    gradient.addColorStop(0.7, 'rgba(200, 30, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                }
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, layer.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }
    }


    cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
    cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
   
    // --- AUDIO ---
    const bgm = q('bgmAudio');
    const sounds = {
        explosion: q('audioExplosion'),
        horn: q('audioHorn'),
        hit: q('audioHit'),
        trap: q('audioTrap'),
        dogs: q('audioDogs'),
        heartbeat: q('audioHeartbeat') // <-- ADD THIS LINE
    };
    let lastExplosionSoundTime = 0;
    let lastBossHitSoundTime = 0;
   
    function playSound(name) {
        const audio = sounds[name];
        if (!audio) return;
        const now = performance.now();
        if (name === 'explosion') {
            if (now - lastExplosionSoundTime < 50) return;
            lastExplosionSoundTime = now;
        }
        if (name === 'hit') {
            if (now - lastBossHitSoundTime < 100) return;
            lastBossHitSoundTime = now;
        }
        audio.currentTime = 0;
        audio.play().catch(e => {});
    }


    // --- GAME STATE & DATA ---
    const player_initial_state = {
        x: W / 2, y: H * 0.8, r: 14, hp: 100, hpMax: 100, fireT: 0, speed: 380, dmgMult: 1, fireRate: 0.18,
        vampirism: 0, shield: 0, shieldMax: 0, multishot: 1, isInvincible: false, piercing: 0, explosive: false,
        hasShieldBubble: false, powerupTimers: {},
        upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0, launcher: 0, lazarus_beam: 0, gravity_well: 0 },
        grenades: 0, hasVoidBeam: false, voidBeamCooldown: 0,
        hasLazarusBeam: false, lazarusBeamCooldown: 0,
        hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 0, vampirismLevel: 0, flamethrowerLevel: 0,
        luckBoost: 0, magnetRadius: 0, hasIceman: false, critChance: 0.02, critDamage: 2,
        pilotGenome: null, missileVolley: 2,
        hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
        rearMultishot: 0, addFrontNext: true,
        flameWallCooldown: 0,
        flameWallActiveT: 0,
        beefChargeState: 'ready', beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 1, beefMaxCharges: 1,
        hasChainLightning: false, chainLightningCooldown: 0,
        subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false
    };
   
    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        isDamageOff: false,          // <-- ADD THIS
        savedPlayerState: null,      // <-- AND THIS
        world: { 
            wave: 1, 
            score: 0, 
            shards: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null, // <-- AND THIS
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            isLowHealth: false // <-- ADD THIS LINE
        },
        player: { ...player_initial_state },
        boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], missiles: [], lasers: [], mines: [], activeEffects: [],
        flameParticles: [],
        lightningBolts: [],
        iceman: null,
        _startTs: performance.now(),
        cheatInvincibilityCooldown: 0,
        cheatDogHealCooldown: 0,
        heartbeatT: 0, // <-- ADD THIS LINE
        cheatsUsed: false
    };

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', icon: 'üí•', desc: '+7% damage', apply: () => { store.player.dmgMult *= 1.07; } },
        { id: 'fire', name: 'OVERCLOCK', icon: 'üî•', desc: '+7% fire rate', apply: () => { store.player.fireRate *= 0.70; } },
        { id: 'multi', name: 'SCATTER PROTOCOL', icon: '‚òÑÔ∏è', desc: '+1 projectile', apply: () => {
            const p = store.player;
            if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
        }},
        { id: 'shield', name: 'VOID SHIELD', icon: 'üõ°Ô∏è', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'flamethrower', name: 'LAVA CHUNKS', icon: 'üåã', desc: 'Spews chunks of molten rock in a cone.', apply: () => { store.player.flamethrowerLevel++; } }
    ];
   
    const SHOP_UPGRADES = {
        'repair': { name: "NANO REPAIR", icon: 'üîß', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'vampirism': {
            name: "VAMPIRIC ROUNDS", icon: 'ü©∏', isPremium: true, max: 4, category: 'utility',
            apply: () => {
                const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                if (store.world.shards >= cost && p.vampirismLevel < 4) { store.world.shards -= cost; p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
            },
            desc: () => {
                const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
            }
        },
        'hp': { name: "MAX HP", icon: '‚ù§Ô∏è', baseCost: 20, scale: 1.4, maxLevel: 10, category: 'health', effect: () => { store.player.hpMax += 10; store.player.hp += 10; }, desc: level => `+10 Max HP (Lvl ${level + 1})` },
        'nano_save': { name: "NANO SAVE", icon: 'üíæ', cost: 25, isPremium: true, max: 3, category: 'utility', apply: () => { if (store.player.nanoSaves < 3) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Auto-heals on low HP. Charges: ${store.player.nanoSaves}/3` },
        'luck_boost': { name: "LUCK BOOST", icon: 'üçÄ', baseCost: 25, scale: 2, maxLevel: 5, category: 'utility', effect: (level) => { store.player.luckBoost = (store.player.luckBoost || 0) + (0.15 / Math.pow(2, level)); }, desc: level => `+${(0.15 / Math.pow(2, level) * 100).toFixed(1)}% drop chance (Lvl ${level + 1})` },
        'dmg': { name: "DAMAGE", icon: 'üí™', baseCost: 25, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.07, desc: level => `+7% Damage (Lvl ${level + 1})` },
        'crit_chance': { name: "SHINOBI REFLEXES", icon: 'ü•∑', baseCost: 20, increment: 12, maxLevel: 10, category: 'attack', effect: () => { store.player.critChance *= 1.5; store.player.critDamage *= 1.5; }, desc: level => `+50% Crit Chance & Dmg (Lvl ${level + 1})` },
        'speed': { name: "SPEED", icon: 'üöÄ', baseCost: 30, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
        'grenade': { name: "NOVA GRENADE", icon: 'üí•üí£üí•', cost: 35, isPremium: true, max: 3, category: 'attack', apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'max_shield': { name: "MAX SHIELD", icon: 'üõ°Ô∏è', baseCost: 40, scale: 1.8, maxLevel: 5, category: 'health', effect: () => { store.player.shieldMax += 25; store.player.shield += 25; }, desc: level => `+25 Max Shield (Lvl ${level + 1})` },
        'mine_wall': { name: "MINE WALL", icon: 'üí£', cost: 40, isPremium: true, max: 2, category: 'attack', apply: () => { const activeWalls = store.mines.filter(m => m.isWallMine).length > 0; if(!activeWalls) { deployMineWall(); return true; } return false; }, desc: () => `Deploy a wall of mines.` },
        'rear_guard': { name: 'AFT FLANKSHIELD', icon: 'üõ°Ô∏è‚ú®', baseCost: 65, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
        'launcher': {
                name: 'FRAG LAUNCHER',
                icon: 'üí•',
                baseCost: 50,
                scale: 2,
                maxLevel: 3,
                category: 'attack',
                effect: () => {
                    store.player.hasLauncher = true;
                },
                desc: level => {
                    if (level === 0) return `Unlocks launcher (2 projectiles).`;
                    if (level === 1) return `Add 2 projectiles (4 total).`;
                    if (level === 2) return `Add 2 more projectiles (6 total).`;
                    return "Max projectiles reached.";
                }
            },
        'iceman': { name: "THE ICEMAN", icon: '‚ùÑÔ∏è', cost: 59, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.hasIceman) { store.player.hasIceman = true; store.iceman = { x: store.player.x, y: store.player.y + 50, t: 0 }; return true; } return false; }, desc: () => `A clone mirrors your attacks.` },
        'lazarus_beam': { name: "LORD LAZARUS", icon: '‚ò¢Ô∏è‚òÑÔ∏è‚ò¢Ô∏è', baseCost: 100, scale: 3, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Lazarus smites foes twice as often.'; if (level === 1) return 'Lazarus fires two beams at once.'; return 'Max Level'; }},
        'magnet_pull': { name: "GRAV-PULSE", icon: 'üß≤', cost: 45, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
        'gravity_well': { name: "GRAVITY WELL", icon: 'üï≥Ô∏è', baseCost: 150, scale: 2, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; }}, desc: level => { if (level === 0) return 'Unleash a singularity that traps and crushes foes.'; if (level === 1) return 'Summon a second, smaller singularity.'; return 'Max Level'; }},
        'ghost_hounds': { name: "GHOST HOUNDS", icon: 'üëªüê∫', baseCost: 75, scale: 2, maxLevel: 2, category: 'attack', effect: () => { if (!store.player.hasHounds) { store.player.hasHounds = true; store.hounds = [createHound(-1), createHound(1)]; } else { store.hounds.push(createHound(-2)); store.hounds.push(createHound(2)); } playSound('dogs'); }, desc: level => { if (level === 0) return `Unlocks 2 spectral hounds.`; if (level === 1) return `Add 2 more hounds.`; return "Max hounds reached."; } }
    };
   
    const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: '‚¨ÜÔ∏è', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'üöÅ', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'üõ°Ô∏è', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: '‚ù§Ô∏è', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'üöÄ', duration: 20, type: 'timed' }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) {
        if (store.world.powerupCooldown > 0) return;
        const p = store.player;
        const baseChance = 0.075;
        const wave = store.world.wave;
        const waveReductionFactor = 0.0025;
        let finalChance = Math.max(0.025, baseChance - (wave - 1) * waveReductionFactor);
        let types = Object.keys(POWERUP_TYPES);
        let bonusType = null;
        if (p.pilotGenome === 'beef') {
            if (Math.random() < 0.25) bonusType = 'shield';
            else if (Math.random() < 0.15) bonusType = 'repair';
        }
        if (p.pilotGenome === 'rocketman' && Math.random() < 0.2) {
            finalChance *= 1.5;
            bonusType = 'missile';
        }
        const roll = Math.random();
        if (roll > finalChance && !bonusType) return;
        let typeKey;
        if (bonusType && (roll <= finalChance || Math.random() < 0.5)) {
            typeKey = bonusType;
        } else {
            typeKey = types[Math.floor(Math.random() * types.length)];
        }
        store.powerups.push({ x, y, r: 12, type: typeKey });
        store.world.powerupCooldown = 5;
    }
   
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
        if (typeKey === 'missile') {
            if (p.pilotGenome === 'rocketman') { p.missileVolley = Math.min(5, p.missileVolley + 2); } else { p.missileVolley = 2; }
        }
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
            else {
                if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') {
                const p = store.player;
                if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                announce('SCATTER SHOT!');
            }
        }
        announce(powerup.name);
    }

    function initWave() {
        const isBossWave = store.world.wave % 5 === 0;
        if (isBossWave) {
            store.enemies = [];
            const bossHpScale = 1 + (store.world.wave / 5 - 1) * 1.5;
            store.boss = createBoss(bossHpScale);
            store.world.bossSpawnTime = performance.now();
            if (store.boss.name === 'TRAP KING') playSound('trap');
            else if (store.boss.name === 'CORE MALIGNUS') playSound('horn');
            announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
        } else {
            store.enemies = [];
            const spawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter'];
                if (store.world.wave > 3) types.push('phantom');
                if (store.world.wave > 5) types.push('mech');
                if (store.world.wave > 7) types.push('angler');
                if (store.world.wave > 9) types.push('manta');
                store.enemies.push(spawnEnemy(types[Math.floor(Math.random() * types.length)]));
            }
            store.world.waveStartTime = performance.now();
            announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
        }
    }
   
    function createBoss(scale) {
        const bossCycle = Math.floor((store.world.wave - 5) / 5) % 5;
        const types = [
            { name: 'DARTH VADER', baseHp: 1300, r: 55, behavior: 'sentinel', color: '#eeff1b' },
            { name: 'TRAP KING', baseHp: 1500, r: 50, behavior: 'hex', color: '#66aaff'},
            { name: 'CORE MALIGNUS', baseHp: 1800, r: 60, behavior: 'malignus', color: '#2E8B57' },
            { name: 'GEOMETRON', baseHp: 2200, r: 65, behavior: 'construct', color: '#e03434', phase: 1 },
            { name: 'Francesca', baseHp: 2500, r: 70, behavior: 'avian', color: '#4b0082' }
        ];
        const type = types[bossCycle];
        let hp = type.baseHp * scale * store.world.bossHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks > 0 ? 0.4 + (store.world.collarStacks - 1) * 0.1 : 0);
        hp *= collarBonus;
        return { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, isEnraged: false, attackPhase: 0, phaseTimer: 0 };
    }

    function spawnEnemy(type = 'drone') {
        const cfgs = {
            drone: { r: 10, v: 80, vx: 0, hp: 25, color: '#C0C0C0', xp: 5, score: 50, shards: 1, fireRateChance: 0.004 },
            hunter: { r: 20, v: 100, vx: 0, hp: 20, color: '#DC143C', xp: 8, score: 80, shards: 1, fireRateChance: 0.005 },
            trap_king_add: { r: 6, v: 90, vx: 0, hp: 10, color: '#ffc83d', damage: 5, xp: 2, score: 10, shards: 1 },
            phantom: { r: 14, v: 90, vx: 0, hp: 40, color: '#FFFFFF', xp: 10, score: 100, shards: 2, fireRateChance: 0.006, fireCooldown: 1.5 },
            mech: { r: 18, v: 40, vx: 0, hp: 90, color: '#FF8500', xp: 15, score: 150, shards: 3, fireRateChance: 0.007, attackPhase: 0 },
            construct_shard: { r: 10, v: 120, vx: 0, hp: 15, color: '#e03434', xp: 3, score: 30, shards: 1 },
            avian_hatchling: { r: 8, v: 150, vx: 0, hp: 20, color: '#9370DB', xp: 4, score: 40, shards: 1 },
            angler: { r: 22, v: 30, vx: 0, hp: 120, color: '#00008b', xp: 18, score: 180, shards: 4, fireRateChance: 0.008 },
            manta: { r: 26, v: 50, vx: 0, hp: 150, color: '#53B6FF', xp: 22, score: 220, shards: 5, fireRateChance: 0.009 }
        };
        let c = { ...cfgs[type] }; const wave = store.world.wave;
        c.hp *= Math.pow(1.075, wave) * store.world.enemyHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks > 0 ? 0.4 + (store.world.collarStacks - 1) * 0.1 : 0);
        c.hp *= collarBonus;
        const e = { ...c, type, x: 20 + Math.random() * (W - 40), y: -50 - Math.random() * 250, hpMax: c.hp, phase: type === 'phantom', t: 0, fireT: (c.fireCooldown || 0), isBursting: false, burstTimer: 0, stunTimer: 0, knockback: null };
        if (e.type === 'manta') { e.startX = e.x; e.amplitude = 150 + Math.random() * 100; e.frequency = 0.5 + Math.random() * 0.5; }
        return e;
    }

    function stepPlayer(dt) {
        const p = store.player;
        if (p.pilotGenome === 'beef' && p.beefChargeState !== 'ready') {
            p.beefChargeT += dt;
            const chargeDuration = 0.25; const returnDuration = 0.35;
            if (p.beefChargeState === 'charging') {
                const progress = Math.min(p.beefChargeT / chargeDuration, 1);
                p.x = p.beefChargeOrigin.x + (p.beefChargeTarget.x - p.beefChargeOrigin.x) * progress;
                p.y = p.beefChargeOrigin.y + (p.beefChargeTarget.y - p.beefChargeOrigin.y) * progress;
                if (progress >= 1) { p.beefChargeState = 'returning'; p.beefChargeT = 0; }
            } else if (p.beefChargeState === 'returning') {
                const progress = Math.min(p.beefChargeT / returnDuration, 1);
                p.x = p.beefChargeTarget.x + (p.beefChargeOrigin.x - p.beefChargeTarget.x) * progress;
                p.y = p.beefChargeTarget.y + (p.beefChargeOrigin.y - p.beefChargeTarget.y) * progress;
                if (progress >= 1) { p.x = p.beefChargeOrigin.x; p.y = p.beefChargeOrigin.y; p.beefChargeState = 'ready'; p.isInvincible = false; }
            }
        } else {
            const vx = mouse.x - p.x, vy = mouse.y - p.y;
            p.x += (vx * p.speed * dt * 0.005); p.y += (vy * p.speed * dt * 0.005);
            p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
        }
        if (p.pilotGenome === 'beef') {
            if (p.beefChargeCooldown > 0) { p.beefChargeCooldown -= dt; } else if (p.beefCharges < p.beefMaxCharges) { p.beefChargeCooldown = 8; p.beefCharges++; }
            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                const chargeRadius = 120; let closestEnemy = null; let closestDistSq = chargeRadius * chargeRadius;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.stunTimer > 0) return;
                    const dx = e.x - p.x; const dy = e.y - p.y; const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) { closestDistSq = distSq; closestEnemy = e; }
                });
                if (closestEnemy) {
                    p.beefCharges--; p.beefChargeCooldown = 8; p.beefChargeState = 'charging'; p.beefChargeOrigin = { x: p.x, y: p.y }; p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y }; p.beefChargeT = 0; p.isInvincible = true;
                    store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                    const impactRadius = p.subclass === 'juggernaut' ? 120 : 80;
                    if (p.subclass === 'juggernaut') { explode(closestEnemy.x, closestEnemy.y, false, true); }
                    potentialTargets.forEach(e => {
                        if (e.dead) return;
                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                        if (distSq < impactRadius * impactRadius) {
                            e.hp -= 80 * p.dmgMult; e.stunTimer = 2.5;
                            const knockbackForce = 250; const angle = Math.atan2(e.y - p.y, e.x - p.x);
                            e.knockback = { vx: Math.cos(angle) * knockbackForce, vy: Math.sin(angle) * knockbackForce, duration: 0.3 };
                        }
                    });
                }
            }
        } else if (p.pilotGenome === 'rocketman') {
            if (p.flameWallCooldown > 0) p.flameWallCooldown -= dt;
            if (p.flameWallActiveT > 0) p.flameWallActiveT -= dt;
            if (p.flameWallCooldown <= 0) { p.flameWallActiveT = 0.5; p.flameWallCooldown = 10; }
            if (p.flameWallActiveT > 0) { for (let i = 0; i < 5; i++) { store.flameParticles.push(new FlameParticle(p.x, p.y + 10)); } }
        } else if (p.pilotGenome === 'wizard') {
            if (p.hasChainLightning) {
                p.chainLightningCooldown -= dt;
                if (p.chainLightningCooldown <= 0) { fireChainLightning(); p.chainLightningCooldown = 1.5; }
            }
        }
        if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
        p.fireT -= dt;
        if (p.fireT <= 0) { firePlayer(); p.fireT = p.fireRate; }
        if (p.powerupTimers['missile']) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });
                if (closest) {
                    const isRocketman = p.pilotGenome === 'rocketman';
                    const missileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                    const missileProps = { r: 4, target: closest, speed: 400, life: 0, dmg: missileDmg, hits: 0 };

                    if (p.subclass === 'demolitionist') {
                        const spreadAngle = 10; const initialSpeed = 300;
                        for (let i = 0; i < p.missileVolley; i++) {
                            const angleOffset = (i - (p.missileVolley - 1) / 2) * spreadAngle * (Math.PI / 180);
                            store.missiles.push({ ...missileProps, x: p.x, y: p.y, vx: Math.sin(angleOffset) * initialSpeed, vy: -Math.cos(angleOffset) * initialSpeed, turnRate: 4, pierce: 0, cluster: true });
                        }
                        if (p.hasIceman && store.iceman) {
                             for (let i = 0; i < p.missileVolley; i++) {
                                const angleOffset = (i - (p.missileVolley - 1) / 2) * spreadAngle * (Math.PI / 180);
                                store.missiles.push({ ...missileProps, x: store.iceman.x, y: store.iceman.y, vx: Math.sin(angleOffset) * initialSpeed, vy: -Math.cos(angleOffset) * initialSpeed, dmg: missileDmg * 0.35, isIceman: true, turnRate: 4, pierce: 0, cluster: true });
                            }
                        }
                    } else {
                        for (let i = 0; i < p.missileVolley; i++) {
                            const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                            store.missiles.push({ ...missileProps, x: p.x + offsetX, y: p.y, vx: 0, vy: -300, turnRate: 5, pierce: p.missilePierce, cluster: p.missileCluster });
                        }
                        if (p.hasIceman && store.iceman) {
                            for (let i = 0; i < p.missileVolley; i++) {
                                const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                                store.missiles.push({ ...missileProps, x: store.iceman.x + offsetX, y: store.iceman.y, vx: 0, vy: -300, dmg: missileDmg * 0.35, isIceman: true, turnRate: 5, pierce: p.missilePierce, cluster: p.missileCluster });
                            }
                        }
                    }
                }
            }
        }
        if (p.shieldMax > 0 && p.shield < p.shieldMax) p.shield = Math.min(p.shieldMax, p.shield + 2 * dt);
        for (const key in p.powerupTimers) { p.powerupTimers[key].remaining -= dt; if (p.powerupTimers[key].remaining <= 0) { if (key === 'drones') store.drones = []; delete p.powerupTimers[key]; } }
        if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
        if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { activateGravityWell(); p.voidBeamCooldown = 30; } }
        if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { activateLazarus(); p.lazarusBeamCooldown = 30 / (p.upgradeLevels.lazarus_beam > 0 ? 2 : 1) ; } }
        if (store.cheatInvincibilityCooldown > 0) store.cheatInvincibilityCooldown -= dt;
        if (store.cheatDogHealCooldown > 0) store.cheatDogHealCooldown -= dt;
        if (p.x < 50 && p.y < 50 && store.cheatInvincibilityCooldown <= 0) {
            store.cheatsUsed = true; p.isInvincible = true; p.cheatMultishotBonus = 2; announce('TEST: INVINCIBILITY ACTIVE');
            setTimeout(() => { p.isInvincible = false; p.cheatMultishotBonus = 0; announce('TEST: INVINCIBILITY ENDS'); store.cheatInvincibilityCooldown = 10; }, 15000);
            store.cheatInvincibilityCooldown = 15 + 10;
        }
        if (p.x > W - 50 && p.y < 50 && store.cheatDogHealCooldown <= 0) {
            store.cheatsUsed = true; p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.20);
            if (!p.hasHounds) { p.hasHounds = true; }
            let houndsToAdd = Math.min(2, 4 - store.hounds.length);
            if (houndsToAdd > 0) {
                const existingSides = new Set(store.hounds.map(h => h.side)); const potentialSides = [-1, 1, -2, 2];
                for (const side of potentialSides) { if (houndsToAdd > 0 && !existingSides.has(side)) { store.hounds.push(createHound(side)); houndsToAdd--; } }
            }
            store.cheatDogHealCooldown = 10; announce('TEST: HEAL & HOUNDS');
        }
    }
    function stepPowerups(dt) {
        const p = store.player;
        store.powerups.forEach(powerup => {
            // Powerup magnet logic
            if (p.magnetRadius > 0) {
                const dx = p.x - powerup.x;
                const dy = p.y - powerup.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < p.magnetRadius * p.magnetRadius) {
                    const dist = Math.sqrt(distSq);
                    const pullSpeed = 350;
                    powerup.x += (dx / dist) * pullSpeed * dt;
                    powerup.y += (dy / dist) * pullSpeed * dt;
                }
            }

            // Collision check to pick up the powerup
            if (collide(p, powerup)) {
                powerup.dead = true;
                applyPowerup(powerup.type);
            }
        });
    }

    function detonateClusterRocket(m) {
        if (m.dead) return;
        m.dead = true;
        playSound('explosion');
        const explosionRadius = 80;
        const chainRadius = 90;
        const microExplosionCount = 5;
        // Damage is 1/5th (0.2) of the missile's damage.
        const aoeDmg = m.dmg * 0.2;
        for (let i = 0; i < microExplosionCount; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.random() * explosionRadius * 0.7;
            const ex = m.x + Math.cos(angle) * dist;
            const ey = m.y + Math.sin(angle) * dist;
            store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
        }
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(e => {
            if (!e.dead) {
                const distSq = (e.x - m.x)**2 + (e.y - m.y)**2;
                if (distSq < explosionRadius**2) {
                    e.hp -= aoeDmg;
                    // Prevents cluster explosions from being lethal.
                    e.hp = Math.max(1, e.hp);
                }
            }
        });
        store.missiles.forEach(other_m => {
            if (other_m !== m && !other_m.dead && other_m.cluster) {
                const distSq = (other_m.x - m.x)**2 + (other_m.y - m.y)**2;
                if (distSq < chainRadius**2) {
                    other_m.chainDetonate = true;
                }
            }
        });
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            if (m.chainDetonate && !m.dead) {
                detonateClusterRocket(m);
                return;
            }
            m.life += dt; if (m.life > 6) { m.dead = true; return; }
            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }
            m.x += m.vx * dt; m.y += m.vy * dt;
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            if (m.cluster) {
                const proxRadiusSq = 50 * 50;
                for (const e of targets) {
                    if (!e.dead && ((m.x - e.x)**2 + (m.y - e.y)**2 < proxRadiusSq)) {
                        detonateClusterRocket(m);
                        return;
                    }
                }
            }
            for (const e of targets) {
                if (!e.dead && collide(m, e)) {
                    m.hits = (m.hits || 0) + 1;
                    if (m.cluster) {
                        detonateClusterRocket(m);
                    } else {
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        e.hp -= dmg;
                        explode(m.x, m.y, false, true);
                        if (store.player.subclass === 'railgunner' && m.pierce > 0) {
                            m.pierce--;
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else { m.dead = true; }
                        } else if (m.pierce > 0) {
                            m.pierce--;
                        } else {
                            m.dead = true;
                        }
                    }
                    if (m.dead) break;
                }
            }
        });
    }

    function stepLightning(dt) {
        store.lightningBolts.forEach(bolt => {
            bolt.life -= dt;
            if (bolt.life <= 0) { bolt.dead = true; }
        });
    }

    function stepLasers(dt) {
        store.lasers.forEach(laser => {
            laser.life -= dt;
            if (laser.life <= 0) { laser.dead = true; return; }
            laser.prevX = laser.x; laser.prevY = laser.y;
            laser.x += laser.vx * dt; laser.y += laser.vy * dt;
            if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                const speed = Math.sqrt(laser.vx**2 + laser.vy**2);
                let newAngle;
                if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                else { newAngle = Math.PI + Math.random() * Math.PI; }
                laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                laser.hitEnemies.clear();
            }
            store.enemies.forEach(e => {
                if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) { e.hp -= 1000 * store.player.dmgMult; laser.hitEnemies.add(e); }
            });
            if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) { store.boss.hp -= 500 * store.player.dmgMult; laser.hitEnemies.add(store.boss); }
        });
    }

    function stepMines(dt) {
        store.mines.forEach(mine => {
            if (mine.dead) return;
            mine.fuse -= dt;
            let detonate = mine.fuse <= 0;
            if (!detonate) {
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                for(const target of targets) { if(!target.dead && collide(mine, target)) { detonate = true; break; } }
            }
            if(detonate) { mine.dead = true; explodeMine(mine); }
        });
    }
   
    function stepFlameParticles(dt) {
        for (let i = store.flameParticles.length - 1; i >= 0; i--) {
            const p = store.flameParticles[i];
            if (!p.update(dt)) { store.flameParticles.splice(i, 1); }
        }
    }




    function stepWorld(dt) {
        // --- 1. UPDATE CORE ENTITIES ---
        stepPlayer(dt);
        if (store.boss) {
            stepBoss(dt);
        }

        // --- 2. UPDATE PROJECTILES & PICKUPS ---
        stepPowerups(dt);
        stepHounds(dt);
        stepMissiles(dt);
        stepLasers(dt);
        stepMines(dt);
        stepFlameParticles(dt);
        stepLightning(dt);
        updateVoidStepSystems(store.enemies);

        // --- 3. UPDATE ACTIVE EFFECTS & COOLDOWNS ---
        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        if (store.world.powerupCooldown > 0) {
            store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2));
        }

        // --- 4. HANDLE ENEMY BULLET LOGIC & COLLISIONS ---
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        store.eBullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.gravity) { b.vy += b.gravity * dt; }
            if (b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            if (collide(b, store.player)) {
                const p = store.player;
                if (p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                    p.rearGuardReady = false;
                    p.rearGuardCooldown = 8;
                    b.dead = true;
                    store.activeEffects.push(createEffect("rearGuardBlock"));
                } else {
                    takeDamage(b.dmg || 10);
                    b.dead = true;
                }
            }
        });

        // --- 5. HANDLE ENEMY & PLAYER BULLET LOGIC & COLLISIONS ---
        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) {
                    store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                    mine.dead = true;
                }
                if (collide(mine, store.player)) {
                    takeDamage(50 * dmgScale);
                    mine.dead = true;
                }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }

        store.enemies.forEach(e => {
            // Handle movement and status effects
            if (e.knockback) {
                e.x += e.knockback.vx * dt;
                e.y += e.knockback.vy * dt;
                e.knockback.duration -= dt;
                if (e.knockback.duration <= 0) e.knockback = null;
            } else if (e.stunTimer && e.stunTimer > 0) {
                e.stunTimer -= dt;
            } else {
                let speedMultiplier = (e.slowTimer > 0) ? 0.3 : 1.0;
                if (e.slowTimer > 0) e.slowTimer -= dt;

                // Different movement patterns
                if (e.type === 'construct_shard' || e.type === 'avian_hatchling') {
                    const dx = store.player.x - e.x, dy = store.player.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        e.x += (dx / dist) * e.v * speedMultiplier * dt;
                        e.y += (dy / dist) * e.v * speedMultiplier * dt;
                    }
                } else if (e.type === 'angler') {
                    const dx = store.player.x - e.x;
                    if (Math.abs(dx) > 10) e.x += Math.sign(dx) * 30 * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'manta') {
                    e.t += dt;
                    e.x = e.startX + e.amplitude * Math.sin(e.t * e.frequency);
                    e.y += e.v * speedMultiplier * dt;
                } else if (!e.isOrbiter) {
                    e.x += (e.vx || 0) * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else { // Orbiter logic
                    if (store.boss) { e.orbitCenter.x = store.boss.x; e.orbitCenter.y = store.boss.y; }
                    e.orbitAngle += e.orbitSpeed * speedMultiplier * dt;
                    e.x = e.orbitCenter.x + e.orbitRadius * Math.cos(e.orbitAngle);
                    e.y = e.orbitCenter.y + e.orbitRadius * Math.sin(e.orbitAngle);
                }
                if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
            }

            // Handle enemy firing
            if (e.fireT > 0) e.fireT -= dt;
            if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                switch (e.type) {
                    case 'hunter': { const a=Math.atan2(store.player.y-e.y,store.player.x-e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:3,col:e.color,dmg:10*dmgScale}); e.fireT=1; break; }
                    case 'phantom': { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:180,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=e.fireCooldown; break; }
                    case 'mech': {
                        e.attackPhase = (e.attackPhase || 0) + 1;
                        if (e.attackPhase % 2 === 1) {
                            const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                            const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                            store.eBullets.push({ x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                            const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                            store.eBullets.push({ x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                        } else {
                            const dx = store.player.x - e.x, dist = Math.sqrt(dx*dx + (store.player.y - e.y)**2), timeToTarget = Math.max(0.5, dist / 250);
                            const vx = dx / timeToTarget, gravity = 350, vy = (store.player.y - e.y - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;
                            store.eBullets.push({ x: e.x, y: e.y, vx: vx, vy: vy, r: 6, col: '#ff6347', dmg: 18 * dmgScale, gravity: gravity });
                        }
                        e.fireT = 2; break;
                    }
                    case 'angler': { const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,r:4,col:e.color,dmg:15*dmgScale, life: 5}); e.fireT = 2.5; break; }
                    case 'manta': { for(let i=-1; i<=1; i++) { const angle = (90 + i * 30) * Math.PI/180; store.eBullets.push({x:e.x, y:e.y, vx:Math.cos(angle)*150, vy:Math.sin(angle)*150, r:3, col:e.color, dmg:12*dmgScale}); } e.fireT = 2.8; break; }
                    default: { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:150,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=.5; }
                }
            }

            // Off-screen and collision checks
            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) {
                takeDamage(15 * dmgScale);
                store.world.shards += e.shards;
                e.dead = true;
            }
        });

        store.bullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.isSwirl) {
                b.life = (b.life || 0) + dt;
                b.x += Math.sin(b.life * 15) * 150 * dt;
            }
            if (b.isFlame) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
                b.particleSpawnT -= dt;
                if (b.particleSpawnT <= 0) {
                    b.particleSpawnT = b.isLavaChunk ? 0.04 : 0.02;
                    const life = 0.3 + Math.random() * 0.3, angle = Math.random() * 2 * Math.PI, speed = b.isLavaChunk ? 10 + Math.random() * 15 : 20 + Math.random() * 20;
                    b.particles.push({ x: 0, y: 0, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: life, maxLife: life, r: 1 + Math.random() * (b.isLavaChunk ? 1.5 : 2) });
                }
                b.particles = b.particles.filter(p => {
                    p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt;
                    return p.life > 0;
                });
            } else if (b.isLevelUpPulse) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
            }

            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
            for (const e of targets) {
                if (b.dead || e.dead) continue;
                if (collide(b, e)) {
                    if (b.isFlame) e.slowTimer = 1.0;
                    
                    let dmg = b.dmg || 20;
                    if (e === store.boss && b.isDrone) dmg *= 0.4;
                    
                    if (Math.random() < store.player.critChance) {
                        dmg *= store.player.critDamage;
                        store.activeEffects.push(createEffect('critText', e.x, e.y));
                        if (Math.random() < 0.05) spawnPowerup(e.x, e.y);
                    }
                    
                    if (e === store.boss) playSound('hit');
                    e.hp -= dmg;

                    if (e.hp <= 0) {
                        e.dead = true;
                        if (e === store.boss) {
                            handleBossDefeat();
                        } else {
                            store.world.score += e.score;
                            store.world.shards += e.shards;
                            store.world.xp += e.xp;
                            store.world.kills++;
                            spawnPowerup(e.x, e.y);
                            if (store.player.vampirism > 0) store.player.hp = Math.min(store.player.hpMax, store.player.hp + dmg * store.player.vampirism);
                            explode(e.x, e.y);
                        }
                    }

                    if (b.explosive) explode(b.x, b.y, false, true);
                    if (!b.pierce) b.dead = true;
                }
            }
        });

        // --- 6. HEARTBEAT & GAME STATE CHECKS ---
        const p = store.player;
        const healthRatio = p.hp / p.hpMax;
        const lowHealthThreshold = 0.35;

        if (healthRatio < lowHealthThreshold) {
            if (!store.world.isLowHealth) {
                store.world.isLowHealth = true;
                store.heartbeatT = 5.0;
                playSound('heartbeat');
                store.activeEffects.push(createEffect("heartbeatPulse"));
            } else {
                if (store.heartbeatT > 0) {
                    store.heartbeatT -= dt;
                } else {
                    store.heartbeatT = 5.0;
                    playSound('heartbeat');
                    store.activeEffects.push(createEffect("heartbeatPulse"));
                }
            }
        } else if (store.world.isLowHealth) {
            store.world.isLowHealth = false;
        }

        ['bullets', 'eBullets', 'enemies', 'powerups', 'mines', 'missiles', 'lasers', 'flameParticles', 'lightningBolts'].forEach(key => store[key] = store[key].filter(i => !i.dead));
        store.activeEffects = store.activeEffects.filter(e => e.isActive !== false);

        if (!store.boss && store.enemies.length === 0) {
            if (store.world.waveStartTime > 0) {
                const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;
                if (waveClearTime < 5 && store.world.wave > 1) {
                    store.world.enemyDensityBonus *= 1.1;
                    store.world.enemyHealthBonus *= 1.05;
                    store.world.xpMultiplier *= 1.05;
                    store.world.collarStacks++;
                    announce("SWARM INTENSITY RISING!");
                }
            }
            store.world.wave++;
            const hpBonus = 3;
            store.player.hpMax += hpBonus;
            store.player.hp += hpBonus;
            initWave();
        }

        let xpNeeded = Math.floor(store.world.level * 100 * store.world.xpMultiplier * (store.world.level >= 8 ? 1.3 : store.world.level >= 4 ? 1.1 : 1) * (store.world.wave > 10 ? 1.3 : 1));
        if (store.world.xp >= xpNeeded) {
            store.world.xp -= xpNeeded;
            store.world.level++;
            levelUp();
        }

        if (store.player.hp <= 0) {
            handleGameOver();
        }
    }





    function handleBossDefeat() {
        const fightDuration = (performance.now() - store.world.bossSpawnTime) / 1000;
        if (store.boss.name === 'TRAP KING' && store.player.pilotGenome === null) {
            store.player.pilotGenome = 'pending';
            setTimeout(showPilotSelect, 1000);
        }
        if (store.world.bossesAtPilotSelection !== null && (store.world.bosses - store.world.bossesAtPilotSelection) === 2 && !store.player.subclass) {
            setTimeout(showSubclassSelect, 1500);
        }
        store.world.score += 2000; store.world.shards += 25; store.world.xp += 100; store.world.bosses++;
        const bossX = store.boss.x;
        const bossY = store.boss.y;
        store.boss = null;
        announce('‚ö° GUARDIAN DEFEATED ‚ö°');
        explode(bossX, bossY, true);

        let healthBonusMultiplier = 1.0, announcedAdaptation = false;
        if (fightDuration <= 4) {
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            store.world.collarStacks++;
        } else if (fightDuration > 10) {
            store.world.collarStacks = 0; store.world.consecutiveFastKills = 0; store.world.fastKillBonus = 0;
            healthBonusMultiplier = 1.0; announce("ADAPTATION RESET!");
        } else {
            announcedAdaptation = true; healthBonusMultiplier = 1.10;
            store.world.consecutiveFastKills = 0; store.world.fastKillBonus = 0;
            announce("GUARDIANS ADAPTING!");
        }
        store.world.bossHealthBonus *= healthBonusMultiplier;
        if (announcedAdaptation) {
            const enemyHealthBonus = healthBonusMultiplier > 1.1 ? 1.15 : 1.05;
            store.world.enemyHealthBonus *= enemyHealthBonus;
            store.world.enemyDensityBonus *= 1.10;
            setTimeout(() => announce("ENEMY SWARMS INTENSIFYING!"), 1000);
        }
        }
    function explode(x, y, isBoss = false, isSmall = false) {
        playSound('explosion');
        if (isBoss) for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
        if (isSmall) {
            const radius = 60;
            const dmg = 25 * store.player.dmgMult;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            targets.forEach(e => {
                if (!e.dead) {
                    const distSq = (e.x - x)**2 + (e.y - y)**2;
                    if (distSq < radius**2) {
                        e.hp -= dmg;
                    }
                }
            });
            store.activeEffects.push(createEffect("grenadeExplosion", x, y, radius));
        }
    }
   
    function levelUp() {
        announce(`LEVEL UP! ‚ö° CHOOSE YOUR AUGMENTATION!`);
        pauseGame();
       
        store.player.isInvincible = true;
        const speedBoost = store.player.speed * 0.75;
        const fireRateBoost = store.player.fireRate * 0.5;
        store.player.speed += speedBoost;
        store.player.fireRate -= fireRateBoost;

        const levelUpPulse = () => {
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 300;
                store.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 4, col: '#ffddff', dmg: 30 * p.dmgMult,
                    pierce: true, life: 1.5, isLevelUpPulse: true
                });
            }
        };

        levelUpPulse();
        setTimeout(levelUpPulse, 250);

        setTimeout(() => {
            store.player.isInvincible = false;
            store.player.speed -= speedBoost;
            store.player.fireRate += fireRateBoost;
        }, 3000);

        const panel = q('levelPanel'), grid = q('skillsGrid');
        const availableUpgrades = LEVEL_UPGRADES.filter(u => {
            if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
            return true;
        });

        for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; }
        const choices = availableUpgrades.slice(0, 3);
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        grid.querySelectorAll('.skill-card').forEach(c => c.addEventListener('click', () => {
            const id = c.dataset.id; const upgrade = LEVEL_UPGRADES.find(s => s.id === id);
            if (upgrade) upgrade.apply(); panel.classList.add('hide');
            resumeGame();
        })); panel.classList.remove('hide');
    }
   
    function handleGameOver() {
        if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score);
        announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide');
    }
   
    function resetGame() {
        store.player = JSON.parse(JSON.stringify(player_initial_state));
    
        store.world = { 
            wave: 1, 
            score: 0, 
            shards: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            consecutiveFastKills: 0, 
            fastKillBonus: 0 
        }; // <-- ERROR FIXED: Changed comma to semicolon
        
        store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = []; store.powerups = [];
        store.drones = []; store.hounds = []; store.missiles = []; store.lasers = []; store.mines = []; store.activeEffects = []; store.flameParticles = [];
        store.lightningBolts = [];
        store.iceman = null;
        store._startTs = performance.now(); store.isGameOver = false;
        store.cheatsUsed = false;
        store.cheatInvincibilityCooldown = 0;
        store.cheatDogHealCooldown = 0;
        shopItemOrder = [];
        q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide'); q('subclassPanel').classList.add('hide');
        ensureName();
    }

    // --- RENDER & DRAW FUNCTIONS ---
    const starCountA = 100, starCountB = 80;
    const starsA = Array.from({ length: starCountA }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.5, pulse: Math.random() * 10 }));
    const starsB = Array.from({ length: starCountB }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 2, pulse: Math.random() * 10 }));

    function render(dt) {
        ctx.fillStyle = '#050008'; ctx.fillRect(0, 0, W, H);
        const time = performance.now() / 1000;
        ctx.globalAlpha = 0.8; for (const s of starsA) { s.y += 30 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(255,0,255,${0.5 + 0.5 * Math.sin(time * 2 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, 2 * Math.PI); ctx.fill(); }
        ctx.globalAlpha = 0.6; for (const s of starsB) { s.y += 60 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(204,0,255,${0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, Math.max(0.1, s.r * (0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse))), 0, 2 * Math.PI); ctx.fill(); }
        ctx.globalAlpha = 1;

        // --- START: New logic for proximity effects ---
        
        // 1. Sort enemy bullets into "close" and "far" groups.
        const closeBullets = [];
        const farBullets = [];
        const proximityThreshold = 110; // Approx. 4 ship lengths (player radius is 14)
        const playerPos = store.player;

        store.eBullets.forEach(b => {
            const dx = b.x - playerPos.x;
            const dy = b.y - playerPos.y;
            // Use squared distance for efficiency (avoids square root)
            const distSq = dx * dx + dy * dy; 
            if (distSq < proximityThreshold * proximityThreshold) {
                // Store the calculated distance to use for the fade effect
                closeBullets.push({ bullet: b, dist: Math.sqrt(distSq) });
            } else {
                farBullets.push(b);
            }
        });
        
        // --- END: New logic ---

        store.powerups.forEach(p => drawPowerup(p));
        store.missiles.forEach(m => drawMissile(m));
        store.lightningBolts.forEach(l => drawLightningBolt(l));
        store.flameParticles.forEach(p => p.draw());

        // --- RENDER "FAR" BULLETS NORMALLY ---
        farBullets.forEach(b => {
            ctx.fillStyle = b.col;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // --- RENDER PLAYER BULLETS (this happens before close enemy bullets) ---
        store.bullets.forEach(b => {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.fillStyle = b.col;
            ctx.beginPath();
            
            const r = b.r * 1.5;

            if (b.isLavaChunk) {
                ctx.beginPath();
                ctx.moveTo(0, -r);
                ctx.lineTo(r, r * 0.2);
                ctx.lineTo(r * 0.5, r);
                ctx.lineTo(-r * 0.5, r);
                ctx.lineTo(-r, r * 0.2);
                ctx.closePath();
                ctx.fill();
                b.particles.forEach(p => {
                    const t = p.life / p.maxLife;
                    const particleR = p.r * t;
                    ctx.fillStyle = `rgba(255, ${100 + Math.random()*50}, 0, ${0.7 * t})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                    ctx.fill();
                });
            } else if (b.isFlame) {
                ctx.fillStyle = `rgba(255, 150, 50, ${0.3 * (b.life / 50)})`;
                ctx.beginPath();
                ctx.arc(0, 0, b.r * 0.5, 0, 2 * Math.PI);
                ctx.fill();
                b.particles.forEach(p => {
                    const t = p.life / p.maxLife;
                    const r_particle = p.r * t;
                    const g = Math.floor(255 * (0.4 + t * 0.6));
                    const b_val = Math.floor(100 * t);
                    ctx.fillStyle = `rgba(${g}, ${b_val}, 0, ${0.8 * t})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r_particle, 0, 2 * Math.PI);
                    ctx.fill();
                });
            } else if (b.isSwirl || b.explosive) {
                ctx.arc(0, 0, b.r, 0, 2 * Math.PI);
            } else if (b.isIceman) {
                ctx.moveTo(0, r);
                ctx.lineTo(r * 0.8, -r * 0.8);
                ctx.lineTo(-r * 0.8, -r * 0.8);
            } else {
                ctx.moveTo(0, -r);
                ctx.lineTo(r * 0.8, r * 0.8);
                ctx.lineTo(-r * 0.8, r * 0.8);
            }

            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });

        store.lasers.forEach(l => drawLaser(l));
        store.mines.forEach(m => drawMine(m));
        if (store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(performance.now() / 200)})`; ctx.fill(); ctx.restore(); });
        store.enemies.forEach(e => drawEnemy(e));
        if (store.boss) drawBoss(store.boss);
        store.drones.forEach(d => drawDrone(d));
        store.hounds.forEach(h => drawHound(h));
        if (store.iceman) drawIceman(store.iceman);
        drawShip(store.player.x, store.player.y, store.player);
        
        // --- RENDER "CLOSE" BULLETS LAST (so they appear on top) ---
        closeBullets.forEach(item => {
            const b = item.bullet;
            const dist = item.dist;
            
            // This factor is 1 when the bullet is very close, and 0 at the edge of the threshold.
            const proxFactor = 1.0 - (dist / proximityThreshold);

            // 1. Draw the glow, which fades in based on proximity
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = proxFactor; // The glow is invisible at the edge and fully visible up close
            const glowRadius = b.r * 2;
            const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
            gradient.addColorStop(0.3, b.col);
            gradient.addColorStop(1, b.col + '00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore(); // Restores alpha and composite operation

            // 2. Draw the main bullet body at its original size and color
            ctx.fillStyle = b.col;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fill();

            // 3. Draw a small, bright "hot" center that also fades in
            ctx.fillStyle = `rgba(255, 255, 255, ${proxFactor * 0.8})`;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r * 0.5, 0, Math.PI * 2);
            ctx.fill();
        });
        
        store.activeEffects.forEach(e => e.draw && e.draw());
        renderVoidStepSystems(ctx);
        updateHUD();

    }
   
    function takeDamage(dmg) {
        if (store.player.isInvincible || playerIsInvulnerable()) return;
        if (store.boss && store.boss.isInvincible) return;

        if (store.player.hasShieldBubble) {
            store.player.hasShieldBubble = false;
            store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
            return;
        }
        const p = store.player;
        const a = Math.min(p.shield, dmg);
        if (a < dmg) playSound('hit');
        p.shield -= a;
        dmg -= a;
        p.hp = Math.max(0, p.hp - dmg);

        if (p.hp > 0 && p.hp < p.hpMax * 0.25 && p.nanoSaves > 0) {
            p.nanoSaves--;
            p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.25);
            store.activeEffects.push(createEffect("nanoHeal"));
            announce('NANO SAVE ACTIVATED!');
        }

        if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
            store.world.lowHealthTutorialShown = true;
            showShopWithHighlight();
        }
    }
   
    function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function announce(text) { const el = q('announce'); el.textContent = text; el.classList.remove('hide'); clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); }
    function updateHUD() { const t = store.player, e = Math.round(t.hp / t.hpMax * 100), o = t.shieldMax > 0 ? Math.round(t.shield / t.shieldMax * 100) : 0; const healthText = `HP: ${Math.round(t.hp)} / ${t.hpMax}`; const shieldText = t.shieldMax > 0 ? `SHIELD: ${Math.round(t.shield)} / ${t.shieldMax}` : ""; q("hudPilotContent").innerHTML = `<div class="hud-title">${store.name ? `‚ó¢ ${escapeHtml(store.name)} ‚ó£` : "‚ó¢ UNIDENTIFIED ‚ó£"}</div><div style="text-align:center">SCORE <b>${store.world.score}</b> ‚Ä¢ SHARDS <b>${store.world.shards}</b></div><div class="bar"><span style="width:${e}%"></span></div><div style="font-size: 9px; text-align: center; line-height: 1;">${healthText}</div>${t.shieldMax > 0 ? `<div class="bar" style="margin-top:2px;"><span style="width:${o}%;background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div><div style="font-size: 9px; text-align: center; line-height: 1;">${shieldText}</div>` : ""}`; q("hudWaveContent").innerHTML = `<div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div><div style="text-align:center">SECTOR <b>${store.world.wave}</b> ‚Ä¢ KILLS <b>${store.world.kills}</b> ‚Ä¢ LVL <b>${store.world.level}</b></div>`; if (store.boss) { q("hudBossContent").classList.remove("hide"); q("hudBossContent").innerHTML = `<div class="hud-title">‚ö° ${store.boss.name} ‚ö°</div><div class="bar"><span style="width:${Math.round(store.boss.hp / store.boss.hpMax * 100)}%"></span></div>`; } else { q("hudBossContent").classList.add("hide"); } const powerupEl = q("hudPowerup"); const timedPowerups = Object.keys(store.player.powerupTimers); let timedContent = ''; if (timedPowerups.length > 0) { timedPowerups.forEach(key => { const timer = store.player.powerupTimers[key]; const percent = Math.min(100, (timer.remaining / timer.max) * 100); timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`; }); } powerupEl.innerHTML = `<div class="hud-title">‚ó¢ SYSTEMS ONLINE ‚ó£</div>${timedContent}`; powerupEl.classList.toggle('hide', !timedContent); const equipEl = q("hudEquipment"); let hasEquipment = store.player.hasLauncher || store.player.hasHounds || store.player.nanoSaves > 0; if (hasEquipment) { equipEl.classList.remove('hide'); let content = `<div class="hud-title">‚ó¢ EQUIPMENT ‚ó£</div>`; if (store.player.nanoSaves > 0) content += `<div>NANO SAVE [${store.player.nanoSaves}]</div>`; if (store.player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`; if (store.player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`; equipEl.innerHTML = content; } else { equipEl.classList.add('hide'); } const grenadeBtn = q('grenadeBtnUI'); if (store.player.grenades > 0) { grenadeBtn.classList.remove('hide'); grenadeBtn.textContent = `GRENADE [${store.player.grenades}]`; grenadeBtn.disabled = false; } else { grenadeBtn.classList.add('hide'); } }
    function updateLeaderboard(top10) { const fallbackData = [{ name: "ACE PILOT", score: 50000, waves: 10 },{ name: "VOID RUNNER", score: 35000, waves: 8 },{ name: "STAR HUNTER", score: 25000, waves: 6 },{ name: "NOVA STRIKER", score: 18000, waves: 5 },{ name: "COSMIC GUARD", score: 12000, waves: 4 }]; const data = top10 && top10.length > 0 ? top10 : fallbackData; q("hsList").innerHTML = data.map(s => `<li>${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); q("hsListPopup").innerHTML = data.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); }
    async function refreshScoreList() { try { const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 }); if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`); const data = await res.json(); updateLeaderboard(data); } catch (err) { console.warn("Failed to fetch leaderboard, using offline data:", err.message); updateLeaderboard(null); } }
    async function addScore(score) {
        if (store.cheatsUsed) {
            announce("Score not submitted: Cheats used");
            return;
        }
        const name = (store.name || "ROGUE").slice(0, 16); try { const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 }); if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`); const { nonce } = await nonceRes.json(); const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce }; const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 }); if (!res.ok) throw new Error(`Submit failed: ${res.status}`); const data = await res.json(); if (data.ok) { updateLeaderboard(data.top10); } else { console.warn("Score rejected:", data.err); announce(`Score rejected: ${data.err}`); refreshScoreList(); } } catch (err) { console.warn("Score submission failed, game continues offline:", err.message); } }
    function fireBullet(x, y, vx, vy, props = {}) { const p = store.player; store.bullets.push({ x, y, vx, vy, r: p.explosive ? 5 : 3, col: p.explosive ? "#ED2F32" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive, ...props }); }
    function firePlayer() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        const bulletSpeed = 420;
        const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0);
        const angleSpread = 10;
        if (p.flamethrowerLevel > 0) {
            let numFlames, angleRange, speed, life;
            switch (p.flamethrowerLevel) {
                case 1: numFlames = 8; angleRange = 40; speed = 250; life = 0.35; break;
                case 2: numFlames = 12; angleRange = 70; speed = 280; life = 0.4; break;
                default: numFlames = 16; angleRange = 90; speed = 320; life = 0.5; break;
            }
            for (let i = 0; i < numFlames; i++) {
                const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                const currentSpeed = speed + Math.random() * 40;
                const sideOffset = (i % 2 === 0) ? -15 : 15;
                const spawnX = p.x + sideOffset;
                const spawnY = p.y + 5;
                store.bullets.push({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 3, col: `rgba(255, ${60 + Math.random() * 60}, 0, 0.9)`, dmg: 2 * p.dmgMult, life: life * 1.5, isFlame: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
            }
            if (p.hasIceman && store.iceman) {
                for (let i = 0; i < numFlames; i++) {
                    const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                    const currentSpeed = speed + Math.random() * 40;
                    const sideOffset = (i % 2 === 0) ? -15 : 15;
                    const spawnX = store.iceman.x + sideOffset;
                    const spawnY = store.iceman.y + 5;
                    store.bullets.push({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 2, col: `rgba(100, 150, 255, 0.7)`, dmg: 2 * p.dmgMult * 0.35, life: life, isFlame: true, isIceman: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
                }
            }
        }
        for (let i = 0; i < totalMultishot; i++) { const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; store.bullets.push({ x: p.x + 10 * Math.sin(angle), y: p.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: p.explosive ? "#cc99ff" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive }); }
        if (p.hasIceman && store.iceman) { for (let i = 0; i < totalMultishot; i++) { const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; store.bullets.push({ x: store.iceman.x + 10 * Math.sin(angle), y: store.iceman.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: "#66aaff", dmg: 20 * p.dmgMult * 0.35, pierce: p.piercing, explosive: p.explosive, isIceman: true }); } }
        if (p.rearMultishot > 0) { const rearAngleSpread = 15; for (let i = 0; i < p.rearMultishot; i++) { const angle = (i - (p.rearMultishot - 1) / 2) * rearAngleSpread; const radAngle = angle * Math.PI / 180; store.bullets.push({ x: p.x + 10 * Math.sin(radAngle), y: p.y + 12, vx: Math.sin(radAngle) * bulletSpeed, vy: Math.cos(radAngle) * bulletSpeed, r: 3, col: "#ffddff", dmg: 15 * p.dmgMult, pierce: p.piercing > 0 ? p.piercing - 1 : 0 }); } }
        store.drones.forEach(drone => store.bullets.push({ x: p.x + drone.offset, y: p.y + 20, vx: 0, vy: -bulletSpeed, r: 3, col: "#66aaff", dmg: 20 * p.dmgMult * 0.4, isDrone: true }));
        if (p.hasLauncher) {
            const speed = 350;
            const numPairs = store.player.upgradeLevels.launcher || 1;
            for (let i = 0; i < numPairs; i++) {
                const spread = 15 + i * 10;
                const vx_offset = 50 + i * 20;
                store.bullets.push({ x: p.x - spread, y: p.y, vx: -vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                store.bullets.push({ x: p.x + spread, y: p.y, vx: vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                if (p.hasIceman && store.iceman) {
                    store.bullets.push({ x: store.iceman.x - spread, y: store.iceman.y, vx: -vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                    store.bullets.push({ x: store.iceman.x + spread, y: store.iceman.y, vx: vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                }
            }
        }
    }
    function stepBossOmegaSentinel(dt, b, dmgScale) { if (b.y >= 100) { b.moveT += dt; b.x += Math.sin(b.moveT * 2) * 200 * dt; b.x = clamp(b.x, 100, W - 100); } b.fireT -= dt; if (b.fireT <= 0) { if (b.patternPhase % 4 === 0) { b.fireT = 1.5; const n = 12; for (let i = 0; i < n; i++) { const a = (i * Math.PI / 6) + b.t; store.eBullets.push({ x: b.x, y: b.y, vx: 150 * Math.cos(a), vy: 150 * Math.sin(a), r: 4, col: '#4169e1', dmg: 12 * dmgScale }); } } else { b.fireT = 0.2; const a = Math.atan2(store.player.y - b.y, store.player.x - b.x); store.eBullets.push({ x: b.x, y: b.y, vx: 250 * Math.cos(a), vy: 250 * Math.sin(a), r: 5, col: '#add8e6', dmg: 18 * dmgScale }); } b.patternPhase++; } }
    function stepBossCoreMalignus(dt, b, dmgScale) { if (b.hp / b.hpMax <= 0.07 && !b.isEnraged) { b.isEnraged = true; playSound('horn'); } if (b.y >= 100) { b.moveT += dt; b.x = W / 2 + (W / 2 - 100) * Math.sin(b.moveT * 0.5); } b.fireT -= dt; if (b.fireT <= 0) { b.fireT = b.isEnraged ? 0.6 : 0.8; const n = 12, g = 3, s = Math.floor(Math.random() * (n - g)); for (let i = 0; i < n; i++) { if (i >= s && i < s + g) continue; const p = (W / (n + 1)) * (i + 1); store.eBullets.push({ x: p, y: b.y, vx: 0, vy: 180, r: 6, col: b.color, dmg: 20 * dmgScale }); } } }
    function stepBossTheHex(dt, b, dmgScale) { if (b.y >= 100) { b.moveT += dt; b.x = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4)); } b.fireT -= dt; if (b.hp / b.hpMax < 0.5 && !b.isEnraged) { b.isEnraged = true; playSound('trap'); } const fireRate = b.isEnraged ? 0.8 : 1.5; if (b.fireT <= 0) { b.fireT = fireRate; b.attackPhase = (b.attackPhase + 1) % 3; switch(b.attackPhase) { case 0: for (let i=0; i<20; i++) { setTimeout(() => { store.eBullets.push({ x: Math.random() * W, y: 0, vx: 0, vy: 250, r: 5, col: '#ffc83d', dmg: 15 * dmgScale }); }, i * 50); } break; case 1: for (let i = 0; i < 4; i++) { const isHorizontal = i < 2; const y = isHorizontal ? 100 + i * 150 : 0; const x = isHorizontal ? 0 : 200 + (i-2) * 250; const vx = isHorizontal ? 300 : 0; const vy = isHorizontal ? 0 : 300; store.eBullets.push({ x, y, vx, vy, r: 4, col: '#80ffff', dmg: 20 * dmgScale, isLaser: true, life: 2.5 }); } break; case 2: const targetX = store.player.x; const dx = targetX - b.x; const dashSpeed = 800; b.vx = Math.sign(dx) * dashSpeed; setTimeout(() => b.vx = 0, 500); break; } } if(b.vx) { b.x += b.vx * dt; store.eBullets.push({ x: b.x, y: b.y, vx: 0, vy: 0, r: 8, col: '#ff8080', dmg: 25 * dmgScale, life: 1 }); } }
    function stepBossGeometron(dt, b, dmgScale) { if (b.hp / b.hpMax < 0.5 && b.phase === 1) { b.phase = 2; b.isInvincible = true; playSound('horn'); store.activeEffects.push(createEffect("bossPhaseChange", b.x, b.y)); b.attackPhase = 0; b.fireT = 2.0; setTimeout(() => { b.isInvincible = false; }, 2000); announce('GEOMETRON ENRAGED!'); } if (b.y >= 100) { b.moveT += dt; const moveSpeed = (b.phase === 1) ? 0.3 : 0.7; b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); } b.fireT -= dt; if (b.fireT <= 0) { if (b.phase === 1) { b.attackPhase = (b.attackPhase + 1) % 4; b.fireT = 2.5; switch(b.attackPhase) { case 0: case 2: const n = 16; for (let i = 0; i < n; i++) { const a = (i * 2 * Math.PI / n) + b.t * 0.5; store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale }); } break; case 1: case 3: const numShards = 3 + Math.floor(store.world.wave / 10); for(let i = 0; i < numShards; i++) { const shard = spawnEnemy('construct_shard'); shard.x = b.x + (Math.random() - 0.5) * 100; shard.y = b.y + 50; store.enemies.push(shard); } break; } } else { b.attackPhase = (b.attackPhase + 1) % 4; b.fireT = 2.0; switch(b.attackPhase) { case 0: case 2: const spread = 8; const numShots = 8; const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); for (let i = 0; i < numShots; i++) { const angle = angleToPlayer + (i - (numShots - 1) / 2) * (spread * Math.PI / 180) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: 350 * Math.cos(angle), vy: 350 * Math.sin(angle), r: 4, col: '#ff4500', dmg: 22 * dmgScale, life: 2.0 }); } break; case 1: case 3: const numShards = 2; for(let i = 0; i < numShards; i++) { const shard = spawnEnemy('construct_shard'); shard.x = b.x + (i === 0 ? -50 : 50); shard.y = b.y + 50; shard.hp *= 1.5; shard.v *= 1.3; shard.color = '#ff4500'; store.enemies.push(shard); } break; } } } }
    function stepBossVoidRaven(dt, b, dmgScale) { b.moveT += dt; if (!b.isDiving) { b.y = 100 + Math.sin(b.moveT * 2) * 20; b.x = W/2 + Math.cos(b.moveT * 0.5) * (W/2 - 100); } b.fireT -= dt; if (b.fireT <=0) { b.attackPhase = (b.attackPhase + 1) % 5; switch(b.attackPhase) { case 0: case 2: b.fireT = 1.2; for(let i = 0; i < 7; i++) { const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: b.color, dmg: 18 * dmgScale }); } break; case 1: case 3: b.fireT = 2.0; const numHatchlings = 2 + Math.floor(store.world.wave / 15); for(let i = 0; i < numHatchlings; i++) { const hatchling = spawnEnemy('avian_hatchling'); hatchling.x = b.x + (Math.random() - 0.5) * 80; hatchling.y = b.y + 40; store.enemies.push(hatchling); } break; case 4: b.fireT = 4.0; b.isDiving = true; b.diveTarget = { x: store.player.x, y: store.player.y }; const dx = b.diveTarget.x - b.x; const dy = b.diveTarget.y - b.y; const dist = Math.sqrt(dx*dx + dy*dy); b.vx = (dx / dist) * 400; b.vy = (dy / dist) * 400; setTimeout(() => { b.isDiving = false; b.vx = 0; b.vy = 30; }, 1500); break; } } if (b.isDiving) { b.x += b.vx * dt; b.y += b.vy * dt; } }
    function stepBoss(dt) {
        const b = store.boss;
        b.t += dt;
        if (b.y < 100) { b.y += b.vy * dt; }
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        
        if (b.slowTimer > 0) { b.slowTimer -= dt; dt *= 0.3; }

        switch (b.behavior) {
            case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break;
            case 'malignus': stepBossCoreMalignus(dt, b, dmgScale); break;
            case 'hex':      stepBossTheHex(dt, b, dmgScale); break;
            case 'construct':stepBossGeometron(dt, b, dmgScale); break;
            case 'avian':    stepBossVoidRaven(dt, b, dmgScale); break;
        }
    }
    function drawMissile(m) {
        ctx.save(); // Save the current canvas state
        ctx.translate(m.x, m.y); // Move to the missile's position
        ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2); // Rotate to face the direction of travel

        // Draw the missile body
        ctx.fillStyle = m.isIceman ? "#a0e9ff" : "#ffddff";
        ctx.shadowColor = m.isIceman ? '#3c9aed' : '#ff8080';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -10); // Tip of the missile
        ctx.lineTo(4, 5);  // Right base
        ctx.lineTo(-4, 5); // Left base
        ctx.closePath();
        ctx.fill();

        // Reset shadow for the flame
        ctx.shadowBlur = 0;

        // --- START: ADDED CODE FOR FLAME ---
        // Calculate a pulsating flame size
        const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
        // Set flame color with random opacity for a flickering effect
        ctx.fillStyle = m.isIceman ? `rgba(60, 154, 237, ${0.6 + 0.4 * Math.random()})` : `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;

        // Draw the flame shape
        ctx.beginPath();
        ctx.moveTo(-3, 5); // Start at the left base of the missile
        ctx.lineTo(3, 5);  // Go to the right base
        ctx.lineTo(0, 5 + flameSize); // Go to the tip of the flame
        ctx.closePath();
        ctx.fill(); // <-- MOVED THIS LINE INSIDE THE FUNCTION
        // --- END: ADDED CODE FOR FLAME ---

        ctx.restore(); // Restore the canvas state
    }
    function drawPowerup(p) { const cfg = POWERUP_TYPES[p.type]; ctx.save(); ctx.translate(p.x, p.y); const pulse = 0.8 + 0.2 * Math.sin(performance.now() / 150); ctx.scale(pulse, pulse); ctx.beginPath(); ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2); const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3); grad.addColorStop(0, '#FFD70099'); grad.addColorStop(1, '#FFD70000'); ctx.fillStyle = grad; ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, p.r, 0, Math.PI * 2); ctx.fillStyle = '#FFD70044'; ctx.fill(); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 16px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(cfg.icon, 0, 1); ctx.restore(); }
    function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }
    
    function drawLaser(laser) {
        ctx.save();
        const trailLength = 200;
        const angle = Math.atan2(laser.vy, laser.vx);
        const startX = laser.x - Math.cos(angle) * trailLength;
        const startY = laser.y - Math.sin(angle) * trailLength;

        const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
        grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
        grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = laser.r * 1.5;
        ctx.lineCap = 'round';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 25;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(laser.x, laser.y);
        ctx.stroke();

        ctx.restore();
    }
    function drawBoss(t) { ctx.save();ctx.translate(t.x,t.y); if(t.isEnraged) ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50); ctx.fillStyle="rgba(0,0,0,0.7)";ctx.fillRect(-60,-t.r-20,120,8);
        const healthBarColor = t.name === 'EVIL BABYMOON' ? '#ffd700' : t.color;
        ctx.fillStyle = healthBarColor;
        ctx.fillRect(-60,-t.r-20,120*(t.hp/t.hpMax),8);ctx.strokeStyle="#fff";ctx.lineWidth=1;ctx.strokeRect(-60,-t.r-20,120,8);if(t.behavior==="malignus"){const time=performance.now()/1e3;ctx.fillStyle=t.color;ctx.beginPath();const pulse=t.r*(.3+.05*Math.sin(4*time));ctx.arc(0,0,pulse,0,2*Math.PI);ctx.fill();ctx.fillStyle="white";ctx.beginPath();ctx.arc(0,0,.4*pulse,0,2*Math.PI);ctx.fill();const numShards=5;for(let i=0;i<numShards;i++){ctx.save();const angle=time*(.5+.1*i)+i*2*Math.PI/numShards,dist=.8*t.r;ctx.rotate(angle);ctx.translate(dist,0);ctx.rotate(2*time);ctx.fillStyle=t.color+"aa";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=2;ctx.beginPath();const shardSize=.3*t.r;ctx.moveTo(0,-shardSize);ctx.lineTo(shardSize/2,shardSize);ctx.lineTo(-shardSize/2,shardSize);ctx.closePath();ctx.fill();ctx.stroke();ctx.restore()}}else if(t.behavior==="hex"){ctx.translate(0,30);const bodyW_top=t.r*1.5,bodyW_bottom=t.r*2.5,bodyH=t.r*1.5;ctx.fillStyle="#66aaff";ctx.strokeStyle="#5599e5";ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(-bodyW_top/2,-bodyH/2);ctx.lineTo(bodyW_top/2,-bodyH/2);ctx.lineTo(bodyW_bottom/2,bodyH/2);ctx.lineTo(-bodyW_bottom/2,bodyH/2);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#e03434";ctx.strokeStyle="#c02d2d";const crownH=t.r*0.8,crownW=bodyW_top*0.9;ctx.beginPath();ctx.moveTo(-crownW/2,-bodyH/2);ctx.lineTo(-crownW/2+crownW/4,-bodyH/2-crownH);ctx.lineTo(0,-bodyH/2-crownH/2);ctx.lineTo(crownW/2-crownW/4,-bodyH/2-crownH);ctx.lineTo(crownW/2,-bodyH/2);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#000";ctx.fillRect(-t.r*0.6,-t.r*0.3,t.r*0.4,t.r*0.15);ctx.fillRect(t.r*0.2,-t.r*0.3,t.r*0.4,t.r*0.15);ctx.fillRect(-t.r*0.4,0,t.r*0.8,t.r*0.1);ctx.strokeStyle="#ffd700";ctx.lineWidth=8;ctx.beginPath();ctx.arc(0,0,t.r*1.1,0.5,Math.PI-0.5);ctx.stroke();ctx.fillStyle="#ffd700";ctx.strokeStyle="#daa520";ctx.lineWidth=3;const medR=t.r*0.5;ctx.beginPath();ctx.moveTo(0,t.r*1.1+medR);for(let i=1;i<=8;i++){const angle=i*(2*Math.PI/8);ctx.lineTo(medR*Math.sin(angle),t.r*1.1+medR*Math.cos(angle))}ctx.closePath();ctx.fill();ctx.stroke()}else if(t.behavior==="construct"){const phaseColor=t.phase===1?t.color:"#ff4500";ctx.fillStyle=phaseColor+"aa";ctx.strokeStyle=phaseColor;ctx.lineWidth=3;if(t.phase===2){ctx.shadowColor=phaseColor;ctx.shadowBlur=25}const bodyW=t.r*1.2,bodyH=t.r*1.5,headH=t.r*0.7;ctx.beginPath();ctx.moveTo(-bodyW*.5,bodyH*.5);ctx.lineTo(-bodyW*.6,bodyH*.2);ctx.lineTo(-bodyW*.4,-bodyH*.6);ctx.lineTo(0,-bodyH*.5);ctx.lineTo(bodyW*.4,-bodyH*.6);ctx.lineTo(bodyW*.6,bodyH*.2);ctx.lineTo(bodyW*.5,bodyH*.5);ctx.closePath();ctx.fill();ctx.stroke();const shoulderY=-bodyH*.3,shoulderX=bodyW*.4;const armW=.4*t.r,armH=.9*t.r;ctx.beginPath();ctx.moveTo(-shoulderX,shoulderY);ctx.lineTo(-shoulderX-armW*.5,shoulderY+armH*.2);ctx.lineTo(-shoulderX,shoulderY+armH);ctx.lineTo(-shoulderX+armW*.5,shoulderY+armH*.8);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(shoulderX,shoulderY);ctx.lineTo(shoulderX+armW*.5,shoulderY+armH*.2);ctx.lineTo(shoulderX,shoulderY+armH);ctx.lineTo(shoulderX-armW*.5,shoulderY+armH*.8);ctx.closePath();ctx.fill();ctx.stroke();const eyeR=t.r*.2+2*Math.sin(performance.now()/200);const eyeGrad=ctx.createRadialGradient(0,-headH*.1,0,0,-headH*.1,eyeR);eyeGrad.addColorStop(0,"#ffffff");eyeGrad.addColorStop(.3,phaseColor);eyeGrad.addColorStop(1,"#ff4500");ctx.fillStyle=eyeGrad;ctx.beginPath();ctx.arc(0,-headH*.1,eyeR,0,2*Math.PI);ctx.fill()}else if(t.behavior==="avian"){const wingSpan=t.r*1.8,bodyH=t.r*0.8,headR=t.r*0.4;ctx.fillStyle=t.color;ctx.strokeStyle="#e6e6fa";ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(0,-bodyH/2);ctx.lineTo(wingSpan/2,-bodyH/4);ctx.lineTo(wingSpan/2,bodyH/4);ctx.lineTo(0,bodyH/2);ctx.lineTo(-wingSpan/2,bodyH/4);ctx.lineTo(-wingSpan/2,-bodyH/4);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(0,-bodyH/2,headR,0,2*Math.PI);ctx.fill();ctx.stroke();ctx.fillStyle="#ffd700";ctx.beginPath();ctx.moveTo(0,-bodyH/2-headR/2);ctx.lineTo(headR/2,-bodyH/2+headR/2);ctx.lineTo(-headR/2,-bodyH/2+headR/2);ctx.closePath();ctx.fill();ctx.fillStyle="#ff4500";ctx.beginPath();ctx.arc(-headR/3,-bodyH/2-headR/4,headR/4,0,2*Math.PI);ctx.arc(headR/3,-bodyH/2-headR/4,headR/4,0,2*Math.PI);ctx.fill()}else{const grad=ctx.createRadialGradient(0,0,t.r*0.6,0,0,t.r);grad.addColorStop(0,t.color);grad.addColorStop(1,"#000000");ctx.fillStyle=grad;ctx.beginPath();ctx.arc(0,0,t.r,0,2*Math.PI);ctx.fill();ctx.strokeStyle="#888";ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-t.r,0);ctx.lineTo(t.r,0);ctx.stroke();for(let i=1;i<6;i++){const y=t.r*i/6;ctx.beginPath();ctx.arc(0,0,t.r,Math.PI-Math.asin(y/t.r),Math.asin(y/t.r));ctx.stroke();ctx.beginPath();ctx.arc(0,0,t.r,Math.PI+Math.asin(y/t.r),-Math.asin(y/t.r));ctx.stroke()}const dishR=t.r*0.3;ctx.fillStyle="#444";ctx.beginPath();ctx.arc(-t.r*0.4, -t.r*0.4, dishR, 0, 2*Math.PI);ctx.fill();ctx.fillStyle="white";ctx.beginPath();ctx.arc(-t.r*0.4,-t.r*0.4,dishR*0.4+1*Math.sin(performance.now()/150),0,2*Math.PI);ctx.fill()} ctx.globalAlpha = 1.0; ctx.restore() }
    function drawShip(t, e, player) { ctx.save();ctx.translate(t,e);if(player.isInvincible || player.hasShieldBubble){ctx.beginPath();ctx.arc(0,0,24,0,2*Math.PI);const g=ctx.createRadialGradient(0,0,18,0,0,24);g.addColorStop(0,"#9a66ff11");g.addColorStop(1,"#9a66ff");ctx.fillStyle=g;ctx.fill()}ctx.beginPath();ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);ctx.closePath();const o=ctx.createLinearGradient(0,-20,0,14);o.addColorStop(0,"#b266ff");o.addColorStop(.5,"#7a49cc");o.addColorStop(1,"#4d2a80");ctx.fillStyle=o;ctx.fill();ctx.lineWidth=2;ctx.strokeStyle="#c49cff";ctx.stroke();ctx.strokeStyle="#b266ff";ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();const r=performance.now()/1e3;ctx.globalAlpha=.8+.2*Math.sin(10*r);ctx.fillStyle="#cc99ff";ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,2*Math.PI);ctx.ellipse(5,16,3,6,0,0,2*Math.PI);ctx.fill();ctx.globalAlpha=1;ctx.fillStyle="#ffffff";ctx.beginPath();ctx.arc(0,-8,3,0,2*Math.PI);ctx.fill();
        if (player.hasRearGuard && player.rearGuardReady) {
            ctx.fillStyle = `rgba(100, 255, 255, ${0.4 + 0.3 * Math.sin(performance.now() / 200)})`;
            ctx.beginPath();
            ctx.arc(0, 15, 8, 0, 2 * Math.PI);
            ctx.fill();
        }
        ctx.restore();
    }
    function drawMine(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        const time = performance.now();
        const pulse = 0.8 + 0.2 * Math.sin(time / 150);
        const fuseRatio = m.fuse / 5;
        const color = `rgb(255, ${100 * fuseRatio}, ${80 * fuseRatio})`;

        ctx.beginPath();
        ctx.arc(0, 0, m.r * 1.5 * pulse, 0, 2 * Math.PI);
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, m.r * 1.5 * pulse);
        grad.addColorStop(0, color + '99');
        grad.addColorStop(1, color + '00');
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(0, 0, m.r, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 2;
        ctx.stroke();
       
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, m.r * 0.4 * pulse, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawEnemy(e) { const{x:t,y:o,r:a,type:r,color:n,hp:l,hpMax:s,t:c}=e;ctx.save();ctx.translate(t,o);l<s&&l>0&&(ctx.fillStyle="rgba(0,0,0,0.5)",ctx.fillRect(-a,-a-8,2*a,3),ctx.fillStyle="#b266ff",ctx.fillRect(-a,-a-8,2*a*(l/s),3));ctx.lineWidth=2;ctx.beginPath();switch(r){case"avian_hatchling":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a*1.2);ctx.lineTo(a,-a*0.5);ctx.lineTo(a,a*0.5);ctx.lineTo(0,a*1.2);ctx.lineTo(-a,a*0.5);ctx.lineTo(-a,-a*0.5);ctx.closePath();ctx.fill();ctx.stroke();break;case"construct_shard":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a);ctx.lineTo(a,0);ctx.lineTo(0,a);ctx.lineTo(-a,0);ctx.closePath();ctx.fill();ctx.stroke();break;case"trap_king_add":case"drone":const e=ctx.createLinearGradient(-a,-a,a,a);e.addColorStop(0,"#E0E0E0");e.addColorStop(1,"#A0A0A0");ctx.fillStyle=e;ctx.strokeStyle="#808080";ctx.beginPath();ctx.moveTo(-1.2*a,0);ctx.quadraticCurveTo(0,-a,1.2*a,0);ctx.quadraticCurveTo(0,.6*a,-1.2*a,0);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#aaddff";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-.2*a,.6*a,Math.PI,0);ctx.fill();ctx.stroke();ctx.fillStyle=r==="trap_king_add"?"#ffc83d":"#32CD32";ctx.beginPath();ctx.ellipse(0,-.2*a,.3*a,.4*a,0,0,2*Math.PI);ctx.fill();ctx.fillStyle="#000000";ctx.beginPath();ctx.ellipse(-.1*a,-.25*a,.08*a,.15*a,-.5,0,2*Math.PI);ctx.ellipse(.1*a,-.25*a,.08*a,.15*a,.5,0,2*Math.PI);ctx.fill();break;
        case "hunter":
            // Void Serpent design
            ctx.strokeStyle = '#BE2545';
            ctx.fillStyle = n + "cc";
            ctx.lineWidth = 2;
            ctx.shadowColor = n;
            ctx.shadowBlur = 15;

            const segments = 12;
            const length = a * 1.8;
            const amplitude = a * 0.5; // Controls side-to-side curve
           
            ctx.beginPath();
           
            // Generate points for one side of the snake
            const points1 = [];
            for (let i = 0; i <= segments; i++) {
                const progress = i / segments;
                // Body is thickest in the middle, tapers at ends
                const segmentWidth = a * Math.sin(progress * Math.PI) * 0.5;
                const x = Math.sin(progress * 2.5 * Math.PI + c * 5) * amplitude;
                const y = (progress - 0.5) * length;
                points1.push({ x: x + segmentWidth, y: y });
            }

            // Generate points for the other side of the snake in reverse
            const points2 = [];
            for (let i = segments; i >= 0; i--) {
                const progress = i / segments;
                const segmentWidth = a * Math.sin(progress * Math.PI) * 0.5;
                const x = Math.sin(progress * 2.5 * Math.PI + c * 5) * amplitude;
                const y = (progress - 0.5) * length;
                points2.push({ x: x - segmentWidth, y: y });
            }

            // Draw the path by connecting all points
            ctx.moveTo(points1[0].x, points1[0].y);
            for(let i = 1; i < points1.length; i++) {
                ctx.lineTo(points1[i].x, points1[i].y);
            }
            ctx.lineTo(points2[0].x, points2[0].y);
             for(let i = 1; i < points2.length; i++) {
                ctx.lineTo(points2[i].x, points2[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Head details
            const headX = Math.sin(c * 5) * amplitude;
            const headY = -0.5 * length;
            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(headX - a*0.2, headY, a * 0.1, 0, 2*Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(headX + a*0.2, headY, a * 0.1, 0, 2*Math.PI);
            ctx.fill();


            ctx.shadowBlur = 0;
            break;
        case "phantom":
            ctx.globalAlpha=.6+.4*Math.sin(5*c);ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-.8*a);ctx.quadraticCurveTo(a,-.5*a,.8*a,.8*a);ctx.quadraticCurveTo(0,.5*a,-.8*a,.8*a);ctx.quadraticCurveTo(-a,-.5*a,0,-.8*a);ctx.closePath();ctx.fill();ctx.stroke();for(let e=-1;e<=1;e++)ctx.beginPath(),ctx.moveTo(e*.4*a,.6*a),ctx.quadraticCurveTo(e*.5*a,a,e*.3*a+2*Math.sin(4*c+e),1.2*a),ctx.stroke();break;
        case "mech": // Refactored to Mech Gorilla
            ctx.strokeStyle = n; ctx.fillStyle = n + "99"; ctx.lineWidth = 2;
           
            // Head
            ctx.beginPath();
            ctx.rect(-a * 0.3, -a * 1.4, a * 0.6, a * 0.4);
            ctx.fill(); ctx.stroke();

            // Cockpit/Eye
            ctx.fillStyle = "#ff99cc";
            ctx.beginPath();
            ctx.rect(-a * 0.2, -a * 1.3, a * 0.4, a * 0.15);
            ctx.fill();

            // Torso
            ctx.fillStyle = n + "99";
            ctx.beginPath();
            ctx.moveTo(-a * 1.2, -a * 1.0); // Top left shoulder
            ctx.lineTo(a * 1.2, -a * 1.0);  // Top right shoulder
            ctx.lineTo(a * 0.6, a * 0.6);   // Bottom right waist
            ctx.lineTo(-a * 0.6, a * 0.6);  // Bottom left waist
            ctx.closePath();
            ctx.fill(); ctx.stroke();

            // Arms (Gorilla-like)
            ctx.beginPath();
            // Left Arm
            ctx.rect(-a * 1.6, -a * 0.9, a * 0.6, a * 1.8);
            // Right Arm
            ctx.rect(a * 1.0, -a * 0.9, a * 0.6, a * 1.8);
            ctx.fill(); ctx.stroke();
           
            // Fists
            ctx.fillStyle = n + "cc";
            ctx.beginPath();
            ctx.arc(-a * 1.3, a * 1.2, a * 0.5, 0, 2 * Math.PI); // Left fist
            ctx.arc(a * 1.3, a * 1.2, a * 0.5, 0, 2 * Math.PI);  // Right fist
            ctx.fill();

            // Legs (Short and stout)
            ctx.fillStyle = n + "99";
            ctx.beginPath();
            ctx.rect(-a * 0.6, a * 0.6, a * 0.5, a * 0.7); // Left leg
            ctx.rect(a * 0.1, a * 0.6, a * 0.5, a * 0.7);  // Right leg
            ctx.fill(); ctx.stroke();
            break;
        case "angler": {
            const scale = a / 20;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle = n + "99"; ctx.strokeStyle = n; ctx.lineWidth = 2;
            // head/torso (teardrop)
            ctx.beginPath();
            ctx.moveTo(-20,0);
            ctx.quadraticCurveTo(0,-18,24,0);
            ctx.quadraticCurveTo(0,16,-20,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            // teeth arc
            ctx.beginPath();
            ctx.moveTo(-6,5);
            ctx.quadraticCurveTo(2,10,10,4);
            ctx.stroke();
            // antenna + glow orb
            ctx.beginPath(); ctx.moveTo(8,-6);
            ctx.quadraticCurveTo(20,-24,32,-28); ctx.stroke();
            ctx.shadowColor="#00FFD5"; ctx.shadowBlur=12;
            ctx.beginPath(); ctx.arc(32,-28,4,0,Math.PI*2); ctx.fillStyle="#00FFD5"; ctx.fill();
            ctx.restore();
            break;
        }
        case "manta": {
            const scale = a / 36;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle= n + "cc"; ctx.strokeStyle=n; ctx.lineWidth=2;

            ctx.beginPath();
            ctx.moveTo(-36,0);
            ctx.quadraticCurveTo(-8,-18,0,-8);
            ctx.quadraticCurveTo(8,-18,36,0);
            ctx.quadraticCurveTo(8,14,0,8);
            ctx.quadraticCurveTo(-8,14,-36,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0,8);
            ctx.quadraticCurveTo(4,22,0,30);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
            ctx.restore();
            break;
        }
    }
    if (e.stunTimer && e.stunTimer > 0) {
        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + 0.3 * Math.sin(performance.now() / 100)})`;
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('STUN', 0, -a - 12);
    }
    ctx.restore()
    }
    function createEffect(type,x,y, radius){
        let effect={isActive:!0,life:1,maxLife:1,x,y};
        switch(type){
            case "heartbeatPulse":
                effect.maxLife = 0.6; // The pulse will last 0.6 seconds
                effect.life = effect.maxLife;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    // This curve creates a smooth "swell" and fade-out for the pulse
                    const alpha = Math.sin((this.life / this.maxLife) * Math.PI) * 0.4;
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "beefCharge":
                effect.maxLife = 0.4;
                effect.origin = x;
                effect.target = y;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const progress = 1 - this.life;
                    const currentX = this.origin.x + (this.target.x - this.origin.x) * progress;
                    const currentY = this.origin.y + (this.target.y - this.origin.y) * progress;
   
                    ctx.save();
                    if(progress > 0.5) {
                        const shockwaveProgress = (progress - 0.5) / 0.5;
                        ctx.strokeStyle = `rgba(255, 100, 100, ${1 - shockwaveProgress})`;
                        ctx.lineWidth = 5 * (1 - shockwaveProgress);
                        ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, 80 * shockwaveProgress, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = `rgba(255, 150, 150, ${this.life})`;
                    ctx.lineWidth = 15 * this.life;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.origin.x, this.origin.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "rearGuardBlock":
                effect.maxLife = 0.5;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${this.life})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Arc at the back of the ship
                    ctx.arc(0, 5, 20 * (1.2 - this.life), Math.PI * 0.2, Math.PI * 0.8);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "gravityWell":
                effect.maxLife = 7;
                effect.life = 7;
                effect.radius = 0;
                effect.maxRadius = 150; // Smaller radius
                effect.damagePulseT = 1;
                effect.totalDamageDealtToBoss = 0;
                effect.stars = [];
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * effect.maxRadius;
                    effect.stars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        r: Math.random() * 1.5,
                        initialDist: dist
                    });
                }
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) {
                        this.isActive = false;
                        screenFlash(1, 400, 'rgba(255, 255, 255, 0.5)');
                        return;
                    }
                    if (this.radius < this.maxRadius) {
                        this.radius += 200 * dt;
                    }

                    this.damagePulseT -= dt;
                    const damageThisFrame = this.damagePulseT <= 0;
                    if (damageThisFrame) {
                        this.damagePulseT = 1;
                    }
                   
                    const pullStrength = 300;
                    const damageRadiusSq = (this.maxRadius * 0.7)**2;

                    store.enemies.forEach(e => {
                        if (e.dead) return;
                        const dx = this.x - e.x;
                        const dy = this.y - e.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < this.radius**2) {
                            const dist = Math.sqrt(distSq);
                            if (dist > 10) {
                                const resistance = (e.type === 'mech' || e.type === 'hunter') ? 0.7 : 1.0;
                                e.x += (dx / dist) * pullStrength * resistance * dt;
                                e.y += (dy / dist) * pullStrength * resistance * dt;
                            }
                           
                            if (damageThisFrame && distSq < damageRadiusSq) {
                                e.hp -= e.hpMax * (0.25 * store.player.dmgMult) ;
                            }
                        }
                    });
                     if (store.boss) {
                         const b = store.boss;
                          const dx = this.x - b.x;
                          const dy = this.y - b.y;
                          const distSq = dx*dx + dy*dy;
                          if(distSq < this.radius**2) {
                               const dist = Math.sqrt(distSq);
                               if (dist > 50) {
                                   b.x += (dx/dist) * pullStrength * 0.5 * dt;
                                   b.y += (dy/dist) * pullStrength * 0.5 * dt;
                               }
                               if (damageThisFrame && distSq < damageRadiusSq) {
                                   const damageToDeal = b.hpMax * (0.10 * store.player.dmgMult);
                                   const cap = b.hpMax * 0.5;
                                   let actualDamage = damageToDeal;
                                   if (this.totalDamageDealtToBoss + actualDamage > cap) {
                                       actualDamage = cap - this.totalDamageDealtToBoss;
                                   }
                                   if (actualDamage > 0) {
                                       b.hp -= actualDamage;
                                       this.totalDamageDealtToBoss += actualDamage;
                                   }
                               }
                            }
                       }
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const time = performance.now();
                    const lifeRatio = this.life / this.maxLife;

                    // Draw swirling stars first
                    ctx.fillStyle = 'white';
                    this.stars.forEach(star => {
                        const pullFactor = 1 - lifeRatio;
                        const currentDist = star.initialDist * (1 - pullFactor * 0.95);
                        const angle = Math.atan2(star.y, star.x) + pullFactor * 3;
                        const sx = Math.cos(angle) * currentDist;
                        const sy = Math.sin(angle) * currentDist;
                       
                        if (currentDist < this.radius) {
                            ctx.globalAlpha = lifeRatio * (currentDist / this.radius);
                            ctx.beginPath();
                            ctx.arc(sx, sy, star.r, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                    ctx.globalAlpha = 1;

                    // Dark swirl effect
                    for (let i = 0; i < 5; i++) {
                        const rotation = (time / (2000 + i * 200)) % (2 * Math.PI);
                        ctx.strokeStyle = `rgba(0, 0, 5, ${0.4 * lifeRatio})`;
                        ctx.lineWidth = (2 + i) * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, (this.radius / 5) * (i + 1), rotation, rotation + Math.PI * 1.5);
                        ctx.stroke();
                    }
                   
                    // Pulsating matter at the core
                    const corePulse = 3 + Math.sin(time / 100) * 2;
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse * 2);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    coreGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.7)');
                    coreGrad.addColorStop(1, 'rgba(150, 150, 255, 0)');
                    ctx.fillStyle = coreGrad;
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, corePulse * 2, 0, Math.PI * 2);
                    ctx.fill();
                   
                    ctx.restore();
                };
                break;
            case"grenadeExplosion":
                effect.maxLife=.5;
                effect.radius=radius || 60;
                effect.step=function(dt){this.life-=2*dt;this.life<=0&&(this.isActive=!1)};
                effect.draw=function(){
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.radius*(1-this.life),0,2*Math.PI);
                    ctx.fillStyle=`rgba(255, 153, 51, ${.8*this.life})`;
                    ctx.fill()
                };
                break;
            case"shieldBreak":effect.maxLife=.6;effect.step=function(dt){this.life-=1.5*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.strokeStyle=`rgba(154, 102, 255, ${this.life})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(this.x,this.y,24*(1.5-this.life),0,2*Math.PI);ctx.stroke()};break;
            case "nanoHeal":
                effect.maxLife = 0.7;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const p = 1 - this.life;
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                    ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "critText":
                effect.maxLife = 0.6;
                effect.text = "CRITICAL!";
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 30 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                };
                break;
            case "bossPhaseChange":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; this.radius += 600 * dt; };
                effect.draw = function() {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                    ctx.lineWidth = 1 + 4 * this.life;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                };
                break;
             case "screenFlash":
                effect.maxLife = y / 1000; // duration
                effect.life = effect.maxLife;
                effect.color = radius; // color
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.globalAlpha = this.life / this.maxLife;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
        }
        return effect
    }
   
    function deployMineWall() {
        const p = store.player;
        for (let i = 0; i < 4; i++) {
            store.mines.push({
                x: p.x + (i - 1.5) * 40,
                y: p.y - 50,
                r: 10,
                fuse: 5,
                proxRadius: 75,
                isWallMine: true,
            });
        }
    }

    function explodeMine(mine) {
        playSound('explosion');
        const p = store.player;
       
        const numBullets = 18;
        for (let i = 0; i < numBullets; i++) {
            const angle = (i / numBullets) * 2 * Math.PI;
            const bulletSpeed = 300;
            store.bullets.push({
                x: mine.x, y: mine.y,
                vx: Math.cos(angle) * bulletSpeed,
                vy: Math.sin(angle) * bulletSpeed,
                r: 3, col: '#ff9966', dmg: 20 * p.dmgMult,
                pierce: false, life: 0.28
            });
        }

        const numFlames = 15;
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * 120 * Math.PI / 180;
            const speed = 250 + Math.random() * 50;
            store.bullets.push({
                x: mine.x, y: mine.y,
                vx: Math.sin(angle) * speed, vy: -Math.cos(angle) * speed,
                r: 3 + Math.random() * 2, col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`,
                dmg: 2 * p.dmgMult, life: 0.3, isFlame: true
            });
        }

        store.activeEffects.push(createEffect("grenadeExplosion", mine.x, mine.y, 55));
    }


    let shopItemOrder = [];
    function showShop() {
        pauseGame();
        const panel = q("shopPanel"),
            grid = q("shopGrid"),
            shardsEl = q("shopShards");
        shardsEl.textContent = store.world.shards;

        const currentItems = Object.keys(SHOP_UPGRADES).map(key => {
            const u = SHOP_UPGRADES[key];
            let currentLevel = store.player.upgradeLevels[key] || 0,
                cost = 0;
            if (key === 'vampirism') {
                cost = 12 + (store.player.vampirismLevel * 5);
                if (store.player.vampirismLevel >= u.max) cost = Infinity
            } else if (u.isPremium) {
                cost = u.cost
            } else {
                if (currentLevel >= u.maxLevel) {
                    cost = Infinity
                } else {
                    if (u.increment) {
                        cost = u.baseCost + (currentLevel * u.increment);
                    } else {
                        cost = Math.floor(u.baseCost * Math.pow(u.scale, currentLevel))
                    }
                }
            }
            return {
                key, ...u,
                cost
            }
        });

        const temporarilyDisabled = ["mine_wall"];

        if (shopItemOrder.length === 0) {
            const itemsToSort = [...currentItems];
            itemsToSort.sort((a, b) => {
                const aIsDisabled = temporarilyDisabled.includes(a.key);
                const bIsDisabled = temporarilyDisabled.includes(b.key);
                if (aIsDisabled && !bIsDisabled) return 1;
                if (!aIsDisabled && bIsDisabled) return -1;
                return a.cost - b.cost;
            });
            shopItemOrder = itemsToSort.map(item => item.key);
        }

        const shopItems = shopItemOrder.map(key => currentItems.find(item => item.key === key));
       
        let content = "";
        for (const u of shopItems) {
            const key = u.key;
            let currentLevel = store.player.upgradeLevels[key] || 0,
                isDisabled = false,
                cost = u.cost,
                desc = typeof u.desc === 'function' ? u.desc(currentLevel) : u.desc,
                name = u.name;
            if (u.isPremium) {
                if (key === 'vampirism') {
                    if (store.player.vampirismLevel >= u.max) isDisabled = true
                } else if (key === 'repair') {
                    if (store.player.hp >= store.player.hpMax) {
                        isDisabled = true;
                        desc = "Health is already full."
                    }
                } else if (key === 'nano_save') {
                    if (store.player.nanoSaves >= u.max) {
                        isDisabled = true;
                        desc = "Max charges reached."
                    }
                } else if (key === 'mine_wall') {
                    if (store.mines.filter(m => m.isWallMine).length > 0) {
                        isDisabled = true;
                        desc = "Wall already deployed."
                    }
                } else if (u.isUnlock) {
                    if ( (key === 'gravity_well' && store.player.hasVoidBeam) ||
                         (key === 'lazarus_beam' && store.player.hasLazarusBeam) ||
                         (key === 'launcher' && store.player.hasLauncher) ||
                         (key === 'luck_boost' && store.player.luckBoost > 0) ||
                         (key === 'magnet_pull' && store.player.magnetRadius > 0) ||
                         (key === 'rear_guard' && store.player.hasRearGuard) ||
                         (key === 'iceman' && store.player.hasIceman)) {
                        isDisabled = true;
                        desc = "Already Unlocked"
                    }
                } else {
                    if (store.player.grenades >= u.max) {
                        isDisabled = true;
                        desc = "At maximum capacity"
                    }
                }
            } else {
                if (currentLevel >= u.maxLevel) {
                    isDisabled = true;
                    desc = "Max Level Reached"
                }
            }
            if (store.world.shards < cost) isDisabled = true;
            if (temporarilyDisabled.includes(key)) {
                isDisabled = true;
                desc = "Under maintenance.";
            }
            const costText = isFinite(cost) ? cost : '---';
            content += `<div class="skill-card shop-item ${isDisabled?'disabled':''} shop-item-${u.category}" data-key="${key}"><div class="skill-icon">${u.icon}</div><div><div class="skill-title">${name}</div><div class="skill-desc">${desc}</div></div><div style="color:var(--accent);margin-top:4px;font-size:11px;">Cost: ${costText}</div></div>`
        }
        grid.innerHTML = content;
        grid.querySelectorAll(".shop-item").forEach(item => {
            item.addEventListener("click", () => {
                if (item.classList.contains('disabled')) return;
                const key = item.dataset.key;
                const upgrade = SHOP_UPGRADES[key];
                let purchaseSuccessful = false;
                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const cost = 12 + (store.player.vampirismLevel * 5);
                        if (store.world.shards >= cost) {
                            purchaseSuccessful = upgrade.apply()
                        }
                    } else {
                        const cost = upgrade.cost;
                        if (store.world.shards >= cost) {
                            store.world.shards -= cost;
                            purchaseSuccessful = upgrade.apply()
                        }
                    }
                } else {
                    const currentLevel = store.player.upgradeLevels[key] || 0;
                    let cost;
                    if (upgrade.increment) {
                        cost = upgrade.baseCost + (currentLevel * upgrade.increment);
                    } else {
                        cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                    }

                    if (store.world.shards >= cost) {
                        store.world.shards -= cost;
                        upgrade.effect();
                        store.player.upgradeLevels[key] = (store.player.upgradeLevels[key] || 0) + 1;
                        purchaseSuccessful = true;
                    }
                }
                if (purchaseSuccessful) {
                    showShop()
                }
            })
        });
        panel.classList.remove("hide")
    }

    function showShopWithHighlight() { showShop(); announce('Low health! Use the Mech Forge to repair!'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }
    function createHound(side) {
        const isTuxedo = side === -1 || side === -2;
        // Default color logic
        let color = isTuxedo ? { main: '#222222', accent: '#FFFFFF' } : { main: '#F0E68C', accent: '#BDB76B' };
       
        // New properties for upgraded hounds
        let isUpgraded = false;
        let eyeType = 'normal';
        let expression = 'normal';

        if (Math.abs(side) > 1) { // This is the second, upgraded pair
            isUpgraded = true;
            if (side === -2) { // The bigger, silly one
                color = { main: '#c4b5a0', accent: '#333' }; // whitish blonde
                eyeType = 'swirly';
                expression = 'silly';
            } else { // side === 2, the smaller, crazy one
                color = { main: '#ffb366', accent: '#000' }; // orangish blonde
                eyeType = 'dilated';
                expression = 'mischievous';
            }
        }

        return {
            x: store.player.x + 50 * side,
            y: store.player.y + 20,
            side,
            target: null,
            attackT: 0,
            r: 12,
            killCount: 0,
            color,
            isUpgraded,
            eyeType,
            expression
        };
    }
    function stepHounds(dt) { if (!store.player.hasHounds) return; store.hounds.forEach(h => { if (!h.target || h.target.dead || h.target.hp <= 0) { let closest = null, closestDist = Infinity; const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies; potentialTargets.forEach(e => { if (e.dead || e.hp <= 0) return; const dist = (h.x - e.x)**2 + (h.y - e.y)**2; if (dist < closestDist) { closest = e; closestDist = dist; } }); h.target = closest; } if (h.target) { const tx = h.target.x, ty = h.target.y; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); const speed = 350; if (dist > 30) { h.x += (dx / dist) * speed * dt; h.y += (dy / dist) * speed * dt; } else { h.attackT -= dt; if (h.attackT <= 0) { h.attackT = 0.25; let dmg = 8 * store.player.dmgMult; if (h.target === store.boss) dmg *= 0.3; if (!h.target.dead && h.target.hp > 0) { h.target.hp -= dmg; if (h.target.hp <= 0) { h.killCount++; if (h.killCount > 0 && h.killCount % 12 === 0) { playSound('dogs'); } } } } } } else { const tx = store.player.x + h.side * 50, ty = store.player.y + 20; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 5) { h.x += dx * 5 * dt; h.y += dy * 5 * dt; } } }); }
    function drawHound(h) {
        ctx.save();
        ctx.translate(h.x, h.y);
        const time = performance.now();
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time / 1000 + h.side);
        const r = h.r;

        if (!h.isUpgraded) {
            // --- EXISTING DRAW LOGIC for first pair ---
            const { main, accent } = h.color;
            const isTuxedo = accent === '#FFFFFF';

            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.5);
            ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
            ctx.quadraticCurveTo(r * 1.2, 0, r, r);
            ctx.lineTo(-r, r);
            ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.4);
            ctx.lineTo(-r * 0.5, -r * 1.2);
            ctx.lineTo(-r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r, -r * 0.4);
            ctx.lineTo(r * 0.5, -r * 1.2);
            ctx.lineTo(r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();

            if (isTuxedo) {
                ctx.fillStyle = accent;
                ctx.beginPath();
                ctx.moveTo(-r * 0.6, r * 0.2);
                ctx.quadraticCurveTo(0, r, r * 0.6, r * 0.2);
                ctx.lineTo(0, r * 0.5);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
           
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
           
            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.3, r * 0.5, r * 0.4, 0, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, r * 0.5);
            ctx.lineTo(-r * 0.1, r * 0.5);
            ctx.lineTo(-r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.3, r * 0.5);
            ctx.lineTo(r * 0.1, r * 0.5);
            ctx.lineTo(r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
        } else {
             // --- NEW DRAW LOGIC for upgraded pair ---
            const color = h.color.main;
            const opacity = ctx.globalAlpha; // Use the calculated opacity
            const eyeType = h.eyeType;
            const expression = h.expression;
            const radius = r * 1.5; // Make them a bit bigger to match example

            // If it's the crazy one, draw its hat first
            if (h.side === 2) {
                ctx.save();
                ctx.globalAlpha = 0.7 * opacity;
                ctx.fillStyle = '#9966ff';
                ctx.beginPath();
                ctx.moveTo(0, -radius * 1.8);
                ctx.lineTo(-radius * 0.8, -radius * 0.9);
                ctx.lineTo(radius * 0.8, -radius * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Draw main circular body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw pointy ears
            ctx.beginPath();
            ctx.moveTo(-radius * 0.6, -radius * 0.7);
            ctx.lineTo(-radius * 0.4, -radius * 1.2);
            ctx.lineTo(-radius * 0.2, -radius * 0.8);
            ctx.fill();
           
            ctx.beginPath();
            ctx.moveTo(radius * 0.6, -radius * 0.7);
            ctx.lineTo(radius * 0.4, -radius * 1.2);
            ctx.lineTo(radius * 0.2, -radius * 0.8);
            ctx.fill();

            // Draw wavy ghost bottom
            ctx.beginPath();
            ctx.moveTo(-radius, 0);
            for(let i = 0; i <= 6; i++) {
                let waveX = -radius + (radius * 2 / 6) * i;
                let waveY = radius + Math.sin(i * 0.8 + time * 0.005) * radius * 0.2; // use time instead of time++
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(radius, 0);
            ctx.fill();

            // Draw crazy eyes based on type
            ctx.fillStyle = 'white';
           
            if (eyeType === 'dilated') {
                // Left eye - super dilated
                ctx.beginPath();
                ctx.ellipse(-radius * 0.35, -radius * 0.1, radius * 0.28, radius * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
               
                // Right eye - different size for crazy look
                ctx.beginPath();
                ctx.ellipse(radius * 0.35, -radius * 0.15, radius * 0.25, radius * 0.32, 0, 0, Math.PI * 2);
                ctx.fill();
               
                // Pupils - tiny and off-center
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-radius * 0.3 + Math.sin(time * 0.001) * radius * 0.05,
                      -radius * 0.05, radius * 0.08, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.beginPath();
                ctx.arc(radius * 0.4,
                      -radius * 0.2 + Math.cos(time * 0.001) * radius * 0.05,
                      radius * 0.06, 0, Math.PI * 2);
                ctx.fill();
            } else { // 'swirly'
                // Swirly hypnotized eyes
                ctx.beginPath();
                ctx.arc(-radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.beginPath();
                ctx.arc(radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
               
                // Draw swirls in eyes
                ctx.strokeStyle = 'black';
                ctx.lineWidth = radius * 0.04;
               
                // Left eye swirl
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = -radius * 0.35 + Math.cos(t + time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t + time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
               
                // Right eye swirl
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = radius * 0.35 + Math.cos(t - time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t - time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
           
            // Draw vampire fangs
            ctx.fillStyle = 'white';
           
            // Left fang
            ctx.beginPath();
            ctx.moveTo(-radius * 0.25, radius * 0.2);
            ctx.lineTo(-radius * 0.2, radius * 0.5);
            ctx.lineTo(-radius * 0.15, radius * 0.2);
            ctx.fill();
           
            // Right fang
            ctx.beginPath();
            ctx.moveTo(radius * 0.25, radius * 0.2);
            ctx.lineTo(radius * 0.2, radius * 0.5);
            ctx.lineTo(radius * 0.15, radius * 0.2);
            ctx.fill();
           
            // Small middle teeth
            for(let i = -1; i <= 1; i++) {
                if(i === 0) continue;
                ctx.beginPath();
                ctx.moveTo(i * radius * 0.08, radius * 0.2);
                ctx.lineTo(i * radius * 0.08 + radius * 0.02, radius * 0.35);
                ctx.lineTo(i * radius * 0.08 - radius * 0.02, radius * 0.35);
                ctx.fill();
            }
           
            // Draw mouth/expression
            ctx.strokeStyle = expression === 'silly' ? '#000' : '#333';
            ctx.lineWidth = radius * 0.03;
            ctx.beginPath();
           
            if (expression === 'silly') {
                // Wavy silly mouth
                ctx.moveTo(-radius * 0.3, radius * 0.15);
                ctx.quadraticCurveTo(-radius * 0.1, radius * 0.05, 0, radius * 0.15);
                ctx.quadraticCurveTo(radius * 0.1, radius * 0.25, radius * 0.3, radius * 0.15);
            } else {
                // Mischievous grin
                ctx.arc(0, 0, radius * 0.35, Math.PI * 0.2, Math.PI * 0.8);
            }
            ctx.stroke();
        }
        ctx.restore();
    }
    function drawIceman(iceman) {
        const { x, y } = iceman;
        ctx.save();
        ctx.translate(x, y);
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12, 8);
        ctx.lineTo(8, 14);
        ctx.lineTo(0, 10);
        ctx.lineTo(-8, 14);
        ctx.lineTo(-12, 8);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
        bodyGrad.addColorStop(0, "#a0e9ff");
        bodyGrad.addColorStop(1, "#3c9aed");
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d0f8ff";
        ctx.stroke();

        ctx.strokeStyle = "#a0e9ff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 5);
        ctx.lineTo(-20, -2);
        ctx.lineTo(-18, 8);
        ctx.moveTo(12, 5);
        ctx.lineTo(20, -2);
        ctx.lineTo(18, 8);
        ctx.stroke();

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(0, -8, 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    // --- NEW: Lightning draw function ---
    function drawLightningBolt(bolt) {
        const { points, life, maxLife } = bolt;
        const t = life / maxLife;
        if (t <= 0) return;

        ctx.save();
        ctx.lineWidth = 4 * t;
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * t})`;
        ctx.shadowColor = '#9a66ff';
        ctx.shadowBlur = 20 * t;
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        
        // Core glow
        ctx.lineWidth = 1.5 * t;
        ctx.strokeStyle = `rgba(200, 220, 255, ${t})`;
        ctx.shadowBlur = 10 * t;
        ctx.stroke();

        ctx.restore();
    }
    function activateGravityWell() {
        if (!store.isPaused) {
            const spawnX = W * 0.2 + Math.random() * W * 0.6;
            const spawnY = H * 0.2 + Math.random() * H * 0.6;
            store.activeEffects.push(createEffect("gravityWell", spawnX, spawnY));
            announce('GRAVITY WELL ACTIVATED');
            screenFlash(2, 250, 'rgba(255, 255, 255, 0.7)');
        }
    }
    function activateLazarus() {
        if (store.player.hasLazarusBeam && !store.isPaused) {
            const angle = Math.random() * 2 * Math.PI,
                speed = 800,
                p = store.player;
            store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 6, r: 12, hitEnemies: new Set });
            
            // At level 2 (after the second purchase), fire a second beam.
            if (p.upgradeLevels.lazarus_beam > 1) {
                const oppositeAngle = angle + Math.PI;
                store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(oppositeAngle) * speed, vy: Math.sin(oppositeAngle) * speed, life: 6, r: 12, hitEnemies: new Set });
            }
        }
    }
    function useGrenade() {
        if (store.player.grenades > 0 && !store.isPaused) {
            playSound('explosion');
            store.player.grenades--;
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 400;
                store.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 5, col: '#ff8080', dmg: 40 * p.dmgMult,
                    pierce: true, life: 0.8
                });
            }
            store.activeEffects.push(createEffect("shieldBreak", p.x, p.y));
        }
    }
   
    // --- NEW: Stormcaller Ability ---
    function fireChainLightning() {
        const p = store.player;
        const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
        if (allEnemies.length === 0) return;

        let closestDistSq = Infinity;
        let currentTarget = null;
        allEnemies.forEach(e => {
            const distSq = (p.x - e.x)**2 + (p.y - e.y)**2;
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                currentTarget = e;
            }
        });

        if (!currentTarget) return;

        const maxJumps = 6;
        let currentDamage = 95 * p.dmgMult;
        const targetsHit = new Set();
        const chainPoints = [{ x: p.x, y: p.y - 20 }]; // Start from ship's cannon

        for (let i = 0; i < maxJumps && currentTarget; i++) {
            targetsHit.add(currentTarget);
            chainPoints.push({ x: currentTarget.x, y: currentTarget.y });

            let dmg = currentDamage;
            if (currentTarget === store.boss) dmg *= 0.3;
            currentTarget.hp -= dmg;

            let nextTarget = null;
            let nextDistSq = Infinity;
            allEnemies.forEach(e => {
                if (e.dead || targetsHit.has(e)) return;
                const distSq = (currentTarget.x - e.x)**2 + (currentTarget.y - e.y)**2;
                if (distSq < nextDistSq) {
                    nextDistSq = distSq;
                    nextTarget = e;
                }
            });

            currentTarget = nextTarget;
            currentDamage *= 0.90;
        }

        if (chainPoints.length > 1) {
            store.lightningBolts.push({
                points: chainPoints,
                life: 0.4,
                maxLife: 0.4,
                dead: false
            });
        }
    }
   
    // --- VOID STEP ABILITY ---
    const VOIDSTEP = {
        cooldownMs: 2500, // Reduced for more frequent use
        iframeMs: 220,
        riftMs: 600,
        edgePadding: 6
    };
    let lastVoidStep = -9999;
    let invulUntil = 0;
    const rifts = [];
    const blinkFlashes = [];
    function spawnBlinkFlash(x, y, life=200){ blinkFlashes.push({x, y, life, birth: performance.now(), dead:false}); }
    function spawnRift(x1,y1,x2,y2, life=VOIDSTEP.riftMs){
        rifts.push({ x1,y1,x2,y2, birth: performance.now(), life, dead:false });
    }

function clampToField(nx, ny){
    const pad = VOIDSTEP.edgePadding;
    nx = Math.max(pad, Math.min(W - pad, nx));
    ny = Math.max(pad, Math.min(H - pad, ny));
    return { nx, ny };
}

function tryVoidStep(player, target, now = performance.now()){
    const cd = VOIDSTEP.cooldownMs;
    if (now - lastVoidStep < cd) return false;

    const start = { x: player.x, y: player.y };
    let { nx, ny } = clampToField(target.x, target.y);

    if (player.blinkDamage) {
        const dx = nx - start.x;
        const dy = ny - start.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const damage = 150 * player.dmgMult;
       
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dot = (((e.x - start.x) * dx) + ((e.y - start.y) * dy)) / (dist * dist);
            const closestX = start.x + dot * dx;
            const closestY = start.y + dot * dy;
           
            const onSegment = dot > 0 && dot < 1;
            if (onSegment) {
                 const distToLine = Math.sqrt((e.x - closestX)**2 + (e.y - closestY)**2);
                 if (distToLine < e.r + 10) { // 10 is the laser width
                     e.hp -= damage;
                 }
            }
        });
    }

    spawnRift(start.x, start.y, nx, ny, VOIDSTEP.riftMs);

    player.x = nx; player.y = ny;
    invulUntil = now + VOIDSTEP.iframeMs;
    lastVoidStep = now;

    spawnBlinkFlash(nx, ny);
    return true;
}
   
    function updateVoidStepSystems(enemies){
        for (const r of rifts) if (!r.dead) {
        if(performance.now() - r.birth >= r.life) r.dead = true;
        }
        for (const f of blinkFlashes) if (!f.dead) {
        if(performance.now() - f.birth >= f.life) f.dead = true;
        }
        for (let i=rifts.length-1; i>=0; i--) if (rifts[i].dead) rifts.splice(i,1);
        for (let i=blinkFlashes.length-1; i>=0; i--) if (blinkFlashes[i].dead) blinkFlashes.splice(i,1);
    }

    function renderVoidStepSystems(ctx){
        rifts.forEach(r => {
            const t = (performance.now() - r.birth)/r.life;
            if (t>=1) { r.dead = true; return; }
            const a = (1 - t) * 0.8 + 0.2; // Starts more opaque, fades to 20%
            ctx.save();
            ctx.globalAlpha = a;
            ctx.strokeStyle = "#ff99cc"; // More magical color
            ctx.lineWidth = 10 * (1-t); // Thicker trail
            ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 25 * (1-t);
            ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
            ctx.restore();
        });
        blinkFlashes.forEach(f => {
            const t = (performance.now() - f.birth)/f.life;
            if (t>=1) { f.dead = true; return; }
            ctx.save();
            // Outer shockwave
            ctx.globalAlpha = 1 - t;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 4 * (1 - t);
            ctx.shadowColor="#b266ff"; ctx.shadowBlur=20;
            ctx.beginPath();
            ctx.arc(f.x, f.y, 20 + 30 * t, 0, Math.PI*2);
            ctx.stroke();

            // Inner core
            ctx.globalAlpha = 1 - t*t; // Fade out faster at the end
            ctx.beginPath(); ctx.arc(f.x, f.y, 20 * (1-t), 0, Math.PI*2);
            ctx.fillStyle="#ffddff"; ctx.fill();
            ctx.restore();
        });
    }
   
    function playerIsInvulnerable(){ return performance.now() < invulUntil; }
   
    function screenFlash(count, duration, color) {
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                store.activeEffects.push(createEffect("screenFlash", 0, duration, color));
            }, i * (duration / 2));
        }
    }

    // --- PAUSE & MENU LOGIC ---
    const PANELS = ['namePanel', 'pilotPanel', 'scorePanel', 'levelPanel', 'shopPanel', 'storyPanel', 'subclassPanel'];
    function isAnyPanelOpen() {
        return PANELS.some(id => !q(id).classList.contains('hide'));
    }
   
    function pauseGame() {
        if (!store.isPaused) {
            store.isPaused = true;
            q('pauseBtn').classList.add('hide');
        }
    }

    function resumeGame() {
        // Only resume if no other panels are open.
        if (!isAnyPanelOpen()) {
            store.isPaused = false;
            q('pauseBtn').classList.remove('hide');
            q('pauseBtn').textContent = 'PAUSE';
        }
    }
   
    // --- EVENT LISTENERS & INITIALIZATION ---
    function showPilotSelect() {
        pauseGame();
        const panel = q('pilotPanel');
        panel.classList.remove('hide');
        panel.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const genome = card.dataset.genome;
                store.player.pilotGenome = genome;
                panel.classList.add('hide');
                applyGenomeBonus(genome);
                resumeGame();
            }, { once: true });
        });
    }

    function applyGenomeBonus(genome) {
        if (!genome) return;
        // Record the number of bosses defeated when the pilot is chosen.
        store.world.bossesAtPilotSelection = store.world.bosses;
        const p = store.player;
        switch(genome) {
            case 'beef':
                p.hpMax *= 1.2;
                p.hp = p.hpMax;
                break;
            case 'wizard':
                p.multishot += 4; // Changed from = 5 to += 4
                break;
            case 'rocketman':
                // Bonus is handled by missile pickups and flame wall passive
                break;
        }
    }
   
    const SUBCLASSES = {
        rocketman: [
            { id: 'railgunner', name: 'Railgunner', desc: 'Missiles pierce through multiple enemies.', icon: 'rail.png' },
            { id: 'demolitionist', name: 'Demolitionist', desc: 'Missiles explode into smaller cluster bombs on impact.', icon: 'demo.png' }
        ],
        beef: [
            { id: 'juggernaut', name: 'juggernaut', desc: 'Charge ability creates a damaging explosion on impact.', icon: 'jug2.png' },
            { id: 'marauder', name: 'Marauder', desc: 'Gain a second charge for your special ability.', icon: 'marauder.png' }
        ],
        wizard: [
            { id: 'phasestriker', name: 'Phase Striker', desc: 'Blink now damages all enemies you pass through.', icon: 'phase.png' },
            { id: 'stormcaller', name: 'Stormcaller', desc: 'Unlocks a new weapon: a chain lightning cannon.', icon: 'storm.png' }
        ]
    };

    function showSubclassSelect() {
        pauseGame();
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const genome = store.player.pilotGenome;
        const choices = SUBCLASSES[genome];

        if (!choices) {
            resumeGame();
            return;
        }
       
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-subclass="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
       
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const subclassId = card.dataset.subclass;
                store.player.subclass = subclassId;
                applySubclassBonus(subclassId);
                panel.classList.add('hide');
                resumeGame();
            }, { once: true });
        });

        panel.classList.remove('hide');
    }

    function applySubclassBonus(subclass) {
        const p = store.player;

        switch(subclass) {
            case 'railgunner': p.missilePierce = 2; break;
            case 'demolitionist': p.missileCluster = true; break;
            case 'juggernaut': /* Handled in charge logic */ break;
            case 'marauder': p.beefMaxCharges = 2; p.beefCharges = 2; break;
            case 'phasestriker': p.blinkDamage = true; break;
            case 'stormcaller': p.hasChainLightning = true; break;
        }

        // --- ADDED CODE FOR SUBCLASS CHALLENGE ---
        // This line runs every time the function is called, applying the penalty.
        store.world.enemyHealthBonus *= 1.10; // Increase enemy health by 10%
}


    function ensureName(){
        if(!store.name){
            pauseGame();
            q("namePanel").classList.remove("hide");
            q("nameInput").value="";
            setTimeout(()=>q("nameInput").focus(),50)
        } else {
            resumeGame();
            if (store.player.pilotGenome === null) {
                initWave();
            }
        }
    }
   
    q("restartBtn").addEventListener("click", resetGame);
   
    q("saveName").addEventListener("click",()=>{const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}});
   
    const closeShopLogic = () => { q("shopPanel").classList.add('hide'); resumeGame(); const highlighted = document.querySelector('.shop-item.highlight'); if (highlighted) highlighted.classList.remove('highlight'); };
    q("closeShop").addEventListener("click", closeShopLogic);
    q("closeShopTopBtn").addEventListener("click", closeShopLogic);

    q("shopBtn").addEventListener("click", () => {
        if (q('shopPanel').classList.contains('hide')) {
            showShop();
        } else {
            closeShopLogic();
        }
    });

    const closeScoresLogic = () => { q('scorePanel').classList.add('hide'); resumeGame(); };
    q("closeScores").addEventListener("click", closeScoresLogic);
   
    q("menuBtn").addEventListener("click",()=>{
        if (q('scorePanel').classList.contains('hide')) {
            pauseGame();
            q('scorePanel').classList.remove('hide');
        } else {
            closeScoresLogic();
        }
    });

    q("fsEnterBtn").addEventListener('click',()=>{const r=document.documentElement;if(!document.fullscreenElement){if(r.requestFullscreen)r.requestFullscreen();else if(r.webkitRequestFullscreen)r.webkitRequestFullscreen();else if(r.msRequestFullscreen)r.msRequestFullscreen()}else{if(document.exitFullscreen)document.exitFullscreen()}});
   
    q('pauseBtn').addEventListener('click',()=>{
        if(store.isGameOver || isAnyPanelOpen()) return;
        store.isPaused = !store.isPaused;
        q('pauseBtn').textContent = store.isPaused ? 'RESUME' : 'PAUSE';
    });
   
    q('grenadeBtnUI').addEventListener('click',useGrenade);

    q('storyBtn').addEventListener('click', (e) => {
        e.stopPropagation(); // Prevents pilotPanel from capturing the click
        pauseGame();
        q('storyPanel').classList.remove('hide');
    });
    q('storyPanel').addEventListener('click', () => {
        q('storyPanel').classList.add('hide');
        // Don't call resumeGame() if another panel is still meant to be open
        if (!q('pilotPanel').classList.contains('hide')) {
            // It was opened from pilot panel, just close it
        } else {
            resumeGame();
        }
    });
   
    q("nameInput").addEventListener("keydown",(e)=>{if(e.key==="Enter"){const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}}});

    q("namePanel").addEventListener("click", (e) => {
        if(e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
            q('nameInput').blur();
        }
    });
   
    let cheatCodeBuffer = "";
    let cheatTapCount = 0;
    let lastCheatTap = 0;

    function activateDamageOffCheat() {
    if (store.isDamageOff) return; // Cheat is already active
    store.isDamageOff = true;
    store.cheatsUsed = true;
    announce('CHEAT: DAMAGE & ABILITIES OFF');

    const p = store.player;
    const propsToDisable = [
        'dmgMult', 'multishot', 'rearMultishot', 'piercing', 'explosive', 
        'flamethrowerLevel', 'missileVolley', 'critChance', 'critDamage', 
        'hasLauncher', 'hasHounds', 'hasLazarusBeam', 'hasVoidBeam', 
        'hasChainLightning', 'hasIceman', 'blinkDamage', 'missilePierce', 'missileCluster'
    ];
    
    store.savedPlayerState = {};
    propsToDisable.forEach(prop => {
        store.savedPlayerState[prop] = p[prop]; // Save the current value
        // Set the property to a "disabled" state
        if (typeof p[prop] === 'number') {
            p[prop] = 0;
        } else if (typeof p[prop] === 'boolean') {
            p[prop] = false;
        }
    });

    // Special handling for entities that are not simple properties
    store.savedPlayerState.hounds = store.hounds;
    store.hounds = [];
    store.savedPlayerState.iceman = store.iceman;
    store.iceman = null;
}

    function deactivateDamageOffCheat() {
        if (!store.isDamageOff || !store.savedPlayerState) return; // Cheat isn't active or no state saved
        store.isDamageOff = false;
        announce('CHEAT: DAMAGE & ABILITIES ON');

        const p = store.player;
        // Restore all saved properties
        for (const prop in store.savedPlayerState) {
            if (prop === 'hounds') {
                store.hounds = store.savedPlayerState.hounds;
            } else if (prop === 'iceman') {
                store.iceman = store.savedPlayerState.iceman;
            } else if (p.hasOwnProperty(prop)) {
                p[prop] = store.savedPlayerState[prop];
            }
        }
        
        store.savedPlayerState = null; // Clear the saved state
}

    function activateSubclassCheat() {
        // A pilot genome must be selected to see subclass choices.
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        // Don't show if a subclass is already active.
        if (store.player.subclass) {
            announce("CHEAT FAILED: Subclass already chosen.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO SUBCLASS SELECT');
        showSubclassSelect();
    }
   
    function activatePowerCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: POWER UP!');
        resetGame();
        store.world.shards = 800;
        store.player.multishot = 10;
        initWave();
        cheatCodeBuffer = "";
    }

    q('diagBox').children[0].addEventListener('click', () => {
        const now = performance.now();
        if (now - lastCheatTap > 500) {
            cheatTapCount = 0;
        }
        lastCheatTap = now;
        cheatTapCount++;
        if (cheatTapCount >= 3) {
            activatePowerCheat();
            cheatTapCount = 0;
        }
    });

    addEventListener("keydown", e => {
        const key = e.key.toLowerCase();
        if (document.activeElement.tagName === "INPUT") return;

        if (/[a-z]/.test(key)) {
            cheatCodeBuffer += key;
            if (cheatCodeBuffer.length > 10) {
                cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
            }

            if (cheatCodeBuffer.endsWith('power')) {
                activatePowerCheat();
                cheatCodeBuffer = ""; // Reset buffer
            } else if (cheatCodeBuffer.endsWith('off')) {
                activateDamageOffCheat();
                cheatCodeBuffer = ""; // Reset buffer
            } else if (cheatCodeBuffer.endsWith('on')) {
                deactivateDamageOffCheat();
                cheatCodeBuffer = ""; // Reset buffer
            } else if (cheatCodeBuffer.endsWith('spec')) { // <-- ADD THIS BLOCK
                activateSubclassCheat();
                cheatCodeBuffer = ""; // Reset buffer
            }
        } else {
            if (key !== ' ' && key !== 'b') {
                cheatCodeBuffer = "";
            }
        }

        if (key === ' ') { e.preventDefault(); useGrenade() }
    });

    let lastTapTime = 0;
    cvs.addEventListener('touchend', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'wizard' && !store.isPaused && !store.isGameOver) {
            const now = performance.now();
            const DOUBLE_TAP_DELAY = 300; // ms
            if (now - lastTapTime < DOUBLE_TAP_DELAY) {
                const p = pointFromEvent(e);
                tryVoidStep(store.player, p);
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: false });

    cvs.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'wizard' && !store.isPaused && !store.isGameOver) {
            const p = pointFromEvent(e);
            tryVoidStep(store.player, p);
        }
    });

    function frame(now) {
        const dt = Math.min((now - store.last) / 1000, 0.07);
        store.last = now;
        if (!store.isPaused && !store.isGameOver) {
            stepWorld(dt);
        }
        render(dt);
        requestAnimationFrame(frame);
    }
    try{
        ensureName();
        refreshScoreList();
        requestAnimationFrame(frame)
    }catch(error){
        console.error("Game initialization failed:",error);
        try{
            updateLeaderboard(null);
            ensureName();
            requestAnimationFrame(frame);
            console.log("Game started in offline mode")
        }catch(criticalError){
            console.error("Critical startup failure:",criticalError);
            // Intentionally not using alert as it's disabled. Error is logged.
        }
    }
   
})();
</script>
</body>
</html>
