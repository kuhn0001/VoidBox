<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 98vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        
        /* Hide VS Code browser controls */
        .monaco-workbench .part.titlebar, 
        .vs-dark .monaco-workbench .part.titlebar,
        .titlebar,
        .browser-close-button,
        .browser-action-buttons,
        .monaco-action-bar {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            opacity: 0 !important;
        }

        .close-btn {
            position: absolute;
            top: 8px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 20px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 4px;
        }
        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Hide only the specific problematic close buttons */
        #closeScores {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        /* More aggressive hiding of browser UI */
        body {
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden;
        }
        
        /* Hide any top-level browser chrome */
        :root {
            --browser-chrome-height: 0px;
        }
        
        #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:0;}
        .stage{width:100vw; height:100svh; position:relative;display:grid;place-items:center;background:#000;border-radius:0;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
        canvas{background:transparent;border-radius:16px;touch-action:none;cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }
        #diagBox{position:absolute;left:8px;top:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:left;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s; font-family: 'Orbitron', 'Audiowide', ui-sans-serif;}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        
        .panel{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:rgba(26,0,34,.95);
            border:1px solid var(--accent);
            border-radius:16px;
            padding:12px;
            width:min(600px, 90vw);
            backdrop-filter:blur(12px);
            color:#ffddff;
            box-shadow:0 0 40px rgba(178,102,255,.3);
            z-index:100;
        }
        
        /* Expanded panel for skill tree */
        #subclassPanel.skill-tree-active {
            width: min(950px, 95vw);
        }
        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }
        #shopPanel h2, #levelPanel h2, #scorePanel h2, #namePanel h2, #pilotPanel h2, #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }
        #shopPanel p, #levelPanel p, #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }
        #shopGrid, #scorePanel div {
            max-height: 60vh; 
            overflow-y: auto;
            padding-right: 8px;
        }
        .grid{
            display:grid;
            gap:8px;
            grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
        }
        .hide{display:none!important}
        #belowBoard{width:min(98vw,var(--maxw));margin:50px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        
        .skill-card {
            background: radial-gradient(circle, rgba(51,0,68,1) 0%, rgba(51,0,68,0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        
        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }
        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }
        .skill-title{
            font-weight:700;
            color:#c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }
        .skill-desc{
            font-size:11px;
            color:#ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }
        .skill-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
            padding: 30px;
            max-width: 900px;
            margin: 0 auto;
        }
        .skill-grid {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 60px;
        }
        .skill-card-node-pair {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            width: 100%;
        }
        
        /* SKILL TREE - Portrait-oriented Icon Button System */
        .skill-track {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .track-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        .skill-icon-button {
            position: relative;
            width: 180px;
            height: 200px;
            cursor: pointer;
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.4s ease;
            border: 3px solid transparent;
        }
        .skill-icon-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: all 0.4s ease;
        }
        .skill-icon-image.enhanced {
            filter: brightness(1.3) saturate(1.2) drop-shadow(0 0 12px rgba(255,215,0,0.8));
        }
        .skill-info-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.8) 30%, rgba(0,0,0,0.95) 100%);
            padding: 15px 12px 12px;
            transform: translateY(70%);
            transition: all 0.4s ease;
        }
        .skill-overlay-title {
            font-size: 14px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 6px;
            text-align: center;
        }
        .skill-overlay-desc {
            font-size: 10px;
            color: #cccccc;
            line-height: 1.3;
            text-align: center;
        }
        
        /* SKILL ICON BUTTON STATES */
        .skill-icon-button.available {
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        .skill-icon-button.available:hover {
            border-color: #66BB6A;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            transform: translateY(-5px) scale(1.05);
        }
        .skill-icon-button.available:hover .skill-info-overlay {
            transform: translateY(0%);
        }
        .skill-icon-button.available:hover .skill-icon-image {
            filter: brightness(1.2) saturate(1.1);
        }
        
        .skill-icon-button.active {
            border-color: #FFD700;
            background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, rgba(255,215,0,0.2) 100%);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1);
            animation: activeIconGlow 3s ease-in-out infinite;
        }
        .skill-icon-button.active .skill-icon-image {
            filter: brightness(1.4) saturate(1.3) drop-shadow(0 0 15px rgba(255,215,0,0.9));
        }
        .skill-icon-button.active .skill-info-overlay {
            transform: translateY(0%);
            background: linear-gradient(180deg, transparent 0%, rgba(255,215,0,0.1) 30%, rgba(0,0,0,0.9) 100%);
        }
        
        .skill-icon-button.locked {
            border-color: #333;
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.7);
        }
        .skill-icon-button.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        /* BEAUTIFUL GLOW ANIMATIONS */
        @keyframes activeIconGlow {
            0% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 215, 0, 1.0), inset 0 0 25px rgba(255,255,255,0.2), 0 0 50px rgba(135,206,235,0.3); }
            100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
        }
        
        /* Old skill node classes for compatibility */
        
        /* Beautiful Marble/Lightning Animations */
        @keyframes marbleSwirl {
            0% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
            25% { background: linear-gradient(225deg, #e6e6fa 0%, #f5f5dc 30%, #f8f8ff 60%, #dcdcdc 100%); }
            50% { background: linear-gradient(315deg, #dcdcdc 0%, #f8f8ff 30%, #f5f5dc 60%, #e6e6fa 100%); }
            75% { background: linear-gradient(45deg, #f5f5dc 0%, #dcdcdc 30%, #e6e6fa 60%, #f8f8ff 100%); }
            100% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
        }
        
        @keyframes lightningPulse {
            0% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
            50% { box-shadow: 0 0 15px rgba(255,215,0,0.8), inset 0 0 12px rgba(255,255,255,0.6), 0 0 25px rgba(135,206,235,0.4); }
            100% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
        }
        .skill-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .skill-node.active, .skill-combo-node.active {
            border-color: #FFD700;
            background: #2a2a4e;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        .skill-node.locked, .skill-combo-node.locked {
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skill-combo-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .skill-tree-title {
            font-size: 18px;
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        .skill-description {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            min-height: 40px;
            color: #ffddff;
            font-size: 12px;
        }
        .ability-hint {
            font-size: 10px;
            color: #87CEEB;
            text-align: center;
            margin-top: 6px;
            font-style: italic;
            text-shadow: 0 0 4px rgba(135, 206, 235, 0.5);
        }
        .ability-icon {
            font-size: 12px;
            margin: 0 2px;
            display: inline-block;
            animation: pulse-glow 2s infinite;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }
        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }
        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }
        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn{
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.4;
            transition: opacity 0.3s ease-in-out;
        }
        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }
        
        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }
        #bottom-right-controls > .fixed-btn {
            position: static;
        }

        #menuBtn, #fsEnterBtn, #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }
        #pauseBtn {
            top: 50%;
            right: 15px; 
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif; box-sizing: border-box;}
        
        #abilityBar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 6; pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }
        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }
        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }
        
        .shop-item-attack { border-color: #00bfff; }
        .shop-item-health { border-color: #00ff00; }
        .shop-item-utility { border-color: #ffd700; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
            50% { box-shadow: 0 0 35px rgba(102, 255, 178, 1); }
            100% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
        }
        @keyframes pulse-glow-ability {
            0% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
            50% { box-shadow: 0 0 20px rgba(178, 102, 255, .8); }
            100% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
        }
        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(500px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
        
        /* Matrix Rain Effect */
        .matrix-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
            z-index: -1;
            pointer-events: none;
        }

        .matrix-column {
            position: absolute;
            top: 0;
            width: 18px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            pointer-events: none;
            will-change: transform;
        }

        .matrix-char {
            position: absolute;
            display: block;
            line-height: 20px;
            width: 100%;
            transition: none;
            transform: translateZ(0); /* Force GPU acceleration */
        }

        /* Purple gradient classes for different brightness levels */
        .bright {
            color: #e6ccff;
            text-shadow: 0 0 5px #cc99ff, 0 0 10px #cc99ff;
        }

        .medium {
            color: #b366ff;
            text-shadow: 0 0 3px #9933ff;
        }

        .dim {
            color: #6600cc;
            text-shadow: 0 0 2px #6600cc;
        }

        .faded {
            color: #330066;
            opacity: 0.7;
        }

        .very-faded {
            color: #1a0033;
            opacity: 0.4;
        }
        
    </style>
</head>
<body>
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide"></div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card"></div>
                        <div id="hudPilotContent" class="hud-card"></div>
                        <div id="hudBossContent" class="hud-card hide"></div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide"></div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <div class="chip">v3.8.0</div>
                    <div class="chip">FPS <span id="fps">‚Äî</span></div>
                    <div class="chip">DPS <span id="dps">‚Äî</span></div>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üöÄ PILOT LOST üöÄ</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <button id="storyBtn" type="button">i</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">A charging juggernaut that automatically retaliates against nearby foes.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN"></div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">A master of explosive ordnance who commands devastating missile strikes.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="wizard">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER"></div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">An ethereal pilot who can blink through the void itself.</div>
                                <div class="ability-hint">
                                    <span class="ability-icon">üñ±Ô∏è</span> Right-click or 
                                    <span class="ability-icon">üëÜüëÜ</span> double-tap to teleport
                                </div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                     <div id="subclassPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                        </div>
                        <div id="skillTree" class="skill-tree hide">
                            <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                            <div class="skill-tree-title">BEEF SPECIALIZATION TREE</div>
                            <div class="skill-grid">
                                <!-- Tier 1: Base subclass choices -->
                                <div class="skill-row">
                                    <div class="skill-track">
                                        <div class="track-title">MARAUDER</div>
                                        <div class="skill-icon-button available" data-skill="marauder" data-tier="1">
                                            <img src="marauder.png" alt="Marauder" class="skill-icon-image">
                                            <div class="skill-info-overlay">
                                                <div class="skill-overlay-title">MARAUDER</div>
                                                <div class="skill-overlay-desc">Rapid assault specialist with multiple charges for sustained combat dominance</div>
                                            </div>
                                        </div>
                                        <div class="skill-icon-button locked" data-skill="marauder_enhanced" data-tier="2" data-parent="marauder">
                                            <img src="marauder.png" alt="Triple Charge" class="skill-icon-image enhanced">
                                            <div class="skill-info-overlay">
                                                <div class="skill-overlay-title">TRIPLE CHARGE</div>
                                                <div class="skill-overlay-desc">MASTERY: Enhanced marauder with three devastating charges</div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="skill-track">
                                        <div class="track-title">JUGGERNAUT</div>
                                        <div class="skill-icon-button available" data-skill="juggernaut" data-tier="1">
                                            <img src="jug.png" alt="Juggernaut" class="skill-icon-image">
                                            <div class="skill-info-overlay">
                                                <div class="skill-overlay-title">JUGGERNAUT</div>
                                                <div class="skill-overlay-desc">Heavy assault specialist with devastating explosive impact attacks</div>
                                            </div>
                                        </div>
                                        <div class="skill-icon-button locked" data-skill="juggernaut_enhanced" data-tier="2" data-parent="juggernaut">
                                            <img src="jug.png" alt="Big Bang" class="skill-icon-image enhanced">
                                            <div class="skill-info-overlay">
                                                <div class="skill-overlay-title">BIG BANG</div>
                                                <div class="skill-overlay-desc">MASTERY: Enhanced juggernaut with massive explosion radius</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="skill-description" id="skillDescription">
                                Choose your specialization path: Marauder for sustained assault, Juggernaut for devastating impact. Select both for the ultimate combo!
                            </div>
                        </div>
                    </div>
                    <div id="storyPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                        Mammalian life developed specialized spacecraft to venture within and colonize the resources of the primitive creatures.<br><br>
                        The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üíÄ CALLSIGN üíÄ</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">üèÜ Aces of the Void üèÜ</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent);">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <button type="button" class="close-btn" id="closeShopTopBtn">√ó</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° MECH FORGE ‚ö°</h2>
                        <button id="skillTreeBtn" class="btn skill-tree-button" type="button" style="margin:10px auto; display:block; font-size:12px; opacity:0.5; pointer-events:none;" disabled>üå≥ SKILL TREE</button>
                        <p style="color:#ffddff">Available Shards: <span id="shopShards">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>‚ö° Aces of the Void ‚ö°</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioHeartbeat" src="heartbeat.mp3" preload="auto"></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>
    <audio id="audioCharge" src="charge.m4a" preload="auto"></audio>
    <audio id="audioBeefCharge" src="beefcharge.m4a" preload="auto"></audio>
    <audio id="audioEpicHorn" src="epichorntrimmed.m4a" preload="auto"></audio>
    <audio id="audioCluster" src="cluster.mp3" preload="auto"></audio>
    <audio id="audioThunder" src="thunder.mp3" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">‚ö° MECH FORGE</button>
        <button id="menuBtn" class="fixed-btn" type="button">üèÜ TOP PILOTS</button>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://interest-christine-kingdom-excerpt.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => {
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height),
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    const pointFromEvent = (e) => {
        const r = cvs.getBoundingClientRect();
        let touch = e;
        if (e.changedTouches && e.changedTouches.length > 0) {
            touch = e.changedTouches[0];
        } else if (e.touches && e.touches.length > 0) {
            touch = e.touches[0];
        }
        const cx = touch.clientX;
        const cy = touch.clientY;
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
    };


    // --- NEW FLAME PARTICLE CLASS ---
class FlameParticle {
    constructor(x, y, attachedEnemy = null) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 40; // Less horizontal spread
        this.vy = -20 - Math.random() * 30; // Slower upward drift
        this.life = 8.4 + Math.random() * 5.6; // 40% longer: 8.4-14 seconds (was 6-10)
        this.maxLife = this.life;
        this.visualLife = this.life * 1.5; // Visual effect lasts 50% longer than mechanics
        this.maxVisualLife = this.visualLife;
        this.size = 8 + Math.random() * 8; // Smaller, more varied sizes
        this.attachedEnemy = attachedEnemy;
        this.damage = 0.45;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.5 + Math.random() * 1;
        this.heat = 0.8 + Math.random() * 0.2; // Start hot
        this.flickerOffset = Math.random() * 1000;
        this.baseSize = this.size;
        this.gravity = 15; // Slight downward pull for realistic behavior
        this.isDying = false;
    }

    update(dt) {
        this.life -= dt;
        this.visualLife -= dt;
        if (this.visualLife <= 0) return false; // Remove particle when visual effect ends

        // Physics - only apply when mechanically active
        if (this.life > 0) {
            this.vy += this.gravity * dt;
            this.vy -= 25 * dt;
            this.x += this.vx * dt;
            this.y += this.vy * dt;

            // Air resistance
            this.vx *= 0.98;
            this.vy *= 0.98;

            // Wobble
            this.wobble += this.wobbleSpeed * dt;
            this.x += Math.sin(this.wobble) * 8 * dt;
        }

        // Heat and void effect - based on VISUAL life for slower fade
        const visualLifeRatio = this.visualLife / this.maxVisualLife;
        this.heat = Math.max(0.2, visualLifeRatio * 0.8); // Minimum heat to avoid pure transparency

        // Size changes - based on visual life for slower shrinking
        if (visualLifeRatio > 0.7) {
            this.size = this.baseSize * (1 + (1 - visualLifeRatio) * 2); // Grow when young
        } else {
            this.size = Math.max(this.baseSize * 0.5, this.baseSize * visualLifeRatio); // Don't shrink below 50% of base
        }

        this.isDying = visualLifeRatio < 0.3;
        return true;
    }

    draw() {
        if (this.visualLife <= 0 || this.size <= 0) return;
        if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;

        const alpha = this.heat;
        
        // Simple flame with just 3 circles - no crackling, no sparkles
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Outer glow - simple and clean
        ctx.fillStyle = `rgba(60, 30, 100, ${alpha * 0.2})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 1.2, 0, 6.283185);
        ctx.fill();
        
        // Middle flame
        ctx.fillStyle = `rgba(100, 50, 150, ${alpha * 0.4})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.7, 0, 6.283185);
        ctx.fill();
        
        // Core flame
        ctx.fillStyle = `rgba(140, 70, 190, ${alpha * 0.6})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.3, 0, 6.283185);
        ctx.fill();
        
        ctx.restore(); // Reset blending mode
    }
}


    cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
    cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    
    // --- AUDIO ---
    const bgm = q('bgmAudio');
    const sounds = {
        explosion: q('audioExplosion'),
        horn: q('audioHorn'),
        hit: q('audioHit'),
        trap: q('audioTrap'),
        dogs: q('audioDogs'),
        heartbeat: q('audioHeartbeat'),
        charge: q('audioCharge'),
        beefCharge: q('audioBeefCharge'),
        epicHorn: q('audioEpicHorn'),
        cluster: q('audioCluster'),
        thunder: q('audioThunder')
    };
    let lastExplosionSoundTime = 0;
    let lastBossHitSoundTime = 0;
    let lastClusterSoundTime = 0;
    
    function playSound(name) {
        const audio = sounds[name];
        if (!audio) return;
        const now = performance.now();
        if (name === 'explosion') {
            if (now - lastExplosionSoundTime < 50) return;
            lastExplosionSoundTime = now;
        }
        if (name === 'cluster') {
            if (now - lastClusterSoundTime < 150) return; // Increased from 60ms to 150ms
            lastClusterSoundTime = now;
        }
        if (name === 'hit') {
            if (now - lastBossHitSoundTime < 100) return;
            lastBossHitSoundTime = now;
        }
        audio.currentTime = 0;
        audio.play().catch(e => {});
    }


    // --- GAME STATE & DATA ---
    const player_initial_state = {
        x: W / 2, y: H * 0.8, r: 14, hp: 100, hpMax: 100, fireT: 0, speed: 380, dmgMult: 1, fireRate: 0.18,
        vampirism: 0, shield: 0, shieldMax: 0, multishot: 1, isInvincible: false, piercing: 0, explosive: false,
        hasShieldBubble: false, powerupTimers: {},
        upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0, launcher: 0, lazarus_beam: 0, gravity_well: 0 },
        grenades: 0, hasVoidBeam: false, voidBeamCooldown: 0,
        hasLazarusBeam: false, lazarusBeamCooldown: 0,
        hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 0, vampirismLevel: 0, flamethrowerLevel: 0,
        flamethrowerT: 0, // Separate timer for lava chunks, unaffected by overclock
        luckBoost: 0, magnetRadius: 0, hasIceman: false, critChance: 0.02, critDamage: 2,
        pilotGenome: null, missileVolley: 2,
        hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
        rearMultishot: 0, addFrontNext: true,
        flameWallCooldown: 0,
        flameWallActiveT: 0,
        beefChargeState: 'ready', beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 1, beefMaxCharges: 1,
        beefDoubleCharge: false, beefBigExplosion: false, // New skill tree abilities
        hasChainLightning: false, chainLightningCooldown: 0,
        subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false,
        enhancedClusters: false, enhancedPierce: false, hasStormcaller: false, hasPhasestriker: false,
        // Void caller enhanced options
        hasDoubleStorm: false, hasHybridVoid: false, hasImpactPhase: false,
        // Skill tree progress
        skillPoints: 0, skillPointsSpent: 0, skillTree: { juggernaut: false, marauder: false, double_charge: false, big_explosion: false, triple_charge: false },
        clusterSoundCounter: 0,
        // EMP nova effects
        empDisabled: false, empDisabledTimer: 0
    };
    
    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        isDamageOff: false,
        savedPlayerState: null,
        world: { 
            wave: 1, 
            score: 0, 
            shards: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            isLowHealth: false
        },
        player: { ...player_initial_state },
        boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], missiles: [], lasers: [], mines: [], activeEffects: [],
        flameParticles: [],
        lightningBolts: [],
        empNovas: [],
        iceman: null,
        _startTs: performance.now(),
        cheatInvincibilityCooldown: 0,
        cheatDogHealCooldown: 0,
        heartbeatT: 0,
        cheatsUsed: false
    };

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', icon: 'üí•', desc: '+7% damage', apply: () => { store.player.dmgMult *= 1.07; } },
        { id: 'fire', name: 'OVERCLOCK', icon: 'üî•', desc: '+7% fire rate', apply: () => { store.player.fireRate *= 0.70; } },
        { id: 'multi', name: 'SCATTER PROTOCOL', icon: '‚òÑÔ∏è', desc: '+1 projectile', apply: () => {
            const p = store.player;
            if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
        }},
        { id: 'shield', name: 'VOID SHIELD', icon: 'üõ°Ô∏è', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'flamethrower', name: 'LAVA CHUNKS', icon: 'üåã', desc: 'Spews chunks of molten rock in a cone.', apply: () => { store.player.flamethrowerLevel++; } }
    ];
    
    const SHOP_UPGRADES = {
        'repair': { name: "NANO REPAIR", icon: 'üîß', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'vampirism': {
            name: "VAMPIRIC ROUNDS", icon: 'ü©∏', isPremium: true, max: 4, category: 'utility',
            apply: () => {
                const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                if (store.world.shards >= cost && p.vampirismLevel < 4) { store.world.shards -= cost; p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
            },
            desc: () => {
                const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
            }
        },
        'hp': { name: "MAX HP", icon: '‚ù§Ô∏è', baseCost: 20, scale: 1.4, maxLevel: 10, category: 'health', effect: () => { store.player.hpMax += 10; store.player.hp += 10; }, desc: level => `+10 Max HP (Lvl ${level + 1})` },
        'nano_save': { name: "NANO SAVE", icon: 'üíæ', cost: 25, isPremium: true, max: 3, category: 'utility', apply: () => { if (store.player.nanoSaves < 3) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Auto-heals on low HP. Charges: ${store.player.nanoSaves}/3` },
        'luck_boost': { name: "LUCK BOOST", icon: 'üçÄ', baseCost: 25, scale: 2, maxLevel: 5, category: 'utility', effect: (level) => { store.player.luckBoost = (store.player.luckBoost || 0) + (0.15 / Math.pow(2, level)); }, desc: level => `+${(0.15 / Math.pow(2, level) * 100).toFixed(1)}% drop chance (Lvl ${level + 1})` },
        'dmg': { name: "DAMAGE", icon: 'üí™', baseCost: 25, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.07, desc: level => `+7% Damage (Lvl ${level + 1})` },
        'crit_chance': { name: "SHINOBI REFLEXES", icon: 'ü•∑', baseCost: 20, increment: 12, maxLevel: 10, category: 'attack', effect: () => { store.player.critChance *= 1.5; store.player.critDamage *= 1.5; }, desc: level => `+50% Crit Chance & Dmg (Lvl ${level + 1})` },
        'speed': { name: "SPEED", icon: 'üöÄ', baseCost: 30, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
        'grenade': { name: "NOVA GRENADE", icon: 'üí•üí£üí•', cost: 35, isPremium: true, max: 3, category: 'attack', apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'max_shield': { 
            name: "MAX SHIELD", 
            icon: 'üõ°Ô∏è', 
            baseCost: 40, 
            scale: 1.8, 
            maxLevel: 20, // Increased max level
            category: 'health', 
            effect: (level) => { 
                const p = store.player;
                if (level < 5) {
                    // First 5 levels: +25 flat shield
                    p.shieldMax += 25; 
                    p.shield += 25;
                } else {
                    // Levels 6+: +25% of current max shield
                    const increase = Math.floor(p.shieldMax * 0.25);
                    p.shieldMax += increase;
                    p.shield += increase;
                }
            }, 
            desc: level => {
                if (level < 5) {
                    return `+25 Max Shield (Lvl ${level + 1})`;
                } else {
                    return `+25% Max Shield (Lvl ${level + 1})`;
                }
            }
        },
        'mine_wall': { name: "MINE WALL", icon: 'üí£', cost: 40, isPremium: true, max: 2, category: 'attack', apply: () => { const activeWalls = store.mines.filter(m => m.isWallMine).length > 0; if(!activeWalls) { deployMineWall(); return true; } return false; }, desc: () => `Deploy a wall of mines.` },
        'rear_guard': { name: 'AFT FLANKSHIELD', icon: 'üõ°Ô∏è‚ú®', baseCost: 65, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
        'launcher': {
                name: 'FRAG LAUNCHER',
                icon: 'üí•',
                baseCost: 50,
                scale: 2,
                maxLevel: 3,
                category: 'attack',
                effect: () => {
                    store.player.hasLauncher = true;
                },
                desc: level => {
                    if (level === 0) return `Unlocks launcher (2 projectiles).`;
                    if (level === 1) return `Add 2 projectiles (4 total).`;
                    if (level === 2) return `Add 2 more projectiles (6 total).`;
                    return "Max projectiles reached.";
                }
            },
        'iceman': { name: "THE ICEMAN", icon: '‚ùÑÔ∏è', cost: 59, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.hasIceman) { store.player.hasIceman = true; store.iceman = { x: store.player.x, y: store.player.y + 50, t: 0 }; return true; } return false; }, desc: () => `A clone mirrors your attacks.` },
        'lazarus_beam': { name: "LORD LAZARUS", icon: '‚ò¢Ô∏è‚òÑÔ∏è‚ò¢Ô∏è', baseCost: 100, scale: 3, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Lazarus smites foes twice as often.'; if (level === 1) return 'Lazarus fires two beams at once.'; return 'Max Level'; }},
        'magnet_pull': { name: "GRAV-PULSE", icon: 'üß≤', cost: 45, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
        'gravity_well': { name: "GRAVITY WELL", icon: 'üï≥Ô∏è', baseCost: 150, scale: 2, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; }}, desc: level => { if (level === 0) return 'Unleash a singularity that traps and crushes foes.'; if (level === 1) return 'Summon a second, smaller singularity.'; return 'Max Level'; }},
        'ghost_hounds': { name: "GHOST HOUNDS", icon: 'üëªüê∫', baseCost: 75, scale: 2, maxLevel: 2, category: 'attack', effect: () => { if (!store.player.hasHounds) { store.player.hasHounds = true; store.hounds = [createHound(-1), createHound(1)]; } else { store.hounds.push(createHound(-2)); store.hounds.push(createHound(2)); } playSound('dogs'); }, desc: level => { if (level === 0) return `Unlocks 2 spectral hounds.`; if (level === 1) return `Add 2 more hounds.`; return "Max hounds reached."; } }
    };
    
    const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: '‚¨ÜÔ∏è', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'üöÅ', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'üõ°Ô∏è', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: '‚ù§Ô∏è', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'üöÄ', duration: 20, type: 'timed' }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) {
        if (store.world.powerupCooldown > 0) return;
        const p = store.player;
        const baseChance = 0.075;
        const wave = store.world.wave;
        const waveReductionFactor = 0.0025;
        let finalChance = Math.max(0.025, baseChance - (wave - 1) * waveReductionFactor);
        let types = Object.keys(POWERUP_TYPES);
        let bonusType = null;
        if (p.pilotGenome === 'beef') {
            if (Math.random() < 0.25) bonusType = 'shield';
            else if (Math.random() < 0.15) bonusType = 'repair';
        }
        if (p.pilotGenome === 'rocketman' && Math.random() < 0.2) {
            finalChance *= 1.5;
            bonusType = 'missile';
        }
        const roll = Math.random();
        if (roll > finalChance && !bonusType) return;
        let typeKey;
        if (bonusType && (roll <= finalChance || Math.random() < 0.5)) {
            typeKey = bonusType;
        } else {
            typeKey = types[Math.floor(Math.random() * types.length)];
        }
        store.powerups.push({ x, y, r: 12, type: typeKey });
        store.world.powerupCooldown = 5;
    }
    
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
        if (typeKey === 'missile') {
            if (p.pilotGenome === 'rocketman') { p.missileVolley = Math.min(5, p.missileVolley + 2); } else { p.missileVolley = 2; }
        }
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
            else {
                if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') {
                const p = store.player;
                if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                announce('SCATTER SHOT!');
            }
        }
        announce(powerup.name);
    }

    function initWave() {
        const isBossWave = store.world.wave % 5 === 0;
        if (isBossWave) {
            store.enemies = [];
            const bossHpScale = 1 + (store.world.wave / 5 - 1) * 1.5;
            store.boss = createBoss(bossHpScale);
            store.world.bossSpawnTime = performance.now();
            if (store.boss.name === 'TRAP KING') playSound('trap');
            else if (store.boss.name === 'CORE MALIGNUS') playSound('horn');
            announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
        } else {
            store.enemies = [];
            // Enemy density optimization for performance - halve spawn count but double health at mid-game
            const isOptimizedWave = store.world.wave >= 37 && store.world.level >= 17;
            const baseSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
            const spawnCount = isOptimizedWave ? Math.max(1, Math.floor(baseSpawnCount / 2)) : baseSpawnCount;
            
            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter'];
                if (store.world.wave > 3) types.push('phantom');
                if (store.world.wave > 5) types.push('mech');
                if (store.world.wave > 7) types.push('angler');
                if (store.world.wave > 9) types.push('manta');
                const enemy = spawnEnemy(types[Math.floor(Math.random() * types.length)]);
                
                // Double health for optimized waves to maintain difficulty
                if (isOptimizedWave) {
                    enemy.hp *= 2;
                    enemy.hpMax *= 2;
                }
                
                store.enemies.push(enemy);
            }
            store.world.waveStartTime = performance.now();
            announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
        }
    }
    
    function createBoss(scale) {
        const bossCycle = Math.floor((store.world.wave - 5) / 5) % 5;
        const types = [
            { name: 'VOID SENTINEL', baseHp: 1300, r: 55, behavior: 'sentinel', color: '#8B4A9C' },
            { name: 'NEXUS PHANTOM', baseHp: 1500, r: 50, behavior: 'hex', color: '#66aaff'},
            { name: 'NEURAL CORE', baseHp: 1800, r: 60, behavior: 'malignus', color: '#2E8B57' },
            { name: 'DEATH ENGINE', baseHp: 9000, r: 90, behavior: 'construct', color: '#e54d24', phase: 1, isLaughing: false, laughStartTime: 0, visible: true },
            { name: 'HIVE SOVEREIGN', baseHp: 7200, r: 85, behavior: 'broodlord', color: '#2d5016' }
        ];
        const type = types[bossCycle];
        let hp = type.baseHp * scale * store.world.bossHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks > 0 ? 0.4 + (store.world.collarStacks - 1) * 0.1 : 0);
        hp *= collarBonus;
        
        const boss = { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, isEnraged: false, attackPhase: 0, phaseTimer: 0 };
        
        // Create Boss class instance for DEATH ENGINE
        if (boss.name === 'DEATH ENGINE') {
            boss.skullRenderer = new Boss(ctx, boss.x, boss.y, boss.color);
        }
        
        return boss;
    }

    function spawnEnemy(type = 'drone') {
        const cfgs = {
            drone: { r: 10, v: 80, vx: 0, hp: 25, color: '#C0C0C0', xp: 5, score: 50, shards: 1, fireRateChance: 0.004 },
            hunter: { r: 20, v: 100, vx: 0, hp: 20, color: '#DC143C', xp: 8, score: 80, shards: 1, fireRateChance: 0.005 },
            trap_king_add: { r: 6, v: 90, vx: 0, hp: 10, color: '#ffc83d', damage: 5, xp: 2, score: 10, shards: 1 },
            phantom: { r: 14, v: 90, vx: 0, hp: 40, color: '#FFFFFF', xp: 10, score: 100, shards: 2, fireRateChance: 0.006, fireCooldown: 1.5 },
            mech: { r: 18, v: 40, vx: 0, hp: 90, color: '#FF8500', xp: 15, score: 150, shards: 3, fireRateChance: 0.007, attackPhase: 0 },
            construct_shard: { r: 10, v: 120, vx: 0, hp: 15, color: '#e03434', xp: 3, score: 30, shards: 1 },
            avian_hatchling: { r: 8, v: 150, vx: 0, hp: 20, color: '#9370DB', xp: 4, score: 40, shards: 1 },
            angler: { r: 22, v: 30, vx: 0, hp: 120, color: '#00008b', xp: 18, score: 180, shards: 4, fireRateChance: 0.008 },
            manta: { r: 26, v: 50, vx: 0, hp: 150, color: '#53B6FF', xp: 22, score: 220, shards: 5, fireRateChance: 0.009 }
        };
        let c = { ...cfgs[type] }; const wave = store.world.wave;
        c.hp *= Math.pow(1.075, wave) * store.world.enemyHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks > 0 ? 0.4 + (store.world.collarStacks - 1) * 0.1 : 0);
        c.hp *= collarBonus;
        const e = { ...c, type, x: 20 + Math.random() * (W - 40), y: -50 - Math.random() * 250, hpMax: c.hp, phase: type === 'phantom', t: 0, fireT: (c.fireCooldown || 0), isBursting: false, burstTimer: 0, stunTimer: 0, knockback: null };
        if (e.type === 'manta') { e.startX = e.x; e.amplitude = 150 + Math.random() * 100; e.frequency = 0.5 + Math.random() * 0.5; }
        return e;
    }

    function stepPlayer(dt) {
        const p = store.player;
        if (p.pilotGenome === 'beef' && p.beefChargeState !== 'ready') {
            p.beefChargeT += dt;
            const chargeDuration = 0.25; const returnDuration = 0.35;
            if (p.beefChargeState === 'charging') {
                const progress = Math.min(p.beefChargeT / chargeDuration, 1);
                p.x = p.beefChargeOrigin.x + (p.beefChargeTarget.x - p.beefChargeOrigin.x) * progress;
                p.y = p.beefChargeOrigin.y + (p.beefChargeTarget.y - p.beefChargeOrigin.y) * progress;
                if (progress >= 1) { p.beefChargeState = 'returning'; p.beefChargeT = 0; }
            } else if (p.beefChargeState === 'returning') {
                const progress = Math.min(p.beefChargeT / returnDuration, 1);
                p.x = p.beefChargeTarget.x + (p.beefChargeOrigin.x - p.beefChargeTarget.x) * progress;
                p.y = p.beefChargeTarget.y + (p.beefChargeOrigin.y - p.beefChargeTarget.y) * progress;
                if (progress >= 1) { p.x = p.beefChargeOrigin.x; p.y = p.beefChargeOrigin.y; p.beefChargeState = 'ready'; p.isInvincible = false; }
            }
        } else {
            const vx = mouse.x - p.x, vy = mouse.y - p.y;
            p.x += (vx * p.speed * dt * 0.005); p.y += (vy * p.speed * dt * 0.005);
            p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
        }
        if (p.pilotGenome === 'beef') {
            if (p.beefCharges < p.beefMaxCharges) {
                if (p.beefChargeCooldown > 0) {
                    p.beefChargeCooldown -= dt;
                }
                if (p.beefChargeCooldown <= 0) {
                    p.beefCharges++;
                    if (p.beefCharges < p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                }
            }
            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                const chargeRadius = 120; let closestEnemy = null; let closestDistSq = chargeRadius * chargeRadius;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.stunTimer > 0) return;
                    const dx = e.x - p.x; const dy = e.y - p.y; const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) { closestDistSq = distSq; closestEnemy = e; }
                });
                if (closestEnemy) {
                    if (p.beefCharges === p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                    p.beefCharges--; 
                    p.beefChargeState = 'charging'; p.beefChargeOrigin = { x: p.x, y: p.y }; p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y }; p.beefChargeT = 0; p.isInvincible = true;
                    store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                    
                    // Calculate impact radius based on skills
                    let impactRadius = 80; // Base radius
                    if (p.skillTree && p.skillTree.juggernaut) impactRadius = 120;
                    if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) impactRadius = 160; // Big explosion
                    
                    // Skill tree compatibility - check subclass for existing players
                    if (p.subclass === 'juggernaut') impactRadius = Math.max(impactRadius, 120);
                    
                    if (p.skillTree && p.skillTree.juggernaut || p.subclass === 'juggernaut') {
                        playSound('charge');
                        explode(closestEnemy.x, closestEnemy.y, false, true);
                    } else {
                        playSound('beefCharge');
                    }
                    
                    // Apply impact damage
                    let baseDamage = 80;
                    if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) baseDamage = 150; // Big explosion damage
                    
                    potentialTargets.forEach(e => {
                        if (e.dead) return;
                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                        if (distSq < impactRadius * impactRadius) {
                            const chargeDmg = baseDamage * p.dmgMult;
                            e.hp -= chargeDmg; 
                            e.stunTimer = 2.5;
                            
                            // Apply vampirism healing for charge damage
                            if (store.player.vampirism > 0) {
                                let healAmount = chargeDmg * store.player.vampirism;
                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                healAmount = Math.min(healAmount, 8); // Cap at 8 HP for charge
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                            
                            const knockbackForce = 250; const angle = Math.atan2(e.y - p.y, e.x - p.x);
                            e.knockback = { vx: Math.cos(angle) * knockbackForce, vy: Math.sin(angle) * knockbackForce, duration: 0.3 };
                        }
                    });
                    
                    // Handle double charge (combo skill)
                    if (p.beefDoubleCharge || (p.skillTree && p.skillTree.combo_charge) && p.beefCharges > 0) {
                        setTimeout(() => {
                            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                                // Trigger second charge at same target
                                p.beefCharges--;
                                p.beefChargeState = 'charging'; 
                                p.beefChargeOrigin = { x: p.x, y: p.y }; 
                                p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y }; 
                                p.beefChargeT = 0; p.isInvincible = true;
                                store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                                
                                setTimeout(() => {
                                    // Second impact (smaller for combo)
                                    if (p.skillTree && p.skillTree.juggernaut || p.subclass === 'juggernaut') {
                                        explode(closestEnemy.x, closestEnemy.y, false, true);
                                    }
                                    potentialTargets.forEach(e => {
                                        if (e.dead) return;
                                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                                        // Use smaller radius for combo double charge
                                        const comboRadius = 60; 
                                        if (distSq < comboRadius * comboRadius) {
                                            const secondChargeDmg = baseDamage * p.dmgMult * 0.7; // Reduced damage for second hit
                                            e.hp -= secondChargeDmg;
                                            e.stunTimer = Math.max(e.stunTimer, 1.5);
                                            
                                            // Apply vampirism healing for second charge damage
                                            if (store.player.vampirism > 0) {
                                                let healAmount = secondChargeDmg * store.player.vampirism;
                                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                                healAmount = Math.min(healAmount, 6); // Cap at 6 HP for second charge
                                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                            }
                                        }
                                    });
                                }, 400); // Second impact timing
                            }
                        }, 800); // Delay before second charge
                    }
                }
            }
        } else if (p.pilotGenome === 'rocketman') {
            if (p.flameWallCooldown > 0) p.flameWallCooldown -= dt;
            if (p.flameWallActiveT > 0) p.flameWallActiveT -= dt;
            if (p.flameWallCooldown <= 0) { p.flameWallActiveT = 0.5; p.flameWallCooldown = 10; }
            if (p.flameWallActiveT > 0) {
                for (let i = 0; i < 2; i++) {
                    let attachedEnemy = null;
                    let closestDistSq = Infinity;
                    store.enemies.forEach(enemy => {
                        const distSq = (enemy.x - p.x) * (enemy.x - p.x) + (enemy.y - (p.y + 10)) * (enemy.y - (p.y + 10));
                        if (distSq < 100 * 100 && distSq < closestDistSq) {
                            closestDistSq = distSq;
                            attachedEnemy = enemy;
                        }
                    });
                    store.flameParticles.push(new FlameParticle(p.x, p.y + 10, attachedEnemy));
                }
            }
        } else if (p.pilotGenome === 'wizard') {
            if (p.hasChainLightning || p.hasHybridVoid) {
                p.chainLightningCooldown -= dt;
                if (p.chainLightningCooldown <= 0) { fireChainLightning(); p.chainLightningCooldown = 1.5; }
            }
            
            // Voidmancer base laser beam system
            if (p.hasVoidLaser) {
                stepVoidLaser(dt);
            }
        }
        if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
        p.fireT -= dt;
        if (p.fireT <= 0 && !p.empDisabled) { firePlayer(); p.fireT = p.fireRate; }
        
        // Separate flamethrower system (unaffected by overclock)
        if (p.flamethrowerLevel > 0 && !p.empDisabled) {
            p.flamethrowerT -= dt;
            if (p.flamethrowerT <= 0) {
                fireFlamethrower();
                p.flamethrowerT = 0.18; // Fixed fire rate for lava chunks
            }
        }
        
        if (p.powerupTimers['missile']) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });
                if (closest) {
                    const isRocketman = p.pilotGenome === 'rocketman';
                    const missileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                    const missileProps = { r: 4, target: closest, speed: 400, life: 0, dmg: missileDmg, hits: 0, travelDistance: 0 };

                    // Check for hybrid rocketman (has both cluster and piercing abilities)
                    const hasClusterAbility = p.subclass === 'demolitionist' || p.missileCluster || p.rocketmanHybrid;
                    const hasPiercingAbility = p.subclass === 'railgunner' || p.missilePierce > 0 || p.rocketmanHybrid;
                    
                    if (hasClusterAbility) {
                        // Count cluster volleys for sound management
                        store.player.clusterSoundCounter++;
                        const shouldPlaySound = store.player.clusterSoundCounter >= 5;
                        if (shouldPlaySound) {
                            store.player.clusterSoundCounter = 0;
                        }
                        
                        const spreadAngle = 10; const initialSpeed = 300;
                        for (let i = 0; i < p.missileVolley; i++) {
                            const angleOffset = (i - (p.missileVolley - 1) / 2) * spreadAngle * (Math.PI / 180);
                            // Only the first missile in the volley plays sound (and only every 5th volley)
                            const playSound = shouldPlaySound && i === 0;
                            // For hybrid, missiles have both cluster and piercing abilities
                            const pierce = hasPiercingAbility ? (p.missilePierce || 2) : 0;
                            store.missiles.push({ ...missileProps, x: p.x, y: p.y, startX: p.x, startY: p.y, vx: Math.sin(angleOffset) * initialSpeed, vy: -Math.cos(angleOffset) * initialSpeed, turnRate: 4, pierce: pierce, cluster: true, playSound: playSound });
                        }
                        if (p.hasIceman && store.iceman) {
                             for (let i = 0; i < p.missileVolley; i++) {
                                const angleOffset = (i - (p.missileVolley - 1) / 2) * spreadAngle * (Math.PI / 180);
                                const pierce = hasPiercingAbility ? (p.missilePierce || 2) : 0;
                                store.missiles.push({ ...missileProps, x: store.iceman.x, y: store.iceman.y, startX: store.iceman.x, startY: store.iceman.y, vx: Math.sin(angleOffset) * initialSpeed, vy: -Math.cos(angleOffset) * initialSpeed, dmg: missileDmg * 0.35, isIceman: true, turnRate: 4, pierce: pierce, cluster: true, playSound: false });
                            }
                        }
                    } else if (hasPiercingAbility) {
                        // Pure railgunner without clusters
                        for (let i = 0; i < p.missileVolley; i++) {
                            const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                            store.missiles.push({ ...missileProps, x: p.x + offsetX, y: p.y, startX: p.x + offsetX, startY: p.y, vx: 0, vy: -300, turnRate: 5, pierce: p.missilePierce, cluster: false, playSound: false });
                        }
                        if (p.hasIceman && store.iceman) {
                            for (let i = 0; i < p.missileVolley; i++) {
                                const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                                store.missiles.push({ ...missileProps, x: store.iceman.x + offsetX, y: store.iceman.y, startX: store.iceman.x + offsetX, startY: store.iceman.y, vx: 0, vy: -300, dmg: missileDmg * 0.35, isIceman: true, turnRate: 5, pierce: p.missilePierce, cluster: false, playSound: false });
                            }
                        }
                    } else {
                        // Basic missiles with no special abilities
                        for (let i = 0; i < p.missileVolley; i++) {
                            const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                            store.missiles.push({ ...missileProps, x: p.x + offsetX, y: p.y, startX: p.x + offsetX, startY: p.y, vx: 0, vy: -300, turnRate: 5, pierce: 0, cluster: false, playSound: false });
                        }
                        if (p.hasIceman && store.iceman) {
                            for (let i = 0; i < p.missileVolley; i++) {
                                const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                                store.missiles.push({ ...missileProps, x: store.iceman.x + offsetX, y: store.iceman.y, startX: store.iceman.x + offsetX, startY: store.iceman.y, vx: 0, vy: -300, dmg: missileDmg * 0.35, isIceman: true, turnRate: 5, pierce: 0, cluster: false, playSound: false });
                            }
                        }
                    }
                }
            }
        }
        if (p.shieldMax > 0 && p.shield < p.shieldMax) p.shield = Math.min(p.shieldMax, p.shield + 2 * dt);
        for (const key in p.powerupTimers) { p.powerupTimers[key].remaining -= dt; if (p.powerupTimers[key].remaining <= 0) { if (key === 'drones') store.drones = []; delete p.powerupTimers[key]; } }
        if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
        if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { activateGravityWell(); p.voidBeamCooldown = 30; } }
        if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { activateLazarus(); p.lazarusBeamCooldown = 30 / (p.upgradeLevels.lazarus_beam > 0 ? 2 : 1) ; } }
        if (store.cheatInvincibilityCooldown > 0) store.cheatInvincibilityCooldown -= dt;
        if (store.cheatDogHealCooldown > 0) store.cheatDogHealCooldown -= dt;
        if (p.x < 50 && p.y < 50 && store.cheatInvincibilityCooldown <= 0) {
            store.cheatsUsed = true; p.isInvincible = true; p.cheatMultishotBonus = 2; announce('TEST: INVINCIBILITY ACTIVE');
            setTimeout(() => { p.isInvincible = false; p.cheatMultishotBonus = 0; announce('TEST: INVINCIBILITY ENDS'); store.cheatInvincibilityCooldown = 10; }, 15000);
            store.cheatInvincibilityCooldown = 15 + 10;
        }
        if (p.x > W - 50 && p.y < 50 && store.cheatDogHealCooldown <= 0) {
            store.cheatsUsed = true; p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.20);
            if (!p.hasHounds) { p.hasHounds = true; }
            let houndsToAdd = Math.min(2, 4 - store.hounds.length);
            if (houndsToAdd > 0) {
                const existingSides = new Set(store.hounds.map(h => h.side)); const potentialSides = [-1, 1, -2, 2];
                for (const side of potentialSides) { if (houndsToAdd > 0 && !existingSides.has(side)) { store.hounds.push(createHound(side)); houndsToAdd--; } }
            }
            store.cheatDogHealCooldown = 10; announce('TEST: HEAL & HOUNDS');
        }
        
        // Handle poison effects
        if (p.isPoisoned && performance.now() > p.poisonEndTime) {
            p.isPoisoned = false;
            p.moveSpeed = 100; // Reset to base speed
        }
        
        // Check poison puddle collisions
        if (store.poisonPuddles) {
            store.poisonPuddles.forEach(puddle => {
                const dx = p.x - puddle.x;
                const dy = p.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < puddle.r + p.r) {
                    // Player is in poison puddle - apply damage and effects
                    if (!p.lastPuddleDamageTime || performance.now() - p.lastPuddleDamageTime > 500) {
                        takeDamage(puddle.damage);
                        p.lastPuddleDamageTime = performance.now();
                        
                        // Apply poison debuff
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 3000; // 3 second poison from puddle
                        p.moveSpeed = Math.max(p.moveSpeed * 0.8, 60); // Slow player more
                    }
                }
            });
        }
    }
    function stepPowerups(dt) {
        const p = store.player;
        store.powerups.forEach(powerup => {
            // Handle powerup movement (for Trap King falling powerups)
            if (powerup.vx !== undefined || powerup.vy !== undefined) {
                powerup.x += (powerup.vx || 0) * dt;
                powerup.y += (powerup.vy || 0) * dt;
                
                // Handle powerup lifetime
                if (powerup.life !== undefined) {
                    powerup.life -= dt;
                    if (powerup.life <= 0) {
                        powerup.dead = true;
                        return;
                    }
                }
                
                // Remove powerups that go off screen
                if (powerup.x < -20 || powerup.x > W + 20 || powerup.y < -20 || powerup.y > H + 20) {
                    powerup.dead = true;
                    return;
                }
            }
            
            if (p.magnetRadius > 0) {
                const dx = p.x - powerup.x;
                const dy = p.y - powerup.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < p.magnetRadius * p.magnetRadius) {
                    const dist = Math.sqrt(distSq);
                    const pullSpeed = 350;
                    powerup.x += (dx / dist) * pullSpeed * dt;
                    powerup.y += (dy / dist) * pullSpeed * dt;
                }
            }

            if (collide(p, powerup)) {
                powerup.dead = true;
                applyPowerup(powerup.type);
            }
        });
    }

    function detonateClusterRocket(m) {
        if (m.dead) return;
        m.dead = true;
        
        // Play cluster sound if this missile is marked for sound
        if (m.playSound) {
            playSound('cluster');
        }
        
        const baseRadius = 40; // Halved from 80
        const explosionRadius = store.player.enhancedClusters ? 80 : baseRadius;
        const chainRadius = 90;
        const microExplosionCount = 5;
        const aoeDmg = m.dmg * .8;
        for (let i = 0; i < microExplosionCount; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.random() * explosionRadius * 0.7;
            const ex = m.x + Math.cos(angle) * dist;
            const ey = m.y + Math.sin(angle) * dist;
            store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
        }
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(e => {
            if (!e.dead) {
                const distSq = (e.x - m.x)**2 + (e.y - m.y)**2;
                if (distSq < explosionRadius**2) {
                    e.hp -= aoeDmg;
                    e.hp = Math.max(1, e.hp);
                    
                    // Apply vampirism healing for cluster damage
                    if (store.player.vampirism > 0) {
                        let healAmount = aoeDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for AoE
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for AoE
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            }
        });
        // Remove chain detonation to prevent rockets from exploding each other
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            if (m.chainDetonate && !m.dead) {
                detonateClusterRocket(m);
                return;
            }
            m.life += dt; if (m.life > 6) { m.dead = true; return; }
            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }
            
            // Track movement distance before updating position
            const prevX = m.x, prevY = m.y;
            m.x += m.vx * dt; m.y += m.vy * dt;
            
            // Update travel distance if we have start position
            if (m.startX !== undefined && m.startY !== undefined) {
                m.travelDistance = Math.sqrt((m.x - m.startX)**2 + (m.y - m.startY)**2);
            }
            
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            
            // For cluster rockets, check proximity detonation only when they should explode
            if (m.cluster && !m.pierce) {
                // Original cluster behavior - explode near enemies
                const proxRadiusSq = 50 * 50;
                for (const e of targets) {
                    if (!e.dead && ((m.x - e.x)**2 + (m.y - e.y)**2 < proxRadiusSq)) {
                        detonateClusterRocket(m);
                        return;
                    }
                }
            }
            
            // Handle collision with enemies
            for (const e of targets) {
                if (!e.dead && collide(m, e)) {
                    m.hits = (m.hits || 0) + 1;
                    
                    if (m.cluster && m.pierce > 0) {
                        // Hybrid cluster + piercing: Deal damage, pierce, then set up for delayed explosion
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        m.pierce--;
                        
                        if (m.pierce <= 0) {
                            // No more pierces left - mark for delayed explosion
                            m.shouldExplodeAfterTravel = true;
                            m.minTravelTimeForExplosion = 0.5; // 0.5 seconds minimum travel time
                            m.travelTimeAfterLastHit = 0;
                        } else {
                            // Find next target for piercing
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else {
                                // No more targets - explode immediately
                                detonateClusterRocket(m);
                            }
                        }
                    } else if (m.cluster) {
                        // Pure cluster rocket - explode immediately
                        detonateClusterRocket(m);
                    } else {
                        // Regular missile logic (non-cluster)
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        if ((store.player.subclass === 'railgunner' || store.player.missilePierce > 0) && m.pierce > 0) {
                            m.pierce--;
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else { m.dead = true; }
                        } else if (m.pierce > 0) {
                            m.pierce--;
                        } else {
                            m.dead = true;
                        }
                    }
                    if (m.dead) break;
                }
            }
            
            // Handle delayed explosion for cluster + pierce missiles
            if (m.shouldExplodeAfterTravel) {
                m.travelTimeAfterLastHit += dt;
                if (m.travelTimeAfterLastHit >= m.minTravelTimeForExplosion) {
                    // Check if we're near any enemies to explode
                    const explosionProximity = 60;
                    let shouldExplode = false;
                    for (const e of targets) {
                        if (!e.dead) {
                            const distSq = (m.x - e.x)**2 + (m.y - e.y)**2;
                            if (distSq < explosionProximity * explosionProximity) {
                                shouldExplode = true;
                                break;
                            }
                        }
                    }
                    if (shouldExplode) {
                        detonateClusterRocket(m);
                    }
                }
            }
        });
    }

    function stepLightning(dt) {
        store.lightningBolts.forEach(bolt => {
            bolt.life -= dt;
            if (bolt.life <= 0) { bolt.dead = true; }
        });
    }

    function stepEmpNovas(dt) {
        store.empNovas.forEach(nova => {
            // Expand the nova
            nova.radius += nova.speed * dt;
            if (nova.radius > nova.maxRadius) {
                nova.radius = nova.maxRadius;
            }
            
            // Countdown life
            nova.life -= dt;
            if (nova.life <= 0) {
                nova.dead = true;
                return;
            }
            
            // Check if player is within EMP range
            const dx = store.player.x - nova.x;
            const dy = store.player.y - nova.y;
            const distSq = dx * dx + dy * dy;
            const radiusSq = nova.radius * nova.radius;
            
            if (distSq <= radiusSq) {
                // Player is within EMP range - disable weapons
                store.player.empDisabled = true;
                store.player.empDisabledTimer = 0.5; // Sizzle effect duration
            }
        });
        
        // Update player EMP disabled state
        if (store.player.empDisabledTimer > 0) {
            store.player.empDisabledTimer -= dt;
            if (store.player.empDisabledTimer <= 0) {
                store.player.empDisabled = false;
            }
        }
    }

    function stepLasers(dt) {
        store.lasers.forEach(laser => {
            laser.life -= dt;
            if (laser.life <= 0) { laser.dead = true; return; }
            laser.prevX = laser.x; laser.prevY = laser.y;
            laser.x += laser.vx * dt; laser.y += laser.vy * dt;
            if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                const speed = Math.sqrt(laser.vx**2 + laser.vy**2);
                let newAngle;
                if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                else { newAngle = Math.PI + Math.random() * Math.PI; }
                laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                laser.hitEnemies.clear();
            }
            store.enemies.forEach(e => {
                if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) { 
                    const laserDmg = 1000 * store.player.dmgMult;
                    e.hp -= laserDmg; 
                    laser.hitEnemies.add(e); 
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = laserDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                        healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            });
            if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) { 
                const bossLaserDmg = 500 * store.player.dmgMult;
                store.boss.hp -= bossLaserDmg; 
                laser.hitEnemies.add(store.boss); 
                
                // Apply vampirism healing for laser damage on boss
                if (store.player.vampirism > 0) {
                    let healAmount = bossLaserDmg * store.player.vampirism;
                    healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                    healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                }
            }
        });
    }

    function stepMines(dt) {
        store.mines.forEach(mine => {
            if (mine.dead) return;
            mine.fuse -= dt;
            let detonate = mine.fuse <= 0;
            if (!detonate) {
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                for(const target of targets) { if(!target.dead && collide(mine, target)) { detonate = true; break; } }
            }
            if(detonate) { mine.dead = true; explodeMine(mine); }
        });
    }
    
    function stepFlameParticles(dt) {
        for (let i = store.flameParticles.length - 1; i >= 0; i--) {
            const p = store.flameParticles[i];
            if (p.attachedEnemy) {
                if (p.attachedEnemy.dead) {
                    p.attachedEnemy = null;
                } else {
                    p.x = p.attachedEnemy.x;
                    p.y = p.attachedEnemy.y;
                    p.attachedEnemy.hp -= p.damage;
                    
                    // Apply vampirism healing for attached flame damage
                    if (store.player.vampirism > 0) {
                        let healAmount = p.damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.2); // Minimum 0.2 HP
                        healAmount = Math.min(healAmount, 1); // Cap at 1 HP
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    p.attachedEnemy.slowTimer = 2.0;
                }
            }
            if (!p.update(dt)) {
                store.flameParticles.splice(i, 1);
            }
        }
    }




    function stepWorld(dt) {
        stepPlayer(dt);
        if (store.boss) {
            stepBoss(dt);
        }

        stepPowerups(dt);
        stepHounds(dt);
        updateGibs(dt);
        stepMissiles(dt);
        stepLasers(dt);
        stepMines(dt);
        stepFlameParticles(dt);
        stepLightning(dt);
        stepEmpNovas(dt);
        updateVoidStepSystems(store.enemies);
        updateImpactSystem();

        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        if (store.world.powerupCooldown > 0) {
            store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2));
        }

        let base = store.world.wave < 200 ? 1.065 : 1.04;
        const dmgScale = Math.pow(base, store.world.wave - 1);
        store.eBullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.gravity) { b.vy += b.gravity * dt; }
            if (b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
            
            // Check if poison blob hits ground
            if (b.type === 'poisonBlob' && b.y > H - 30) {
                // Create poison puddle on ground impact
                if (!store.poisonPuddles) store.poisonPuddles = [];
                store.poisonPuddles.push({
                    x: b.x,
                    y: H - 20,
                    r: 20 + Math.random() * 10,
                    life: 12 + Math.random() * 8,
                    damage: (b.dmg || 15) * 0.5,
                    created: performance.now()
                });
                b.dead = true;
            }
            
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            if (collide(b, store.player)) {
                const p = store.player;
                if (p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                    p.rearGuardReady = false;
                    p.rearGuardCooldown = 8;
                    b.dead = true;
                    store.activeEffects.push(createEffect("rearGuardBlock"));
                } else {
                    // Check if this is a poison blob for special effects
                    if (b.type === 'poisonBlob') {
                        // Apply poison debuff to player
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 5000; // 5 second poison
                        p.moveSpeed = Math.max(p.moveSpeed * 0.7, 50); // Slow player
                        
                        // Create poison puddle at impact location
                        if (!store.poisonPuddles) store.poisonPuddles = [];
                        store.poisonPuddles.push({
                            x: b.x,
                            y: b.y,
                            r: 25,
                            life: 10,
                            damage: (b.dmg || 15) * 0.3,
                            created: performance.now()
                        });
                    }
                    
                    takeDamage(b.dmg || 10);
                    b.dead = true;
                }
            }
        });

        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) {
                    store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                    mine.dead = true;
                }
                if (collide(mine, store.player)) {
                    takeDamage(50 * dmgScale);
                    mine.dead = true;
                }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }


        // OPTIMIZED Flame particle collision - avoid expensive sqrt calls
        store.flameParticles.forEach(flame => {
            // Only check collisions while the flame is mechanically active
            if (flame.life <= 0) return;
            
            store.enemies.forEach(enemy => {
                if (enemy.dead) return;
                
                const dx = flame.x - enemy.x;
                const dy = flame.y - enemy.y;
                const distSq = dx * dx + dy * dy; // Skip sqrt - use squared distance
                const collisionRadius = Math.max(5, flame.size + enemy.r - 50);
                const collisionRadiusSq = collisionRadius * collisionRadius;
                
                if (distSq < collisionRadiusSq) {
                    enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.5);
                    enemy.hp -= flame.damage;
                    
                    // Apply vampirism healing for flamethrower damage
                    if (store.player.vampirism > 0) {
                        let healAmount = flame.damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    enemy.isBurning = true;
                    setTimeout(() => { if (enemy) enemy.isBurning = false; }, 100);
                }
            });
            
            if (store.boss && !store.boss.dead) {
                const dx = flame.x - store.boss.x;
                const dy = flame.y - store.boss.y;
                const distSq = dx * dx + dy * dy;
                const collisionRadius = Math.max(10, flame.size + store.boss.r - 50);
                const collisionRadiusSq = collisionRadius * collisionRadius;
                
                if (distSq < collisionRadiusSq) {
                    store.boss.stunTimer = Math.max(store.boss.stunTimer || 0, 0.3);
                    const bossFlameDmg = flame.damage * 0.5;
                    store.boss.hp -= bossFlameDmg;
                    
                    // Apply vampirism healing for flamethrower damage on boss
                    if (store.player.vampirism > 0) {
                        let healAmount = bossFlameDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    store.boss.isBurning = true;
                    setTimeout(() => { if (store.boss) store.boss.isBurning = false; }, 100);
                }
            }
        });
        store.enemies.forEach(e => {
            if (e.knockback) {
                e.x += e.knockback.vx * dt;
                e.y += e.knockback.vy * dt;
                e.knockback.duration -= dt;
                if (e.knockback.duration <= 0) e.knockback = null;
            } else if (e.stunTimer && e.stunTimer > 0) {
                e.stunTimer -= dt;
            } else {
                let speedMultiplier = (e.slowTimer > 0) ? 0.3 : 1.0;
                if (e.slowTimer > 0) e.slowTimer -= dt;

                if (e.type === 'construct_shard' || e.type === 'avian_hatchling') {
                    const dx = store.player.x - e.x, dy = store.player.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        e.x += (dx / dist) * e.v * speedMultiplier * dt;
                        e.y += (dy / dist) * e.v * speedMultiplier * dt;
                    }
                } else if (e.type === 'angler') {
                    const dx = store.player.x - e.x;
                    if (Math.abs(dx) > 10) e.x += Math.sign(dx) * 30 * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'manta') {
                    e.t += dt;
                    e.x = e.startX + e.amplitude * Math.sin(e.t * e.frequency);
                    e.y += e.v * speedMultiplier * dt;
                } else if (!e.isOrbiter) {
                    e.x += (e.vx || 0) * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else {
                    if (store.boss) { e.orbitCenter.x = store.boss.x; e.orbitCenter.y = store.boss.y; }
                    e.orbitAngle += e.orbitSpeed * speedMultiplier * dt;
                    e.x = e.orbitCenter.x + e.orbitRadius * Math.cos(e.orbitAngle);
                    e.y = e.orbitCenter.y + e.orbitRadius * Math.sin(e.orbitAngle);
                }
                if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
            }

            if (e.fireT > 0) e.fireT -= dt;
            if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                switch (e.type) {
                    case 'hunter': { const a=Math.atan2(store.player.y-e.y,store.player.x-e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:3,col:e.color,dmg:10*dmgScale}); e.fireT=1; break; }
                    case 'phantom': { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:180,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=e.fireCooldown; break; }
                    case 'mech': {
                        e.attackPhase = (e.attackPhase || 0) + 1;
                        if (e.attackPhase % 2 === 1) {
                            const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                            const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                            store.eBullets.push({ x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                            const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                            store.eBullets.push({ x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                        } else {
                            const dx = store.player.x - e.x, dist = Math.sqrt(dx*dx + (store.player.y - e.y)**2), timeToTarget = Math.max(0.5, dist / 250);
                            const vx = dx / timeToTarget, gravity = 350, vy = (store.player.y - e.y - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;
                            store.eBullets.push({ x: e.x, y: e.y, vx: vx, vy: vy, r: 6, col: '#ff6347', dmg: 18 * dmgScale, gravity: gravity });
                        }
                        e.fireT = 2; break;
                    }
                    case 'angler': { const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,r:4,col:e.color,dmg:15*dmgScale, life: 5}); e.fireT = 2.5; break; }
                    case 'manta': { for(let i=-1; i<=1; i++) { const angle = (90 + i * 30) * Math.PI/180; store.eBullets.push({x:e.x, y:e.y, vx:Math.cos(angle)*150, vy:Math.sin(angle)*150, r:3, col:e.color, dmg:12*dmgScale}); } e.fireT = 2.8; break; }
                    default: { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:150,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=.5; }
                }
            }

            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) {
                takeDamage(15 * dmgScale);
                store.world.shards += e.shards;
                e.dead = true;
            }
        });

        store.bullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.isSwirl) {
                b.life = (b.life || 0) + dt;
                b.x += Math.sin(b.life * 15) * 150 * dt;
            }
            if (b.isFlame) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
                b.particleSpawnT -= dt;
                if (b.particleSpawnT <= 0) {
                    b.particleSpawnT = b.isLavaChunk ? 0.1 : 0.05;
                    const life = 0.3 + Math.random() * 0.3, angle = Math.random() * 2 * Math.PI, speed = b.isLavaChunk ? 10 + Math.random() * 15 : 20 + Math.random() * 20;
                    b.particles.push({ x: 0, y: 0, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: life, maxLife: life, r: 1 + Math.random() * (b.isLavaChunk ? 1.5 : 2) });
                }
                b.particles = b.particles.filter(p => {
                    p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt;
                    return p.life > 0;
                });
            } else if (b.isLevelUpPulse) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
            }

            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
            for (const e of targets) {
                if (b.dead || e.dead) continue;
                if (collide(b, e)) {
                    if (b.isFlame) e.slowTimer = 1.0;
                    
                    let dmg = b.dmg || 20;
                    if (e === store.boss && b.isDrone) dmg *= 0.4;
                    
                    if (Math.random() < store.player.critChance) {
                        dmg *= store.player.critDamage;
                        store.activeEffects.push(createEffect('critText', e.x, e.y));
                        if (Math.random() < 0.05) spawnPowerup(e.x, e.y);
                    }
                    
                    if (e === store.boss) playSound('hit');
                    e.hp -= dmg;
                    
                    // Apply vampirism healing on damage dealt (not just kills)
                    if (store.player.vampirism > 0) {
                        let healAmount = dmg * store.player.vampirism;
                        // Ensure minimum healing of 1 HP per shot if vampirism is active
                        healAmount = Math.max(healAmount, 1);
                        // Cap healing to prevent overpowered early game
                        healAmount = Math.min(healAmount, 5);
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }

                    if (e.hp <= 0) {
                        e.dead = true;
                        if (e === store.boss) {
                            handleBossDefeat();
                        } else {
                            spawnGibs(e.x, e.y, e.color);
                            store.world.score += e.score;
                            store.world.shards += e.shards;
                            store.world.xp += e.xp;
                            store.world.kills++;
                            spawnPowerup(e.x, e.y);
                            explode(e.x, e.y);
                        }
                    }

                    if (b.explosive) explode(b.x, b.y, false, true);
                    if (!b.pierce) b.dead = true;
                }
            }
        });

        const p = store.player;
        const healthRatio = p.hp / p.hpMax;
        const lowHealthThreshold = 0.35;

        if (healthRatio < lowHealthThreshold) {
            if (!store.world.isLowHealth) {
                store.world.isLowHealth = true;
                store.heartbeatT = 5.0;
                playSound('heartbeat');
                store.activeEffects.push(createEffect("heartbeatPulse"));
            } else {
                if (store.heartbeatT > 0) {
                    store.heartbeatT -= dt;
                } else {
                    store.heartbeatT = 5.0;
                    playSound('heartbeat');
                    store.activeEffects.push(createEffect("heartbeatPulse"));
                }
            }
        } else if (store.world.isLowHealth) {
            store.world.isLowHealth = false;
        }

        ['bullets', 'eBullets', 'enemies', 'powerups', 'mines', 'missiles', 'lasers', 'flameParticles', 'lightningBolts', 'empNovas'].forEach(key => store[key] = store[key].filter(i => !i.dead));
        store.activeEffects = store.activeEffects.filter(e => e.isActive !== false);

        if (!store.boss && store.enemies.length === 0) {
            if (store.world.waveStartTime > 0) {
                const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;
                if (waveClearTime < 5 && store.world.wave > 1) {
                    store.world.enemyDensityBonus *= 1.1;
                    store.world.enemyHealthBonus *= 1.05;
                    store.world.xpMultiplier *= 1.05;
                    store.world.collarStacks++;
                    announce("SWARM INTENSITY RISING!");
                }
            }
            store.world.wave++;
            const hpBonus = 3;
            store.player.hpMax += hpBonus;
            store.player.hp += hpBonus;
            initWave();
        }

        let xpNeeded = Math.floor(store.world.level * 100 * store.world.xpMultiplier * (store.world.level >= 8 ? 1.3 : store.world.level >= 4 ? 1.1 : 1) * (store.world.wave > 10 ? 1.3 : 1));
        if (store.world.xp >= xpNeeded) {
            store.world.xp -= xpNeeded;
            store.world.level++;
            levelUp();
        }

        if (store.player.hp <= 0) {
            handleGameOver();
        }
    }





    function handleBossDefeat() {
        const fightDuration = (performance.now() - store.world.bossSpawnTime) / 1000;
        
        // Track boss defeats for progression
        const bossCount = store.world.bosses + 1; // +1 because we increment bosses after this check
        
        // NEW PROGRESSION SYSTEM:
        // 1st boss = pilot class selection
        // 2nd+ boss = skill tree for all pilots
        
        if (bossCount === 1 && !store.player.pilotGenome) {
            // 1st boss defeated - show pilot class selection
            store.player.pilotGenome = 'pending';
            setTimeout(showPilotSelect, 1000);
        } else if (bossCount >= 2 && store.player.pilotGenome && store.player.pilotGenome !== 'pending') {
            // 2nd+ boss defeated - show skill tree for all pilots
            
            // Don't award points or show tree if already fully capped OR if 4 skill points have been spent
            const skillPointsSpent = store.player.skillPointsSpent || 0;
            if (isSkillTreeFullyCapped() || skillPointsSpent >= 4) {
                console.log(`Skill tree stopped - ${isSkillTreeFullyCapped() ? 'fully capped' : '4 skill points spent'} (${skillPointsSpent}/4)`);
            } else {
                if (!store.player.skillTreeProgress) {
                    store.player.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
                }
                store.player.skillTreeProgress.bossesDefeated = bossCount;
                store.player.skillPoints = (store.player.skillPoints || 0) + 1;
                console.log(`${bossCount}${bossCount === 2 ? 'nd' : bossCount === 3 ? 'rd' : 'th'} boss defeated - showing skill tree for ${store.player.pilotGenome} with`, store.player.skillPoints, 'points');
                setTimeout(showSkillTreeModal, 1500);
            }
        }
        
        // Enhanced spec system: after 4th and 6th boss, then every 2 bosses after that  
        if (store.player.pilotGenome && store.player.subclass && bossCount >= 4) {
            if (bossCount === 4 || bossCount === 6 || (bossCount > 6 && (bossCount - 6) % 2 === 0)) {
                setTimeout(() => showSpecSelect(bossCount >= 6), 1500); // Second spec is additive
            }
        }
        
        store.world.score += 2000; store.world.shards += 25; store.world.xp += 100; store.world.bosses++;
        const bossX = store.boss.x;
        const bossY = store.boss.y;
        store.boss = null;
        announce('‚ö° GUARDIAN DEFEATED ‚ö°');
        explode(bossX, bossY, true);

        let healthBonusMultiplier = 1.0, announcedAdaptation = false;
        if (fightDuration <= 4) {
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            store.world.collarStacks++;
        } else if (fightDuration > 10) {
            store.world.collarStacks = 0; store.world.consecutiveFastKills = 0; store.world.fastKillBonus = 0;
            healthBonusMultiplier = 1.0; announce("ADAPTATION RESET!");
        } else {
            announcedAdaptation = true; healthBonusMultiplier = 1.10;
            store.world.consecutiveFastKills = 0; store.world.fastKillBonus = 0;
            announce("GUARDIANS ADAPTING!");
        }
        store.world.bossHealthBonus *= healthBonusMultiplier;
        if (announcedAdaptation) {
            const enemyHealthBonus = healthBonusMultiplier > 1.1 ? 1.15 : 1.05;
            store.world.enemyHealthBonus *= enemyHealthBonus;
            store.world.enemyDensityBonus *= 1.10;
            setTimeout(() => announce("ENEMY SWARMS INTENSIFYING!"), 1000);
        }
    }

    function explode(x, y, isBoss = false, isSmall = false) {
        playSound('explosion');
        if (isBoss) for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
        if (isSmall) {
            const radius = 60;
            const dmg = 25 * store.player.dmgMult;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            targets.forEach(e => {
                if (!e.dead) {
                    const distSq = (e.x - x)**2 + (e.y - y)**2;
                    if (distSq < radius**2) {
                        e.hp -= dmg;
                        store.world.totalDamage += dmg;
                        
                        // Apply vampirism healing for explosion damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP
                            healAmount = Math.min(healAmount, 2); // Cap at 2 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                    }
                }
            });
            store.activeEffects.push(createEffect("grenadeExplosion", x, y, radius));
        }
    }
    
    function levelUp() {
        announce(`LEVEL UP! ‚ö° CHOOSE YOUR AUGMENTATION!`);
        pauseGame();
        
        store.player.isInvincible = true;
        const speedBoost = store.player.speed * 0.75;
        const fireRateBoost = store.player.fireRate * 0.5;
        store.player.speed += speedBoost;
        store.player.fireRate -= fireRateBoost;

        const levelUpPulse = () => {
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 300;
                store.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 4, col: '#ffddff', dmg: 30 * p.dmgMult,
                    pierce: true, life: 1.5, isLevelUpPulse: true
                });
            }
        };

        levelUpPulse();
        setTimeout(levelUpPulse, 250);

        setTimeout(() => {
            store.player.isInvincible = false;
            store.player.speed -= speedBoost;
            store.player.fireRate += fireRateBoost;
        }, 3000);

        const panel = q('levelPanel'), grid = q('skillsGrid');
        const availableUpgrades = LEVEL_UPGRADES.filter(u => {
            if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
            return true;
        });

        for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; }
        const choices = availableUpgrades.slice(0, 3);
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        grid.querySelectorAll('.skill-card').forEach(c => c.addEventListener('click', () => {
            const id = c.dataset.id; const upgrade = LEVEL_UPGRADES.find(s => s.id === id);
            if (upgrade) upgrade.apply(); panel.classList.add('hide');
            resumeGame();
        })); 

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        panel.classList.remove('hide');
    }
    
    function handleGameOver() {
        if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score);
        announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide');
    }
    
    function resetGame() {
        store.player = JSON.parse(JSON.stringify(player_initial_state));
        
        // Ensure dmgMult is initialized
        if (!store.player.dmgMult) store.player.dmgMult = 1;
    
        store.world = { 
            wave: 1, 
            score: 0, 
            shards: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            totalDamage: 0,
            damageStartTime: performance.now()
        };
        
        store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = []; store.powerups = [];
        store.drones = []; store.hounds = []; store.missiles = []; store.lasers = []; store.mines = []; store.activeEffects = []; store.flameParticles = [];
        store.lightningBolts = []; store.empNovas = [];
        store.iceman = null;
        store._startTs = performance.now(); store.isGameOver = false;
        store.cheatsUsed = false;
        store.cheatInvincibilityCooldown = 0;
        store.cheatDogHealCooldown = 0;
        shopItemOrder = [];
        q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide'); 
        q('subclassPanel').classList.add('hide'); q('subclassPanel').classList.remove('skill-tree-active');
        ensureName();
    }

    // --- RENDER & DRAW FUNCTIONS ---
    const starCountA = 100, starCountB = 80;
    const starsA = Array.from({ length: starCountA }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.5, pulse: Math.random() * 10 }));
    const starsB = Array.from({ length: starCountB }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 2, pulse: Math.random() * 10 }));

function render(dt) {
    ctx.fillStyle = '#050008'; ctx.fillRect(0, 0, W, H);
    const time = performance.now() / 1000;
    ctx.globalAlpha = 0.8; for (const s of starsA) { s.y += 30 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(255,0,255,${0.5 + 0.5 * Math.sin(time * 2 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, 2 * Math.PI); ctx.fill(); }
    ctx.globalAlpha = 0.6; for (const s of starsB) { s.y += 60 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(204,0,255,${0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, Math.max(0.1, s.r * (0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse))), 0, 2 * Math.PI); ctx.fill(); }
    ctx.globalAlpha = 1;

    const closeBullets = [];
    const farBullets = [];
    const proximityThreshold = 110;
    const playerPos = store.player;

    store.eBullets.forEach(b => {
        const distSq = (b.x - playerPos.x)**2 + (b.y - playerPos.y)**2; 
        if (distSq < proximityThreshold**2) {
            closeBullets.push({ bullet: b, dist: Math.sqrt(distSq) });
        } else {
            farBullets.push(b);
        }
    });
    
    store.powerups.forEach(p => drawPowerup(p));
    store.missiles.forEach(m => drawMissile(m));
    store.lightningBolts.forEach(l => drawLightningBolt(l));
    store.empNovas.forEach(n => drawEmpNova(n));


    farBullets.forEach(b => {
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
    });
    
    store.bullets.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.fillStyle = b.col;
        ctx.beginPath();
        
        const r = b.r * 1.5;

        if (b.isLavaChunk) {
            ctx.beginPath();
            ctx.moveTo(0, -r); ctx.lineTo(r, r * 0.2); ctx.lineTo(r * 0.5, r); ctx.lineTo(-r * 0.5, r); ctx.lineTo(-r, r * 0.2);
            ctx.closePath();
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const particleR = p.r * t;
                ctx.fillStyle = `rgba(255, ${60 + Math.random() * 60}, 0, ${0.7 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isFlame) {
            ctx.fillStyle = `rgba(255, 150, 50, ${0.3 * (b.life / 50)})`;
            ctx.beginPath();
            ctx.arc(0, 0, b.r * 0.5, 0, 2 * Math.PI);
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const r_particle = p.r * t;
                const g = Math.floor(255 * (0.4 + t * 0.6));
                const b_val = Math.floor(100 * t);
                ctx.fillStyle = `rgba(${g}, ${b_val}, 0, ${0.8 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r_particle, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isSwirl || b.explosive) {
            ctx.arc(0, 0, b.r, 0, 2 * Math.PI);
        } else if (b.isIceman) {
            ctx.moveTo(0, r); ctx.lineTo(r * 0.8, -r * 0.8); ctx.lineTo(-r * 0.8, -r * 0.8);
        } else {
            ctx.moveTo(0, -r); ctx.lineTo(r * 0.8, r * 0.8); ctx.lineTo(-r * 0.8, r * 0.8);
        }

        ctx.closePath();
        ctx.fill();
        ctx.restore();
    });

    store.lasers.forEach(l => drawLaser(l));
    store.mines.forEach(m => drawMine(m));
    if (store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(performance.now() / 200)})`; ctx.fill(); ctx.restore(); });
    
    // Draw poison puddles
    if (store.poisonPuddles) {
        store.poisonPuddles.forEach(puddle => {
            const time = performance.now() / 1000;
            const age = (performance.now() - puddle.created) / 1000;
            const maxAge = puddle.life + (15 - puddle.life); // Total possible age
            
            ctx.save();
            ctx.translate(puddle.x, puddle.y);
            
            // Animate puddle bubbling
            const bubbleOffset = Math.sin(time * 3 + puddle.x * 0.01) * 2;
            
            // Create toxic glow effect
            const glowRadius = puddle.r * 1.5;
            const glowAlpha = 0.3 * (puddle.life / 15) + 0.2 * Math.sin(time * 4);
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
            gradient.addColorStop(0, `rgba(124, 252, 0, ${glowAlpha})`);
            gradient.addColorStop(0.7, `rgba(173, 255, 47, ${glowAlpha * 0.5})`);
            gradient.addColorStop(1, 'rgba(124, 252, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw the puddle itself
            const puddleAlpha = Math.max(0.4, puddle.life / 15);
            ctx.fillStyle = `rgba(45, 80, 22, ${puddleAlpha})`;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, puddle.r, 0, Math.PI * 2);
            ctx.fill();
            
            // Add surface texture/ripples
            ctx.strokeStyle = `rgba(124, 252, 0, ${puddleAlpha * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const rippleRadius = puddle.r * (0.3 + i * 0.3) + Math.sin(time * 2 + i) * 3;
                const rippleAlpha = puddleAlpha * (0.8 - i * 0.2);
                ctx.globalAlpha = rippleAlpha;
                ctx.arc(0, bubbleOffset, rippleRadius, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Add occasional toxic bubbles
            if (Math.random() < 0.1) {
                const bubbleX = (Math.random() - 0.5) * puddle.r;
                const bubbleY = (Math.random() - 0.5) * puddle.r + bubbleOffset;
                const bubbleSize = 2 + Math.random() * 3;
                
                ctx.fillStyle = `rgba(124, 252, 0, ${0.6 + Math.random() * 0.4})`;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    store.enemies.forEach(e => drawEnemy(e));
    drawGibs(ctx); // <-- ADD THIS LINE TO DRAW THE GIBS
    if (store.boss && store.boss.visible !== false) drawBoss(store.boss);
    store.flameParticles.forEach(p => p.draw());
    store.drones.forEach(d => drawDrone(d));
    store.hounds.forEach(h => drawHound(h));
    if (store.iceman) drawIceman(store.iceman);
    drawShip(store.player.x, store.player.y, store.player);
    
    // Draw EMP disabled effect on player
    if (store.player.empDisabled) {
        const time = performance.now() / 1000;
        const sizzleIntensity = 0.5 + 0.5 * Math.sin(time * 15);
        
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        
        // Electric sparks around player
        ctx.strokeStyle = `rgba(255, 140, 0, ${sizzleIntensity})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 8;
        
        for (let i = 0; i < 8; i++) {
            if (Math.random() < 0.7) {
                const angle = (i / 8) * Math.PI * 2 + time * 5;
                const radius = store.player.r + 5;
                const x1 = Math.cos(angle) * radius;
                const y1 = Math.sin(angle) * radius;
                const x2 = x1 + (Math.random() - 0.5) * 15;
                const y2 = y1 + (Math.random() - 0.5) * 15;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        // Purple inner glow
        ctx.fillStyle = `rgba(138, 43, 226, ${sizzleIntensity * 0.3})`;
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(0, 0, store.player.r * 1.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Draw poison effect on player
    if (store.player.isPoisoned) {
        const time = performance.now() / 1000;
        const poisonAlpha = 0.3 + 0.2 * Math.sin(time * 8);
        
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = `rgba(0, 255, 0, ${poisonAlpha})`;
        ctx.beginPath();
        ctx.arc(store.player.x, store.player.y, store.player.r + 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Add poison particle effect around player
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        for (let i = 0; i < 6; i++) {
            const angle = time * 2 + i * Math.PI / 3;
            const x = Math.cos(angle) * (store.player.r + 12 + Math.sin(time * 4 + i) * 5);
            const y = Math.sin(angle) * (store.player.r + 12 + Math.sin(time * 4 + i) * 5);
            
            ctx.fillStyle = `rgba(124, 252, 0, ${0.4 + 0.3 * Math.sin(time * 6 + i)})`;
            ctx.beginPath();
            ctx.arc(x, y, 2 + Math.sin(time * 5 + i), 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    // Draw voidmancer laser beam
    if (store.player.hasVoidLaser && store.player.voidLaserTarget && !store.player.voidLaserTarget.dead) {
        const p = store.player;
        const target = p.voidLaserTarget;
        
        // Determine laser color based on player ship color
        let laserColor = '#b266ff'; // Default purple
        switch (p.subclass) {
            case 'juggernaut':
                laserColor = '#ff3333';
                break;
            case 'marauder':
                laserColor = '#33cc33';
                break;
            case 'railgunner':
                laserColor = '#ff6600';
                break;
            case 'demolitionist':
                laserColor = '#ff4500';
                break;
            case 'phasestriker':
                laserColor = '#9900ff';
                break;
            case 'stormcaller':
                laserColor = '#00ccff';
                break;
        }
        
        const time = performance.now() / 1000;
        const pulseAlpha = 0.6 + 0.4 * Math.sin(time * 12);
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Draw main laser beam
        ctx.strokeStyle = laserColor;
        ctx.globalAlpha = pulseAlpha;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - 12);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        
        // Draw laser glow effect
        const gradient = ctx.createLinearGradient(p.x, p.y - 12, target.x, target.y);
        gradient.addColorStop(0, laserColor + '80');
        gradient.addColorStop(0.5, laserColor + 'FF');
        gradient.addColorStop(1, laserColor + '80');
        
        ctx.strokeStyle = gradient;
        ctx.globalAlpha = pulseAlpha * 0.5;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - 12);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        
        // Add impact effect at target
        ctx.fillStyle = laserColor;
        ctx.globalAlpha = pulseAlpha;
        ctx.beginPath();
        ctx.arc(target.x, target.y, 4 + Math.sin(time * 8) * 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    
    closeBullets.forEach(item => {
        const b = item.bullet;
        const dist = item.dist;
        
        const proxFactor = 1.0 - (dist / proximityThreshold);

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = proxFactor; 
        const glowRadius = b.r * 2;
        const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
        gradient.addColorStop(0.3, b.col);
        gradient.addColorStop(1, b.col + '00');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255, 255, 255, ${proxFactor * 0.8})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 0.5, 0, Math.PI * 2);
        ctx.fill();
    });
    
    store.activeEffects.forEach(e => e.draw && e.draw());
    renderVoidStepSystems(ctx);
    renderImpactSystem(ctx);
    updateHUD();
}
    
    function takeDamage(dmg) {
        if (store.player.isInvincible || playerIsInvulnerable()) return;
        if (store.boss && store.boss.isInvincible) return;

        if (store.player.hasShieldBubble) {
            store.player.hasShieldBubble = false;
            store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
            return;
        }
        const p = store.player;
        const a = Math.min(p.shield, dmg);
        if (a < dmg) playSound('hit');
        p.shield -= a;
        dmg -= a;
        
        // Check for nano save BEFORE applying damage
        const hpAfterDamage = p.hp - dmg;
        if (hpAfterDamage <= 0 && hpAfterDamage > -p.hpMax * 0.75 && p.nanoSaves > 0) {
            p.nanoSaves--;
            p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.25);
            store.activeEffects.push(createEffect("nanoHeal"));
            announce('NANO SAVE ACTIVATED!');
            return; // Don't apply the lethal damage
        }
        
        p.hp = Math.max(0, hpAfterDamage);

        if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
            store.world.lowHealthTutorialShown = true;
            showShopWithHighlight();
        }
    }
    
    function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function announce(text) { const el = q('announce'); el.textContent = text; el.classList.remove('hide'); clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); }
    function updateHUD() { const t = store.player, e = Math.round(t.hp / t.hpMax * 100), o = t.shieldMax > 0 ? Math.round(t.shield / t.shieldMax * 100) : 0; const healthText = `HP: ${Math.round(t.hp)} / ${t.hpMax}`; const shieldText = t.shieldMax > 0 ? `SHIELD: ${Math.round(t.shield)} / ${t.shieldMax}` : ""; q("hudPilotContent").innerHTML = `<div class="hud-title">${store.name ? `‚ó¢ ${escapeHtml(store.name)} ‚ó£` : "‚ó¢ UNIDENTIFIED ‚ó£"}</div><div style="text-align:center">SCORE <b>${store.world.score}</b> ‚Ä¢ SHARDS <b>${store.world.shards}</b></div><div class="bar"><span style="width:${e}%"></span></div><div style="font-size: 9px; text-align: center; line-height: 1;">${healthText}</div>${t.shieldMax > 0 ? `<div class="bar" style="margin-top:2px;"><span style="width:${o}%;background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div><div style="font-size: 9px; text-align: center; line-height: 1;">${shieldText}</div>` : ""}`; q("hudWaveContent").innerHTML = `<div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div><div style="text-align:center">SECTOR <b>${store.world.wave}</b> ‚Ä¢ KILLS <b>${store.world.kills}</b> ‚Ä¢ LVL <b>${store.world.level}</b></div>`; if (store.boss) { q("hudBossContent").classList.remove("hide"); q("hudBossContent").innerHTML = `<div class="hud-title">‚ö° ${store.boss.name} ‚ö°</div><div class="bar"><span style="width:${Math.round(store.boss.hp / store.boss.hpMax * 100)}%"></span></div>`; } else { q("hudBossContent").classList.add("hide"); } const powerupEl = q("hudPowerup"); const timedPowerups = Object.keys(store.player.powerupTimers); let timedContent = ''; if (timedPowerups.length > 0) { timedPowerups.forEach(key => { const timer = store.player.powerupTimers[key]; const percent = Math.min(100, (timer.remaining / timer.max) * 100); timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`; }); } powerupEl.innerHTML = `<div class="hud-title">‚ó¢ SYSTEMS ONLINE ‚ó£</div>${timedContent}`; powerupEl.classList.toggle('hide', !timedContent); const equipEl = q("hudEquipment"); let hasEquipment = store.player.hasLauncher || store.player.hasHounds || store.player.nanoSaves > 0; if (hasEquipment) { equipEl.classList.remove('hide'); let content = `<div class="hud-title">‚ó¢ EQUIPMENT ‚ó£</div>`; if (store.player.nanoSaves > 0) content += `<div>NANO SAVE [${store.player.nanoSaves}]</div>`; if (store.player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`; if (store.player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`; equipEl.innerHTML = content; } else { equipEl.classList.add('hide'); } const grenadeBtn = q('grenadeBtnUI'); if (store.player.grenades > 0) { grenadeBtn.classList.remove('hide'); grenadeBtn.textContent = `GRENADE [${store.player.grenades}]`; grenadeBtn.disabled = false; } else { grenadeBtn.classList.add('hide'); } 
        
        // Update DPS counter
        const timeElapsed = (performance.now() - store.world.damageStartTime) / 1000; // seconds
        const dps = timeElapsed > 0 ? (store.world.totalDamage / timeElapsed) : 0;
        q('dps').textContent = dps.toFixed(8);
        
        // Update FPS counter
        if (!store.fpsLastTime) {
            store.fpsLastTime = performance.now();
            store.fpsFrameCount = 0;
        }
        store.fpsFrameCount++;
        const now = performance.now();
        if (now - store.fpsLastTime >= 1000) {
            const fps = Math.round((store.fpsFrameCount * 1000) / (now - store.fpsLastTime));
            q('fps').textContent = fps;
            store.fpsFrameCount = 0;
            store.fpsLastTime = now;
        }
    }
    function updateLeaderboard(leaderboardData) { 
        const fallbackData = [
            { name: "ACE PILOT", score: 50000, waves: 10 },
            { name: "VOID RUNNER", score: 35000, waves: 8 },
            { name: "STAR HUNTER", score: 25000, waves: 6 },
            { name: "NOVA STRIKER", score: 18000, waves: 5 },
            { name: "COSMIC GUARD", score: 12000, waves: 4 }
        ]; 
        
        // Handle both old format (array) and new format (object with entries)
        let data;
        if (leaderboardData && leaderboardData.entries) {
            data = leaderboardData.entries;
        } else if (leaderboardData && Array.isArray(leaderboardData)) {
            data = leaderboardData;
        } else {
            data = fallbackData;
        }
        
        q("hsList").innerHTML = data.map(s => `<li>${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); 
        q("hsListPopup").innerHTML = data.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); 
    }
    
    async function refreshScoreList() { 
        try { 
            const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 }); 
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`); 
            const data = await res.json(); 
            // data.entries contains up to 50 players
            // Implement smooth scrolling through the list
            updateLeaderboard(data); 
        } catch (err) { 
            console.warn("Failed to fetch leaderboard, using offline data:", err.message); 
            updateLeaderboard(null); 
        } 
    }
    async function addScore(score) {
        if (store.cheatsUsed) {
            announce("Score not submitted: Cheats used");
            return;
        }
        const name = (store.name || "ROGUE").slice(0, 16); 
        try { 
            const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 }); 
            if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`); 
            const { nonce } = await nonceRes.json(); 
            const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce }; 
            const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 }); 
            if (!res.ok) throw new Error(`Submit failed: ${res.status}`); 
            const data = await res.json(); 
            if (data.ok) { 
                // Handle new server response format - use top50 instead of top10
                updateLeaderboard(data.top50 || data.top10); 
            } else { 
                console.warn("Score rejected:", data.err); 
                announce(`Score rejected: ${data.err}`); 
                refreshScoreList(); 
            } 
        } catch (err) { 
            console.warn("Score submission failed, game continues offline:", err.message); 
        } 
    }
    function fireBullet(x, y, vx, vy, props = {}) { const p = store.player; store.bullets.push({ x, y, vx, vy, r: p.explosive ? 5 : 3, col: p.explosive ? "#ED2F32" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive, ...props }); }
    function firePlayer() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        const bulletSpeed = 420;
        const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0);
        const angleSpread = 10;
        for (let i = 0; i < totalMultishot; i++) { const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; store.bullets.push({ x: p.x + 10 * Math.sin(angle), y: p.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: p.explosive ? "#cc99ff" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive }); }
        if (p.hasIceman && store.iceman) { for (let i = 0; i < totalMultishot; i++) { const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; store.bullets.push({ x: store.iceman.x + 10 * Math.sin(angle), y: store.iceman.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: "#66aaff", dmg: 20 * p.dmgMult * 0.35, pierce: p.piercing, explosive: p.explosive, isIceman: true }); } }
        if (p.rearMultishot > 0) { const rearAngleSpread = 15; for (let i = 0; i < p.rearMultishot; i++) { const angle = (i - (p.rearMultishot - 1) / 2) * rearAngleSpread; const radAngle = angle * Math.PI / 180; store.bullets.push({ x: p.x + 10 * Math.sin(radAngle), y: p.y + 12, vx: Math.sin(radAngle) * bulletSpeed, vy: Math.cos(radAngle) * bulletSpeed, r: 3, col: "#ffddff", dmg: 15 * p.dmgMult, pierce: p.piercing > 0 ? p.piercing - 1 : 0 }); } }
        store.drones.forEach(drone => store.bullets.push({ x: p.x + drone.offset, y: p.y + 20, vx: 0, vy: -bulletSpeed, r: 3, col: "#66aaff", dmg: 20 * p.dmgMult * 0.4, isDrone: true }));
        if (p.hasLauncher) {
            const speed = 350;
            const numPairs = store.player.upgradeLevels.launcher || 1;
            for (let i = 0; i < numPairs; i++) {
                const spread = 15 + i * 10;
                const vx_offset = 50 + i * 20;
                store.bullets.push({ x: p.x - spread, y: p.y, vx: -vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                store.bullets.push({ x: p.x + spread, y: p.y, vx: vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                if (p.hasIceman && store.iceman) {
                    store.bullets.push({ x: store.iceman.x - spread, y: store.iceman.y, vx: -vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                    store.bullets.push({ x: store.iceman.x + spread, y: store.iceman.y, vx: vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                }
            }
        }
    }
    
    function fireFlamethrower() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        
        let numFlames, angleRange, speed, life;
        switch (p.flamethrowerLevel) {
            case 1: numFlames = 4; angleRange = 40; speed = 250; life = 0.35; break;    // Halved from 8
            case 2: numFlames = 6; angleRange = 70; speed = 280; life = 0.4; break;     // Halved from 12
            default: numFlames = 8; angleRange = 90; speed = 320; life = 0.5; break;    // Halved from 16
        }
        
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
            const currentSpeed = speed + Math.random() * 40;
            const sideOffset = (i % 2 === 0) ? -15 : 15;
            const spawnX = p.x + sideOffset;
            const spawnY = p.y + 5;
            store.bullets.push({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 3, col: `rgba(255, ${60 + Math.random() * 60}, 0, 0.9)`, dmg: 2 * p.dmgMult, life: life * 1.5, isFlame: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
        }
        
        if (p.hasIceman && store.iceman) {
            for (let i = 0; i < numFlames; i++) {
                const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                const currentSpeed = speed + Math.random() * 40;
                const sideOffset = (i % 2 === 0) ? -15 : 15;
                const spawnX = store.iceman.x + sideOffset;
                const spawnY = store.iceman.y + 5;
                store.bullets.push({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 2, col: `rgba(100, 150, 255, 0.7)`, dmg: 2 * p.dmgMult * 0.35, life: life, isFlame: true, isIceman: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
            }
        }
    }
    
    function stepBossOmegaSentinel(dt, b, dmgScale) {
        // Movement behavior
        if (b.y >= 100) {
            b.moveT += dt;
            b.x += Math.sin(b.moveT * 2) * 200 * dt;
            b.x = clamp(b.x, 100, W - 100);
        }
        
        // Initialize EMP nova timer if not set
        if (b.empNovaTimer === undefined) {
            b.empNovaTimer = 8; // EMP nova every 8 seconds
        }
        
        // EMP Nova attack countdown
        b.empNovaTimer -= dt;
        if (b.empNovaTimer <= 0) {
            // Create EMP nova
            store.empNovas.push({
                x: b.x,
                y: b.y,
                radius: 0,
                maxRadius: H / 3, // 1/3 of screen height
                speed: 80, // Slow expansion speed
                life: 15, // Lives for 15 seconds
                dead: false
            });
            b.empNovaTimer = 8; // Reset timer
        }
        
        // Regular attack patterns
        b.fireT -= dt;
        if (b.fireT <= 0) {
            if (b.patternPhase % 4 === 0) {
                // Radial burst
                b.fireT = 1.5;
                const n = 12;
                for (let i = 0; i < n; i++) {
                    const a = (i * Math.PI / 6) + b.t;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: 150 * Math.cos(a),
                        vy: 150 * Math.sin(a),
                        r: 4,
                        col: '#4169e1',
                        dmg: 12 * dmgScale
                    });
                }
            } else {
                // Aimed shot
                b.fireT = 0.2;
                const a = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                store.eBullets.push({
                    x: b.x,
                    y: b.y,
                    vx: 250 * Math.cos(a),
                    vy: 250 * Math.sin(a),
                    r: 5,
                    col: '#add8e6',
                    dmg: 18 * dmgScale
                });
            }
            b.patternPhase++;
        }
    }
    function stepBossCoreMalignus(dt, b, dmgScale) { if (b.hp / b.hpMax <= 0.07 && !b.isEnraged) { b.isEnraged = true; playSound('horn'); } if (b.y >= 100) { b.moveT += dt; b.x = W / 2 + (W / 2 - 100) * Math.sin(b.moveT * 0.5); } b.fireT -= dt; if (b.fireT <= 0) { b.fireT = b.isEnraged ? 0.6 : 0.8; const n = 12, g = 3, s = Math.floor(Math.random() * (n - g)); for (let i = 0; i < n; i++) { if (i >= s && i < s + g) continue; const p = (W / (n + 1)) * (i + 1); store.eBullets.push({ x: p, y: b.y, vx: 0, vy: 180, r: 6, col: b.color, dmg: 20 * dmgScale }); } } }
    function stepBossTheHex(dt, b, dmgScale) { 
        if (b.y >= 100) { 
            b.moveT += dt; 
            b.x = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4)); 
        } 
        b.fireT -= dt; 
        if (b.hp / b.hpMax < 0.5 && !b.isEnraged) { 
            b.isEnraged = true; 
            playSound('trap'); 
        } 
        const fireRate = b.isEnraged ? 0.8 : 1.5; 
        if (b.fireT <= 0) { 
            b.fireT = fireRate; 
            b.attackPhase = (b.attackPhase + 1) % 3; 
            switch(b.attackPhase) { 
                case 0: 
                    // Gold rain with interspersed powerups for strategic gambling
                    for (let i = 0; i < 20; i++) { 
                        setTimeout(() => { 
                            // 20% chance to spawn a powerup instead of a bullet (strategic gamble)
                            if (Math.random() < 0.2) {
                                // Spawn yellow powerup that looks similar to gold bullets
                                // Use valid powerup types from POWERUP_TYPES
                                const powerupTypes = ['double', 'missile', 'drones', 'shield'];
                                const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                                
                                store.powerups.push({
                                    x: Math.random() * W,
                                    y: 0,
                                    vx: 0,
                                    vy: 250, // Same speed as bullets to blend in
                                    r: 6, // Slightly larger to be distinguishable
                                    type: randomType,
                                    life: H / 250 + 2 // Ensure it lives long enough to reach bottom
                                });
                            } else {
                                // Spawn normal gold bullet
                                store.eBullets.push({ 
                                    x: Math.random() * W, 
                                    y: 0, 
                                    vx: 0, 
                                    vy: 250, 
                                    r: 5, 
                                    col: '#ffc83d', 
                                    dmg: 15 * dmgScale 
                                }); 
                            }
                        }, i * 50); 
                    } 
                    break; 
                case 1: 
                    for (let i = 0; i < 4; i++) { 
                        const isHorizontal = i < 2; 
                        const y = isHorizontal ? 100 + i * 150 : 0; 
                        const x = isHorizontal ? 0 : 200 + (i-2) * 250; 
                        const vx = isHorizontal ? 300 : 0; 
                        const vy = isHorizontal ? 0 : 300; 
                        store.eBullets.push({ 
                            x: x, 
                            y: y, 
                            vx: vx, 
                            vy: vy, 
                            r: 4, 
                            col: '#80ffff', 
                            dmg: 20 * dmgScale, 
                            isLaser: true, 
                            life: 2.5 
                        }); 
                    } 
                    break; 
                case 2: 
                    const targetX = store.player.x; 
                    const dx = targetX - b.x; 
                    const dashSpeed = 800; 
                    b.vx = Math.sign(dx) * dashSpeed; 
                    setTimeout(() => { 
                        b.vx = 0; 
                    }, 500); 
                    break; 
            } 
        } 
        if(b.vx) { 
            b.x += b.vx * dt; 
            store.eBullets.push({ 
                x: b.x, 
                y: b.y, 
                vx: 0, 
                vy: 0, 
                r: 8, 
                col: '#ff8080', 
                dmg: 25 * dmgScale, 
                life: 1 
            }); 
        } 
    }
    function stepBossGeometron(dt, b, dmgScale) { 
        // Handle DEATH ENGINE specific behavior
        if (b.name === 'DEATH ENGINE') {
            // Initialize skull ship specific properties
            if (!b.skullPhaseInitialized) {
                b.skullPhaseInitialized = true;
                b.phase = 1;
                b.disappearPhase = false;
                b.disappearStartTime = 0;
                b.safeZoneY = H * 0.5; // Start safe zone in middle
                b.safeZoneChanges = 0;
                b.maxSafeZoneChanges = 3;
            }

            // Phase 1: Normal attacks until 50% HP
            if (b.phase === 1 && b.hp / b.hpMax > 0.5) {
                // Movement
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * 0.3); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Normal attack pattern
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                            const n = 12; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 160 * Math.cos(a), vy: 160 * Math.sin(a), r: 4, col: '#8B0000', dmg: 18 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Aimed shots at player
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < 5; i++) { 
                                const angle = angleToPlayer + (i - 2) * 0.15; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 280 * Math.cos(angle), vy: 280 * Math.sin(angle), r: 5, col: '#FF4500', dmg: 22 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // Spawn construct shards
                            const numShards = 2 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numShards; i++) { 
                                const shard = spawnEnemy('construct_shard'); 
                                shard.x = b.x + (Math.random() - 0.5) * 120; 
                                shard.y = b.y + 60; 
                                shard.color = '#8B0000';
                                store.enemies.push(shard); 
                            } 
                            break;
                        case 3:
                            // New attack phase: Bouncing skull projectiles
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * Math.PI / 3) + (Math.random() - 0.5) * 0.3;
                                const speed = 150 + Math.random() * 50;
                                store.eBullets.push({ 
                                    x: b.x, 
                                    y: b.y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    r: 6, 
                                    col: '#DC143C', 
                                    dmg: 20 * dmgScale,
                                    bounces: 2, // Special bouncing bullets
                                    life: 4.0
                                }); 
                            }
                            break; 
                    }
                }
            }
            // Phase transition: Disappear and start train bullet pattern
            else if (b.phase === 1 && b.hp / b.hpMax <= 0.5) {
                b.phase = 2;
                b.disappearPhase = true;
                b.disappearStartTime = performance.now();
                b.isInvincible = true;
                b.visible = false; // Hide the boss
                
                // Move boss offscreen below player so it can't be shot
                b.x = W / 2;
                b.y = H + 200; // Move well below the screen
                
                // Update skull renderer position to be offscreen too
                if (b.skullRenderer) {
                    b.skullRenderer.x = b.x;
                    b.skullRenderer.y = b.y;
                }
                
                playSound('shao_kahn'); // Skull laugh when disappearing
                announce('THE DEATH ENGINE VANISHES INTO THE VOID!');
                
                // Reset safe zone position and changes
                b.safeZoneY = H * 0.5;
                b.safeZoneChanges = 0;
            }
            // Phase 2: Disappear phase with train bullets
            else if (b.disappearPhase) {
                const disappearTime = (performance.now() - b.disappearStartTime) / 1000;
                
                // Change bullet pattern/safe zone location during disappear phase
                if (b.safeZoneChanges < b.maxSafeZoneChanges) {
                    const changeInterval = 3; // Change every 3 seconds (shorter phases)
                    if (disappearTime > (b.safeZoneChanges + 1) * changeInterval) {
                        // Store old safe zone position for reference
                        b.oldSafeZoneY = b.safeZoneY;
                        
                        // Set safe zone based on pattern type
                        switch(b.safeZoneChanges) {
                            case 0: // Preparing for horizontal pattern
                                b.safeZoneY = H * 0.5; // Middle horizontal
                                announce(`HORIZONTAL BARRAGE INCOMING!`);
                                break;
                            case 1: // Preparing for vertical pattern  
                                b.safeZoneY = H * 0.5; // Safe zone will be vertical middle
                                announce(`VERTICAL STORM APPROACHING!`);
                                break;
                            case 2: // Preparing for diagonal pattern
                                b.safeZoneY = H * 0.3; // Corner safe zones
                                announce(`DIAGONAL CHAOS UNLEASHED!`);
                                break;
                        }
                        
                        b.safeZoneChanges++;
                        playSound('shao_kahn'); // Laugh when safe zone changes
                    }
                }
                
                // Spawn train bullets continuously with different patterns per subphase
                if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                b.trainBulletTimer -= dt;
                
                if (b.trainBulletTimer <= 0) {
                    b.trainBulletTimer = 0.08; // Very frequent spawning
                    
                    const safeZoneHeight = 80;
                    const bulletSpeed = 280;
                    const bulletSpacing = 30;
                    
                    // Different bullet patterns for each subphase
                    const currentSubphase = b.safeZoneChanges;
                    
                    switch(currentSubphase) {
                        case 0:
                            // Phase 1: Horizontal trains (original pattern)
                            // Safe zone in horizontal center
                            const topBoundary1 = b.safeZoneY - safeZoneHeight/2;
                            if (topBoundary1 > 30) {
                                for (let y = 0; y < topBoundary1; y += bulletSpacing) {
                                    store.eBullets.push({
                                        x: -10, y: y,
                                        vx: bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1
                                    });
                                }
                            }
                            
                            const bottomBoundary1 = b.safeZoneY + safeZoneHeight/2;
                            if (bottomBoundary1 < H - 30) {
                                for (let y = bottomBoundary1; y < H; y += bulletSpacing) {
                                    store.eBullets.push({
                                        x: W + 10, y: y,
                                        vx: -bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1
                                    });
                                }
                            }
                            break;
                            
                        case 1:
                            // Phase 2: Vertical trains (left/right sides)
                            // Safe zone positioned vertically in middle (around x = W/2)
                            const safeZoneWidth = 100;
                            const leftBoundary = (W/2) - safeZoneWidth/2;
                            const rightBoundary = (W/2) + safeZoneWidth/2;
                            
                            // Left side vertical bullets (moving down)
                            for (let x = 0; x < leftBoundary; x += bulletSpacing) {
                                store.eBullets.push({
                                    x: x, y: -10,
                                    vx: 0, vy: bulletSpeed,
                                    r: 6, col: '#FF4500',
                                    dmg: 25 * dmgScale,
                                    life: (H + 20) / bulletSpeed + 1
                                });
                            }
                            
                            // Right side vertical bullets (moving up)
                            for (let x = rightBoundary; x < W; x += bulletSpacing) {
                                store.eBullets.push({
                                    x: x, y: H + 10,
                                    vx: 0, vy: -bulletSpeed,
                                    r: 6, col: '#FF4500',
                                    dmg: 25 * dmgScale,
                                    life: (H + 20) / bulletSpeed + 1
                                });
                            }
                            break;
                            
                        case 2:
                            // Phase 3: Diagonal cross pattern
                            // Safe zone in one corner (randomized)
                            const cornerChoice = Math.floor(Math.random() * 4);
                            let safeCornerX, safeCornerY;
                            
                            switch(cornerChoice) {
                                case 0: safeCornerX = W * 0.2; safeCornerY = H * 0.2; break; // Top-left
                                case 1: safeCornerX = W * 0.8; safeCornerY = H * 0.2; break; // Top-right  
                                case 2: safeCornerX = W * 0.2; safeCornerY = H * 0.8; break; // Bottom-left
                                case 3: safeCornerX = W * 0.8; safeCornerY = H * 0.8; break; // Bottom-right
                            }
                            
                            // Main diagonal (top-left to bottom-right)
                            const diagBulletCount1 = 20;
                            for (let i = 0; i < diagBulletCount1; i++) {
                                const t = i / (diagBulletCount1 - 1);
                                const startX = -50;
                                const startY = t * H;
                                const distance = Math.sqrt((safeCornerX - startX) ** 2 + (safeCornerY - startY) ** 2);
                                
                                if (distance > 80) { // Avoid safe zone
                                    store.eBullets.push({
                                        x: startX, y: startY,
                                        vx: bulletSpeed * 0.7, vy: bulletSpeed * 0.3,
                                        r: 6, col: '#8B0000',
                                        dmg: 25 * dmgScale,
                                        life: 6
                                    });
                                }
                            }
                            
                            // Counter diagonal (top-right to bottom-left) 
                            const diagBulletCount2 = 20;
                            for (let i = 0; i < diagBulletCount2; i++) {
                                const t = i / (diagBulletCount2 - 1);
                                const startX = W + 50;
                                const startY = t * H;
                                const distance = Math.sqrt((safeCornerX - startX) ** 2 + (safeCornerY - startY) ** 2);
                                
                                if (distance > 80) { // Avoid safe zone
                                    store.eBullets.push({
                                        x: startX, y: startY,
                                        vx: -bulletSpeed * 0.7, vy: bulletSpeed * 0.3,
                                        r: 6, col: '#8B0000',
                                        dmg: 25 * dmgScale,
                                        life: 6
                                    });
                                }
                            }
                            break;
                    }
                }
                
                // Return after 9 seconds (3 phases * 3 seconds each)
                if (disappearTime > 9) {
                    b.disappearPhase = false;
                    b.visible = true;
                    b.isInvincible = false;
                    b.fireT = 1.0;
                    
                    // Reposition boss
                    b.x = W / 2;
                    b.y = 100;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Another laugh as he returns
                    announce('THE DEATH ENGINE RETURNS!');
                }
            }
            // Phase 2: Normal combat after returning
            else if (b.phase === 2 && !b.disappearPhase) {
                // Calculate health percentage for final phase mechanics
                const healthPercent = b.hp / b.hpMax;
                const isFinalPhase = healthPercent <= 0.25; // Final phase at 25% health
                
                // Red coloration and faster movement in final phase
                const moveSpeed = isFinalPhase ? 0.9 : 0.6; // Faster movement when low on health
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Override skull ship color to red when in final phase
                if (isFinalPhase && b.color !== '#FF0000') {
                    b.color = '#FF0000'; // Turn red in final phase
                }
                
                // More aggressive attacks, even faster in final phase
                const fireRate = isFinalPhase ? 1.2 : 1.8; // Faster attacks in final phase
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = fireRate;
                    switch(b.attackPhase) { 
                        case 0: 
                            // Dense spiral (more bullets in final phase)
                            const n = isFinalPhase ? 20 : 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 1.2; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 200 * Math.cos(a), vy: 200 * Math.sin(a), r: 5, col: bulletColor, dmg: 20 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Triple aimed shots (more spread in final phase)
                            const shotCount = isFinalPhase ? 9 : 7;
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < shotCount; i++) { 
                                const angle = angleToPlayer + (i - Math.floor(shotCount/2)) * 0.12; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#FF4500';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 320 * Math.cos(angle), vy: 320 * Math.sin(angle), r: 5, col: bulletColor, dmg: 25 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // More shards (significantly more in final phase)
                            const baseShards = 3 + Math.floor(store.world.wave / 8);
                            const finalPhaseBonus = isFinalPhase ? Math.floor(baseShards * 0.75) : 0; // 75% more adds in final phase
                            const numShards = baseShards + finalPhaseBonus;
                            for(let i = 0; i < numShards; i++) { 
                                const shard = spawnEnemy('construct_shard'); 
                                shard.x = b.x + (Math.random() - 0.5) * 150; 
                                shard.y = b.y + 60; 
                                shard.color = isFinalPhase ? '#FF0000' : '#FF0000';
                                shard.hp *= isFinalPhase ? 1.5 : 1.3; // Tougher adds in final phase
                                store.enemies.push(shard); 
                            } 
                            break; 
                        case 3: 
                            // Cross pattern (more layers in final phase)
                            const layers = isFinalPhase ? 4 : 3;
                            for (let i = 0; i < 4; i++) {
                                const angle = i * Math.PI / 2;
                                for (let j = 1; j <= layers; j++) {
                                    const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                    store.eBullets.push({ 
                                        x: b.x, y: b.y, 
                                        vx: 180 * j * 0.7 * Math.cos(angle), 
                                        vy: 180 * j * 0.7 * Math.sin(angle), 
                                        r: 4, col: bulletColor, dmg: 18 * dmgScale 
                                    }); 
                                }
                            }
                            break;
                    }
                }
            }
        } else {
            // Original GEOMETRON logic (unchanged)
            if (b.hp / b.hpMax < 0.5 && b.phase === 1) { 
                b.phase = 2; 
                b.isInvincible = true; 
                playSound('horn'); 
                store.activeEffects.push(createEffect("bossPhaseChange", b.x, b.y)); 
                b.attackPhase = 0; 
                b.fireT = 2.0; 
                setTimeout(() => { b.isInvincible = false; }, 2000); 
                announce('GEOMETRON ENRAGED!'); 
            }
            
            // Movement logic
            if (b.y >= 100) { 
                b.moveT += dt; 
                const moveSpeed = (b.phase === 1) ? 0.3 : 0.7; 
                b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
            } 
            
            // Attack logic
            b.fireT -= dt; 
            if (b.fireT <= 0) { 
                if (b.phase === 1) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const n = 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numShards = 3 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numShards; i++) { 
                                const shard = spawnEnemy('construct_shard'); 
                                shard.x = b.x + (Math.random() - 0.5) * 100; 
                                shard.y = b.y + 50; 
                                store.enemies.push(shard); 
                            } 
                            break; 
                    } 
                } else { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.0; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const spread = 8; 
                            const numShots = 8; 
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < numShots; i++) { 
                                const angle = angleToPlayer + (i - (numShots - 1) / 2) * (spread * Math.PI / 180) * 0.1; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 350 * Math.cos(angle), vy: 350 * Math.sin(angle), r: 4, col: '#ff4500', dmg: 22 * dmgScale, life: 2.0 }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numShards = 2; 
                            for(let i = 0; i < numShards; i++) { 
                                const shard = spawnEnemy('construct_shard'); 
                                shard.x = b.x + (i === 0 ? -50 : 50); 
                                shard.y = b.y + 50; 
                                shard.hp *= 1.5; 
                                shard.v *= 1.3; 
                                shard.color = '#ff4500'; 
                                store.enemies.push(shard); 
                            } 
                            break; 
                    } 
                } 
            }
        }
    }
    function stepBossVoidRaven(dt, b, dmgScale) { b.moveT += dt; if (!b.isDiving) { b.y = 100 + Math.sin(b.moveT * 2) * 20; b.x = W/2 + Math.cos(b.moveT * 0.5) * (W/2 - 100); } b.fireT -= dt; if (b.fireT <=0) { b.attackPhase = (b.attackPhase + 1) % 5; switch(b.attackPhase) { case 0: case 2: b.fireT = 1.2; for(let i = 0; i < 7; i++) { const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: '#4169e1', dmg: 18 * dmgScale }); } break; case 1: case 3: b.fireT = 2.0; const numHatchlings = 2 + Math.floor(store.world.wave / 15); for(let i = 0; i < numHatchlings; i++) { const hatchling = spawnEnemy('avian_hatchling'); hatchling.x = b.x + (Math.random() - 0.5) * 80; hatchling.y = b.y + 40; store.enemies.push(hatchling); } break; case 4: b.fireT = 4.0; b.isDiving = true; b.diveTarget = { x: store.player.x, y: store.player.y }; const dx = b.diveTarget.x - b.x; const dy = b.diveTarget.y - b.y; const dist = Math.sqrt(dx*dx + dy*dy); b.vx = (dx / dist) * 400; b.vy = (dy / dist) * 400; setTimeout(() => { b.isDiving = false; b.vx = 0; b.vy = 30; }, 1500); break; } } if (b.isDiving) { b.x += b.vx * dt; b.y += b.vy * dt; } }
    
    function stepBossBroodlord(dt, b, dmgScale) {
        // Initialize poison puddles array if not exists
        if (!store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        
        // Broodlord movement - slower, more menacing
        b.moveT += dt;
        if (b.y >= 100) {
            b.x = W/2 + (W/2 - 150) * Math.sin(b.moveT * 0.4);
            b.y = 120 + Math.sin(b.moveT * 0.8) * 15;
        }
        
        // Attack phases
        b.fireT -= dt;
        if (b.fireT <= 0) {
            b.attackPhase = (b.attackPhase + 1) % 4;
            
            switch(b.attackPhase) {
                case 0:
                case 2:
                    // Poison blob barrage
                    b.fireT = 1.8;
                    const numBlobs = 5 + Math.floor(store.world.wave / 10);
                    for (let i = 0; i < numBlobs; i++) {
                        const spread = Math.PI * 0.6;
                        const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                        const angle = baseAngle + (Math.random() - 0.5) * spread;
                        const speed = 180 + Math.random() * 80;
                        
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 8,
                            col: '#7cfc00',
                            dmg: 22 * dmgScale,
                            life: 4,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 1:
                    // Acid spit pattern
                    b.fireT = 2.2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI / 4) + b.t * 0.5;
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * 160,
                            vy: Math.sin(angle) * 160,
                            r: 6,
                            col: '#adff2f',
                            dmg: 20 * dmgScale,
                            life: 3,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 3:
                    // Toxic ground slam - creates multiple puddles
                    b.fireT = 3.0;
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 60 + Math.random() * 100;
                        const puddleX = b.x + Math.cos(angle) * distance;
                        const puddleY = b.y + Math.sin(angle) * distance;
                        
                        // Create poison puddle directly
                        if (puddleX > 20 && puddleX < W - 20 && puddleY > 20 && puddleY < H - 20) {
                            store.poisonPuddles.push({
                                x: puddleX,
                                y: puddleY,
                                r: 25 + Math.random() * 15,
                                life: 15 + Math.random() * 10,
                                damage: 15 * dmgScale,
                                created: performance.now()
                            });
                        }
                    }
                    break;
            }
        }
        
        // Update poison puddles
        for (let i = store.poisonPuddles.length - 1; i >= 0; i--) {
            const puddle = store.poisonPuddles[i];
            puddle.life -= dt;
            if (puddle.life <= 0) {
                store.poisonPuddles.splice(i, 1);
            }
        }
    }
    
    function stepBoss(dt) {
        const b = store.boss;
        b.t += dt;
        if (b.y < 100) { b.y += b.vy * dt; }
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        
        if (b.slowTimer > 0) { b.slowTimer -= dt; dt *= 0.3; }

        switch (b.behavior) {
            case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break;
            case 'malignus': stepBossCoreMalignus(dt, b, dmgScale); break;
            case 'hex':      stepBossTheHex(dt, b, dmgScale); break;
            case 'construct': stepBossGeometron(dt, b, dmgScale); break;
            case 'avian':    stepBossVoidRaven(dt, b, dmgScale); break;
            case 'broodlord': stepBossBroodlord(dt, b, dmgScale); break;
        }
    }
    function drawMissile(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2);

        ctx.fillStyle = m.isIceman ? "#a0e9ff" : "#ffddff";
        ctx.shadowColor = m.isIceman ? '#3c9aed' : '#ff8080';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(4, 5); 
        ctx.lineTo(-4, 5);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;

        const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
        ctx.fillStyle = m.isIceman ? `rgba(60, 154, 237, ${0.6 + 0.4 * Math.random()})` : `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;

        ctx.beginPath();
        ctx.moveTo(-3, 5);
        ctx.lineTo(3, 5); 
        ctx.lineTo(0, 5 + flameSize);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }
    function drawPowerup(p) { const cfg = POWERUP_TYPES[p.type]; ctx.save(); ctx.translate(p.x, p.y); const pulse = 0.8 + 0.2 * Math.sin(performance.now() / 150); ctx.scale(pulse, pulse); ctx.beginPath(); ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2); const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3); grad.addColorStop(0, '#FFD70099'); grad.addColorStop(1, '#FFD70000'); ctx.fillStyle = grad; ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, p.r, 0, Math.PI * 2); ctx.fillStyle = '#FFD70044'; ctx.fill(); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 16px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(cfg.icon, 0, 1); ctx.restore(); }
    function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }
    
    function drawLaser(laser) {
        ctx.save();
        const trailLength = 200;
        const angle = Math.atan2(laser.vy, laser.vx);
        const startX = laser.x - Math.cos(angle) * trailLength;
        const startY = laser.y - Math.sin(angle) * trailLength;

        const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
        grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
        grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = laser.r * 1.5;
        ctx.lineCap = 'round';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 25;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(laser.x, laser.y);
        ctx.stroke();
        
        // Inner bright core
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = `rgba(200, 220, 255, 0.8)`;
        ctx.shadowBlur = 10;
        ctx.stroke();

        ctx.restore();
    }
// Helper: safely add alpha to a hex color (falls back if not hex)
    function addAlpha(color, alpha) {
        const a = Math.max(0, Math.min(1, alpha));
        if (typeof color === 'string' && color.startsWith('#')) {
            let hex = color.slice(1);
            if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
            if (hex.length >= 6) {
            const r = parseInt(hex.slice(0, 2), 16);
            const g = parseInt(hex.slice(2, 4), 16);
            const b = parseInt(hex.slice(4, 6), 16);
            return `rgba(${r},${g},${b},${a})`;
            }
        }
        // If it's not hex, return as-is (the caller can tweak globalAlpha if needed)
        return color;
        }

    // Skull Ship Drawing Functions

    /**
     * @class Boss
     * Represents the main antagonist character.
     * This class encapsulates all logic for rendering, animating, and managing the state of the boss.
     */
    class Boss {
        /**
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context for the canvas.
         * @param {number} x The initial X position of the boss.
         * @param {number} y The initial Y position of the boss.
         * @param {string} skullColor The color for the skull (supports red final phase).
         */
        constructor(ctx, x, y, skullColor = '#e54d24') {
            this.ctx = ctx;
            this.x = x;
            this.y = y;
            this.skullColor = skullColor;

            this.width = 180;
            this.height = 280;

            // Animation state
            this.isAttacking = false;
            this.attackStartTime = 0;
            this.bloodDrips = [];
        }

        /**
         * Triggers the boss's attack animation (laugh and scythe swipe).
         * This should be called from the main game logic (e.g., on a timer or player action).
         * @param {boolean} playAudio - Whether to play the laugh sound effect.
         */
        triggerAttack(playAudio = true) {
            if (!this.isAttacking) {
                this.isAttacking = true;
                this.attackStartTime = Date.now();

                // Play death engine laugh sound using game's sound system
                if (playAudio && typeof playSound !== 'undefined') {
                    playSound('shao_kahn');
                }

                // Reset the attack state after the animation duration
                setTimeout(() => {
                    this.isAttacking = false;
                }, 3000);
            }
        }

        /**
         * Updates the boss's state. This should be called every frame in the game loop.
         * It handles internal animations like the blood drips.
         */
        update() {
            this._updateBloodDrips();
        }

        /**
         * Renders the boss on the canvas. This should be called every frame in the game loop after `update`.
         */
        draw() {
            this.ctx.save();
            this.ctx.translate(this.x, this.y);
            this._drawHorns();
            this._drawHead();
            this._drawFacialFeatures();
            this._addWeathering(); // Scars
            this._drawBloodDrips();
            this.ctx.restore();
        }

        // --- Private Helper Methods ---

        _drawHorns() {
            const { ctx, width: skullWidth, height: skullHeight } = this;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            let swipeAngle = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                const duration = 1000;
                if (elapsedTime < duration) {
                    const progress = elapsedTime / duration;
                    swipeAngle = Math.sin(progress * Math.PI) * -0.3;
                }
            }

            const drawHornScythe = (isFlipped) => {
                const side = isFlipped ? -1 : 1;
                ctx.save();
                
                const handleGradient = ctx.createLinearGradient(0, -200, 0, 100);
                handleGradient.addColorStop(0, '#111111');
                handleGradient.addColorStop(0.5, '#333333');
                handleGradient.addColorStop(1, '#222222');
                ctx.fillStyle = handleGradient;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 18;

                ctx.beginPath();
                ctx.moveTo(side * skullWidth * 0.35, -skullHeight * 0.4);
                const handleEndX = side * 400;
                const handleEndY = -skullHeight * 0.20;
                ctx.bezierCurveTo(side * 220, -skullHeight * 0.9, side * 350, -skullHeight * 0.1, handleEndX, handleEndY);
                ctx.bezierCurveTo(side * 360, 0, side * 230, -skullHeight * 0.55, side * skullWidth * 0.25, -skullHeight * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 10, handleEndY, 14, 20, side * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 35, handleEndY - 5, 12, 18, side * 0.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.translate(handleEndX, handleEndY);
                const baseRotation = Math.PI / 4;
                ctx.rotate(side * baseRotation + side * swipeAngle);

                const bladeGradient = ctx.createLinearGradient(side * 50, 0, side * 150, 300);
                bladeGradient.addColorStop(0, '#ffffff');
                bladeGradient.addColorStop(0.5, '#e3dac9');
                bladeGradient.addColorStop(1, '#c1b8a8');
                ctx.fillStyle = bladeGradient;
                ctx.strokeStyle = '#8c8273';
                ctx.lineWidth = 4;

                ctx.beginPath();
                const tipX = side * 150;
                const tipY = 220;
                ctx.moveTo(0, -15);
                ctx.bezierCurveTo(side * 180, 80, side * 200, 200, tipX, tipY);
                ctx.bezierCurveTo(side * 130, 160, side * 40, 70, 0, 15);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.clip();
                ctx.strokeStyle = 'rgba(80, 70, 60, 0.2)';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    const startX = side * (Math.random() * 250);
                    const startY = -15 + Math.random() * 300;
                    const length = 20 + Math.random() * 30;
                    const angle = Math.random() * Math.PI * 2;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
                    ctx.stroke();
                }
                ctx.restore();
                
                if (this.isAttacking && Math.random() < 0.3) {
                    const dripSpawnPoint = { x: tipX / 2, y: tipY / 1.5 };
                    const rotatedPoint = {
                        x: dripSpawnPoint.x * Math.cos(side * baseRotation) - dripSpawnPoint.y * Math.sin(side * baseRotation),
                        y: dripSpawnPoint.x * Math.sin(side * baseRotation) + dripSpawnPoint.y * Math.cos(side * baseRotation)
                    };
                    this._addBloodDrip(handleEndX + rotatedPoint.x, handleEndY + rotatedPoint.y);
                }

                ctx.restore();
            };

            drawHornScythe(false);
            drawHornScythe(true);
        }

        _drawHead() {
            const { ctx, width: skullWidth, height: skullHeight, skullColor } = this;
            const gradient = ctx.createRadialGradient(0, -50, skullWidth * 0.1, 0, 0, skullWidth * 1.2);
            
            if (skullColor === '#FF0000') {
                // Red final phase colors
                gradient.addColorStop(0, '#ff6666');
                gradient.addColorStop(0.5, '#ff0000');
                gradient.addColorStop(1, '#660000');
            } else {
                // Original orange colors
                gradient.addColorStop(0, '#ff8c66');
                gradient.addColorStop(0.5, '#e54d24');
                gradient.addColorStop(1, '#661a00');
            }

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#1a0a05';
            ctx.lineWidth = 8;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 20;

            ctx.beginPath();
            ctx.moveTo(0, -skullHeight * 0.55);
            ctx.bezierCurveTo(-skullWidth * 0.6, -skullHeight * 0.6, -skullWidth * 0.6, -skullHeight * 0.1, -skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(-skullWidth * 0.6, skullHeight * 0.3, -skullWidth * 0.2, skullHeight * 0.55, 0, skullHeight * 0.52);
            ctx.bezierCurveTo(skullWidth * 0.2, skullHeight * 0.55, skullWidth * 0.6, skullHeight * 0.3, skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(skullWidth * 0.6, -skullHeight * 0.1, skullWidth * 0.6, -skullHeight * 0.6, 0, -skullHeight * 0.55);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.shadowColor = 'transparent';
        }

        _drawFacialFeatures() {
            const { ctx, height: skullHeight } = this;

            const drawMirrorEye = (offsetX, isFlipped) => {
                ctx.save();
                ctx.translate(offsetX, -10);
                if (isFlipped) ctx.scale(-1, 1);
                const eyePath = new Path2D();
                eyePath.moveTo(-30, -20); eyePath.lineTo(30, -30); eyePath.lineTo(25, 28); eyePath.lineTo(-25, 25); eyePath.closePath();
                for (let i = 0; i < 6; i++) {
                    ctx.fillStyle = (i % 2 === 0 || i === 5) ? '#1a0a05' : '#ff3300';
                    ctx.fill(eyePath);
                    ctx.scale(0.8, 0.75);
                }
                ctx.restore();
            };
            drawMirrorEye(-35, true);
            drawMirrorEye(35, false);

            let mouthOpenness = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 15;
            }

            ctx.strokeStyle = 'rgba(26, 10, 5, 0.8)';
            ctx.lineWidth = 2;

            for (let i = -6; i <= 6; i++) {
                if (i === 0) continue;
                let toothWidth = 10;
                let toothHeight = 25 - Math.abs(i) * 1.2;
                const isCanine = Math.abs(i) === 5 || Math.abs(i) === 6;
                if (isCanine) {
                    toothHeight += 18;
                    toothWidth -= 2;
                }
                const xPos = i * 9;
                let yPos = skullHeight * 0.53;
                yPos -= Math.pow(i, 2) * 1.8;
                yPos += mouthOpenness;
                ctx.save();
                ctx.translate(xPos, yPos);
                ctx.beginPath();
                ctx.moveTo(-toothWidth / 2, 0);
                ctx.lineTo(toothWidth / 2, 0);
                ctx.lineTo(0, toothHeight);
                ctx.closePath();
                ctx.fillStyle = '#e8d9a9';
                ctx.fill();
                ctx.stroke();
                const tipY = toothHeight;
                ctx.fillStyle = '#8c1803';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 3, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        _addWeathering() {
            const { ctx } = this;
            ctx.strokeStyle = 'rgba(26, 10, 5, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, -30);
            ctx.lineTo(70, 10);
            ctx.lineTo(65, 15);
            ctx.stroke();
        }

        _addBloodDrip(x, y) {
            if (this.bloodDrips.length > 100) return;
            this.bloodDrips.push({
                x: x,
                y: y,
                speed: 2 + Math.random() * 3,
                size: 2 + Math.random() * 3
            });
        }

        _updateBloodDrips() {
            for (let i = this.bloodDrips.length - 1; i >= 0; i--) {
                const drip = this.bloodDrips[i];
                drip.y += drip.speed;
                if (drip.y > this.ctx.canvas.height) {
                    this.bloodDrips.splice(i, 1);
                }
            }
        }

        _drawBloodDrips() {
            const { ctx } = this;
            ctx.fillStyle = '#8c1803';
            for (const drip of this.bloodDrips) {
                ctx.beginPath();
                ctx.arc(drip.x, drip.y, drip.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawBoss(t) {ctx.save(); ctx.translate(t.x, t.y); if (t.isEnraged) {ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50);} const hpRatio = Math.max(0, Math.min(1, ((t.hp || 0) / (t.hpMax || 1)))); ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(-60, -t.r - 20, 120, 8); const healthBarColor = t.name === 'EVIL BABYMOON' ? '#ffd700' : (t.color || '#ff4444'); ctx.fillStyle = healthBarColor; ctx.fillRect(-60, -t.r - 20, 120 * hpRatio, 8); ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.strokeRect(-60, -t.r - 20, 120, 8); if (t.behavior === "malignus") {const time = performance.now() / 1000; ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.4, 0, Math.PI * 2); ctx.fill(); const numShards = 5; for (let i = 0; i < numShards; i++) {ctx.save(); const angle = time * (0.5 + 0.1 * i) + i * (2 * Math.PI / numShards); const dist = 0.8 * t.r; ctx.rotate(angle); ctx.translate(dist, 0); ctx.rotate(2 * time); ctx.fillStyle = addAlpha(t.color, 0.67); ctx.strokeStyle = "#FFFFFF"; ctx.lineWidth = 2; const shardSize = 0.3 * t.r; ctx.beginPath(); ctx.moveTo(0, -shardSize); ctx.lineTo(shardSize / 2, shardSize); ctx.lineTo(-shardSize / 2, shardSize); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();}} else if (t.behavior === "hex") {ctx.translate(0, 30); const bodyW_top = t.r * 1.5; const bodyW_bottom = t.r * 2.5; const bodyH = t.r * 1.5; ctx.fillStyle = "#66aaff"; ctx.strokeStyle = "#5599e5"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_bottom / 2, bodyH / 2); ctx.lineTo(-bodyW_bottom / 2, bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#e03434"; ctx.strokeStyle = "#c02d2d"; const crownH = t.r * 0.8, crownW = bodyW_top * 0.9; ctx.beginPath(); ctx.moveTo(-crownW / 2, -bodyH / 2); ctx.lineTo(-crownW / 2 + crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(0, -bodyH / 2 - crownH / 2); ctx.lineTo(crownW / 2 - crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(crownW / 2, -bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#000"; ctx.fillRect(-t.r * 0.6, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(t.r * 0.2, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(-t.r * 0.4, 0, t.r * 0.8, t.r * 0.1); ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 8; ctx.beginPath(); ctx.arc(0, 0, t.r * 1.1, 0.5, Math.PI - 0.5); ctx.stroke(); ctx.fillStyle = "#ffd700"; ctx.strokeStyle = "#daa520"; ctx.lineWidth = 3; const medR = t.r * 0.5; ctx.beginPath(); ctx.moveTo(0, t.r * 1.1 + medR); for (let i = 1; i <= 8; i++) {const angle = i * (2 * Math.PI / 8); ctx.lineTo(medR * Math.sin(angle), t.r * 1.1 + medR * Math.cos(angle));} ctx.closePath(); ctx.fill(); ctx.stroke();} else if (t.behavior === "construct") {
        // Check if this is the DEATH ENGINE boss
        if (t.name === 'DEATH ENGINE') {
            // Update skull renderer position and color for red final phase
            if (t.skullRenderer) {
                t.skullRenderer.x = 0; // Relative position since we're already translated
                t.skullRenderer.y = 0; // Relative position since we're already translated  
                t.skullRenderer.skullColor = t.color || '#e54d24';
                
                // Handle attack animation
                if (t.isLaughing && !t.skullRenderer.isAttacking) {
                    // Trigger attack animation with sound effect
                    t.skullRenderer.triggerAttack(true);
                }
                
                // Update and draw using Boss class
                t.skullRenderer.update();
                t.skullRenderer.draw();
            } else {
                // Fallback to original drawing if skullRenderer is missing (shouldn't happen)
                const skullWidth = t.r * 2; 
                const skullHeight = t.r * 2.8; 
                
                // Calculate mouth openness for animation
                let mouthOpenness = 0;
                if (t.isLaughing) {
                    const elapsedTime = performance.now() - t.laughStartTime;
                    mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 7;
                }

                // Draw all parts of the skull ship (pass boss color for red final phase)
                const skullColor = t.color || '#e54d24';
                drawSkullHorns(ctx, skullWidth, skullHeight, skullColor);
                drawSkullMain(ctx, skullWidth, skullHeight, skullColor);
                drawSkullFace(ctx, skullWidth, skullHeight, mouthOpenness, skullColor);
                drawSkullWeathering(ctx, skullWidth, skullHeight, skullColor);
            }
        } else {
            // Original GEOMETRON drawing code
            const phaseColor = t.phase === 1 ? (t.color || "#ff4500") : "#ff4500"; ctx.fillStyle = addAlpha(phaseColor, 0.67); ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; if (t.phase === 2) {ctx.shadowColor = phaseColor; ctx.shadowBlur = 25;} const bodyW = t.r * 1.2, bodyH = t.r * 1.5, headH = t.r * 0.7; ctx.beginPath(); ctx.moveTo(-bodyW * 0.5, bodyH * 0.5); ctx.lineTo(-bodyW * 0.6, bodyH * 0.2); ctx.lineTo(-bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(0, -bodyH * 0.5); ctx.lineTo(bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(bodyW * 0.6, bodyH * 0.2); ctx.lineTo(bodyW * 0.5, bodyH * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); const shoulderY = -bodyH * 0.3, shoulderX = bodyW * 0.4; const armW = 0.4 * t.r, armH = 0.9 * t.r; ctx.beginPath(); ctx.moveTo(-shoulderX, shoulderY); ctx.lineTo(-shoulderX - armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(-shoulderX, shoulderY + armH); ctx.lineTo(-shoulderX + armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(shoulderX + armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(shoulderX, shoulderY + armH); ctx.lineTo(shoulderX - armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); const eyeR = Math.max(1, t.r * 0.2 + 2 * Math.sin(performance.now() / 200)); ctx.fillStyle = "#ffffff"; ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -headH * 0.1, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        }
    } else if (t.behavior === "avian") {ctx.save(); ctx.rotate(-Math.PI / 2); const wingY = -t.r * 0.4; ctx.strokeStyle = "#FFFFFF"; ctx.fillStyle = t.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-t.r * 0.4, wingY); ctx.quadraticCurveTo(-t.r * 0.8, wingY - t.r * 0.6, -t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(-t.r * 0.9, wingY - t.r * 0.1, -t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(t.r * 0.4, wingY); ctx.quadraticCurveTo(t.r * 0.8, wingY - t.r * 0.6, t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(t.r * 0.9, wingY - t.r * 0.1, t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0, 0, t.r * 0.6, t.r * 0.8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); const eyeSize = t.r * 0.15; ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = "#FF6600"; ctx.beginPath(); ctx.moveTo(0, t.r * 0.1); ctx.lineTo(-t.r * 0.15, t.r * 0.3); ctx.lineTo(t.r * 0.15, t.r * 0.3); ctx.closePath(); ctx.fill(); ctx.restore();} else if (t.behavior === "sentinel") {
        // Cyberpunk VOID SENTINEL with purple-orange sunset gradient
        const time = performance.now() / 1000;
        
        // Create radial gradient for cyberpunk sunset effect
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
        gradient.addColorStop(0, '#FF6B35'); // Orange center
        gradient.addColorStop(0.4, '#FF8E53'); // Orange-purple transition
        gradient.addColorStop(0.7, '#8B4A9C'); // Purple
        gradient.addColorStop(1, '#2D1B69'); // Deep purple edge
        
        // Main body - hexagonal cyberpunk shape
        ctx.fillStyle = gradient;
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const sides = 6;
        for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const x = Math.cos(angle) * t.r;
            const y = Math.sin(angle) * t.r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Inner core with pulsing effect
        const pulseSize = 0.6 + 0.2 * Math.sin(time * 3);
        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 0.5);
        coreGradient.addColorStop(0, '#FFFFFF');
        coreGradient.addColorStop(0.3, '#FF6B35');
        coreGradient.addColorStop(1, '#8B4A9C');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, t.r * 0.4 * pulseSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Cyberpunk energy rings
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            const ringTime = time * (2 + i * 0.5);
            const opacity = 0.3 + 0.4 * Math.sin(ringTime);
            ctx.globalAlpha = opacity;
            
            ctx.beginPath();
            ctx.arc(0, 0, t.r * (0.7 + i * 0.15), 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        
        // Rotating cyberpunk elements
        ctx.strokeStyle = '#8B4A9C';
        ctx.fillStyle = '#FF6B35';
        ctx.lineWidth = 2;
        
        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate(i * Math.PI / 4 + time * 0.5);
            ctx.translate(t.r * 0.8, 0);
            
            // Small diamond-shaped elements
            ctx.beginPath();
            ctx.moveTo(0, -t.r * 0.08);
            ctx.lineTo(t.r * 0.06, 0);
            ctx.lineTo(0, t.r * 0.08);
            ctx.lineTo(-t.r * 0.06, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
        // Glowing eyes with cyberpunk effect
        ctx.shadowColor = '#FF6B35';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#FFFFFF';
        
        const eyeOffset = t.r * 0.25;
        ctx.beginPath();
        ctx.arc(-eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
    } else if (t.behavior === "broodlord") {
        // Draw menacing broodlord body - insectoid and intimidating
        const time = performance.now() / 1000;
        const pulseFactor = 1 + 0.1 * Math.sin(time * 3);
        
        // Main carapace body
        ctx.fillStyle = t.color;
        ctx.strokeStyle = "#8b4513";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(0, 0, t.r * 1.2 * pulseFactor, t.r * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Segmented armor plating
        ctx.strokeStyle = "#654321";
        ctx.lineWidth = 2;
        for (let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.ellipse(0, i * t.r * 0.25, t.r * 1.1 * pulseFactor, t.r * 0.15, 0, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Menacing claws/appendages
        ctx.strokeStyle = "#2d5016";
        ctx.lineWidth = 4;
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.translate(side * t.r * 0.8, (i - 1) * t.r * 0.4);
                ctx.rotate(side * (Math.PI/6 + i * Math.PI/12) + Math.sin(time * 2 + i) * 0.2);
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.lineTo(t.r * 0.7, -t.r * 0.1);
                ctx.lineTo(t.r * 0.8, 0);
                ctx.lineTo(t.r * 0.7, t.r * 0.1);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Glowing compound eyes
        const eyeGlow = 0.5 + 0.5 * Math.sin(time * 4);
        ctx.shadowColor = "#7cfc00";
        ctx.shadowBlur = 15 * eyeGlow;
        ctx.fillStyle = "#7cfc00";
        
        for (let side = -1; side <= 1; side += 2) {
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // Pupil
            ctx.shadowBlur = 0;
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = "#7cfc00";
            ctx.shadowBlur = 15 * eyeGlow;
        }
        
        // Mandibles
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#8b4513";
        ctx.strokeStyle = "#654321";
        ctx.lineWidth = 2;
        
        const mandibleOffset = Math.sin(time * 2) * 0.1;
        for (let side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(side * t.r * 0.2, t.r * 0.2);
            ctx.rotate(side * (Math.PI/8 + mandibleOffset));
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(t.r * 0.3, -t.r * 0.1);
            ctx.lineTo(t.r * 0.4, 0);
            ctx.lineTo(t.r * 0.3, t.r * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
    } else {const time = performance.now() / 1000; ctx.fillStyle = '#2c2c54'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, t.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#706fd3'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f0932b'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.3, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 6; i++) {ctx.save(); ctx.rotate(i * Math.PI / 3 + time * 0.3); ctx.translate(t.r * 0.6, 0); ctx.fillStyle = '#ff6348'; ctx.strokeStyle = '#2f3542'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore();} const eyeSize = t.r * 0.12; ctx.fillStyle = '#ff3838'; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 4; i++) {ctx.save(); ctx.rotate(i * Math.PI / 2 + time * -0.5); ctx.translate(t.r * 0.9, 0); ctx.fillStyle = '#3c6382'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 2; ctx.fillRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.strokeRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.restore();}} ctx.restore();}

    function drawShip(t, e, player) {
        let mainColor = '#b266ff', accentColor1 = '#7a49cc', accentColor2 = '#4d2a80',
            wingStrokeColor = '#c49cff', engineColor = '#cc99ff';

        switch (player.subclass) {
            case 'juggernaut':
                mainColor = '#ff3333'; accentColor1 = '#cc0000'; accentColor2 = '#990000';
                wingStrokeColor = '#ff6666'; engineColor = '#ffaaaa';
                break;
            case 'marauder':
                mainColor = '#33cc33'; accentColor1 = '#009900'; accentColor2 = '#006600';
                wingStrokeColor = '#66ff66'; engineColor = '#aaffaa';
                break;
            case 'demolitionist':
                mainColor = '#ffcc00'; accentColor1 = '#ffaa00'; accentColor2 = '#cc8800';
                wingStrokeColor = '#ffeeaa'; engineColor = '#ffffcc';
                break;
            case 'railgunner':
                mainColor = '#9933ff'; accentColor1 = '#6600cc'; accentColor2 = '#440088';
                wingStrokeColor = '#cc99ff'; engineColor = '#e6ccff';
                break;
            case 'phasestriker':
                mainColor = '#ff69b4'; accentColor1 = '#ff1493'; accentColor2 = '#c71585';
                wingStrokeColor = '#ffb6c1'; engineColor = '#ffc0cb';
                break;
            case 'stormcaller':
                mainColor = '#00bfff'; accentColor1 = '#1e90ff'; accentColor2 = '#0000cd';
                wingStrokeColor = '#87cefa'; engineColor = '#add8e6';
                break;
        }

        ctx.save();
        ctx.translate(t,e);
        if(player.isInvincible || player.hasShieldBubble){
            ctx.beginPath();ctx.arc(0,0,24,0,2*Math.PI);
            const g=ctx.createRadialGradient(0,0,18,0,0,24);
            g.addColorStop(0,"#9a66ff11");g.addColorStop(1,"#9a66ff");
            ctx.fillStyle=g;ctx.fill()
        }
        ctx.beginPath();
        ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);
        ctx.closePath();
        const o=ctx.createLinearGradient(0,-20,0,14);
        o.addColorStop(0, mainColor);o.addColorStop(.5, accentColor1);o.addColorStop(1, accentColor2);
        ctx.fillStyle=o;ctx.fill();
        ctx.lineWidth=2;ctx.strokeStyle=wingStrokeColor;ctx.stroke();
        ctx.strokeStyle=mainColor;ctx.lineWidth=2;
        ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();
        const r=performance.now()/1e3;
        ctx.globalAlpha=.8+.2*Math.sin(10*r);
        ctx.fillStyle=engineColor;
        ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,2*Math.PI);ctx.ellipse(5,16,3,6,0,0,2*Math.PI);ctx.fill();
        ctx.globalAlpha=1;
        ctx.fillStyle="#ffffff";ctx.beginPath();ctx.arc(0,-8,3,0,2*Math.PI);ctx.fill();

        if (player.hasRearGuard && player.rearGuardReady) {
            ctx.fillStyle = `rgba(100, 255, 255, ${0.4 + 0.3 * Math.sin(performance.now() / 200)})`;
            ctx.beginPath();
            ctx.arc(0, 15, 8, 0, 2 * Math.PI);
            ctx.fill();
        }
        ctx.restore();
    }
    function drawMine(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        const time = performance.now();
        const pulse = 0.8 + 0.2 * Math.sin(time / 150);
        const fuseRatio = m.fuse / 5;
        const color = `rgb(255, ${100 * fuseRatio}, ${80 * fuseRatio})`;

        ctx.beginPath();
        ctx.arc(0, 0, m.r * 1.5 * pulse, 0, 2 * Math.PI);
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, m.r * 1.5 * pulse);
        grad.addColorStop(0, color + '99');
        grad.addColorStop(1, color + '00');
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(0, 0, m.r, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, m.r * 0.4 * pulse, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawEnemy(e) { const{x:t,y:o,r:a,type:r,color:n,hp:l,hpMax:s,t:c}=e;ctx.save();ctx.translate(t,o);l<s&&l>0&&(ctx.fillStyle='rgba(0,0,0,0.5)',ctx.fillRect(-a,-a-8,2*a,3),ctx.fillStyle="#b266ff",ctx.fillRect(-a,-a-8,2*a*(l/s),3));ctx.lineWidth=2;ctx.beginPath();switch(r){case"avian_hatchling":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a*1.2);ctx.lineTo(a,-a*0.5);ctx.lineTo(a,a*0.5);ctx.lineTo(0,a*1.2);ctx.lineTo(-a,a*0.5);ctx.lineTo(-a,-a*0.5);ctx.closePath();ctx.fill();ctx.stroke();break;case"construct_shard":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a);ctx.lineTo(a,0);ctx.lineTo(0,a);ctx.lineTo(-a,0);ctx.closePath();ctx.fill();ctx.stroke();break;case"trap_king_add":case"drone":const e=ctx.createLinearGradient(-a,-a,a,a);e.addColorStop(0,"#E0E0E0");e.addColorStop(1,"#A0A0A0");ctx.fillStyle=e;ctx.strokeStyle="#808080";ctx.beginPath();ctx.moveTo(-1.2*a,0);ctx.quadraticCurveTo(0,-a,1.2*a,0);ctx.quadraticCurveTo(0,.6*a,-1.2*a,0);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#aaddff";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-.2*a,.6*a,Math.PI,0);ctx.fill();ctx.stroke();ctx.fillStyle=r==="trap_king_add"?"#ffc83d":"#32CD32";ctx.beginPath();ctx.ellipse(0,-.2*a,.3*a,.4*a,0,0,2*Math.PI);ctx.fill();ctx.fillStyle="#000000";ctx.beginPath();ctx.ellipse(-.1*a,-.25*a,.08*a,.15*a,-.5,0,2*Math.PI);ctx.ellipse(.1*a,-.25*a,.08*a,.15*a,.5,0,2*Math.PI);ctx.fill();break;
        case "hunter":
            ctx.strokeStyle = '#BE2545';
            ctx.fillStyle = n + "cc";
            ctx.lineWidth = 2;
            ctx.shadowColor = n;
            ctx.shadowBlur = 15;

            const segments = 12;
            const length = a * 1.8;
            const amplitude = a * 0.5; 
            
            ctx.beginPath();
            
            const points1 = [];
            for (let i = 0; i <= segments; i++) {
                const progress = i / segments;
                const segmentWidth = a * Math.sin(progress * Math.PI) * 0.5;
                const x = Math.sin(progress * 2.5 * Math.PI + c * 5) * amplitude;
                const y = (progress - 0.5) * length;
                points1.push({ x: x + segmentWidth, y: y });
            }

            const points2 = [];
            for (let i = segments; i >= 0; i--) {
                const progress = i / segments;
                const segmentWidth = a * Math.sin(progress * Math.PI) * 0.5;
                const x = Math.sin(progress * 2.5 * Math.PI + c * 5) * amplitude;
                const y = (progress - 0.5) * length;
                points2.push({ x: x - segmentWidth, y: y });
            }

            ctx.moveTo(points1[0].x, points1[0].y);
            for(let i = 1; i < points1.length; i++) {
                ctx.lineTo(points1[i].x, points1[i].y);
            }
            ctx.lineTo(points2[0].x, points2[0].y);
             for(let i = 1; i < points2.length; i++) {
                ctx.lineTo(points2[i].x, points2[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            const headX = Math.sin(c * 5) * amplitude;
            const headY = -0.5 * length;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(headX - a*0.2, headY, a * 0.1, 0, 2*Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(headX + a*0.2, headY, a * 0.1, 0, 2*Math.PI);
            ctx.fill();


            ctx.shadowBlur = 0;
            break;
        case "phantom":
            ctx.globalAlpha=.6+.4*Math.sin(5*c);ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-.8*a);ctx.quadraticCurveTo(a,-.5*a,.8*a,.8*a);ctx.quadraticCurveTo(0,.5*a,-.8*a,.8*a);ctx.quadraticCurveTo(-a,-.5*a,0,-.8*a);ctx.closePath();ctx.fill();ctx.stroke();for(let e=-1;e<=1;e++)ctx.beginPath(),ctx.moveTo(e*.4*a,.6*a),ctx.quadraticCurveTo(e*.5*a,a,e*.3*a+2*Math.sin(4*c+e),1.2*a),ctx.stroke();break;
        case "mech": 
            ctx.strokeStyle = n; ctx.fillStyle = n + "99"; ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.rect(-a * 0.3, -a * 1.4, a * 0.6, a * 0.4);
            ctx.fill(); ctx.stroke();

            ctx.fillStyle = "#ff99cc";
            ctx.beginPath();
            ctx.rect(-a * 0.2, -a * 1.3, a * 0.4, a * 0.15);
            ctx.fill();

            ctx.fillStyle = n + "99";
            ctx.beginPath();
            ctx.moveTo(-a * 1.2, -a * 1.0);
            ctx.lineTo(a * 1.2, -a * 1.0); 
            ctx.lineTo(a * 0.6, a * 0.6);  
            ctx.lineTo(-a * 0.6, a * 0.6); 
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.beginPath();
            ctx.rect(-a * 1.6, -a * 0.9, a * 0.6, a * 1.8);
            ctx.rect(a * 1.0, -a * 0.9, a * 0.6, a * 1.8);
            ctx.fill(); ctx.stroke();
            
            ctx.fillStyle = n + "cc";
            ctx.beginPath();
            ctx.arc(-a * 1.3, a * 1.2, a * 0.5, 0, 2 * Math.PI);
            ctx.arc(a * 1.3, a * 1.2, a * 0.5, 0, 2 * Math.PI); 
            ctx.fill();

            ctx.fillStyle = n + "99";
            ctx.beginPath();
            ctx.rect(-a * 0.6, a * 0.6, a * 0.5, a * 0.7);
            ctx.rect(a * 0.1, a * 0.6, a * 0.5, a * 0.7); 
            ctx.fill(); ctx.stroke();
            break;
        case "angler": {
            const scale = a / 20;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle = n + "99"; ctx.strokeStyle = n; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-20,0);
            ctx.quadraticCurveTo(0,-18,24,0);
            ctx.quadraticCurveTo(0,16,-20,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-6,5);
            ctx.quadraticCurveTo(2,10,10,4);
            ctx.stroke();
            ctx.beginPath(); ctx.moveTo(8,-6);
            ctx.quadraticCurveTo(20,-24,32,-28); ctx.stroke();
            ctx.shadowColor="#00FFD5"; ctx.shadowBlur=12;
            ctx.beginPath(); ctx.arc(32,-28,4,0,Math.PI*2); ctx.fillStyle="#00FFD5"; ctx.fill();
            ctx.restore();
            break;
        }
        case "manta": {
            const scale = a / 36;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle= n + "cc"; ctx.strokeStyle=n; ctx.lineWidth=2;

            ctx.beginPath();
            ctx.moveTo(-36,0);
            ctx.quadraticCurveTo(-8,-18,0,-8);
            ctx.quadraticCurveTo(8,-18,36,0);
            ctx.quadraticCurveTo(8,14,0,8);
            ctx.quadraticCurveTo(-8,14,-36,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0,8);
            ctx.quadraticCurveTo(4,22,0,30);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
            ctx.restore();
            break;
        }
    }
    if (e.stunTimer && e.stunTimer > 0) {
        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + 0.3 * Math.sin(performance.now() / 100)})`;
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('STUN', 0, -a - 12);
    }
    ctx.restore()
    }
    function createEffect(type,x,y, radius){
        let effect={isActive:!0,life:1,maxLife:1,x,y};
        switch(type){
            case "heartbeatPulse":
                effect.maxLife = 0.6;
                effect.life = effect.maxLife;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const alpha = Math.sin((this.life / this.maxLife) * Math.PI) * 0.4;
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "beefCharge":
                effect.maxLife = 0.4;
                effect.origin = x;
                effect.target = y;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const progress = 1 - this.life;
                    const currentX = this.origin.x + (this.target.x - this.origin.x) * progress;
                    const currentY = this.origin.y + (this.target.y - this.origin.y) * progress;
        
                    ctx.save();
                    if(progress > 0.5) {
                        const shockwaveProgress = (progress - 0.5) / 0.5;
                        ctx.strokeStyle = `rgba(255, 100, 100, ${1 - shockwaveProgress})`;
                        ctx.lineWidth = 5 * (1 - shockwaveProgress);
                        ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, 80 * shockwaveProgress, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = `rgba(255, 150, 150, ${this.life})`;
                    ctx.lineWidth = 15 * this.life;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.origin.x, this.origin.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "rearGuardBlock":
                effect.maxLife = 0.5;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${this.life})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 5, 20 * (1.2 - this.life), Math.PI * 0.2, Math.PI * 0.8);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "gravityWell":
                effect.maxLife = 7;
                effect.life = 7;
                effect.radius = 0;
                effect.maxRadius = 150;
                effect.damagePulseT = 1;
                effect.totalDamageDealtToBoss = 0;
                effect.stars = [];
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * effect.maxRadius;
                    effect.stars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        r: Math.random() * 1.5,
                        initialDist: dist
                    });
                }
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) {
                        this.isActive = false;
                        screenFlash(1, 400, 'rgba(255, 255, 255, 0.5)');
                        return;
                    }
                    if (this.radius < this.maxRadius) {
                        this.radius += 200 * dt;
                    }

                    this.damagePulseT -= dt;
                    const damageThisFrame = this.damagePulseT <= 0;
                    if (damageThisFrame) {
                        this.damagePulseT = 1;
                    }
                    
                    const pullStrength = 300;
                    const damageRadiusSq = (this.maxRadius * 0.7)**2;

                    store.enemies.forEach(e => {
                        if (e.dead) {
                            return; 
                        }
                        const dx = this.x - e.x;
                        const dy = this.y - e.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < this.radius**2) {
                            const dist = Math.sqrt(distSq);
                            if (dist > 10) {
                                const resistance = (e.type === 'mech' || e.type === 'hunter') ? 0.7 : 1.0;
                                e.x += (dx / dist) * pullStrength * resistance * dt;
                                e.y += (dy / dist) * pullStrength * resistance * dt;
                            }
                            
                            if (damageThisFrame && distSq < damageRadiusSq) {
                                const damage = e.hpMax * (0.25 * store.player.dmgMult);
                                e.hp -= damage;
                                store.world.totalDamage += damage;
                                
                                // Apply vampirism healing for blink damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = damage * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }
                            }
                        }
                    });
                     if (store.boss) {
                         const b = store.boss;
                          const dx = this.x - b.x;
                          const dy = this.y - b.y;
                          const distSq = dx*dx + dy*dy;
                          if(distSq < this.radius**2) {
                               const dist = Math.sqrt(distSq);
                               if (dist > 50) {
                                   b.x += (dx/dist) * pullStrength * 0.5 * dt;
                                   b.y += (dy/dist) * pullStrength * 0.5 * dt;
                               }
                               if (damageThisFrame && distSq < damageRadiusSq) {
                                    const damageToDeal = b.hpMax * (0.10 * store.player.dmgMult);
                                    const cap = b.hpMax * 0.5;
                                    let actualDamage = damageToDeal;
                                    if (this.totalDamageDealtToBoss + actualDamage > cap) {
                                        actualDamage = cap - this.totalDamageDealtToBoss;
                                    }
                                    if (actualDamage > 0) {
                                        b.hp -= actualDamage;
                                        this.totalDamageDealtToBoss += actualDamage;
                                        store.world.totalDamage += actualDamage;
                                        
                                        // Apply vampirism healing for blink damage on boss
                                        if (store.player.vampirism > 0) {
                                            let healAmount = actualDamage * store.player.vampirism;
                                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                        }
                                    }
                               }
                           }
                      }
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const time = performance.now();
                    const lifeRatio = this.life / this.maxLife;

                    ctx.fillStyle = 'white';
                    this.stars.forEach(star => {
                        const pullFactor = 1 - lifeRatio;
                        const currentDist = star.initialDist * (1 - pullFactor * 0.95);
                        const angle = Math.atan2(star.y, star.x) + pullFactor * 3;
                        const sx = Math.cos(angle) * currentDist;
                        const sy = Math.sin(angle) * currentDist;
                        
                        if (currentDist < this.radius) {
                            ctx.globalAlpha = lifeRatio * (currentDist / this.radius);
                            ctx.beginPath();
                            ctx.arc(sx, sy, star.r, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                    ctx.globalAlpha = 1;

                    for (let i = 0; i < 5; i++) {
                        const rotation = (time / (2000 + i * 200)) % (2 * Math.PI);
                        ctx.strokeStyle = `rgba(0, 0, 5, ${0.4 * lifeRatio})`;
                        ctx.lineWidth = (2 + i) * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, (this.radius / 5) * (i + 1), rotation, rotation + Math.PI * 1.5);
                        ctx.stroke();
                    }
                    
                    const corePulse = 3 + Math.sin(time / 100) * 2;
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse * 2);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    coreGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.7)');
                    coreGrad.addColorStop(1, 'rgba(150, 150, 255, 0)');
                    ctx.fillStyle = coreGrad;
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, corePulse * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case"grenadeExplosion":
                effect.maxLife=.5;
                effect.radius=radius || 60;
                effect.step=function(dt){this.life-=2*dt;this.life<=0&&(this.isActive=!1)};
                effect.draw=function(){
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.radius*(1-this.life),0,2*Math.PI);
                    ctx.fillStyle=`rgba(255, 153, 51, ${.8*this.life})`;
                    ctx.fill()
                };
                break;
            case"shieldBreak":effect.maxLife=.6;effect.step=function(dt){this.life-=1.5*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.strokeStyle=`rgba(154, 102, 255, ${this.life})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(this.x,this.y,24*(1.5-this.life),0,2*Math.PI);ctx.stroke()};break;
            case "nanoHeal":
                effect.maxLife = 0.7;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const p = 1 - this.life;
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                    ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "critText":
                effect.maxLife = 0.6;
                effect.text = "CRITICAL!";
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 30 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                };
                break;
            case "bossPhaseChange":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; this.radius += 600 * dt; };
                effect.draw = function() {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                    ctx.lineWidth = 1 + 4 * this.life;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                };
                break;
             case "screenFlash":
                effect.maxLife = y / 1000;
                effect.life = effect.maxLife;
                effect.color = radius;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.globalAlpha = this.life / this.maxLife;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "timeRippleExplosion":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.maxRadius = 80;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.radius = this.maxRadius * (1 - this.life);
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Create time ripple effect with concentric circles
                    for (let i = 0; i < 3; i++) {
                        const rippleRadius = this.radius * (0.3 + i * 0.3);
                        const alpha = this.life * (1 - i * 0.2);
                        
                        // Outer ripple ring
                        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                        ctx.lineWidth = 3 - i;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Inner glow
                        ctx.fillStyle = `rgba(150, 220, 255, ${alpha * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius * 0.8, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    // Central time distortion effect
                    const centerAlpha = this.life * 0.6;
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                    grad.addColorStop(0, `rgba(200, 240, 255, ${centerAlpha})`);
                    grad.addColorStop(0.7, `rgba(100, 200, 255, ${centerAlpha * 0.5})`);
                    grad.addColorStop(1, `rgba(50, 150, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case "lightningFlash":
                effect.maxLife = 0.15; // Very short flash duration
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Calculate flash intensity based on remaining life
                    const intensity = Math.sin(this.life * Math.PI); // Sine wave for smooth fade
                    const alpha = intensity * 0.8;
                    
                    // Outer blue glow
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                    grad.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 150, 255, ${alpha * 0.6})`);
                    grad.addColorStop(1, `rgba(30, 100, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Inner bright white core
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Electric sparks around the edge
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI + this.life * 10; // Rotate sparks
                        const sparkX = Math.cos(angle) * (20 + Math.random() * 10);
                        const sparkY = Math.sin(angle) * (20 + Math.random() * 10);
                        
                        ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.7})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(sparkX * 0.7, sparkY * 0.7);
                        ctx.lineTo(sparkX, sparkY);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                };
                break;
        }
        return effect
    }
    
    function deployMineWall() {
        const p = store.player;
        for (let i = 0; i < 4; i++) {
            store.mines.push({
                x: p.x + (i - 1.5) * 40,
                y: p.y - 50,
                r: 10,
                fuse: 5,
                proxRadius: 75,
                isWallMine: true,
            });
        }
    }

    function explodeMine(mine) {
        playSound('explosion');
        const p = store.player;
        
        const numBullets = 18;
        for (let i = 0; i < numBullets; i++) {
            const angle = (i / numBullets) * 2 * Math.PI;
            const bulletSpeed = 300;
            store.bullets.push({
                x: mine.x, y: mine.y,
                vx: Math.cos(angle) * bulletSpeed,
                vy: Math.sin(angle) * bulletSpeed,
                r: 3, col: '#ff9966', dmg: 20 * p.dmgMult,
                pierce: false, life: 0.28
            });
        }

        const numFlames = 15;
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * 120 * Math.PI / 180;
            const speed = 250 + Math.random() * 50;
            store.bullets.push({
                x: mine.x, y: mine.y,
                vx: Math.sin(angle) * speed, vy: -Math.cos(angle) * speed,
                r: 3 + Math.random() * 2, col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`,
                dmg: 2 * p.dmgMult, life: 0.3, isFlame: true
            });
        }

        store.activeEffects.push(createEffect("grenadeExplosion", mine.x, mine.y, 55));
    }


    let shopItemOrder = [];
    function showShop() {
        pauseGame();
        const panel = q("shopPanel"),
            grid = q("shopGrid"),
            shardsEl = q("shopShards");
        shardsEl.textContent = store.world.shards;

        const currentItems = Object.keys(SHOP_UPGRADES).map(key => {
            const u = SHOP_UPGRADES[key];
            let currentLevel = store.player.upgradeLevels[key] || 0,
                cost = 0;
            if (key === 'vampirism') {
                cost = 12 + (store.player.vampirismLevel * 5);
                if (store.player.vampirismLevel >= u.max) cost = Infinity
            } else if (u.isPremium) {
                cost = u.cost
            } else {
                if (currentLevel >= u.maxLevel) {
                    cost = Infinity
                } else {
                    if (u.increment) {
                        cost = u.baseCost + (currentLevel * u.increment);
                    } else {
                        cost = Math.floor(u.baseCost * Math.pow(u.scale, currentLevel))
                    }
                }
            }
            return {
                key, ...u,
                cost
            }
        });
        const temporarilyDisabled = ["mine_wall"];

        if (shopItemOrder.length === 0) {
            const itemsToSort = [...currentItems];
            itemsToSort.sort((a, b) => {
                const aIsDisabled = temporarilyDisabled.includes(a.key);
                const bIsDisabled = temporarilyDisabled.includes(b.key);
                if (aIsDisabled && !bIsDisabled) return 1;
                if (!aIsDisabled && bIsDisabled) return -1;
                return a.cost - b.cost;
            });
            shopItemOrder = itemsToSort.map(item => item.key);
        }

        const shopItems = shopItemOrder.map(key => currentItems.find(item => item.key === key));
        
        let content = "";
        for (const u of shopItems) {
            const key = u.key;
            let currentLevel = store.player.upgradeLevels[key] || 0,
                isDisabled = false,
                cost = u.cost,
                desc = typeof u.desc === 'function' ? u.desc(currentLevel) : u.desc,
                name = u.name;
            if (u.isPremium) {
                if (key === 'vampirism') {
                    if (store.player.vampirismLevel >= u.max) isDisabled = true
                } else if (key === 'repair') {
                    if (store.player.hp >= store.player.hpMax) {
                        isDisabled = true;
                        desc = "Health is already full."
                    }
                } else if (key === 'nano_save') {
                    if (store.player.nanoSaves >= u.max) {
                        isDisabled = true;
                        desc = "Max charges reached."
                    }
                } else if (key === 'mine_wall') {
                    if (store.mines.filter(m => m.isWallMine).length > 0) {
                        isDisabled = true;
                        desc = "Wall already deployed."
                    }
                } else if (u.isUnlock) {
                    if ( (key === 'gravity_well' && store.player.hasVoidBeam) ||
                         (key === 'lazarus_beam' && store.player.hasLazarusBeam) ||
                         (key === 'launcher' && store.player.hasLauncher) ||
                         (key === 'luck_boost' && store.player.luckBoost > 0) ||
                         (key === 'magnet_pull' && store.player.magnetRadius > 0) ||
                         (key === 'rear_guard' && store.player.hasRearGuard) ||
                         (key === 'iceman' && store.player.hasIceman)) {
                        isDisabled = true;
                        desc = "Already Unlocked"
                    }
                } else {
                    if (store.player.grenades >= u.max) {
                        isDisabled = true;
                        desc = "At maximum capacity"
                    }
                }
            } else {
                if (currentLevel >= u.maxLevel) {
                    isDisabled = true;
                    desc = "Max Level Reached"
                }
            }
            if (store.world.shards < cost) isDisabled = true;
            if (temporarilyDisabled.includes(key)) {
                isDisabled = true;
                desc = "Under maintenance.";
            }
            const costText = isFinite(cost) ? cost : '---';
            content += `<div class="skill-card shop-item ${isDisabled?'disabled':''} shop-item-${u.category}" data-key="${key}"><div class="skill-icon">${u.icon}</div><div><div class="skill-title">${name}</div><div class="skill-desc">${desc}</div></div><div style="color:var(--accent);margin-top:4px;font-size:11px;">Cost: ${costText}</div></div>`
        }
        grid.innerHTML = content;
        grid.querySelectorAll(".shop-item").forEach(item => {
            item.addEventListener("click", () => {
                if (item.classList.contains('disabled')) return;
                const key = item.dataset.key;
                const upgrade = SHOP_UPGRADES[key];
                let purchaseSuccessful = false;
                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const cost = 12 + (store.player.vampirismLevel * 5);
                        if (store.world.shards >= cost) {
                            purchaseSuccessful = upgrade.apply()
                        }
                    } else {
                        const cost = upgrade.cost;
                        if (store.world.shards >= cost) {
                            store.world.shards -= cost;
                            purchaseSuccessful = upgrade.apply()
                        }
                    }
                } else {
                    const currentLevel = store.player.upgradeLevels[key] || 0;
                    let cost;
                    if (upgrade.increment) {
                        cost = upgrade.baseCost + (currentLevel * upgrade.increment);
                    } else {
                        cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                    }

                    if (store.world.shards >= cost) {
                        store.world.shards -= cost;
                        upgrade.effect(currentLevel);
                        store.player.upgradeLevels[key] = (store.player.upgradeLevels[key] || 0) + 1;
                        purchaseSuccessful = true;
                    }
                }
                if (purchaseSuccessful) {
                    showShop()
                }
            })
        });

        // Update skill tree button state
        const skillTreeBtn = q('skillTreeBtn');
        const bossCount = (store.world.bosses || 0) + 1;
        const hasSkillTreeAccess = store.player.pilotGenome && store.player.pilotGenome !== 'pending';
        const hasSkillPoints = (store.player.skillPoints || 0) > 0;
        const isTreeCapped = isSkillTreeFullyCapped();
        const skillPointsSpent = store.player.skillPointsSpent || 0;
        const reachedMaxPoints = skillPointsSpent >= 4;
        
        // Enable if: 2nd boss defeated AND (beef, rocketman, or wizard pilot) AND (has skill points OR not reached 4 points spent)
        const shouldEnable = bossCount >= 2 && hasSkillTreeAccess && (hasSkillPoints || !reachedMaxPoints);
        
        if (shouldEnable) {
            skillTreeBtn.disabled = false;
            skillTreeBtn.style.opacity = '1';
            skillTreeBtn.style.pointerEvents = 'auto';
            skillTreeBtn.onclick = () => {
                const subclassPanel = q('subclassPanel');
                // Check if skill tree is already open
                if (subclassPanel.classList.contains('skill-tree-active') && !subclassPanel.classList.contains('hide')) {
                    // Close the skill tree
                    subclassPanel.classList.add('hide');
                    subclassPanel.classList.remove('skill-tree-active');
                    resumeGame();
                } else {
                    // Open the skill tree
                    q('shopPanel').classList.add('hide');
                    showSkillTreeModal();
                }
            };
        } else {
            skillTreeBtn.disabled = true;
            skillTreeBtn.style.opacity = '0.5';
            skillTreeBtn.style.pointerEvents = 'none';
        }

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        panel.classList.remove("hide")
    }

    function showShopWithHighlight() { showShop(); announce('Low health! Use the Mech Forge to repair!'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }
    function createHound(side) {
        const isTuxedo = side === -1 || side === -2;
        let color = isTuxedo ? { main: '#222222', accent: '#FFFFFF' } : { main: '#F0E68C', accent: '#BDB76B' };
        
        let isUpgraded = false;
        let eyeType = 'normal';
        let expression = 'normal';

        if (Math.abs(side) > 1) { 
            isUpgraded = true;
            if (side === -2) { 
                color = { main: '#c4b5a0', accent: '#333' }; 
                eyeType = 'swirly';
                expression = 'silly';
            } else { 
                color = { main: '#ffb366', accent: '#000' }; 
                eyeType = 'dilated';
                expression = 'mischievous';
            }
        }

        return {
            x: store.player.x + 50 * side,
            y: store.player.y + 20,
            side,
            target: null,
            attackT: 0,
            r: 12,
            killCount: 0,
            color,
            isUpgraded,
            eyeType,
            expression
        };
    }
    function stepHounds(dt) { if (!store.player.hasHounds) return; store.hounds.forEach(h => { if (!h.target || h.target.dead || h.target.hp <= 0) { let closest = null, closestDist = Infinity; const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies; potentialTargets.forEach(e => { if (e.dead || e.hp <= 0) return; const dist = (h.x - e.x)**2 + (h.y - e.y)**2; if (dist < closestDist) { closestDist = dist; closest = e; } }); h.target = closest; } if (h.target) { const tx = h.target.x, ty = h.target.y; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); const speed = 350; if (dist > 30) { h.x += (dx / dist) * speed * dt; h.y += (dy / dist) * speed * dt; } else { h.attackT -= dt; if (h.attackT <= 0) { h.attackT = 0.25; let dmg = 8 * store.player.dmgMult; if (h.target === store.boss) dmg *= 0.3; if (!h.target.dead && h.target.hp > 0) { h.target.hp -= dmg; if (store.player.vampirism > 0) { let healAmount = dmg * store.player.vampirism; healAmount = Math.max(healAmount, 0.5); healAmount = Math.min(healAmount, 2); store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount); } if (h.target.hp <= 0) { h.killCount++; if (h.killCount > 0 && h.killCount % 12 === 0) { playSound('dogs'); } } } } } } else { const tx = store.player.x + h.side * 50, ty = store.player.y + 20; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 5) { h.x += dx * 5 * dt; h.y += dy * 5 * dt; } } }); }
    function drawHound(h) {
        ctx.save();
        ctx.translate(h.x, h.y);
        const time = performance.now();
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time / 1000 + h.side);
        const r = h.r;

        if (!h.isUpgraded) {
            const { main, accent } = h.color;
            const isTuxedo = accent === '#FFFFFF';

            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.5);
            ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
            ctx.quadraticCurveTo(r * 1.2, 0, r, r);
            ctx.lineTo(-r, r);
            ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.4);
            ctx.lineTo(-r * 0.5, -r * 1.2);
            ctx.lineTo(-r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r, -r * 0.4);
            ctx.lineTo(r * 0.5, -r * 1.2);
            ctx.lineTo(r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();

            if (isTuxedo) {
                ctx.fillStyle = accent;
                ctx.beginPath();
                ctx.moveTo(-r * 0.6, r * 0.2);
                ctx.quadraticCurveTo(0, r, r * 0.6, r * 0.2);
                ctx.lineTo(0, r * 0.5);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.3, r * 0.5, r * 0.4, 0, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, r * 0.5);
            ctx.lineTo(-r * 0.1, r * 0.5);
            ctx.lineTo(-r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.3, r * 0.5);
            ctx.lineTo(r * 0.1, r * 0.5);
            ctx.lineTo(r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
        } else {
            const color = h.color.main;
            const opacity = ctx.globalAlpha;
            const eyeType = h.eyeType;
            const expression = h.expression;
            const radius = r * 1.5;

            if (h.side === 2) {
                ctx.save();
                ctx.globalAlpha = 0.7 * opacity;
                ctx.fillStyle = '#9966ff';
                ctx.beginPath();
                ctx.moveTo(0, -radius * 1.8);
                ctx.lineTo(-radius * 0.8, -radius * 0.9);
                ctx.lineTo(radius * 0.8, -radius * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius * 0.6, -radius * 0.7);
            ctx.lineTo(-radius * 0.4, -radius * 1.2);
            ctx.lineTo(-radius * 0.2, -radius * 0.8);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.6, -radius * 0.7);
            ctx.lineTo(radius * 0.4, -radius * 1.2);
            ctx.lineTo(radius * 0.2, -radius * 0.8);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius, 0);
            for(let i = 0; i <= 6; i++) {
                let waveX = -radius + (radius * 2 / 6) * i;
                let waveY = radius + Math.sin(i * 0.8 + time * 0.005) * radius * 0.2;
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(radius, 0);
            ctx.fill();

            ctx.fillStyle = 'white';
            
            if (eyeType === 'dilated') {
                ctx.beginPath();
                ctx.ellipse(-radius * 0.35, -radius * 0.1, radius * 0.28, radius * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(radius * 0.35, -radius * 0.15, radius * 0.25, radius * 0.32, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-radius * 0.3 + Math.sin(time * 0.001) * radius * 0.05,
                      -radius * 0.05, radius * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.4,
                      -radius * 0.2 + Math.cos(time * 0.001) * radius * 0.05,
                      radius * 0.06, 0, Math.PI * 2);
                ctx.fill();
            } else { // 'swirly'
                ctx.beginPath();
                ctx.arc(-radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'black';
                ctx.lineWidth = radius * 0.04;
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = -radius * 0.35 + Math.cos(t + time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t + time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = radius * 0.35 + Math.cos(t - time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t - time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            
            ctx.fillStyle = 'white';
            
            ctx.beginPath();
            ctx.moveTo(-radius * 0.25, radius * 0.2);
            ctx.lineTo(-radius * 0.2, radius * 0.5);
            ctx.lineTo(-radius * 0.15, radius * 0.2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.25, radius * 0.2);
            ctx.lineTo(radius * 0.2, radius * 0.5);
            ctx.lineTo(radius * 0.15, radius * 0.2);
            ctx.fill();
            
            for(let i = -1; i <= 1; i++) {
                if(i === 0) continue;
                ctx.beginPath();
                ctx.moveTo(i * radius * 0.08, radius * 0.2);
                ctx.lineTo(i * radius * 0.08 + radius * 0.02, radius * 0.35);
                ctx.lineTo(i * radius * 0.08 - radius * 0.02, radius * 0.35);
                ctx.fill();
            }
            
            ctx.strokeStyle = expression === 'silly' ? '#000' : '#333';
            ctx.lineWidth = radius * 0.03;
            ctx.beginPath();
            
            if (expression === 'silly') {
                ctx.moveTo(-radius * 0.3, radius * 0.15);
                ctx.quadraticCurveTo(-radius * 0.1, radius * 0.05, 0, radius * 0.15);
                ctx.quadraticCurveTo(radius * 0.1, radius * 0.25, radius * 0.3, radius * 0.15);
            } else {
                ctx.arc(0, 0, radius * 0.35, Math.PI * 0.2, Math.PI * 0.8);
            }
            ctx.stroke();
        }
        ctx.restore();
    }
    function drawIceman(iceman) {
        const { x, y } = iceman;
        ctx.save();
        ctx.translate(x, y);
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12, 8);
        ctx.lineTo(8, 14);
        ctx.lineTo(0, 10);
        ctx.lineTo(-8, 14);
        ctx.lineTo(-12, 8);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
        bodyGrad.addColorStop(0, "#a0e9ff");
        bodyGrad.addColorStop(1, "#3c9aed");
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d0f8ff";
        ctx.stroke();

        ctx.strokeStyle = "#a0e9ff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 5);
        ctx.lineTo(-20, -2);
        ctx.lineTo(-18, 8);
        ctx.moveTo(12, 5);
        ctx.lineTo(20, -2);
        ctx.lineTo(18, 8);
        ctx.stroke();

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(0, -8, 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawLightningBolt(bolt) {
        const { points, life, maxLife } = bolt;
        const t = life / maxLife;
        if (t <= 0) return;

        ctx.save();
        ctx.lineWidth = 4 * t;
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * t})`;
        ctx.shadowColor = '#9a66ff';
        ctx.shadowBlur = 20 * t;
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        
        ctx.lineWidth = 1.5 * t;
        ctx.strokeStyle = `rgba(200, 220, 255, ${t})`;
        ctx.shadowBlur = 10 * t;
        ctx.stroke();

        ctx.restore();
    }

    function drawEmpNova(nova) {
        ctx.save();
        
        // Create pulsing effect
        const time = performance.now() / 1000;
        const pulse = 0.8 + 0.2 * Math.sin(time * 8);
        const opacity = Math.min(1, nova.life / 2) * 0.3; // Fade in over 2 seconds
        
        // Draw expanding EMP ring
        ctx.strokeStyle = `rgba(255, 140, 0, ${opacity * pulse})`; // Orange cyberpunk color
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]); // Dashed line for tech effect
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner energy ring
        ctx.strokeStyle = `rgba(138, 43, 226, ${opacity * pulse * 0.7})`; // Purple
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 10;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        
        // Add some sparking effects around the perimeter
        ctx.setLineDash([]);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * pulse})`;
        ctx.lineWidth = 1;
        
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2 + time * 2;
            const x1 = nova.x + Math.cos(angle) * (nova.radius - 5);
            const y1 = nova.y + Math.sin(angle) * (nova.radius - 5);
            const x2 = nova.x + Math.cos(angle) * (nova.radius + 5);
            const y2 = nova.y + Math.sin(angle) * (nova.radius + 5);
            
            if (Math.random() < 0.3) { // Random sparking
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        ctx.restore();
    }

    function activateGravityWell() {
        if (!store.isPaused) {
            const spawnX = W * 0.2 + Math.random() * W * 0.6;
            const spawnY = H * 0.2 + Math.random() * H * 0.6;
            store.activeEffects.push(createEffect("gravityWell", spawnX, spawnY));
            announce('GRAVITY WELL ACTIVATED');
            screenFlash(2, 250, 'rgba(255, 255, 255, 0.7)');
        }
    }
    function activateLazarus() {
        if (store.player.hasLazarusBeam && !store.isPaused) {
            const angle = Math.random() * 2 * Math.PI,
                speed = 800,
                p = store.player;
            store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 6, r: 12, hitEnemies: new Set });
            
            if (p.upgradeLevels.lazarus_beam > 1) {
                const oppositeAngle = angle + Math.PI;
                store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(oppositeAngle) * speed, vy: Math.sin(oppositeAngle) * speed, life: 6, r: 12, hitEnemies: new Set });
            }
        }
    }
    function useGrenade() {
        if (store.player.grenades > 0 && !store.isPaused) {
            playSound('explosion');
            store.player.grenades--;
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 400;
                store.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 5, col: '#ff8080', dmg: 40 * p.dmgMult,
                    pierce: true, life: 0.8
                });
            }
            store.activeEffects.push(createEffect("shieldBreak", p.x, p.y));
        }
    }
    
    function stepVoidLaser(dt) {
        const p = store.player;
        const maxRange = p.r * 12; // Doubled range from 6 to 12 ship lengths
        
        // Timer for retargeting - check for new targets every 0.1 seconds
        p.voidLaserRetargetTimer -= dt;
        if (p.voidLaserRetargetTimer <= 0) {
            p.voidLaserRetargetTimer = 0.1;
            
            // Find closest enemy within range
            const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
            let closestTarget = null;
            let closestDistSq = maxRange * maxRange;
            
            allEnemies.forEach(e => {
                const distSq = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                if (distSq < closestDistSq) {
                    closestDistSq = distSq;
                    closestTarget = e;
                }
            });
            
            p.voidLaserTarget = closestTarget;
        }
        
        // Apply continuous damage if we have a target
        if (p.voidLaserTarget && !p.voidLaserTarget.dead) {
            // Check if target is still in range
            const distSq = (p.x - p.voidLaserTarget.x) ** 2 + (p.y - p.voidLaserTarget.y) ** 2;
            if (distSq <= maxRange * maxRange) {
                // Damage timer - apply damage every 0.1 seconds for smooth continuous damage
                p.voidLaserDamageTimer -= dt;
                if (p.voidLaserDamageTimer <= 0) {
                    p.voidLaserDamageTimer = 0.1;
                    
                    // Increased damage - was 6.33, now 8.5 per 0.1s (85 DPS vs original 63.33 DPS)
                    let damage = 8.5 * p.dmgMult;
                    if (p.voidLaserTarget === store.boss) damage *= 0.3; // Reduced damage to boss
                    
                    p.voidLaserTarget.hp -= damage;
                    store.world.totalDamage += damage;
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.1); // Minimum heal
                        healAmount = Math.min(healAmount, 0.6); // Increased heal cap slightly
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            } else {
                // Target out of range
                p.voidLaserTarget = null;
            }
        }
    }
    
    function fireChainLightning() {
        const p = store.player;
        
        if (p.hasDoubleStorm) {
            // Fire two chain lightning bolts with stochastic chaining
            fireChainLightningBolt();
            setTimeout(() => fireChainLightningBolt(), 100); // Slight delay for visual effect
        } else if (p.hasHybridVoid) {
            // Fire single lightning bolt (reduced power for hybrid)
            fireChainLightningBolt(0.7); // 70% damage for hybrid mode
        } else {
            // Standard single chain lightning with stochastic chaining
            fireChainLightningBolt();
        }
    }
    
    function fireChainLightningBolt(damageMultiplier = 1.0) {
        const p = store.player;
        const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
        if (allEnemies.length === 0) return;

        let closestDistSq = Infinity;
        let currentTarget = null;
        allEnemies.forEach(e => {
            const distSq = (p.x - e.x)**2 + (p.y - e.y)**2;
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                currentTarget = e;
            }
        });

        if (!currentTarget) return;

        const maxJumps = 25; // Increased to 25 for jackpot potential
        const chainChance = 0.5; // 50% chance to chain
        let currentDamage = 95 * p.dmgMult * damageMultiplier;
        const targetsHit = new Set();
        const chainPoints = [{ x: p.x, y: p.y - 20 }];

        for (let i = 0; i < maxJumps && currentTarget; i++) {
            targetsHit.add(currentTarget);
            chainPoints.push({ x: currentTarget.x, y: currentTarget.y });

            // Create blue lightning flash at hit point
            store.activeEffects.push(createEffect('lightningFlash', currentTarget.x, currentTarget.y));

            let dmg = currentDamage;
            if (currentTarget === store.boss) dmg *= 0.3;
            currentTarget.hp -= dmg;
            store.world.totalDamage += dmg;
            
            // Apply vampirism healing for chain lightning damage
            if (store.player.vampirism > 0) {
                let healAmount = dmg * store.player.vampirism;
                healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for lightning
                healAmount = Math.min(healAmount, 3); // Cap at 3 HP for lightning
                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
            }

            // Check if the lightning should chain (50% chance each jump)
            if (Math.random() >= chainChance) {
                // Chain failed - stop here
                break;
            }

            // Find next target for chaining
            let nextTarget = null;
            let nextDistSq = Infinity;
            allEnemies.forEach(e => {
                if (e.dead || targetsHit.has(e)) return;
                const distSq = (currentTarget.x - e.x)**2 + (currentTarget.y - e.y)**2;
                if (distSq < nextDistSq) {
                    nextDistSq = distSq;
                    nextTarget = e;
                }
            });

            // If no valid target found, stop chaining
            if (!nextTarget) break;

            currentTarget = nextTarget;
            currentDamage *= 0.85; // Slightly less decay since we have probabilistic limiting
        }

        if (chainPoints.length > 1) {
            store.lightningBolts.push({
                points: chainPoints,
                life: 0.4,
                maxLife: 0.4,
                dead: false
            });
        }
    }
    
    const VOIDSTEP = {
        cooldownMs: 2500,
        iframeMs: 220,
        riftMs: 600,
        edgePadding: 6
    };
    let lastVoidStep = -9999;
    let invulUntil = 0;
    const rifts = [];
    const blinkFlashes = [];
    function spawnBlinkFlash(x, y, life=200){ blinkFlashes.push({x, y, life, birth: performance.now(), dead:false}); }
    function spawnRift(x1,y1,x2,y2, life=VOIDSTEP.riftMs){
        rifts.push({ x1,y1,x2,y2, birth: performance.now(), life, dead:false });
    }

function clampToField(nx, ny){
    const pad = VOIDSTEP.edgePadding;
    nx = Math.max(pad, Math.min(W - pad, nx));
    ny = Math.max(pad, Math.min(H - pad, ny));
    return { nx, ny };
}

function tryVoidStep(player, target, now = performance.now()){
    const cd = VOIDSTEP.cooldownMs;
    if (now - lastVoidStep < cd) return false;

    const start = { x: player.x, y: player.y };
    let { nx, ny } = clampToField(target.x, target.y);

    if (player.blinkDamage) {
        const dx = nx - start.x;
        const dy = ny - start.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let damage = 150 * player.dmgMult;
        
        // Enhanced damage for phasestriker mastery
        if (player.blinkDamageEnhanced) {
            damage = 200 * player.dmgMult;
        }
        
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dot = (((e.x - start.x) * dx) + ((e.y - start.y) * dy)) / (dist * dist);
            const closestX = start.x + dot * dx;
            const closestY = start.y + dot * dy;
            
            const onSegment = dot > 0 && dot < 1;
            if (onSegment) {
                 const distToLine = Math.sqrt((e.x - closestX)**2 + (e.y - closestY)**2);
                 if (distToLine < e.r + 10) {
                     e.hp -= damage;
                     store.world.totalDamage += damage;
                     
                     // Apply vampirism healing for void step damage
                     if (store.player.vampirism > 0) {
                         let healAmount = damage * store.player.vampirism;
                         healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                         healAmount = Math.min(healAmount, 6); // Cap at 6 HP
                         store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                     }
                 }
            }
        });
    }

    spawnRift(start.x, start.y, nx, ny, VOIDSTEP.riftMs);

    player.x = nx; player.y = ny;
    invulUntil = now + VOIDSTEP.iframeMs;
    lastVoidStep = now;

    // Phasestriker mastery: Time ripple explosion at destination
    if (player.blinkDamageEnhanced) {
        // Create time ripple explosion effect
        store.activeEffects.push(createEffect("timeRippleExplosion", nx, ny));
        
        // Damage enemies in explosion radius
        const explosionRadius = 80;
        const explosionDamage = 120 * player.dmgMult;
        const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
        targets.forEach(e => {
            if (e.dead) return;
            const distSq = (e.x - nx)**2 + (e.y - ny)**2;
            if (distSq < explosionRadius**2) {
                e.hp -= explosionDamage;
                store.world.totalDamage += explosionDamage;
            }
        });
    }

    // Impact shockwave for earthquake enhancement
    if (player.hasImpactPhase) {
        createImpactShockwave(nx, ny, player.dmgMult);
    }

    spawnBlinkFlash(nx, ny);
    return true;
}
    
    // Impact shockwave system for earthquake enhancement
    const impactRipples = [];
    
    function createImpactShockwave(x, y, dmgMult) {
        const shockDamage = 200 * dmgMult;  // High impact damage
        const maxRadius = 120;  // Large earthquake radius
        
        // Create expanding ripple effect
        impactRipples.push({
            x: x, y: y,
            radius: 0,
            maxRadius: maxRadius,
            life: 0.8,
            maxLife: 0.8,
            birth: performance.now(),
            dead: false
        });
        
        // Damage all enemies in impact radius
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3; // 30% falloff at edge
                const actualDamage = shockDamage * damageFalloff;
                e.hp -= actualDamage;
                store.world.totalDamage += actualDamage;
                
                // Knockback effect
                if (dist > 0) {
                    const knockbackForce = 200;
                    const knockbackX = (e.x - x) / dist * knockbackForce;
                    const knockbackY = (e.y - y) / dist * knockbackForce;
                    e.knockback = { x: knockbackX, y: knockbackY, duration: 0.3, timer: 0.3 };
                }
            }
        });
        
        // Damage boss if in range
        if (store.boss && !store.boss.dead) {
            const dist = Math.sqrt((store.boss.x - x)**2 + (store.boss.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3;
                const bossDamage = shockDamage * damageFalloff * 0.4;
                store.boss.hp -= bossDamage; // Reduced boss damage
                store.world.totalDamage += bossDamage;
            }
        }
        
        playSound('thunder'); // Play earthquake sound
    }
    
    function updateImpactSystem() {
        const now = performance.now();
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const age = (now - ripple.birth) / 1000; // Convert to seconds
            ripple.radius = (age / ripple.maxLife) * ripple.maxRadius;
            
            if (age >= ripple.maxLife) {
                ripple.dead = true;
            }
        }
        
        // Remove dead ripples
        for (let i = impactRipples.length - 1; i >= 0; i--) {
            if (impactRipples[i].dead) {
                impactRipples.splice(i, 1);
            }
        }
    }
    
    function renderImpactSystem(ctx) {
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const now = performance.now();
            const age = (now - ripple.birth) / 1000;
            const progress = age / ripple.maxLife;
            const alpha = 1.0 - progress; // Fade out over time
            
            ctx.save();
            ctx.globalAlpha = alpha * 0.6;
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;  // Yellow earthquake ripples
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner ripple for more impact
            if (progress < 0.7) {
                ctx.globalAlpha = alpha * 0.4;
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius * 0.6, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    
    function updateVoidStepSystems(enemies){
        for (const r of rifts) if (!r.dead) {
        if(performance.now() - r.birth >= r.life) r.dead = true;
        }
        for (const f of blinkFlashes) if (!f.dead) {
        if(performance.now() - f.birth >= f.life) f.dead = true;
        }
        for (let i=rifts.length-1; i>=0; i--) if (rifts[i].dead) rifts.splice(i,1);
        for (let i=blinkFlashes.length-1; i>=0; i--) if (blinkFlashes[i].dead) blinkFlashes.splice(i,1);
    }

    function renderVoidStepSystems(ctx){
        rifts.forEach(r => {
            const t = (performance.now() - r.birth)/r.life;
            if (t>=1) { r.dead = true; return; }
            const a = (1 - t) * 0.8 + 0.2;
            ctx.save();
            ctx.globalAlpha = a;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 10 * (1-t);
            ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 25 * (1-t);
            ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
            ctx.restore();
        });
        blinkFlashes.forEach(f => {
            const t = (performance.now() - f.birth)/f.life;
            if (t>=1) { f.dead = true; return; }
            ctx.save();
            ctx.globalAlpha = 1 - t;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 4 * (1 - t);
            ctx.shadowColor="#b266ff"; ctx.shadowBlur=20;
            ctx.beginPath();
            ctx.arc(f.x, f.y, 20 + 30 * t, 0, Math.PI*2);
            ctx.stroke();

            ctx.globalAlpha = 1 - t*t;
            ctx.beginPath(); ctx.arc(f.x, f.y, 20 * (1-t), 0, Math.PI*2);
            ctx.fillStyle="#ffddff"; ctx.fill();
            ctx.restore();
        });
    }
    
    function playerIsInvulnerable(){ return performance.now() < invulUntil; }
    
    function screenFlash(count, duration, color) {
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                store.activeEffects.push(createEffect("screenFlash", 0, duration, color));
            }, i * (duration / 2));
        }
    }

    // --- PAUSE & MENU LOGIC ---
    const PANELS = ['namePanel', 'pilotPanel', 'scorePanel', 'levelPanel', 'shopPanel', 'storyPanel', 'subclassPanel'];
    function isAnyPanelOpen() {
        return PANELS.some(id => !q(id).classList.contains('hide'));
    }
    
    function pauseGame() {
        if (!store.isPaused) {
            store.isPaused = true;
            q('pauseBtn').classList.add('hide');
        }
    }

    function resumeGame() {
        if (!isAnyPanelOpen()) {
            store.isPaused = false;
            q('pauseBtn').classList.remove('hide');
            q('pauseBtn').textContent = 'PAUSE';
        }
    }
    
    // --- EVENT LISTENERS & INITIALIZATION ---
    function showPilotSelect() {
        playSound('epicHorn');
        pauseGame();
        const panel = q('pilotPanel');
        
        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }
        
        panel.classList.remove('hide');
        const cards = panel.querySelectorAll('.skill-card');
        
        const clickHandler = (e) => {
            const card = e.currentTarget;
            const genome = card.dataset.genome;
            store.player.pilotGenome = genome;
            panel.classList.add('hide');
            applyGenomeBonus(genome);
            resumeGame();
            cards.forEach(c => c.removeEventListener('click', clickHandler));
        };
        
        cards.forEach(card => {
            card.addEventListener('click', clickHandler);
        });
    }

    // --- GIBBING EFFECT ---

    // Initialize the gibs array in your game's store
    store.gibs = [];

    /**
     * Spawns a cluster of gib particles at a specific location.
     * Call this function when an enemy dies.
     * @param {number} x - The x-coordinate of the enemy.
     * @param {number} y - The y-coordinate of the enemy.
     * @param {string} color - The base color of the enemy.
     * @param {number} [amount=15] - The number of gibs to create.
     */
    function spawnGibs(x, y, color, amount = 15) {
        for (let i = 0; i < amount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 50 + Math.random() * 150;
            const size = 2 + Math.random() * 4;
            const life = 0.5 + Math.random() * 0.5;

            store.gibs.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                r: size,
                life,
                maxLife: life,
                color,
                gravity: 300, // Pulls gibs downward
            });
        }
    }

    /**
     * Updates the position and lifetime of all active gibs.
     * This should be called once per frame from your main game loop.
     * @param {number} dt - Delta time, the time since the last frame.
     */
    function updateGibs(dt) {
        for (let i = store.gibs.length - 1; i >= 0; i--) {
            const gib = store.gibs[i];
            
            // Apply physics
            gib.vy += gib.gravity * dt;
            gib.x += gib.vx * dt;
            gib.y += gib.vy * dt;
            gib.life -= dt;

            // Remove gibs that have expired
            if (gib.life <= 0) {
                store.gibs.splice(i, 1);
            }
        }
    }

    /**
     * Draws all active gibs to the canvas.
     * This is called from the main render() function.
     * @param {object} ctx - The 2D rendering context of the canvas.
     */
    function drawGibs(ctx) {
        store.gibs.forEach(gib => {
            const alpha = gib.life / gib.maxLife; // Fade out effect
            
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha);
            ctx.fillStyle = gib.color;
            ctx.beginPath();
            ctx.fillRect(gib.x - gib.r / 2, gib.y - gib.r / 2, gib.r, gib.r);
            ctx.restore();
        });
    }

    function applyGenomeBonus(genome) {
        if (!genome) return;

        // Reset all potential subclass stats to their defaults
        const p = store.player;
        p.subclass = null;
        p.beefMaxCharges = 1;
        p.missilePierce = 0;
        p.missileCluster = false;
        p.blinkDamage = false;
        p.hasChainLightning = false;
        p.hasVoidLaser = false;
        p.voidLaserTarget = null;
        p.voidLaserDamageTimer = 0;
        p.voidLaserRetargetTimer = 0;
        console.log('GENOME RESET: Reset blinkDamage=false, hasChainLightning=false, hasVoidLaser=false');

        store.world.bossesAtPilotSelection = store.world.bosses;
        
        switch(genome) {
            case 'beef':
                p.hpMax *= 1.2;
                p.hp = p.hpMax;
                break;
            case 'wizard':
                // Initialize voidmancer laser beam system instead of multishot
                p.hasVoidLaser = true;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                break;
            case 'rocketman':
                break;
        }
    }
    
    const SUBCLASSES = {
        rocketman: [
            { id: 'railgunner', name: 'Railgunner', desc: 'Missiles pierce through multiple enemies with devastating precision.', icon: 'rail.png' },
            { id: 'demolitionist', name: 'Demolitionist', desc: 'Missiles explode into deadly cluster bombs on impact.', icon: 'demo.png' }
        ],
        beef: [
            { id: 'juggernaut', name: 'juggernaut', desc: 'Charge ability creates a damaging explosion on impact.', icon: 'jug2.png' },
            { id: 'marauder', name: 'Marauder', desc: 'Gain a second charge for your special ability.', icon: 'marauder.png' }
        ],
        wizard: [
            { id: 'phasestriker', name: 'Phase Striker', desc: 'Blink now damages all enemies you pass through.', icon: 'phase.png' },
            { id: 'stormcaller', name: 'Stormcaller', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
        ]
    };

    function showSubclassSelect() {
        pauseGame();
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const skillTree = q('skillTree');
        const genome = store.player.pilotGenome;

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        // Show traditional card selection for all pilots (including beef)
        const choices = SUBCLASSES[genome];
        if (!choices) {
            resumeGame();
            return;
        }
        
        skillTree.classList.add('hide');
        grid.classList.remove('hide');
        panel.classList.remove('skill-tree-active'); // Ensure normal panel size for subclass selection
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-subclass="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const subclassId = card.dataset.subclass;
                store.player.subclass = subclassId;
                applySubclassBonus(subclassId);
                panel.classList.add('hide');
                resumeGame();
            }, { once: true });
        });

        panel.querySelector('h2').style.display = 'block'; // Show h2 for subclass selection
        panel.classList.remove('hide');
    }

    function showSkillTreeModal() {
        playSound('epicHorn');
        pauseGame();
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const skillTree = q('skillTree');

        // Check if skill tree is fully capped before showing
        if (isSkillTreeFullyCapped()) {
            console.log('Skill tree is fully capped - not showing modal');
            resumeGame();
            return;
        }

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        // Hide grid, show skill tree
        grid.classList.add('hide');
        skillTree.classList.remove('hide');
        panel.classList.add('skill-tree-active'); // Expand panel for skill tree
        panel.classList.remove('hide');

        // Hide the h2 since skill tree has its own title
        panel.querySelector('h2').style.display = 'none';

        // Generate dynamic skill tree based on pilot type
        generateDynamicSkillTree();
        
        // Set up close button handler AFTER generating the tree
        const closeBtn = q('skillTreeCloseBtn');
        if (closeBtn) {
            closeBtn.onclick = () => {
                closeSkillTree();
            };
        }
        
        // Update UI to reflect learned skills
        updateSkillTreeUI();
        
        // Set up click handlers for skill buttons
        setupSkillTreeHandlers();
        
        // If no skill points are available or 4 skill points have been spent, don't show the tree
        if (store.player.skillPoints <= 0 || skillPointsSpent >= 4) {
            console.log(`Not showing skill tree - ${store.player.skillPoints <= 0 ? 'no skill points available' : '4 skill points spent'} (${skillPointsSpent}/4)`);
            panel.classList.add('hide');
            resumeGame();
            return;
        }
    }

    function generateDynamicSkillTree() {
        const skillTreeElement = q('skillTree');
        const pilotType = store.player.pilotGenome;
        
        if (pilotType === 'beef') {
            // Keep existing beef skill tree
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">BEEF SPECIALIZATION TREE</div>
                <div class="skill-grid">
                    <div class="skill-row">
                        <div class="skill-track">
                            <div class="track-title">MARAUDER</div>
                            <div class="skill-icon-button available" data-skill="marauder" data-tier="1">
                                <img src="marauder.png" alt="Marauder" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">MARAUDER</div>
                                    <div class="skill-overlay-desc">Rapid assault specialist with multiple charges for sustained combat dominance</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="marauder_enhanced" data-tier="2" data-parent="marauder">
                                <img src="marauder.png" alt="Triple Charge" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">TRIPLE CHARGE</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced marauder with three devastating charges</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">JUGGERNAUT</div>
                            <div class="skill-icon-button available" data-skill="juggernaut" data-tier="1">
                                <img src="jug.png" alt="Juggernaut" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">JUGGERNAUT</div>
                                    <div class="skill-overlay-desc">Heavy assault specialist with devastating explosive impact attacks</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="juggernaut_enhanced" data-tier="2" data-parent="juggernaut">
                                <img src="jug.png" alt="Big Bang" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">BIG BANG</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced juggernaut with massive explosion radius</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="skill-description" id="skillDescription">
                    Choose your specialization path: Marauder for sustained assault, Juggernaut for devastating impact. Select both for the ultimate combo!
                </div>`;
        } else if (pilotType === 'rocketman') {
            // Create rocketman skill tree
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">ROCKETMAN SPECIALIZATION TREE</div>
                <div class="skill-grid">
                    <div class="skill-row">
                        <div class="skill-track">
                            <div class="track-title">RAILGUNNER</div>
                            <div class="skill-icon-button available" data-skill="railgunner" data-tier="1">
                                <img src="rail.png" alt="Railgunner" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">RAILGUNNER</div>
                                    <div class="skill-overlay-desc">Precision missile specialist with devastating piercing capabilities</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="railgunner_enhanced" data-tier="2" data-parent="railgunner">
                                <img src="rail.png" alt="Super Pierce" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">SUPER PIERCE</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced railgunner with maximum piercing power</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">DEMOLITIONIST</div>
                            <div class="skill-icon-button available" data-skill="demolitionist" data-tier="1">
                                <img src="demo.png" alt="Demolitionist" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">DEMOLITIONIST</div>
                                    <div class="skill-overlay-desc">Explosive missile specialist with devastating cluster bombs</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="demolitionist_enhanced" data-tier="2" data-parent="demolitionist">
                                <img src="demo.png" alt="Mega Clusters" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">MEGA CLUSTERS</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced demolitionist with massive cluster explosions</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="skill-description" id="skillDescription">
                    Choose your specialization path: Railgunner for piercing precision, Demolitionist for explosive devastation. Select both for the ultimate combo!
                </div>`;
        } else if (pilotType === 'wizard') {
            // Create wizard skill tree
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">VOIDMANCER SPECIALIZATION TREE</div>
                <div class="skill-grid">
                    <div class="skill-row">
                        <div class="skill-track">
                            <div class="track-title">PHASE STRIKER</div>
                            <div class="skill-icon-button available" data-skill="phasestriker" data-tier="1">
                                <img src="phase.png" alt="Phase Striker" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">PHASE STRIKER</div>
                                    <div class="skill-overlay-desc">Void manipulation specialist with damaging blink teleportation</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="phasestriker_enhanced" data-tier="2" data-parent="phasestriker">
                                <img src="phase.png" alt="Void Blink" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">VOID BLINK</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced phase striker with devastating void blink damage</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">STORMCALLER</div>
                            <div class="skill-icon-button available" data-skill="stormcaller" data-tier="1">
                                <img src="storm.png" alt="Stormcaller" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">STORMCALLER</div>
                                    <div class="skill-overlay-desc">Lightning manipulation specialist with chain lightning weaponry</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="stormcaller_enhanced" data-tier="2" data-parent="stormcaller">
                                <img src="storm.png" alt="Chain Storm" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">CHAIN STORM</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced stormcaller with maximum chain lightning power</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="skill-description" id="skillDescription">
                    Choose your specialization path: Phase Striker for void teleportation, Stormcaller for chain lightning. Select both for the ultimate combo!
                </div>`;
        } else {
            // Fallback for unknown pilot types
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">UNKNOWN PILOT TYPE</div>
                <div class="skill-description" id="skillDescription">
                    Skill tree not available for this pilot type.
                </div>`;
        }
    }
    
    function initializeSkillTree() {
        const p = store.player;
        const pilotType = p.pilotGenome;
        
        // Initialize skill tree properties if needed
        if (!p.skillTree) {
            if (pilotType === 'beef') {
                p.skillTree = { juggernaut: false, marauder: false, juggernaut_enhanced: false, marauder_enhanced: false };
            } else if (pilotType === 'rocketman') {
                p.skillTree = { railgunner: false, demolitionist: false, railgunner_enhanced: false, demolitionist_enhanced: false };
            } else if (pilotType === 'wizard') {
                p.skillTree = { phasestriker: false, stormcaller: false, phasestriker_enhanced: false, stormcaller_enhanced: false };
            } else {
                // Fallback for unknown pilot types
                p.skillTree = {};
            }
        }
        if (!p.skillTreeProgress) p.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
        if (!p.skillPoints) p.skillPoints = 0;
        if (!p.skillPointsSpent) p.skillPointsSpent = 0;
        
        // Don't award skill points here - they're awarded in handleBossDefeat
        // Just update the UI with whatever points we have
        updateSkillTreeUI();
        setupSkillTreeHandlers();
    }
    
    function updateSkillTreeUI() {
        const p = store.player;
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        
        // Update button states first, regardless of whether tree will close
        iconButtons.forEach(button => {
            const skill = button.dataset.skill;
            const tier = parseInt(button.dataset.tier);
            const parent = button.dataset.parent;
            
            // Remove all state classes
            button.classList.remove('available', 'active', 'locked');
            
            if (p.skillTree && p.skillTree[skill]) {
                // Skill is learned - show active glow effect
                button.classList.add('active');
            } else if (canLearnSkill(skill, tier, parent)) {
                // Skill can be learned - show available state
                button.classList.add('available');
            } else {
                // Skill is locked - show dim state
                button.classList.add('locked');
            }
        });
        
        // Safety check: if no skill points remain and skill tree is open, close it
        if (p.skillPoints <= 0 && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
            setTimeout(() => {
                console.log('Auto-closing skill tree from updateSkillTreeUI - no points remaining');
                closeSkillTree();
            }, 100);
            return;
        }
        
        // If tree is fully capped, also close it
        if (isSkillTreeFullyCapped() && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
            setTimeout(() => {
                console.log('Auto-closing skill tree from updateSkillTreeUI - tree fully capped');
                closeSkillTree();
            }, 100);
            return;
        }
        
        // If 4 skill points have been spent, don't auto-close (allow viewing)
        // const skillPointsSpent = p.skillPointsSpent || 0;
        // if (skillPointsSpent >= 4 && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
        //     setTimeout(() => {
        //         console.log(`Auto-closing skill tree from updateSkillTreeUI - 4 skill points spent (${skillPointsSpent}/4)`);
        //         closeSkillTree();
        //     }, 100);
        //     return;
        // }
    }
    
    function canLearnSkill(skill, tier, parent) {
        const p = store.player;
        const pilotType = p.pilotGenome;
        
        // Can't learn a skill that's already learned
        if (p.skillTree && p.skillTree[skill]) return false;
        
        if (p.skillPoints <= 0) return false;
        
        if (tier === 1) {
            return true; // First tier is always available with skill points
        }
        
        if (tier === 2) {
            if (parent === 'both') {
                // Requires both tier 1 skills based on pilot type
                if (pilotType === 'beef') {
                    return p.skillTree.juggernaut && p.skillTree.marauder;
                } else if (pilotType === 'rocketman') {
                    return p.skillTree.railgunner && p.skillTree.demolitionist;
                } else if (pilotType === 'wizard') {
                    return p.skillTree.phasestriker && p.skillTree.stormcaller;
                }
            } else {
                // Requires specific parent skill
                return p.skillTree[parent];
            }
        }
        
        return false;
    }
    
    function setupSkillTreeHandlers() {
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        const description = q('skillDescription');
        
        // Remove any existing handlers first to prevent duplicates
        iconButtons.forEach(button => {
            button.replaceWith(button.cloneNode(true));
        });
        
        // Re-query after cloning to get fresh elements
        const freshButtons = document.querySelectorAll('.skill-icon-button');
        
        // Updated skill descriptions for icon button system
        const skillDescriptions = {
            // Beef skills
            juggernaut: "Heavy assault specialist with explosive charge impacts and superior defensive capabilities.",
            marauder: "Rapid assault specialist with multiple charge capacity for sustained offensive operations.",
            juggernaut_enhanced: "MASTERY: Enhanced juggernaut with devastating explosion radius and catastrophic damage output.", 
            marauder_enhanced: "MASTERY: Elite marauder with triple charge capacity for relentless battlefield dominance.",
            
            // Rocketman skills
            railgunner: "Precision missile specialist with devastating piercing capabilities that cut through multiple enemies.",
            demolitionist: "Explosive missile specialist with cluster bombs that devastate large areas on impact.",
            railgunner_enhanced: "MASTERY: Enhanced railgunner with maximum piercing power and superior accuracy.",
            demolitionist_enhanced: "MASTERY: Elite demolitionist with massive cluster explosions and enhanced area damage.",
            
            // Wizard skills
            phasestriker: "Void manipulation specialist with damaging blink teleportation that harms enemies you pass through.",
            stormcaller: "Lightning manipulation specialist with chain lightning weaponry that arcs between targets.",
            phasestriker_enhanced: "MASTERY: Enhanced phase striker with devastating void blink damage and increased range.",
            stormcaller_enhanced: "MASTERY: Elite stormcaller with maximum chain lightning power and enhanced conductivity."
        };
        
        // Add hover effects to icon buttons
        freshButtons.forEach(button => {
            const skill = button.dataset.skill;
            
            button.addEventListener('mouseenter', () => {
                description.textContent = skillDescriptions[skill] || "Specialization path available";
            });
            
            button.addEventListener('mouseleave', () => {
                const pilotType = store.player.pilotGenome;
                if (pilotType === 'beef') {
                    description.textContent = "Choose your specialization path: Marauder for sustained assault, Juggernaut for devastating impact. Select both for the ultimate combo!";
                } else if (pilotType === 'rocketman') {
                    description.textContent = "Choose your specialization path: Railgunner for piercing precision, Demolitionist for explosive devastation. Select both for the ultimate combo!";
                } else if (pilotType === 'wizard') {
                    description.textContent = "Choose your specialization path: Phase Striker for void teleportation, Stormcaller for chain lightning. Select both for the ultimate combo!";
                }
            });
        });
        
        // Click handlers - icon buttons are directly clickable
        freshButtons.forEach(button => {
            button.addEventListener('click', () => {
                console.log('Button clicked:', button.dataset.skill, 'Classes:', button.className);
                if (button.classList.contains('available')) {
                    const skill = button.dataset.skill;
                    console.log('About to learn skill:', skill);
                    learnSkill(skill);
                }
            });
        });
    }
    
    let isLearningSkill = false;
    
    function learnSkill(skill) {
        if (isLearningSkill) {
            console.log('Already learning a skill, ignoring duplicate call');
            return;
        }
        
        isLearningSkill = true;
        console.log('Learning skill:', skill);
        
        try {
            const p = store.player;
            const skillButton = document.querySelector(`[data-skill="${skill}"]`);
            const tier = parseInt(skillButton.dataset.tier);
            
            console.log('Skill tier:', tier, 'Can learn:', canLearnSkill(skill, tier, skillButton.dataset.parent));
            if (!canLearnSkill(skill, tier, skillButton.dataset.parent)) {
                isLearningSkill = false;
                return;
            }
            
            if (!p.skillTree) p.skillTree = {};
            p.skillTree[skill] = true;
            p.skillPoints--; // Spend the skill point
            p.skillPointsSpent = (p.skillPointsSpent || 0) + 1; // Track total spent
            
            console.log('Applying skill bonus for:', skill);
            // Apply the skill effects
            applySkillBonus(skill);
            
            console.log('Checking for combo...');
            // Check for combo when both base skills are learned
            const pilotType = p.pilotGenome;
            if (tier === 1) {
                if (pilotType === 'beef' && p.skillTree.marauder && p.skillTree.juggernaut) {
                    p.beefDoubleCharge = true;
                    announce('DOUBLE CHARGE COMBO ACTIVATED!');
                } else if (pilotType === 'rocketman' && p.skillTree.railgunner && p.skillTree.demolitionist) {
                    p.rocketmanHybrid = true;
                    announce('HYBRID MISSILES COMBO ACTIVATED!');
                } else if (pilotType === 'wizard' && p.skillTree.phasestriker && p.skillTree.stormcaller) {
                    p.wizardHybrid = true;
                    announce('VOID STORM COMBO ACTIVATED!');
                }
            }
            
            console.log('Updating UI...');
            updateSkillTreeUI();
            
            console.log('Remaining skill points:', p.skillPoints);
            
            // Check if tree is now fully capped
            if (isSkillTreeFullyCapped()) {
                setTimeout(() => {
                    console.log('Skill tree is now fully capped - closing tree');
                    closeSkillTree();
                }, 1500);
            } else if (p.skillPoints <= 0) {
                // Close skill tree if no more points remaining
                setTimeout(() => {
                    console.log('Auto-closing skill tree - no points remaining');
                    closeSkillTree();
                }, 1500);
            }
            // Note: No longer auto-closing when 4 skill points are spent - allow viewing
        } catch (error) {
            console.error('Error in learnSkill:', error);
        } finally {
            isLearningSkill = false;
        }
    }
    
    function closeSkillTree() {
        const panel = q('subclassPanel');
        panel.classList.add('hide');
        panel.classList.remove('skill-tree-active');
        resumeGame();
    }
    
    function isSkillTreeFullyCapped() {
        const p = store.player;
        const pilotType = p.pilotGenome;
        
        if (!p.skillTree) return false;
        
        // Define all possible skills for each pilot type
        const allSkills = {
            'beef': ['marauder', 'juggernaut', 'marauder_enhanced', 'juggernaut_enhanced'],
            'rocketman': ['railgunner', 'demolitionist', 'railgunner_enhanced', 'demolitionist_enhanced'],
            'wizard': ['phasestriker', 'stormcaller', 'phasestriker_enhanced', 'stormcaller_enhanced']
        };
        
        const skillsForPilot = allSkills[pilotType];
        if (!skillsForPilot) return false;
        
        // Check if all skills are learned - debug output
        const allLearned = skillsForPilot.every(skill => p.skillTree[skill] === true);
        console.log(`Skill tree cap check for ${pilotType}: ${allLearned ? 'CAPPED' : 'NOT CAPPED'}`, skillsForPilot.map(s => `${s}:${p.skillTree[s] || false}`));
        
        return allLearned;
    }
    
    function applySkillBonus(skill) {
        console.log('applySkillBonus called with skill:', skill);
        const p = store.player;
        
        switch(skill) {
            case 'juggernaut':
                p.subclass = 'juggernaut';
                // Give 2 charges like marauder originally gave
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                p.beefCharges = Math.max(p.beefCharges, 2);
                announce('JUGGERNAUT ACTIVATED - Larger Impact!');
                break;
            case 'marauder':
                p.subclass = 'marauder';
                // Give 2 charges
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);  
                p.beefCharges = Math.max(p.beefCharges, 2);
                announce('MARAUDER ACTIVATED - Extra Charge!');
                break;
                
            // Tier 2 Enhanced Skills
            case 'marauder_enhanced':
                p.beefMaxCharges = 3;
                p.beefCharges = Math.max(p.beefCharges, 3);
                announce('TRIPLE CHARGE ACTIVATED!');
                break;
            case 'juggernaut_enhanced':
                p.beefBigExplosion = true;
                announce('BIG BANG EXPLOSION ACTIVATED!');
                break;
                
            // Rocketman skills
            case 'railgunner':
                // Don't overwrite existing subclass if they already have demolitionist
                if (p.subclass !== 'demolitionist') {
                    p.subclass = 'railgunner';
                }
                p.missilePierce = 2;
                announce('RAILGUNNER ACTIVATED - Piercing Missiles!');
                break;
            case 'demolitionist':
                // Don't overwrite existing subclass if they already have railgunner
                if (p.subclass !== 'railgunner') {
                    p.subclass = 'demolitionist';
                }
                p.missileCluster = true;
                announce('DEMOLITIONIST ACTIVATED - Cluster Bombs!');
                break;
                
            // Rocketman Tier 2 Enhanced Skills
            case 'railgunner_enhanced':
                // Enhanced railgunner should preserve existing abilities
                if (!p.missilePierce) p.missilePierce = 2; // Give basic piercing if they don't have it
                p.missilePierce = Math.max(p.missilePierce, 4);
                announce('SUPER PIERCE ACTIVATED - Maximum Penetration!');
                break;
            case 'demolitionist_enhanced':
                // Enhanced demolitionist should preserve existing abilities
                if (!p.missileCluster) p.missileCluster = true; // Give basic clusters if they don't have them
                p.missileClusterEnhanced = true;
                announce('MEGA CLUSTERS ACTIVATED - Devastating Explosions!');
                break;
                
            // Wizard skills
            case 'phasestriker':
                p.subclass = 'phasestriker';
                p.blinkDamage = true;
                announce('PHASE STRIKER ACTIVATED - Damaging Blink!');
                break;
            case 'stormcaller':
                p.subclass = 'stormcaller';
                p.hasChainLightning = true;
                announce('STORMCALLER ACTIVATED - Chain Lightning!');
                break;
                
            // Wizard Tier 2 Enhanced Skills
            case 'phasestriker_enhanced':
                p.blinkDamageEnhanced = true;
                announce('VOID BLINK ACTIVATED - Maximum Void Damage!');
                break;
            case 'stormcaller_enhanced':
                p.chainLightningEnhanced = true;
                announce('CHAIN STORM ACTIVATED - Maximum Lightning Power!');
                break;
        }
    }

    function applySubclassBonus(subclass) {
        const p = store.player;

        switch(subclass) {
            case 'railgunner': p.missilePierce = 2; break;
            case 'demolitionist': p.missileCluster = true; break;
            case 'juggernaut': break;
            case 'marauder': p.beefMaxCharges = 2; p.beefCharges = 2; break;
            case 'phasestriker': p.blinkDamage = true; break;
            case 'stormcaller':
                p.hasChainLightning = true;
                playSound('thunder');
                break;
        }
        store.world.enemyHealthBonus *= 1.10;
}

    function showSpecSelect(isAdditive = false) {
        pauseGame();
        const panel = q('subclassPanel'); // Reuse the subclass panel
        const grid = q('subclassGrid');
        const p = store.player;
        const genome = p.pilotGenome;
        
        let choices = [];
        
        if (genome === 'rocketman') {
            if (p.subclass === 'demolitionist') {
                if (isAdditive && p.enhancedClusters) {
                    // If they already have enhanced clusters, double current power
                    choices = [{ id: 'double_clusters', name: 'MEGA CLUSTERS', desc: 'Cluster explosions are twice as large and deal massive damage.', icon: 'demo.png' }];
                } else if (isAdditive && p.missilePierce > 0) {
                    // If they have railgunner abilities, give them enhanced clusters
                    choices = [{ id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' }];
                } else {
                    // First spec or missing railgunner - offer both
                    const opts = [
                        { id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' },
                        { id: 'railgunner_pierce', name: 'PIERCING MISSILES', desc: 'Missiles pierce through 3 enemies with devastating force.', icon: 'rail.png' },
                        { id: 'compact_clusters_pierce', name: 'COMPACT PIERCING', desc: 'Smaller clusters but missiles pierce through 2 enemies.', icon: 'rail.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_clusters');
                }
            } else if (p.subclass === 'railgunner') {
                if (isAdditive && p.enhancedPierce) {
                    choices = [{ id: 'mega_pierce', name: 'ULTRA PIERCE', desc: 'Missiles pierce through 6 enemies with increased damage.', icon: 'rail.png' }];
                } else if (isAdditive && p.enhancedClusters) {
                    choices = [{ id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' }];
                } else {
                    const opts = [
                        { id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' },
                        { id: 'cluster_missiles', name: 'CLUSTER MISSILES', desc: 'Missiles explode into smaller cluster bombs.', icon: 'demo.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_pierce');
                }
            }
        } else if (genome === 'wizard') {
            // Voidmancer only gets the power they don't have
            if (!p.hasStormcaller && !p.hasPhasestriker) {
                // First spec - let them choose
                choices = [
                    { id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' },
                    { id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                ];
            } else if (!p.hasStormcaller) {
                choices = [{ id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }];
            } else if (!p.hasPhasestriker) {
                choices = [{ id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' }];
            } else {
                // They have both - offer three enhanced void caller options
                choices = [
                    { id: 'double_storm', name: 'TWIN LIGHTNING', desc: 'Fires two chain lightning bolts instead of one.', icon: 'storm.png' },
                    { id: 'hybrid_void', name: 'VOID STORM', desc: 'Voidstep damages enemies + unlocks single lightning bolt.', icon: 'phase.png' },
                    { id: 'impact_phase', name: 'EARTHQUAKE', desc: 'Voidstep creates a massive impact shockwave at destination.', icon: 'void.png' }
                ];
            }
        } else if (genome === 'beef') {
            // Handle beef subclasses similarly
            if (p.subclass === 'juggernaut') {
                choices = [{ id: 'enhanced_juggernaut', name: 'MEGA JUGGERNAUT', desc: 'Massive charge radius and knockback increase.', icon: 'jug2.png' }];
            } else if (p.subclass === 'marauder') {
                choices = [{ id: 'enhanced_marauder', name: 'SHIELD MASTER', desc: 'Charge restores even more shields and grants temporary invulnerability.', icon: 'marauder.png' }];
            }
        }
        
        if (!choices.length) {
            resumeGame();
            return;
        }
        
        const title = isAdditive ? 'ENHANCED SPECIALIZATION' : 'CHOOSE SPECIALIZATION';
        document.querySelector('#subclassPanel h2').textContent = title;
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-spec="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const specId = card.dataset.spec;
                applySpecBonus(specId);
                panel.classList.add('hide');
                resumeGame();
                document.querySelector('#subclassPanel h2').textContent = 'CHOOSE SPECIALIZATION'; // Reset title
            }, { once: true });
        });

        panel.classList.remove('hide');
    }

    // DISABLED: applySpecBonus function for stability  
    function applySpecBonus(specId) {
        const p = store.player;
        
        switch(specId) {
            case 'enhanced_clusters':
                p.enhancedClusters = true;
                announce('ENHANCED CLUSTERS ACTIVATED!');
                break;
            case 'double_clusters':
                // Implement double cluster damage
                announce('MEGA CLUSTERS ACTIVATED!');
                break;
            case 'railgunner_pierce':
                p.missilePierce = 3;
                announce('PIERCING MISSILES ACTIVATED!');
                break;
            case 'compact_clusters_pierce':
                p.missilePierce = 2;
                // Keep clusters small but add pierce
                announce('COMPACT PIERCING ACTIVATED!');
                break;
            case 'enhanced_pierce':
                p.enhancedPierce = true;
                p.missilePierce = Math.max(p.missilePierce, 4); // Ensure at least 4 pierce
                announce('ENHANCED PIERCE ACTIVATED!');
                break;
            case 'mega_pierce':
                p.missilePierce = 6;
                announce('ULTRA PIERCE ACTIVATED!');
                break;
            case 'cluster_missiles':
                p.missileCluster = true;
                announce('CLUSTER MISSILES ACTIVATED!');
                break;
            case 'phasestriker':
                p.hasPhasestriker = true;
                p.blinkDamage = true;
                console.log('PHASESTRIKER: Set blinkDamage=true, hasPhasestriker=true');
                announce('PHASESTRIKER ACTIVATED!');
                break;
            case 'stormcaller':
                p.hasStormcaller = true;
                p.hasChainLightning = true;
                console.log('STORMCALLER: Set hasChainLightning=true, hasStormcaller=true');
                announce('CHAIN LIGHTNING ACTIVATED!');
                playSound('thunder');
                break;
            case 'double_storm':
                p.hasDoubleStorm = true;
                announce('TWIN CHAIN LIGHTNING ACTIVATED!');
                break;
            case 'hybrid_void':
                p.hasHybridVoid = true; 
                p.blinkDamage = true;  // Enable voidstep damage
                announce('VOID STORM ACTIVATED!');
                break;
            case 'impact_phase':
                p.hasImpactPhase = true;
                p.blinkDamage = true;  // Ensure voidstep does damage
                announce('EARTHQUAKE ACTIVATED!');
                break;
            case 'enhanced_storm':
                announce('MEGA STORM ACTIVATED!');
                break;
            case 'enhanced_phase':
                announce('VOID MASTERY ACTIVATED!');
                break;
            case 'enhanced_juggernaut':
                announce('MEGA JUGGERNAUT ACTIVATED!');
                break;
            case 'enhanced_marauder':
                announce('SHIELD MASTER ACTIVATED!');
                break;
        }
    }


    function ensureName(){
        if(!store.name){
            pauseGame();
            const panel = q("namePanel");
            
            // Initialize matrix
            const matrixContainer = panel.querySelector('.matrix-container');
            if (matrixContainer.matrix) {
                matrixContainer.matrix.init();
            }
            
            panel.classList.remove("hide");
            q("nameInput").value="";
            setTimeout(()=>q("nameInput").focus(),50)
        } else {
            resumeGame();
            if (store.player.pilotGenome === null) {
                initWave();
            }
        }
    }
    
    q("restartBtn").addEventListener("click", resetGame);
    
    q("saveName").addEventListener("click",()=>{const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}});
    
    const closeShopLogic = () => { q("shopPanel").classList.add('hide'); resumeGame(); const highlighted = document.querySelector('.shop-item.highlight'); if (highlighted) highlighted.classList.remove('highlight'); };
    q("closeShopTopBtn").addEventListener("click", closeShopLogic);
    q("closeShop").addEventListener("click", closeShopLogic);

    q("shopBtn").addEventListener("click", () => {
        if (q('shopPanel').classList.contains('hide')) {
            showShop();
        } else {
            closeShopLogic();
        }
    });

    const closeScoresLogic = () => { q('scorePanel').classList.add('hide'); resumeGame(); };
    // q("closeScores").addEventListener("click", closeScoresLogic); // Button hidden via CSS
    
    q("menuBtn").addEventListener("click",()=>{
        if (q('scorePanel').classList.contains('hide')) {
            pauseGame();
            
            // Initialize matrix
            const matrixContainer = q('scorePanel').querySelector('.matrix-container');
            if (matrixContainer.matrix) {
                matrixContainer.matrix.init();
            }
            
            q('scorePanel').classList.remove('hide');
        } else {
            closeScoresLogic();
        }
    });

    q("fsEnterBtn").addEventListener('click',()=>{const r=document.documentElement;if(!document.fullscreenElement){if(r.requestFullscreen)r.requestFullscreen();else if(r.webkitRequestFullscreen)r.webkitRequestFullscreen();else if(r.msRequestFullscreen)r.msRequestFullscreen()}else{if(document.exitFullscreen)document.exitFullscreen()}});
    
    q('pauseBtn').addEventListener('click',()=>{
        if(store.isGameOver || isAnyPanelOpen()) return;
        store.isPaused = !store.isPaused;
        q('pauseBtn').textContent = store.isPaused ? 'RESUME' : 'PAUSE';
    });
    
    q('grenadeBtnUI').addEventListener('click',useGrenade);

    q('storyBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        pauseGame();
        
        // Initialize matrix
        const matrixContainer = q('storyPanel').querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }
        
        q('storyPanel').classList.remove('hide');
    });
    q('storyPanel').addEventListener('click', () => {
        q('storyPanel').classList.add('hide');
        if (!q('pilotPanel').classList.contains('hide')) {
        } else {
            resumeGame();
        }
    });
    
    q("nameInput").addEventListener("keydown",(e)=>{if(e.key==="Enter"){const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}}});

    q("namePanel").addEventListener("click", (e) => {
        if(e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
            q('nameInput').blur();
        }
    });
    
    let cheatCodeBuffer = "";
    let cheatTapCount = 0;
    let lastCheatTap = 0;

    function activateDamageOffCheat() {
    if (store.isDamageOff) return;
    store.isDamageOff = true;
    store.cheatsUsed = true;
    announce('CHEAT: DAMAGE & ABILITIES OFF');

    const p = store.player;
    const propsToDisable = [
        'dmgMult', 'multishot', 'rearMultishot', 'piercing', 'explosive', 
        'flamethrowerLevel', 'missileVolley', 'critChance', 'critDamage', 
        'hasLauncher', 'hasHounds', 'hasLazarusBeam', 'hasVoidBeam', 
        'hasChainLightning', 'hasIceman', 'blinkDamage', 'missilePierce', 'missileCluster',
        'hasDoubleStorm', 'hasHybridVoid', 'hasImpactPhase'
    ];
    
    store.savedPlayerState = {};
    propsToDisable.forEach(prop => {
        store.savedPlayerState[prop] = p[prop];
        if (typeof p[prop] === 'number') {
            p[prop] = 0;
        } else if (typeof p[prop] === 'boolean') {
            p[prop] = false;
        }
    });

    store.savedPlayerState.hounds = store.hounds;
    store.hounds = [];
    store.savedPlayerState.iceman = store.iceman;
    store.iceman = null;
}

    function deactivateDamageOffCheat() {
        if (!store.isDamageOff || !store.savedPlayerState) return;
        store.isDamageOff = false;
        announce('CHEAT: DAMAGE & ABILITIES ON');

        const p = store.player;
        for (const prop in store.savedPlayerState) {
            if (prop === 'hounds') {
                store.hounds = store.savedPlayerState.hounds;
            } else if (prop === 'iceman') {
                store.iceman = store.savedPlayerState.iceman;
            } else if (p.hasOwnProperty(prop)) {
                p[prop] = store.savedPlayerState[prop];
            }
        }
        
        store.savedPlayerState = null;
}

    function activateSubclassCheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (store.player.subclass) {
            announce("CHEAT FAILED: Subclass already chosen.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO SUBCLASS SELECT');
        showSubclassSelect();
    }
    
    function activateClassCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO CLASS SELECT');
        showPilotSelect();
    }
    
    function activatePowerCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: POWER UP!');
        resetGame();
        store.world.shards = 800;
        store.player.multishot = 10;
        initWave();
        cheatCodeBuffer = "";
    }

    // ENABLED: Spec2 cheat functions  
    function activateSpec2Cheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (!store.player.subclass) {
            announce("CHEAT FAILED: Choose a Subclass first.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: JUMPING TO SUB2');
        showSpecSelect(true); // true = additive/second spec
    }

    function activateSpeedCheat() {
        // Initialize if not present
        if (!window.gameSpeedMultiplier || window.gameSpeedMultiplier < 1) {
            window.gameSpeedMultiplier = 1;
        }
        
        // Cycle through speed multipliers: 1x -> 2x -> 3x -> 1x
        if (window.gameSpeedMultiplier === 1) {
            window.gameSpeedMultiplier = 2;
            announce('CHEAT: GAME SPEED 2X');
        } else if (window.gameSpeedMultiplier === 2) {
            window.gameSpeedMultiplier = 3;
            announce('CHEAT: GAME SPEED 3X');
        } else {
            window.gameSpeedMultiplier = 1;
            announce('CHEAT: GAME SPEED NORMAL');
        }
        
        store.cheatsUsed = true;
        console.log('Speed multiplier set to:', window.gameSpeedMultiplier);
    }

    q('diagBox').children[0].addEventListener('click', () => {
        const now = performance.now();
        if (now - lastCheatTap > 500) {
            cheatTapCount = 0;
        }
        lastCheatTap = now;
        cheatTapCount++;
        if (cheatTapCount >= 3) {
            activatePowerCheat();
            cheatTapCount = 0;
        }
    });

    addEventListener("keydown", e => {
        const key = e.key.toLowerCase();
        if (document.activeElement.tagName === "INPUT") return;

        if (/[a-z]/.test(key)) {
            cheatCodeBuffer += key;
            if (cheatCodeBuffer.length > 10) {
                cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
            }

            if (cheatCodeBuffer.endsWith('power')) {
                activatePowerCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('off')) {
                activateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('on')) {
                deactivateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('spec')) {
                activateSubclassCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('sub2')) {
                activateSpec2Cheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('fast')) {
                activateSpeedCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('class')) {
                activateClassCheat();
                cheatCodeBuffer = "";
            }
        } else {
            if (key !== ' ' && key !== 'b') {
                cheatCodeBuffer = "";
            }
        }

        if (key === ' ') { e.preventDefault(); useGrenade() }
        if (key === 'escape') { 
            e.preventDefault(); 
            // Close skill tree if it's open
            if (!q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                closeSkillTree();
            }
        }
    });

    let lastTapTime = 0;
    cvs.addEventListener('touchend', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'wizard' && !store.isPaused && !store.isGameOver) {
            const now = performance.now();
            const DOUBLE_TAP_DELAY = 300;
            if (now - lastTapTime < DOUBLE_TAP_DELAY) {
                const p = pointFromEvent(e);
                tryVoidStep(store.player, p);
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: false });

    cvs.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'wizard' && !store.isPaused && !store.isGameOver) {
            const p = pointFromEvent(e);
            tryVoidStep(store.player, p);
        }
    });
    function frame(now) {
        const rawDt = Math.min((now - store.last) / 1000, 0.07);
        const speedMultiplier = window.gameSpeedMultiplier || 1;
        // Cap the dt to prevent simulation instability even with speed multiplier
        const dt = Math.min(rawDt * speedMultiplier, 0.1); 
        
        store.last = now;
        if (!store.isPaused && !store.isGameOver) {
            stepWorld(dt);
        }
        render(rawDt); // Use original dt for rendering to avoid visual issues
        requestAnimationFrame(frame);
    }
    try{
        ensureName();
        refreshScoreList();
        requestAnimationFrame(frame)
    }catch(error){
        console.error("Game initialization failed:",error);
        try{
            updateLeaderboard(null);
            ensureName();
            requestAnimationFrame(frame);
            console.log("Game started in offline mode")
        }catch(criticalError){
            console.error("Critical startup failure:",criticalError);
        }
    }
    

    // Matrix Rain Effect for Menus
    class OptimizedMatrixRain {
        constructor(container) {
            this.container = container;
            this.columns = [];
            this.isRunning = true;
            this.speed = 50;
            this.density = 85;
            this.trailLength = 15;
            this.columnWidth = 30;
            this.charHeight = 20;
            
            // Character pool for reuse
            this.characterPool = [];
            this.activeCharacters = new Set();
            
            // Matrix-style character set with emphasis on 0, 1, 2
            this.matrixChars = [
                '0', '0', '0', '1', '1', '1', '2', '2', '2',
                '3', '4', '5', '6', '7', '8', '9',
                '$', '‚Ç¨', '¬•', '¬£', '‚Çπ', '%', '&', '*',
                '„Ç¢', '„Ç§', '„Ç¶', '„Ç®', '„Ç™', '„Ç´', '„Ç≠',
                '„ÇØ', '„Ç±', '„Ç≥', '„Çµ', '„Ç∑', '„Çπ', '„Çª'
            ];
            
            // Performance tracking
            this.frameCount = 0;
            this.lastFpsTime = performance.now();
            this.fps = 60;
            
            // Use RAF for smooth animation
            this.lastAnimationTime = 0;
            this.animationId = null;
            
            this.init();
            this.animate(0);
        }

        init() {
            // Clear container
            this.container.innerHTML = '';
            this.columns = [];
            this.characterPool = [];
            this.activeCharacters.clear();
            
            const screenWidth = this.container.clientWidth;
            const screenHeight = this.container.clientHeight;
            const numColumns = Math.floor(screenWidth / this.columnWidth);
            
            // Pre-create character pool (reusable elements)
            const poolSize = numColumns * this.trailLength * 2;
            for (let i = 0; i < poolSize; i++) {
                const char = document.createElement('span');
                char.className = 'matrix-char';
                char.style.display = 'none';
                this.container.appendChild(char);
                this.characterPool.push(char);
            }
            
            // Initialize columns
            for (let i = 0; i < numColumns; i++) {
                const column = {
                    x: i * this.columnWidth,
                    chars: [],
                    speed: 0.5 + Math.random() * 1.5,
                    nextSpawnTime: Math.random() * 1000
                };
                this.columns.push(column);
            }
        }

        getCharFromPool() {
            // Reuse character from pool
            for (let char of this.characterPool) {
                if (!this.activeCharacters.has(char)) {
                    this.activeCharacters.add(char);
                    char.style.display = 'block';
                    return char;
                }
            }
            return null; // Pool exhausted
        }

        returnCharToPool(char) {
            char.style.display = 'none';
            this.activeCharacters.delete(char);
        }

        getRandomChar() {
            return this.matrixChars[Math.floor(Math.random() * this.matrixChars.length)];
        }

        updateColumn(column, deltaTime, currentTime) {
            const screenHeight = this.container.clientHeight;
            const speedMultiplier = this.speed / 50;
            
            // Check if should spawn new character
            if (currentTime > column.nextSpawnTime) {
                if (Math.random() * 100 < this.density) {
                    const char = this.getCharFromPool();
                    if (char && column.chars.length < this.trailLength) {
                        char.textContent = this.getRandomChar();
                        char.style.left = column.x + 'px';
                        char.style.top = '0px';
                        char.className = 'matrix-char bright';
                        
                        column.chars.push({
                            element: char,
                            y: 0,
                            changeTime: currentTime + Math.random() * 500
                        });
                    }
                }
                column.nextSpawnTime = currentTime + (100 / this.density) * 50;
            }
            
            // Update existing characters
            for (let i = column.chars.length - 1; i >= 0; i--) {
                const char = column.chars[i];
                
                // Move character down
                char.y += column.speed * speedMultiplier * deltaTime * 0.05;
                
                // Remove if off screen
                if (char.y > screenHeight) {
                    this.returnCharToPool(char.element);
                    column.chars.splice(i, 1);
                    continue;
                }
                
                // Update position using transform (GPU accelerated)
                char.element.style.transform = `translateY(${char.y}px)`;
                
                // Change character occasionally
                if (currentTime > char.changeTime) {
                    char.element.textContent = this.getRandomChar();
                    char.changeTime = currentTime + 200 + Math.random() * 800;
                }
                
                // Update brightness based on position in trail
                const progress = char.y / screenHeight;
                const trailPosition = i / column.chars.length;
                
                if (i === column.chars.length - 1 && progress < 0.1) {
                    char.element.className = 'matrix-char bright';
                } else if (progress < 0.3 && trailPosition > 0.6) {
                    char.element.className = 'matrix-char medium';
                } else if (progress < 0.5) {
                    char.element.className = 'matrix-char dim';
                } else if (progress < 0.8) {
                    char.element.className = 'matrix-char faded';
                } else {
                    char.element.className = 'matrix-char very-faded';
                }
            }
        }

        animate(currentTime) {
            if (!this.isRunning) {
                this.animationId = requestAnimationFrame(time => this.animate(time));
                return;
            }
            
            const deltaTime = currentTime - this.lastAnimationTime;
            this.lastAnimationTime = currentTime;
            
            // Update all columns
            for (let column of this.columns) {
                this.updateColumn(column, deltaTime, currentTime);
            }
            
            this.animationId = requestAnimationFrame(time => this.animate(time));
        }
    }

    // Initialize matrix effects for all panels
    document.addEventListener('DOMContentLoaded', () => {
        const matrixContainers = document.querySelectorAll('.matrix-container');
        matrixContainers.forEach(container => {
            new OptimizedMatrixRain(container);
        });
    });

})();
</script>
</body>
</html>
