<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Void Skies ‚Äî 2P RPG Shoot 'Em Up (v0.4)</title>
  <style>
    :root { --bg:#0a0d12; --fg:#e6f0ff; --accent:#5eead4; --p1:#60a5fa; --p2:#f472b6; --danger:#f87171; }
    html, body { height:100%; margin:0; background:radial-gradient(1200px 800px at 50% 40%, #0f1420, var(--bg)); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
    #wrap { position:fixed; inset:0; display:grid; place-items:center; }
    canvas { background: transparent; box-shadow: 0 10px 40px rgba(0,0,0,.5); border-radius: 16px; image-rendering: pixelated; }
    #ui { position:fixed; inset:0; pointer-events:none; }
    .panel { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:rgba(15, 20, 32, .9); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:24px; width:min(800px, 92vw); pointer-events:auto; backdrop-filter: blur(10px); }
    .panel h1, .panel h2 { margin:.2rem 0 .8rem 0; }
    .panel button { background:#0b1220; color:var(--fg); border:1px solid rgba(255,255,255,.15); border-radius:12px; padding:10px 14px; cursor:pointer; }
    .grid { display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    .skill { padding:12px; border:1px solid rgba(255,255,255,.12); border-radius:12px; background:rgba(255,255,255,.03); }
    .skill.locked { opacity:.55; }
    .skill .req { font-size:.85rem; opacity:.75; }
    .row { display:flex; gap:12px; align-items:center; }
    #hud { position:absolute; inset:0; padding:10px; display:flex; justify-content:space-between; align-items:flex-start; pointer-events:none; font-size:14px; }
    .hudCol { display:flex; gap:8px; align-items:center; }
    .chip { padding:6px 10px; border-radius:10px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); }
    .bar { height:8px; width:220px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.12); }
    .bar > span { display:block; height:100%; background:linear-gradient(90deg, var(--accent), #38bdf8); }
    #help { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); opacity:.8; font-size:13px; text-align:center; }
    a { color: var(--accent); }
    .hide { display:none !important; }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game" width="960" height="540"></canvas></div>
  <div id="ui">
    <div id="menuPanel" class="panel">
      <h1>üéÆ Void Skies <small style="opacity:.7;font-weight:500">v0.4</small></h1>
      <p>A 2‚Äëplayer top‚Äëdown RPG shoot ‚Äôem up. Clear waves, earn XP & parts, unlock skills.</p>
      <div class="row" style="flex-wrap:wrap">
        <div class="chip" style="border-color:rgba(96,165,250,.5)">P1: <b style="color:var(--p1)">Mouse</b> move, <b>Click</b> shoot, <b>Shift</b> Special</div>
        <div class="chip" style="border-color:rgba(244,114,182,.5)">P2: <b style="color:var(--p2)">Arrows</b> move, <b>/</b> shoot, <b>Right Shift</b> Special</div>
        <div class="chip">Pause: <b>P</b></div>
      </div>
      <p>Click anywhere, press <b>Enter</b>, or hit the <b>Start</b> button to begin.</p>
      <button id="startBtn">Start</button>
    </div>

    <div id="levelPanel" class="panel hide">
      <h2>Level Up</h2>
      <p id="levelWho">Player leveled up! Choose a skill.</p>
      <div id="skillsGrid" class="grid"></div>
      <div class="row" style="justify-content:flex-end; margin-top:10px">
        <button id="closeLevel">Continue</button>
      </div>
    </div>

    <div id="pausePanel" class="panel hide">
      <h2>‚è∏Ô∏è Paused</h2>
      <p>Press <b>P</b> to resume.</p>
    </div>

    <div id="hud">
      <div class="hudCol" id="hudP1"></div>
      <div class="hudCol" id="hudWave"></div>
      <div class="hudCol" id="hudP2"></div>
      <div id="help">Tip: Clear a wave to earn extra XP & parts. Level up to unlock skills like <i>Gunnery, Shield Plating, Engine Tuning</i> and more.</div>
    </div>
  </div>

<script>
(() => {
  // --- Canvas setup & scaling ---
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const W = cvs.width, H = cvs.height;
  function fit() {
    const scale = Math.min(window.innerWidth / W, window.innerHeight / H);
    cvs.style.transformOrigin = 'top left';
    cvs.style.transform = `scale(${scale})`;
  }
  window.addEventListener('resize', fit); fit();

  // --- UI elements ---
  const menuPanel = document.getElementById('menuPanel');
  const levelPanel = document.getElementById('levelPanel');
  const skillsGrid = document.getElementById('skillsGrid');
  const pausePanel = document.getElementById('pausePanel');
  const hudP1 = document.getElementById('hudP1');
  const hudWave = document.getElementById('hudWave');
  const hudP2 = document.getElementById('hudP2');
  const startBtn = document.getElementById('startBtn');
  if (startBtn) startBtn.addEventListener('click', () => startGame());
  const levelWho = document.getElementById('levelWho');
  document.getElementById('closeLevel').onclick = () => hide(levelPanel);
  function show(el){ el.classList.remove('hide'); }
  function hide(el){ el.classList.add('hide'); }

  // --- Input ---
  const keys = new Set();
  const block = new Set(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ']);
  window.addEventListener('keydown', (e) => { keys.add(e.key); if(block.has(e.key)) e.preventDefault(); }, {passive:false});
  window.addEventListener('keyup',   (e) => { keys.delete(e.key); if(block.has(e.key)) e.preventDefault(); }, {passive:false});

  // Mouse input for P1
  const mouse = {x: W*0.3, y: H-60, down:false};
  function toCanvasPos(ev){
    const rect = cvs.getBoundingClientRect();
    const scaleX = rect.width / W;
    const scaleY = rect.height / H;
    const x = (ev.clientX - rect.left) / scaleX;
    const y = (ev.clientY - rect.top) / scaleY;
    return {x, y};
  }
  window.addEventListener('mousemove', (e)=>{ if(gameState==='playing'||gameState==='menu'){ const p=toCanvasPos(e); mouse.x=p.x; mouse.y=p.y; }});
  window.addEventListener('mousedown', ()=>{ mouse.down=true; if(gameState==='menu'||gameOver) startGame(); });
  window.addEventListener('mouseup', ()=> mouse.down=false);
  window.addEventListener('click', ()=>{ if(gameState==='menu'||gameOver) startGame(); });
  window.addEventListener('touchstart', ()=>{ if(gameState==='menu'||gameOver) startGame(); }, {passive:true});

  // --- Random helpers ---
  const rnd = (a,b) => Math.random()*(b-a)+a;
  const rndi = (a,b)=> (Math.random()*(b-a+1)|0)+a;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));

  // --- Starfield background ---
  const stars = Array.from({length:200}, () => ({x:rnd(0,W), y:rnd(0,H), z:rnd(.2,1)}));
  function drawStars(dt){
    ctx.save();
    ctx.fillStyle = '#05070b';
    ctx.fillRect(0,0,W,H);
    for(const s of stars){
      s.y += 40 * s.z * dt;
      if(s.y>H) { s.y=0; s.x=rnd(0,W); }
      const alpha = .4 + .6*s.z;
      ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(2)})`;
      ctx.fillRect(s.x, s.y, 2*s.z, 2*s.z);
    }
    ctx.restore();
  }

  // --- Game objects ---
  class Bullet{
    constructor(x,y,vx,vy,owner,color){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=3; this.owner=owner; this.color=color||'#fff'; this.alive=true; this.dmg=owner?.stats.bulletDamage||1; }
    update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; if(this.y<-10||this.y>H+10||this.x<-10||this.x>W+10) this.alive=false; }
    draw(){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); }
  }

  class Enemy{
    constructor(x,y,type=0){ this.x=x; this.y=y; this.r=14; this.hp= type===1? 28: 18; this.speed= type===1? 55: 65; this.type=type; this.t=0; this.alive=true; this.value= type===1? 18:12; }
    update(dt){ this.t+=dt; this.y += this.speed*dt; this.x += Math.sin(this.t*3)*(this.type? 60:40)*dt; if(this.y>H+30) this.alive=false; if(Math.random()<0.005) this.shoot(); }
    shoot(){ bullets.push(new Bullet(this.x, this.y+10, 0, 180, this, '#fca5a5')); }
    draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.fillStyle = this.type? '#f97316' : '#eab308'; ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(10,10); ctx.lineTo(-10,10); ctx.closePath(); ctx.fill(); ctx.restore(); }
  }

  const SkillDefs = {
    gunnery1: {name:'Gunnery I', desc:'+20% bullet damage', cost:1, req:[], apply:p=>p.stats.bulletDamage*=1.2},
    gunnery2: {name:'Gunnery II', desc:'+25% bullet damage', cost:1, req:['gunnery1'], apply:p=>p.stats.bulletDamage*=1.25},
    shields1: {name:'Shield Plating I', desc:'+25% max HP', cost:1, req:[], apply:p=>{p.stats.maxHp=Math.round(p.stats.maxHp*1.25); p.hp=p.stats.maxHp;}},
    shields2: {name:'Shield Plating II', desc:'+35% max HP', cost:1, req:['shields1'], apply:p=>{p.stats.maxHp=Math.round(p.stats.maxHp*1.35); p.hp=p.stats.maxHp;}},
    engine1:  {name:'Engine Tuning', desc:'+15% move speed', cost:1, req:[], apply:p=>p.stats.speed*=1.15},
    reactor:  {name:'Reactor Overdrive', desc:'Special lasts 2√ó longer', cost:1, req:['engine1'], apply:p=>p.stats.specialDur*=2},
    focus:    {name:'Targeting Focus', desc:'-20% fire cooldown', cost:1, req:['gunnery1'], apply:p=>p.stats.fireCd*=0.8},
    drone:    {name:'Auto-Drone', desc:'Deploys a support drone', cost:1, req:['focus'], apply:p=>p.deployDrone()},
    salvage:  {name:'Salvage Ops', desc:'+25% parts dropped', cost:1, req:[], apply:p=>p.stats.partsBonus=1.25},
  };

  class Player{
    constructor(id, x,y, color, keys){
      this.id=id; this.x=x; this.y=y; this.r=14; this.color=color; this.keys=keys;
      this.stats={ maxHp:100, speed:180, fireCd:.22, bulletDamage:10, specialCd:10, specialDur:3, partsBonus:1 };
      this.hp=this.stats.maxHp; this.fireTimer=0; this.specialTimer=0; this.specialActive=0; this.level=1; this.xp=0; this.xpNext=60; this.skillPoints=0; this.skills=new Set(); this.drone=null;
      this.mouseControl = (id===1); // P1 follows mouse
    }
    update(dt){
      // movement
      let dx=0, dy=0;
      if(this.mouseControl){
        const mx = mouse.x, my = mouse.y;
        const vx = mx - this.x, vy = my - this.y;
        const d = Math.hypot(vx,vy);
        if(d>1){ dx = vx/d; dy = vy/d; }
      } else {
        if(keys.has(this.keys.up)) dy-=1; if(keys.has(this.keys.down)) dy+=1; if(keys.has(this.keys.left)) dx-=1; if(keys.has(this.keys.right)) dx+=1;
        if(dx||dy){ const len=Math.hypot(dx,dy); dx/=len; dy/=len; }
      }
      this.x+=dx*this.stats.speed*dt; this.y+=dy*this.stats.speed*dt;
      this.x=clamp(this.x, 20, W-20); this.y=clamp(this.y, 20, H-20);

      // firing
      this.fireTimer-=dt;
      const wantsFire = this.mouseControl ? mouse.down : keys.has(this.keys.fire);
      if(wantsFire && this.fireTimer<=0){ this.shoot(); this.fireTimer=this.stats.fireCd*(this.specialActive?0.5:1); }

      // special
      this.specialTimer-=dt; if((this.mouseControl? keys.has('Shift') : keys.has(this.keys.special)) && this.specialTimer<=0){ this.specialActive=this.stats.specialDur; this.specialTimer=this.stats.specialCd; }
      if(this.specialActive>0) this.specialActive=Math.max(0, this.specialActive-dt);

      // drone
      if(this.drone) this.drone.update(dt);
    }
    draw(){
      ctx.save(); ctx.translate(this.x,this.y);
      ctx.fillStyle=this.color; ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(12,10); ctx.lineTo(-12,10); ctx.closePath(); ctx.fill();
      if(this.specialActive>0){ ctx.strokeStyle=this.color; ctx.globalAlpha=.8; ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
      ctx.restore();
      if(this.drone) this.drone.draw();
    }
    shoot(){
      bullets.push(new Bullet(this.x-6, this.y-12, 0, -360, this, this.color));
      bullets.push(new Bullet(this.x+6, this.y-12, 0, -360, this, this.color));
    }
    hit(dmg){ this.hp-=dmg; if(this.hp<=0){ this.hp=0; gameOver=true; } }
    earn(xp, parts){ this.xp+=xp; currency+=Math.round(parts*(this.stats.partsBonus||1)); if(this.xp>=this.xpNext){ this.level++; this.skillPoints++; this.xp-=this.xpNext; this.xpNext=Math.round(this.xpNext*1.35); queueLevelUp(this); } }
    deployDrone(){
      this.drone = new (class Drone{ constructor(p){ this.p=p; this.t=0; this.r=6; }
        update(dt){ this.t+=dt; }
        draw(){ const px=this.p.x+Math.cos(this.t*2)*24, py=this.p.y-24+Math.sin(this.t*2)*6; ctx.fillStyle='#a7f3d0'; ctx.beginPath(); ctx.arc(px,py,this.r,0,Math.PI*2); ctx.fill(); if(rndi(0,25)===0){ bullets.push(new Bullet(px, py-8, 0, -340, {stats:{bulletDamage:6}}, '#a7f3d0')); } }
      })(this);
    }
  }

  // --- Game state ---
  let players=[], bullets=[], enemies=[], particles=[], wave=1, spawnTimer=0, gameState='menu', gameOver=false, currency=0;

  // Auto-start after load as a failsafe for environments that block input events
  setTimeout(() => { if (gameState==='menu') { console.log('[VoidSkies] Autostart fallback'); startGame(); } }, 800);

  function startGame(){
    players=[ new Player(1, W*0.3, H-60, '#60a5fa', {up:'w',down:'s',left:'a',right:'d',fire:' ', special:'Shift'}),
              new Player(2, W*0.7, H-60, '#f472b6', {up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight',fire:'/', special:'ShiftRight'}) ];
    bullets=[]; enemies=[]; particles=[]; wave=1; currency=0; gameOver=false; gameState='playing'; spawnWave(); hide(menuPanel); hide(levelPanel); hide(pausePanel);
  }

  function spawnWave(){
    const count = 8 + wave*2;
    for(let i=0;i<count;i++){
      setTimeout(()=>{ enemies.push(new Enemy(rnd(40,W-40), -30, Math.random()<0.35?1:0)); }, i*300);
    }
  }

  function update(dt){
    if(gameState!=='playing') return;
    for(const p of players) p.update(dt);
    for(const b of bullets) b.update(dt);
    for(const e of enemies) e.update(dt);
    bullets=bullets.filter(b=>b.alive);
    enemies=enemies.filter(e=>e.alive);

    // collisions: bullets vs enemies
    for(const b of bullets){ if(!b.owner || !players.includes(b.owner)) continue; // player bullet only
      for(const e of enemies){ const dx=b.x-e.x, dy=b.y-e.y; if(dx*dx+dy*dy < (e.r+b.r)*(e.r+b.r)){
          e.hp -= b.dmg; b.alive=false; if(e.hp<=0){ e.alive=false; spawnPop(e.x,e.y); // rewards
            const xp = e.value, parts = Math.round(e.value/2);
            players.forEach(p=>p.earn(xp/players.length, parts/players.length));
          }
      } }

    // enemy bullets vs players
    for(const b of bullets){ if(b.owner && players.includes(b.owner)) continue; // enemy bullet only
      for(const p of players){ const dx=b.x-p.x, dy=b.y-p.y; if(dx*dx+dy*dy < (p.r+b.r)*(p.r+b.r)){
          p.hit(12); b.alive=false; spawnHit(p.x,p.y,p.color);
      } }
    }

    // enemies vs players
    for(const e of enemies){ for(const p of players){ const dx=e.x-p.x, dy=e.y-p.y; if(dx*dx+dy*dy < (e.r+p.r)*(e.r+p.r)){
          p.hit(18); e.alive=false; spawnPop(e.x,e.y);
    } } }

    // wave cleared?
    if(enemies.length===0 && document.querySelectorAll('.skill.pending').length===0){
      wave++; spawnWave(); players.forEach(p=>p.earn(20, 10));
    }
  }

  function draw(){
    drawStars(dt);
    // Debug state badge
    ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(8,8,190,28);
    ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.fillText(`Void Skies v0.4  |  state: ${gameState}`, 14, 27);

    if(gameState==='playing' || gameState==='paused' || gameOver){
      for(const p of players) p.draw();
      for(const e of enemies) e.draw();
      for(const b of bullets) b.draw();
      for(const prt of particles){ prt.update(dt); prt.draw(); }
      particles=particles.filter(p=>p.alive);
      renderHud();
    }

    if(gameOver){
      ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='bold 28px system-ui';
      ctx.fillText('Game Over', W/2, H/2-8);
      ctx.font='16px system-ui'; ctx.fillText('Click or press Enter to restart', W/2, H/2+22);
    }
  }

  function renderHud(){
    function hudFor(p, label){
      const xpPct = Math.max(0, Math.min(1, p.xp/p.xpNext));
      return `
        <div class="chip">${label}</div>
        <div class="chip">HP: ${p.hp}/${p.stats.maxHp}</div>
        <div class="chip">Lvl ${p.level} (${p.skillPoints} SP)</div>
        <div class="bar"><span style="width:${(xpPct*100).toFixed(0)}%"></span></div>
      `;
    }
    hudP1.innerHTML = hudFor(players[0]||{hp:0,stats:{maxHp:0}}, '<b style="color:var(--p1)">P1</b>');
    hudP2.innerHTML = hudFor(players[1]||{hp:0,stats:{maxHp:0}}, '<b style="color:var(--p2)">P2</b>');
    hudWave.innerHTML = `<div class="chip">Wave ${wave}</div><div class="chip">Parts: ${currency}</div>`;
  }

  function spawnPop(x,y){
    for(let i=0;i<12;i++) particles.push(new Particle(x,y,rnd(-140,140), rnd(-80,40), '#fde047'));
  }
  function spawnHit(x,y,c){
    for(let i=0;i<8;i++) particles.push(new Particle(x,y,rnd(-120,120), rnd(-60,20), c||'#fff'));
  }
  class Particle{ constructor(x,y,vx,vy,col){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life= .6; this.col=col; this.alive=true;}
    update(dt){ this.life-=dt; if(this.life<=0) this.alive=false; this.x+=this.vx*dt; this.y+=this.vy*dt; this.vy += 60*dt; }
    draw(){ ctx.globalAlpha=Math.max(0,this.life/0.6); ctx.fillStyle=this.col; ctx.fillRect(this.x,this.y,3,3); ctx.globalAlpha=1; }
  }

  // --- Level up UI ---
  function queueLevelUp(player){
    show(levelPanel);
    levelWho.textContent = `Player ${player.id} leveled up! Choose a skill.`;
    renderSkillChoices(player);
    gameState='paused';
  }

  function availableSkillsOf(p){
    const avail=[]; for(const [key,def] of Object.entries(SkillDefs)){
      if(p.skills.has(key)) continue;
      const hasReq = def.req.every(r=>p.skills.has(r));
      if(hasReq) avail.push({key,def});
    }
    return avail.slice(0,6);
  }

  function renderSkillChoices(p){
    skillsGrid.innerHTML='';
    const avail = availableSkillsOf(p);
    for(const {key,def} of avail){
      const card = document.createElement('div');
      card.className='skill';
      card.innerHTML = `<b>${def.name}</b><div>${def.desc}</div>` + (def.req.length? `<div class="req">Requires: ${def.req.map(r=>SkillDefs[r].name).join(', ')}</div>`: '');
      card.onclick = ()=>{
        if(p.skillPoints<=0) return;
        p.skillPoints -= def.cost; p.skills.add(key); def.apply(p); hide(levelPanel); gameState='playing';
      };
      skillsGrid.appendChild(card);
    }
  }

  // --- Main loop ---
  let last=performance.now(), dt=0;
  function loop(t){
    dt = Math.min(0.033, (t-last)/1000); last=t;
    if(gameState==='playing') update(dt);
    ctx.save(); draw(); ctx.restore();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // --- Menu / Pause / Restart ---
  window.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' || e.code==='NumpadEnter' || e.code==='Space'){
      if(gameState==='menu' || gameOver){ console.log('[VoidSkies] Start via key'); startGame(); }
    }
    if(e.key==='p' || e.key==='P'){
      if(gameState==='playing'){ gameState='paused'; show(pausePanel); }
      else if(gameState==='paused'){ gameState='playing'; hide(pausePanel); }
    }
  });
  // Canvas & window clicks start too
  cvs.addEventListener('click', () => { if (gameState==='menu' || gameOver) { console.log('[VoidSkies] Start via canvas click'); startGame(); } });
  window.addEventListener('click', () => { if (gameState==='menu' || gameOver) { console.log('[VoidSkies] Start via window click'); startGame(); } });
})();
</script>
</body>
</html>
