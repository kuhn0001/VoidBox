<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 98vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:0;}
        .stage{width:100vw; height:100svh; position:relative;display:grid;place-items:center;background:#000;border-radius:0;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
        canvas{background:transparent;border-radius:16px;touch-action:none;cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }
        #diagBox{position:absolute;left:8px;top:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:left;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s; font-family: 'Orbitron', 'Audiowide', ui-sans-serif;}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        
        .panel{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:rgba(26,0,34,.95);
            border:1px solid var(--accent);
            border-radius:16px;
            padding:12px;
            width:min(600px, 90vw);
            backdrop-filter:blur(12px);
            color:#ffddff;
            box-shadow:0 0 40px rgba(178,102,255,.3);
            z-index:100;
        }
        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }
        .close-btn {
            position: absolute;
            top: 8px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 20px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 4px;
        }
        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        #shopPanel h2, #levelPanel h2, #scorePanel h2, #namePanel h2, #pilotPanel h2, #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }
        #shopPanel p, #levelPanel p, #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }
        #shopGrid, #scorePanel div {
            max-height: 60vh; 
            overflow-y: auto;
            padding-right: 8px;
        }
        .grid{
            display:grid;
            gap:8px;
            grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
        }
        .hide{display:none!important}
        #belowBoard{width:min(98vw,var(--maxw));margin:50px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        
        .skill-card {
            background: radial-gradient(circle, rgba(51,0,68,1) 0%, rgba(51,0,68,0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        
        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }
        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }
        .skill-title{
            font-weight:700;
            color:#c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }
        .skill-desc{
            font-size:11px;
            color:#ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }
        .skill-bonuses {
            font-size: 10px;
            color: var(--accent);
            line-height: 1.4;
            margin-top: auto;
            padding-top: 8px;
            border-top: 1px solid var(--edge);
            width: 100%;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }
        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }
        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }
        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn{
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.4;
            transition: opacity 0.3s ease-in-out;
        }
        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }
        
        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }
        #bottom-right-controls > .fixed-btn {
            position: static;
        }

        #menuBtn, #fsEnterBtn, #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }
        #pauseBtn {
            top: 50%;
            right: 15px; 
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif; box-sizing: border-box;}
        
        #abilityBar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 6; pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }
        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }
        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }
        
        .shop-item-attack { border-color: #00bfff; }
        .shop-item-health { border-color: #00ff00; }
        .shop-item-utility { border-color: #ffd700; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
            50% { box-shadow: 0 0 35px rgba(102, 255, 178, 1); }
            100% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
        }
        @keyframes pulse-glow-ability {
            0% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
            50% { box-shadow: 0 0 20px rgba(178, 102, 255, .8); }
            100% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
        }
        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(500px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
    </style>
</head>
<body>
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide"></div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card"></div>
                        <div id="hudPilotContent" class="hud-card"></div>
                        <div id="hudBossContent" class="hud-card hide"></div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide"></div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <div class="chip">v3.7.5</div>
                    <div class="chip">FPS <span id="fps">‚Äî</span></div>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üöÄ PILOT LOST üöÄ</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <button id="storyBtn" type="button">i</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">A charging juggernaut that automatically retaliates against nearby foes.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN"></div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">A master of area denial, leaving a trail of fire in his wake.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="wizard">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER"></div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">An ethereal pilot who can blink through the void itself.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                     <div id="subclassPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                            <!-- Subclass options will be injected here -->
                        </div>
                    </div>
                    <div id="storyPanel" class="panel hide">
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                        Mammalian life developed specialized spacecraft to venture within and colonize the resources of the primitive creatures.<br><br>
                        The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üíÄ CALLSIGN üíÄ</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üèÜ Aces of the Void üèÜ</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <button type="button" class="close-btn" id="closeShopTopBtn">X</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° MECH FORGE ‚ö°</h2>
                        <p style="color:#ffddff">Available Shards: <span id="shopShards">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>‚ö° Aces of the Void ‚ö°</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">‚ö° MECH FORGE</button>
        <button id="menuBtn" class="fixed-btn" type="button">üèÜ TOP PILOTS</button>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://ignored-insight-easter-scholars.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => {
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height),
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    const pointFromEvent = (e) => {
        const r = cvs.getBoundingClientRect();
        let touch = e;
        if (e.changedTouches && e.changedTouches.length > 0) {
            touch = e.changedTouches[0];
        } else if (e.touches && e.touches.length > 0) {
            touch = e.touches[0];
        }
        const cx = touch.clientX;
        const cy = touch.clientY;
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
    };


    // --- NEW FLAME PARTICLE CLASS ---
    class FlameParticle {
        constructor(x, y) {
            this.x = x + (Math.random() - 0.5) * 8;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 20;
            this.vy = -Math.random() * 80 - 40;
            this.maxLife = 10;
            this.life = this.maxLife * (0.7 + Math.random() * 0.3);
            this.size = Math.random() * 12 + 6;
            this.heat = Math.random();
            this.wobble = Math.random() * Math.PI * 2;
            this.wobbleSpeed = Math.random() * 2 + 1;
        }

        update(dt) {
            this.life -= dt;
            if (this.life <= 0) return false;
            this.y += this.vy * dt;
            this.x += this.vx * dt;
            this.vy -= 100 * dt;
            this.wobble += this.wobbleSpeed * dt;
            this.x += Math.sin(this.wobble) * 15 * dt;
            this.size *= 1 + (0.1 * dt);
            return true;
        }

        draw() {
            if (this.life <= 0) return;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const lifeRatio = this.life / this.maxLife;
            const layers = [
                { size: this.size * 2.5, alpha: lifeRatio * 0.15 },
                { size: this.size * 1.5, alpha: lifeRatio * 0.3 },
                { size: this.size, alpha: lifeRatio * 0.8 }
            ];
            layers.forEach(layer => {
                ctx.globalAlpha = layer.alpha;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, layer.size);
                if (this.heat > 0.6) {
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.2, 'rgba(200, 220, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 200, 100, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                } else if (this.heat > 0.3) {
                    gradient.addColorStop(0, 'rgba(255, 240, 180, 1)');
                    gradient.addColorStop(0.3, 'rgba(255, 180, 50, 0.8)');
                    gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(200, 50, 0, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(255, 150, 50, 1)');
                    gradient.addColorStop(0.4, 'rgba(255, 80, 0, 0.6)');
                    gradient.addColorStop(0.7, 'rgba(200, 30, 0, 0.3)');
                    gradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                }
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, layer.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
        }
    }


    cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
    cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
   
    // --- AUDIO ---
    const bgm = q('bgmAudio');
    const sounds = {
        explosion: q('audioExplosion'),
        horn: q('audioHorn'),
        hit: q('audioHit'),
        trap: q('audioTrap'),
        dogs: q('audioDogs')
    };
    let lastExplosionSoundTime = 0;
    let lastBossHitSoundTime = 0;
   
    function playSound(name) {
        const audio = sounds[name];
        if (!audio) return;
        const now = performance.now();
        if (name === 'explosion') {
            if (now - lastExplosionSoundTime < 50) return;
            lastExplosionSoundTime = now;
        }
        if (name === 'hit') {
            if (now - lastBossHitSoundTime < 100) return;
            lastBossHitSoundTime = now;
        }
        audio.currentTime = 0;
        audio.play().catch(e => {});
    }


    // --- GAME STATE & DATA ---
    const player_initial_state = {
        x: W / 2, y: H * 0.8, r: 14, hp: 100, hpMax: 100, fireT: 0, speed: 380, dmgMult: 1, fireRate: 0.18,
        vampirism: 0, shield: 0, shieldMax: 0, multishot: 1, isInvincible: false, piercing: 0, explosive: false,
        hasShieldBubble: false, powerupTimers: {},
        upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0 },
        grenades: 0, hasVoidBeam: false, voidBeamCooldown: 0,
        hasLazarusBeam: false, lazarusBeamCooldown: 0,
        hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 0, vampirismLevel: 0, flamethrowerLevel: 0,
        luckBoost: 0, magnetRadius: 0, hasIceman: false, critChance: 0.02, critDamage: 2,
        pilotGenome: null, missileVolley: 2,
        hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
        rearMultishot: 0, addFrontNext: true,
        flameWallCooldown: 0,
        flameWallActiveT: 0,
        beefChargeState: 'ready', beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 1, beefMaxCharges: 1,
        hasChainLightning: false, chainLightningCooldown: 0,
        subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false
    };
   
    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        world: { wave: 1, score: 0, shards: 0, xp: 0, level: 1, kills: 0, bosses: 0, lowHealthTutorialShown: false, bossSpawnTime: 0, waveStartTime: 0, enemyHealthBonus: 1.0, bossHealthBonus: 1.0, enemyDensityBonus: 1.0, powerupCooldown: 0, xpMultiplier: 1.0, collarStacks: 0, consecutiveFastKills: 0, fastKillBonus: 0 },
        player: { ...player_initial_state },
        boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], missiles: [], lasers: [], mines: [], activeEffects: [],
        flameParticles: [],
        lightningBolts: [],
        iceman: null,
        _startTs: performance.now(),
        cheatInvincibilityCooldown: 0,
        cheatDogHealCooldown: 0,
        cheatsUsed: false
    };

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', icon: 'üí•', desc: '+7% damage', apply: () => { store.player.dmgMult *= 1.07; } },
        { id: 'fire', name: 'OVERCLOCK', icon: 'üî•', desc: '+10% fire rate', apply: () => { store.player.fireRate *= 0.90; } },
        { id: 'multi', name: 'SCATTER PROTOCOL', icon: '‚òÑÔ∏è', desc: '+1 projectile', apply: () => {
            const p = store.player;
            if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
        }},
        { id: 'shield', name: 'VOID SHIELD', icon: 'üõ°Ô∏è', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'flamethrower', name: 'LAVA CHUNKS', icon: 'üåã', desc: 'Spews chunks of molten rock in a cone.', apply: () => { store.player.flamethrowerLevel++; } }
    ];
   
    const SHOP_UPGRADES = {
        'repair': { name: "NANO REPAIR", icon: 'üîß', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'vampirism': {
            name: "VAMPIRIC ROUNDS", icon: 'ü©∏', isPremium: true, max: 4, category: 'utility',
            apply: () => {
                const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                if (store.world.shards >= cost && p.vampirismLevel < 4) { store.world.shards -= cost; p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
            },
            desc: () => {
                const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
            }
        },
        'hp': { name: "MAX HP", icon: '‚ù§Ô∏è', baseCost: 20, scale: 1.4, maxLevel: 10, category: 'health', effect: () => { store.player.hpMax += 10; store.player.hp += 10; }, desc: level => `+10 Max HP (Lvl ${level + 1})` },
        'nano_save': { name: "NANO SAVE", icon: 'üíæ', cost: 25, isPremium: true, max: 3, category: 'utility', apply: () => { if (store.player.nanoSaves < 3) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Auto-heals on low HP. Charges: ${store.player.nanoSaves}/3` },
        'luck_boost': { name: "LUCK BOOST", icon: 'üçÄ', baseCost: 25, scale: 2, maxLevel: 5, category: 'utility', effect: (level) => { store.player.luckBoost = (store.player.luckBoost || 0) + (0.15 / Math.pow(2, level)); }, desc: level => `+${(0.15 / Math.pow(2, level) * 100).toFixed(1)}% drop chance (Lvl ${level + 1})` },
        'dmg': { name: "DAMAGE", icon: 'üí™', baseCost: 25, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.07, desc: level => `+7% Damage (Lvl ${level + 1})` },
        'crit_chance': { name: "SHINOBI REFLEXES", icon: 'ü•∑', baseCost: 20, increment: 12, maxLevel: 10, category: 'attack', effect: () => { store.player.critChance *= 1.5; store.player.critDamage *= 1.5; }, desc: level => `+50% Crit Chance & Dmg (Lvl ${level + 1})` },
        'speed': { name: "SPEED", icon: 'üöÄ', baseCost: 30, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
        'grenade': { name: "NOVA GRENADE", icon: 'üí•üí£üí•', cost: 35, isPremium: true, max: 3, category: 'attack', apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'max_shield': { name: "MAX SHIELD", icon: 'üõ°Ô∏è', baseCost: 40, scale: 1.8, maxLevel: 5, category: 'health', effect: () => { store.player.shieldMax += 25; store.player.shield += 25; }, desc: level => `+25 Max Shield (Lvl ${level + 1})` },
        'mine_wall': { name: "MINE WALL", icon: 'üí£', cost: 40, isPremium: true, max: 2, category: 'attack', apply: () => { const activeWalls = store.mines.filter(m => m.isWallMine).length > 0; if(!activeWalls) { deployMineWall(); return true; } return false; }, desc: () => `Deploy a wall of mines.` },
        'rear_guard': { name: 'AFT FLANKSHIELD', icon: 'üõ°Ô∏è‚ú®', baseCost: 65, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
        'launcher': { name: 'FRAG LAUNCHER', icon: 'üí•', baseCost: 50, scale: 2, maxLevel: 3, category: 'attack', effect: () => { store.player.upgradeLevels.launcher = (store.player.upgradeLevels.launcher || 0) + 1; store.player.hasLauncher = true; }, desc: level => `+2 projectiles (Lvl ${level + 1})` },
        'iceman': { name: "THE ICEMAN", icon: '‚ùÑÔ∏è', cost: 59, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.hasIceman) { store.player.hasIceman = true; store.iceman = { x: store.player.x, y: store.player.y + 50, t: 0 }; return true; } return false; }, desc: () => `A clone mirrors your attacks.` },
        'lazarus_beam': { name: "LORD LAZARUS", icon: '‚ò¢Ô∏è‚òÑÔ∏è‚ò¢Ô∏è', cost: 75, isPremium: true, isUnlock: true, category: 'attack', apply: () => { if (!store.player.hasLazarusBeam) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; return true; } return false; }, desc: () => `Lazarus periodically smites your foes.` },
        'magnet_pull': { name: "GRAV-PULSE", icon: 'üß≤', cost: 45, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
        'gravity_well': { name: "GRAVITY WELL", icon: 'üï≥Ô∏è', cost: 100, isPremium: true, isUnlock: true, category: 'attack', apply: () => { if (!store.player.hasVoidBeam) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; return true; } return false; }, desc: () => `Unleashes a singularity that traps and crushes foes.` },
        'ghost_hounds': { name: "GHOST HOUNDS", icon: 'üëªüê∫', baseCost: 75, scale: 2, maxLevel: 2, category: 'attack', effect: () => { if (!store.player.hasHounds) { store.player.hasHounds = true; store.hounds = [createHound(-1), createHound(1)]; } else { store.hounds.push(createHound(-2)); store.hounds.push(createHound(2)); } playSound('dogs'); }, desc: level => { if (level === 0) return `Unlocks 2 spectral hounds.`; if (level === 1) return `Add 2 more hounds.`; return "Max hounds reached."; } }
    };
   
    const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: '‚¨ÜÔ∏è', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'üöÅ', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'üõ°Ô∏è', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: '‚ù§Ô∏è', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'üöÄ', duration: 20, type: 'timed' }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) {
        if (store.world.powerupCooldown > 0) return;
        const p = store.player;
        const baseChance = 0.075;
        const wave = store.world.wave;
        const waveReductionFactor = 0.0025;
        let finalChance = Math.max(0.025, baseChance - (wave - 1) * waveReductionFactor);
        let types = Object.keys(POWERUP_TYPES);
        let bonusType = null;
        if (p.pilotGenome === 'beef') {
            if (Math.random() < 0.25) bonusType = 'shield';
            else if (Math.random() < 0.15) bonusType = 'repair';
        }
        if (p.pilotGenome === 'rocketman' && Math.random() < 0.2) {
            finalChance *= 1.5;
            bonusType = 'missile';
        }
        const roll = Math.random();
        if (roll > finalChance && !bonusType) return;
        let typeKey;
        if (bonusType && (roll <= finalChance || Math.random() < 0.5)) {
            typeKey = bonusType;
        } else {
            typeKey = types[Math.floor(Math.random() * types.length)];
        }
        store.powerups.push({ x, y, r: 12, type: typeKey });
        store.world.powerupCooldown = 5;
    }
   
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
        if (typeKey === 'missile') {
            if (p.pilotGenome === 'rocketman') { p.missileVolley = Math.min(5, p.missileVolley + 2); } else { p.missileVolley = 2; }
        }
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
            else {
                if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') {
                const p = store.player;
                if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                announce('SCATTER SHOT!');
            }
        }
        announce(powerup.name);
    }

    function initWave() {
        const isBossWave = store.world.wave % 5 === 0;
        if (isBossWave) {
            store.enemies = [];
            const bossHpScale = 1 + (store.world.wave / 5 - 1) * 1.5;
            store.boss = createBoss(bossHpScale);
            store.world.bossSpawnTime = performance.now();
            if (store.boss.name === 'TRAP KING') playSound('trap');
            else if (store.boss.name === 'CORE MALIGNUS') playSound('horn');
            announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
        } else {
            store.enemies = [];
            const spawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter'];
                if (store.world.wave > 3) types.push('phantom');
                if (store.world.wave > 5) types.push('mech');
                if (store.world.wave > 7) types.push('angler');
                if (store.world.wave > 9) types.push('manta');
                store.enemies.push(spawnEnemy(types[Math.floor(Math.random() * types.length)]));
            }
            store.world.waveStartTime = performance.now();
            announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
        }
    }
   
    function createBoss(scale) {
        const bossCycle = Math.floor((store.world.wave - 5) / 5) % 5;
        const types = [
            { name: 'DARTH VADER', baseHp: 1300, r: 55, behavior: 'sentinel', color: '#eeff1b' },
            { name: 'TRAP KING', baseHp: 1500, r: 50, behavior: 'hex', color: '#66aaff'},
            { name: 'CORE MALIGNUS', baseHp: 1800, r: 60, behavior: 'malignus', color: '#2E8B57' },
            { name: 'GEOMETRON', baseHp: 2200, r: 65, behavior: 'construct', color: '#e03434', phase: 1 },
            { name: 'Francesca', baseHp: 2500, r: 70, behavior: 'avian', color: '#4b0082' }
        ];
        const type = types[bossCycle];
        let hp = type.baseHp * scale * store.world.bossHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks > 0 ? 0.4 + (store.world.collarStacks - 1) * 0.1 : 0);
        hp *= collarBonus;
        return { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, isEnraged: false, attackPhase: 0, phaseTimer: 0 };
    }

    function spawnEnemy(type = 'drone') {
        const cfgs = {
            drone: { r: 10, v: 80, vx: 0, hp: 25, color: '#C0C0C0', xp: 5, score: 50, shards: 1, fireRateChance: 0.004 },
            hunter: { r: 20, v: 100, vx: 0, hp: 20, color: '#DC143C', xp: 8, score: 80, shards: 1, fireRateChance: 0.005 },
            trap_king_add: { r: 6, v: 90, vx: 0, hp: 10, color: '#ffc83d', damage: 5, xp: 2, score: 10, shards: 1 },
            phantom: { r: 14, v: 90, vx: 0, hp: 40, color: '#FFFFFF', xp: 10, score: 100, shards: 2, fireRateChance: 0.006, fireCooldown: 1.5 },
            mech: { r: 18, v: 40, vx: 0, hp: 90, color: '#FF8500', xp: 15, score: 150, shards: 3, fireRateChance: 0.007, attackPhase: 0 },
            construct_shard: { r: 10, v: 120, vx: 0, hp: 15, color: '#e03434', xp: 3, score: 30, shards: 1 },
            avian_hatchling: { r: 8, v: 150, vx: 0, hp: 20, color: '#9370DB', xp: 4, score: 40, shards: 1 },
            angler: { r: 22, v: 30, vx: 0, hp: 120, color: '#00008b', xp: 18, score: 180, shards: 4, fireRateChance: 0.008 },
            manta: { r: 26, v: 50, vx: 0, hp: 150, color: '#53B6FF', xp: 22, score: 220, shards: 5, fireRateChance: 0.009 }
        };
        let c = { ...cfgs[type] }; const wave = store.world.wave;
        c.hp *= Math.pow(1.075, wave) * store.world.enemyHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks > 0 ? 0.4 + (store.world.collarStacks - 1) * 0.1 : 0);
        c.hp *= collarBonus;
        const e = { ...c, type, x: 20 + Math.random() * (W - 40), y: -50 - Math.random() * 250, hpMax: c.hp, phase: type === 'phantom', t: 0, fireT: (c.fireCooldown || 0), isBursting: false, burstTimer: 0, stunTimer: 0, knockback: null };
        if (e.type === 'manta') { e.startX = e.x; e.amplitude = 150 + Math.random() * 100; e.frequency = 0.5 + Math.random() * 0.5; }
        return e;
    }

    function stepPlayer(dt) {
        const p = store.player;
        if (p.pilotGenome === 'beef' && p.beefChargeState !== 'ready') {
            p.beefChargeT += dt;
            const chargeDuration = 0.25; const returnDuration = 0.35;
            if (p.beefChargeState === 'charging') {
                const progress = Math.min(p.beefChargeT / chargeDuration, 1);
                p.x = p.beefChargeOrigin.x + (p.beefChargeTarget.x - p.beefChargeOrigin.x) * progress;
                p.y = p.beefChargeOrigin.y + (p.beefChargeTarget.y - p.beefChargeOrigin.y) * progress;
                if (progress >= 1) { p.beefChargeState = 'returning'; p.beefChargeT = 0; }
            } else if (p.beefChargeState === 'returning') {
                const progress = Math.min(p.beefChargeT / returnDuration, 1);
                p.x = p.beefChargeTarget.x + (p.beefChargeOrigin.x - p.beefChargeTarget.x) * progress;
                p.y = p.beefChargeTarget.y + (p.beefChargeOrigin.y - p.beefChargeTarget.y) * progress;
                if (progress >= 1) { p.x = p.beefChargeOrigin.x; p.y = p.beefChargeOrigin.y; p.beefChargeState = 'ready'; p.isInvincible = false; }
            }
        } else {
            const vx = mouse.x - p.x, vy = mouse.y - p.y;
            p.x += (vx * p.speed * dt * 0.005); p.y += (vy * p.speed * dt * 0.005);
            p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
        }
        if (p.pilotGenome === 'beef') {
            if (p.beefChargeCooldown > 0) { p.beefChargeCooldown -= dt; } else if (p.beefCharges < p.beefMaxCharges) { p.beefChargeCooldown = 8; p.beefCharges++; }
            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                const chargeRadius = 120; let closestEnemy = null; let closestDistSq = chargeRadius * chargeRadius;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.stunTimer > 0) return;
                    const dx = e.x - p.x; const dy = e.y - p.y; const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) { closestDistSq = distSq; closestEnemy = e; }
                });
                if (closestEnemy) {
                    p.beefCharges--; p.beefChargeCooldown = 8; p.beefChargeState = 'charging'; p.beefChargeOrigin = { x: p.x, y: p.y }; p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y }; p.beefChargeT = 0; p.isInvincible = true;
                    store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                    const impactRadius = p.subclass === 'juggernaut' ? 120 : 80;
                    if (p.subclass === 'juggernaut') { explode(closestEnemy.x, closestEnemy.y, false, true); }
                    potentialTargets.forEach(e => {
                        if (e.dead) return;
                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                        if (distSq < impactRadius * impactRadius) {
                            e.hp -= 80 * p.dmgMult; e.stunTimer = 2.5;
                            const knockbackForce = 250; const angle = Math.atan2(e.y - p.y, e.x - p.x);
                            e.knockback = { vx: Math.cos(angle) * knockbackForce, vy: Math.sin(angle) * knockbackForce, duration: 0.3 };
                        }
                    });
                }
            }
        } else if (p.pilotGenome === 'rocketman') {
            if (p.flameWallCooldown > 0) p.flameWallCooldown -= dt;
            if (p.flameWallActiveT > 0) p.flameWallActiveT -= dt;
            if (p.flameWallCooldown <= 0) { p.flameWallActiveT = 0.5; p.flameWallCooldown = 10; }
            if (p.flameWallActiveT > 0) { for (let i = 0; i < 5; i++) { store.flameParticles.push(new FlameParticle(p.x, p.y + 10)); } }
        } else if (p.pilotGenome === 'wizard') {
            if (p.hasChainLightning) {
                p.chainLightningCooldown -= dt;
                if (p.chainLightningCooldown <= 0) { fireChainLightning(); p.chainLightningCooldown = 1.5; }
            }
        }
        if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
        p.fireT -= dt;
        if (p.fireT <= 0) { firePlayer(); p.fireT = p.fireRate; }
        if (p.powerupTimers['missile']) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });
                if (closest) {
                    const isRocketman = p.pilotGenome === 'rocketman';
                    const missileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                    const missileProps = { r: 4, target: closest, speed: 400, life: 0, dmg: missileDmg, hits: 0 };

                    if (p.subclass === 'demolitionist') {
                        const spreadAngle = 10; const initialSpeed = 300;
                        for (let i = 0; i < p.missileVolley; i++) {
                            const angleOffset = (i - (p.missileVolley - 1) / 2) * spreadAngle * (Math.PI / 180);
                            store.missiles.push({ ...missileProps, x: p.x, y: p.y, vx: Math.sin(angleOffset) * initialSpeed, vy: -Math.cos(angleOffset) * initialSpeed, turnRate: 4, pierce: 0, cluster: true });
                        }
                        if (p.hasIceman && store.iceman) {
                             for (let i = 0; i < p.missileVolley; i++) {
                                const angleOffset = (i - (p.missileVolley - 1) / 2) * spreadAngle * (Math.PI / 180);
                                store.missiles.push({ ...missileProps, x: store.iceman.x, y: store.iceman.y, vx: Math.sin(angleOffset) * initialSpeed, vy: -Math.cos(angleOffset) * initialSpeed, dmg: missileDmg * 0.35, isIceman: true, turnRate: 4, pierce: 0, cluster: true });
                            }
                        }
                    } else {
                        for (let i = 0; i < p.missileVolley; i++) {
                            const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                            store.missiles.push({ ...missileProps, x: p.x + offsetX, y: p.y, vx: 0, vy: -300, turnRate: 5, pierce: p.missilePierce, cluster: p.missileCluster });
                        }
                        if (p.hasIceman && store.iceman) {
                            for (let i = 0; i < p.missileVolley; i++) {
                                const offsetX = (i - (p.missileVolley - 1) / 2) * 15;
                                store.missiles.push({ ...missileProps, x: store.iceman.x + offsetX, y: store.iceman.y, vx: 0, vy: -300, dmg: missileDmg * 0.35, isIceman: true, turnRate: 5, pierce: p.missilePierce, cluster: p.missileCluster });
                            }
                        }
                    }
                }
            }
        }
        if (p.shieldMax > 0 && p.shield < p.shieldMax) p.shield = Math.min(p.shieldMax, p.shield + 2 * dt);
        for (const key in p.powerupTimers) { p.powerupTimers[key].remaining -= dt; if (p.powerupTimers[key].remaining <= 0) { if (key === 'drones') store.drones = []; delete p.powerupTimers[key]; } }
        if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
        if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { activateGravityWell(); p.voidBeamCooldown = 30; } }
        if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { activateLazarus(); p.lazarusBeamCooldown = 30; } }
        if (store.cheatInvincibilityCooldown > 0) store.cheatInvincibilityCooldown -= dt;
        if (store.cheatDogHealCooldown > 0) store.cheatDogHealCooldown -= dt;
        if (p.x < 50 && p.y < 50 && store.cheatInvincibilityCooldown <= 0) {
            store.cheatsUsed = true; p.isInvincible = true; p.cheatMultishotBonus = 2; announce('TEST: INVINCIBILITY ACTIVE');
            setTimeout(() => { p.isInvincible = false; p.cheatMultishotBonus = 0; announce('TEST: INVINCIBILITY ENDS'); store.cheatInvincibilityCooldown = 10; }, 15000);
            store.cheatInvincibilityCooldown = 15 + 10;
        }
        if (p.x > W - 50 && p.y < 50 && store.cheatDogHealCooldown <= 0) {
            store.cheatsUsed = true; p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.20);
            if (!p.hasHounds) { p.hasHounds = true; }
            let houndsToAdd = Math.min(2, 4 - store.hounds.length);
            if (houndsToAdd > 0) {
                const existingSides = new Set(store.hounds.map(h => h.side)); const potentialSides = [-1, 1, -2, 2];
                for (const side of potentialSides) { if (houndsToAdd > 0 && !existingSides.has(side)) { store.hounds.push(createHound(side)); houndsToAdd--; } }
            }
            store.cheatDogHealCooldown = 10; announce('TEST: HEAL & HOUNDS');
        }
    }

    function detonateClusterRocket(m) {
        if (m.dead) return;
        m.dead = true;
        playSound('explosion');
        const explosionRadius = 80;
        const chainRadius = 90;
        const microExplosionCount = 5;
        const aoeDmg = m.dmg * 0.2; // 1/5th of a rocket's damage
        for (let i = 0; i < microExplosionCount; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.random() * explosionRadius * 0.7;
            const ex = m.x + Math.cos(angle) * dist;
            const ey = m.y + Math.sin(angle) * dist;
            store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
        }
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(e => {
            if (!e.dead) {
                const distSq = (e.x - m.x)**2 + (e.y - m.y)**2;
                if (distSq < explosionRadius**2) {
                    e.hp = Math.max(1, e.hp - aoeDmg); // Cannot kill, leaves at 1 HP
                }
            }
        });
        store.missiles.forEach(other_m => {
            if (other_m !== m && !other_m.dead && other_m.cluster) {
                const distSq = (other_m.x - m.x)**2 + (other_m.y - m.y)**2;
                if (distSq < chainRadius**2) {
                    other_m.chainDetonate = true;
                }
            }
        });
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            if (m.chainDetonate && !m.dead) {
                detonateClusterRocket(m);
                return;
            }
            m.life += dt; if (m.life > 6) { m.dead = true; return; }
            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }
            m.x += m.vx * dt; m.y += m.vy * dt;
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            if (m.cluster) {
                const proxRadiusSq = 50 * 50;
                for (const e of targets) {
                    if (!e.dead && ((m.x - e.x)**2 + (m.y - e.y)**2 < proxRadiusSq)) {
                        detonateClusterRocket(m);
                        return;
                    }
                }
            }
            for (const e of targets) {
                if (!e.dead && collide(m, e)) {
                    m.hits = (m.hits || 0) + 1;
                    if (m.cluster) {
                        detonateClusterRocket(m);
                    } else {
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        e.hp -= dmg;
                        explode(m.x, m.y, false, true);
                        if (store.player.subclass === 'railgunner' && m.pierce > 0) {
                            m.pierce--;
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else { m.dead = true; }
                        } else if (m.pierce > 0) {
                            m.pierce--;
                        } else {
                            m.dead = true;
                        }
                    }
                    if (m.dead) break;
                }
            }
        });
    }

    function stepLightning(dt) {
        store.lightningBolts.forEach(bolt => {
            bolt.life -= dt;
            if (bolt.life <= 0) { bolt.dead = true; }
        });
    }

    function stepLasers(dt) {
        store.lasers.forEach(laser => {
            laser.life -= dt;
            if (laser.life <= 0) { laser.dead = true; return; }
            laser.prevX = laser.x; laser.prevY = laser.y;
            laser.x += laser.vx * dt; laser.y += laser.vy * dt;
            if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                const speed = Math.sqrt(laser.vx**2 + laser.vy**2);
                let newAngle;
                if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                else { newAngle = Math.PI + Math.random() * Math.PI; }
                laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                laser.hitEnemies.clear();
            }
            store.enemies.forEach(e => {
                if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) { e.hp -= 1000 * store.player.dmgMult; laser.hitEnemies.add(e); }
            });
            if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) { store.boss.hp -= 500 * store.player.dmgMult; laser.hitEnemies.add(store.boss); }
        });
    }

    function stepMines(dt) {
        store.mines.forEach(mine => {
            if (mine.dead) return;
            mine.fuse -= dt;
            let detonate = mine.fuse <= 0;
            if (!detonate) {
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                for(const target of targets) { if(!target.dead && collide(mine, target)) { detonate = true; break; } }
            }
            if(detonate) { mine.dead = true; explodeMine(mine); }
        });
    }
   
    function stepFlameParticles(dt) {
        for (let i = store.flameParticles.length - 1; i >= 0; i--) {
            const p = store.flameParticles[i];
            if (!p.update(dt)) { store.flameParticles.splice(i, 1); }
        }
    }

    function stepWorld(dt) {
        stepPlayer(dt);
        if (store.boss) stepBoss(dt);
        stepHounds(dt);
        stepMissiles(dt);
        stepLasers(dt);
        stepMines(dt);
        stepFlameParticles(dt);
        stepLightning(dt);
        updateVoidStepSystems(store.enemies);
        if (store.world.powerupCooldown > 0) { store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2)); }
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        store.eBullets.forEach(b => {
            b.x += b.vx * dt; b.y += b.vy * dt;
            if (b.gravity) { b.vy += b.gravity * dt; }
            if(b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;
            if (collide(b, store.player)) {
                const p = store.player;
                if(p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                    p.rearGuardReady = false; p.rearGuardCooldown = 8; b.dead = true;
                    store.activeEffects.push(createEffect("rearGuardBlock"));
                } else {
                    takeDamage(b.dmg || 10); b.dead = true;
                }
            }
        });
        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) { store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale }); mine.dead = true; }
                if (collide(mine, store.player)) { takeDamage(50 * dmgScale); mine.dead = true; }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }
        store.enemies.forEach(e => {
            if (e.knockback) {
                e.x += e.knockback.vx * dt; e.y += e.knockback.vy * dt; e.knockback.duration -= dt;
                if (e.knockback.duration <= 0) { e.knockback = null; }
            } else if (e.stunTimer && e.stunTimer > 0) {
                e.stunTimer -= dt;
            } else {
                let speedMultiplier = 1.0;
                if (e.slowTimer > 0) { speedMultiplier = 0.3; e.slowTimer -= dt; }
                if(e.type === 'construct_shard' || e.type === 'avian_hatchling') {
                     const dx = store.player.x - e.x, dy = store.player.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
                     if (dist > 1) { e.x += (dx / dist) * e.v * speedMultiplier * dt; e.y += (dy / dist) * e.v * speedMultiplier * dt; }
                } else if (e.type === 'angler') {
                    const dx = store.player.x - e.x;
                    if(Math.abs(dx) > 10) { e.x += Math.sign(dx) * 30 * speedMultiplier * dt; }
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'manta') {
                    e.t += dt; e.x = e.startX + e.amplitude * Math.sin(e.t * e.frequency); e.y += e.v * speedMultiplier * dt;
                } else {
                    if(store.player.powerupTimers['stealth']) { e.fireT = 1; return; }
                    if (e.isOrbiter) {
                        if (store.boss) { e.orbitCenter.x = store.boss.x; e.orbitCenter.y = store.boss.y; }
                        e.orbitAngle += e.orbitSpeed * speedMultiplier * dt;
                        e.x = e.orbitCenter.x + e.orbitRadius * Math.cos(e.orbitAngle);
                        e.y = e.orbitCenter.y + e.orbitRadius * Math.sin(e.orbitAngle);
                    } else {
                        e.x += (e.vx || 0) * speedMultiplier * dt; e.y += e.v * speedMultiplier * dt;
                    }
                }
                if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
                e.fireT -= dt;
                if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                    switch (e.type) {
                        case 'hunter': { const a=Math.atan2(store.player.y-e.y,store.player.x-e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:3,col:e.color,dmg:10*dmgScale}); e.fireT=1; break; }
                        case 'phantom': { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:180,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=e.fireCooldown; break; }
                        case 'mech': {
                            e.attackPhase = (e.attackPhase || 0) + 1;
                            if (e.attackPhase % 2 === 1) {
                                const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                                const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                                store.eBullets.push({ x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                                const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                                store.eBullets.push({ x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                            } else {
                                const dx = store.player.x - e.x, dist = Math.sqrt(dx*dx + (store.player.y - e.y)**2), timeToTarget = Math.max(0.5, dist / 250);
                                const vx = dx / timeToTarget, gravity = 350, vy = (store.player.y - e.y - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;
                                store.eBullets.push({ x: e.x, y: e.y, vx: vx, vy: vy, r: 6, col: '#ff6347', dmg: 18 * dmgScale, gravity: gravity });
                            }
                            e.fireT = 2; break;
                        }
                        case 'angler': { const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,r:4,col:e.color,dmg:15*dmgScale, life: 5}); e.fireT = 2.5; break; }
                        case 'manta': { for(let i=-1; i<=1; i++) { const angle = (90 + i * 30) * Math.PI/180; store.eBullets.push({x:e.x, y:e.y, vx:Math.cos(angle)*150, vy:Math.sin(angle)*150, r:3, col:e.color, dmg:12*dmgScale}); } e.fireT = 2.8; break; }
                        default: { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:150,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=.5; }
                    }
                }
            }
            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) { takeDamage(15 * dmgScale); store.world.shards += e.shards; e.dead = true; }
        });
        store.bullets.forEach(b => {
            b.x += b.vx * dt; b.y += b.vy * dt;
            if (b.isSwirl) { b.life = (b.life || 0) + dt; b.x += Math.sin(b.life * 15) * 150 * dt; }
            if (b.isFlame) {
                b.life -= dt; if (b.life <= 0) b.dead = true;
                b.particleSpawnT -= dt;
                if(b.particleSpawnT <= 0) {
                    b.particleSpawnT = b.isLavaChunk ? 0.04 : 0.02;
                    const life = 0.3 + Math.random() * 0.3, angle = Math.random() * 2 * Math.PI, speed = b.isLavaChunk ? 10 + Math.random() * 15 : 20 + Math.random() * 20;
                    b.particles.push({ x: 0, y: 0, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: life, maxLife: life, r: 1 + Math.random() * (b.isLavaChunk ? 1.5 : 2) });
                }
                b.particles.forEach(p => { p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt; });
                b.particles = b.particles.filter(p => p.life > 0);
            } else if (b.isLevelUpPulse) { b.life -= dt; if(b.life <= 0) b.dead = true; }
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;
            store.enemies.forEach(e => {
                if (!e.dead && collide(b, e)) {
                    if (b.isFlame) { e.slowTimer = 1.0; }
                    let dmg = b.dmg || 20;
                    if (Math.random() < store.player.critChance) {
                        dmg *= store.player.critDamage;
                        store.activeEffects.push(createEffect('critText', e.x, e.y));
                        if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                    }
                    e.hp -= dmg;
                    if (e.hp <= 0) {
                        e.dead = true; store.world.score += e.score; store.world.shards += e.shards; store.world.xp += e.xp; store.world.kills++;
                        spawnPowerup(e.x, e.y);
                        if (store.player.vampirism > 0) store.player.hp = Math.min(store.player.hpMax, store.player.hp + dmg * store.player.vampirism);
                        explode(e.x, e.y);
                    }
                    if (b.explosive) explode(b.x, b.y, false, true); if (!b.pierce) b.dead = true;
                }
            });
            if (store.boss && !b.dead && collide(b, store.boss)) {
                if (b.isFlame) { store.boss.slowTimer = 1.0; }
                playSound('hit');
                let dmg = b.dmg || 20; if (b.isDrone) dmg *= 0.4;
                if (Math.random() < store.player.critChance) {
                    dmg *= store.player.critDamage;
                    store.activeEffects.push(createEffect('critText', store.boss.x, store.boss.y));
                    if (Math.random() < 0.05) { spawnPowerup(store.boss.x, store.boss.y); }
                }
                store.boss.hp -= dmg;
                if (store.boss.hp <= 0) {
                    const fightDuration = (performance.now() - store.world.bossSpawnTime) / 1000;
                    if (store.boss.name === 'TRAP KING' && store.player.pilotGenome === null) {
                        store.player.pilotGenome = 'pending';
                        setTimeout(showPilotSelect, 1000);
                    }
                    if(store.world.wave === 20 && !store.player.subclass) { setTimeout(showSubclassSelect, 1500); }
                    store.world.score += 2000; store.world.shards += 25; store.world.xp += 100; store.world.bosses++;
                    store.boss = null; announce('‚ö° GUARDIAN DEFEATED ‚ö°'); explode(b.x, b.y, true);
                    let healthBonusMultiplier = 1.0, announcedAdaptation = false;
                    if (fightDuration <= 4) {
                        announcedAdaptation = true;
                        if (store.world.wave >= 15) {
                            store.world.consecutiveFastKills++;
                            if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                            healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                            announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
                        } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
                        store.world.collarStacks++;
                    } else if (fightDuration > 10) {
                        store.world.collarStacks = 0; store.world.consecutiveFastKills = 0; store.world.fastKillBonus = 0;
                        healthBonusMultiplier = 1.0; announce("ADAPTATION RESET!");
                    } else {
                        announcedAdaptation = true; healthBonusMultiplier = 1.10;
                        store.world.consecutiveFastKills = 0; store.world.fastKillBonus = 0;
                        announce("GUARDIANS ADAPTING!");
                    }
                    store.world.bossHealthBonus *= healthBonusMultiplier;
                    if (announcedAdaptation) {
                        const enemyHealthBonus = healthBonusMultiplier > 1.1 ? 1.15 : 1.05;
                        store.world.enemyHealthBonus *= enemyHealthBonus;
                        store.world.enemyDensityBonus *= 1.10;
                        setTimeout(() => announce("ENEMY SWARMS INTENSIFYING!"), 1000);
                    }
                }
                if (b.explosive) explode(b.x, b.y, false, true); if (!b.pierce) b.dead = true;
            }
        });
        ['bullets', 'eBullets', 'enemies', 'powerups', 'mines', 'missiles', 'lasers', 'flameParticles', 'lightningBolts'].forEach(key => store[key] = store[key].filter(i => !i.dead));
        store.activeEffects = store.activeEffects.filter(e => e.isActive !== false);
        if (!store.boss && store.enemies.length === 0) {
            if (store.world.waveStartTime > 0) {
                const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;
                if (waveClearTime < 5 && store.world.wave > 1) {
                    store.world.enemyDensityBonus *= 1.1; store.world.enemyHealthBonus *= 1.05;
                    store.world.xpMultiplier *= 1.05; store.world.collarStacks++;
                    announce("SWARM INTENSITY RISING!");
                }
            }
            store.world.wave++;
            const hpBonus = 3; store.player.hpMax += hpBonus; store.player.hp += hpBonus;
            initWave();
        }
        let xpNeeded = store.world.level * 100 * store.world.xpMultiplier;
        if (store.world.wave > 10) { xpNeeded *= 1.30; }
        if (store.world.level >= 8) { xpNeeded *= 1.30; } else if (store.world.level >= 4) { xpNeeded *= 1.10; }
        xpNeeded = Math.floor(xpNeeded);
        if (store.world.xp >= xpNeeded) { store.world.xp -= xpNeeded; store.world.level++; levelUp(); }
        if (store.player.hp <= 0) handleGameOver();
    }
</body>
</html>
