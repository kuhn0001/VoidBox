<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg%20xmlns%3D%27http://www.w3.org/2000/svg%27%20viewBox%3D%270%200%2064%2064%27%3E%3Crect%20width%3D%2764%27%20height%3D%2764%27%20rx%3D%2712%27%20fill%3D%27%23130029%27/%3E%3Cpath%20d%3D%27M16%2044L32%2020l16%2024%27%20stroke%3D%27%23ff66cc%27%20stroke-width%3D%276%27%20stroke-linecap%3D%27round%27%20stroke-linejoin%3D%27round%27%20fill%3D%27none%27/%3E%3Ccircle%20cx%3D%2732%27%20cy%3D%2732%27%20r%3D%276%27%20fill%3D%27%238a7fff%27/%3E%3C/svg%3E" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap"
        rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg: #050008;
            --fg: #ff99cc;
            --accent: #b266ff;
            --accent2: #9a66ff;
            --edge: rgba(178, 102, 255, .35);
            --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px);
            --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px);
            --maxw: 98vw;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: radial-gradient(1200px 800px at 50% 40%, #330044, var(--bg));
            color: var(--fg);
            font-family: 'Audiowide', ui-sans-serif, system-ui
        }

        /* Hide VS Code browser controls */
        .monaco-workbench .part.titlebar,
        .vs-dark .monaco-workbench .part.titlebar,
        .titlebar,
        .browser-close-button,
        .browser-action-buttons,
        .monaco-action-bar {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            opacity: 0 !important;
        }

        .close-btn {
            position: absolute;
            top: 12px;
            right: 16px;
            background: rgba(40, 14, 60, 0.82);
            border: 1px solid rgba(210, 170, 255, 0.55);
            color: #f1d9ff;
            font-size: 24px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: 700;
            line-height: 1;
            cursor: pointer;
            opacity: 0.84;
            transition: opacity 0.2s, transform 0.2s, box-shadow 0.2s;
            padding: 6px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 18px rgba(210, 170, 255, 0.35);
            z-index: 5;
        }

        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Hide only the specific problematic close buttons */
        #closeScores {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* More aggressive hiding of browser UI */
        body {
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden;
        }

        /* Hide any top-level browser chrome */
        :root {
            --browser-chrome-height: 0px;
        }

        #wrap {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            min-height: 100svh;
            padding: 0;
        }

        .stage {
            width: 100vw;
            height: 100svh;
            position: relative;
            display: grid;
            place-items: center;
            background: #000;
            border-radius: 0;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(255, 0, 255, .4);
            container-type: inline-size;
            z-index: 2;
        }

        canvas {
            background: transparent;
            border-radius: 16px;
            touch-action: none;
            cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;
        }

        #ui {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .panel {
            pointer-events: auto;
        }

        #topBar {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: start;
            padding: 4px;
            pointer-events: none
        }

        #hud {
            display: flex;
            gap: 8px;
            pointer-events: none;
            font-size: var(--hud-text);
            justify-content: center;
            align-items: flex-start;
            width: auto;
            max-width: none;
            transform: translateY(2px);
            grid-column: 2
        }

        .hud-card {
            pointer-events: none;
            border: 1px solid var(--edge);
            background: linear-gradient(180deg, rgba(150, 80, 255, .12), rgba(150, 80, 255, .06));
            backdrop-filter: blur(8px);
            padding: 6px 10px;
            border-radius: 8px;
            width: auto;
            min-width: 220px
        }

        .hud-title {
            opacity: .85;
            font-weight: 600;
            margin-bottom: 4px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-align: center;
            font-size: 10px;
            color: #c49cff
        }

        #hudPowerup {
            grid-column: 1;
            justify-self: start;
            margin-left: 8px;
            min-width: 150px
        }

        #hudEquipment {
            grid-column: 3;
            justify-self: end;
            margin-right: 8px;
            min-width: 150px;
            text-align: right;
        }

        .bar {
            height: 4px;
            width: 100%;
            background: rgba(150, 80, 255, .12);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid var(--edge);
            margin-top: 2px
        }

        .bar>span {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent2))
        }

        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }

        #diagBox {
            position: absolute;
            left: 8px;
            top: 8px;
            display: grid;
            gap: 4px;
            pointer-events: none
        }

        .chip {
            pointer-events: auto;
            background: rgba(0, 0, 0, .7);
            border: 1px solid var(--edge);
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 10px;
            letter-spacing: .3px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-align: left;
            color: #c49cff
        }

        .btn {
            background: #330044;
            color: #ffddff;
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            font-size: var(--btn-text);
            cursor: pointer;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            transition: all .2s;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .btn:hover {
            background: #4c0e72;
            box-shadow: 0 0 15px rgba(178, 102, 255, .5)
        }

        .btn.secondary {
            background: transparent;
            border-color: #ff9cff;
            color: #ffd6ff;
            box-shadow: none;
        }

        .btn.secondary:hover {
            background: rgba(255, 156, 255, 0.12);
            box-shadow: 0 0 15px rgba(255, 156, 255, 0.4)
        }

        .panel {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 0, 34, .95);
            border: 1px solid var(--accent);
            border-radius: 16px;
            padding: 20px 18px 18px;
            width: min(560px, 88vw);
            max-height: min(84vh, 720px);
            overflow-y: auto;
            overscroll-behavior: contain;
            backdrop-filter: blur(12px);
            color: #ffddff;
            box-shadow: 0 0 40px rgba(178, 102, 255, .3);
            z-index: 100;
        }

        .panel::-webkit-scrollbar {
            width: 8px
        }

        .panel::-webkit-scrollbar-thumb {
            background: rgba(178, 102, 255, 0.35);
            border-radius: 999px
        }

        .panel.panel-floating-close {
            padding-top: 58px
        }

        .panel-back-btn {
            position: absolute;
            top: 14px;
            left: 16px;
            padding: 8px 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 215, 128, 0.55);
            background: linear-gradient(135deg, rgba(255, 215, 128, 0.18), rgba(255, 160, 64, 0.16));
            color: #ffe6b3;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 11px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 6;
        }

        .panel-back-btn:hover {
            border-color: rgba(255, 215, 128, 0.9);
            background: linear-gradient(135deg, rgba(255, 215, 128, 0.32), rgba(255, 170, 80, 0.26));
            box-shadow: 0 0 14px rgba(255, 200, 110, 0.28);
        }

        .panel-back-btn.hide {
            display: none;
        }


        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }

        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }

        #shopPanel h2,
        #levelPanel h2,
        #scorePanel h2,
        #namePanel h2,
        #pilotPanel h2,
        #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }

        #shopPanel p,
        #levelPanel p,
        #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }

        #shopGrid,
        #scorePanel div {
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 8px;
        }

        #shopGrid {
            display: block;
        }

        .character-sheet-body {
            font-family: 'Orbitron', 'Audiowide', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.55;
            color: #f6ecff;
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 6px;
        }

        .character-sheet-body::-webkit-scrollbar {
            width: 6px;
        }

        .character-sheet-body::-webkit-scrollbar-thumb {
            background: rgba(189, 128, 255, 0.45);
            border-radius: 10px;
        }

        .intel-section {
            margin-bottom: 16px;
        }

        .intel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #f7d7ff;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        .intel-summary {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(124, 62, 160, 0.22);
            border-left: 2px solid rgba(228, 189, 255, 0.55);
            padding: 8px 12px;
            border-radius: 6px;
        }

        .intel-summary-line {
            font-size: 11px;
            letter-spacing: 0.05em;
            color: #f3e3ff;
        }

        .intel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .intel-cell {
            background: rgba(82, 34, 120, 0.32);
            border: 1px solid rgba(201, 146, 255, 0.35);
            border-radius: 10px;
            padding: 8px 10px 9px;
            box-shadow: inset 0 0 12px rgba(150, 70, 200, 0.25);
        }

        .intel-key {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: #dfc2ff;
            opacity: 0.82;
        }

        .intel-val {
            font-size: 14px;
            font-weight: 700;
            color: #f6ecff;
        }

        .intel-detail {
            font-size: 10px;
            color: #d5b9ff;
            opacity: 0.85;
            margin-top: 4px;
        }

        .intel-list {
            margin: 0;
            padding-left: 18px;
            font-size: 11px;
            color: #f3e3ff;
        }

        .intel-list li {
            margin-bottom: 4px;
        }

        .intel-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: rgba(66, 24, 110, 0.48);
            border: 1px solid rgba(205, 150, 255, 0.4);
            border-radius: 10px;
            overflow: hidden;
        }

        .intel-table thead {
            background: rgba(118, 58, 168, 0.55);
        }

        .intel-table th,
        .intel-table td {
            padding: 6px 8px;
            color: #f2e6ff;
            border-bottom: 1px solid rgba(205, 150, 255, 0.22);
            text-align: left;
        }

        .intel-table tr:last-child td {
            border-bottom: none;
        }

        .intel-table tr.active {
            background: rgba(151, 83, 214, 0.35);
        }

        .intel-table tr.inactive {
            opacity: 0.55;
        }

        .intel-subtitle {
            margin-top: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #f0d9ff;
        }

        .intel-note {
            font-size: 10px;
            color: #d4baff;
            opacity: 0.75;
            margin-top: 6px;
        }

        .forge-toolbar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            margin-bottom: 12px;
        }

        .forge-toolbar .mobile-toggle-container {
            flex: 1 1 auto;
        }

        .forge-toolbar-btn {
            background: linear-gradient(135deg, rgba(138, 70, 214, 0.85), rgba(84, 36, 140, 0.9));
            border: 1px solid rgba(214, 170, 255, 0.7);
            border-radius: 20px;
            padding: 6px 14px;
            font-size: 11px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #f8eaff;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .forge-toolbar-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 14px rgba(210, 160, 255, 0.6);
        }

        .forge-toolbar-btn[aria-pressed="true"] {
            background: linear-gradient(135deg, rgba(167, 90, 240, 0.95), rgba(110, 48, 180, 0.95));
            box-shadow: 0 0 18px rgba(214, 170, 255, 0.7);
        }

        .grid {
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .shop-section {
            margin-bottom: 18px;
            padding-bottom: 14px;
            border-bottom: 1px solid rgba(178, 102, 255, 0.24);
        }

        .shop-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .shop-section-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
        }

        .shop-section-title {
            margin: 0;
            font-size: clamp(14px, 1.8vw, 18px);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #f6e4ff;
        }

        .shop-section-subtitle {
            margin: 0;
            font-size: clamp(10px, 1.4vw, 12px);
            letter-spacing: 0.06em;
            color: rgba(214, 190, 255, 0.78);
            flex: 1 1 auto;
            text-align: right;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .shop-section-grid {
            margin-top: 10px;
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .shop-control-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: stretch;
            margin: 16px 0;
        }

        .shop-control-block {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 14px;
            border: 1px solid rgba(178, 102, 255, 0.35);
            background: rgba(20, 4, 40, 0.65);
            flex: 1 1 260px;
            min-width: 220px;
            box-shadow: inset 0 0 12px rgba(178, 102, 255, 0.18);
        }

        .shop-control-copy {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1 1 auto;
        }

        .shop-control-title {
            margin: 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.09em;
            color: var(--accent);
        }

        .shop-control-desc {
            margin: 0;
            font-size: 10px;
            line-height: 1.4;
            color: rgba(214, 190, 255, 0.82);
        }

        .shop-control-status {
            font-size: 10px;
            color: #9fead8;
            line-height: 1.4;
        }

        .shop-advanced-btn {
            background: linear-gradient(140deg, rgba(140, 80, 255, 0.9), rgba(70, 20, 140, 0.92));
            border: 1px solid rgba(210, 160, 255, 0.8);
            border-radius: 14px;
            padding: 10px 18px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #ffffff;
            flex: 0 0 auto;
            align-self: center;
        }

        .shop-advanced-btn:hover {
            background: linear-gradient(140deg, rgba(160, 100, 255, 0.95), rgba(80, 30, 160, 0.95));
            border-color: rgba(230, 200, 255, 0.9);
            box-shadow: 0 0 18px rgba(178, 102, 255, 0.5);
        }

        .shop-view-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .shop-view-btn {
            flex: 1 1 180px;
            padding: 8px 16px;
            border-radius: 999px;
            border: 1px solid rgba(178, 102, 255, 0.35);
            background: rgba(24, 4, 44, 0.6);
            color: #eadeff;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shop-view-btn:hover {
            background: rgba(178, 102, 255, 0.18);
            box-shadow: 0 0 12px rgba(178, 102, 255, 0.28);
        }

        .shop-view-btn.active {
            background: linear-gradient(135deg, rgba(140, 70, 255, 0.92), rgba(70, 20, 150, 0.9));
            border-color: rgba(210, 160, 255, 0.85);
            color: #ffffff;
            box-shadow: 0 0 16px rgba(178, 102, 255, 0.4);
        }

        .shop-view {
            display: block;
        }

        .shop-power-section {
            margin-bottom: 18px;
            padding: 14px 16px 16px;
            border-radius: 14px;
            border: 1px solid rgba(178, 102, 255, 0.25);
            background: linear-gradient(160deg, rgba(18, 0, 32, 0.7), rgba(30, 10, 50, 0.6));
            box-shadow: inset 0 0 12px rgba(178, 102, 255, 0.15);
        }

        .shop-power-section:last-of-type {
            margin-bottom: 0;
        }

        .shop-power-section h4 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--accent);
        }

        .shop-power-section p {
            margin: 0 0 10px 0;
            font-size: 10px;
            color: rgba(214, 190, 255, 0.78);
            line-height: 1.5;
        }

        .shop-powerup-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .shop-power-card {
            background: rgba(40, 10, 68, 0.65);
            border: 1px solid rgba(178, 102, 255, 0.3);
            border-radius: 12px;
            padding: 12px 14px;
            color: #f6edff;
            box-shadow: inset 0 0 10px rgba(178, 102, 255, 0.18);
        }

        .shop-power-card-title {
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin: 0 0 6px 0;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .shop-power-card-meta {
            font-size: 10px;
            color: rgba(214, 190, 255, 0.86);
            margin-bottom: 6px;
        }

        .shop-power-bar {
            height: 6px;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(178, 102, 255, 0.25);
        }

        .shop-power-bar span {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, #ffd45a, #ff8bff);
        }

        .shop-powerup-list {
            margin: 6px 0 0 0;
            padding-left: 18px;
            list-style: square;
            font-size: 11px;
            line-height: 1.6;
            color: #e8dcff;
        }

        .shop-powerup-list strong {
            color: var(--accent);
        }

        .shop-empty-subtle {
            text-align: center;
            padding: 12px;
            border: 1px dashed rgba(178, 102, 255, 0.3);
            border-radius: 12px;
            font-size: 11px;
            color: rgba(230, 210, 255, 0.78);
        }

        .shop-item-cost {
            color: #ffd95a;
            margin-top: 6px;
            font-size: 12px;
            letter-spacing: 0.08em;
            font-weight: 700;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 205, 90, 0.6), 0 0 18px rgba(255, 140, 40, 0.35);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .shop-item-cost::before {
            content: "âœ¦";
            font-size: 13px;
            color: #ffe8a3;
            text-shadow: inherit;
        }

        .shop-empty {
            text-align: center;
            padding: 16px;
            border: 1px dashed rgba(214, 190, 255, 0.35);
            border-radius: 12px;
            font-size: 12px;
            letter-spacing: 0.08em;
            color: rgba(230, 210, 255, 0.75);
        }

        /* Character Sheet Panel */
        #characterSheetPanel {
            width: min(900px, 95vw);
            max-height: 85vh;
            overflow-y: auto;
        }

        /* Upgrade Hangar Menu Panel */
        #mechForgeMenuPanel {
            width: min(660px, 92vw);
            padding: 28px 32px 30px;
            background: radial-gradient(circle at top, rgba(40, 12, 68, 0.92) 0%, rgba(22, 4, 40, 0.95) 55%, rgba(16, 0, 28, 0.96) 100%);
        }

        .forge-menu-header {
            text-align: center;
            margin-bottom: 28px;
        }

        .forge-menu-title-large {
            margin: 0;
            font-size: 26px;
            letter-spacing: 0.2em;
            color: var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-transform: uppercase;
        }

        .forge-menu-subtitle {
            margin: 12px auto 0;
            max-width: 500px;
            font-size: 12px;
            line-height: 1.6;
            color: #d7caff;
        }

        .forge-menu-highlight {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 9px 18px;
            margin-top: 15px;
            border-radius: 999px;
            border: 1px solid rgba(160, 120, 255, 0.5);
            background: rgba(100, 60, 200, 0.22);
            font-size: 11px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: #f6edff;
        }

        .forge-menu-section {
            margin-bottom: 24px;
            background: rgba(18, 0, 26, 0.75);
            border: 1px solid rgba(160, 110, 255, 0.28);
            border-radius: 14px;
            padding: 18px 20px 20px;
            box-shadow: 0 0 22px rgba(122, 68, 210, 0.22);
        }

        .forge-menu-section:last-of-type {
            margin-bottom: 0;
        }

        .forge-menu-section-head {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 16px;
        }

        .forge-menu-title {
            font-size: 15px;
            color: var(--accent);
            margin: 0 0 4px;
            text-align: left;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }

        .forge-menu-section-hint {
            font-size: 11px;
            color: #cbb8ff;
            line-height: 1.5;
        }

        .forge-menu-grid {
            display: grid;
            gap: 14px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .forge-profile-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .forge-profile-card {
            position: relative;
            border: 1px solid rgba(160, 110, 255, 0.28);
            background: linear-gradient(145deg, rgba(16, 0, 32, 0.85), rgba(30, 0, 48, 0.65));
            border-radius: 12px;
            padding: 12px 14px 14px;
            color: #f0eaff;
            text-align: left;
            font-size: 12px;
            line-height: 1.5;
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }

        .forge-profile-card:hover {
            transform: translateY(-2px);
            border-color: rgba(190, 150, 255, 0.5);
            box-shadow: 0 10px 24px rgba(90, 40, 150, 0.25);
        }

        .forge-profile-card.active {
            border-color: var(--accent);
            box-shadow: 0 12px 28px rgba(120, 70, 220, 0.38);
            background: linear-gradient(150deg, rgba(34, 4, 70, 0.95), rgba(18, 0, 40, 0.9));
        }

        .forge-profile-card-title {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 13px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            margin-bottom: 6px;
            color: var(--accent);
        }

        .forge-profile-card-summary {
            font-size: 12px;
            color: #d7caff;
        }

        .forge-profile-card.active .forge-profile-card-summary {
            color: #ffffff;
        }

        .forge-profile-summary {
            margin-top: 16px;
            font-size: 12px;
            line-height: 1.6;
            color: #d7caff;
            min-height: 40px;
        }

        .forge-menu-btn {
            background: linear-gradient(135deg, rgba(150, 80, 255, 0.3), rgba(120, 60, 200, 0.4));
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 18px 22px;
            color: #ffddff;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 10px;
            min-height: 110px;
        }

        .forge-menu-btn-title {
            font-size: 15px;
            letter-spacing: 0.08em;
        }

        #openPrimordialLabFromMenu {
            background: linear-gradient(135deg, rgba(120, 70, 255, 0.95), rgba(40, 160, 255, 0.88));
            border-color: rgba(200, 170, 255, 0.85);
            color: #f7f3ff;
            padding: 22px 24px;
            font-size: 15px;
            box-shadow: 0 0 22px rgba(150, 120, 255, 0.38);
        }

        #openPrimordialLabFromMenu .forge-menu-desc {
            color: rgba(246, 240, 255, 0.82);
            opacity: 0.95;
        }

        #openPrimordialLabFromMenu:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(140, 92, 255, 0.98), rgba(70, 190, 255, 0.92));
            box-shadow: 0 0 28px rgba(168, 132, 255, 0.55);
        }

        #openCharacterSheet {
            background: linear-gradient(135deg, rgba(140, 90, 255, 0.45), rgba(100, 40, 200, 0.6));
            border-color: #b88bff;
            color: #f2e8ff;
        }

        #openCharacterSheet .forge-menu-desc {
            color: rgba(236, 222, 255, 0.8);
        }

        #openCharacterSheet:hover {
            background: linear-gradient(135deg, rgba(170, 120, 255, 0.65), rgba(120, 60, 220, 0.75));
            box-shadow: 0 0 24px rgba(184, 139, 255, 0.45);
        }

        #openShopTutorial {
            background: linear-gradient(135deg, rgba(60, 200, 125, 0.45), rgba(20, 150, 95, 0.6));
            border-color: #4fd688;
            color: #e8fff4;
        }

        #openShopTutorial .forge-menu-desc {
            color: rgba(224, 255, 242, 0.85);
        }

        #openShopTutorial:hover {
            background: linear-gradient(135deg, rgba(90, 230, 150, 0.65), rgba(30, 170, 110, 0.75));
            box-shadow: 0 0 22px rgba(94, 232, 170, 0.45);
        }

        .forge-menu-btn:hover {
            background: linear-gradient(135deg, rgba(180, 100, 255, 0.5), rgba(150, 80, 230, 0.6));
            box-shadow: 0 0 20px rgba(178, 102, 255, 0.5);
            transform: translateY(-2px);
        }

        .forge-menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .forge-menu-desc {
            font-size: 11px;
            color: #ccaaff;
            line-height: 1.6;
            text-align: left;
            opacity: 0.88;
        }

        .forge-menu-meta {
            margin-top: 6px;
            font-size: 11px;
            line-height: 1.5;
            color: #dee4ff;
            text-align: left;
        }

        .forge-menu-meta strong {
            color: #a9baff;
            font-weight: 600;
        }

        .forge-menu-meta.locked {
            color: #ffadc9;
        }

        .forge-menu-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 18px;
            background: rgba(45, 20, 70, 0.62);
            border: 1px solid rgba(160, 120, 255, 0.3);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 12px;
            color: #e9dcff;
        }

        .forge-menu-toggle:last-child {
            margin-bottom: 0;
        }

        .forge-menu-toggle-copy {
            flex: 1;
            text-align: left;
        }

        .forge-menu-toggle-title {
            font-size: 12px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #f4e8ff;
        }

        .forge-menu-toggle-desc {
            margin-top: 4px;
            font-size: 11px;
            color: #cbb8ff;
            line-height: 1.5;
        }

        .forge-menu-footnote {
            margin: 22px 0 0;
            font-size: 11px;
            color: #bfa8ff;
            text-align: center;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        @media (max-width: 540px) {
            #mechForgeMenuPanel {
                padding: 24px 18px;
            }

            .forge-menu-title-large {
                font-size: 22px;
                letter-spacing: 0.14em;
            }

            .forge-menu-section-head {
                flex-direction: column;
                gap: 8px;
            }

            .forge-menu-toggle {
                flex-direction: column;
                align-items: flex-start;
            }

            .forge-menu-toggle .switch {
                align-self: flex-end;
            }
        }

        .hide {
            display: none !important
        }

        #belowBoard {
            width: min(98vw, var(--maxw));
            margin: 50px auto 0;
            padding: 8px;
            display: grid;
            gap: 8px
        }

        #hsCard {
            border: 1px solid var(--edge);
            background: linear-gradient(180deg, rgba(150, 80, 255, .12), rgba(150, 80, 255, .06));
            backdrop-filter: blur(8px);
            padding: 8px;
            border-radius: 8px
        }

        #hsCard h3 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-align: center;
            font-size: 14px;
            color: #c49cff
        }

        #hsList {
            list-style: decimal;
            margin: 0;
            padding: 0 0 0 1rem;
            line-height: 1.4;
            font-size: 12px;
            color: #ffddff
        }

        .skill-card {
            background: radial-gradient(circle, rgba(51, 0, 68, 1) 0%, rgba(51, 0, 68, 0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }

        .skill-card:hover {
            background: rgba(85, 0, 120, .9);
            box-shadow: 0 0 20px rgba(178, 102, 255, .6);
            transform: scale(1.05)
        }

        .skill-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important
        }

        /* Primordial Soldier Laboratory Styles */
        #championDressingRoom {
            width: min(85vw, 650px);
            max-height: 85vh;
            overflow-y: auto;
        }

        .dressing-room-header {
            text-align: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(178, 102, 255, .3);
            padding-bottom: 12px;
        }

        .dressing-room-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px;
            margin-bottom: 15px;
        }

        @media (max-width: 600px) {
            .dressing-room-content {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }

        .champion-preview-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .preview-viewport {
            position: relative;
            width: 160px;
            height: 160px;
            border: 2px solid var(--accent);
            border-radius: 10px;
            background: radial-gradient(circle, rgba(20, 0, 40, 0.9) 0%, rgba(5, 0, 15, 0.95) 100%);
            overflow: hidden;
            margin-bottom: 8px;
            box-shadow: inset 0 0 15px rgba(178, 102, 255, .2);
        }

        #championPreviewCanvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .preview-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 8px;
            text-align: center;
        }

        .champion-name {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 8px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }



        .champion-stats-section {
            background: rgba(18, 0, 26, 0.6);
            border: 1px solid rgba(178, 102, 255, .2);
            border-radius: 10px;
            padding: 12px;
        }

        .stats-header h3 {
            margin: 0 0 10px 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            color: var(--accent);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 6px;
            background: rgba(30, 0, 50, 0.4);
            border: 1px solid rgba(178, 102, 255, .15);
            border-radius: 5px;
        }

        .stat-label {
            font-size: 10px;
            color: #c0b4ff;
            font-family: 'Orbitron', ui-sans-serif;
        }

        .stat-value {
            font-size: 10px;
            color: #ffddff;
            font-weight: bold;
        }

        .attack-types-section,
        .upgrade-preview-section {
            margin-bottom: 12px;
        }

        .attack-types-section h4,
        .upgrade-preview-section h4 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', ui-sans-serif;
            color: var(--accent2);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .attack-types-list,
        .upgrades-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .attack-type-item,
        .upgrade-item {
            background: rgba(40, 0, 60, 0.3);
            border: 1px solid rgba(178, 102, 255, .1);
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 9px;
            color: #e0d4ff;
        }

        .attack-type-item .attack-name,
        .upgrade-item .upgrade-name {
            font-weight: bold;
            color: var(--accent2);
        }

        .ability-icon {
            font-size: 12px;
            margin-right: 6px;
            opacity: 0.85;
        }

        .loadout-section {
            margin-bottom: 12px;
        }

        .loadout-section h4 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', ui-sans-serif;
            color: var(--accent2);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .loadout-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .loadout-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(26, 0, 45, 0.4);
            border: 1px solid rgba(178, 102, 255, .12);
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 9px;
            color: #e0d4ff;
        }

        .loadout-label {
            color: #c0b4ff;
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .loadout-value {
            font-weight: 600;
            color: #ffddff;
        }

        .champion-class {
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 7px;
            color: rgba(255, 230, 255, 0.9);
            letter-spacing: 0.08em;
            margin-top: 2px;
        }

        .dressing-room-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid rgba(178, 102, 255, .2);
            padding-top: 12px;
        }

        .btn-primary {
            background: linear-gradient(145deg, var(--accent), var(--accent2));
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: linear-gradient(145deg, var(--accent2), var(--accent));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(178, 102, 255, .3);
        }

        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }

        /* Enhanced Attack Module Selection Styles */
        .builder-select {
            background: rgba(20, 0, 40, 0.8);
            border: 1px solid rgba(178, 102, 255, .3);
            color: #e0d4ff;
            border-radius: 5px;
            padding: 6px 8px;
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 10px;
            width: 100%;
        }

        .builder-select optgroup {
            background: rgba(30, 0, 50, 0.95);
            color: var(--accent);
            font-weight: bold;
            font-size: 9px;
            letter-spacing: 0.05em;
        }

        .builder-select option {
            background: rgba(20, 0, 40, 0.9);
            color: #e0d4ff;
            padding: 4px;
            font-size: 9px;
        }

        .builder-select option:hover {
            background: rgba(178, 102, 255, 0.2);
        }

        /* Attack Module Info Display */
        .module-info-display {
            margin-top: 8px;
            padding: 8px;
            background: rgba(26, 0, 45, 0.4);
            border: 1px solid rgba(178, 102, 255, .15);
            border-radius: 5px;
            font-size: 9px;
            line-height: 1.3;
        }

        .module-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 8px;
        }

        .module-type-kinetic {
            background: rgba(150, 150, 150, 0.3);
            color: #ddd;
        }

        .module-type-fire {
            background: rgba(255, 100, 50, 0.3);
            color: #ffaa88;
        }

        .module-type-laser {
            background: rgba(255, 50, 100, 0.3);
            color: #ff88aa;
        }

        .module-type-lightning {
            background: rgba(100, 150, 255, 0.3);
            color: #88aaff;
        }

        .trade-off-indicator {
            font-style: italic;
            color: #c0b4ff;
            margin-top: 4px;
        }

        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }

        .skill-title {
            font-weight: 700;
            color: #c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }

        .skill-desc {
            font-size: 11px;
            color: #ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }

        .skill-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .skill-row {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .skill-card-node-pair {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .skill-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            width: 100%;
        }

        #subclassPanel.skill-tree-active {
            width: min(900px, 95vw);
            max-height: 80vh;
            overflow-y: auto;
            padding: 20px 24px 28px;
        }

        #skillTree {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .skill-tree-title {
            font-size: 28px;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.24em;
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.8);
            text-align: center;
            margin: 0 auto 14px;
            max-width: 680px;
        }

        .skill-view-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 14px;
        }

        /* Champion Builder Styles */
        .champion-builder-section {
            flex: 1;
            min-width: 250px;
            padding: 15px;
            background: linear-gradient(145deg, rgba(30, 10, 50, 0.9), rgba(50, 20, 80, 0.8));
            border: 1px solid rgba(178, 102, 255, 0.3);
            border-radius: 10px;
            margin: 0 15px;
        }

        .builder-header h3 {
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 14px;
            color: var(--accent);
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .builder-guidance {
            font-size: 9px;
            color: #c8b6ff;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .builder-guidance p {
            margin: 0 0 4px 0;
        }

        .builder-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .builder-option {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .builder-option label {
            font-size: 11px;
            color: #ffddff;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .builder-option-desc {
            font-size: 9px;
            color: #b8a8ff;
            line-height: 1.3;
            margin: -2px 0 2px 0;
        }

        .builder-option-detail {
            margin-top: 4px;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(178, 102, 255, 0.32);
            background: linear-gradient(135deg, rgba(30, 10, 60, 0.85), rgba(18, 6, 36, 0.8));
            box-shadow: inset 0 0 10px rgba(178, 102, 255, 0.14);
            color: #efe4ff;
            font-size: 9.5px;
            line-height: 1.45;
        }

        .builder-option-detail p {
            margin: 0;
        }

        .builder-detail-title {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 10px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #ffd9ff;
            margin: 0 0 4px 0;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .builder-detail-title span {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .builder-detail-meta {
            list-style: none;
            margin: 6px 0 0 0;
            padding: 0;
            color: #d9cfff;
            font-size: 9px;
        }

        .builder-detail-meta li {
            margin-bottom: 3px;
        }

        .builder-detail-meta li strong {
            color: #f9ecff;
        }

        .builder-select {
            padding: 6px 10px;
            background: rgba(20, 10, 40, 0.8);
            border: 1px solid rgba(178, 102, 255, 0.4);
            border-radius: 5px;
            color: #ffffff;
            font-size: 12px;
            cursor: pointer;
        }

        .builder-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(178, 102, 255, 0.3);
        }

        .builder-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
        }

        .builder-action-btn {
            padding: 6px 14px;
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border-radius: 9px;
            background: rgba(51, 0, 68, 0.85);
            border: 1px solid rgba(178, 102, 255, 0.55);
            color: #f9e9ff;
            box-shadow: none;
        }

        .builder-action-btn:hover {
            background: linear-gradient(135deg, rgba(140, 60, 255, 0.9), rgba(60, 20, 120, 0.95));
            box-shadow: 0 0 16px rgba(178, 102, 255, 0.45);
        }

        .builder-action-apply {
            background: linear-gradient(135deg, rgba(160, 70, 255, 0.92), rgba(70, 20, 160, 0.9));
            border-color: rgba(210, 150, 255, 0.8);
        }

        .builder-action-apply:hover {
            border-color: rgba(235, 190, 255, 0.95);
            box-shadow: 0 0 18px rgba(210, 150, 255, 0.55);
        }

        .builder-action-reset {
            background: rgba(20, 10, 40, 0.6);
            border-color: rgba(178, 102, 255, 0.35);
            color: #d8ccff;
        }

        .builder-action-reset:hover {
            background: rgba(178, 102, 255, 0.14);
            box-shadow: 0 0 14px rgba(178, 102, 255, 0.35);
        }

        .champion-preset-section {
            margin-top: 18px;
            padding: 14px;
            border-radius: 12px;
            border: 1px solid rgba(178, 102, 255, 0.35);
            background: linear-gradient(145deg, rgba(20, 10, 40, 0.7), rgba(12, 6, 28, 0.85));
            box-shadow: inset 0 0 18px rgba(25, 10, 45, 0.45);
        }

        .champion-preset-section h3 {
            margin: 0 0 6px 0;
            font-size: 15px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .champion-preset-section p {
            margin: 0 0 10px 0;
            color: #dcd0ff;
            font-size: 11px;
        }

        .preset-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .preset-code-output {
            width: 100%;
            resize: none;
            border-radius: 10px;
            border: 1px solid rgba(178, 102, 255, 0.5);
            background: rgba(12, 6, 24, 0.9);
            color: #f0e5ff;
            font-family: 'Consolas', 'Fira Code', monospace;
            font-size: 13px;
            letter-spacing: 0.05em;
            padding: 10px 12px;
        }

        .preset-code-output:focus {
            outline: none;
            border-color: rgba(210, 150, 255, 0.85);
            box-shadow: 0 0 12px rgba(178, 102, 255, 0.35);
        }

        .preset-import {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .preset-code-input {
            flex: 1;
            min-width: 200px;
            border-radius: 10px;
            border: 1px solid rgba(178, 102, 255, 0.45);
            background: rgba(15, 8, 30, 0.92);
            color: #f5e8ff;
            font-family: 'Consolas', 'Fira Code', monospace;
            font-size: 13px;
            letter-spacing: 0.04em;
            padding: 8px 12px;
        }

        .preset-code-input:focus {
            outline: none;
            border-color: rgba(210, 150, 255, 0.85);
            box-shadow: 0 0 12px rgba(178, 102, 255, 0.35);
        }

        .preset-status {
            margin-top: 8px;
            font-size: 11px;
            min-height: 1.2em;
            color: #d8ccff;
        }

        .preset-status.success {
            color: #7df0b8;
        }

        .preset-status.error {
            color: #ff8fb3;
        }

        /* Champion Upgrade Section Styles */
        .champion-upgrade-section {
            flex: 1;
            min-width: 250px;
            padding: 15px;
            background: linear-gradient(145deg, rgba(40, 20, 60, 0.9), rgba(60, 30, 90, 0.8));
            border: 1px solid rgba(178, 102, 255, 0.3);
            border-radius: 10px;
            margin: 0 15px;
        }

        .upgrade-header h3 {
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 14px;
            color: var(--accent);
            margin: 0 0 5px 0;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .upgrade-header p {
            color: #ffddff;
            margin: 0 0 15px 0;
            font-size: 12px;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }

        .upgrade-card {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: rgba(30, 10, 50, 0.8);
            border: 1px solid rgba(178, 102, 255, 0.4);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upgrade-card:hover:not(.disabled) {
            background: rgba(50, 20, 80, 0.9);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .upgrade-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .upgrade-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .upgrade-content {
            flex: 1;
            min-width: 0;
        }

        .upgrade-title {
            font-weight: 600;
            color: #ffddff;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .upgrade-desc {
            font-size: 11px;
            color: #cccccc;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .upgrade-cost {
            font-size: 12px;
            color: #ffd700;
            font-weight: 500;
        }

        /* SKILL TREE - Portrait-oriented Icon Button System */
        .skill-track {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 26px;
            width: 100%;
        }

        .track-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        .skill-icon-button {
            position: relative;
            width: min(520px, 100%);
            min-height: 190px;
            cursor: pointer;
            border-radius: 16px;
            padding: 16px;
            display: flex;
            gap: 18px;
            align-items: stretch;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            border: 2px solid rgba(110, 70, 180, 0.6);
            background: radial-gradient(circle at 18% 22%, rgba(66, 18, 110, 0.95), rgba(24, 2, 40, 0.9));
            box-shadow: inset 0 0 18px rgba(122, 60, 190, 0.22);
        }

        .skill-icon-frame {
            flex: 0 0 clamp(160px, 48%, 220px);
            aspect-ratio: 3 / 4;
            border-radius: 14px;
            border: 1px solid rgba(202, 138, 255, 0.45);
            background: radial-gradient(circle at 40% 30%, rgba(120, 70, 200, 0.35), rgba(40, 10, 70, 0.4));
            box-shadow: inset 0 0 24px rgba(150, 80, 255, 0.35);
            display: grid;
            place-items: center;
            overflow: hidden;
        }

        .skill-icon-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease, filter 0.3s ease;
            border-radius: 12px;
        }

        .skill-icon-image.enhanced {
            filter: brightness(1.25) saturate(1.15) drop-shadow(0 0 12px rgba(255, 215, 0, 0.8));
        }

        .skill-info-table {
            flex: 1 1 50%;
            display: grid;
            gap: 10px;
            background: rgba(82, 34, 120, 0.32);
            border: 1px solid rgba(201, 146, 255, 0.32);
            border-radius: 14px;
            padding: 14px 18px;
        }

        .skill-info-row {
            display: grid;
            grid-template-columns: minmax(86px, 30%) 1fr;
            gap: 12px;
            align-items: start;
        }

        .skill-info-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #e6ccff;
            opacity: 0.82;
        }

        .skill-info-value {
            font-size: 12px;
            color: #f5e8ff;
            line-height: 1.4;
        }

        .skill-info-note {
            font-size: 11px;
            color: #ffb3f7;
            opacity: 0.8;
            border-top: 1px solid rgba(201, 146, 255, 0.28);
            padding-top: 8px;
            margin-top: 6px;
        }

        .skill-track-connector {
            width: 3px;
            height: 38px;
            border-radius: 6px;
            background: linear-gradient(180deg, rgba(216, 176, 255, 0.7) 0%, rgba(125, 82, 200, 0.9) 100%);
            box-shadow: 0 0 12px rgba(180, 120, 255, 0.45);
        }

        .skill-view-toggle {
            display: inline-flex;
            align-items: stretch;
            justify-content: center;
            gap: 6px;
            padding: 6px;
            border-radius: 999px;
            background: radial-gradient(circle at 20% 20%, rgba(90, 30, 160, 0.6), rgba(30, 10, 50, 0.8));
            border: 1px solid rgba(210, 165, 255, 0.45);
            box-shadow: 0 0 20px rgba(160, 100, 240, 0.28);
            width: fit-content;
            min-width: 0;
        }

        .skill-view-toggle button {
            border: 1px solid rgba(190, 150, 255, 0.22);
            background: linear-gradient(135deg, rgba(80, 30, 140, 0.55), rgba(40, 18, 82, 0.65));
            color: #d8ceff;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            padding: 10px 18px 12px;
            border-radius: 999px;
            cursor: pointer;
            transition: all 0.28s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            text-shadow: 0 0 10px rgba(90, 40, 160, 0.5);
            min-width: 150px;
        }

        .skill-view-badge {
            font-size: 10px;
            letter-spacing: 0.24em;
            color: rgba(255, 237, 255, 0.85);
            background: rgba(255, 255, 255, 0.12);
            padding: 3px 12px;
            border-radius: 999px;
            box-shadow: inset 0 0 12px rgba(220, 200, 255, 0.15);
        }

        .skill-view-label {
            font-size: 11px;
            letter-spacing: 0.08em;
            color: #f5edff;
            text-align: center;
            line-height: 1.3;
        }

        .skill-view-toggle button.active {
            background: linear-gradient(135deg, rgba(230, 200, 255, 0.95), rgba(150, 90, 255, 0.88));
            color: #1b1031;
            border-color: rgba(255, 235, 255, 0.75);
            box-shadow: 0 0 26px rgba(210, 170, 255, 0.6);
            transform: translateY(-2px) scale(1.015);
            text-shadow: 0 0 12px rgba(255, 240, 255, 0.8);
        }

        .skill-view-toggle button.active .skill-view-badge {
            background: rgba(255, 255, 255, 0.9);
            color: #32164e;
            box-shadow: inset 0 0 18px rgba(255, 220, 255, 0.7);
        }

        .skill-view-toggle button:not(.active):hover {
            border-color: rgba(210, 170, 255, 0.55);
            box-shadow: 0 0 20px rgba(150, 110, 230, 0.45);
            color: #efe3ff;
        }

        .skill-view-toggle button:focus-visible {
            outline: 2px solid rgba(255, 215, 0, 0.7);
            outline-offset: 2px;
        }

        .skill-grid[data-active-view="main"] .view-signature {
            display: none;
        }

        .skill-grid[data-active-view="main"] .view-main {
            display: flex;
        }

        .skill-grid[data-active-view="signature"] .view-main {
            display: none;
        }

        .skill-grid[data-active-view="signature"] .view-signature {
            display: flex;
        }

        .skill-status-heading {
            font-size: 16px;
            font-weight: 700;
            color: #f8d87f;
            letter-spacing: 0.08em;
        }

        .skill-status-heading.readonly {
            color: #ff9c6b;
        }

        .skill-status-body {
            font-size: 13px;
            color: #d8c9ff;
            margin-top: 6px;
            line-height: 1.4;
        }

        .skill-status-line {
            font-size: 12px;
            color: #b8a6ff;
            margin-top: 6px;
        }

        .skill-status-line strong {
            color: #f5e8ff;
        }

        .skill-hover-title {
            font-size: 15px;
            font-weight: 600;
            color: #ffe39f;
            letter-spacing: 0.06em;
        }

        .skill-hover-body {
            font-size: 13px;
            color: #ded2ff;
            margin-top: 6px;
            line-height: 1.5;
        }

        .skill-hover-note {
            font-size: 11px;
            color: #94ffd1;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
        }

        /* SKILL ICON BUTTON STATES */
        .skill-icon-button.available {
            border-color: rgba(102, 255, 178, 0.7);
            box-shadow: 0 0 24px rgba(102, 255, 178, 0.35);
        }

        .skill-icon-button.available .skill-info-table {
            border-color: rgba(120, 255, 210, 0.55);
            box-shadow: inset 0 0 18px rgba(120, 255, 210, 0.18);
        }

        .skill-icon-button.available:hover {
            border-color: rgba(140, 255, 210, 0.85);
            box-shadow: 0 0 32px rgba(120, 255, 200, 0.5);
            transform: translateY(-4px);
        }

        .skill-icon-button.available:hover .skill-icon-image {
            filter: brightness(1.2) saturate(1.1);
            transform: scale(1.02);
        }

        .skill-icon-button.active {
            border-color: rgba(255, 215, 0, 0.95);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.16), rgba(140, 60, 200, 0.24));
            box-shadow: 0 0 26px rgba(255, 215, 0, 0.7), inset 0 0 22px rgba(255, 255, 255, 0.12);
            animation: activeIconGlow 3s ease-in-out infinite;
        }

        .skill-icon-button.active .skill-icon-frame {
            border-color: rgba(255, 215, 0, 0.85);
            box-shadow: inset 0 0 26px rgba(255, 215, 0, 0.35);
        }

        .skill-icon-button.active .skill-icon-image {
            filter: brightness(1.35) saturate(1.2) drop-shadow(0 0 16px rgba(255, 215, 0, 0.85));
        }

        .skill-icon-button.active .skill-info-table {
            border-color: rgba(255, 220, 120, 0.65);
            box-shadow: inset 0 0 24px rgba(255, 220, 120, 0.24);
        }

        .skill-icon-button.locked {
            border-color: rgba(70, 40, 120, 0.65);
            opacity: 0.65;
            cursor: not-allowed;
            filter: grayscale(0.4);
        }

        .skill-icon-button.locked .skill-info-table {
            background: rgba(38, 14, 68, 0.5);
            border-color: rgba(90, 50, 130, 0.35);
        }

        .skill-icon-button.locked:hover {
            transform: none;
            box-shadow: none;
        }

        /* CLASS ABILITY TRACK STYLING */
        .class-ability-track {
            position: relative;
            margin-left: 40px;
            padding: 20px;
            border-left: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 0 12px 12px 0;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(135, 206, 235, 0.05));
        }

        .class-ability-track .track-title {
            color: #FFD700;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        .class-ability-track .skill-icon-button+.skill-icon-button {
            margin-top: 18px;
        }

        .class-ability-solo {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6) !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.2)) !important;
        }

        .class-ability-solo.locked {
            opacity: 0.85;
            filter: none;
        }

        .class-ability-solo .skill-info-table {
            border-color: rgba(255, 223, 120, 0.8) !important;
            box-shadow: inset 0 0 26px rgba(255, 220, 130, 0.32) !important;
            background: rgba(80, 40, 0, 0.28);
        }

        .class-ability-solo:hover {
            border-color: #FFF700 !important;
            box-shadow: 0 0 36px rgba(255, 215, 0, 0.75) !important;
            transform: translateY(-5px) scale(1.04) !important;
        }

        .cross-ability {
            border-color: rgba(102, 255, 178, 0.6);
            box-shadow: 0 0 18px rgba(102, 255, 178, 0.3);
        }

        .cross-ability.available {
            border-color: rgba(125, 255, 200, 0.9);
            box-shadow: 0 0 28px rgba(125, 255, 200, 0.6);
        }

        .cross-ability .skill-info-table {
            border-color: rgba(120, 255, 210, 0.6);
        }

        @media (max-width: 640px) {
            .skill-row {
                gap: 24px;
            }

            .skill-icon-button {
                flex-direction: column;
                align-items: stretch;
                min-height: auto;
            }

            .skill-icon-frame {
                flex: 0 0 auto;
                width: 100%;
                max-width: 260px;
                margin: 0 auto 12px;
            }

            .skill-info-table {
                padding: 14px;
            }

            .skill-info-row {
                grid-template-columns: 1fr;
                gap: 6px;
            }

            .skill-info-label {
                font-size: 10px;
                letter-spacing: 0.12em;
            }

            .skill-track-connector {
                display: none;
            }

            .skill-view-toggle {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                padding: 8px;
            }

            .skill-view-toggle button {
                min-width: 0;
                width: 100%;
                padding: 10px 12px 12px;
            }

            .skill-view-badge {
                font-size: 9px;
                letter-spacing: 0.18em;
                padding: 3px 10px;
            }

            .skill-view-label {
                font-size: 10px;
                letter-spacing: 0.06em;
            }
        }

        @media (max-width: 700px) {
            .panel {
                width: min(92vw, 440px);
                max-height: 90vh;
                padding: 22px 16px 18px;
                border-radius: 14px;
            }

            .panel.panel-floating-close {
                padding-top: 60px;
            }

            .close-btn {
                top: 10px;
                right: 12px;
                font-size: 26px;
                width: 42px;
                height: 42px;
            }
        }

        @media (max-width: 480px) {
            .panel {
                width: 94vw;
                padding: 18px 12px 16px;
            }

            .panel.panel-floating-close {
                padding-top: 54px;
            }

            .close-btn {
                right: 10px;
                width: 44px;
                height: 44px;
                font-size: 28px;
            }
        }

        .skill-grid[data-active-view="signature"] .class-ability-track {
            margin-left: 0;
        }

        /* BEAUTIFUL GLOW ANIMATIONS */
        @keyframes activeIconGlow {
            0% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.1);
            }

            50% {
                box-shadow: 0 0 35px rgba(255, 215, 0, 1.0), inset 0 0 25px rgba(255, 255, 255, 0.2), 0 0 50px rgba(135, 206, 235, 0.3);
            }

            100% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.1);
            }
        }

        /* Old skill node classes for compatibility */

        /* Beautiful Marble/Lightning Animations */
        @keyframes marbleSwirl {
            0% {
                background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%);
            }

            25% {
                background: linear-gradient(225deg, #e6e6fa 0%, #f5f5dc 30%, #f8f8ff 60%, #dcdcdc 100%);
            }

            50% {
                background: linear-gradient(315deg, #dcdcdc 0%, #f8f8ff 30%, #f5f5dc 60%, #e6e6fa 100%);
            }

            75% {
                background: linear-gradient(45deg, #f5f5dc 0%, #dcdcdc 30%, #e6e6fa 60%, #f8f8ff 100%);
            }

            100% {
                background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%);
            }
        }

        @keyframes lightningPulse {
            0% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), inset 0 0 8px rgba(255, 255, 255, 0.4);
            }

            50% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), inset 0 0 12px rgba(255, 255, 255, 0.6), 0 0 25px rgba(135, 206, 235, 0.4);
            }

            100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), inset 0 0 8px rgba(255, 255, 255, 0.4);
            }
        }

        .skill-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .skill-node.active,
        .skill-combo-node.active {
            border-color: #FFD700;
            background: #2a2a4e;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        .skill-node.locked,
        .skill-combo-node.locked {
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skill-combo-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .skill-description {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 18px auto 0;
            text-align: center;
            min-height: 40px;
            color: #ffddff;
            font-size: 12px;
            max-width: 680px;
        }

        .ability-hint {
            font-size: 10px;
            color: #87CEEB;
            text-align: center;
            margin-top: 6px;
            font-style: italic;
            text-shadow: 0 0 4px rgba(135, 206, 235, 0.5);
        }

        .ability-icon {
            font-size: 12px;
            margin: 0 2px;
            display: inline-block;
            animation: pulse-glow 2s infinite;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }

        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }

        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }

        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn {
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.5;
            transition: opacity 0.3s ease-in-out;
        }

        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }

        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }

        #bottom-right-controls>.fixed-btn {
            position: static;
        }

        #menuBtn,
        #fsEnterBtn,
        #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn,
        #shopBtnHUD {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }

        #shopBtn {
            opacity: 0.9;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 220, 120, 0.8);
            animation: shopIdleGlow 3.2s ease-in-out infinite;
        }

        #shopBtn:hover {
            opacity: 1;
        }

        #shopBtn.mech-forge-pulse {
            animation: mechForgePulse 1.2s ease-in-out infinite;
            box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25);
        }

        #shopBtn.mech-forge-pulse::after {
            content: "";
            position: absolute;
            inset: -6px;
            border-radius: 18px;
            border: 2px solid rgba(255, 215, 0, 0.65);
            pointer-events: none;
            animation: mechForgeRing 1.2s ease-in-out infinite;
        }

        #shopBtnHUD.mech-forge-pulse {
            animation: mechForgePulse 1.2s ease-in-out infinite;
            box-shadow: 0 0 16px rgba(255, 215, 0, 0.35), 0 0 28px rgba(255, 140, 0, 0.18);
        }

        #pauseBtn {
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }

        .input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 10px;
            background: #17001f;
            color: #ffddff;
            border: 1px solid var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            box-sizing: border-box;
        }

        #abilityBar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 6;
            pointer-events: auto;
        }

        #abilityBar .ability-btn {
            position: relative;
            bottom: auto;
            left: auto;
            right: auto;
            top: auto;
            min-width: 150px;
            padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }

        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }

        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }

        .shop-item-attack {
            border-color: #00bfff;
        }

        .shop-item-health {
            border-color: #00ff00;
        }

        .shop-item-utility {
            border-color: #ffd700;
        }

        .shop-item-champion {
            border-color: #b07bff;
        }

        @keyframes pulse-glow {
            0% {
                box-shadow: 0 0 15px rgba(102, 255, 178, .5);
            }

            50% {
                box-shadow: 0 0 35px rgba(102, 255, 178, 1);
            }

            100% {
                box-shadow: 0 0 15px rgba(102, 255, 178, .5);
            }
        }

        @keyframes mechForgePulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25);
            }

            50% {
                transform: scale(1.03);
                box-shadow: 0 0 28px rgba(255, 215, 0, 0.75), 0 0 45px rgba(255, 140, 0, 0.35);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25);
            }
        }

        @keyframes mechForgeRing {
            0% {
                transform: scale(0.92);
                opacity: 0.9;
            }

            70% {
                transform: scale(1.1);
                opacity: 0.3;
            }

            100% {
                transform: scale(1.15);
                opacity: 0;
            }
        }

        @keyframes shopIdleGlow {
            0% {
                box-shadow: 0 0 6px rgba(255, 215, 0, 0.35);
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.65);
            }

            100% {
                box-shadow: 0 0 6px rgba(255, 215, 0, 0.35);
            }
        }

        @keyframes pulse-glow-ability {
            0% {
                box-shadow: 0 0 10px rgba(178, 102, 255, .5);
            }

            50% {
                box-shadow: 0 0 20px rgba(178, 102, 255, .8);
            }

            100% {
                box-shadow: 0 0 10px rgba(178, 102, 255, .5);
            }
        }

        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        .shop-spotlight {
            position: fixed;
            right: 20px;
            bottom: 95px;
            z-index: 6;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            pointer-events: none;
        }

        .shop-spotlight__badge {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 105, 180, 0.95));
            color: #1d0030;
            font-weight: 700;
            letter-spacing: 0.05em;
            font-size: 13px;
            padding: 8px 16px;
            border-radius: 999px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.45);
            animation: spotlightBadgePulse 2.4s ease-in-out infinite;
        }

        .shop-spotlight__arrow {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 14px solid rgba(255, 215, 0, 0.85);
            filter: drop-shadow(0 0 12px rgba(255, 215, 0, 0.45));
            animation: spotlightArrowBob 1.6s ease-in-out infinite;
        }

        @keyframes spotlightBadgePulse {
            0% {
                transform: translateY(0);
                opacity: 0.85;
            }

            50% {
                transform: translateY(-3px);
                opacity: 1;
            }

            100% {
                transform: translateY(0);
                opacity: 0.85;
            }
        }

        @keyframes spotlightArrowBob {
            0% {
                transform: translateY(0) scale(1);
            }

            50% {
                transform: translateY(-4px) scale(1.05);
            }

            100% {
                transform: translateY(0) scale(1);
            }
        }

        @media (max-width: 640px) {
            .shop-spotlight {
                right: 50%;
                transform: translateX(50%);
                bottom: 110px;
                align-items: center;
            }
        }

        @media (max-width:820px) {
            canvas {
                width: 100vw;
                height: auto;
                max-height: 75vh;
                border-radius: 8px
            }

            .panel {
                width: min(500px, 94vw)
            }

            .stage {
                width: 98vw
            }

            #belowBoard {
                width: 98vw
            }
        }

        /* Purple gradient classes for different brightness levels */
        .bright {
            color: #e6ccff;
            text-shadow: 0 0 5px #cc99ff, 0 0 10px #cc99ff;
        }

        .medium {
            color: #b366ff;
            text-shadow: 0 0 3px #9933ff;
        }

        .dim {
            color: #6600cc;
            text-shadow: 0 0 2px #6600cc;
        }

        .faded {
            color: #330066;
            opacity: 0.7;
        }

        .very-faded {
            color: #1a0033;
            opacity: 0.4;
        }

        /* Teleport Tutorial Popup */
        #teleportTutorialPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(102, 0, 204, 0.2) 100%);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(204, 153, 255, 0.4);
        }

        #teleportTutorialPanel h2 {
            color: var(--accent);
            font-family: 'Orbitron';
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--accent);
        }

        .teleport-instruction {
            font-size: 18px;
            color: #ffddff;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .teleport-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 5px var(--accent));
        }

        /* --- MOBILE JOYSTICK & BUTTON CONTROLS --- */
        .mobile-control {
            position: fixed;
            z-index: 20;
            opacity: 0.6;
            display: none;
            /* Hidden by default */
        }

        body.mobile-controls-active .mobile-control {
            display: block;
            /* Shown when body class is active */
        }

        #joystick-container {
            bottom: 90px;
            left: 45px;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(50, 0, 70, 0.5);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
        }

        #joystick-stick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ffddff, var(--accent));
            border-radius: 50%;
            pointer-events: none;
            /* Pass touches through to the base */
        }

        #ability-button-container {
            bottom: 100px;
            right: 70px;
        }

        #ability-button {
            width: 90px;
            height: 90px;
            background: rgba(150, 80, 255, 0.3);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(178, 102, 255, .5);
        }

        #ability-icon {
            width: 70px;
            height: 70px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            filter: drop-shadow(0 0 5px white);
        }

        /* --- TOGGLE SWITCH IN UPGRADE HANGAR --- */
        .mobile-toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #330044;
            border: 1px solid var(--accent);
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--accent2);
        }

        input:checked+.slider:before {
            transform: translateX(22px);
        }
    </style>
</head>

<body>
    <!-- Asset Loading Screen DISABLED FOR PERFORMANCE TESTING -->
    <div id="loadingScreen" style="
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2a 50%, #0a0a1a 100%); 
        display: none; 
        flex-direction: column; 
        align-items: center; 
        justify-content: center; 
        z-index: 9999;
        font-family: 'Orbitron', monospace;
        color: #b266ff;
    ">
        <div style="text-align: center; margin-bottom: 40px;">
            <h1
                style="font-size: 3em; margin: 0; text-shadow: 0 0 20px #b266ff; animation: pulse 2s ease-in-out infinite;">
                âš¡ VOID SKIES âš¡
            </h1>
            <p style="font-size: 1.2em; margin: 10px 0; color: #cc99ff;">
                Initializing Combat Systems...
            </p>
        </div>

        <div style="width: 400px; max-width: 80vw; margin-bottom: 20px;">
            <div style="background: rgba(0,0,0,0.5); border: 2px solid #b266ff; border-radius: 10px; padding: 4px;">
                <div id="loadingBar" style="
                    height: 20px; 
                    background: linear-gradient(90deg, #b266ff, #7a49cc); 
                    border-radius: 6px; 
                    width: 0%; 
                    transition: width 0.3s ease;
                    box-shadow: 0 0 10px #b266ff;
                "></div>
            </div>
            <div id="loadingText" style="text-align: center; margin-top: 10px; font-size: 0.9em; color: #cc99ff;">
                Loading Assets... 0%
            </div>
        </div>

        <div id="loadingDetails" style="
            font-size: 0.8em; 
            color: #8866bb; 
            text-align: center; 
            min-height: 20px;
        ">
            Scanning combat protocols...
        </div>

        <style>
            @keyframes pulse {

                0%,
                100% {
                    text-shadow: 0 0 20px #b266ff;
                }

                50% {
                    text-shadow: 0 0 30px #b266ff, 0 0 40px #b266ff;
                }
            }
        </style>
    </div>

    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide">
                        <div class="hud-title">â—¢ SYSTEMS ONLINE â—£</div>
                        <div id="powerupList"></div>
                    </div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card">
                            <div class="hud-title">â—¢ VOID SKIES â—£</div>
                            <div style="text-align:center">
                                SCORE <b id="scoreNum">0</b> â€¢ Gold ðŸ’° <b id="goldNum"
                                    style="color:#FFD700;font-size:1.2em">0</b>
                            </div>
                        </div>
                        <div id="hudPilotContent" class="hud-card">
                            <div class="hud-title" id="pilotTitle">â—¢ UNIDENTIFIED â—£</div>
                            <div style="display:flex;justify-content:space-between;font-size:10px;margin:4px 0 6px 0;">
                                <div>WAVE <b id="waveNum">1</b></div>
                                <div>KILLS <b id="killsNum">0</b></div>
                                <div>LEVEL <b id="levelNum">1</b></div>
                            </div>
                            <div class="bar" id="hpBar"><span id="hpBarFill" style="width:100%"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="hpText">HP: 100 / 100
                            </div>
                            <div class="bar" id="beefShieldBar" style="margin-top:2px;display:none"><span
                                    id="beefShieldBarFill"
                                    style="background:linear-gradient(90deg,#ff8c00,#ff4500)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="beefShieldText"></div>
                            <div class="bar" id="shieldBar" style="margin-top:2px;display:none"><span id="shieldBarFill"
                                    style="background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="shieldText"></div>
                        </div>
                        <div id="hudBossContent" class="hud-card hide">
                            <div class="hud-title" id="bossTitle">âš¡ BOSS âš¡</div>
                            <div class="bar"><span id="bossBarFill" style="width:100%"></span></div>
                        </div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide">
                        <div class="hud-title">â—¢ EQUIPMENT â—£</div>
                        <div id="equipmentList"></div>
                    </div>

                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <table
                        style="font-size:10px; color:var(--fg); background:rgba(0,0,0,0.7); padding:8px; border-radius:8px; border-spacing:8px 2px;">
                        <tr>
                            <td>v3.8.0</td>
                            <td>FPS:</td>
                            <td><span id="fps">â€”</span></td>
                        </tr>

                    </table>
                </div>

                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">ðŸš€ PILOT LOST ðŸš€</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span
                                id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <!-- <button id="storyBtn" type="button">i</button> -->
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">Cybernetic heavy assault unit with adaptive bio-armor that
                                    responds to hostile engagement. Neural implants trigger reflexive counterstrike
                                    protocols when threatened.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN">
                                </div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">Former corporate military contractor with black-market ordnance
                                    mods. Tactical AI systems provide precision strike capabilities and explosive
                                    payload optimization.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="voidmancer">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER">
                                </div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">Quantum-phase enhanced operative with experimental void-fold
                                    technology. Neural interfaces allow instantaneous spatial displacement through
                                    dimensional rifts.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="subclassPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="subclassPanel">â† BACK</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                        </div>

                    </div>
                    <div id="storyPanel" class="panel hide">
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the
                            plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                            Mammalian life developed specialized spacecraft to venture within and colonize the resources
                            of the primitive creatures.<br><br>
                            The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">ðŸ’€ CALLSIGN ðŸ’€</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button
                                id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">ðŸ† Aces of the Void ðŸ†</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);">âš¡ AUGMENTATION PROTOCOL âš¡</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="shopPanel">â† BACK</button>
                        <button type="button" class="close-btn" id="closeShopTopBtn">Ã—</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">PILOT SYSTEMS UPGRADE CATALOGUE</h2>
                        <p style="color:#ffddff">Gold ðŸ’° <span id="shopgold"
                                style="color:#FFD700;font-size:1.2em">0</span></p>
                        <div class="shop-control-bar">
                            <div class="shop-control-block">
                                <div class="shop-control-copy">
                                    <div class="shop-control-title">Mobile Controls</div>
                                    <div class="shop-control-desc">Toggle the on-screen joystick and ability key for
                                        touch devices.</div>
                                </div>
                                <label class="switch">
                                    <input type="checkbox" id="shopMobileToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="shop-control-block">
                                <div class="shop-control-copy">
                                    <div class="shop-control-title">Auto-Buy Logistics</div>
                                    <div class="shop-control-desc">Let hangar personnel resupply core systems between
                                        waves.</div>
                                    <div id="autoForgeStatusLabel" class="shop-control-status"></div>
                                </div>
                                <label class="switch">
                                    <input type="checkbox" id="shopAutoToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <button id="shopGameMenuBtn" class="btn shop-advanced-btn" type="button">Game Menu</button>
                        </div>

                        <div class="shop-view-tabs">
                            <button id="shopTabPowerups" class="shop-view-btn active" type="button">Powerup
                                Loadout</button>
                            <button id="shopTabUpgrades" class="shop-view-btn" type="button">Upgrade
                                Catalog</button>
                        </div>

                        <div id="shopPowerupView" class="shop-view"></div>
                        <div id="shopUpgradeView" class="shop-view hide">
                            <div id="shopGrid" class="grid"></div>
                        </div>
                        <div class="row" style="justify-content:center;margin-top:10px;gap:10px">
                            <button id="openChampionDressingRoom" class="btn btn-primary hide" type="button">PRIMORDIAL
                                SOLDIER LABORATORY</button>
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="mechForgeMenuPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="mechForgeMenuPanel">â† BACK</button>
                        <button type="button" class="close-btn" id="closeMechForgeMenuBtn">Ã—</button>
                        <div class="forge-menu-header">
                            <h2 class="forge-menu-title-large">GAME MENU</h2>
                            <p class="forge-menu-subtitle">Configure mission subsystems and references.</p>
                        </div>

                        <div class="forge-menu-section">
                            <div class="mobile-toggle-container forge-menu-toggle">
                                <div class="forge-menu-toggle-copy">
                                    <div class="forge-menu-toggle-title">Upgrade Alerts</div>
                                    <div class="forge-menu-toggle-desc">Display upgrade prompts and reminders between
                                        waves.</div>
                                </div>
                                <label class="switch">
                                    <input type="checkbox" id="shopTutorialToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>

                        <div class="forge-menu-section">
                            <div class="forge-menu-section-head">
                                <div>
                                    <div class="forge-menu-title">Auto-Buy Doctrine</div>
                                    <div class="forge-menu-section-hint">Choose a logistics profile to steer procurement
                                        priorities whenever Auto-Buy takes over.</div>
                                </div>
                            </div>
                            <div id="autoForgeProfileGrid" class="forge-profile-grid" role="group"
                                aria-label="Auto-buy doctrines"></div>
                            <div id="autoForgeProfileSummary" class="forge-profile-summary"></div>
                        </div>

                        <div class="forge-menu-section">
                            <div class="forge-menu-grid">
                                <button id="openPrimordialLabFromMenu" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸ§¬ PRIMORDIAL SOLDIER LABORATORY ðŸ§¬</span>
                                    <div class="forge-menu-desc">Refit champion modules, cadence cores, escort protocols, and plating.</div>
                                    <div class="forge-menu-meta" id="championQuickStatus"></div>
                                    <div class="forge-menu-meta">Champion access unlocks once you bind the Shadow Sigil.</div>
                                </button>
                                <button id="openCharacterSheet" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸ“Š CHARACTER STATS &amp; INFO</span>
                                    <div class="forge-menu-desc">Review pilot stats, perks, and mission intel.</div>
                                    <div class="forge-menu-meta">Cross-check loadout bonuses before launch.</div>
                                </button>
                                <button id="openSkillTreeReadonly" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸŒŸ SKILL TREE</span>
                                    <div class="forge-menu-desc">Select a specialization first.</div>
                                </button>
                                <button id="openShopTutorial" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸŽ“ BEGINNER TUTORIAL</span>
                                    <div class="forge-menu-desc">Help learning the basics of the game.</div>
                                </button>
                            </div>
                        </div>

                        <p class="forge-menu-footnote">Combat remains paused while this terminal is open.</p>

                        <div class="row" style="justify-content:center;margin-top:24px">
                            <button id="closeMechForgeMenu" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="characterSheetPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="characterSheetPanel">â† BACK</button>
                        <button type="button" class="close-btn" id="closeCharacterSheetBtn">Ã—</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">ðŸ“Š CHARACTER SHEET</h2>
                        <div id="characterSheetBody" class="character-sheet-body" aria-live="polite"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeCharacterSheet" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="teleportTutorialPanel" class="panel hide">
                        <h2>âš¡ VOID-FOLD PROTOCOL âš¡</h2>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">ðŸ–±ï¸</span>
                            <span>Right-click to teleport</span>
                        </div>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">ðŸ‘†ðŸ‘†</span>
                            <span>Double-tap to teleport (mobile)</span>
                        </div>
                        <div style="margin-top: 30px;">
                            <p style="color: #ccaaff; font-size: 14px; margin-bottom: 20px;">
                                Quantum displacement damages enemies at origin point.<br>
                                Use strategically to escape danger and deal damage.
                            </p>
                            <button id="closeTeleportTutorial" class="btn" type="button">GOT IT</button>
                        </div>
                    </div>
                    <div id="shopTutorialPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">UPGRADE HANGAR</h2>
                        <p style="color:#ffddff;font-size:14px;line-height:1.5;margin-bottom:14px;">
                            Spend stored gold in the hangar to refit weapons, reinforce hull systems, and restock
                            support gear.
                        </p>
                        <ul style="color:#cfe9ff;font-size:12px;line-height:1.6;padding-left:20px;margin:0 0 18px 0;">
                            <li>Tap an upgrade card to execute the purchase immediately.</li>
                            <li>Enable Auto-Buy to let logistics maintain essentials.</li>
                            <li>Glowing cards flag critical needs such as repairs or shields.</li>
                        </ul>
                        <div class="row" style="justify-content:center;gap:10px;margin-top:10px;flex-wrap:wrap;">
                            <button id="shopTutorialOpen" class="btn" type="button">OPEN UPGRADE HANGAR</button>
                            <button id="shopTutorialSkip" class="btn secondary" type="button">LATER</button>
                        </div>
                        <label
                            style="display:flex;align-items:center;justify-content:center;gap:8px;margin-top:18px;color:#d2baff;font-size:12px;">
                            <input id="shopTutorialDontShow" type="checkbox" style="accent-color:#ffd700;">
                            Don't show this spotlight again
                        </label>
                    </div>
                </div>

                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">SHIELD PULSE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>âš¡ Aces of the Void âš¡</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>

            <!-- Primordial Soldier Laboratory Panel -->
            <div id="championDressingRoom" class="panel panel-floating-close hide">
                <button type="button" class="panel-back-btn hide" data-panel-id="championDressingRoom">â† BACK</button>
                <button type="button" class="close-btn" id="closeDressingRoom">Ã—</button>
                <div class="dressing-room-header">
                    <h2 style="font-family:'Orbitron';color:var(--accent)">PRIMORDIAL SOLDIER LABORATORY</h2>
                    <p style="color:#ffddff;margin:0 0 15px 0">Build and customize your champion guardian with advanced
                        modules and enhancements</p>
                </div>

                <div class="dressing-room-content">
                    <!-- Champion Preview Area -->
                    <div class="champion-preview-section">
                        <div class="preview-viewport">
                            <canvas id="championPreviewCanvas" width="200" height="200"></canvas>
                            <div class="preview-overlay">
                                <div class="champion-name" id="previewChampionName">SHADOW GUARDIAN</div>
                                <div class="champion-class" id="previewChampionClass"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Champion Builder Section -->
                    <div class="champion-builder-section">
                        <div class="builder-header">
                            <h3>Guardian Configuration</h3>
                        </div>
                        <div class="builder-guidance">
                            <p><strong>Attack Modules</strong> are mutually exclusive loadouts. Equipping one replaces
                                the Starfall Salvo until you switch back.</p>
                            <p><strong>Cadence Cores</strong> unlock in tiers. Selecting a higher tier automatically
                                includes the timing bonuses from earlier cores.</p>
                            <p><strong>Minion Protocols</strong> swap escort behaviors. Only one protocol runs at a
                                time, so choose the pattern you want active.</p>
                        </div>

                        <div class="builder-options">
                            <div class="builder-option">
                                <label for="attackModuleSelect">Attack Module</label>
                                <p class="builder-option-desc">Primary weapon pattern for your guardian. Equipping one
                                    replaces the Starfall Salvo until you switch back.</p>
                                <select id="attackModuleSelect" class="builder-select">
                                    <option value="default">Default: Starfall Salvo</option>
                                </select>
                                <div class="builder-option-detail" id="attackModuleDetail"></div>
                            </div>

                            <div class="builder-option">
                                <label for="cadenceSelect">Cadence Core</label>
                                <p class="builder-option-desc">Timing core tiers stack automatically. Higher selections
                                    include the bonuses from earlier cadence cores.</p>
                                <select id="cadenceSelect" class="builder-select">
                                    <option value="0">Default: Baseline Cadence</option>
                                </select>
                                <div class="builder-option-detail" id="cadenceDetail"></div>
                            </div>

                            <div class="builder-option">
                                <label for="protocolSelect">Minion Protocol</label>
                                <p class="builder-option-desc">Choose the escort formation and behavior your minions
                                    will maintain while deployed.</p>
                                <select id="protocolSelect" class="builder-select">
                                    <option value="0">Default: Escort Drones</option>
                                </select>
                                <div class="builder-option-detail" id="protocolDetail"></div>
                            </div>

                            <div class="builder-option">
                                <label for="skinSelect">Plating Skin</label>
                                <p class="builder-option-desc">Cosmetic plating for your champion chassis. Skins do not
                                    alter combat stats.</p>
                                <select id="skinSelect" class="builder-select">
                                    <option value="default">Default: Void Vanguard</option>
                                </select>
                                <div class="builder-option-detail" id="skinDetail"></div>
                            </div>
                        </div>

                        <div class="builder-actions">
                            <button id="applyConfigurationBtn" class="btn builder-action-btn builder-action-apply">Apply
                                Loadout</button>
                            <button id="resetConfigurationBtn" class="btn builder-action-btn builder-action-reset">Reset
                                to Current</button>
                        </div>

                        <div class="champion-preset-section">
                            <h3>Permanent Config Codes</h3>
                            <p>Generate a code from your current champion or load one to restore a saved build.</p>
                            <div class="preset-actions">
                                <button id="generateChampionPresetBtn" class="btn builder-action-btn builder-action-apply" type="button">Generate Code</button>
                                <button id="copyChampionPresetBtn" class="btn builder-action-btn" type="button">Copy to Clipboard</button>
                            </div>
                            <textarea id="championPresetCodeOutput" class="preset-code-output" rows="2" readonly spellcheck="false" placeholder="Your champion code will appear here"></textarea>
                            <div class="preset-import">
                                <input id="championPresetCodeInput" class="preset-code-input" type="text" placeholder="Enter champion code" spellcheck="false" autocomplete="off" />
                                <button id="applyChampionPresetBtn" class="btn builder-action-btn builder-action-apply" type="button">Load Code</button>
                            </div>
                            <div id="championPresetStatus" class="preset-status"></div>
                        </div>
                    </div>

                    <!-- Champion Upgrade Shop Section -->
                    <div class="champion-upgrade-section">
                        <div class="upgrade-header">
                            <h3>Upgrade Laboratory</h3>
                            <p>Purchase new modules and enhancements for your champion</p>
                        </div>

                        <div id="championUpgradeGrid" class="upgrade-grid">
                            <!-- Champion upgrades will be populated by JS -->
                        </div>
                    </div>

                    <!-- Champion Stats Panel -->
                    <div class="champion-stats-section">
                        <div class="stats-header">
                            <h3>Combat Profile</h3>
                        </div>

                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Health</span>
                                <span class="stat-value" id="championHealthStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Shield</span>
                                <span class="stat-value" id="championShieldStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Attack Power</span>
                                <span class="stat-value" id="championAttackStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Fire Rate</span>
                                <span class="stat-value" id="championFireRateStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Level</span>
                                <span class="stat-value" id="championLevelStat">1</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Experience</span>
                                <span class="stat-value" id="championExpStat">0/100</span>
                            </div>
                        </div>

                        <div class="loadout-section">
                            <h4>Loadout Highlights</h4>
                            <div class="loadout-list">
                                <div class="loadout-item">
                                    <span class="loadout-label">Skin</span>
                                    <span class="loadout-value" id="championSkinLabel">Void Vanguard</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Attack Module</span>
                                    <span class="loadout-value" id="championAttackModuleLabel">Starfall Salvo</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Cadence Core</span>
                                    <span class="loadout-value" id="championCadenceLabel">Baseline Cadence</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Minion Protocol</span>
                                    <span class="loadout-value" id="championProtocolLabel">Escort Drones</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Signature</span>
                                    <span class="loadout-value" id="championSignatureLabel">Adaptive Void
                                        Sentinel</span>
                                </div>
                            </div>
                        </div>

                        <div class="attack-types-section">
                            <h4>Attack Capabilities</h4>
                            <div id="championAttackTypesList" class="attack-types-list">
                                <!-- Attack types will be populated by JS -->
                            </div>
                        </div>

                        <div class="upgrade-preview-section">
                            <h4>Active Upgrades</h4>
                            <div id="championUpgradesList" class="upgrades-list">
                                <!-- Active upgrades will be populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>

                <div class="dressing-room-footer">
                    <button id="closeDressingRoomBtn" class="btn" type="button">EXIT LABORATORY</button>
                    <button id="openShopFromDressingRoom" class="btn btn-primary" type="button">UPGRADE HANGAR</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Upgrade Popup Panel -->
    <div id="upgradePopupPanel" class="panel panel-floating-close hide">
        <div style="text-align: center; padding: 20px;">
            <div id="upgradePopupIcon" style="font-size: 48px; margin-bottom: 15px;">âš¡</div>
            <h2 id="upgradePopupTitle" style="font-family:'Orbitron';color:var(--accent);margin:0 0 10px 0;">UPGRADE ACQUIRED</h2>
            <p id="upgradePopupDesc" style="color:#ffddff;font-size:14px;line-height:1.5;margin-bottom:20px;">
                Enhancement applied to your systems.
            </p>
            <div id="upgradePopupTier" style="color:#b19cd9;font-size:12px;margin-bottom:20px;text-transform:uppercase;letter-spacing:1px;"></div>
            <button id="upgradePopupOkBtn" class="btn btn-primary" type="button">ACKNOWLEDGED</button>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>
    <audio id="audioCharge" src="charge.m4a" preload="auto"></audio>
    <audio id="audioBeefCharge" src="beefcharge.m4a" preload="auto"></audio>
    <audio id="audioEpicHorn" src="epichorntrimmed.m4a" preload="auto"></audio>
    <audio id="audioCluster" src="cluster.mp3" preload="auto"></audio>
    <audio id="audioThunder" src="thunder.mp3" preload="auto"></audio>
    <audio id="audioShaoKahn" src="shao_kahn.m4a" preload="auto"></audio>
    <audio id="audioStarGun" src="stargun.m4a" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">UPGRADE HANGAR</button>
        <button id="menuBtn" class="fixed-btn" type="button">ðŸ† TOP PILOTS</button>
    </div>
    <div id="shopSpotlight" class="shop-spotlight hide" aria-live="polite">
        <div id="shopSpotlightMessage" class="shop-spotlight__badge">Upgrade Hangar online. Deploy credits as needed.
        </div>
        <div class="shop-spotlight__arrow"></div>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

    <div id="joystick-container" class="mobile-control">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
    <div id="ability-button-container" class="mobile-control">
        <div id="ability-button">
            <div id="ability-icon"></div>
        </div>
    </div>

    <script>
        (() => {
            // --- CORE SETUP ---
            const W = 960, H = 540;
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            const withAlpha = (color, alpha) => {
                if (!color) return `rgba(255,255,255,${alpha})`;
                const normAlpha = Math.max(0, Math.min(1, alpha));
                if (color.startsWith('rgba')) {
                    return color.replace(/rgba\(([^)]+)\)/, (_, body) => {
                        const parts = body.split(',').map(part => part.trim());
                        return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${normAlpha})`;
                    });
                }
                if (color.startsWith('rgb')) {
                    const inner = color.slice(color.indexOf('(') + 1, color.indexOf(')')).split(',').map(p => p.trim());
                    return `rgba(${inner[0]}, ${inner[1]}, ${inner[2]}, ${normAlpha})`;
                }
                if (color.startsWith('#')) {
                    let hex = color.slice(1);
                    if (hex.length === 3) {
                        hex = hex.split('').map(ch => ch + ch).join('');
                    }
                    const r = parseInt(hex.slice(0, 2), 16);
                    const g = parseInt(hex.slice(2, 4), 16);
                    const b = parseInt(hex.slice(4, 6), 16);
                    if ([r, g, b].some(Number.isNaN)) {
                        return `rgba(255,255,255,${normAlpha})`;
                    }
                    return `rgba(${r}, ${g}, ${b}, ${normAlpha})`;
                }
                return `rgba(255,255,255,${normAlpha})`;
            };
            const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
            const API_BASE = "https://finding-corps-focal-cgi.trycloudflare.com/api";
            const q = (id) => document.getElementById(id);
            const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
            new ResizeObserver(() => {
                const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height),
                    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
                cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
                cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
                ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
            }).observe(stage);
            const mouse = { x: W / 2, y: H * 0.8 };

            const trackedPanelIds = ['shopPanel', 'mechForgeMenuPanel', 'championDressingRoom', 'characterSheetPanel', 'subclassPanel'];
            const panelStack = [];
            let currentPanelId = null;

            const panelRegistry = trackedPanelIds.reduce((acc, id) => {
                const element = q(id);
                if (element) {
                    const backBtn = element.querySelector('.panel-back-btn');
                    if (backBtn) {
                        backBtn.addEventListener('click', () => {
                            handlePanelBack(id);
                        });
                    }
                    acc[id] = { element, backBtn };
                }
                return acc;
            }, {});

            const updatePanelBackButtons = () => {
                trackedPanelIds.forEach(id => {
                    const entry = panelRegistry[id];
                    if (!entry || !entry.backBtn) return;
                    if (panelStack.length === 0 || currentPanelId !== id) {
                        entry.backBtn.classList.add('hide');
                    } else {
                        entry.backBtn.classList.remove('hide');
                    }
                });
            };

            const clearPanelStack = () => {
                panelStack.length = 0;
                currentPanelId = null;
                updatePanelBackButtons();
            };

            const enterPanel = (panelId, { allowDuplicatePush = false } = {}) => {
                if (!panelId) return;
                if (currentPanelId && currentPanelId !== panelId) {
                    const last = panelStack[panelStack.length - 1];
                    if (allowDuplicatePush || last !== currentPanelId) {
                        panelStack.push(currentPanelId);
                    }
                }
                currentPanelId = panelId;
                updatePanelBackButtons();
            };

            const exitPanel = (panelId) => {
                if (!panelId) return;
                if (currentPanelId === panelId) {
                    currentPanelId = null;
                }
                let idx = panelStack.lastIndexOf(panelId);
                while (idx !== -1) {
                    panelStack.splice(idx, 1);
                    idx = panelStack.lastIndexOf(panelId);
                }
                updatePanelBackButtons();
            };

            const runPanelResumeHooks = (panelId) => {
                switch (panelId) {
                    case 'shopPanel': {
                        const goldEl = q('shopgold');
                        if (goldEl && typeof getWorldGold === 'function') {
                            goldEl.textContent = getWorldGold();
                        }
                        if (typeof updateAutoForgeStatusLabel === 'function') {
                            updateAutoForgeStatusLabel();
                        }
                        break;
                    }
                    case 'mechForgeMenuPanel': {
                        if (typeof updateChampionQuickStatus === 'function') {
                            updateChampionQuickStatus();
                        }
                        break;
                    }
                    case 'championDressingRoom': {
                        if (typeof populateChampionBuilder === 'function') {
                            populateChampionBuilder();
                        }
                        if (typeof updateChampionPreview === 'function') {
                            updateChampionPreview();
                        }
                        if (typeof updateChampionStats === 'function') {
                            updateChampionStats();
                        }
                        if (typeof updateChampionBuilderDetails === 'function') {
                            updateChampionBuilderDetails();
                        }
                        if (typeof startChampionPreviewAnimation === 'function') {
                            startChampionPreviewAnimation();
                        }
                        break;
                    }
                    case 'characterSheetPanel': {
                        const body = q('characterSheetBody');
                        if (body && typeof renderCharacterSheet === 'function') {
                            renderCharacterSheet(body);
                        }
                        break;
                    }
                    default:
                        break;
                }
            };

            const handlePanelBack = (panelId) => {
                const entry = panelRegistry[panelId];
                if (!entry) return;

                const destination = panelStack.pop() || null;
                entry.element.classList.add('hide');

                exitPanel(panelId);

                if (destination && panelRegistry[destination]) {
                    const destEntry = panelRegistry[destination];
                    destEntry.element.classList.remove('hide');
                    currentPanelId = destination;
                    runPanelResumeHooks(destination);
                } else if (!destination) {
                    currentPanelId = null;
                    resumeGame();
                    return;
                }
                updatePanelBackButtons();
            };

            updatePanelBackButtons();

            // Simple resize handling without bounds caching
            window.addEventListener('resize', () => {
                // Mark joystick bounds for update too
                if (typeof joystickState !== 'undefined') {
                    joystickState.boundsNeedUpdate = true;
                }
            }, { passive: true });

            const pointFromEvent = (e) => {
                const r = cvs.getBoundingClientRect();
                let touch = e;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    touch = e.changedTouches[0];
                } else if (e.touches && e.touches.length > 0) {
                    touch = e.touches[0];
                }
                const cx = touch.clientX;
                const cy = touch.clientY;
                return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
            };

            // --- MOBILE JOYSTICK & ABILITY BUTTON SETUP ---
            const joystick = {
                base: q('joystick-base'),
                stick: q('joystick-stick'),
                container: q('joystick-container'),
                abilityButton: q('ability-button'),
                abilityIcon: q('ability-icon')
            };

            const joystickState = {
                active: false,
                touchId: null,
                baseRect: null,
                input: { x: 0, y: 0 }, // Normalized vector for player movement
                cachedBaseRect: null,
                boundsNeedUpdate: true
            };

            // Mobile device detection
            function isMobileDevice() {
                return window.innerWidth <= 768 ||
                    'ontouchstart' in window ||
                    navigator.maxTouchPoints > 0 ||
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            function setupMobileControls() {
                // Only set up joystick if elements exist
                if (joystick.base) {
                    joystick.base.addEventListener('touchstart', handleJoystickStart, { passive: false });
                    document.addEventListener('touchmove', handleJoystickMove, { passive: false });
                    document.addEventListener('touchend', handleJoystickEnd, { passive: false });
                    document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
                }

                // Only set up ability button if it exists
                if (joystick.abilityButton) {
                    joystick.abilityButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        if (typeof handleAbilityPress === 'function') {
                            handleAbilityPress();
                        }
                    }, { passive: false });
                }

                // Load saved mobile controls preference
                try {
                    if (localStorage.getItem('mobileControlsEnabled') === 'true') {
                        document.body.classList.add('mobile-controls-active');
                    }
                } catch (e) {
                    // Ignore localStorage errors
                }
            }

            function handleJoystickStart(e) {
                e.preventDefault();
                if (joystickState.active) return;
                const touch = e.changedTouches[0];
                joystickState.active = true;
                joystickState.touchId = touch.identifier;

                // Cache joystick bounds to avoid layout calculations
                if (joystickState.boundsNeedUpdate || !joystickState.cachedBaseRect) {
                    joystickState.cachedBaseRect = joystick.base.getBoundingClientRect();
                    joystickState.boundsNeedUpdate = false;
                }
                joystickState.baseRect = joystickState.cachedBaseRect;

                handleJoystickMove(e); // Process initial position
            }

            function handleJoystickMove(e) {
                if (!joystickState.active) return;
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
                if (!touch) return;

                const baseCenterX = joystickState.baseRect.left + joystickState.baseRect.width / 2;
                const baseCenterY = joystickState.baseRect.top + joystickState.baseRect.height / 2;

                let dx = touch.clientX - baseCenterX;
                let dy = touch.clientY - baseCenterY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxDist = joystickState.baseRect.width / 4; // Stick can move 1/4 of the base width from center

                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }

                joystick.stick.style.transform = `translate(${dx}px, ${dy}px)`;
                joystickState.input.x = dx / maxDist;
                joystickState.input.y = dy / maxDist;
            }

            function handleJoystickEnd(e) {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
                if (!touch) return;

                joystickState.active = false;
                joystickState.touchId = null;
                joystick.stick.style.transform = `translate(0, 0)`;
                joystickState.input = { x: 0, y: 0 };
            }

            function handleAbilityPress() {
                if (store.isPaused || store.isGameOver) return;
                const p = store.player;

                switch (p.pilotGenome) {
                    case 'voidmancer':
                        // Blink in the direction of joystick input, or straight ahead if idle
                        const targetAngle = Math.atan2(joystickState.input.y, joystickState.input.x);
                        const targetDist = 200; // Blink distance
                        const target = {
                            x: p.x + (joystickState.input.x !== 0 ? Math.cos(targetAngle) * targetDist : 0),
                            y: p.y + (joystickState.input.y !== 0 ? Math.sin(targetAngle) * targetDist : p.y - targetDist)
                        };
                        tryVoidStep(p, target);
                        break;
                    case 'beef':
                        // Manually trigger the charge ability
                        p.isRequestingCharge = true; // A flag for the stepPlayer function
                        break;
                    default:
                        // EMP charges now auto-activate on proximity
                        break;
                }
            }

            function updateAbilityButtonIcon() {
                const p = store.player;
                let iconUrl = '';

                // Determine icon based on class and subclass
                switch (p.pilotGenome) {
                    case 'beef':
                        iconUrl = p.subclass === 'marauder' ? 'marauder.png' : 'jug2.png';
                        break;
                    case 'voidmancer':
                        iconUrl = p.subclass === 'phasestriker' ? 'phase.png' : 'storm.png';
                        break;
                    default:
                        iconUrl = 'storm4.png'; // Shield Pulse icon
                        break;
                }
                joystick.abilityIcon.style.backgroundImage = `url('${iconUrl}')`;
            }


            // --- FLAME PARTICLE CLASS ---
            class FlameParticle {
                constructor(x, y, attachedEnemy = null) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 40; // Horizontal spread
                    this.vy = -20 - Math.random() * 30; // Upward drift
                    this.life = 8.4 + Math.random() * 5.6; // 8.4-14 seconds
                    this.maxLife = this.life;
                    this.visualLife = this.life * 1.5; // Visual effect lasts 50% longer than mechanics
                    this.maxVisualLife = this.visualLife;
                    this.size = 8 + Math.random() * 8; // Varied sizes
                    this.attachedEnemy = attachedEnemy;
                    this.damage = 0.45;
                    this.wobble = Math.random() * Math.PI * 2;
                    this.wobbleSpeed = 0.5 + Math.random() * 1;
                    this.heat = 0.8 + Math.random() * 0.2; // Start hot
                    this.flickerOffset = Math.random() * 1000;
                    this.baseSize = this.size;
                    this.gravity = 15; // Slight downward pull
                    this.isDying = false;
                }

                update(dt) {
                    this.life -= dt;
                    this.visualLife -= dt;
                    if (this.visualLife <= 0) return false; // Remove particle when visual effect ends

                    // Standard fire physics
                    if (this.life > 0) {
                        this.vy += this.gravity * dt;
                        this.vy -= 25 * dt;
                        this.x += this.vx * dt;
                        this.y += this.vy * dt;

                        // Air resistance
                        this.vx *= 0.98;
                        this.vy *= 0.98;

                        // Wobble
                        this.wobble += this.wobbleSpeed * dt;
                        this.x += Math.sin(this.wobble) * 8 * dt;
                    }

                    // Heat and void effect - based on VISUAL life for slower fade
                    const visualLifeRatio = this.visualLife / this.maxVisualLife;
                    this.heat = Math.max(0.2, visualLifeRatio * 0.8); // Minimum heat to avoid pure transparency

                    // Size changes - based on visual life for slower shrinking
                    if (visualLifeRatio > 0.7) {
                        this.size = this.baseSize * (1 + (1 - visualLifeRatio) * 2); // Grow when young
                    } else {
                        this.size = Math.max(this.baseSize * 0.5, this.baseSize * visualLifeRatio); // Don't shrink below 50% of base
                    }

                    this.isDying = visualLifeRatio < 0.3;
                    return true;
                }

                draw() {
                    if (this.visualLife <= 0 || this.size <= 0) return;
                    if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;

                    const alpha = this.heat;

                    // Simple flame with just 3 circles - no crackling, no sparkles
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    // Outer glow - simple and clean
                    ctx.fillStyle = `rgba(255, 140, 20, ${alpha * 0.18})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 1.2, 0, 6.283185);
                    ctx.fill();

                    // Middle flame
                    ctx.fillStyle = `rgba(255, 100, 30, ${alpha * 0.38})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 0.7, 0, 6.283185);
                    ctx.fill();

                    // Core flame
                    ctx.fillStyle = `rgba(255, 215, 120, ${alpha * 0.55})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 0.3, 0, 6.283185);
                    ctx.fill();

                    ctx.restore(); // Reset blending mode
                }
            }

            // Simple particle creation function
            function createParticle(x, y, vx, vy, color, life) {
                return {
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: life,
                    maxLife: life,
                    color: color,
                    size: 1
                };
            }


            cvs.addEventListener('mousemove', (e) => {
                try {
                    const p = pointFromEvent(e);
                    mouse.x = p.x;
                    mouse.y = p.y;
                } catch (err) {
                    console.error('Mouse move error:', err);
                }
            }, { passive: true });
            cvs.addEventListener('touchstart', (e) => {
                try {
                    const p = pointFromEvent(e);
                    mouse.x = p.x;
                    mouse.y = p.y;
                    e.preventDefault();
                } catch (err) {
                    console.error('Touch start error:', err);
                }
            }, { passive: false });
            cvs.addEventListener('touchmove', (e) => {
                try {
                    const p = pointFromEvent(e);
                    mouse.x = p.x;
                    mouse.y = p.y;
                    e.preventDefault();
                } catch (err) {
                    console.error('Touch move error:', err);
                }
            }, { passive: false });

            // --- AUDIO ---
            const bgm = q('bgmAudio');
            const sounds = {
                explosion: q('audioExplosion'),
                horn: q('audioHorn'),
                hit: q('audioHit'),
                trap: q('audioTrap'),
                dogs: q('audioDogs'),
                charge: q('audioCharge'),
                beefCharge: q('audioBeefCharge'),
                epicHorn: q('audioEpicHorn'),
                cluster: q('audioCluster'),
                thunder: q('audioThunder'),
                shao_kahn: q('audioShaoKahn'),
                stargun: q('audioStarGun')
            };
            let lastExplosionSoundTime = 0;
            let lastBossHitSoundTime = 0;
            let lastClusterSoundTime = 0;
            let lastChampionThunderTime = 0;
            const SOUND_COOLDOWNS = {
                thunder: 1500,
                epicHorn: 2500
            };
            const soundLastPlayTime = {};

            function playSound(name) {
                // Check if audio is muted
                if (store.settings.audioMuted) return;

                const audio = sounds[name];
                if (!audio) return;
                const now = performance.now();
                if (name === 'explosion') {
                    if (now - lastExplosionSoundTime < 50) return;
                    lastExplosionSoundTime = now;
                }
                if (name === 'cluster') {
                    if (now - lastClusterSoundTime < 150) return; // Increased from 60ms to 150ms
                    lastClusterSoundTime = now;
                }
                if (name === 'hit') {
                    if (now - lastBossHitSoundTime < 100) return;
                    lastBossHitSoundTime = now;
                }
                const cooldown = SOUND_COOLDOWNS[name];
                if (cooldown) {
                    const lastTime = soundLastPlayTime[name] || 0;
                    if (now - lastTime < cooldown) return;
                    soundLastPlayTime[name] = now;
                }
                audio.currentTime = 0;
                audio.play().catch(e => { });
            }


            // --- GAME STATE & DATA ---
            const player_initial_state = {
                x: W / 2, y: H * 0.8, r: 14, hp: 80, hpMax: 100, fireT: 0, speed: 380, dmgMult: 1.2, fireRate: 0.16,
                vampirism: 0, shield: 25, shieldMax: 50, multishot: 2, isInvincible: false, piercing: 0, explosive: false,
                timeShardStacks: 0, timeShardTimer: 0, timeShardMultiplier: 1,
                hasShieldBubble: false, powerupTimers: {},
                swirlShots: false, attackSpeedStacks: 0,
                upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0, launcher: 0, lazarus_beam: 0, gravity_well: 0, star_cannon: 0, fragment_blast: 0 },
                grenades: 0, hasVoidBeam: false, voidBeamCooldown: 0,
                hasLazarusBeam: false, lazarusBeamCooldown: 0,
                hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 1, vampirismLevel: 0, flamethrowerLevel: 0,
                flamethrowerT: 0, // Separate timer for lava chunks, unaffected by overclock
                fragmentBlasters: [], // Auto-targeting shotgun blasts
                // Shield recharge delay system
                shieldRecharging: false,
                shieldRechargeDelay: 0,
                shieldRechargeDelayMax: 2.0,
                // Rocketman afterburner system
                afterburnerActive: false,
                afterburnerTimer: 0,
                afterburnerMaxDuration: 2.0,
                afterburnerParticleTimer: 0,
                starCannonLevel: 0, starCannonTimer: 0, starCannonIcemanSupport: false, starCannonNextSide: 'left',
                juggernautCloneActive: false,
                luckBoost: 0, magnetRadius: 0, hasIceman: false, icemanFireT: 0, hasBeefClone: false, critChance: 0.02, critDamage: 1.85,
                pilotGenome: null, missileVolley: 2,
                hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
                rearMultishot: 0, addFrontNext: true,
                flameWallCooldown: 0,
                flameWallCooldownMax: 10,
                flameWallCharge: 0,
                flameWallInitialized: false,
                flameWallActiveT: 0,
                beefChargeState: null, beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 0, beefMaxCharges: 0,
                beefChargePlan: null, beefChargeSegmentIndex: 0, beefImpactDelay: 0, beefLastImpact: null, beefQueuedCharge: null,
                beefDoubleCharge: false, beefBigExplosion: false, // New skill tree abilities
                beefChainMode: false, // Chain jumping system for marauder
                hasChainLightning: false, chainLightningCooldown: 0, stormstrikerLevel: 0, lightningAlternate: false, lightningCycleIndex: 0, chainLightningDamage: 1.0,
                phasestRikerLevel: 0, voidLaserRampTime: 0, voidLaserLastTarget: null,
                wiperLasers: false, wiperLaser1Angle: 0, wiperLaser2Angle: Math.PI, wiperLaserSpeed: 1.5, wiperLaserDamageTimer: 0,
                subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false,
                hasBlink: false, autoBlinkEnabled: false, autoBlinkRange: 0, autoBlinkLookahead: 0.45, autoBlinkLastTrigger: 0,
                isBlinkSlashing: false,
                enhancedClusters: false, enhancedPierce: false, hasStormbringer: false, hasPhasestriker: false,
                // Omega multishot abilities
                hasOmegaMultishot: false, omegaMultishotType: null,
                // Void caller enhanced options
                hasDoubleStorm: false, hasHybridVoid: false, hasImpactPhase: false,
                // Skill tree progress
                skillPoints: 0, skillPointsSpent: 0, skillTree: { juggernaut: false, marauder: false, double_charge: false, big_explosion: false, triple_charge: false },
                clusterSoundCounter: 0,
                // EMP nova effects
                empDisabled: false, empDisabledTimer: 0,
                championUnlocked: false,
                championUpgrades: {
                    attackModule: 'default',
                    unlockedAttacks: {
                        // Legacy modules (for backwards compatibility)
                        ember: false, tempest: false, void: false,
                        // New attack modules - some available for testing
                        precision_strike: true, kinetic_swarm: true,
                        inferno_burst: true, plasma_stream: true,
                        focus_beam: false, scatter_array: false,
                        arc_cannon: true, storm_grid: false
                    },
                    cadenceLevel: 0,
                    minionProtocols: 0,
                    skin: 'default',
                    unlockedSkins: { default: true }
                }
            };

            class Pool {
                constructor(createFn, resetFn) {
                    this.createFn = createFn;
                    this.resetFn = resetFn;
                    this.available = [];
                }

                prefill(count) {
                    for (let i = 0; i < count; i++) {
                        this.available.push(this.createFn());
                    }
                }

                get() {
                    const item = this.available.pop() || this.createFn();
                    if (this.resetFn) this.resetFn(item);
                    return item;
                }

                release(item) {
                    if (this.resetFn) this.resetFn(item);
                    this.available.push(item);
                }
            }

            function resetBulletState(bullet) {
                bullet.x = 0;
                bullet.y = 0;
                bullet.vx = 0;
                bullet.vy = 0;
                bullet.r = 3;
                bullet.col = "#b266ff";
                bullet.dmg = 0;
                bullet.pierce = 0;
                bullet.explosive = false;
                bullet.dead = false;
                bullet.life = undefined;
                bullet.fadeInTime = undefined;
                bullet.spawnTime = undefined;
                bullet.isSwirl = false;
                bullet.isFlame = false;
                bullet.isIceman = false;
                bullet.isDrone = false;
                bullet.isLavaChunk = false;
                bullet.isLevelUpPulse = false;
                bullet.gravity = undefined;
                bullet.target = undefined;
                bullet.particles = null;
                bullet.particleSpawnT = 0;
            }

            function createBullet() {
                const bullet = {};
                resetBulletState(bullet);
                return bullet;
            }

            const bulletPool = new Pool(createBullet, resetBulletState);
            bulletPool.prefill(100);

            const STAR_CANNON_BASE_COOLDOWN = 7;
            const STAR_CANNON_MIN_COOLDOWN = 1.4;
            const STAR_CANNON_LEVEL_CAP = 16;
            const STAR_CANNON_ALTERNATE_DELAY = 0.22;
            const STAR_CANNON_SPEED = 420;
            const STAR_CANNON_DAMAGE = 220;
            const STAR_CANNON_SIZE = 20;
            const STAR_CANNON_HITBOX_SCALE = 1.0;
            const STAR_CANNON_CLONE_DELAY = 0.35;
            const STAR_CANNON_ICEMAN_DAMAGE_SCALE = 0.3;

            function getStarCannonCooldown(level) {
                if (!level || level <= 0) {
                    return STAR_CANNON_BASE_COOLDOWN;
                }
                const clampedLevel = clamp(level, 1, STAR_CANNON_LEVEL_CAP);
                const reductionPerLevel = (STAR_CANNON_BASE_COOLDOWN - STAR_CANNON_MIN_COOLDOWN) / (STAR_CANNON_LEVEL_CAP - 1);
                const cooldown = STAR_CANNON_BASE_COOLDOWN - reductionPerLevel * (clampedLevel - 1);
                return Math.max(STAR_CANNON_MIN_COOLDOWN, cooldown);
            }

            function getStarCannonBurstCount(level) {
                if (!level || level <= 0) return 0;
                const clamped = clamp(level, 1, STAR_CANNON_LEVEL_CAP);
                const base = clamped >= 2 ? 2 : 1;
                const extra = Math.floor(Math.max(0, clamped - 3) / 2);
                return Math.min(base + extra, 6);
            }

            const initialTelemetryEnabled = (() => {
                try {
                    return !!(window.localStorage && window.localStorage.getItem('voidTelemetry') === '1');
                } catch (err) {
                    return false;
                }
            })();

            const storedAutoForgeEnabled = (() => {
                try {
                    if (!window.localStorage) return true;
                    const value = window.localStorage.getItem('voidAutoForge');
                    if (value === null) return true;
                    const normalized = value.toLowerCase();
                    if (normalized === 'off' || normalized === '0' || normalized === 'false') return false;
                    if (normalized === 'on' || normalized === '1' || normalized === 'true') return true;
                    return true;
                } catch (err) {
                    return true;
                }
            })();

            const storedShopTutorialEnabled = (() => {
                try {
                    if (!window.localStorage) return true;
                    const value = window.localStorage.getItem('voidShopTutorial');
                    if (value === null) return true;
                    const normalized = value.toLowerCase();
                    if (normalized === 'off' || normalized === '0' || normalized === 'false') return false;
                    if (normalized === 'on' || normalized === '1' || normalized === 'true') return true;
                    return true;
                } catch (err) {
                    return true;
                }
            })();

            const AUTO_FORGE_DEFAULT_PROFILE_ID = 'baseline_directive';

            const rawAutoForgeProfiles = [
                {
                    id: 'baseline_directive',
                    label: 'Baseline Directive',
                    summary: 'Balanced logistics that rotates through heavy ordnance and sustain.',
                    statusLine: 'Balanced procurement across weapons and hull sustain.',
                    groups: [
                        { keys: ['gravity_well', 'star_cannon', 'ghost_hounds', 'lazarus_beam', 'launcher', 'iceman'], sort: 'cost-desc', isFun: true },
                        { keys: ['nano_save', 'max_shield', 'hp', 'vampirism'], sort: 'cost-desc' },
                        { keys: ['speed', 'luck_boost'], sort: 'cost-asc' }
                    ],
                    fallback: ['dmg', 'crit_chance', 'repair'],
                    repairThreshold: 0.82
                },
                {
                    id: 'void_savant',
                    label: 'Void Savant',
                    summary: 'Singularity tactician favouring beams, speed, and layered shields.',
                    statusLine: 'Prioritizes Gravity Well, Lazarus protocols, and shield fortification.',
                    groups: [
                        { keys: ['gravity_well', 'lazarus_beam'], sort: 'cost-desc', isFun: true },
                        { keys: ['speed', 'magnet_pull'], sort: 'cost-desc' },
                        { keys: ['max_shield', 'rear_guard', 'nano_save'], sort: 'cost-desc' }
                    ],
                    fallback: ['hp', 'vampirism', 'luck_boost'],
                    repairThreshold: 0.78
                },
                {
                    id: 'starcaller',
                    label: 'Starcaller',
                    summary: 'Amplifies orbital cannons while stacking lifesteal and fortune.',
                    statusLine: 'Channels Star Cannon calibrations with vampiric sustain.',
                    groups: [
                        { keys: ['star_cannon'], sort: 'cost-desc', isFun: true },
                        { keys: ['vampirism', 'hp'], sort: 'cost-desc' },
                        { keys: ['luck_boost', 'max_shield', 'nano_save'], sort: 'cost-desc' }
                    ],
                    fallback: ['speed', 'repair', 'dmg'],
                    repairThreshold: 0.76
                },
                {
                    id: 'fleet_admiral',
                    label: 'Fleet Admiral',
                    summary: 'Directs companion cadres and champion support systems.',
                    statusLine: 'Funds hounds, iceman, and champion modules when available.',
                    groups: [
                        { keys: ['ghost_hounds', 'iceman'], sort: 'cost-desc', isFun: true },
                        { keys: ['champion_attack_module', 'champion_cadence', 'champion_protocol'], sort: 'cost-desc', includeRestricted: true },
                        { keys: ['rear_guard', 'nano_save', 'max_shield'], sort: 'cost-desc' }
                    ],
                    fallback: ['hp', 'speed', 'repair'],
                    repairThreshold: 0.8
                },
                {
                    id: 'aegis_warden',
                    label: 'Aegis Warden',
                    summary: 'Fortifies hull integrity and keeps emergency reserves primed.',
                    statusLine: 'Stacks shields, nanosaves, and defensive redundancies.',
                    groups: [
                        { keys: ['max_shield', 'nano_save'], sort: 'cost-desc' },
                        { keys: ['rear_guard', 'hp'], sort: 'cost-desc' },
                        { keys: ['repair', 'magnet_pull'], sort: 'cost-asc' }
                    ],
                    fallback: ['vampirism', 'luck_boost', 'speed'],
                    repairThreshold: 0.9
                },
                {
                    id: 'blitz_vanguard',
                    label: 'Blitz Vanguard',
                    summary: 'Rushdown doctrine emphasising damage spikes and crowd clear.',
                    statusLine: 'Invests in raw damage, crit chains, and explosive salvos.',
                    groups: [
                        { keys: ['dmg', 'crit_chance'], sort: 'cost-desc', isFun: true },
                        { keys: ['speed', 'launcher'], sort: 'cost-desc', isFun: true },
                        { keys: ['grenade', 'star_cannon'], sort: 'cost-desc', isFun: true }
                    ],
                    fallback: ['hp', 'repair', 'max_shield'],
                    repairThreshold: 0.74
                },
                {
                    id: 'arc_technician',
                    label: 'Arc Technician',
                    summary: 'Optimises utility grids, resource pulls, and survivability buffers.',
                    statusLine: 'Focuses on magnetics, luck matrices, and nanosaves.',
                    groups: [
                        { keys: ['magnet_pull', 'luck_boost'], sort: 'cost-desc' },
                        { keys: ['speed', 'nano_save'], sort: 'cost-desc' },
                        { keys: ['rear_guard', 'vampirism'], sort: 'cost-desc' }
                    ],
                    fallback: ['hp', 'max_shield', 'dmg'],
                    repairThreshold: 0.82
                },
                {
                    id: 'stormrunner',
                    label: 'Stormrunner',
                    summary: 'Keeps velocity high while topping off shields and ordnance.',
                    statusLine: 'Funds speed, shield loops, and opportunistic explosives.',
                    groups: [
                        { keys: ['speed', 'magnet_pull'], sort: 'cost-desc' },
                        { keys: ['max_shield', 'nano_save'], sort: 'cost-desc' },
                        { keys: ['grenade', 'dmg'], sort: 'cost-desc', isFun: true }
                    ],
                    fallback: ['hp', 'repair', 'luck_boost'],
                    repairThreshold: 0.8
                }
            ];

            function normalizeAutoForgeProfile(profile) {
                const groups = Array.isArray(profile.groups) ? profile.groups.map(group => Object.freeze({
                    ...group,
                    keys: Object.freeze([...(group.keys || [])])
                })) : [];
                return Object.freeze({
                    ...profile,
                    groups: Object.freeze(groups),
                    fallback: Object.freeze([...(profile.fallback || [])])
                });
            }

            const AUTO_FORGE_PROFILES = Object.freeze(rawAutoForgeProfiles.map(normalizeAutoForgeProfile));
            const AUTO_FORGE_PROFILE_MAP = (() => {
                const map = new Map();
                for (const profile of AUTO_FORGE_PROFILES) {
                    map.set(profile.id, profile);
                }
                return map;
            })();

            function resolveAutoForgeProfileId(candidate) {
                if (candidate && AUTO_FORGE_PROFILE_MAP.has(candidate)) {
                    return candidate;
                }
                return AUTO_FORGE_DEFAULT_PROFILE_ID;
            }

            const storedAutoForgeProfileRaw = (() => {
                try {
                    if (!window.localStorage) return null;
                    return window.localStorage.getItem('voidAutoForgeProfile');
                } catch (err) {
                    return null;
                }
            })();

            const initialAutoForgeProfileId = resolveAutoForgeProfileId(storedAutoForgeProfileRaw);

            const BOSS_DEFINITIONS = Object.freeze([
                { key: 'void_sentinel', name: 'VOID SENTINEL', baseHp: 4000, r: 55, behavior: 'sentinel', color: '#8B4A9C' },
                { key: 'nexus_phantom', name: 'NEXUS PHANTOM', baseHp: 2200, r: 50, behavior: 'hex', color: '#66aaff' },
                { key: 'aegis_architect', name: 'AEGIS ARCHITECT', baseHp: 3600, r: 68, behavior: 'aegis_architect', color: '#5dd0ff' },
                { key: 'hive_sovereign', name: 'HIVE SOVEREIGN', baseHp: 8500, r: 85, behavior: 'broodlord', color: '#2d5016' },
                { key: 'shadow_mirror', name: 'SHADOW MIRROR', baseHp: 7200, r: 58, behavior: 'shadow_clone', color: '#cbd4ff' },
                { key: 'death_engine', name: 'DEATH ENGINE', baseHp: 9000, r: 90, behavior: 'construct', color: '#e54d24', phase: 1, isLaughing: false, laughStartTime: 0, visible: true },
                { key: 'asynchronos', name: 'ASYNCHRONOS', baseHp: 7800, r: 62, behavior: 'asynchronos', color: '#6ff2ff' }
            ]);

            const BOSS_THEME_MAP = Object.freeze({
                'VOID SENTINEL': 'void_sentinel',
                'NEXUS PHANTOM': 'nexus_phantom',
                'AEGIS ARCHITECT': 'aegis_architect',
                'HIVE SOVEREIGN': 'hive_sovereign',
                'SHADOW MIRROR': 'shadow_mirror',
                'DEATH ENGINE': 'death_engine',
                'ASYNCHRONOS': 'asynchronos'
            });

            const DEFAULT_MAP_THEME_KEY = 'void_sentinel';

            const MAP_THEME_DEFS = Object.freeze({
                void_sentinel: {
                    key: 'void_sentinel',
                    label: 'Sentinel Breach',
                    baseFill: '#050008',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.38, radius: 0.95, stops: [
                            { offset: 0, color: 'rgba(120, 0, 160, 0.9)' },
                            { offset: 0.45, color: 'rgba(35, 0, 90, 0.55)' },
                            { offset: 1, color: 'rgba(4, 0, 12, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 120, speed: 26, color: 'rgba(255, 160, 255, 0.75)', pulseColor: 'rgba(255, 225, 255, 0.95)', minRadius: 0.35, maxRadius: 1.4, twinkleSpeed: 2.1, twinkleAmplitude: 0.55 },
                        { count: 80, speed: 52, color: 'rgba(140, 60, 220, 0.6)', pulseColor: 'rgba(225, 140, 255, 0.85)', minRadius: 0.2, maxRadius: 1.9, twinkleSpeed: 1.4, twinkleAmplitude: 0.45 }
                    ],
                    auroraBands: [
                        { y: 0.22, thickness: 0.14, alpha: 0.42, waveSpeed: 0.32, waveAmplitude: 0.12, rotation: 0.14, colorStops: ['rgba(60, 0, 120, 0)', 'rgba(240, 160, 255, 0.55)', 'rgba(10, 0, 30, 0)'] }
                    ]
                },
                nexus_phantom: {
                    key: 'nexus_phantom',
                    label: 'Phantom Glacial Drift',
                    baseFill: '#031024',
                    gradient: {
                        type: 'radial', x: 0.48, y: 0.33, radius: 0.92, stops: [
                            { offset: 0, color: 'rgba(20, 80, 180, 0.8)' },
                            { offset: 0.6, color: 'rgba(5, 18, 50, 0.7)' },
                            { offset: 1, color: 'rgba(3, 10, 28, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 140, speed: 20, color: 'rgba(140, 200, 255, 0.75)', pulseColor: 'rgba(210, 235, 255, 0.95)', minRadius: 0.3, maxRadius: 1.3, twinkleSpeed: 1.6, twinkleAmplitude: 0.5 },
                        { count: 70, speed: 38, color: 'rgba(80, 180, 255, 0.55)', pulseColor: 'rgba(120, 220, 255, 0.8)', minRadius: 0.25, maxRadius: 1.7, twinkleSpeed: 1.1, twinkleAmplitude: 0.4 }
                    ],
                    auroraBands: [
                        { y: 0.68, thickness: 0.18, alpha: 0.36, waveSpeed: 0.24, waveAmplitude: 0.16, rotation: -0.18, colorStops: ['rgba(0, 40, 120, 0)', 'rgba(50, 180, 255, 0.55)', 'rgba(0, 18, 60, 0)'] }
                    ]
                },
                aegis_architect: {
                    key: 'aegis_architect',
                    label: 'Aegis Vault Nexus',
                    baseFill: '#04111c',
                    gradient: {
                        type: 'radial', x: 0.48, y: 0.42, radius: 0.92, stops: [
                            { offset: 0, color: 'rgba(30, 180, 255, 0.78)' },
                            { offset: 0.5, color: 'rgba(10, 70, 120, 0.7)' },
                            { offset: 1, color: 'rgba(4, 12, 20, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 130, speed: 26, color: 'rgba(120, 220, 255, 0.75)', pulseColor: 'rgba(200, 240, 255, 0.95)', minRadius: 0.3, maxRadius: 1.4, twinkleSpeed: 1.9, twinkleAmplitude: 0.52 },
                        { count: 75, speed: 48, color: 'rgba(90, 180, 255, 0.6)', pulseColor: 'rgba(140, 210, 255, 0.85)', minRadius: 0.25, maxRadius: 1.85, twinkleSpeed: 1.3, twinkleAmplitude: 0.44 }
                    ],
                    auroraBands: [
                        { y: 0.46, thickness: 0.2, alpha: 0.34, waveSpeed: 0.38, waveAmplitude: 0.14, rotation: 0.12, colorStops: ['rgba(20, 120, 200, 0)', 'rgba(80, 200, 255, 0.55)', 'rgba(6, 28, 48, 0)'] }
                    ]
                },
                hive_sovereign: {
                    key: 'hive_sovereign',
                    label: 'Hive Nebular Bloom',
                    baseFill: '#1b0d04',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.45, radius: 0.94, stops: [
                            { offset: 0, color: 'rgba(150, 90, 10, 0.8)' },
                            { offset: 0.5, color: 'rgba(50, 20, 4, 0.75)' },
                            { offset: 1, color: 'rgba(14, 6, 2, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 130, speed: 22, color: 'rgba(255, 200, 120, 0.7)', pulseColor: 'rgba(255, 240, 180, 0.92)', minRadius: 0.3, maxRadius: 1.4, twinkleSpeed: 1.7, twinkleAmplitude: 0.55 },
                        { count: 65, speed: 36, color: 'rgba(220, 130, 40, 0.6)', pulseColor: 'rgba(255, 180, 80, 0.85)', minRadius: 0.25, maxRadius: 1.9, twinkleSpeed: 1.3, twinkleAmplitude: 0.4 }
                    ],
                    auroraBands: [
                        { y: 0.3, thickness: 0.22, alpha: 0.34, waveSpeed: 0.28, waveAmplitude: 0.14, rotation: -0.06, colorStops: ['rgba(120, 50, 10, 0)', 'rgba(255, 170, 60, 0.55)', 'rgba(40, 12, 3, 0)'] }
                    ]
                },
                shadow_mirror: {
                    key: 'shadow_mirror',
                    label: 'Shadow Cascade',
                    baseFill: '#04081a',
                    gradient: {
                        type: 'radial', x: 0.52, y: 0.3, radius: 0.88, stops: [
                            { offset: 0, color: 'rgba(60, 0, 140, 0.8)' },
                            { offset: 0.55, color: 'rgba(15, 10, 45, 0.75)' },
                            { offset: 1, color: 'rgba(4, 8, 20, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 150, speed: 28, color: 'rgba(180, 190, 255, 0.75)', pulseColor: 'rgba(230, 235, 255, 0.95)', minRadius: 0.3, maxRadius: 1.25, twinkleSpeed: 2.4, twinkleAmplitude: 0.6 },
                        { count: 80, speed: 50, color: 'rgba(80, 120, 255, 0.6)', pulseColor: 'rgba(160, 180, 255, 0.85)', minRadius: 0.25, maxRadius: 1.75, twinkleSpeed: 1.5, twinkleAmplitude: 0.5 }
                    ],
                    auroraBands: [
                        { y: 0.58, thickness: 0.18, alpha: 0.4, waveSpeed: 0.42, waveAmplitude: 0.18, rotation: 0.18, colorStops: ['rgba(10, 40, 160, 0)', 'rgba(120, 160, 255, 0.6)', 'rgba(4, 14, 40, 0)'] }
                    ]
                },
                death_engine: {
                    key: 'death_engine',
                    label: 'Death Engine Crucible',
                    baseFill: '#120202',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.4, radius: 0.96, stops: [
                            { offset: 0, color: 'rgba(190, 40, 0, 0.85)' },
                            { offset: 0.5, color: 'rgba(80, 10, 0, 0.75)' },
                            { offset: 1, color: 'rgba(18, 2, 2, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 125, speed: 30, color: 'rgba(255, 160, 120, 0.72)', pulseColor: 'rgba(255, 210, 160, 0.95)', minRadius: 0.32, maxRadius: 1.4, twinkleSpeed: 2.0, twinkleAmplitude: 0.58 },
                        { count: 85, speed: 58, color: 'rgba(220, 80, 20, 0.62)', pulseColor: 'rgba(255, 140, 60, 0.86)', minRadius: 0.24, maxRadius: 2.0, twinkleSpeed: 1.4, twinkleAmplitude: 0.5 }
                    ],
                    auroraBands: [
                        { y: 0.4, thickness: 0.26, alpha: 0.38, waveSpeed: 0.5, waveAmplitude: 0.2, rotation: -0.12, colorStops: ['rgba(120, 20, 0, 0)', 'rgba(255, 140, 60, 0.6)', 'rgba(40, 6, 2, 0)'] }
                    ]
                },
                asynchronos: {
                    key: 'asynchronos',
                    label: 'Chronoshift Expanse',
                    baseFill: '#04030a',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.36, radius: 0.94, stops: [
                            { offset: 0, color: 'rgba(90, 240, 255, 0.82)' },
                            { offset: 0.48, color: 'rgba(32, 60, 160, 0.7)' },
                            { offset: 1, color: 'rgba(8, 10, 26, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 140, speed: 24, color: 'rgba(160, 255, 245, 0.75)', pulseColor: 'rgba(220, 255, 250, 0.95)', minRadius: 0.28, maxRadius: 1.3, twinkleSpeed: 2.1, twinkleAmplitude: 0.48 },
                        { count: 90, speed: 46, color: 'rgba(110, 180, 255, 0.6)', pulseColor: 'rgba(180, 220, 255, 0.86)', minRadius: 0.24, maxRadius: 1.8, twinkleSpeed: 1.5, twinkleAmplitude: 0.42 }
                    ],
                    auroraBands: [
                        { y: 0.28, thickness: 0.18, alpha: 0.36, waveSpeed: 0.36, waveAmplitude: 0.16, rotation: -0.14, colorStops: ['rgba(20, 200, 255, 0)', 'rgba(150, 240, 255, 0.55)', 'rgba(10, 30, 80, 0)'] },
                        { y: 0.64, thickness: 0.2, alpha: 0.28, waveSpeed: 0.42, waveAmplitude: 0.2, rotation: 0.18, colorStops: ['rgba(140, 100, 255, 0)', 'rgba(220, 180, 255, 0.5)', 'rgba(30, 0, 70, 0)'] }
                    ]
                }
            });

            const store = {
                frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
                isDamageOff: false,
                savedPlayerState: null,
                world: {
                    wave: 1,
                    score: 0,
                    gold: 0,
                    xp: 0,
                    level: 1,
                    kills: 0,
                    bosses: 0,
                    bossesAtPilotSelection: null,
                    lowHealthTutorialShown: false,
                    bossSpawnTime: 0,
                    waveStartTime: 0,
                    activeBossToken: null,
                    activeBossWave: null,
                    completedBossTokens: Object.create(null),
                    lastBossAwardToken: null,
                    waveTransitionTimer: null,
                    enemyHealthBonus: 1.0,
                    bossHealthBonus: 1.0,
                    enemyDensityBonus: 1.0,
                    powerupCooldown: 0,
                    xpMultiplier: 1.0,
                    collarStacks: 0,
                    collarTargetStacks: 0,
                    collarTargetStacks: 0,
                    lateGameDamageScaling: 1,
                    consecutiveFastKills: 0,
                    fastKillBonus: 0,
                    isLowHealth: false,
                    lastThreatScale: 1,
                    lastSpawnOverflow: 0,
                    lastPlannedSpawnCount: 0,
                    lastSpawnCount: 0,
                    lastSpawnFallback: false,
                    lastSpawnQueueLength: 0,
                    lastSpawnTempo: 0,
                    firstBossOrbsGifted: false,
                    mechForgeGoldTriggered: false,
                    mechForgePulseTimeout: null,
                    mechForgePromptActive: false,
                    mechForgePromptInterval: 250,
                    nextMechForgePrompt: 135,
                    mechForgePromptCount: 0,
                    autoForgeEnabled: storedAutoForgeEnabled,
                    autoForgeReserve: 0,
                    autoForgeDecisionTimer: null,
                    autoForgeAnnounceCooldown: 0,
                    totalForgeSpend: 0,
                    autoForgeTutorialShown: false,
                    shopTutorialShown: false,
                    shopSpotlightDismissed: false,
                    currentThemeKey: DEFAULT_MAP_THEME_KEY,
                    targetThemeKey: DEFAULT_MAP_THEME_KEY,
                    themeTransitionProgress: 1,
                    themeTransitionActive: false,
                    autoForgeProfileId: initialAutoForgeProfileId,
                    voidReaperSpawnedThisWave: false,
                    lastVoidReaperWave: 0,
                    voidReaperCooldown: 0,
                    pendingVoidReaper: null,
                    voidReaperWarningIssued: false
                },
                settings: {
                    showShopTutorial: storedShopTutorialEnabled,
                    autoForgeProfile: initialAutoForgeProfileId,
                    audioMuted: false
                },
                ui: {
                    shopSpotlightActive: false,
                    shopSpotlightMessage: 'Upgrade Hangar online. Deploy credits as needed.'
                },
                player: { ...player_initial_state },
                boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], shadowHounds: [], missiles: [], lasers: [], mines: [], activeEffects: [], starProjectiles: [], pendingStarSalvos: [], pendingStarClones: [], juggernautBombs: [],
                lastBossSnapshot: null,
                lastBossDefeatId: null,
                flameParticles: [],
                lightningBolts: [],
                empNovas: [],
                flamePulses: [], // Rocketman flame pulse rings
                mechPuddles: [], // Hazardous puddles left by mech tank attacks
                poisonPuddles: [],
                goldenOrbs: [],
                shadowEchoes: [],
                temporalEchoes: [],
                timeShards: [],
                championPresetCache: null,
                lastChampionPresetCode: null,
                temporalBeam: null,
                championMinions: [],
                empCharges: [],
                empGlobalCooldown: 0,
                playerChampion: null,
                shadowChampionId: null,
                shadowChampionDefeated: false,
                shadowChampionTokenDropped: false,
                shadowChampionLastPos: null,
                _enemySpatial: {
                    cellSize: 160,
                    buckets: new Map(),
                    usedKeys: []
                },
                iceman: null,
                beefClone: null,
                waveSpawnQueue: [],
                pendingSpawnCount: 0,
                vulnerabilityEvents: [],
                // Object pools for performance optimization
                bulletPool: null,
                eBulletPool: [],
                effectPool: [],
                tempFlamePool: [], // For simple flame particles
                _startTs: performance.now(),
                cheatInvincibilityCooldown: 0,
                cheatDogHealCooldown: 0,
                cheatChampionCooldown: 0,
                heartbeatT: 0,
                cheatsUsed: false,
                telemetryEnabled: initialTelemetryEnabled
            };

            function getActiveAutoForgeProfileId() {
                const worldId = store?.world?.autoForgeProfileId;
                if (worldId && AUTO_FORGE_PROFILE_MAP.has(worldId)) {
                    return worldId;
                }
                const settingsId = store?.settings?.autoForgeProfile;
                if (settingsId && AUTO_FORGE_PROFILE_MAP.has(settingsId)) {
                    return settingsId;
                }
                return AUTO_FORGE_DEFAULT_PROFILE_ID;
            }

            function getActiveAutoForgeProfile() {
                const profileId = getActiveAutoForgeProfileId();
                return AUTO_FORGE_PROFILE_MAP.get(profileId) || AUTO_FORGE_PROFILE_MAP.get(AUTO_FORGE_DEFAULT_PROFILE_ID);
            }

            function setAutoForgeProfile(profileId, options = {}) {
                const resolved = resolveAutoForgeProfileId(profileId);
                const current = getActiveAutoForgeProfileId();
                if (resolved === current && !options.force) {
                    if (!options.skipUi) {
                        updateAutoForgeProfileButtons();
                        updateAutoForgeStatusLabel();
                    }
                    return resolved;
                }

                if (store.settings) {
                    store.settings.autoForgeProfile = resolved;
                }
                if (store.world) {
                    store.world.autoForgeProfileId = resolved;
                }

                try {
                    if (window.localStorage) {
                        window.localStorage.setItem('voidAutoForgeProfile', resolved);
                    }
                } catch (err) { }

                if (!options.skipUi) {
                    updateAutoForgeProfileButtons();
                    updateAutoForgeStatusLabel();
                }

                if (!options.silent && typeof announce === 'function') {
                    const profile = AUTO_FORGE_PROFILE_MAP.get(resolved);
                    if (profile) {
                        announce(`Auto-buy doctrine set: ${profile.label}.`);
                    }
                }

                return resolved;
            }

            function getAutoForgeStatusText() {
                const world = store.world;
                if (!world || !world.autoForgeEnabled) {
                    return 'Auto-buy offline. Route purchases manually.';
                }
                const profile = getActiveAutoForgeProfile();
                if (profile) {
                    return `Auto-buy active: ${profile.label}. ${profile.statusLine}`;
                }
                return 'Auto-buy active. Logistics maintain core systems.';
            }

            function updateAutoForgeStatusLabel() {
                const statusEl = q('autoForgeStatusLabel');
                if (statusEl) {
                    statusEl.textContent = getAutoForgeStatusText();
                }
            }

            function updateAutoForgeProfileButtons() {
                const container = q('autoForgeProfileGrid');
                if (!container) return;
                const activeId = getActiveAutoForgeProfileId();
                container.querySelectorAll('.forge-profile-card').forEach(card => {
                    if (!(card instanceof HTMLElement)) return;
                    const isActive = card.dataset.profileId === activeId;
                    if (isActive) {
                        card.classList.add('active');
                        card.setAttribute('aria-pressed', 'true');
                    } else {
                        card.classList.remove('active');
                        card.setAttribute('aria-pressed', 'false');
                    }
                });
                const summaryEl = q('autoForgeProfileSummary');
                if (summaryEl) {
                    const profile = getActiveAutoForgeProfile();
                    if (!store.world || !store.world.autoForgeEnabled) {
                        summaryEl.textContent = 'Auto-buy is currently offline. Enable the switch above to deploy a doctrine.';
                    } else {
                        summaryEl.textContent = profile ? profile.summary : '';
                    }
                }
            }

            function ensureAutoForgeProfileGrid() {
                const container = q('autoForgeProfileGrid');
                if (!container) return;
                if (!container.dataset.initialized) {
                    container.dataset.initialized = 'true';
                    for (const profile of AUTO_FORGE_PROFILES) {
                        const card = document.createElement('button');
                        card.type = 'button';
                        card.className = 'forge-profile-card';
                        card.dataset.profileId = profile.id;
                        card.setAttribute('aria-pressed', 'false');
                        card.innerHTML = `<div class="forge-profile-card-title">${profile.label}</div><div class="forge-profile-card-summary">${profile.summary}</div>`;
                        card.addEventListener('click', () => {
                            setAutoForgeProfile(profile.id);
                        });
                        container.appendChild(card);
                    }
                }
                updateAutoForgeProfileButtons();
            }

            // --- OBJECT POOLING SYSTEM ---
            store.bulletPool = bulletPool;

            function spawnBullet(props = {}) {
                const bullet = bulletPool.get();
                Object.assign(bullet, props);
                bullet.dead = false;
                if (bullet.isFlame && !Array.isArray(bullet.particles)) {
                    bullet.particles = [];
                }
                store.bullets.push(bullet);
                return bullet;
            }

            function getEBulletFromPool(props = {}) {
                let bullet;
                if (store.eBulletPool.length > 0) {
                    bullet = store.eBulletPool.pop();
                    // Reset all properties to default
                    Object.assign(bullet, {
                        x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                        dmg: 0, dead: false, life: undefined,
                        fadeInTime: undefined, spawnTime: undefined,
                        bounceCount: 0, maxBounces: 0, type: undefined
                    });
                } else {
                    bullet = {
                        x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                        dmg: 0, dead: false
                    };
                }

                // Apply custom properties
                Object.assign(bullet, props);
                return bullet;
            }

            function returnEBulletToPool(bullet) {
                if (store.eBulletPool.length < 1000) { // Cap pool size
                    store.eBulletPool.push(bullet);
                }
            }

            // PERFORMANCE: Effect pooling for createEffect() calls
            function getEffectFromPool(type, x, y, extra) {
                let effect;
                if (store.effectPool.length > 0) {
                    effect = store.effectPool.pop();
                    effect.type = type;
                    effect.x = x;
                    effect.y = y;
                    effect.extra = extra;
                    effect.isActive = true;
                    effect.dead = false;
                    effect.birth = performance.now();
                } else {
                    effect = createEffect(type, x, y, extra);
                }
                return effect;
            }

            function returnEffectToPool(effect) {
                if (store.effectPool.length < 50) { // Limit pool size
                    effect.isActive = false;
                    effect.dead = true;
                    store.effectPool.push(effect);
                }
            }

            // PERFORMANCE: Simple flame particle pooling
            function getTempFlameFromPool() {
                if (store.tempFlamePool.length > 0) {
                    return store.tempFlamePool.pop();
                }
                return {
                    x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, dead: false
                };
            }

            function returnTempFlameToPool(flame) {
                if (store.tempFlamePool.length < 100) {
                    flame.dead = true;
                    store.tempFlamePool.push(flame);
                }
            }

            const ENEMY_SPATIAL_KEY_MASK = 0xffff;

            function computeEnemySpatialKey(cellX, cellY) {
                return ((cellX & ENEMY_SPATIAL_KEY_MASK) << 16) | (cellY & ENEMY_SPATIAL_KEY_MASK);
            }

            function rebuildEnemySpatialIndex() {
                const spatial = store._enemySpatial;
                if (!spatial) return;

                const { buckets, usedKeys, cellSize } = spatial;

                for (let i = 0; i < usedKeys.length; i++) {
                    const key = usedKeys[i];
                    const bucket = buckets.get(key);
                    if (bucket) {
                        bucket.length = 0;
                    }
                }
                usedKeys.length = 0;

                const enemies = store.enemies;
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    if (!enemy || enemy.dead) continue;
                    const cellX = Math.floor(enemy.x / cellSize);
                    const cellY = Math.floor(enemy.y / cellSize);
                    const key = computeEnemySpatialKey(cellX, cellY);
                    let bucket = buckets.get(key);
                    if (!bucket) {
                        bucket = [];
                        buckets.set(key, bucket);
                    }
                    bucket.push(enemy);
                    if (bucket.length === 1) {
                        usedKeys.push(key);
                    }
                }
            }

            function forEachEnemyNearby(x, y, radius, iterator) {
                const spatial = store._enemySpatial;
                if (!spatial) return;

                const { buckets, cellSize } = spatial;
                const minCellX = Math.floor((x - radius) / cellSize);
                const maxCellX = Math.floor((x + radius) / cellSize);
                const minCellY = Math.floor((y - radius) / cellSize);
                const maxCellY = Math.floor((y + radius) / cellSize);

                for (let cellX = minCellX; cellX <= maxCellX; cellX++) {
                    for (let cellY = minCellY; cellY <= maxCellY; cellY++) {
                        const key = computeEnemySpatialKey(cellX, cellY);
                        const bucket = buckets.get(key);
                        if (!bucket || bucket.length === 0) continue;
                        for (let i = 0; i < bucket.length; i++) {
                            const enemy = bucket[i];
                            if (!enemy || enemy.dead) continue;
                            if (iterator(enemy) === true) {
                                return;
                            }
                        }
                    }
                }
            }

            function getBulletSearchRadius(bullet) {
                if (bullet.collisionSearchRadius != null) {
                    return bullet.collisionSearchRadius;
                }

                let radius = 140;
                if (bullet.r) radius += bullet.r;
                if (bullet.explosive) radius = Math.max(radius, 230);
                if (bullet.isLevelUpPulse) radius = Math.max(radius, 260);
                if (bullet.isFlame) radius = Math.max(radius, 220);
                if (bullet.isDrone) radius = Math.max(radius, 200);

                return Math.max(120, Math.min(radius, 320));
            }

            function applyChampionOnHitEffects(bullet, enemy, context) {
                if (!bullet || !enemy || enemy.dead || enemy.hp <= 0) return;
                if (!bullet.isChampionShot) return;

                const championLevel = Math.max(1, bullet.championLevel || context.championLevel || (store.playerChampion?.level || 1));
                const baseDamage = Math.max(0, context.baseDamage || bullet.dmg || 0);
                const finalDamage = Math.max(0, context.finalDamage || bullet.dmg || 0);
                if (finalDamage <= 0) return;

                const moduleId = bullet.championAttackModule || getChampionUpgradeState().attackModule;
                if (!bullet.skipChampionEffects) {
                    switch (moduleId) {
                        // KINETIC MODULES
                        case 'precision_strike':
                            applyPrecisionStrike(enemy, { finalDamage, championLevel });
                            break;
                        case 'kinetic_swarm':
                            applyKineticSwarm(enemy, { finalDamage, championLevel });
                            break;

                        // FIRE MODULES
                        case 'inferno_burst':
                            applyInfernoBurst(bullet, enemy, { finalDamage, championLevel });
                            break;
                        case 'plasma_stream':
                            applyPlasmaStream(enemy, { finalDamage, championLevel });
                            break;

                        // LASER MODULES
                        case 'focus_beam':
                            applyFocusBeam(enemy, { finalDamage, championLevel });
                            break;
                        case 'scatter_array':
                            applyScatterArray(bullet, enemy, { finalDamage, championLevel });
                            break;

                        // LIGHTNING MODULES
                        case 'arc_cannon':
                            applyArcCannon(bullet, enemy, { finalDamage, championLevel });
                            break;
                        case 'storm_grid':
                            applyStormGrid(bullet, enemy, { finalDamage, championLevel });
                            break;

                        // LEGACY MODULES (for backwards compatibility)
                        case 'ember':
                            applyPlasmaStream(enemy, { finalDamage, championLevel }); // Map to plasma stream
                            break;
                        case 'tempest':
                            applyArcCannon(bullet, enemy, { finalDamage, championLevel }); // Map to arc cannon
                            break;
                        case 'void':
                            applyChampionVoidResonance(bullet, enemy, { baseDamage, finalDamage, championLevel });
                            break;
                        default:
                            break;
                    }
                }

                if (bullet.fromChampionMinion) {
                    applyChampionMinionProtocols(bullet, enemy, {
                        baseDamage,
                        championLevel
                    });
                }
            }

            function applyChampionEmberBurn(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;
                const now = performance.now();
                const duration = 2.8 + (championLevel - 1) * 0.6;
                const tickInterval = Math.max(0.28, 0.54 - championLevel * 0.05);
                const damagePerTick = Math.max(8, finalDamage * (0.2 + (championLevel - 1) * 0.05));

                let burn = enemy.championBurn;
                if (!burn) {
                    burn = enemy.championBurn = {};
                }
                burn.timer = Math.max(burn.timer || 0, duration);
                burn.tickInterval = tickInterval;
                burn.tickTimer = Math.min(burn.tickTimer ?? tickInterval, tickInterval * 0.5);
                burn.damagePerTick = Math.max(burn.damagePerTick || 0, damagePerTick);
                burn.lethalFloor = enemy === store.boss ? 0 : 1;
                burn.level = championLevel;
                burn.lastApplied = now;

                if (!burn.visualCooldown || now - burn.visualCooldown > 120) {
                    store.activeEffects.push(createEffect('jugFearEmber', enemy.x, enemy.y, (enemy.r || 18) * 1.1));
                    burn.visualCooldown = now;
                }
            }

            function applyChampionTempestChain(bullet, sourceEnemy, { finalDamage, championLevel }) {
                if (!sourceEnemy || sourceEnemy.dead || sourceEnemy.hp <= 0 || finalDamage <= 0) return;
                const radius = 220 + (championLevel - 1) * 35;
                const maxTargets = 2;
                const chainDamage = finalDamage * 0.6;
                if (chainDamage <= 0) return;

                if (!bullet._tempestVisited) bullet._tempestVisited = new Set();
                const visited = bullet._tempestVisited;
                visited.add(sourceEnemy.id || sourceEnemy);

                const candidates = [];
                forEachEnemyNearby(sourceEnemy.x, sourceEnemy.y, radius, enemy => {
                    if (!enemy || enemy === sourceEnemy || enemy.dead || enemy.hp <= 0) return false;
                    const key = enemy.id || enemy;
                    if (visited.has(key)) return false;
                    const dx = enemy.x - sourceEnemy.x;
                    const dy = enemy.y - sourceEnemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        candidates.push({ enemy, dist });
                    }
                    return false;
                });

                if (store.boss && store.boss !== sourceEnemy && !store.boss.dead) {
                    const dx = store.boss.x - sourceEnemy.x;
                    const dy = store.boss.y - sourceEnemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius + (store.boss.r || 50)) {
                        candidates.push({ enemy: store.boss, dist });
                    }
                }

                candidates.sort((a, b) => a.dist - b.dist);
                for (let i = 0; i < Math.min(maxTargets, candidates.length); i++) {
                    const target = candidates[i].enemy;
                    const key = target.id || target;
                    if (visited.has(key)) continue;
                    visited.add(key);
                    championDealDamage(target, chainDamage, {
                        x: sourceEnemy.x,
                        y: sourceEnemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });
                    store.activeEffects.push(createEffect('lightning', sourceEnemy.x, sourceEnemy.y, 18, {
                        targetX: target.x,
                        targetY: target.y,
                        strength: 42
                    }));
                }
            }

            function applyChampionVoidResonance(bullet, enemy, { baseDamage, finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;
                if (!enemy.championVoidMarks) {
                    enemy.championVoidMarks = { stacks: 0, timer: 0, level: championLevel };
                }
                const state = enemy.championVoidMarks;
                state.stacks = (state.stacks || 0) + 1;
                state.timer = 4.5;
                state.level = championLevel;
                state.lastDamage = finalDamage;
                store.activeEffects.push(createEffect('voidLockChains', enemy.x, enemy.y, (enemy.r || 18) * 1.1));

                if (state.stacks >= 3) {
                    detonateChampionVoidResonance(bullet, enemy, state, { baseDamage, finalDamage, championLevel });
                }
            }

            function detonateChampionVoidResonance(bullet, enemy, state, { baseDamage, finalDamage, championLevel }) {
                state.stacks = 0;
                state.timer = 0;
                const primaryDamage = Math.max(0, finalDamage * (0.75 + (championLevel - 1) * 0.12));
                const splashDamage = Math.max(0, baseDamage * (0.45 + (championLevel - 1) * 0.1));
                const radius = 130 + (championLevel - 1) * 28;
                const originX = enemy.x;
                const originY = enemy.y;

                championDealDamage(enemy, primaryDamage, {
                    x: originX,
                    y: originY,
                    skipChampionEffects: true,
                    sourceAttackModule: bullet.championAttackModule,
                    championLevel
                });
                enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 3.2);
                enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 1, 3);

                const radiusSq = radius * radius;
                forEachEnemyNearby(originX, originY, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const dx = candidate.x - originX;
                    const dy = candidate.y - originY;
                    if (dx * dx + dy * dy > radiusSq) return false;
                    championDealDamage(candidate, splashDamage, {
                        x: originX,
                        y: originY,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });
                    candidate.railgunArmorTimer = Math.max(candidate.railgunArmorTimer || 0, 2.0);
                    candidate.railgunCrackLevel = Math.min((candidate.railgunCrackLevel || 0) + 1, 3);
                    store.activeEffects.push(createEffect('voidLockChains', candidate.x, candidate.y, candidate.r || 18));
                    return false;
                });

                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dxB = store.boss.x - originX;
                    const dyB = store.boss.y - originY;
                    if (dxB * dxB + dyB * dyB <= Math.pow(radius + (store.boss.r || 60), 2)) {
                        championDealDamage(store.boss, splashDamage, {
                            x: originX,
                            y: originY,
                            skipChampionEffects: true,
                            sourceAttackModule: bullet.championAttackModule,
                            championLevel
                        });
                        store.boss.railgunArmorTimer = Math.max(store.boss.railgunArmorTimer || 0, 3.0);
                        store.activeEffects.push(createEffect('voidLockChains', store.boss.x, store.boss.y, (store.boss.r || 60) * 1.2));
                    }
                }

                store.activeEffects.push(createEffect('hitSpark', originX, originY, Math.max(enemy.r || 22, radius * 0.6), { strength: 70 }));
            }

            function applyChampionMinionProtocols(bullet, enemy, { baseDamage, championLevel }) {
                const protocolLevel = bullet.minionProtocolLevel || 0;
                if (protocolLevel <= 0) return;

                if (bullet.minionProtocolSlowFactor) {
                    const slowDuration = 0.55 + protocolLevel * 0.18;
                    enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, bullet.minionProtocolSlowFactor);
                    enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
                    store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, enemy.r || 16, { strength: 30 }));
                }

                if (protocolLevel >= 2 && bullet.minionProtocolNovaDamageScale > 0) {
                    const splashDamage = Math.max(0, baseDamage * bullet.minionProtocolNovaDamageScale);
                    if (splashDamage <= 0) return;
                    const radius = 95 + 14 * Math.max(0, championLevel - 1);
                    const radiusSq = radius * radius;
                    forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                        if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                        const dx = candidate.x - enemy.x;
                        const dy = candidate.y - enemy.y;
                        if (dx * dx + dy * dy > radiusSq) return false;
                        championDealDamage(candidate, splashDamage, {
                            x: enemy.x,
                            y: enemy.y,
                            skipChampionEffects: true,
                            sourceAttackModule: bullet.championAttackModule,
                            championLevel
                        });
                        return false;
                    });

                    if (store.boss && store.boss !== enemy && !store.boss.dead) {
                        const dxB = store.boss.x - enemy.x;
                        const dyB = store.boss.y - enemy.y;
                        if (dxB * dxB + dyB * dyB <= Math.pow(radius + (store.boss.r || 60), 2)) {
                            championDealDamage(store.boss, splashDamage, {
                                x: enemy.x,
                                y: enemy.y,
                                skipChampionEffects: true,
                                sourceAttackModule: bullet.championAttackModule,
                                championLevel
                            });
                        }
                    }

                    store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, Math.max(enemy.r || 18, radius * 0.65), { strength: 55 }));
                }
            }

            function tickChampionBurn(target, dt) {
                if (!target || !target.championBurn) return;
                const burn = target.championBurn;
                if (!burn || burn.timer <= 0) {
                    target.championBurn = null;
                    return;
                }

                burn.timer = Math.max(0, burn.timer - dt);
                burn.tickTimer = (burn.tickTimer ?? burn.tickInterval ?? 0.5) - dt;
                const interval = burn.tickInterval || 0.5;
                const lethalFloor = burn.lethalFloor ?? (target === store.boss ? 0 : 1);
                const level = burn.level || 1;

                while (burn.timer > 0 && burn.tickTimer <= 0) {
                    burn.tickTimer += interval;
                    const allowable = Math.max(0, (target.hp ?? 0) - lethalFloor);
                    const tickDamage = Math.min(allowable, burn.damagePerTick || 0);
                    if (tickDamage > 0) {
                        store.activeEffects.push(createEffect('jugFearEmber', target.x, target.y, (target.r || 18) * 1.05));
                        championDealDamage(target, tickDamage, {
                            x: target.x,
                            y: target.y,
                            skipChampionEffects: true,
                            sourceAttackModule: 'ember',
                            championLevel: level
                        });
                    } else {
                        break;
                    }
                }

                if (burn.timer <= 0) {
                    target.championBurn = null;
                }
            }

            function tickChampionVoidMarks(target, dt) {
                if (!target || !target.championVoidMarks) return;
                const state = target.championVoidMarks;
                state.timer = Math.max(0, (state.timer || 0) - dt);
                if (state.timer <= 0) {
                    target.championVoidMarks = null;
                }
            }

            function tickChampionStormGrid(target, dt) {
                if (!target || !target.stormField) return;
                const field = target.stormField;

                field.duration = Math.max(0, field.duration - dt);
                if (field.duration <= 0) {
                    target.stormField = null;
                    return;
                }

                field.tickTimer = Math.max(0, field.tickTimer - dt);
                if (field.tickTimer <= 0) {
                    field.tickTimer = field.tickInterval;

                    // Apply damage to all enemies in the field area
                    const radiusSq = field.radius * field.radius;
                    store.enemies.forEach(enemy => {
                        if (!enemy || enemy.dead || enemy.hp <= 0) return;
                        const dx = enemy.x - field.x;
                        const dy = enemy.y - field.y;
                        if (dx * dx + dy * dy <= radiusSq) {
                            const allowable = Math.max(0, enemy.hp - (enemy === store.boss ? 0 : 1));
                            const tickDamage = Math.min(allowable, field.tickDamage);
                            if (tickDamage > 0) {
                                championDealDamage(enemy, tickDamage, {
                                    x: field.x,
                                    y: field.y,
                                    skipChampionEffects: true,
                                    sourceAttackModule: 'storm_grid',
                                    championLevel: field.level
                                });

                                // Visual feedback
                                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, 18));
                            }
                        }
                    });

                    // Also check boss
                    if (store.boss && !store.boss.dead) {
                        const dx = store.boss.x - field.x;
                        const dy = store.boss.y - field.y;
                        const bossRadius = store.boss.r || 50;
                        if (dx * dx + dy * dy <= Math.pow(field.radius + bossRadius, 2)) {
                            const tickDamage = field.tickDamage;
                            if (tickDamage > 0) {
                                championDealDamage(store.boss, tickDamage, {
                                    x: field.x,
                                    y: field.y,
                                    skipChampionEffects: true,
                                    sourceAttackModule: 'storm_grid',
                                    championLevel: field.level
                                });

                                store.activeEffects.push(createEffect('stormDischarge', store.boss.x, store.boss.y, 24));
                            }
                        }
                    }
                }
            }

            // NEW ATTACK MODULE FUNCTIONS

            // KINETIC MODULES
            function applyPrecisionStrike(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Precision Strike: Armor-piercing massive damage
                enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 4.5);
                enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 2, 3);

                // Visual effect for armor penetration
                const flashLevel = Math.max(1, Math.min(enemy.railgunCrackLevel || 1, 3));
                store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, flashLevel));
                store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, 20, { strength: 52 }));
            }

            function applyKineticSwarm(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Kinetic Swarm: Rapid fire effect with small visual impact
                const intensity = Math.min(4, championLevel);
                store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, 14, { strength: 18 + intensity * 4 }));
            }

            // FIRE MODULES
            function applyInfernoBurst(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Inferno Burst: Area explosion with burn
                const radius = 150 + (championLevel - 1) * 30;
                const splashDamage = finalDamage * (0.6 + (championLevel - 1) * 0.1);
                const burnDuration = 3.5 + (championLevel - 1) * 0.8;
                const burnDamagePerTick = finalDamage * (0.15 + (championLevel - 1) * 0.03);

                // Apply burn to primary target
                applyBurnEffect(enemy, burnDuration, burnDamagePerTick, championLevel);

                // Area damage and burn
                const radiusSq = radius * radius;
                forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const dx = candidate.x - enemy.x;
                    const dy = candidate.y - enemy.y;
                    if (dx * dx + dy * dy > radiusSq) return false;

                    championDealDamage(candidate, splashDamage, {
                        x: enemy.x,
                        y: enemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });
                    applyBurnEffect(candidate, burnDuration * 0.7, burnDamagePerTick * 0.8, championLevel);
                    return false;
                });

                // Boss splash
                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dxB = store.boss.x - enemy.x;
                    const dyB = store.boss.y - enemy.y;
                    if (dxB * dxB + dyB * dyB <= Math.pow(radius + (store.boss.r || 60), 2)) {
                        championDealDamage(store.boss, splashDamage, {
                            x: enemy.x,
                            y: enemy.y,
                            skipChampionEffects: true,
                            sourceAttackModule: bullet.championAttackModule,
                            championLevel
                        });
                        applyBurnEffect(store.boss, burnDuration * 0.7, burnDamagePerTick * 0.8, championLevel);
                    }
                }

                // Explosion effect (subtle)
                const visualRadius = Math.min(52, radius * 0.28);
                store.activeEffects.push(createEffect('jugFearEmber', enemy.x, enemy.y, visualRadius));
                store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, visualRadius * 0.9, { strength: 42 }));
            }

            function applyPlasmaStream(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Plasma Stream: Sustained burn (like old ember but balanced)
                const duration = 2.5 + (championLevel - 1) * 0.5;
                const tickInterval = Math.max(0.3, 0.5 - championLevel * 0.03);
                const damagePerTick = Math.max(6, finalDamage * (0.18 + (championLevel - 1) * 0.04));

                applyBurnEffect(enemy, duration, damagePerTick, championLevel, tickInterval);
                store.activeEffects.push(createEffect('jugFearEmber', enemy.x, enemy.y, Math.min(24, (enemy.r || 18) * 0.9)));
            }

            // LASER MODULES
            function applyFocusBeam(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Focus Beam: Ignores all armor and shields, piercing damage
                enemy.laserIgnoreArmor = true; // Special flag for armor bypass
                enemy.railgunArmorTimer = 0; // Remove armor entirely
                enemy.railgunCrackLevel = 3; // Maximum armor crack

                // Piercing laser effect
                store.activeEffects.push(createEffect('laser', enemy.x, enemy.y, 18, {
                    targetX: enemy.x,
                    targetY: enemy.y - 40,
                    duration: 0.65,
                    strength: 62
                }));
                store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, 3));
            }

            function applyScatterArray(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Scatter Array: Hit multiple nearby targets
                const maxTargets = 2 + Math.floor((championLevel - 1) / 2);
                const radius = 200 + (championLevel - 1) * 25;
                const scatterDamage = finalDamage * (0.75 + (championLevel - 1) * 0.05);

                if (!bullet._scatterVisited) bullet._scatterVisited = new Set();
                const visited = bullet._scatterVisited;
                visited.add(enemy.id || enemy);

                const candidates = [];
                forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const key = candidate.id || candidate;
                    if (visited.has(key)) return false;
                    const dx = candidate.x - enemy.x;
                    const dy = candidate.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        candidates.push({ enemy: candidate, dist });
                    }
                    return false;
                });

                // Include boss
                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dx = store.boss.x - enemy.x;
                    const dy = store.boss.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius + (store.boss.r || 50)) {
                        candidates.push({ enemy: store.boss, dist });
                    }
                }

                candidates.sort((a, b) => a.dist - b.dist);
                for (let i = 0; i < Math.min(maxTargets, candidates.length); i++) {
                    const target = candidates[i].enemy;
                    const key = target.id || target;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    championDealDamage(target, scatterDamage, {
                        x: enemy.x,
                        y: enemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });

                    // Laser beam to each target
                    store.activeEffects.push(createEffect('laser', enemy.x, enemy.y, 14, {
                        targetX: target.x,
                        targetY: target.y,
                        duration: 0.35,
                        strength: 46
                    }));
                }
            }

            // LIGHTNING MODULES
            function applyArcCannon(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Arc Cannon: High primary damage + chain (like improved tempest)
                const radius = 250 + (championLevel - 1) * 40;
                const maxTargets = 2 + Math.floor((championLevel - 1) / 3);
                const chainDamage = finalDamage * (0.65 + (championLevel - 1) * 0.05);

                if (!bullet._arcVisited) bullet._arcVisited = new Set();
                const visited = bullet._arcVisited;
                visited.add(enemy.id || enemy);

                const candidates = [];
                forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const key = candidate.id || candidate;
                    if (visited.has(key)) return false;
                    const dx = candidate.x - enemy.x;
                    const dy = candidate.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        candidates.push({ enemy: candidate, dist });
                    }
                    return false;
                });

                // Include boss
                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dx = store.boss.x - enemy.x;
                    const dy = store.boss.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius + (store.boss.r || 50)) {
                        candidates.push({ enemy: store.boss, dist });
                    }
                }

                candidates.sort((a, b) => a.dist - b.dist);
                for (let i = 0; i < Math.min(maxTargets, candidates.length); i++) {
                    const target = candidates[i].enemy;
                    const key = target.id || target;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    championDealDamage(target, chainDamage, {
                        x: enemy.x,
                        y: enemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });

                    // Lightning arc effect
                    store.activeEffects.push(createEffect('lightning', enemy.x, enemy.y, 18, {
                        targetX: target.x,
                        targetY: target.y,
                        strength: 46
                    }));
                }

                // Primary target effect
                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, 22));
            }

            function applyStormGrid(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Storm Grid: Creates persistent electrical field
                const fieldDuration = 4.0 + (championLevel - 1) * 0.8;
                const fieldRadius = 120 + (championLevel - 1) * 20;
                const tickDamage = finalDamage * (0.25 + (championLevel - 1) * 0.03);

                // Create or update storm field at impact location
                let field = enemy.stormField;
                if (!field) {
                    field = enemy.stormField = {
                        x: enemy.x,
                        y: enemy.y,
                        radius: fieldRadius,
                        duration: fieldDuration,
                        tickDamage: tickDamage,
                        tickInterval: 0.4,
                        tickTimer: 0.4,
                        level: championLevel
                    };
                } else {
                    field.duration = Math.max(field.duration, fieldDuration);
                    field.tickDamage = Math.max(field.tickDamage, tickDamage);
                }

                // Visual storm effect
                const pulseRadius = Math.min(40, fieldRadius * 0.35);
                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, pulseRadius));
            }

            // HELPER FUNCTION for burn effects
            function applyBurnEffect(enemy, duration, damagePerTick, championLevel, tickInterval = 0.5) {
                if (!enemy || enemy.dead || enemy.hp <= 0) return;

                let burn = enemy.championBurn;
                if (!burn) {
                    burn = enemy.championBurn = {};
                }
                burn.timer = Math.max(burn.timer || 0, duration);
                burn.tickInterval = tickInterval;
                burn.tickTimer = Math.min(burn.tickTimer ?? tickInterval, tickInterval * 0.5);
                burn.damagePerTick = Math.max(burn.damagePerTick || 0, damagePerTick);
                burn.lethalFloor = enemy === store.boss ? 0 : 1;
                burn.level = championLevel;
                burn.lastApplied = performance.now();
            }

            function applyBossDamage(boss, amount, options = {}) {
                if (!boss || amount <= 0) return { amount: 0, blocked: false };

                if (!options.skipShield && boss.behavior === 'aegis_architect') {
                    const result = applyAegisShieldDamage(boss, amount, options);
                    if (result && result.blocked) {
                        return { amount: result.damageApplied || 0, blocked: true };
                    }
                }

                boss.hp = Math.max(0, boss.hp - amount);
                store.world.totalDamage += amount;
                if (boss.hp <= 0) {
                    handleBossDefeat();
                }
                return { amount, blocked: false };
            }

            function handleBulletImpact(b, e) {
                if (b.isFlame) e.slowTimer = 1.0;

                if (e.isHeatDeath) {
                    b.dead = true;
                    return;
                }

                if (e === store.boss && e.isInvincible) {
                    b.dead = true;
                    return;
                }

                let dmg = b.dmg || 15;
                if (b.isChampionShot && b.vulnerabilityProfile && e) {
                    dmg = applyChampionVulnerabilityScaling(dmg, e, b.vulnerabilityProfile);
                }
                let didCrit = false;
                if (e === store.boss && b.isDrone) dmg *= 0.4;

                if (Math.random() < store.player.critChance) {
                    dmg *= store.player.critDamage;
                    didCrit = true;
                    store.activeEffects.push(createEffect('critText', e.x, e.y));
                    if (Math.random() < 0.05) spawnPowerup(e.x, e.y);
                }

                if (e === store.boss) playSound('hit');
                const subclass = store.player.subclass;
                let bulletTags;
                switch (subclass) {
                    case 'juggernaut':
                        bulletTags = ['fire', 'explosive'];
                        break;
                    case 'marauder':
                        bulletTags = ['kinetic', 'concussive'];
                        break;
                    case 'railgunner':
                        bulletTags = ['kinetic', 'explosive'];
                        break;
                    case 'demolitioner':
                        bulletTags = ['fire', 'explosive'];
                        break;
                    case 'phasestriker':
                        bulletTags = ['void', 'magic'];
                        break;
                    case 'stormbringer':
                        bulletTags = ['lightning', 'magic'];
                        break;
                    default:
                        bulletTags = b.explosive ? ['fire', 'explosive'] : ['kinetic'];
                }
                const vulnBullet = applySubclassVulnerability(e, dmg, {
                    subclass,
                    player: store.player,
                    damageTags: bulletTags,
                    source: b.explosive ? 'explosiveBullet' : 'bullet',
                    projectile: b,
                    baseDamage: dmg
                });
                dmg = vulnBullet.damage;
                if (e === store.boss && e.behavior === 'aegis_architect') {
                    const interceptResult = tryAegisShieldInterceptBullet(e, b, dmg);
                    if (interceptResult && interceptResult.blocked) {
                        if (store.player.pilotGenome === 'beef') {
                            store.player.beefShieldDamageDealt += interceptResult.damageApplied;
                        }
                        if (store.player.vampirism > 0) {
                            let healAmount = interceptResult.damageApplied * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1);
                            healAmount = Math.min(healAmount, 5);
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        if (b.isChampionShot) {
                            applyChampionOnHitEffects(b, e, {
                                baseDamage: b.dmg || dmg,
                                finalDamage: interceptResult.damageApplied,
                                championLevel: b.championLevel || (store.playerChampion?.level || 1)
                            });
                        }
                        return;
                    }
                }

                if (e === store.boss) {
                    const bossDamageResult = applyBossDamage(e, dmg, {
                        point: { x: b.x, y: b.y },
                        skipShield: true
                    });
                    dmg = bossDamageResult.amount;
                } else {
                    e.hp -= dmg;
                }

                if (dmg > 0) {
                    const impactAngle = Math.atan2(e.y - b.y, e.x - b.x);
                    registerEnemyHit(e, {
                        angle: impactAngle,
                        knockbackStrength: 0,
                        shakeIntensity: b.explosive ? 6 : 3.5,
                        shakeDuration: b.explosive ? 0.22 : 0.14,
                        slowFactor: b.explosive ? 0.8 : 0.9,
                        slowDuration: b.explosive ? 0.22 : 0.12,
                        crit: didCrit,
                        effect: false
                    });

                    if (store.player.pilotGenome === 'beef') {
                        store.player.beefShieldDamageDealt += dmg;
                    }

                    if (store.player.vampirism > 0) {
                        let healAmount = dmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 1);
                        healAmount = Math.min(healAmount, 5);
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }

                    if (b.isChampionShot) {
                        applyChampionOnHitEffects(b, e, {
                            baseDamage: b.dmg || dmg,
                            finalDamage: dmg,
                            championLevel: b.championLevel || (store.playerChampion?.level || 1)
                        });
                    }

                    if (e !== store.boss && e.hp <= 0) {
                        e.dead = true;
                        if (e.type === 'void_champion') {
                            store.enemies.forEach(minion => {
                                if (minion.orbitTargetId === e.id && !minion.dead) {
                                    spawnGibs(minion.x, minion.y, minion.color);
                                    minion.dead = true;
                                }
                            });
                            handleVoidChampionReward(e);
                        }

                        if (e.type === 'shadow_champion') {
                            store.shadowChampionDefeated = true;
                            store.shadowChampionLastPos = { x: e.x, y: e.y };
                            store.shadowChampionId = null;
                            if (!store.shadowChampionTokenDropped) {
                                addShadowEcho(e.x, e.y);
                                announce('Champion sigil destabilized!');
                            }
                        }

                        const isVoidReaper = e.type === 'void_reaper';
                        if (isVoidReaper) {
                            finalizeVoidReaperDefeat(e, { preemptive: !e.lungeStarted });
                        }

                        if (!isVoidReaper) {
                            spawnGibs(e.x, e.y, e.color);
                        }
                        const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                        const scoreGain = Math.floor((Number.isFinite(e.score) ? e.score : 0) * collarBonus);
                        const goldGain = Math.floor((Number.isFinite(e.gold) ? e.gold : 0) * collarBonus);
                        const xpGain = Math.floor((Number.isFinite(e.xp) ? e.xp : 0) * collarBonus);
                        if (scoreGain) store.world.score += scoreGain;
                        if (goldGain) addWorldGold(goldGain);
                        if (xpGain) store.world.xp += xpGain;
                        store.world.kills++;

                        if (e.type !== 'shadow_champion') {
                            spawnPowerup(e.x, e.y);
                        }
                        explode(e.x, e.y);
                    }
                }

                // Trigger Omega Multishot explosion on impact
                if (b.isOmegaShot && !b.omegaExplosionTriggered) {
                    triggerOmegaMultishotExplosion(b, e);
                    b.omegaExplosionTriggered = true; // Only explode once
                }
                
                if (b.explosive) explode(b.x, b.y, false, true);
                if (!b.pierce) b.dead = true;
            }

            const CLASS_DAMAGE_TAGS = {
                juggernaut: ['fire', 'explosive'],
                marauder: ['kinetic', 'concussive'],
                railgunner: ['kinetic', 'explosive'],
                demolitioner: ['fire', 'explosive'],
                phasestriker: ['void', 'magic'],
                stormbringer: ['lightning', 'magic']
            };

            const MARAUDER_VULNERABILITY_ALLOWED_SOURCES = new Set([
                'beefCharge',
                'beefChargeCombo',
                'missileImpact',
                'pierceMissile',
                'clusterMissile',
                'clusterDetonation',
                'voidLaser',
                'chainLightning'
            ]);

            function triggerJuggernautVulnerability(enemy, context) {
                enemy.jugFearTimer = Math.max(enemy.jugFearTimer || 0, 2.6);
                enemy.jugBurnTimer = Math.max(enemy.jugBurnTimer || 0, 3.5);
                enemy.jugBurnTick = 0;
                enemy.jugPulseTimer = Math.max(enemy.jugPulseTimer || 0, 3.0);
                enemy.jugPulsePhase = enemy.jugPulsePhase || 0;
                enemy.vulnerabilityPulseColor = '#ff3b3b';
                enemy.vulnerabilityPulseStrength = 1;
                store.activeEffects.push(createEffect('jugFearIgnite', enemy.x, enemy.y, enemy.r * 1.1));
            }

            function triggerMarauderVulnerability(enemy, context) {
                const angle = context.knockbackAngle ?? Math.atan2(enemy.y - store.player.y, enemy.x - store.player.x);
                const smashSpeed = 1100;
                const smashDuration = 0.55;
                enemy.knockback = {
                    vx: Math.cos(angle) * smashSpeed,
                    vy: Math.sin(angle) * smashSpeed,
                    duration: smashDuration,
                    type: 'maraLaunch'
                };
                enemy.maraLaunchTimer = smashDuration;
                enemy.maraImpactTriggered = false;
                enemy.vulnerabilityPulseColor = '#aad1ff';
                enemy.vulnerabilityPulseStrength = 0.8;
                store.activeEffects.push(createEffect('marauderLaunchTrail', enemy.x, enemy.y, { duration: smashDuration, enemy }));
            }

            function triggerRailgunnerVulnerability(enemy) {
                enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 4.0);
                enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 1, 3);
                enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.35);
                enemy.vulnerabilityPulseColor = '#d7f0ff';
                enemy.vulnerabilityPulseStrength = 0.6;
                store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, enemy.railgunCrackLevel));
            }

            function triggerDemolitionerVulnerability(enemy, context) {
                const fallbackPos = { x: enemy.x, y: enemy.y };
                const sourcePlayer = context.player || store.player;
                scheduleVulnerabilityEvent(0.7, () => {
                    const ref = enemy.dead ? fallbackPos : { x: enemy.x, y: enemy.y };
                    spawnFlamePulse(ref.x, ref.y, 95, context.baseDamage * 0.8, { player: sourcePlayer });
                });
                enemy.demolitionPulseWarmup = Math.max(enemy.demolitionPulseWarmup || 0, 0.7);
                enemy.vulnerabilityPulseColor = '#ffae5b';
                enemy.vulnerabilityPulseStrength = 0.7;
                store.activeEffects.push(createEffect('demolitionPulseCharge', enemy.x, enemy.y, enemy.r * 1.4));
            }

            function triggerPhaseStrikerVulnerability(enemy) {
                enemy.phaseLockTimer = Math.max(enemy.phaseLockTimer || 0, 2.4);
                enemy.phaseLockSlowFactor = 0.35;
                enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.5);
                enemy.vulnerabilityPulseColor = '#8f6bff';
                enemy.vulnerabilityPulseStrength = 0.9;
                store.activeEffects.push(createEffect('voidLockChains', enemy.x, enemy.y, enemy.r * 1.2));
            }

            function triggerStormbringerVulnerability(enemy, context) {
                enemy.stormShockTimer = Math.max(enemy.stormShockTimer || 0, 2.2);
                enemy.stormShockIntensity = 1;
                enemy.vulnerabilityPulseColor = '#6fd2ff';
                enemy.vulnerabilityPulseStrength = 1;
                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, enemy.r * 1.5));
                const targets = store.enemies.filter(en => !en.dead && en !== enemy);
                const arcTargets = targets.sort((a, b) => ((a.x - enemy.x) ** 2 + (a.y - enemy.y) ** 2) - ((b.x - enemy.x) ** 2 + (b.y - enemy.y) ** 2)).slice(0, 3);
                arcTargets.forEach(target => {
                    store.activeEffects.push(createEffect('stormArc', enemy.x, enemy.y, { x: target.x, y: target.y }));
                    target.stunTimer = Math.max(target.stunTimer || 0, 0.3);
                });
            }

            const ENEMY_VULNERABILITIES = {
                mech: {
                    juggernaut: {
                        multiplier: 1.6,
                        damageTags: ['fire', 'explosive'],
                        cooldownMs: 500,
                        onTrigger: triggerJuggernautVulnerability
                    }
                },
                manta: {
                    marauder: {
                        multiplier: 1.45,
                        damageTags: ['kinetic', 'concussive'],
                        cooldownMs: 400,
                        onTrigger: triggerMarauderVulnerability
                    }
                },
                phantom: {
                    railgunner: {
                        multiplier: 1.4,
                        damageTags: ['kinetic', 'explosive'],
                        cooldownMs: 350,
                        onTrigger: triggerRailgunnerVulnerability
                    }
                },
                void_champion_orb: {
                    demolitioner: {
                        multiplier: 1.35,
                        damageTags: ['fire', 'explosive'],
                        cooldownMs: 650,
                        onTrigger: triggerDemolitionerVulnerability
                    }
                },
                void_champion: {
                    phasestriker: {
                        multiplier: 1.5,
                        damageTags: ['void', 'magic'],
                        cooldownMs: 500,
                        onTrigger: triggerPhaseStrikerVulnerability
                    }
                },
                angler: {
                    stormbringer: {
                        multiplier: 1.4,
                        damageTags: ['lightning', 'magic'],
                        cooldownMs: 450,
                        onTrigger: triggerStormbringerVulnerability
                    }
                }
            };

            function scheduleVulnerabilityEvent(delay, action) {
                store.vulnerabilityEvents.push({ timer: delay, action });
            }

            function processVulnerabilityEvents(dt) {
                for (let i = store.vulnerabilityEvents.length - 1; i >= 0; i--) {
                    const evt = store.vulnerabilityEvents[i];
                    evt.timer -= dt;
                    if (evt.timer <= 0) {
                        try {
                            evt.action?.();
                        } catch (err) {
                            console.warn('Vulnerability event error', err);
                        }
                        store.vulnerabilityEvents.splice(i, 1);
                    }
                }
            }

            function spawnFlamePulse(x, y, radius = 90, damage = 40, context = {}) {
                store.activeEffects.push(createEffect('delayedFlamePulse', x, y, radius));
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                targets.forEach(enemy => {
                    if (!enemy || enemy.dead) return;
                    const distSq = (enemy.x - x) * (enemy.x - x) + (enemy.y - y) * (enemy.y - y);
                    if (distSq <= radius * radius) {
                        let dmg = damage;
                        if (enemy === store.boss) dmg *= 0.35;
                        const vuln = applySubclassVulnerability(enemy, dmg, {
                            subclass: 'demolitioner',
                            damageTags: ['fire', 'explosive'],
                            player: context.player,
                            source: 'demolitionPulse',
                            disableVulnerability: true
                        });
                        let applied = vuln.damage;
                        if (enemy === store.boss) {
                            const result = applyBossDamage(enemy, applied, {
                                point: { x, y }
                            });
                            if (result.blocked || result.amount <= 0) {
                                applied = 0;
                            } else {
                                applied = result.amount;
                            }
                        } else {
                            enemy.hp -= applied;
                        }

                        // Flame particles removed per user request - pulse visual effect remains
                    }
                });
            }

            function applySubclassVulnerability(enemy, baseDamage, context = {}) {
                if (context.disableVulnerability) {
                    return { damage: baseDamage, triggered: false };
                }

                const player = context.player || store.player;
                if (!player) {
                    return { damage: baseDamage, triggered: false };
                }

                const subclass = context.subclass || player.subclass;
                if (!subclass) {
                    return { damage: baseDamage, triggered: false };
                }

                const config = ENEMY_VULNERABILITIES[enemy.type];
                const subclassConfig = config && config[subclass];
                if (!subclassConfig) {
                    return { damage: baseDamage, triggered: false };
                }

                const appliedTags = context.damageTags || CLASS_DAMAGE_TAGS[subclass] || [];
                const matchesTag = appliedTags.some(tag => subclassConfig.damageTags.includes(tag));
                if (!matchesTag) {
                    return { damage: baseDamage, triggered: false };
                }

                const allowTriggerOverride = context.allowVulnerabilityTrigger;
                let allowTrigger = allowTriggerOverride !== undefined ? !!allowTriggerOverride : true;
                if (allowTrigger && subclass === 'marauder') {
                    const source = context.source;
                    if (!MARAUDER_VULNERABILITY_ALLOWED_SOURCES.has(source) && !context.forceVulnerabilityTrigger) {
                        allowTrigger = false;
                    }
                }

                enemy._lastVulnerabilityTrigger = enemy._lastVulnerabilityTrigger || {};
                const now = performance.now();
                const cooldown = subclassConfig.cooldownMs ?? 350;
                const lastTrigger = enemy._lastVulnerabilityTrigger[subclass] || 0;
                let triggered = false;
                if (allowTrigger && now - lastTrigger >= cooldown) {
                    enemy._lastVulnerabilityTrigger[subclass] = now;
                    triggered = true;
                    if (subclassConfig.onTrigger) {
                        subclassConfig.onTrigger(enemy, { ...context, baseDamage, player });
                    }
                }

                const damage = baseDamage * (subclassConfig.multiplier || 1);
                return { damage, triggered };
            }

            const LEVEL_UPGRADES = [
                { id: 'dmg', name: 'PLASMA CORE', icon: 'ðŸ’¥', desc: '+6% damage', apply: () => { store.player.dmgMult *= 1.06; } },
                { id: 'fire', name: 'OVERCLOCK', icon: 'ðŸ”¥', desc: '+6% fire rate', apply: () => { store.player.fireRate *= 0.60; } },
                {
                    id: 'multi', name: 'SCATTER PROTOCOL', icon: 'â˜„ï¸', desc: '+1 projectile', apply: () => {
                        const p = store.player;
                        if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                    }
                },
                { id: 'shield', name: 'VOID BARRIER', icon: 'ðŸ©µ', desc: 'BIG Shields', apply: () => { store.player.shieldMax *= 1.15 ; store.player.shieldMax += 50 ; store.player.shield = store.player.shieldMax; } },
                { id: 'flamethrower', name: 'LAVA CHUNKS', icon: 'ðŸŒ‹', desc: 'Spews chunks of molten rock in a cone.', apply: () => { store.player.flamethrowerLevel++; } }
            ];


            const SHOP_UPGRADES = {
                'repair': { name: "NANO REPAIR", icon: 'ðŸ”§', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
                'vampirism': {
                    name: "VAMPIRIC ROUNDS", icon: 'ðŸ©¸', isPremium: true, max: 4, category: 'utility',
                    apply: () => {
                        const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                        if (getWorldGold() >= cost && p.vampirismLevel < 4) { addWorldGold(-cost); p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
                    },
                    desc: () => {
                        const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                        const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
                    }
                },
                'hp': {
                    name: "MAX HP",
                    icon: 'â¤ï¸',
                    baseCost: 25,
                    scale: 1.1,
                    maxLevel: 20,
                    category: 'health',
                    effect: (level) => {
                        const p = store.player;
                        // Scale HP upgrades with current wave for late game viability
                        let hpIncrease = 10;
                        if (store.world.wave > 20) {
                            // After wave 20, HP upgrades scale with wave
                            hpIncrease = 10 + (store.world.wave - 20) * 2;
                        }
                        p.hpMax += hpIncrease;
                        p.hp += hpIncrease;
                        // console.log(`HP upgrade: +${hpIncrease} HP (wave ${store.world.wave})`);
                    },
                    desc: level => {
                        let hpIncrease = 10;
                        if (store.world.wave > 20) {
                            hpIncrease = 10 + (store.world.wave - 20) * 2;
                        }
                        return `+${hpIncrease} Max HP (Lvl ${level + 1})`;
                    }
                },
                'nano_save': { name: "NANO CHARGE", icon: 'ðŸ’¾', cost: 25, isPremium: true, max: 5, category: 'utility', apply: () => { if (store.player.nanoSaves < 5) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Blocks death, sets HP to 10, +15 max HP, opens shop. Charges: ${store.player.nanoSaves}/5` },
                'luck_boost': { name: "LUCK BOOST", icon: 'ðŸ€', baseCost: 50, scale: 2, maxLevel: 5, category: 'utility', effect: (level) => { store.player.luckBoost = (store.player.luckBoost || 0) + (0.15 / Math.pow(2, level)); }, desc: level => `+${(0.15 / Math.pow(2, level) * 100).toFixed(1)}% drop chance (Lvl ${level + 1})` },
                'dmg': { name: "DAMAGE", icon: 'ðŸ’ª', baseCost: 50, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.06, desc: level => `+6% Damage (Lvl ${level + 1})` },
                'crit_chance': { name: "SHINOBI REFLEXES", icon: 'ðŸ¥·', baseCost: 40, increment: 24, maxLevel: 10, category: 'attack', effect: () => { store.player.critChance *= 1.5; store.player.critDamage *= 1.5; }, desc: level => `+50% Crit Chance & Dmg (Lvl ${level + 1})` },
                'speed': { name: "SPEED", icon: 'ðŸš€', baseCost: 40, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
                'grenade': { 
                    name: "SHIELD PULSE", 
                    icon: 'âš¡ï¿½ï¸', 
                    cost: 70, 
                    isPremium: true, 
                    max: 3, 
                    category: 'attack', 
                    apply: () => { 
                        if (!store.empCharges) store.empCharges = []; 
                        if (store.empCharges.length < 3) { 
                            createEmpCharge(); 
                            return true; 
                        } else {
                            // At max capacity - recharge the charge with longest cooldown
                            let longestCooldownCharge = null;
                            let maxCooldown = 0;
                            for (const charge of store.empCharges) {
                                if (charge && !charge.dead && (charge.cooldown || 0) > maxCooldown) {
                                    maxCooldown = charge.cooldown;
                                    longestCooldownCharge = charge;
                                }
                            }
                            if (longestCooldownCharge) {
                                longestCooldownCharge.cooldown = 0; // Instantly recharge
                                announce('âš¡ Shield Pulse Recharged! âš¡');
                                return true;
                            }
                            return false;
                        }
                    }, 
                    desc: () => {
                        const count = store.empCharges?.length || 0;
                        if (count < 3) {
                            return `Add Shield Pulse charge (${count}/3). Auto-activates near threats.`;
                        } else {
                            return `Shield Pulse (3/3). Additional pickups recharge your longest cooldown.`;
                        }
                    }
                },
                'fragment_blast': { 
                    name: "FRAGMENT BLAST", 
                    icon: 'ðŸ’¥', 
                    baseCost: 80, 
                    scale: 2, 
                    maxLevel: 3, 
                    isPremium: true, 
                    category: 'attack',
                    effect: (level) => {
                        const p = store.player;
                        if (!p.fragmentBlasters) {
                            p.fragmentBlasters = [];
                        }
                        p.fragmentBlasters.push({
                            cooldown: 0,
                            maxCooldown: 10,
                            barrelDelay: 0,
                            meleeRange: 120,
                            triggerRange: 60
                        });
                    },
                    desc: level => {
                        if (level === 0) return 'Auto-firing shotgun blast when enemies get close (10s cooldown).';
                        if (level === 1) return 'Add 2nd barrel - fires 1s after first if enemies remain close.';
                        if (level === 2) return 'Add 3rd barrel - independent targeting for maximum coverage.';
                        return 'Max Level';
                    }
                },
                'max_shield': {
                    name: "MAX SHIELD",
                    icon: 'ðŸ›¡ï¸',
                    baseCost: 30,
                    scale: 1.2,
                    maxLevel: 20, // Increased max level
                    category: 'health',
                    effect: (level) => {
                        const p = store.player;
                        if (level < 5) {
                            // First 5 levels: +25 flat shield
                            p.shieldMax += 25;
                            p.shield += 25;
                        } else {
                            // Levels 6+: +25% of current max shield
                            const increase = Math.floor(p.shieldMax * 0.25);
                            p.shieldMax += increase;
                            p.shield += increase;
                        }
                    },
                    desc: level => {
                        if (level < 5) {
                            return `+25 Max Shield (Lvl ${level + 1})`;
                        } else {
                            return `+25% Max Shield (Lvl ${level + 1})`;
                        }
                    }
                },
                'rear_guard': { name: 'AFT FLANKSHIELD', icon: 'ðŸ›¡ï¸âœ¨', baseCost: 130, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
                'launcher': {
                    name: 'FRAG LAUNCHER',
                    icon: 'ðŸ’¥',
                    baseCost: 100,
                    scale: 2,
                    maxLevel: 3,
                    category: 'attack',
                    effect: () => {
                        store.player.hasLauncher = true;
                    },
                    desc: level => {
                        if (level === 0) return `Unlocks launcher (2 projectiles).`;
                        if (level === 1) return `Add 2 projectiles (4 total).`;
                        if (level === 2) return `Add 2 more projectiles (6 total).`;
                        return "Max projectiles reached.";
                    }
                },
                'star_cannon': {
                    name: 'STAR CANNON',
                    icon: 'ðŸŒ ',
                    baseCost: 150,
                    scale: 1.5,
                    maxLevel: STAR_CANNON_LEVEL_CAP,
                    category: 'attack',
                    effect: level => {
                        const p = store.player;
                        const nextLevel = Math.min(level + 1, STAR_CANNON_LEVEL_CAP);
                        const previous = p.starCannonLevel || 0;
                        if (nextLevel > previous) {
                            p.starCannonLevel = nextLevel;
                        }
                        p.starCannonTimer = 0;
                        if (!p.starCannonNextSide) {
                            p.starCannonNextSide = 'left';
                        }
                        p.starCannonIcemanSupport = p.starCannonLevel >= 3;
                        const cooldownMsg = getStarCannonCooldown(p.starCannonLevel).toFixed(1);
                        let message;
                        if (nextLevel === 1) {
                            message = 'STAR CANNON ONLINE!';
                        } else if (nextLevel === 2) {
                            message = 'STAR CANNON MKII - Alternating Barrage!';
                        } else if (nextLevel === 3) {
                            message = 'STAR CANNON MKIII - Blizzard Sync!';
                        } else {
                            message = `STAR CANNON CALIBRATION MK${pad(nextLevel)} â–¸ Reload ${cooldownMsg}s`;
                        }
                        announce(message);
                    },
                    desc: level => {
                        const upcomingLevel = Math.min(level + 1, STAR_CANNON_LEVEL_CAP);
                        const cooldown = getStarCannonCooldown(upcomingLevel).toFixed(1);
                        if (upcomingLevel === 1) return 'Left-side artillery platform (7.0s reload).';
                        if (upcomingLevel === 2) return 'Unlock right cannon and alternating salvo pattern.';
                        if (upcomingLevel === 3) return 'Iceman mirrors your salvos with frosty stars.';
                        const bursts = getStarCannonBurstCount(upcomingLevel);
                        return `Calibration Mk${pad(upcomingLevel)} â–¸ ${bursts} alternating blasts â€¢ ${cooldown}s reload.`;
                    }
                },
                'iceman': { 
                    name: "THE ICEMAN", 
                    icon: 'â„ï¸', 
                    baseCost: 118, 
                    scale: 2, 
                    maxLevel: 3, 
                    isPremium: true, 
                    category: 'utility', 
                    effect: (level) => { 
                        const p = store.player;
                        if (!p.hasIceman) { 
                            // First purchase - initialize everything
                            p.hasIceman = true;
                            p.icemanFireT = 0;
                            store.iceman = { 
                                x: p.x, 
                                y: p.y + 50, 
                                t: 0, 
                                level: 1 
                            }; 
                            announce('â„ï¸ Iceman is your wingman!');
                            console.log('Iceman initialized:', store.iceman, 'fireT:', p.icemanFireT);
                        } else {
                            // Upgrade existing iceman
                            if (!store.iceman) {
                                // Safety: recreate iceman if somehow missing
                                store.iceman = { 
                                    x: p.x, 
                                    y: p.y + 50, 
                                    t: 0, 
                                    level: 1 
                                };
                                console.warn('Iceman was missing, recreated');
                            }
                            store.iceman.level = (store.iceman.level || 1) + 1;
                            announce(`â„ï¸ Iceman upgraded to level ${store.iceman.level}!`);
                            console.log('Iceman upgraded to level:', store.iceman.level);
                        }
                        // Always ensure fireT is a valid number
                        if (typeof p.icemanFireT !== 'number' || isNaN(p.icemanFireT)) {
                            p.icemanFireT = 0;
                        }
                    }, 
                    desc: level => { 
                        if (level === 0) return 'Val Kilmer mirrors your attacks.'; 
                        if (level === 1) return 'Iceman fires 50% faster.'; 
                        if (level === 2) return 'Iceman deals 50% more damage.'; 
                        return 'Max Level'; 
                    } 
                },
                'lazarus_beam': { name: "LORD LAZARUS", icon: 'â˜¢ï¸â˜„ï¸â˜¢ï¸', baseCost: 200, scale: 3, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Summon Lord Lazarus who fires devastating energy beams across the battlefield.'; if (level === 1) return 'Lazarus fires twice as often and launches dual beams.'; return 'Max Level'; } },
                'magnet_pull': { name: "GRAV-PULSE", icon: 'ðŸ§²', cost: 90, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
                'gravity_well': { name: "GRAVITY WELL", icon: 'ðŸ•³ï¸', baseCost: 300, scale: 2, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Unleash a singularity that traps and crushes foes.'; if (level === 1) return 'Summon a second, smaller singularity.'; return 'Max Level'; } },
                'ghost_hounds': {
                    name: "GHOST HOUNDS",
                    icon: 'ðŸ‘»ðŸº',
                    baseCost: 150,
                    scale: 2,
                    maxLevel: 3,
                    category: 'attack',
                    effect: (level) => {
                        if (!Array.isArray(store.hounds)) {
                            store.hounds = [];
                        }

                        const isMini = store.player.miniAbilities && store.player.miniAbilities.has('ghost_hounds');
                        if (level === 0) {
                            store.player.hasHounds = true;
                            store.hounds.push(createHound(-1, isMini));
                            store.hounds.push(createHound(1, isMini));
                        } else if (level === 1) {
                            store.hounds.push(createHound(-2, isMini));
                            store.hounds.push(createHound(2, isMini));
                        } else if (level === 2) {
                            store.hounds.push(createHound(3, isMini));
                            store.hounds.push(createHound(4, isMini));
                        }

                        playSound('dogs');
                    },
                    desc: level => {
                        if (level === 0) return `Unlocks 2 spectral hounds.`;
                        if (level === 1) return `Add 2 more hounds.`;
                        if (level === 2) return `Add 2 Bernese Mountain hounds.`;
                        return "Max hounds reached.";
                    }
                },
                'champion_attack_module': {
                    name: 'CHAMPION MODULE',
                    icon: 'âš”ï¸',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Champion Modules';
                        const state = getChampionUpgradeState();
                        const detail = info?.detail;
                        if (detail?.module) {
                            return `Unlock ${detail.module.name}`;
                        }
                        const activeModule = CHAMPION_ATTACK_MODULE_MAP[state.attackModule];
                        return activeModule ? `Active: ${activeModule.name}` : 'Champion Modules';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.module) {
                            return detail.module.desc;
                        }
                        return 'All champion attack modules unlocked.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionAttackUnlock(state);
                        if (!next) {
                            const activeModule = CHAMPION_ATTACK_MODULE_MAP[state.attackModule];
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'All modules unlocked.',
                                detail: { modules: getChampionAttackCatalogue(state), activeModule }
                            };
                        }
                        const cost = next.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionAttackUnlock(state);
                        if (!detail || !detail.module) return false;
                        const moduleId = detail.module.id;
                        if (state.unlockedAttacks[moduleId]) return false;
                        state.unlockedAttacks[moduleId] = true;
                        state.attackModule = moduleId;
                        notifyChampionLoadoutChanged();
                        announce(`Champion module secured: ${detail.module.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                },
                'champion_cadence': {
                    name: 'CHAMPION CADENCE',
                    icon: 'ðŸŽµ',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Champion Cadence';
                        const detail = info?.detail;
                        if (detail?.option) {
                            return `Upgrade: ${detail.option.name}`;
                        }
                        const state = getChampionUpgradeState();
                        const current = detail?.current || getChampionCadenceOptions(state).find(opt => opt.active);
                        return current ? `Cadence: ${current.name}` : 'Champion Cadence';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.option) {
                            return detail.option.desc || 'Improve guardian firing rhythm and dash cooldown.';
                        }
                        const state = getChampionUpgradeState();
                        const current = getChampionCadenceOptions(state).find(opt => opt.active);
                        return current ? `Current cadence: ${current.name}.` : 'Cadence at base configuration.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionCadenceUpgrade(state);
                        if (!next) {
                            const options = getChampionCadenceOptions(state);
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'Cadence maxed.',
                                detail: { options, current: options.find(opt => opt.active) }
                            };
                        }
                        const cost = next.option.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionCadenceUpgrade(state);
                        if (!detail || !detail.option) return false;
                        const targetLevel = detail.option.level;
                        if (state.cadenceLevel >= targetLevel) return false;
                        state.cadenceLevel = targetLevel;
                        notifyChampionLoadoutChanged();
                        announce(`Champion cadence aligned: ${detail.option.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                },
                'champion_protocol': {
                    name: 'MINION PROTOCOLS',
                    icon: 'ðŸ›°ï¸',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Minion Protocols';
                        const detail = info?.detail;
                        if (detail?.option) {
                            return `Upgrade: ${detail.option.name}`;
                        }
                        const state = getChampionUpgradeState();
                        const current = detail?.current || getChampionProtocolOptions(state).find(opt => opt.active);
                        return current ? `Protocols: ${current.name}` : 'Minion Protocols';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.option) {
                            return detail.option.desc || 'Enhance guardian minion behavior.';
                        }
                        const state = getChampionUpgradeState();
                        const current = getChampionProtocolOptions(state).find(opt => opt.active);
                        return current ? `Current protocol: ${current.name}.` : 'Escort drones in default pattern.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionProtocolUpgrade(state);
                        if (!next) {
                            const options = getChampionProtocolOptions(state);
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'Protocols maxed.',
                                detail: { options, current: options.find(opt => opt.active) }
                            };
                        }
                        const cost = next.option.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionProtocolUpgrade(state);
                        if (!detail || !detail.option) return false;
                        const targetLevel = detail.option.level;
                        if (state.minionProtocols >= targetLevel) return false;
                        state.minionProtocols = targetLevel;
                        notifyChampionLoadoutChanged();
                        announce(`Minion protocols upgraded: ${detail.option.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                },
                'champion_skin': {
                    name: 'CHAMPION PLATING',
                    icon: 'ðŸŽ¨',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Champion Plating';
                        const detail = info?.detail;
                        if (detail?.option) {
                            return `Unlock Skin: ${detail.option.name}`;
                        }
                        const state = getChampionUpgradeState();
                        const active = detail?.active || getChampionSkinCatalogue(state).find(opt => opt.active);
                        return active ? `Skin: ${active.name}` : 'Champion Plating';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.option) {
                            return detail.option.desc || 'Unlock a new guardian aesthetic.';
                        }
                        const state = getChampionUpgradeState();
                        const active = getChampionSkinCatalogue(state).find(opt => opt.active);
                        if (active) {
                            return `All skins unlocked. Current skin: ${active.name}.`;
                        }
                        return 'All champion skins unlocked.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionSkinUnlock(state);
                        if (!next) {
                            const catalogue = getChampionSkinCatalogue(state);
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'All skins unlocked.',
                                detail: { catalogue, active: catalogue.find(opt => opt.active) }
                            };
                        }
                        const cost = next.option.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionSkinUnlock(state);
                        if (!detail || !detail.option) return false;
                        const skinId = detail.option.id;
                        if (state.unlockedSkins[skinId]) return false;
                        state.unlockedSkins[skinId] = true;
                        state.skin = skinId;
                        notifyChampionLoadoutChanged();
                        announce(`Champion plating unlocked: ${detail.option.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                }
            };

            const SHOP_DISPLAY_ORDER = [
                'repair',
                'hp',
                'max_shield',
                'nano_save',
                'vampirism',
                'luck_boost',
                'speed',
                'magnet_pull',
                'rear_guard',
                'dmg',
                'crit_chance',
                'grenade',
                'launcher',
                'star_cannon',
                'ghost_hounds',
                'iceman',
                'lazarus_beam',
                'gravity_well',
                'champion_attack_module',
                'champion_cadence',
                'champion_protocol',
                'champion_skin'
            ];

            const POWERUP_TYPES = {
                'double': { name: 'SCATTER SHOT', icon: 'â¬†ï¸', duration: 0, type: 'instant' },
                'drones': { name: 'SIDE DRONES', icon: 'ðŸš', duration: 15, type: 'timed' },
                'shield': { name: 'SHIELD BUBBLE', icon: 'ðŸ›¡ï¸', duration: 0, type: 'instant' },
                'repair': { name: 'REPAIR KIT', icon: 'â¤ï¸', duration: 0, type: 'instant' },
                'missile': { name: 'HOMING MISSILES', icon: 'ðŸš€', duration: 20, type: 'timed' },
                'upgrade': { name: 'UPGRADE CORE', icon: 'âš¡', duration: 0, type: 'instant', isSpecial: true },
                'void_core': { name: 'VOID CORE', icon: 'ðŸŒ€', duration: 25, type: 'timed' },
                'cash': { name: 'CASH INFUSION', icon: 'ðŸ’°', duration: 0, type: 'instant', isSpecial: true },
                'attack_speed': { name: 'HYPER DRIVE', icon: 'âš¡', duration: 0, type: 'instant', isSpecial: true },
                'swirly_upgrade': { name: 'SWIRL CORE', icon: 'ðŸŒªï¸', duration: 0, type: 'instant', isSpecial: true },
                'star_upgrade': { name: 'STAR CORE', icon: 'ðŸŒ ', duration: 0, type: 'instant', isSpecial: true },
                'shadow_champion_token': { name: 'CHAMPION SIGIL', icon: 'âš”ï¸', duration: 0, type: 'instant', isSpecial: true },
                'collar_fragment': { name: 'COLLAR FRAGMENT', icon: 'â›“ï¸', duration: 0, type: 'instant', isSpecial: true }
            };

            // --- GAME MECHANICS ---
            function spawnPowerup(x, y) {
                if (store.world.powerupCooldown > 0) return;
                const p = store.player;
                const baseChance = 0.075;
                const wave = store.world.wave;
                const waveReductionFactor = 0.0025;
                let finalChance = Math.max(0.025, baseChance - (wave - 1) * waveReductionFactor);
                let types = Object.keys(POWERUP_TYPES).filter(key => key !== 'void_core' && !POWERUP_TYPES[key].isSpecial);
                let bonusType = null;
                if (p.pilotGenome === 'beef') {
                    // Enhanced drop rates for beef - additional powerups, not replacing existing ones
                    if (Math.random() < 0.4) bonusType = 'shield'; // Increased from 0.25 to 0.4
                    else if (Math.random() < 0.3) bonusType = 'repair'; // Increased from 0.15 to 0.3
                    // Also boost the base chance for beef pilots
                    finalChance *= 1.3; // 30% higher overall powerup drop rate
                }
                if (p.pilotGenome === 'rocketman') {
                    // Significantly boost missile powerup rates for rocketman
                    if (Math.random() < 0.5) bonusType = 'missile'; // 50% chance for missile powerups
                    finalChance *= 2.0; // Double overall powerup drop rate
                    // Extra chance if rocketman doesn't currently have missiles active
                    if (!p.powerupTimers.missile || p.powerupTimers.missile.remaining <= 3) {
                        if (Math.random() < 0.3) bonusType = 'missile'; // Extra 30% chance when missiles are low/inactive
                    }
                }
                const roll = Math.random();
                if (roll > finalChance && !bonusType) return;
                let typeKey;
                if (bonusType && (roll <= finalChance || Math.random() < 0.5)) {
                    typeKey = bonusType;
                } else {
                    typeKey = types[Math.floor(Math.random() * types.length)];
                }
                store.powerups.push({ x, y, r: 12, type: typeKey });
                store.world.powerupCooldown = 5;
            }

            function spawnVoidCoreDrop(x, y) {
                if (!store.powerups) store.powerups = [];
                store.powerups.push({ x, y, r: 14, type: 'void_core' });
            }

            const VOID_CHAMPION_REWARD_POOL = ['multishot_bundle', 'attack_speed', 'swirly_upgrade', 'star_upgrade'];
            const VOID_CHAMPION_REWARD_MAP = {
                purple: 'swirly_upgrade',
                crimson: 'attack_speed',
                azure: 'multishot_bundle',
                emerald: 'star_upgrade',
                golden: 'cash_bundle'
            };

            // Upgrade tier definitions for powerup drops
            const UPGRADE_TIERS = {
                midTier: [
                    'hp', 'max_shield', 'speed', 'dmg', 'crit_chance', 'luck_boost',
                    'magnet_pull', 'rear_guard', 'repair', 'nano_save'
                ],
                bossTier: [
                    'vampirism', 'grenade', 'launcher', 'star_cannon', 'ghost_hounds',
                    'iceman', 'lazarus_beam', 'gravity_well'
                ]
            };

            function spawnMultishotBundle(x, y) {
                if (!store.powerups) store.powerups = [];
                const offsets = [-36, 0, 36];
                offsets.forEach((offset, index) => {
                    store.powerups.push({
                        x: x + offset,
                        y: y - index * 6,
                        r: 12,
                        type: 'double'
                    });
                });
            }

            function spawnSpecialPowerup(type, x, y) {
                if (!store.powerups) store.powerups = [];
                store.powerups.push({ x, y, r: 14, type });
            }

            function spawnUpgradePowerup(x, y, tier = 'midTier') {
                if (!store.powerups) store.powerups = [];
                store.powerups.push({ 
                    x, 
                    y, 
                    r: 14, 
                    type: 'upgrade',
                    upgradeTier: tier
                });
            }

            function spawnCashBundle(x, y) {
                if (!store.powerups) store.powerups = [];
                const offsets = [-30, 0, 30];
                offsets.forEach((offset, index) => {
                    store.powerups.push({
                        x: x + offset,
                        y: y - index * 8,
                        r: 14,
                        type: 'cash'
                    });
                });
            }

            function handleVoidChampionReward(enemy) {
                if (!enemy || enemy.voidChampionRewardGranted) return;
                const scheme = getVoidChampionColorScheme(enemy);
                const colorKey = enemy.colorScheme || 'purple';
                if (!enemy.voidChampionRewardKey) {
                    let rewardKey = VOID_CHAMPION_REWARD_MAP[colorKey] || 'attack_speed';
                    if (rewardKey === 'random_high_tier') {
                        rewardKey = VOID_CHAMPION_REWARD_POOL[Math.floor(Math.random() * VOID_CHAMPION_REWARD_POOL.length)];
                    }
                    enemy.voidChampionRewardKey = rewardKey;
                }

                enemy.voidChampionRewardGranted = true;
                const rewardKey = enemy.voidChampionRewardKey;
                const dropX = enemy.x;
                const dropY = enemy.y - 12;

                switch (rewardKey) {
                    case 'multishot_bundle':
                        spawnMultishotBundle(dropX, dropY);
                        announce(`${scheme.name} shattered! Triple scatter caches deployed!`);
                        break;
                    case 'attack_speed':
                        spawnSpecialPowerup('attack_speed', dropX, dropY);
                        announce(`${scheme.name} dismantled! Hyper drive matrix recovered!`);
                        break;
                    case 'swirly_upgrade':
                        spawnSpecialPowerup('swirly_upgrade', dropX, dropY);
                        announce(`${scheme.name} collapsed! Swirl core resonance secured!`);
                        break;
                    case 'star_upgrade':
                        spawnSpecialPowerup('star_upgrade', dropX, dropY);
                        announce(`${scheme.name} defeated! Star core schematics salvaged!`);
                        break;
                    case 'cash_bundle':
                        spawnCashBundle(dropX, dropY);
                        announce(`${scheme.name} destroyed! Triple cash infusion secured!`);
                        break;
                    default:
                        spawnSpecialPowerup('attack_speed', dropX, dropY);
                        announce(`${scheme.name} neutralized! Hyper drive cache secured!`);
                        break;
                }
            }

            function applyPowerup(typeKey) {
                const p = store.player;
                const powerup = POWERUP_TYPES[typeKey];
                if (typeKey === 'shadow_champion_token') {
                    grantChampionCompanion();
                    return;
                }
                if (typeKey === 'missile') {
                    if (p.pilotGenome === 'rocketman') { p.missileVolley = Math.min(5, p.missileVolley + 2); } else { p.missileVolley = 2; }
                }
                if (typeKey === 'collar_fragment') {
                    const collarGain = 1.75;
                    scheduleCollarIncrease(collarGain);
                    if (!store.activeEffects) {
                        store.activeEffects = [];
                    }
                    store.activeEffects.push(createEffect('spawnTeleport', p.x, p.y, 36, {
                        color: '#5df4d6',
                        duration: 0.55
                    }));
                    announce(`Collar lattice reinforced +${collarGain.toFixed(1)} stacks!`);
                    return;
                }
                if (typeKey === 'cash') {
                    const baseGoldValue = 80;
                    const waveScaling = Math.max(1, store.world.wave * 1.5);
                    const goldAmount = Math.floor(baseGoldValue * waveScaling);
                    if (goldAmount > 0) {
                        addWorldGold(goldAmount);
                        announce(`ðŸ’° CASH INFUSION +${goldAmount} GOLD! ðŸ’°`);
                    }
                    return;
                }
                if (typeKey === 'attack_speed') {
                    const newStacks = (p.attackSpeedStacks || 0) + 1;
                    p.attackSpeedStacks = newStacks;
                    p.fireRate = Math.max(p.fireRate * 0.88, 0.045);
                    announce(`HYPER DRIVE +12% (${newStacks} stack${newStacks === 1 ? '' : 's'})`);
                    return;
                }
                if (typeKey === 'swirly_upgrade') {
                    if (!p.swirlShots) {
                        p.swirlShots = true;
                        announce('SWIRL SHOTS ONLINE!');
                    } else {
                        announce('Swirl core overloaded! Diverting to hyper drive.');
                        applyPowerup('attack_speed');
                    }
                    return;
                }
                if (typeKey === 'star_upgrade') {
                    const upgrade = SHOP_UPGRADES && SHOP_UPGRADES.star_cannon;
                    if (upgrade) {
                        const currentLevel = p.upgradeLevels.star_cannon || 0;
                        const maxLevel = upgrade.maxLevel ?? 3;
                        if (currentLevel < maxLevel) {
                            upgrade.effect(currentLevel);
                            p.upgradeLevels.star_cannon = currentLevel + 1;
                            announce('STAR CANNON BLUEPRINT ACQUIRED (FREE)!');
                        } else {
                            announce('Star core surplus! Converting to hyper drive.');
                            applyPowerup('attack_speed');
                        }
                    }
                    return;
                }
                if (typeKey === 'void_core') {
                    const timer = p.powerupTimers[typeKey];
                    const prevStacks = timer ? (timer.stacks || 0) : 0;
                    const newStacks = Math.min(3, prevStacks + 1);
                    const prevDmgMult = p.voidCoreDmgMult || 1;
                    const prevFireRateMult = p.voidCoreFireRateMult || 1;
                    const newDmgMult = 1 + newStacks * 0.3;
                    const newFireRateMult = 1 + newStacks * 0.2;

                    p.dmgMult = (p.dmgMult / prevDmgMult) * newDmgMult;
                    p.fireRate = (p.fireRate * prevFireRateMult) / newFireRateMult;
                    p.fireRate = Math.max(p.fireRate, 0.05);

                    p.voidCoreStacks = newStacks;
                    p.voidCoreDmgMult = newDmgMult;
                    p.voidCoreFireRateMult = newFireRateMult;

                    if (timer) {
                        timer.remaining = powerup.duration;
                        timer.max = powerup.duration;
                        timer.stacks = newStacks;
                    } else {
                        p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration, stacks: newStacks };
                    }

                    announce(`VOID CORE RESONANCE x${newStacks}`);
                    announce(powerup.name);
                    return;
                }
                if (typeKey === 'upgrade') {
                    // Handle upgrade powerup collection - need to find the tier from the powerup being collected
                    // This will be passed through the collection system
                    applyRandomUpgrade(store.currentUpgradeTier || 'midTier');
                    delete store.currentUpgradeTier; // Clean up
                    return;
                }
                if (powerup.type === 'timed') {
                    if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
                    else {
                        if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                        p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
                    }
                } else if (powerup.type === 'instant') {
                    if (typeKey === 'shield') p.hasShieldBubble = true;
                    if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
                    if (typeKey === 'double') {
                        const p = store.player;
                        if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                        announce('SCATTER SHOT!');
                    }
                }
                announce(powerup.name);
            }

            function applyRandomUpgrade(forcedTier = null) {
                const tier = forcedTier || 'midTier';
                const availableUpgrades = UPGRADE_TIERS[tier] || UPGRADE_TIERS.midTier;
                
                // Filter to upgrades that aren't maxed out (ignore cost for free upgrades)
                const eligibleUpgrades = availableUpgrades.filter(key => {
                    const upgrade = SHOP_UPGRADES[key];
                    if (!upgrade) return false;
                    
                    const info = getNextUpgradeCost(key);
                    return info && Number.isFinite(info.cost);
                });
                
                if (eligibleUpgrades.length === 0) {
                    // If no eligible upgrades, give gold instead
                    const goldAmount = tier === 'bossTier' ? 200 : 100;
                    addWorldGold(goldAmount);
                    showUpgradePopup({
                        name: 'GOLD CACHE',
                        icon: 'ðŸ’°',
                        desc: `+${goldAmount} Gold (No upgrades available)`,
                        tier: tier
                    });
                    return;
                }
                
                // Select random upgrade from eligible options
                const selectedKey = eligibleUpgrades[Math.floor(Math.random() * eligibleUpgrades.length)];
                const upgrade = SHOP_UPGRADES[selectedKey];
                
                // Special handling for iceman from boss token - create escort drone instead
                let result;
                if (selectedKey === 'iceman' && tier === 'bossTier') {
                    // Add an escort drone instead of mini iceman
                    if (!store.escortDrones) store.escortDrones = [];
                    const droneIndex = store.escortDrones.length;
                    const side = droneIndex % 2 === 0 ? 'left' : 'right';
                    store.escortDrones.push({
                        x: store.player.x,
                        y: store.player.y,
                        side: side,
                        offset: droneIndex,
                        fireT: Math.random() * 0.3
                    });
                    result = { success: true, cost: 0, key: selectedKey };
                } else {
                    // Apply the upgrade for free
                    result = attemptPurchaseUpgrade(selectedKey, { silent: true, free: true });
                    
                    // Mark boss-tier abilities as mini versions
                    if (result.success && tier === 'bossTier') {
                        if (!store.player.miniAbilities) store.player.miniAbilities = new Set();
                        if (['gravity_well', 'lazarus_beam', 'ghost_hounds', 'launcher', 'grenade'].includes(selectedKey)) {
                            store.player.miniAbilities.add(selectedKey);
                        }
                    }
                }
                
                if (result.success) {
                    // Show popup with upgrade details
                    const level = (store.player?.upgradeLevels && store.player.upgradeLevels[selectedKey]) || 0;
                    const name = typeof upgrade.getName === 'function' ? upgrade.getName(null, level - 1) : upgrade.name;
                    const desc = typeof upgrade.desc === 'function' ? upgrade.desc(level - 1) : upgrade.desc;
                    
                    showUpgradePopup({
                        name: name,
                        icon: upgrade.icon || 'âš¡',
                        desc: desc,
                        tier: tier
                    });
                } else {
                    // Fallback to gold if upgrade failed
                    const goldAmount = tier === 'bossTier' ? 150 : 75;
                    addWorldGold(goldAmount);
                    showUpgradePopup({
                        name: 'COMPENSATION CACHE',
                        icon: 'ðŸ’°',
                        desc: `+${goldAmount} Gold (Upgrade failed)`
                    });
                }
            }

            function sanitizeCollarStacks() {
                if (!Number.isFinite(store.world.collarStacks)) {
                    console.warn('Invalid collar stack value detected, resetting.', store.world.collarStacks);
                    store.world.collarStacks = 0;
                }
                if (!Number.isFinite(store.world.collarTargetStacks)) {
                    store.world.collarTargetStacks = store.world.collarStacks;
                }
                return store.world.collarStacks;
            }
            const MAX_COLLAR_STACKS = 50; // Increased from 40 to allow longer runs
            const COLLAR_TARGET_GAIN_MULTIPLIER = 1.6;

            function calculateCollarBonus(stacks) {
                const safeStacks = Math.max(0, Number.isFinite(stacks) ? stacks : 0);
                const tierOneLimit = 5; // First 5 stacks at 8% each (increased from 6%)
                const tierTwoLimit = 10; // Next 5 stacks at 6% each (increased from 4%)
                const tierThreeLimit = 20; // Next 10 stacks at 5% each (increased from 2%)
                const cappedStacks = Math.min(safeStacks, MAX_COLLAR_STACKS);
                const tierOne = Math.min(cappedStacks, tierOneLimit);
                const tierTwo = Math.min(Math.max(cappedStacks - tierOneLimit, 0), tierTwoLimit - tierOneLimit);
                const tierThree = Math.min(Math.max(cappedStacks - tierTwoLimit, 0), tierThreeLimit - tierTwoLimit);
                const tierFour = Math.max(cappedStacks - tierThreeLimit, 0); // Stacks beyond 20 at 4% each
                const bonus = tierOne * 0.08 + tierTwo * 0.06 + tierThree * 0.05 + tierFour * 0.04;
                return 1 + bonus;
            }

            function setCollarStacks(value) {
                const clamped = Math.max(0, Math.min(MAX_COLLAR_STACKS, ensureFiniteNumber(value, 0)));
                store.world.collarStacks = clamped;
                store.world.collarTargetStacks = clamped;
                return clamped;
            }

            function approachCollarTarget() {
                const currentStacks = sanitizeCollarStacks();
                if (!Number.isFinite(store.world.collarTargetStacks)) {
                    store.world.collarTargetStacks = currentStacks;
                }
                const targetStacks = Math.min(MAX_COLLAR_STACKS, store.world.collarTargetStacks);
                const stackGap = targetStacks - currentStacks;
                if (stackGap > 0) {
                    const maxIncrease = 1 + Math.min(2, currentStacks * 0.05);
                    const appliedIncrease = Math.min(stackGap, maxIncrease);
                    store.world.collarStacks = Math.min(MAX_COLLAR_STACKS, currentStacks + appliedIncrease);
                } else if (stackGap < 0) {
                    setCollarStacks(targetStacks);
                }
            }

            function scheduleCollarIncrease(amount) {
                const delta = ensureFiniteNumber(amount, 0);
                if (delta <= 0) {
                    approachCollarTarget();
                    return;
                }

                const currentStacks = sanitizeCollarStacks();
                if (!Number.isFinite(store.world.collarTargetStacks)) {
                    store.world.collarTargetStacks = currentStacks;
                }
                const boostedDelta = delta * COLLAR_TARGET_GAIN_MULTIPLIER;
                store.world.collarTargetStacks = Math.min(MAX_COLLAR_STACKS, store.world.collarTargetStacks + boostedDelta);
                approachCollarTarget();
            }

            function ensureFiniteNumber(value, fallback = 0) {
                return Number.isFinite(value) ? value : fallback;
            }

            function pad(value, digits = 2) {
                const num = Number.isFinite(value) ? value : 0;
                const negative = num < 0;
                const abs = Math.abs(Math.floor(num));
                const padded = abs.toString().padStart(digits, '0');
                return negative ? `-${padded}` : padded;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ENHANCED WAVE SYSTEM: Themed Tactical Challenges
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Defined globally so it can be accessed by spawn functions
            
            // Helper function to get wave profile - must be defined globally
            function getSpawnProfileForWave(wave) {
                if (!window.WAVE_SPAWN_PROFILES) return null;
                for (let i = 0; i < window.WAVE_SPAWN_PROFILES.length; i++) {
                    const profile = window.WAVE_SPAWN_PROFILES[i];
                    if (wave >= profile.minWave) {
                        return profile;
                    }
                }
                return window.WAVE_SPAWN_PROFILES[window.WAVE_SPAWN_PROFILES.length - 1];
            }

            function initWave() {
                if (store.goldenOrbs) {
                    store.goldenOrbs.length = 0;
                }
                if (store.world) {
                    store.world.voidReaperSpawnedThisWave = false;
                    if (store.world.voidReaperCooldown && store.world.voidReaperCooldown > 0) {
                        store.world.voidReaperCooldown = Math.max(0, store.world.voidReaperCooldown - 1);
                    }
                }
                const isBossWave = store.world.wave % 5 === 0;
                const isPreBossWave = !isBossWave && store.world.wave % 5 === 4;

                if (isPreBossWave) {
                    const upcomingWave = store.world.wave + 1;
                    const upcomingCycle = Math.floor((upcomingWave - 5) / 5);
                    const upcomingBossDef = getBossDefinitionByCycle(upcomingCycle);
                    const upcomingThemeKey = upcomingBossDef ? ensureValidThemeKey(upcomingBossDef.key) : DEFAULT_MAP_THEME_KEY;
                    queueMapThemeTransition(upcomingThemeKey, { force: true });
                }

                const teleportAuraByType = {
                    drone: '#7fd5ff',
                    hunter: '#ff6e84',
                    phantom: '#d9a7ff',
                    mech: '#4ef0ff',
                    angler: '#8cf8f8',
                    manta: '#7acbff',
                    construct_gold: '#ffc35c',
                    avian_hatchling: '#c297ff',
                    void_champion: '#a864ff',
                    void_reaper: '#5a1b80'
                };
                const spawnDurationByType = {
                    phantom: 0.7,
                    mech: 0.8,
                    angler: 0.7,
                    manta: 0.85,
                    construct_gold: 0.65,
                    avian_hatchling: 0.62,
                    void_champion: 1.05,
                    void_reaper: 0
                };
                const dropDistanceByType = {
                    mech: 200,
                    angler: 170,
                    manta: 180,
                    construct_gold: 140,
                    avian_hatchling: 130,
                    void_champion: 220,
                    void_reaper: 0
                };
                const BOSS_CHAMPION_LOOP = 6;

                // Make spawn constants globally accessible
                if (!window.teleportAuraByType) {
                    window.teleportAuraByType = teleportAuraByType;
                }
                if (!window.spawnDurationByType) {
                    window.spawnDurationByType = spawnDurationByType;
                }
                if (!window.dropDistanceByType) {
                    window.dropDistanceByType = dropDistanceByType;
                }
                if (!window.BOSS_CHAMPION_LOOP) {
                    window.BOSS_CHAMPION_LOOP = BOSS_CHAMPION_LOOP;
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ENHANCED WAVE SYSTEM: Themed Tactical Challenges
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Each wave presents a unique tactical scenario designed to reward specific
                // playstyles and challenge different ability sets:
                //
                // PLAYSTYLE TESTS:
                // â€¢ AOE Damage (E-bullets, Multishot) â†’ Excels in SWARM_HELL waves
                // â€¢ Single-Target DPS (Phase Striker) â†’ Critical in TANK_RUSH/ELITE_ASSAULT
                // â€¢ Multi-Target (Chain Lightning, Railgunner) â†’ Shines in PRECISION_TEST
                // â€¢ Melee/Close Range (Flamethrower) â†’ Effective vs SWARM_HELL
                //
                // VULNERABILITY SYSTEM:
                // â€¢ Juggernaut (fire/explosive) â†’ Bonus vs Mech
                // â€¢ Marauder (kinetic/concussive) â†’ Bonus vs Manta
                // â€¢ Railgunner (kinetic/explosive) â†’ Bonus vs Phantom
                // â€¢ Demolitioner (fire/explosive) â†’ Bonus vs Void Champion Orb
                // â€¢ Phasestriker (void/magic) â†’ Bonus vs Void Champion
                // â€¢ Stormbringer (lightning/magic) â†’ Bonus vs Angler
                //
                // WAVE THEMES PROGRESSION:
                // Waves 1-2:   TUTORIAL - Basic mechanics
                // Waves 3-5:   MIXED_BASICS - Enemy variety introduction
                // Waves 6-8:   TANK_INTRO - First tanky enemies
                // Waves 9-12:  SWARM_HELL - Mass targets for AOE builds
                // Waves 13-15: PRECISION_TEST - Spread formations for multi-target
                // Waves 16-19: TANK_RUSH - High HP enemies for sustained DPS
                // Waves 20-24: MIXED_TACTICS - Adaptability test
                // Waves 25-29: VULNERABILITY_TEST - Class synergy critical
                // Waves 30-34: DODGE_HELL - Evasive enemies stress tracking
                // Waves 35-39: ELITE_ASSAULT - Heavy hitters with support
                // Waves 40+:   ULTIMATE_CHAOS - All systems engaged
                //
                // MOVEMENT PROTOCOLS:
                // â€¢ SWARM: Fast homing (construct_gold, avian_hatchling)
                // â€¢ PURSUIT: Aggressive tracking (hunter)
                // â€¢ BASIC: Simple downward with light tracking (drone)
                // â€¢ TANK: Slow, steady, horizontal tracking (angler, mech)
                // â€¢ WEAVE: Sinusoidal patterns (manta)
                // â€¢ DODGE: Unpredictable phase-shift (phantom)
                // â€¢ CHARGE: Periodic dash attacks (void_champion)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Store profiles globally for access from spawn functions
                const WAVE_SPAWN_PROFILES = window.WAVE_SPAWN_PROFILES || [
                    // WAVES 40+: ULTIMATE GAUNTLET - All systems tested simultaneously
                    {
                        minWave: 40,
                        theme: 'ULTIMATE_CHAOS',
                        description: 'All enemy types, maximum chaos',
                        forced: ['manta', 'angler', 'mech', 'phantom'],
                        weights: {
                            manta: 3.2,
                            angler: 3.0,
                            mech: 2.6,
                            phantom: 2.0,
                            hunter: 1.8,
                            avian_hatchling: 1.4,
                            construct_gold: 1.4,
                            drone: 1.0
                        },
                        special: [
                            { interval: 4, offset: 0, types: ['manta', 'angler'] },
                            { interval: 5, offset: 2, types: ['phantom', 'mech'] },
                            { interval: 6, offset: 1, types: ['avian_hatchling', 'construct_gold'] }
                        ]
                    },
                    
                    // WAVES 35-39: ELITE ASSAULT - Heavy hitters dominate
                    {
                        minWave: 35,
                        theme: 'ELITE_ASSAULT',
                        description: 'Tanky elites with support swarms - tests single-target DPS',
                        forced: ['manta', 'manta', 'angler', 'mech'],
                        weights: {
                            manta: 3.0,      // Dodge tanks (Marauder weak)
                            angler: 2.8,      // Slow tanks (Stormbringer weak)
                            mech: 2.4,        // Heavy tanks (Juggernaut weak)
                            phantom: 1.4,     // Phase dodgers (Railgunner weak)
                            construct_gold: 1.2,
                            avian_hatchling: 1.0,
                            hunter: 0.7,
                            drone: 0.4
                        },
                        special: [
                            { interval: 5, offset: 1, types: ['construct_gold', 'avian_hatchling'] },
                            { interval: 6, offset: 0, types: ['manta', 'angler'] }
                        ]
                    },
                    
                    // WAVES 30-34: DODGE GAUNTLET - Evasive enemies stress tracking
                    {
                        minWave: 30,
                        theme: 'DODGE_HELL',
                        description: 'Evasive enemies that dodge attacks - rewards AOE and prediction',
                        forced: ['manta', 'phantom', 'phantom'],
                        weights: {
                            manta: 2.8,       // Sinusoidal dodge
                            phantom: 2.6,     // Phase shift
                            avian_hatchling: 2.0,  // Erratic fast
                            hunter: 1.4,
                            construct_gold: 1.2,
                            mech: 0.8,
                            drone: 0.6,
                            angler: 0.4
                        },
                        special: [
                            { interval: 4, offset: 1, types: ['phantom'] },
                            { interval: 5, offset: 3, types: ['manta'] }
                        ]
                    },
                    
                    // WAVES 25-29: VULNERABILITY MASTERS - Class synergy critical
                    {
                        minWave: 25,
                        theme: 'VULNERABILITY_TEST',
                        description: 'Mixed enemies with vulnerability focus - rewards class-specific builds',
                        forced: ['angler', 'mech', 'phantom'],
                        weights: {
                            angler: 2.2,      // Stormbringer target
                            mech: 2.0,        // Juggernaut target
                            phantom: 1.8,     // Railgunner target
                            manta: 1.6,       // Marauder target
                            hunter: 1.2,
                            construct_gold: 1.0,
                            avian_hatchling: 0.9,
                            drone: 0.5
                        },
                        special: [
                            { interval: 5, offset: 0, types: ['angler', 'mech'] },
                            { interval: 6, offset: 3, types: ['phantom', 'manta'] }
                        ]
                    },
                    
                    // WAVES 20-24: MIXED TACTICS - Balanced challenge
                    {
                        minWave: 20,
                        theme: 'MIXED_TACTICS',
                        description: 'Balanced mix - tests adaptability',
                        forced: ['angler', 'mech', 'phantom'],
                        weights: {
                            manta: 2.0,
                            angler: 1.8,
                            mech: 1.6,
                            phantom: 1.5,
                            hunter: 1.2,
                            construct_gold: 1.0,
                            avian_hatchling: 0.9,
                            drone: 0.5
                        },
                        special: [
                            { interval: 6, offset: 3, types: ['construct_gold', 'avian_hatchling'] },
                            { interval: 5, offset: 0, types: ['mech', 'angler'] }
                        ]
                    },
                    
                    // WAVES 16-19: TANK RUSH - High HP enemies test sustained DPS
                    {
                        minWave: 16,
                        theme: 'TANK_RUSH',
                        description: 'Fewer but tankier enemies - tests single-target damage',
                        forced: ['mech', 'mech'],
                        weights: {
                            mech: 2.4,        // Slow, tanky, high damage
                            angler: 1.6,      // Very tanky
                            phantom: 1.4,     // Medium tank
                            hunter: 1.0,
                            manta: 0.6,
                            construct_gold: 0.5,
                            avian_hatchling: 0.4,
                            drone: 0.3
                        },
                        special: [
                            { interval: 4, offset: 1, types: ['mech'] },
                            { interval: 7, offset: 3, types: ['angler'] }
                        ]
                    },
                    
                    // WAVES 13-15: PRECISION TEST - Spaced targets reward accuracy
                    {
                        minWave: 13,
                        theme: 'PRECISION_TEST',
                        description: 'Spread formation - tests multi-target abilities',
                        forced: ['phantom', 'hunter'],
                        weights: {
                            phantom: 2.0,     // Phase enemies spread out
                            hunter: 1.8,      // Fast, spread targeting
                            mech: 1.2,
                            avian_hatchling: 0.8,
                            construct_gold: 0.7,
                            drone: 0.6
                        },
                        special: [
                            { interval: 5, offset: 2, types: ['phantom'] },
                            { interval: 6, offset: 0, types: ['hunter'] }
                        ]
                    },
                    
                    // WAVES 9-12: SWARM HELL - Many weak enemies test AOE damage
                    {
                        minWave: 9,
                        theme: 'SWARM_HELL',
                        description: 'Many weak, fast enemies - AOE abilities shine',
                        forced: ['construct_gold', 'avian_hatchling'],
                        weights: {
                            construct_gold: 2.2,  // Fast homing
                            avian_hatchling: 2.0, // Very fast homing
                            drone: 1.8,           // Basic swarm
                            hunter: 1.4,          // Fast tracking
                            phantom: 0.8,
                            mech: 0.3
                        },
                        special: [
                            { interval: 3, offset: 0, types: ['construct_gold', 'avian_hatchling'] },
                            { interval: 4, offset: 2, types: ['drone', 'hunter'] }
                        ]
                    },
                    
                    // WAVES 6-8: INTRODUCTION TO TANKS - First tanky enemy
                    {
                        minWave: 6,
                        theme: 'TANK_INTRO',
                        description: 'Introducing tanky mechs mixed with basic enemies',
                        forced: ['mech'],
                        weights: {
                            mech: 1.4,        // First tank enemy
                            hunter: 1.6,
                            drone: 1.8,
                            phantom: 0.6
                        },
                        special: [
                            { interval: 5, offset: 2, types: ['mech'] }
                        ]
                    },
                    
                    // WAVES 3-5: MIXED BASICS - Learning enemy variety
                    {
                        minWave: 3,
                        theme: 'MIXED_BASICS',
                        description: 'Introduction to enemy variety',
                        forced: ['hunter'],
                        weights: {
                            drone: 2.0,
                            hunter: 1.6,
                            phantom: 0.4
                        },
                        special: [
                            { interval: 4, offset: 1, types: ['hunter'] }
                        ]
                    },
                    
                    // WAVES 1-2: TUTORIAL - Pure basics
                    {
                        minWave: 1,
                        theme: 'TUTORIAL',
                        description: 'Basic drones only - learning the ropes',
                        forced: [],
                        weights: {
                            drone: 3.0,
                            hunter: 0.8
                        },
                        special: []
                    }
                ];
                
                // Make profiles globally accessible
                if (!window.WAVE_SPAWN_PROFILES) {
                    window.WAVE_SPAWN_PROFILES = WAVE_SPAWN_PROFILES;
                }

                const WAVE_TRANSMISSION_LIBRARY = window.WAVE_TRANSMISSION_LIBRARY || {
                    DEFAULT: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... signal's drifting.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Static.`
                    ],
                    TUTORIAL: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Quiet.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... nothing yet.`
                    ],
                    MIXED_BASICS: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Something out there.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Movement detected.`
                    ],
                    TANK_INTRO: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... heavy readings.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Big ones incoming.`
                    ],
                    SWARM_HELL: [
                        ({ wave }) => `ï¿½ Sector ${wave}... sensor's overloading.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Too many.`
                    ],
                    PRECISION_TEST: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Spread formation.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... make them count.`
                    ],
                    TANK_RUSH: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Armor inbound.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... gonna be a slog.`
                    ],
                    MIXED_TACTICS: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. All types.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Mixed bag.`
                    ],
                    VULNERABILITY_TEST: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... reading variances.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Find their weak spots.`
                    ],
                    DODGE_HELL: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Fast movers.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... they're erratic.`
                    ],
                    ELITE_ASSAULT: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Trouble.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... serious contacts.`
                    ],
                    ULTIMATE_CHAOS: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... everything.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Just survive.`
                    ]
                };

                if (!window.WAVE_TRANSMISSION_LIBRARY) {
                    window.WAVE_TRANSMISSION_LIBRARY = WAVE_TRANSMISSION_LIBRARY;
                }

                function pickTransmission(entries, context) {
                    if (!entries || !entries.length) return null;
                    const idx = Math.floor(Math.random() * entries.length);
                    const choice = entries[idx];
                    if (typeof choice === 'function') {
                        try {
                            return choice(context) || null;
                        } catch (err) {
                            console.error('Transmission composer failed', err);
                            return null;
                        }
                    }
                    if (typeof choice === 'string') {
                        return choice.replace('{wave}', context.wave);
                    }
                    return null;
                }

                function composeWaveTransmission(theme, wave) {
                    const context = { wave, theme };
                    const themed = theme && WAVE_TRANSMISSION_LIBRARY[theme];
                    const entries = themed && themed.length ? themed : WAVE_TRANSMISSION_LIBRARY.DEFAULT;
                    return pickTransmission(entries, context) || pickTransmission(WAVE_TRANSMISSION_LIBRARY.DEFAULT, context);
                }

                function broadcastTransmission(message, delay = 0) {
                    if (!message) return;
                    if (delay > 0) {
                        setTimeout(() => announce(message), delay);
                    } else {
                        announce(message);
                    }
                }

                function getSpawnProfileForWave(wave) {
                    for (let i = 0; i < WAVE_SPAWN_PROFILES.length; i++) {
                        const profile = WAVE_SPAWN_PROFILES[i];
                        if (wave >= profile.minWave) {
                            return profile;
                        }
                    }
                    return WAVE_SPAWN_PROFILES[WAVE_SPAWN_PROFILES.length - 1];
                }

                function pickWeightedType(weights) {
                    const entries = Object.entries(weights || {}).filter(([, weight]) => ensureFiniteNumber(weight, 0) > 0);
                    if (!entries.length) {
                        return 'drone';
                    }
                    const totalWeight = entries.reduce((sum, [, weight]) => sum + weight, 0);
                    if (totalWeight <= 0 || !Number.isFinite(totalWeight)) {
                        return entries[0][0];
                    }
                    let roll = Math.random() * totalWeight;
                    for (const [type, weight] of entries) {
                        roll -= weight;
                        if (roll <= 0) {
                            return type;
                        }
                    }
                    return entries[entries.length - 1][0];
                }

                function createSpawnSpec(type, threatScale, lateGameScaling) {
                    return {
                        type,
                        props: { hpScale: threatScale, damageMult: threatScale },
                        lateGameScaling,
                        spawnDuration: spawnDurationByType[type],
                        spawnDropDistance: dropDistanceByType[type],
                        effectColor: teleportAuraByType[type] || teleportAuraByType.drone
                    };
                }

                function shuffleInPlace(list) {
                    for (let i = list.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        const tmp = list[i];
                        list[i] = list[j];
                        list[j] = tmp;
                    }
                }

                function buildWaveSpawnSpecs(wave, spawnCount, threatScale, lateGameScaling) {
                    const profile = getSpawnProfileForWave(wave);
                    const specs = [];
                    const forced = Array.isArray(profile.forced) ? profile.forced.slice(0, Math.max(0, spawnCount)) : [];

                    forced.forEach(type => {
                        specs.push(createSpawnSpec(type, threatScale, lateGameScaling));
                    });

                    while (specs.length < spawnCount) {
                        const slotIndex = specs.length;
                        let type = pickWeightedType(profile.weights);
                        if (Array.isArray(profile.special)) {
                            for (const routine of profile.special) {
                                if (!routine || !routine.interval || !Array.isArray(routine.types) || !routine.types.length) continue;
                                const interval = Math.max(1, Math.floor(routine.interval));
                                const offset = Math.floor(routine.offset || 0);
                                if ((slotIndex + offset) % interval === 0) {
                                    const index = Math.floor(Math.random() * routine.types.length);
                                    type = routine.types[index];
                                    break;
                                }
                            }
                        }
                        specs.push(createSpawnSpec(type, threatScale, lateGameScaling));
                    }

                    shuffleInPlace(specs);
                    return specs;
                }

                // Make spawn helper functions globally accessible
                if (!window.buildWaveSpawnSpecs) {
                    window.buildWaveSpawnSpecs = buildWaveSpawnSpecs;
                }
                if (!window.pickWeightedType) {
                    window.pickWeightedType = pickWeightedType;
                }
                if (!window.createSpawnSpec) {
                    window.createSpawnSpec = createSpawnSpec;
                }
                if (!window.shuffleInPlace) {
                    window.shuffleInPlace = shuffleInPlace;
                }

                const VOID_REAPER_CONFIG = Object.freeze({
                    warningDuration: 2.0,
                    emergeDuration: 0.55,
                    lungeSpeed: 640,
                    lungePadding: 260,
                    scytheArc: Math.PI * 0.95,
                    scytheReach: 150,
                    minWaveGap: 3,
                    preemptiveGoldBonus: 0.6,
                    bonusScoreRatio: 0.5,
                    bonusXpRatio: 0.45
                });

                // Make VOID_REAPER_CONFIG globally accessible
                if (!window.VOID_REAPER_CONFIG) {
                    window.VOID_REAPER_CONFIG = VOID_REAPER_CONFIG;
                }

                function chooseVoidReaperSpawnPosition(player) {
                    // Spawn from far corners/edges to maximize travel distance
                    const corners = [
                        { name: 'top-left', x: 50, y: 50 },
                        { name: 'top-right', x: W - 50, y: 50 },
                        { name: 'bottom-left', x: 50, y: H - 50 },
                        { name: 'bottom-right', x: W - 50, y: H - 50 }
                    ];
                    
                    // Calculate which corner is farthest from player for maximum dramatic effect
                    let farthestCorner = corners[0];
                    let maxDist = 0;
                    
                    corners.forEach(corner => {
                        const dx = corner.x - player.x;
                        const dy = corner.y - player.y;
                        const dist = dx * dx + dy * dy;
                        if (dist > maxDist) {
                            maxDist = dist;
                            farthestCorner = corner;
                        }
                    });
                    
                    // Add slight randomness so it's not always exactly the same spot
                    const jitterX = (Math.random() - 0.5) * 80;
                    const jitterY = (Math.random() - 0.5) * 80;
                    
                    return { 
                        edge: farthestCorner.name, 
                        x: clamp(farthestCorner.x + jitterX, 30, W - 30), 
                        y: clamp(farthestCorner.y + jitterY, 30, H - 30)
                    };
                }

                function spawnVoidReaper({ hpScale = 1, damageMult = 1, lateGameScaling = 1 } = {}) {
                    // Cache-busting fix for undefined function error
                    if (!store || !store.player) return null;
                    const player = store.player;
                    const pos = chooseVoidReaperSpawnPosition(player);
                    const heading = Math.atan2(player.y - pos.y, player.x - pos.x);
                    const enemy = spawnEnemy('void_reaper', {
                        x: pos.x,
                        y: pos.y,
                        hpScale,
                        damageMult,
                        spawnEdge: pos.edge,
                        entryAngle: heading,
                        warningTimer: VOID_REAPER_CONFIG.warningDuration,
                        lungeSpeed: VOID_REAPER_CONFIG.lungeSpeed,
                        lungePadding: VOID_REAPER_CONFIG.lungePadding,
                        scytheArc: VOID_REAPER_CONFIG.scytheArc,
                        scytheReach: VOID_REAPER_CONFIG.scytheReach
                    });
                    if (!enemy) return null;

                    applySpawnSpecToEnemy(enemy, { lateGameScaling });

                    enemy.warningDuration = VOID_REAPER_CONFIG.warningDuration;
                    enemy.emergeDuration = VOID_REAPER_CONFIG.emergeDuration;
                    enemy.phase = 'warning';
                    enemy.isInvulnerable = true;
                    enemy.heading = heading;
                    enemy.riftSeed = Math.random() * Math.PI * 2;

                    store.activeEffects.push(createEffect('voidReaperRift', enemy.x, enemy.y, (enemy.r || 24) * 2.6, {
                        duration: enemy.warningDuration,
                        edge: pos.edge
                    }));

                    store.enemies.push(enemy);
                    store.world.voidReaperSpawnedThisWave = true;
                    store.world.lastVoidReaperWave = store.world.wave;
                    store.world.voidReaperCooldown = Math.max(VOID_REAPER_CONFIG.minWaveGap || 3, 1);

                    return enemy;
                }

                // Make spawnVoidReaper globally accessible
                if (!window.spawnVoidReaper) {
                    window.spawnVoidReaper = spawnVoidReaper;
                }

                function finalizeVoidReaperDefeat(enemy, { preemptive = false } = {}) {
                    if (!enemy || enemy.reaperDefeated) return;
                    enemy.reaperDefeated = true;
                    enemy.dead = true;
                    enemy.hp = 0;

                    if (!store || !store.world) return;

                    if (preemptive) {
                        const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                        const baseGold = Number.isFinite(enemy.gold) ? enemy.gold : 0;
                        const bonusGold = Math.max(50, Math.floor(baseGold * VOID_REAPER_CONFIG.preemptiveGoldBonus * collarBonus)); // Increased minimum from 12 to 50
                        const bonusScore = Math.floor((enemy.score || 0) * VOID_REAPER_CONFIG.bonusScoreRatio);
                        const bonusXp = Math.floor((enemy.xp || 0) * VOID_REAPER_CONFIG.bonusXpRatio);
                        if (bonusGold) addWorldGold(bonusGold);
                        if (bonusScore) store.world.score += bonusScore;
                        if (bonusXp) store.world.xp += bonusXp;
                        announce('â­ VOID REAPER DEFEATED! STAR POWER ACTIVATED! â­');
                        store.activeEffects.push(createEffect('voidReaperReward', enemy.x, enemy.y, (enemy.r || 24) * 3.2, { gold: bonusGold }));
                        
                        // Grant 5 seconds of invincibility star effect (like Mario/Mario Kart)
                        store.player.isInvincible = true;
                        store.player.starPowerEndTime = performance.now() + 5000; // 5 seconds
                        screenFlash(2, 250, 'rgba(255, 215, 0, 0.3)'); // Golden flash
                        playSound('powerup');
                        
                        // Spawn purple & gold coins (New Orleans style) to make loot visible
                        if (!store.powerups) store.powerups = [];
                        const numCoins = Math.min(8, Math.floor(bonusGold / 8)); // 1 coin per 8 gold, max 8 coins (increased from 5)
                        for (let i = 0; i < numCoins; i++) {
                            const angle = (i / numCoins) * Math.PI * 2;
                            const dist = 30 + Math.random() * 30;
                            const coinX = enemy.x + Math.cos(angle) * dist;
                            const coinY = enemy.y + Math.sin(angle) * dist;
                            store.powerups.push({
                                x: coinX,
                                y: coinY,
                                r: 14,
                                type: 'cash',
                                isVoidReaper: true, // Special flag for purple/gold rendering
                                pulseOffset: i * 0.5
                            });
                        }
                        
                        // GUARANTEED REWARD: Elite tier upgrade, boss tier upgrade + money, OR large money
                        const rewardRoll = Math.random();
                        if (rewardRoll < 0.40) {
                            // 40% chance: Elite tier upgrade (iceman, lazarus, gravity well, etc)
                            spawnUpgradePowerup(enemy.x, enemy.y - 20, 'bossTier');
                            announce('ðŸŒŸ Elite Upgrade Acquired!');
                        } else if (rewardRoll < 0.70) {
                            // 30% chance: Boss tier upgrade + bonus money
                            spawnUpgradePowerup(enemy.x - 25, enemy.y - 20, 'bossTier');
                            const extraGold = 25;
                            addWorldGold(extraGold);
                            // Spawn extra gold coins
                            for (let i = 0; i < 3; i++) {
                                const angle = (Math.PI / 3) * i + Math.PI / 6;
                                const dist = 45;
                                store.powerups.push({
                                    x: enemy.x + Math.cos(angle) * dist,
                                    y: enemy.y + Math.sin(angle) * dist,
                                    r: 14,
                                    type: 'cash',
                                    isVoidReaper: true,
                                    pulseOffset: i * 0.3
                                });
                            }
                        } else {
                            // 30% chance: Large money reward (no upgrade)
                            const largeGoldBonus = 35;
                            addWorldGold(largeGoldBonus);
                            announce('ðŸ’° Major Gold Cache Secured!');
                            // Spawn extra gold powerups in a circle
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const dist = 50;
                                store.powerups.push({
                                    x: enemy.x + Math.cos(angle) * dist,
                                    y: enemy.y + Math.sin(angle) * dist,
                                    r: 14,
                                    type: 'cash',
                                    isVoidReaper: true,
                                    pulseOffset: i * 0.4
                                });
                            }
                        }
                    } else {
                        store.activeEffects.push(createEffect('voidReaperDissolve', enemy.x, enemy.y, (enemy.r || 24) * 2.2));
                    }
                }

                function updateVoidReaper(enemy, dt) {
                    if (!enemy || enemy.dead) return;

                    if (enemy.hitPulseTimer && enemy.hitPulseTimer > 0) {
                        enemy.hitPulseTimer = Math.max(0, enemy.hitPulseTimer - dt);
                    }
                    if (enemy.hitShakeTimer && enemy.hitShakeTimer > 0) {
                        enemy.hitShakeTimer = Math.max(0, enemy.hitShakeTimer - dt);
                        if (enemy.hitShakeTimer <= 0) {
                            enemy.hitShakeIntensity = 0;
                        }
                    }

                    if (enemy.hp <= 0 && !enemy.reaperDefeated) {
                        finalizeVoidReaperDefeat(enemy, { preemptive: !enemy.lungeStarted });
                        return;
                    }

                    const warningDuration = enemy.warningDuration || VOID_REAPER_CONFIG.warningDuration;
                    const emergeDuration = enemy.emergeDuration || VOID_REAPER_CONFIG.emergeDuration;
                    enemy.isInvulnerable = enemy.phase === 'warning';

                    switch (enemy.phase) {
                        case 'warning': {
                            enemy.warningTimer = (enemy.warningTimer ?? warningDuration) - dt;
                            enemy.riftPulse = (enemy.riftPulse || 0) + dt;
                            enemy.riftProgress = Math.min(1, 1 - Math.max(0, enemy.warningTimer) / Math.max(0.001, warningDuration));
                            if (enemy.warningTimer <= 0) {
                                enemy.phase = 'emerging';
                                enemy.isInvulnerable = false;
                                enemy.emergeTimer = emergeDuration;
                                enemy.emergeProgress = 0;
                                enemy.lockedTarget = { x: store.player.x, y: store.player.y };
                                enemy.heading = Math.atan2(enemy.lockedTarget.y - enemy.y, enemy.lockedTarget.x - enemy.x);
                                store.activeEffects.push(createEffect('voidReaperStrike', enemy.x, enemy.y, (enemy.r || 24) * 1.45, {
                                    heading: enemy.heading,
                                    duration: emergeDuration,
                                    warmup: true
                                }));
                            }
                            break;
                        }
                        case 'emerging': {
                            enemy.emergeTimer = (enemy.emergeTimer ?? emergeDuration) - dt;
                            const current = Math.max(0, enemy.emergeTimer);
                            enemy.emergeProgress = Math.min(1, 1 - current / Math.max(0.001, emergeDuration));
                            if (enemy.emergeTimer <= 0) {
                                enemy.phase = 'lunge';
                                enemy.lungeStarted = true;
                                const target = enemy.lockedTarget || { x: store.player.x, y: store.player.y };
                                const dx = target.x - enemy.x;
                                const dy = target.y - enemy.y;
                                const dist = Math.max(60, Math.sqrt(dx * dx + dy * dy));
                                enemy.lungeDirX = dx / dist;
                                enemy.lungeDirY = dy / dist;
                                enemy.heading = Math.atan2(enemy.lungeDirY, enemy.lungeDirX);
                                enemy.totalLungeDistance = dist + (enemy.lungePadding || VOID_REAPER_CONFIG.lungePadding);
                                enemy.lungeDistanceTravelled = 0;
                                enemy.lungeSpeed = enemy.lungeSpeed || VOID_REAPER_CONFIG.lungeSpeed;
                                store.activeEffects.push(createEffect('voidReaperStrike', enemy.x, enemy.y, (enemy.r || 24) * 1.35, {
                                    heading: enemy.heading,
                                    duration: 0.32
                                }));
                                playSound('horn');
                            }
                            break;
                        }
                        case 'lunge': {
                            enemy.hitSlowTimer = 0;
                            enemy.slowTimer = 0;
                            const speed = enemy.lungeSpeed || VOID_REAPER_CONFIG.lungeSpeed;
                            
                            // Track player until close, then go straight for dodging
                            const player = store.player;
                            const dx = player.x - enemy.x;
                            const dy = player.y - enemy.y;
                            const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                            
                            // When far from player (>300 units), curve toward them
                            // When close (<300 units), lock direction for dodgeable straight line
                            if (distToPlayer > 300 && !enemy.lockedForDodge) {
                                // Update direction to track player
                                const targetAngle = Math.atan2(dy, dx);
                                enemy.heading = targetAngle;
                                enemy.lungeDirX = Math.cos(targetAngle);
                                enemy.lungeDirY = Math.sin(targetAngle);
                            } else {
                                // Lock direction when close enough
                                enemy.lockedForDodge = true;
                            }
                            
                            const dirX = enemy.lungeDirX || Math.cos(enemy.heading || 0);
                            const dirY = enemy.lungeDirY || Math.sin(enemy.heading || 0);
                            enemy.x += dirX * speed * dt;
                            enemy.y += dirY * speed * dt;
                            enemy.lungeDistanceTravelled = (enemy.lungeDistanceTravelled || 0) + speed * dt;
                            const total = Math.max(1, enemy.totalLungeDistance || 1);
                            enemy.lungeProgress = Math.min(1.15, enemy.lungeDistanceTravelled / total);

                            if (player && !player.isInvincible && !playerIsInvulnerable()) {
                                const px = player.x - enemy.x;
                                const py = player.y - enemy.y;
                                const dist = Math.sqrt(px * px + py * py);
                                const reach = enemy.scytheReach || VOID_REAPER_CONFIG.scytheReach;
                                if (dist <= reach) {
                                    const angleToPlayer = Math.atan2(py, px);
                                    let diff = angleToPlayer - (enemy.heading || 0);
                                    if (diff > Math.PI) diff -= Math.PI * 2;
                                    if (diff < -Math.PI) diff += Math.PI * 2;
                                    const arc = (enemy.scytheArc || VOID_REAPER_CONFIG.scytheArc) * (0.7 + 0.3 * Math.min(1, enemy.lungeProgress || 0));
                                    if (Math.abs(diff) <= arc * 0.5) {
                                        // Check for Shield Pulse (EMP) protection
                                        if (store.empCharges && store.empCharges.length > 0) {
                                            // Shield Pulse blocks the reaper!
                                            const charge = store.empCharges[0];
                                            triggerEmpBurst(charge.x, charge.y);
                                            charge.cooldown = EMP_BURST_CONFIG.chargeCooldown;
                                            store.empGlobalCooldown = Math.max(store.empGlobalCooldown || 0, EMP_BURST_CONFIG.globalCooldown || 0);
                                            announce('âš¡ SHIELD PULSE STOPPED THE REAPER! âš¡');
                                            playSound('thunder');
                                            screenFlash(1, 200, 'rgba(100, 200, 255, 0.4)');
                                            // Stun and damage the reaper
                                            enemy.hp -= 80;
                                            enemy.stunTimer = 3.5;
                                            enemy.phase = 'recovering';
                                            enemy.hitSlowFactor = 0.3;
                                            enemy.hitSlowTimer = 4;
                                            store.activeEffects.push(createEffect('empShockwave', enemy.x, enemy.y, 280));
                                            return;
                                        }
                                        // Check for Aft Flank Shield protection (if reaper is behind player)
                                        const reaperAngleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                        const playerFacingAngle = player.heading || 0;
                                        let facingDiff = reaperAngleToPlayer - playerFacingAngle;
                                        if (facingDiff > Math.PI) facingDiff -= Math.PI * 2;
                                        if (facingDiff < -Math.PI) facingDiff += Math.PI * 2;
                                        const isFromBehind = Math.abs(facingDiff) > Math.PI * 0.5; // Behind if angle > 90 degrees
                                        
                                        if (player.hasRearGuard && player.rearGuardReady && isFromBehind) {
                                            // Aft Flank Shield blocks the reaper from behind!
                                            player.rearGuardReady = false;
                                            player.rearGuardCooldown = 8;
                                            announce('ðŸ›¡ï¸ AFT FLANKSHIELD STOPPED THE REAPER! ðŸ›¡ï¸');
                                            playSound('stargun');
                                            screenFlash(1, 200, 'rgba(255, 215, 0, 0.4)');
                                            store.activeEffects.push(createEffect("rearGuardBlock"));
                                            // Stun and damage the reaper
                                            enemy.hp -= 60;
                                            enemy.stunTimer = 2.5;
                                            enemy.phase = 'recovering';
                                            enemy.hitSlowFactor = 0.4;
                                            enemy.hitSlowTimer = 3;
                                            return;
                                        }
                                        
                                        takeDamage(player.hp + player.shield + player.hpMax + 999);
                                    }
                                }
                            }

                            if (
                                enemy.lungeDistanceTravelled >= total ||
                                enemy.x < -220 || enemy.x > W + 220 ||
                                enemy.y < -220 || enemy.y > H + 220
                            ) {
                                enemy.phase = 'finished';
                                enemy.dead = true;
                                store.activeEffects.push(createEffect('voidReaperDissolve', enemy.x, enemy.y, (enemy.r || 24) * 1.8));
                            }
                            break;
                        }
                        default:
                            enemy.dead = true;
                    }
                }

                // Make void reaper functions globally accessible
                if (!window.updateVoidReaper) {
                    window.updateVoidReaper = updateVoidReaper;
                }
                if (!window.finalizeVoidReaperDefeat) {
                    window.finalizeVoidReaperDefeat = finalizeVoidReaperDefeat;
                }

                function spawnVoidChampion({
                    hpScale = 1,
                    damageMult = 1,
                    lateGameScaling = 1,
                    entryTargetYBase = 110,
                    entryYOffset = 0
                } = {}) {
                    const playerState = typeof getChampionUpgradeState === 'function' ? getChampionUpgradeState() : null;
                    const attackModule = (store?.playerChampion?.attackModule) || (playerState?.attackModule) || 'default';
                    const champion = spawnEnemy('void_champion', { hpScale, damageMult, attackModule });
                    if (!champion) return null;

                    applySpawnSpecToEnemy(champion, { lateGameScaling });
                    const entryDrop = dropDistanceByType.void_champion || 220;
                    const entryTargetY = entryTargetYBase + entryYOffset + Math.random() * 50;
                    champion.spawnTargetY = entryTargetY;
                    champion.y = entryTargetY - entryDrop;
                    champion.x = Math.max(120, Math.min(W - 120, champion.x));

                    activateSpawnIntro(champion, {
                        duration: spawnDurationByType.void_champion,
                        dropDistance: entryDrop,
                        targetY: entryTargetY,
                        clusterIndex: -1,
                        effectColor: teleportAuraByType.void_champion,
                        topClampBuffer: 1.2,
                        fireDelayBuffer: 0.6
                    });

                    store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.spawnTargetY ?? champion.y, champion.r || 28, {
                        duration: (champion.spawnDuration || 1) + 0.35,
                        color: teleportAuraByType.void_champion,
                        clusterIndex: -1,
                        isChampion: true
                    }));
                    store.enemies.push(champion);
                    return champion;
                }

                function spawnBossLoopChampions(loopCount, bossHpScale) {
                    if (loopCount < 1 || !Number.isFinite(loopCount)) return 0;
                    const championsToSpawn = Math.min(2, Math.max(0, loopCount));
                    let spawned = 0;
                    for (let i = 0; i < championsToSpawn; i++) {
                        const champion = spawnVoidChampion({
                            hpScale: bossHpScale * 0.6, // 60% of boss HP scaling (reduced from 100%)
                            damageMult: bossHpScale * 0.5, // 50% of boss damage scaling (reduced from 100%)
                            lateGameScaling: bossHpScale * 0.6,
                            entryTargetYBase: 100,
                            entryYOffset: i * 40
                        });
                        if (champion) spawned += 1;
                    }
                    return spawned;
                }

                // Make champion spawn functions globally accessible
                if (!window.spawnVoidChampion) {
                    window.spawnVoidChampion = spawnVoidChampion;
                }
                if (!window.spawnBossLoopChampions) {
                    window.spawnBossLoopChampions = spawnBossLoopChampions;
                }

                // Clear poison puddles at start of each wave for clean slate
                if (store.poisonPuddles) {
                    store.poisonPuddles = [];
                }

                if (isBossWave) {
                    store.enemies = [];
                    store.world.pendingVoidReaper = null;
                    store.world.voidReaperWarningIssued = false;

                    // FIXED: Balanced boss scaling instead of aggressive exponential growth
                    // Old: 1 + (wave/5 - 1) * 1.5 caused 4x HP by wave 15
                    // New: Gentler scaling with reasonable progression
                    let bossHpScale;
                    if (store.world.wave <= 5) {
                        bossHpScale = 1; // No scaling for early bosses
                    } else if (store.world.wave <= 15) {
                        bossHpScale = 1 + (store.world.wave - 5) * 0.2; // +20% per wave 6-15
                    } else {
                        bossHpScale = 1 + 10 * 0.2 + (store.world.wave - 15) * 0.1; // +10% per wave after 15
                    }

                    store.boss = createBoss(bossHpScale);
                    applyBossTheme(store.boss);
                    if (store.world) {
                        if (!store.world.completedBossTokens || typeof store.world.completedBossTokens !== 'object') {
                            store.world.completedBossTokens = Object.create(null);
                        }
                        store.world.activeBossToken = (store.boss && store.boss.instanceId) || null;
                        store.world.activeBossWave = store.world.wave;
                        store.world.lastBossAwardToken = null;
                    }
                    store.lastBossSnapshot = null;
                    store.lastBossDefeatId = null;
                    store.world.bossSpawnTime = performance.now();
                    store.world.lastPlannedSpawnCount = 0;
                    store.world.lastSpawnCount = 0;
                    store.world.lastSpawnOverflow = 0;
                    store.world.lastThreatScale = 1;
                    store.world.lastSpawnFallback = false;
                    if (store.boss.name === 'VOID SENTINEL') playSound('trap');
                    else if (store.boss.name === 'NEURAL CORE') playSound('horn');
                    announce(`ðŸ“¡ [Command Relay] "Sector ${store.world.wave}: Guardian signature ${store.boss.name}. That's your mark."`);
                    if (!store.world.firstBossOrbsGifted && store.world.bosses === 0 && store.boss.name === 'VOID SENTINEL') {
                        spawnGoldenSentinelOrbs(3);
                        store.world.firstBossOrbsGifted = true;
                        setTimeout(() => announce('ðŸ“¡ [Command Relay] "Collect GOLDEN ORBS to shatter the guardian!"'), 750);
                    }

                    const bossesDefeated = ensureFiniteNumber(store.world.bosses, 0);
                    const bossLoopCount = Math.floor(bossesDefeated / BOSS_CHAMPION_LOOP);
                    if (bossLoopCount > 0) {
                        spawnBossLoopChampions(bossLoopCount, bossHpScale);
                    }
                } else {
                    store.enemies = [];
                    store.waveSpawnQueue = [];
                    store.pendingSpawnCount = 0;

                    // NEW SCALING SYSTEM: After wave 35, stop increasing spawn count and increase enemy stats instead
                    // ENHANCED: Wave themes modify spawn counts for tactical variety
                    let baseSpawnCount, spawnCount, lateGameScaling = 1;

                    if (store.world.wave <= 35) {
                        // Normal scaling: increase spawn count with waves
                        baseSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                        spawnCount = baseSpawnCount;
                    } else {
                        // Wave 35+: Cap spawn count, scale enemy stats instead
                        baseSpawnCount = Math.floor((7 + Math.floor(35 * 1.8)) * store.world.enemyDensityBonus);
                        spawnCount = Math.max(1, Math.floor(baseSpawnCount * 0.8)); // Slightly fewer enemies for performance

                        // Calculate what the spawn count WOULD have been, use that as scaling factor
                        const theoreticalSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                        lateGameScaling = theoreticalSpawnCount / baseSpawnCount; // This becomes our health/damage multiplier
                    }

                    // WAVE THEME MODIFIERS: Adjust spawn count and enemy stats based on wave archetype
                    const currentWaveProfile = getSpawnProfileForWave(store.world.wave);
                    if (currentWaveProfile && currentWaveProfile.theme) {
                        switch (currentWaveProfile.theme) {
                            case 'SWARM_HELL':
                                // More enemies, but each slightly weaker
                                spawnCount = Math.floor(spawnCount * 1.4);
                                lateGameScaling *= 0.85;
                                break;
                            case 'TANK_RUSH':
                            case 'ELITE_ASSAULT':
                                // Fewer enemies, but each significantly stronger
                                spawnCount = Math.floor(spawnCount * 0.65);
                                lateGameScaling *= 1.45;
                                break;
                            case 'DODGE_HELL':
                                // Normal count, enemies have more evasion (handled in movement)
                                spawnCount = Math.floor(spawnCount * 0.9);
                                break;
                            case 'PRECISION_TEST':
                                // Moderate count, spread formation
                                spawnCount = Math.floor(spawnCount * 1.1);
                                lateGameScaling *= 0.95;
                                break;
                            case 'VULNERABILITY_TEST':
                                // Balanced count, rewards class builds
                                lateGameScaling *= 1.1;
                                break;
                        }
                    }

                    // Store late-game scaling factor globally for damage calculations
                    store.world.lateGameDamageScaling = lateGameScaling;

                    // Apply collar bonus to spawn count with defensive guards
                    const collarStacks = sanitizeCollarStacks();
                    const collarBonus = calculateCollarBonus(collarStacks);
                    const plannedSpawnCountRaw = spawnCount * collarBonus;
                    const plannedSpawnCount = Math.max(0, ensureFiniteNumber(Math.floor(plannedSpawnCountRaw), 0));

                    const rawEnemyCap = ensureFiniteNumber(store.world.enemyCap, 36);
                    const enemyCap = rawEnemyCap > 0 ? rawEnemyCap : 36;

                    let cappedSpawnCount = Math.min(enemyCap, plannedSpawnCount);
                    if (!Number.isFinite(cappedSpawnCount) || cappedSpawnCount <= 0) {
                        cappedSpawnCount = 1;
                        store.world.lastSpawnFallback = true;
                    } else {
                        store.world.lastSpawnFallback = false;
                    }

                    const spawnIterations = Math.max(1, Math.floor(cappedSpawnCount));
                    const threatScaleRaw = spawnIterations > 0 && plannedSpawnCount > 0 ? plannedSpawnCount / spawnIterations : 1;
                    const threatScale = ensureFiniteNumber(threatScaleRaw, 1);

                    store.world.lastThreatScale = threatScale;
                    store.world.lastSpawnOverflow = Math.max(0, plannedSpawnCount - spawnIterations);
                    store.world.lastPlannedSpawnCount = plannedSpawnCount;
                    store.world.lastSpawnCount = 0;

                    spawnCount = spawnIterations;

                    if (store.world.wave > 8) {
                        const championChance = Math.min(0.4, 0.12 + (store.world.wave - 8) * 0.025);
                        if (Math.random() < championChance) {
                            // Cap champion scaling to prevent absurd HP values
                            const maxChampionScale = 3.0; // Max 3x scaling instead of unlimited
                            const cappedHpScale = Math.min(maxChampionScale, threatScale);
                            const cappedLateGameScaling = Math.min(maxChampionScale, lateGameScaling);

                            const champion = spawnVoidChampion({
                                hpScale: cappedHpScale,
                                damageMult: Math.min(2.0, threatScale), // Cap damage scaling at 2x
                                lateGameScaling: cappedLateGameScaling
                            });
                            if (champion) {
                                spawnCount = Math.max(1, spawnCount - 1);
                            }
                        }
                    }
                    const spawnSpecs = buildWaveSpawnSpecs(store.world.wave, spawnCount, threatScale, lateGameScaling);

                    if (spawnSpecs.length === 0) {
                        console.warn('Enemy spawn pipeline produced zero entities; applying fallback spawn.', {
                            wave: store.world.wave,
                            plannedSpawnCount,
                            enemyCap,
                            collarStacks,
                            threatScale
                        });
                        spawnSpecs.push({
                            type: 'drone',
                            props: { hpScale: threatScale, damageMult: threatScale },
                            lateGameScaling,
                            spawnDuration: 0.6,
                            spawnDropDistance: 120,
                            effectColor: teleportAuraByType.drone
                        });
                        store.world.lastSpawnFallback = true;
                    }

                    const plannedClusters = Math.max(1, Math.ceil(spawnSpecs.length / 4));
                    const clusterCount = Math.min(6, plannedClusters);
                    const spawnTempo = Math.max(0.2, 0.55 - Math.min(store.world.wave, 25) * 0.015);

                    store.pendingSpawnCount = spawnSpecs.length;
                    store.world.lastSpawnQueueLength = spawnSpecs.length;
                    store.world.lastSpawnTempo = spawnTempo;
                    store.world.lastSpawnCount = store.enemies.length;

                    scheduleWaveSpawnClusters(spawnSpecs, {
                        clusterCount,
                        baseDelay: spawnTempo,
                        jitter: spawnTempo * 0.6
                    });

                    const cooldownReady = !store.world.voidReaperCooldown || store.world.voidReaperCooldown <= 0;
                    const recentWaveGap = store.world.lastVoidReaperWave ? (store.world.wave - store.world.lastVoidReaperWave) : Infinity;
                    const eligibleForVoidReaper = store.world.wave >= 12 && cooldownReady && recentWaveGap >= (VOID_REAPER_CONFIG.minWaveGap || 3) && !store.world.voidReaperSpawnedThisWave;
                    if (eligibleForVoidReaper) {
                        const baseChance = 0.14;
                        const waveBonus = Math.min(0.18, Math.max(0, store.world.wave - 12) * 0.012);
                        const loopBonus = Math.min(0.12, (store.world.loop || 0) * 0.02);
                        const spawnChance = Math.min(0.42, baseChance + waveBonus + loopBonus);
                        if (Math.random() < spawnChance) {
                            const spawnDelay = 4.5 + Math.random() * 5.5;
                            const hpScale = Math.min(3.2, threatScale * (0.88 + Math.random() * 0.25));
                            const damageMult = Math.min(2.4, threatScale * (1 + Math.random() * 0.2));
                            store.world.pendingVoidReaper = {
                                timer: spawnDelay,
                                hpScale,
                                damageMult,
                                lateGameScaling
                            };
                            store.world.voidReaperWarningIssued = false;
                        } else {
                            store.world.pendingVoidReaper = null;
                            store.world.voidReaperWarningIssued = false;
                        }
                    } else {
                        store.world.pendingVoidReaper = null;
                        store.world.voidReaperWarningIssued = false;
                    }

                    store.world.waveStartTime = performance.now();
                    const waveProfile = currentWaveProfile || getSpawnProfileForWave(store.world.wave);
                    const openingTransmission = composeWaveTransmission(waveProfile?.theme, store.world.wave);
                    broadcastTransmission(openingTransmission);
                }
            }

            function getBossDefinitionByCycle(cycle) {
                const total = BOSS_DEFINITIONS.length;
                if (total === 0) return null;
                const idx = ((cycle % total) + total) % total;
                return BOSS_DEFINITIONS[idx];
            }

            function createBoss(scale) {
                const cycleRaw = Math.floor((store.world.wave - 5) / 5);
                const def = getBossDefinitionByCycle(cycleRaw) || BOSS_DEFINITIONS[0];
                let hp = def.baseHp * scale * store.world.bossHealthBonus;
                const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
                hp *= collarBonus;

                const boss = {
                    ...def,
                    themeKey: def.key,
                    x: W / 2,
                    y: -80,
                    hpMax: hp,
                    hp,
                    t: 0,
                    fireT: 0,
                    moveT: 0,
                    vx: 100,
                    vy: 30,
                    patternPhase: 0,
                    isEnraged: false,
                    attackPhase: 0,
                    phaseTimer: 0,
                    dashTimer: 0,
                    dashTrailCooldown: 0,
                    rainEvent: null,
                    phase: def.phase ?? 0,
                    isLaughing: def.isLaughing ?? false,
                    laughStartTime: def.laughStartTime ?? 0,
                    visible: def.visible ?? true
                };

                const waveIndex = store && store.world ? store.world.wave : 0;
                const instanceSuffix = Math.random().toString(36).slice(2, 8);
                boss.instanceId = `boss-${waveIndex}-${Date.now().toString(36)}-${instanceSuffix}`;
                boss._instanceId = boss.instanceId;
                boss.spawnWave = waveIndex;
                boss.spawnedAt = performance.now();

                // console.log(`ðŸ† Boss Created: ${boss.name} | Wave: ${store.world.wave} | HP: ${hp} | Scale: ${scale} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x`);

                // Create Boss class instance for DEATH ENGINE
                if (boss.name === 'DEATH ENGINE') {
                    boss.skullRenderer = new Boss(ctx, boss.x, boss.y, boss.color);
                    // Store collar stacks before Death Engine fight to restore them after
                    store.world.deathEngineCollarStacks = store.world.collarStacks;
                    store.world.deathEngineCollarTargetStacks = store.world.collarTargetStacks;
                }

                return boss;
            }

            function spawnEnemy(type = 'drone', props = {}) {
                const cfgs = {
                    drone: { r: 10, v: 80, vx: 0, hp: 22, color: '#C0C0C0', xp: 5, score: 50, gold: 2, fireRateChance: 0.004, contactDamage: 6 },
                    hunter: { r: 20, v: 100, vx: 0, hp: 18, color: '#DC143C', xp: 8, score: 80, gold: 2, fireRateChance: 0.005, contactDamage: 8 },
                    trap_king_add: { r: 6, v: 90, vx: 0, hp: 9, color: '#ffc83d', damage: 5, xp: 2, score: 10, gold: 1, contactDamage: 5 },
                    phantom: { r: 14, v: 90, vx: 0, hp: 35, color: '#FFFFFF', xp: 10, score: 100, gold: 3, fireRateChance: 0.006, fireCooldown: 1.5, contactDamage: 8 },
                    mech: { r: 18, v: 40, vx: 0, hp: 73, color: '#FF8500', xp: 15, score: 150, gold: 5, fireRateChance: 0.007, attackPhase: 0, contactDamage: 10 },
                    construct_gold: { r: 10, v: 120, vx: 0, hp: 17, color: '#e03434', xp: 3, score: 30, gold: 1, contactDamage: 7 },
                    avian_hatchling: { r: 8, v: 150, vx: 0, hp: 22, color: '#9370DB', xp: 4, score: 40, gold: 1, contactDamage: 6 },
                    angler: { r: 22, v: 30, vx: 0, hp: 150, color: '#00008b', xp: 18, score: 180, gold: 4, fireRateChance: 0.008, contactDamage: 10 },
                    manta: { r: 26, v: 50, vx: 0, hp: 175, color: '#53B6FF', xp: 22, score: 220, gold: 5, fireRateChance: 0.009, contactDamage: 10 },
                    shadow_champion: { r: 18, v: 70, vx: 0, hp: 620, color: '#cbd4ff', xp: 60, score: 480, gold: 12, fireRateChance: 1, fireCooldown: 1.45, contactDamage: 14 },
                    void_champion: { r: 16, v: 48, vx: 0, hp: 190, color: '#5A28D8', xp: 32, score: 325, gold: 9, fireRateChance: 0.75, fireCooldown: 1.65, contactDamage: 10 },
                    void_champion_orb: { r: 6, v: 0, vx: 0, hp: 22, color: '#FF7DEB', xp: 2, score: 24, gold: 0, fireRateChance: 0.55, fireCooldown: 1.25, contactDamage: 4 },
                    void_reaper: { r: 20, v: 0, vx: 0, hp: 165, color: '#9f74ff', xp: 55, score: 520, gold: 15, contactDamage: 11 }
                };
                const baseCfg = cfgs[type];
                if (!baseCfg) {
                    console.warn('Unknown enemy type', type);
                    return null;
                }
                let c = { ...baseCfg }; const wave = store.world.wave;

                // FIXED: Much gentler health scaling to prevent unkillable enemies
                // Old: Math.pow(1.075, wave) - exponential growth was too aggressive
                // New: Linear growth with soft cap
                let waveMultiplier;
                if (wave <= 10) {
                    waveMultiplier = 1 + (wave - 1) * 0.15; // +15% per wave early game
                } else {
                    waveMultiplier = 1 + 9 * 0.15 + (wave - 10) * 0.05; // +5% per wave after wave 10
                }

                c.hp *= waveMultiplier * store.world.enemyHealthBonus;
                const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
                c.hp *= collarBonus;

                // console.log(`ðŸ” Enemy Health Debug | Type: ${type} | Base: ${cfgs[type].hp} | Wave: ${wave} | WaveMult: ${waveMultiplier.toFixed(2)} | EnemyBonus: ${store.world.enemyHealthBonus.toFixed(2)} | CollarBonus: ${collarBonus.toFixed(2)} | Final HP: ${c.hp.toFixed(1)}`);
                const spawnX = props.x !== undefined ? props.x : 20 + Math.random() * (W - 40);
                const spawnY = props.y !== undefined ? props.y : -50 - Math.random() * 250;
                const e = {
                    ...c,
                    type,
                    id: Date.now() + Math.random(),
                    x: spawnX,
                    y: spawnY,
                    hpMax: c.hp,
                    phase: type === 'phantom',
                    t: 0,
                    fireT: props.fireT !== undefined ? props.fireT : (c.fireCooldown || 0),
                    isBursting: false,
                    burstTimer: 0,
                    stunTimer: 0,
                    knockback: null,
                    hitPulseTimer: 0,
                    hitPulseDuration: props.hitPulseDuration || 0.22
                };

                if (props.hpScale && props.hpScale !== 1) {
                    e.hp *= props.hpScale;
                    e.hpMax *= props.hpScale;
                }

                e.damageMult = props.damageMult !== undefined ? props.damageMult : 1;
                e.baseContactDamage = props.baseContactDamage || c.contactDamage || 8;
                e.contactDamage = e.baseContactDamage * e.damageMult;

                if (!props.damageMult && props.hpScale && props.hpScale !== 1) {
                    e.damageMult = props.hpScale;
                    e.contactDamage = e.baseContactDamage * e.damageMult;
                }

                if (e.type === 'manta') {
                    e.startX = e.x;
                    e.amplitude = 150 + Math.random() * 100;
                    e.frequency = 0.5 + Math.random() * 0.5;
                    e.dodgeCooldown = 0;
                    e.isDodging = false;
                }
                if (e.type === 'void_champion') {
                    e.attackModule = props.attackModule || e.attackModule || 'default';
                    if (typeof getChampionMinionAbilityTheme === 'function') {
                        e.abilityTheme = props.abilityTheme || getChampionMinionAbilityTheme(e.attackModule);
                    }
                    if (!props.colorScheme && !e.colorScheme && typeof VOID_CHAMPION_SCHEME_BY_MODULE !== 'undefined') {
                        e.colorScheme = VOID_CHAMPION_SCHEME_BY_MODULE[e.attackModule] || VOID_CHAMPION_SCHEME_BY_MODULE.default;
                    }
                    e.fireCooldown = c.fireCooldown || 1.8;
                    e.fireT = e.fireCooldown * (0.4 + Math.random() * 0.6);
                    e.vx = (Math.random() < 0.5 ? -1 : 1) * (40 + Math.random() * 30);
                    e.dashTimer = 2 + Math.random() * 2;
                    e.dashCooldown = 4 + Math.random() * 3;
                    e.minionIds = [];
                    e.nextPattern = 'beam';
                    if (store && store.player) {
                        const pStats = store.player;
                        const dmgFactor = Math.min(3, Math.max(1, pStats.dmgMult || 1));
                        const multishotFactor = 1 + Math.max(0, (pStats.multishot || 1) - 1) * 0.2 + (pStats.rearMultishot || 0) * 0.1;
                        const fireRateBaseline = 0.45;
                        const fireRateFactor = Math.min(2.5, Math.max(1, fireRateBaseline / Math.max(pStats.fireRate || 0.45, 0.18)));
                        const shieldFactor = Math.pow(Math.max(1, (pStats.shieldMax || 0) / 60), 0.2);
                        const healthFactor = Math.pow(Math.max(1, (pStats.hpMax || 100) / 120), 0.2);
                        const playerScaling = Math.min(3.5, Math.max(1, dmgFactor * multishotFactor * fireRateFactor * Math.max(shieldFactor, healthFactor)));
                        e.hp *= playerScaling;
                        e.hpMax *= playerScaling;
                        e.damageMult *= playerScaling;
                        e.contactDamage = e.baseContactDamage * e.damageMult;
                        e.playerScaling = playerScaling;
                    }
                    if (store && store.world && !store.world.seenVoidChampion) {
                        store.world.seenVoidChampion = true;
                        announce('ðŸ“¡ [Command Relay] "Intercepted: Void champion signature just came online."');
                    }
                    if (store && store.enemies) {
                        const minionCount = 3;
                        for (let i = 0; i < minionCount; i++) {
                            const angle = (i / minionCount) * Math.PI * 2;
                            const ringRadius = 42;
                            const minionAbilityTheme = e.abilityTheme || (typeof getChampionMinionAbilityTheme === 'function' ? getChampionMinionAbilityTheme(e.attackModule) : null);
                            const minionTrailColor = minionAbilityTheme?.trail || e.color;
                            const minion = spawnEnemy('void_champion_orb', {
                                x: e.x + Math.cos(angle) * ringRadius,
                                y: e.y + Math.sin(angle) * ringRadius,
                                orbitTargetId: e.id,
                                orbitAngle: angle,
                                orbitRadius: ringRadius,
                                orbitSpeed: 1.3 + i * 0.12,
                                parentColor: minionTrailColor,
                                fireT: Math.random() * 0.6,
                                damageMult: Math.max(1, (e.damageMult || 1) * 0.65),
                                hpScale: Math.max(1, (e.damageMult || 1) * 0.7),
                                attackModule: e.attackModule,
                                abilityTheme: minionAbilityTheme
                            });
                            if (minion) {
                                const minionDrop = 140;
                                const minionTargetY = (e.spawnTargetY ?? e.y + minionDrop) + Math.sin(angle) * 26;
                                minion.spawnTargetY = minionTargetY;
                                activateSpawnIntro(minion, {
                                    duration: 0.55 + Math.random() * 0.1,
                                    dropDistance: minionDrop,
                                    targetY: minionTargetY,
                                    clusterIndex: -1,
                                    effectColor: '#ff7deb',
                                    topClampBuffer: 0.6,
                                    fireDelayBuffer: 0.4
                                });
                                e.minionIds.push(minion.id);
                                store.enemies.push(minion);
                            }
                        }
                    }
                }
                if (e.type === 'shadow_champion') {
                    e.baseV = e.v;
                    e.guardRadius = props.guardRadius || 120;
                    e.guardAngle = props.guardAngle ?? Math.random() * Math.PI * 2;
                    e.angularSpeed = props.angularSpeed || (0.75 + Math.random() * 0.25);
                    e.anchorOffsetY = props.anchorOffsetY ?? 80;
                    e.fireCooldown = props.fireCooldown || e.fireCooldown || 1.45;
                    e.fireT = props.fireT !== undefined ? props.fireT : e.fireCooldown * (0.4 + Math.random() * 0.3);
                    e.momentum = props.momentum || 3.4;
                    e.enrageThreshold = props.enrageThreshold || 0.45;
                    e.state = null;
                    e.dashTimer = 0;
                    e.dashVX = 0;
                    e.dashVY = 0;
                    e.bossLinkId = props.bossLinkId || null;
                    e.guardAnchor = props.guardAnchor || null;
                    e.isShadowChampion = true;
                }
                if (e.type === 'void_champion_orb') {
                    e.isOrbiter = true;
                    e.orbitRadius = props.orbitRadius || 42;
                    e.orbitSpeed = props.orbitSpeed || 1.45;
                    e.orbitAngle = props.orbitAngle ?? Math.random() * Math.PI * 2;
                    e.orbitTargetId = props.orbitTargetId || null;
                    const centerX = props.orbitCenterX !== undefined ? props.orbitCenterX : e.x;
                    const centerY = props.orbitCenterY !== undefined ? props.orbitCenterY : e.y;
                    e.orbitCenter = { x: centerX, y: centerY };
                    if (props.parentColor) {
                        e.color = props.parentColor;
                    }
                    e.attackModule = props.attackModule || e.attackModule || 'default';
                    if (props.abilityTheme) {
                        e.abilityTheme = props.abilityTheme;
                    } else if (!e.abilityTheme && typeof getChampionMinionAbilityTheme === 'function') {
                        e.abilityTheme = getChampionMinionAbilityTheme(e.attackModule);
                    }
                    e.trailColor = e.color || e.abilityTheme?.trail || '#ff7deb';
                    e.fireCooldown = c.fireCooldown || 1.15;
                    e.fireT = props.fireT !== undefined ? props.fireT : e.fireCooldown;
                    e.v = 0;
                }
                if (e.type === 'void_reaper') {
                    e.isVoidReaper = true;
                    e.hp = Math.max(40, e.hp * 0.85);
                    e.hpMax = e.hp;
                    e.v = 0;
                    e.vx = 0;
                    e.contactDamage = Math.max(e.contactDamage || 1, 28);
                    e.gold = Math.max(12, e.gold || 12);
                    e.score = Math.max(420, e.score || 420);
                    e.xp = Math.max(40, e.xp || 40);
                    e.fireRateChance = 0;
                    e.fireT = Infinity;
                    e.hitPulseDuration = props.hitPulseDuration || 0.18;
                    e.hitPulseTimer = 0;
                    e.cannotBeFrozen = true;
                    e.cannotBeKnocked = true;
                    e.knockback = null;
                    e.stunTimer = 0;
                    e.topClampDelay = 0;
                    e.alphaPulseSeed = Math.random() * Math.PI * 2;
                    e.spawnTargetY = props.y !== undefined ? props.y : e.y;
                    e.spawnEdge = props.spawnEdge || 'top';
                    e.entryAngle = props.entryAngle || 0;
                }
                return e;
            }

            function scheduleWaveSpawnClusters(spawnSpecs, options = {}) {
                const clustersRequested = options.clusterCount ?? 3;
                const clusterCount = Math.max(1, Math.min(clustersRequested, spawnSpecs.length || 1));
                const clusters = Array.from({ length: clusterCount }, () => []);

                spawnSpecs.forEach((spec, index) => {
                    clusters[index % clusterCount].push(spec);
                });

                const baseDelay = options.baseDelay ?? 0.35; // seconds between clusters
                const jitterAmplitude = options.jitter ?? baseDelay * 0.35;
                const queue = store.waveSpawnQueue;

                clusters.forEach((cluster, idx) => {
                    if (!cluster.length) return;
                    const stagger = idx === 0 ? 0 : (Math.random() - 0.5) * jitterAmplitude;
                    const timer = Math.max(0, idx * baseDelay + stagger);
                    queue.push({
                        timer,
                        enemies: cluster,
                        clusterIndex: idx,
                        clusterSize: cluster.length,
                        totalClusters: clusterCount,
                        baseDelay
                    });
                });
            }

            function processWaveSpawnQueue(dt) {
                if (!store.waveSpawnQueue.length) return;
                for (let i = store.waveSpawnQueue.length - 1; i >= 0; i--) {
                    const evt = store.waveSpawnQueue[i];
                    evt.timer -= dt;
                    if (evt.timer <= 0) {
                        spawnClusterEnemies(evt);
                        store.waveSpawnQueue.splice(i, 1);
                    }
                }
            }

            function spawnClusterEnemies(event) {
                const clusterSize = event.enemies.length;
                const centerX = Math.max(80, Math.min(W - 80, 80 + Math.random() * (W - 160)));
                
                // THEMED SPAWN FORMATIONS based on current wave profile
                const waveProfile = getSpawnProfileForWave(store.world.wave);
                let spacing = Math.max(40, 140 - clusterSize * 10);
                let formationStyle = 'line'; // default: horizontal line
                
                if (waveProfile && waveProfile.theme) {
                    switch (waveProfile.theme) {
                        case 'SWARM_HELL':
                            // Tight clusters for overwhelming swarms
                            spacing *= 0.6;
                            formationStyle = 'cluster';
                            break;
                        case 'TANK_RUSH':
                        case 'ELITE_ASSAULT':
                            // Wide spread for tanky enemies
                            spacing *= 1.4;
                            formationStyle = 'spread';
                            break;
                        case 'PRECISION_TEST':
                            // Maximum spread to test multi-target
                            spacing *= 1.8;
                            formationStyle = 'spread';
                            break;
                        case 'DODGE_HELL':
                            // Staggered formation
                            formationStyle = 'stagger';
                            break;
                    }
                }
                
                let spawnedThisCluster = 0;

                event.enemies.forEach((spec, idx) => {
                    let lateralOffset, spawnY;
                    
                    // Apply formation-specific positioning
                    switch (formationStyle) {
                        case 'cluster':
                            // Tight cluster with more randomness
                            lateralOffset = (idx - (clusterSize - 1) / 2) * spacing + (Math.random() - 0.5) * 60;
                            spawnY = -140 - Math.random() * 80;
                            break;
                        case 'spread':
                            // Wide spread, minimal randomness
                            lateralOffset = (idx - (clusterSize - 1) / 2) * spacing + (Math.random() - 0.5) * 20;
                            spawnY = -180 - Math.random() * 100;
                            break;
                        case 'stagger':
                            // Alternating heights for dodge patterns
                            lateralOffset = (idx - (clusterSize - 1) / 2) * spacing + (Math.random() - 0.5) * 35;
                            spawnY = -140 - (idx % 2 === 0 ? 0 : 80) - Math.random() * 60;
                            break;
                        default: // 'line'
                            lateralOffset = (idx - (clusterSize - 1) / 2) * spacing + (Math.random() - 0.5) * 35;
                            spawnY = -160 - Math.random() * 120;
                    }
                    
                    const spawnX = Math.max(40, Math.min(W - 40, centerX + lateralOffset));
                    const props = { ...(spec.props || {}), x: spawnX, y: spawnY };
                    const enemy = spawnEnemy(spec.type, props);
                    store.pendingSpawnCount = Math.max(0, (store.pendingSpawnCount || 0) - 1);
                    if (!enemy) {
                        store.world.lastSpawnFallback = true;
                        return;
                    }

                    applySpawnSpecToEnemy(enemy, spec);
                    activateSpawnIntro(enemy, {
                        duration: spec.spawnDuration,
                        dropDistance: spec.spawnDropDistance,
                        clusterIndex: event.clusterIndex,
                        effectColor: spec.effectColor,
                        topClampBuffer: 0.75,
                        clusterSize
                    });

                    store.enemies.push(enemy);
                    store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
                    spawnedThisCluster++;

                    store.activeEffects.push(createEffect('spawnTeleport', enemy.x, enemy.spawnTargetY ?? enemy.y, enemy.r || 18, {
                        duration: (enemy.spawnDuration || 0.6) + 0.25,
                        color: spec.effectColor,
                        clusterIndex: event.clusterIndex,
                        clusterSize
                    }));
                });

                if (spawnedThisCluster === 0) {
                    const fallback = spawnEnemy('drone', { x: centerX, y: -140 });
                    if (fallback) {
                        applySpawnSpecToEnemy(fallback, { lateGameScaling: 1 });
                        activateSpawnIntro(fallback, {
                            duration: 0.6,
                            dropDistance: 110,
                            clusterIndex: event.clusterIndex,
                            effectColor: '#7fd5ff',
                            topClampBuffer: 0.75,
                            clusterSize
                        });
                        store.enemies.push(fallback);
                        store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
                        store.world.lastSpawnFallback = true;
                        store.activeEffects.push(createEffect('spawnTeleport', fallback.x, fallback.spawnTargetY ?? fallback.y, fallback.r || 14, {
                            duration: (fallback.spawnDuration || 0.6) + 0.25,
                            color: '#7fd5ff',
                            clusterIndex: event.clusterIndex,
                            clusterSize,
                            fallback: true
                        }));
                    }
                }
            }

            function applySpawnSpecToEnemy(enemy, spec) {
                if (spec.lateGameScaling && spec.lateGameScaling > 1) {
                    enemy.hp *= spec.lateGameScaling;
                    enemy.hpMax *= spec.lateGameScaling;
                    enemy.damageMult = (enemy.damageMult || 1) * spec.lateGameScaling;
                }
                if (spec.props && spec.props.damageMult !== undefined) {
                    enemy.damageMult = spec.props.damageMult;
                }
                enemy.baseContactDamage = spec.baseContactDamage ?? enemy.baseContactDamage ?? enemy.contactDamage ?? 8;
                enemy.contactDamage = enemy.baseContactDamage * (enemy.damageMult || 1);
                if (typeof spec.onSpawn === 'function') {
                    try {
                        spec.onSpawn(enemy);
                    } catch (err) {
                        console.warn('Spawn spec hook failed', err);
                    }
                }
            }

            function activateSpawnIntro(enemy, opts = {}) {
                const duration = opts.duration ?? enemy.spawnDuration ?? (0.6 + Math.random() * 0.2);
                const dropDistance = opts.dropDistance ?? enemy.spawnDropDistance ?? (80 + Math.random() * 70);
                const existingTarget = enemy.spawnTargetY !== undefined ? enemy.spawnTargetY : enemy.y;
                const targetY = opts.targetY ?? (enemy.spawnTargetY !== undefined ? existingTarget : existingTarget + dropDistance);
                const startY = targetY - dropDistance;

                enemy.spawnPhase = 'teleport';
                enemy.spawnDuration = duration;
                enemy.spawnTimer = duration;
                enemy.spawnTargetY = targetY;
                enemy.spawnStartY = startY;
                enemy.spawnOpacity = 0;
                enemy.spawnEffectColor = opts.effectColor ?? enemy.spawnEffectColor;
                enemy.spawnClusterIndex = opts.clusterIndex ?? enemy.spawnClusterIndex ?? 0;
                enemy.spawnClusterSize = opts.clusterSize ?? enemy.spawnClusterSize ?? 1;
                enemy.spawnIntroGlow = opts.glowStrength ?? enemy.spawnIntroGlow ?? 1;
                enemy.topClampDelay = Math.max(enemy.topClampDelay || 0, duration + (opts.topClampBuffer ?? 0.5));
                enemy.fireT = Math.max(enemy.fireT || 0, duration + (opts.fireDelayBuffer ?? 0.25));
                enemy.y = startY;
            }

            function registerEnemyHit(enemy, impact = {}) {
                if (!enemy || enemy.dead) return;

                const duration = impact.duration ?? enemy.hitPulseDuration ?? 0.22;
                enemy.hitPulseDuration = duration;
                enemy.hitPulseTimer = duration;

                const shakeIntensity = impact.shakeIntensity ?? 0;
                if (shakeIntensity > 0) {
                    const shakeDuration = Math.max(impact.shakeDuration ?? 0.16, 0);
                    enemy.hitShakeDuration = Math.max(enemy.hitShakeDuration || 0, shakeDuration);
                    enemy.hitShakeTimer = Math.max(enemy.hitShakeTimer || 0, shakeDuration);
                    enemy.hitShakeIntensity = Math.max(enemy.hitShakeIntensity || 0, shakeIntensity);
                }

                if (impact.slowFactor !== undefined && impact.slowFactor < 1) {
                    const slowDuration = Math.max(impact.slowDuration ?? 0.12, 0);
                    if (slowDuration > 0) {
                        enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, impact.slowFactor);
                        enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
                    }
                }

                const strength = impact.knockbackStrength ?? 140;
                if (strength > 0) {
                    const angle = impact.angle ?? 0;
                    const vx = Math.cos(angle) * strength;
                    const vy = Math.sin(angle) * strength;
                    const knockDuration = impact.knockbackDuration ?? 0.1;

                    if (!enemy.knockback || enemy.knockback.type === 'hitReaction') {
                        enemy.knockback = {
                            vx,
                            vy,
                            duration: knockDuration,
                            type: 'hitReaction'
                        };
                    } else if (enemy.knockback && enemy.knockback.vx !== undefined && enemy.knockback.type !== 'maraLaunch' && enemy.knockback.type !== 'jugCharge') {
                        enemy.knockback.vx += vx * 0.35;
                        enemy.knockback.vy += vy * 0.35;
                        enemy.knockback.duration = Math.max(enemy.knockback.duration || 0, knockDuration * 0.8);
                    }
                } else if (strength === 0 && enemy.knockback && enemy.knockback.type === 'hitReaction') {
                    enemy.knockback = null;
                }

                if (impact.effect !== false) {
                    store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, enemy.r || 16, {
                        angle: impact.angle ?? 0,
                        strength,
                        crit: impact.crit || false
                    }));
                }
            }

            function computeBeefChargeContext(p) {
                let impactRadius = 80;
                if (p.skillTree && p.skillTree.juggernaut) impactRadius = 120;
                if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) impactRadius = 160;
                if (p.beefExplosionRadius) impactRadius *= p.beefExplosionRadius;
                if (p.subclass === 'juggernaut') impactRadius = Math.max(impactRadius, 120);

                // Reduced base damage for better balance - charge is utility/mobility first, damage second
                let baseDamage = 35; // Reduced from 80
                if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) baseDamage = 65; // Reduced from 150
                if (p.beefChargeDamage) baseDamage *= p.beefChargeDamage;
                if (p.beefExplosionDamage) baseDamage *= p.beefExplosionDamage;
                if (p.beefChargeDamageMultiplier) baseDamage *= p.beefChargeDamageMultiplier;

                const damageTags = p.subclass === 'juggernaut' ? ['fire', 'explosive'] : ['kinetic', 'concussive'];

                const hasJuggernautSkills = (p.skillTree && p.skillTree.juggernaut) || p.subclass === 'juggernaut' ||
                    (p.skillTree && (p.skillTree.juggernaut_charge_power || p.skillTree.juggernaut_charge_mastery ||
                        p.skillTree.juggernaut_heavy_armor || p.skillTree.juggernaut_unstoppable || p.skillTree.juggernaut_enhanced));

                const chainDamageBonus = p.beefChainDamageBonus || (p.beefChainMode ? 1.25 : 1);
                const chainRadiusScale = p.beefChainMode ? 0.85 : 1;

                return {
                    impactRadius,
                    baseDamage,
                    damageTags,
                    hasJuggernautSkills,
                    explosionSound: hasJuggernautSkills ? 'charge' : 'beefCharge',
                    knockbackBase: 250,
                    doubleHitMultiplier: p.marauderDoubleHitBonus || 2.0,
                    chainDamageBonus,
                    chainRadiusScale
                };
            }

            function getBeefChargeTargetPosition(segment) {
                if (!segment) return { x: 0, y: 0 };
                if (segment.enemy && !segment.enemy.dead) {
                    segment.fallbackX = segment.enemy.x;
                    segment.fallbackY = segment.enemy.y;
                }
                const targetX = segment.fallbackX !== undefined ? segment.fallbackX : (segment.startX ?? 0);
                const targetY = segment.fallbackY !== undefined ? segment.fallbackY : (segment.startY ?? 0);
                return { x: targetX, y: targetY };
            }

            function findClosestEnemyInRange(origin, enemies, rangeSq, used = new Set()) {
                if (!origin || !enemies || enemies.length === 0) return null;
                const ox = origin.x ?? 0;
                const oy = origin.y ?? 0;
                let best = null;
                let bestDistSq = Infinity;
                enemies.forEach(enemy => {
                    if (!enemy || enemy.dead || enemy.stunTimer > 0) return;
                    if (used && used.has(enemy)) return;
                    const dx = enemy.x - ox;
                    const dy = enemy.y - oy;
                    const distSq = dx * dx + dy * dy;
                    if (rangeSq !== undefined && distSq > rangeSq) return;
                    if (!best || distSq < bestDistSq) {
                        best = enemy;
                        bestDistSq = distSq;
                    }
                });
                return best;
            }

            function buildBeefChargePlan(p, primaryEnemy, potentialTargets = []) {
                if (!p || !primaryEnemy) return null;

                const context = computeBeefChargeContext(p);
                const origin = { x: p.x, y: p.y };
                const rangeMultiplier = p.beefChargeRange || 1;
                const baseRange = 240;
                const effectiveRange = baseRange * rangeMultiplier;
                const rangeSq = effectiveRange * effectiveRange;
                const segments = [];
                const used = new Set();

                const pushEnemySegment = (enemy, label) => {
                    if (!enemy || enemy.dead || used.has(enemy)) return;
                    segments.push({
                        enemy,
                        fallbackX: enemy.x,
                        fallbackY: enemy.y,
                        doImpact: true,
                        label
                    });
                    used.add(enemy);
                };

                pushEnemySegment(primaryEnemy, 'primary');

                if (p.beefChainMode && p.beefMaxCharges > 1) {
                    let anchor = primaryEnemy;
                    const maxChains = Math.min(p.beefMaxCharges - 1, potentialTargets.length);
                    for (let i = 0; i < maxChains; i++) {
                        const reference = (anchor && !anchor.dead)
                            ? { x: anchor.x, y: anchor.y }
                            : (segments.length
                                ? { x: segments[segments.length - 1].fallbackX, y: segments[segments.length - 1].fallbackY }
                                : origin);
                        const nextEnemy = findClosestEnemyInRange(reference, potentialTargets, rangeSq, used);
                        if (!nextEnemy) break;
                        pushEnemySegment(nextEnemy, 'chain');
                        anchor = nextEnemy;
                    }
                }

                if (segments.length === 0) return null;

                const returnToOrigin = !p.beefChainMode && p.subclass !== 'marauder';
                if (returnToOrigin) {
                    segments.push({
                        enemy: null,
                        fallbackX: origin.x,
                        fallbackY: origin.y,
                        doImpact: false,
                        label: 'return'
                    });
                }

                return {
                    context,
                    origin,
                    segments,
                    chainDelay: p.beefChainMode ? 0.08 : 0,
                    recoveryDelay: returnToOrigin ? 0.1 : 0.12,
                    segmentDuration: 0.24 / Math.max(p.beefChargeSpeed || 1.35, 0.6),
                    returnToOrigin
                };
            }

            function spawnBeefChargeTrail(startX, startY, targetX, targetY, options = {}) {
                store.activeEffects.push(createEffect('beefCharge', { x: startX, y: startY }, { x: targetX, y: targetY }, undefined, options));
            }

            function resolveBeefChargeImpact(p, context, impactX, impactY, options = {}) {
                const segment = options.segment || null;
                const segmentLabel = segment ? segment.label : 'primary';
                const segmentIndex = options.index ?? 0;
                let impactRadius = context.impactRadius;
                if (segmentLabel === 'chain' && context.chainRadiusScale) {
                    impactRadius *= context.chainRadiusScale;
                }

                if (context.hasJuggernautSkills) {
                    playSound(context.explosionSound);
                    explode(impactX, impactY, false, true);
                } else {
                    playSound(context.explosionSound);
                }

                store.activeEffects.push(createEffect('marauderImpact', impactX, impactY, impactRadius, {
                    subclass: p.subclass,
                    segmentLabel,
                    segmentIndex
                }));

                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                if (!p.marauderHitTargets) p.marauderHitTargets = new Set();

                let lastEnemyHit = null;
                const radiusSq = impactRadius * impactRadius;

                potentialTargets.forEach(e => {
                    if (!e || e.dead) return;
                    const dx = e.x - impactX;
                    const dy = e.y - impactY;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > radiusSq) return;

                    let damageMultiplier = 1;
                    if (segmentLabel === 'chain') {
                        if (context.chainDamageBonus) damageMultiplier *= context.chainDamageBonus;
                        if (p.beefChainBonus) damageMultiplier *= p.beefChainBonus;
                    }
                    let chargeDmg = context.baseDamage * damageMultiplier * p.dmgMult;
                    const enemyId = e.id || `${e.x}_${e.y}_${e.type}`;
                    let isDoubleHit = false;

                    if (p.subclass === 'marauder') {
                        if (p.marauderHitTargets.has(enemyId)) {
                            isDoubleHit = true;
                            const multiplier = context.doubleHitMultiplier || 2.0;
                            if (e === store.boss || e.type === 'void_champion') {
                                chargeDmg *= multiplier * 1.5;
                                e.stunTimer = 8.0;
                                e.marauderMarked = true;
                                announce('CHAMPION DEVASTATION!');
                            } else {
                                e.isFlattened = true;
                                e.flattenedTime = performance.now();
                                e.v = 0;
                                e.vx = 0;
                                e.vy = 0;
                                e.hp = Math.min(e.hp, 1);
                                e.stunTimer = Math.max(e.stunTimer || 0, 999);
                                e.fireRateChance = 0;
                                e.flattenScale = { x: 2.0, y: 0.1 };
                                const bonusText = multiplier >= 3.0 ? 'ELITE FLATTEN!' : 'MARAUDER FLATTEN!';
                                announce(bonusText);
                            }
                            setTimeout(() => p.marauderHitTargets.delete(enemyId), 100);
                        } else {
                            p.marauderHitTargets.add(enemyId);
                            setTimeout(() => p.marauderHitTargets.delete(enemyId), 3000);
                        }
                    }

                    const knockbackAngle = Math.atan2(e.y - impactY, e.x - impactX);
                    const vulnResult = applySubclassVulnerability(e, chargeDmg, {
                        player: p,
                        subclass: p.subclass,
                        damageTags: context.damageTags,
                        source: 'beefCharge',
                        knockbackAngle,
                        baseDamage: chargeDmg
                    });
                    chargeDmg = vulnResult.damage;

                    e.hp -= chargeDmg;
                    if (!isDoubleHit) {
                        e.stunTimer = Math.max(e.stunTimer || 0, 2.5);
                    }

                    if (p.vampirism > 0) {
                        let healAmount = chargeDmg * p.vampirism;
                        healAmount = Math.max(healAmount, 1);
                        healAmount = Math.min(healAmount, 8);
                        p.hp = Math.min(p.hpMax, p.hp + healAmount);
                    }

                    let knockbackForce = context.knockbackBase * (segmentLabel === 'chain' ? Math.max(0.85, damageMultiplier) : 1);
                    if (p.beefChargeKnockback) {
                        knockbackForce *= p.beefChargeKnockback;
                    }
                    if (!e.knockback || e.knockback.type !== 'maraLaunch') {
                        e.knockback = {
                            vx: Math.cos(knockbackAngle) * knockbackForce,
                            vy: Math.sin(knockbackAngle) * knockbackForce,
                            duration: 0.3,
                            type: 'maraLaunch'
                        };
                    }

                    lastEnemyHit = e;
                });

                return {
                    x: impactX,
                    y: impactY,
                    enemy: lastEnemyHit
                };
            }

            function stepPlayer(dt) {
                const p = store.player;
                
                // Check if star power invincibility should expire
                if (p.isInvincible && p.starPowerEndTime && performance.now() >= p.starPowerEndTime) {
                    p.isInvincible = false;
                    p.starPowerEndTime = null;
                    announce('â­ Star Power Expired');
                }
                
                if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0 && p.beefChargeState !== 'ready') {
                    const plan = p.beefChargePlan;
                    if (!plan || !plan.segments || plan.segments.length === 0) {
                        p.beefChargeState = 'ready';
                        p.beefChargePlan = null;
                        p.beefChargeT = 0;
                        p.beefImpactDelay = 0;
                        p.isInvincible = false;
                    } else if (p.beefChargeState === 'charging') {
                        const segmentIndex = Math.min(p.beefChargeSegmentIndex, plan.segments.length - 1);
                        const segment = plan.segments[segmentIndex];
                        if (!segment) {
                            p.beefChargeState = 'ready';
                            p.beefChargePlan = null;
                            p.beefChargeT = 0;
                            p.isInvincible = false;
                        } else {
                            if (segment.startX === undefined) {
                                segment.startX = p.x;
                                segment.startY = p.y;
                            }
                            const targetPos = getBeefChargeTargetPosition(segment);
                            const startX = segment.startX;
                            const startY = segment.startY;
                            const progress = Math.min((p.beefChargeT + dt) / plan.segmentDuration, 1);
                            const eased = 1 - Math.pow(1 - progress, 3);
                            p.x = startX + (targetPos.x - startX) * eased;
                            p.y = startY + (targetPos.y - startY) * eased;
                            p.beefChargeT += dt;
                            p.isInvincible = true;
                            const distSq = (targetPos.x - p.x) * (targetPos.x - p.x) + (targetPos.y - p.y) * (targetPos.y - p.y);
                            if (progress >= 1 || distSq < 9) {
                                p.x = targetPos.x;
                                p.y = targetPos.y;
                                const impactResult = segment.doImpact
                                    ? resolveBeefChargeImpact(p, plan.context, targetPos.x, targetPos.y, {
                                        segment,
                                        index: p.beefChargeSegmentIndex
                                    })
                                    : { x: targetPos.x, y: targetPos.y, enemy: null };
                                if (segment.doImpact || !p.beefLastImpact) {
                                    p.beefLastImpact = impactResult;
                                }
                                p.beefChargeSegmentIndex++;
                                p.beefChargeT = 0;
                                if (p.beefChargeSegmentIndex < plan.segments.length) {
                                    p.beefImpactDelay = plan.chainDelay;
                                    if (plan.chainDelay > 0) {
                                        p.beefChargeState = 'impactPause';
                                    } else {
                                        const nextSegment = plan.segments[p.beefChargeSegmentIndex];
                                        nextSegment.startX = p.x;
                                        nextSegment.startY = p.y;
                                        const nextTarget = getBeefChargeTargetPosition(nextSegment);
                                        p.beefChargeOrigin = { x: p.x, y: p.y };
                                        p.beefChargeTarget = { x: nextTarget.x, y: nextTarget.y };
                                        spawnBeefChargeTrail(p.x, p.y, nextTarget.x, nextTarget.y, {
                                            subclass: p.subclass,
                                            segmentIndex: p.beefChargeSegmentIndex,
                                            segmentLabel: nextSegment.label,
                                            rangeOverride: plan.context.impactRadius
                                        });
                                    }
                                } else {
                                    p.beefImpactDelay = plan.recoveryDelay;
                                    p.beefChargeState = 'recovering';
                                    p.beefChargePlan = null;
                                    p.isInvincible = false;
                                }
                            }
                        }
                    } else if (p.beefChargeState === 'impactPause') {
                        p.beefImpactDelay -= dt;
                        p.isInvincible = true;
                        if (p.beefImpactDelay <= 0) {
                            if (plan && p.beefChargeSegmentIndex < plan.segments.length) {
                                const nextSegment = plan.segments[p.beefChargeSegmentIndex];
                                nextSegment.startX = p.x;
                                nextSegment.startY = p.y;
                                const nextTarget = getBeefChargeTargetPosition(nextSegment);
                                p.beefChargeOrigin = { x: p.x, y: p.y };
                                p.beefChargeTarget = { x: nextTarget.x, y: nextTarget.y };
                                spawnBeefChargeTrail(p.x, p.y, nextTarget.x, nextTarget.y, {
                                    subclass: p.subclass,
                                    segmentIndex: p.beefChargeSegmentIndex,
                                    segmentLabel: nextSegment.label,
                                    rangeOverride: plan.context.impactRadius
                                });
                                p.beefChargeState = 'charging';
                                p.beefChargeT = 0;
                            } else {
                                p.beefChargeState = 'recovering';
                                p.beefImpactDelay = plan ? plan.recoveryDelay : 0.12;
                                p.isInvincible = false;
                            }
                        }
                    } else if (p.beefChargeState === 'recovering') {
                        p.beefImpactDelay -= dt;
                        if (p.beefImpactDelay <= 0) {
                            p.beefChargeState = 'ready';
                            p.beefChargePlan = null;
                            p.beefChargeT = 0;
                            p.beefImpactDelay = 0;
                            p.isInvincible = false;
                        }
                    }
                } else {
                    // MOVEMENT LOGIC
                    if (document.body.classList.contains('mobile-controls-active')) {
                        // Joystick Movement
                        const moveSpeed = p.speed;
                        p.x += joystickState.input.x * moveSpeed * dt;
                        p.y += joystickState.input.y * moveSpeed * dt;
                        p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
                    } else {
                        const vx = mouse.x - p.x, vy = mouse.y - p.y;
                        const dist = Math.sqrt(vx * vx + vy * vy);
                        if (dist < 15) {
                            p.x = mouse.x;
                            p.y = mouse.y;
                        } else {
                            const accelFactor = 0.0125;
                            p.x += vx * p.speed * dt * accelFactor;
                            p.y += vy * p.speed * dt * accelFactor;
                        }
                        p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
                    }
                }
                if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0) {
                    if (p.beefCharges < p.beefMaxCharges) {
                        if (p.beefChargeCooldown > 0) {
                            p.beefChargeCooldown = Math.max(0, p.beefChargeCooldown - dt);
                        }
                        if (p.beefChargeCooldown <= 0) {
                            p.beefCharges++;
                            if (p.beefCharges < p.beefMaxCharges) {
                                p.beefChargeCooldown = 8;
                            }
                        }
                    }

                    const shouldCharge = p.isRequestingCharge || !document.body.classList.contains('mobile-controls-active');

                    if (p.beefChargeState === 'ready' && p.beefCharges > 0 && shouldCharge) {
                        p.isRequestingCharge = false;
                        const chargeRadius = 120;
                        let closestEnemy = null;
                        let closestDistSq = chargeRadius * chargeRadius;
                        const potentialTargets = store.boss ? [...store.enemies, store.boss] : [...store.enemies];
                        potentialTargets.forEach(enemy => {
                            if (!enemy || enemy.dead || enemy.stunTimer > 0) return;
                            const dx = enemy.x - p.x;
                            const dy = enemy.y - p.y;
                            const distSq = dx * dx + dy * dy;
                            if (distSq < closestDistSq) {
                                closestDistSq = distSq;
                                closestEnemy = enemy;
                            }
                        });

                        if (closestEnemy) {
                            if (p.beefCharges === p.beefMaxCharges) {
                                p.beefChargeCooldown = 8;
                            }
                            p.beefCharges = Math.max(0, p.beefCharges - 1);

                            const plan = buildBeefChargePlan(p, closestEnemy, potentialTargets);
                            if (plan) {
                                plan.primaryEnemy = closestEnemy;
                                p.beefChargePlan = plan;
                                p.beefChargeSegmentIndex = 0;
                                p.beefChargeState = 'charging';
                                p.beefChargeT = 0;
                                p.beefImpactDelay = 0;
                                p.isInvincible = true;
                                p.beefLastImpact = null;

                                const firstSegment = plan.segments[0];
                                firstSegment.startX = p.x;
                                firstSegment.startY = p.y;
                                const firstTarget = getBeefChargeTargetPosition(firstSegment);
                                p.beefChargeOrigin = { x: p.x, y: p.y };
                                p.beefChargeTarget = { x: firstTarget.x, y: firstTarget.y };
                                spawnBeefChargeTrail(p.x, p.y, firstTarget.x, firstTarget.y, {
                                    subclass: p.subclass,
                                    segmentIndex: p.beefChargeSegmentIndex,
                                    segmentLabel: firstSegment.label,
                                    rangeOverride: plan.context.impactRadius
                                });

                                if ((p.beefDoubleCharge || (p.skillTree && p.skillTree.combo_charge)) && p.beefCharges > 0) {
                                    p.beefQueuedCharge = {
                                        delay: 0.4,
                                        fallback: { x: firstTarget.x, y: firstTarget.y },
                                        targetEnemy: closestEnemy
                                    };
                                } else {
                                    p.beefQueuedCharge = null;
                                }
                            } else {
                                p.beefChargeState = 'ready';
                                p.isInvincible = false;
                            }
                        }
                    } else if (p.beefChargeState !== 'ready') {
                        p.isRequestingCharge = false;
                    }

                    if (p.beefQueuedCharge) {
                        p.beefQueuedCharge.delay -= dt;
                        if (p.beefQueuedCharge.delay <= 0) {
                            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                                const potentialTargets = store.boss ? [...store.enemies, store.boss] : [...store.enemies];
                                let comboEnemy = p.beefQueuedCharge.targetEnemy;
                                if (!comboEnemy || comboEnemy.dead) {
                                    comboEnemy = findClosestEnemyInRange(p.beefQueuedCharge.fallback, potentialTargets, 180 * 180);
                                }
                                if (comboEnemy) {
                                    if (p.beefCharges === p.beefMaxCharges) {
                                        p.beefChargeCooldown = 8;
                                    }
                                    p.beefCharges = Math.max(0, p.beefCharges - 1);
                                    const comboPlan = buildBeefChargePlan(p, comboEnemy, potentialTargets);
                                    if (comboPlan) {
                                        comboPlan.primaryEnemy = comboEnemy;
                                        p.beefChargePlan = comboPlan;
                                        p.beefChargeSegmentIndex = 0;
                                        p.beefChargeState = 'charging';
                                        p.beefChargeT = 0;
                                        p.beefImpactDelay = 0;
                                        p.isInvincible = true;
                                        p.beefLastImpact = null;

                                        const firstSegment = comboPlan.segments[0];
                                        firstSegment.startX = p.x;
                                        firstSegment.startY = p.y;
                                        const firstTarget = getBeefChargeTargetPosition(firstSegment);
                                        p.beefChargeOrigin = { x: p.x, y: p.y };
                                        p.beefChargeTarget = { x: firstTarget.x, y: firstTarget.y };
                                        spawnBeefChargeTrail(p.x, p.y, firstTarget.x, firstTarget.y, {
                                            subclass: p.subclass,
                                            segmentIndex: p.beefChargeSegmentIndex,
                                            segmentLabel: firstSegment.label,
                                            rangeOverride: comboPlan.context ? comboPlan.context.impactRadius : undefined
                                        });
                                        p.beefQueuedCharge = null;
                                    }
                                }
                            }

                            if (p.beefQueuedCharge) {
                                p.beefQueuedCharge.delay = 0.08;
                            }
                        }
                    }
                } else if (p.pilotGenome === 'rocketman' && p.hasFirewall) {
                    // Rocketman Flame Pulse system
                    if (!p.flamePulseInitialized) {
                        const baseCooldown = p.firewallCooldown || 8; // 8 second cooldown
                        p.flamePulseCooldownMax = baseCooldown;
                        const immediateCast = Math.random() < 0.5;
                        p.flamePulseCooldown = immediateCast ? 0 : baseCooldown;
                        p.flamePulseCharge = immediateCast ? 1 : 0;
                        p.flamePulseInitialized = true;
                    }

                    const cooldownMax = p.flamePulseCooldownMax || 8;

                    if (p.flamePulseCooldown > 0) {
                        p.flamePulseCooldown = Math.max(0, p.flamePulseCooldown - dt);
                    }

                    const cooldownProgress = cooldownMax > 0 ? 1 - (p.flamePulseCooldown / cooldownMax) : 1;
                    p.flamePulseCharge = cooldownProgress;

                    // Release flame pulse when ready
                    if (p.flamePulseCooldown <= 0) {
                        // Create expanding fire ring
                        store.flamePulses.push({
                            x: p.x,
                            y: p.y,
                            radius: 20, // Start small
                            maxRadius: 200, // Expand to 200 pixels
                            speed: 250, // Expansion speed
                            life: 2.0, // Lasts 2 seconds
                            damage: 0.6, // Damage per frame
                            knockback: 300, // Knockback strength
                            dead: false
                        });
                        
                        p.flamePulseCooldown = cooldownMax;
                        p.flamePulseCharge = 0;
                        playSound('explosion'); // Sound effect
                    }
                } else if (p.pilotGenome === 'voidmancer') {
                    if (p.hasChainLightning || p.hasHybridVoid) {
                        p.chainLightningCooldown -= dt;
                        if (p.chainLightningCooldown <= 0) {
                            fireChainLightning();
                            // Set cooldown based on stormstriker level - more bolts = faster alternation
                            if (p.stormstrikerLevel >= 3) {
                                p.chainLightningCooldown = 0.375; // 4-bolt rotation: quadruple fire rate
                            } else if (p.stormstrikerLevel >= 2) {
                                p.chainLightningCooldown = 0.75; // Alternating bolts: double fire rate
                            } else {
                                p.chainLightningCooldown = 1.5; // Single bolt: normal rate
                            }
                        }
                    }

                    // Voidmancer base laser beam system
                    if (p.hasVoidLaser) {
                        stepVoidLaser(dt); // Regular seeking lasers for Phasestriker
                    }

                    // Wiper lasers work for both Phasestriker and Stormbringer
                    if (p.wiperLasers) {
                        stepWiperLasers(dt); // Ultimate ability for both subclasses
                    }
                }
                if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
                
                // Update escort drones
                if (store.escortDrones && store.escortDrones.length > 0) {
                    stepEscortDrones(dt);
                }
                
                if (p.hasBeefClone) {
                    if (store.beefClone && store.beefClone.mode === 'juggernaut_bomber') {
                        updateJuggernautClone(dt);
                    } else {
                        updateMirrorClone(dt);
                    }
                }
                if (p.timeShardTimer > 0) {
                    p.timeShardTimer = Math.max(0, p.timeShardTimer - dt);
                    if (p.timeShardTimer <= 0) {
                        p.timeShardStacks = 0;
                        p.timeShardMultiplier = 1;
                    }
                }
                p.fireT -= dt;
                const timeShardRate = p.timeShardMultiplier && p.timeShardMultiplier > 0 ? p.timeShardMultiplier : 1;
                if (p.fireT <= 0 && !p.empDisabled) { firePlayer(); p.fireT = p.fireRate * timeShardRate; }

                // Iceman has independent fire rate (level 2+: 50% faster)
                if (p.hasIceman && store.iceman && !p.empDisabled) {
                    // Ensure timer is initialized
                    if (typeof p.icemanFireT !== 'number' || isNaN(p.icemanFireT)) {
                        console.warn('Iceman fireT was invalid, initializing to 0');
                        p.icemanFireT = 0;
                    }
                    
                    const icemanLevel = store.iceman.level || 1;
                    const icemanFireRate = icemanLevel >= 2 ? p.fireRate * 0.67 : p.fireRate; // 50% faster at level 2+
                    p.icemanFireT -= dt;
                    if (p.icemanFireT <= 0) {
                        console.log(`Iceman ready to fire! fireT: ${p.icemanFireT}, rate: ${icemanFireRate}`);
                        fireIcemanShot();
                        p.icemanFireT = icemanFireRate * timeShardRate;
                        console.log(`Iceman fireT reset to: ${p.icemanFireT}`);
                    }
                } else if (p.hasIceman && !store.iceman) {
                    console.error('Player hasIceman but store.iceman is missing!');
                } else if (p.hasIceman && p.empDisabled) {
                    console.log('Iceman disabled by EMP');
                }

                // Separate flamethrower system (unaffected by overclock)
                if (p.flamethrowerLevel > 0 && !p.empDisabled) {
                    p.flamethrowerT -= dt;
                    if (p.flamethrowerT <= 0) {
                        fireFlamethrower();
                        p.flamethrowerT = 0.18; // Fixed fire rate for lava chunks
                    }
                }

                if (p.starCannonLevel > 0 && !p.empDisabled) {
                    p.starCannonTimer -= dt;
                    if (p.starCannonTimer <= 0) {
                        fireStarCannon();
                        p.starCannonTimer += getStarCannonCooldown(p.starCannonLevel);
                    }
                }

                // Homing Missile system (from powerup)
                if (p.powerupTimers['missile'] && !p.empDisabled) {
                    p.missileFireT -= dt;
                    if (p.missileFireT <= 0) {
                        p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                        let closest = null, closestDist = Infinity;
                        const playfieldMargin = 50;
                        const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                        potentialTargets.forEach(e => {
                            if (e.dead || e.hp <= 0 || e.y < 0) return;
                            // Don't target enemies outside playfield
                            if (e.x < -playfieldMargin || e.x > W + playfieldMargin || 
                                e.y < -playfieldMargin || e.y > H + playfieldMargin) return;
                            const dist = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                            if (dist < closestDist) { closest = e; closestDist = dist; }
                        });
                        if (closest) {
                            const isRocketman = p.pilotGenome === 'rocketman';
                            let baseMissileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                            let baseSpeed = 200;

                            // Apply stealth rocket upgrades
                            if (p.stealthRockets) {
                                baseMissileDmg *= (p.stealthRocketDamage || 1.25);
                                baseSpeed *= (p.stealthRocketSpeed || 1.5);
                            }

                            const volleySize = p.missileVolley || 2;

                            for (let i = 0; i < volleySize; i++) {
                                const spreadAngle = (i - (volleySize - 1) / 2) * 0.2;
                                const dx = closest.x - p.x;
                                const dy = closest.y - p.y;
                                const baseAngle = Math.atan2(dy, dx);
                                const finalAngle = baseAngle + spreadAngle;

                                const missile = {
                                    x: p.x, y: p.y - 10,
                                    vx: Math.cos(finalAngle) * baseSpeed,
                                    vy: Math.sin(finalAngle) * baseSpeed,
                                    speed: baseSpeed, turnRate: 4.5,
                                    target: closest, life: 0,
                                    dmg: baseMissileDmg,
                                    cluster: isRocketman && p.missileCluster,
                                    pierce: isRocketman ? (p.missilePierce || 0) : 0,
                                    isIceman: false,
                                    isStealth: p.stealthRockets || false,
                                    startX: p.x,
                                    startY: p.y - 10,
                                    travelDistance: 0
                                };
                                store.missiles.push(missile);
                            }
                        }
                    }
                }

                // Shield recharge system with damage delay
                if (p.shieldMax > 0 && p.shield < p.shieldMax) {
                    if (p.shieldRechargeDelay > 0) {
                        // Still in delay period, count down
                        p.shieldRechargeDelay -= dt;
                        p.shieldRecharging = false;
                    } else {
                        // Delay period over, start/continue recharging
                        p.shieldRecharging = true;
                        p.shield = Math.min(p.shieldMax, p.shield + (p.shieldMax / 6) * dt);
                    }
                } else {
                    p.shieldRecharging = false;
                }

                for (const key in p.powerupTimers) {
                    const timer = p.powerupTimers[key];
                    timer.remaining -= dt;
                    if (timer.remaining <= 0) {
                        if (key === 'drones') {
                            store.drones = [];
                        } else if (key === 'void_core') {
                            const prevDmgMult = p.voidCoreDmgMult || 1;
                            const prevFireRateMult = p.voidCoreFireRateMult || 1;
                            p.dmgMult = p.dmgMult / prevDmgMult;
                            p.fireRate = p.fireRate * prevFireRateMult;
                            p.voidCoreStacks = 0;
                            p.voidCoreDmgMult = 1;
                            p.voidCoreFireRateMult = 1;
                        }
                        delete p.powerupTimers[key];
                    }
                }
                if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
                if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { const isMini = p.miniAbilities && p.miniAbilities.has('gravity_well'); activateGravityWell(isMini ? 0.4 : 1.0); p.voidBeamCooldown = 30; } }
                if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { const isMini = p.miniAbilities && p.miniAbilities.has('lazarus_beam'); activateLazarus(isMini ? 0.5 : 1.0); p.lazarusBeamCooldown = 30 / (p.upgradeLevels.lazarus_beam > 0 ? 2 : 1); } }
                // Handle poison effects
                if (p.isPoisoned && performance.now() > p.poisonEndTime) {
                    p.isPoisoned = false;
                    p.moveSpeed = 100; // Reset to base speed
                }

                // Check poison puddle collisions
                if (store.poisonPuddles) {
                    store.poisonPuddles.forEach(puddle => {
                        const dx = p.x - puddle.x;
                        const dy = p.y - puddle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < puddle.r + p.r) {
                            // Player is in poison puddle - apply damage and effects
                            if (!p.lastPuddleDamageTime || performance.now() - p.lastPuddleDamageTime > 500) {
                                takeDamage(puddle.damage);
                                p.lastPuddleDamageTime = performance.now();

                                // Apply poison debuff
                                p.isPoisoned = true;
                                p.poisonEndTime = performance.now() + 3000; // 3 second poison from puddle
                                p.moveSpeed = Math.max(p.moveSpeed * 0.8, 60); // Slow player more
                            }
                        }
                    });
                }

                // Check mech oil/fuel puddle collisions
                if (store.mechPuddles && store.mechPuddles.length > 0) {
                    store.mechPuddles.forEach(puddle => {
                        // Calculate current radius with shrinking effect
                        const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
                        const currentRadius = puddle.r * Math.max(0.3, lifePercent);

                        const dx = p.x - puddle.x;
                        const dy = p.y - puddle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < currentRadius + p.r) {
                            // Player is in hazardous puddle - apply damage and burning effect
                            if (!p.lastMechPuddleDamageTime || performance.now() - p.lastMechPuddleDamageTime > 400) {
                                // console.log('Player in mech puddle! Taking', puddle.damage, 'damage');
                                takeDamage(puddle.damage);
                                p.lastMechPuddleDamageTime = performance.now();

                                // Apply burning/slowing effect
                                p.isBurning = true;
                                p.burnEndTime = performance.now() + 2500; // 2.5 second burn effect

                                // Create burning particle effect
                                for (let i = 0; i < 3; i++) {
                                    store.flameParticles.push({
                                        x: p.x + (Math.random() - 0.5) * 30,
                                        y: p.y + (Math.random() - 0.5) * 30,
                                        vx: (Math.random() - 0.5) * 100,
                                        vy: -Math.random() * 150,
                                        life: 1 + Math.random() * 0.5,
                                        maxLife: 1 + Math.random() * 0.5,
                                        r: 3 + Math.random() * 4
                                    });
                                }
                            }
                        }
                    });
                }

                // Fragment Blaster auto-targeting system
                if (p.fragmentBlasters && p.fragmentBlasters.length > 0) {
                    stepFragmentBlasters(dt, p);
                }
            }
            function stepPowerups(dt) {
                const p = store.player;
                store.powerups.forEach(powerup => {
                    // Handle powerup movement (for Trap King falling powerups)
                    if (powerup.vx !== undefined || powerup.vy !== undefined) {
                        powerup.x += (powerup.vx || 0) * dt;
                        powerup.y += (powerup.vy || 0) * dt;

                        // Handle powerup lifetime
                        if (powerup.life !== undefined) {
                            powerup.life -= dt;
                            if (powerup.life <= 0) {
                                powerup.dead = true;
                                return;
                            }
                        }

                        // Remove powerups that go off screen
                        if (powerup.x < -20 || powerup.x > W + 20 || powerup.y < -20 || powerup.y > H + 20) {
                            powerup.dead = true;
                            return;
                        }
                    }

                    if (p.magnetRadius > 0) {
                        const dx = p.x - powerup.x;
                        const dy = p.y - powerup.y;
                        const distSq = dx * dx + dy * dy;
                        const dist = Math.sqrt(distSq);

                        // Auto-collect if very close to prevent vibration
                        if (dist < p.r + powerup.r + 5) {
                            powerup.dead = true;
                            if (powerup.type === 'upgrade' && powerup.upgradeTier) {
                                store.currentUpgradeTier = powerup.upgradeTier;
                            }
                            applyPowerup(powerup.type);
                            return;
                        }

                        if (distSq < p.magnetRadius * p.magnetRadius) {
                            const pullSpeed = 350;
                            powerup.x += (dx / dist) * pullSpeed * dt;
                            powerup.y += (dy / dist) * pullSpeed * dt;
                        }
                    }

                    if (collide(p, powerup)) {
                        powerup.dead = true;
                        if (powerup.type === 'upgrade' && powerup.upgradeTier) {
                            store.currentUpgradeTier = powerup.upgradeTier;
                        }
                        applyPowerup(powerup.type);
                    }
                });
            }

            function detonateClusterRocket(m) {
                if (m.dead) return;
                m.dead = true;

                if (m.isStealth && !m.fireworkMini && !m.fireworkBurstTriggered) {
                    spawnRocketmanFireworkBurst({ x: m.x, y: m.y }, m);
                    m.fireworkBurstTriggered = true;
                }

                // Play cluster sound if this missile is marked for sound
                if (m.playSound) {
                    playSound('cluster');
                }

                const baseRadius = 70; // Halved from 80
                const explosionRadius = store.player.enhancedClusters ? 120 : baseRadius;
                const chainRadius = 90;
                const microExplosionCount = 5;
                let aoeDmg = m.dmg * .8;
                if (store.player.subclass === 'demolitioner') {
                    aoeDmg *= 1.5;  // OPTIONAL: Boost damage for demolitioner
                }
                for (let i = 0; i < microExplosionCount; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const dist = Math.random() * explosionRadius * 0.7;
                    const ex = m.x + Math.cos(angle) * dist;
                    const ey = m.y + Math.sin(angle) * dist;
                    store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
                }
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                targets.forEach(e => {
                    if (!e.dead) {
                        const distSq = (e.x - m.x) ** 2 + (e.y - m.y) ** 2;
                        if (distSq < explosionRadius ** 2) {
                            let pulseDmg = aoeDmg;
                            const explosionTags = store.player.subclass === 'demolitioner' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                            const vulnExplosion = applySubclassVulnerability(e, pulseDmg, {
                                subclass: store.player.subclass,
                                player: store.player,
                                damageTags: explosionTags,
                                source: 'clusterDetonation',
                                projectile: m,
                                baseDamage: pulseDmg
                            });
                            pulseDmg = vulnExplosion.damage;
                            e.hp -= pulseDmg;
                            e.hp = Math.max(1, e.hp);

                            // Apply vampirism healing for cluster damage
                            if (store.player.vampirism > 0) {
                                let healAmount = aoeDmg * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for AoE
                                healAmount = Math.min(healAmount, 2); // Cap at 2 HP for AoE
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                        }
                    }
                });
                // Remove chain detonation to prevent rockets from exploding each other
            }

            function spawnRocketmanFireworkBurst(origin, baseMissile, impactedEnemy) {
                const player = store.player;
                if (!player || player.pilotGenome !== 'rocketman' || !player.stealthRockets) {
                    return;
                }

                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                const liveTargets = potentialTargets.filter(target => !target.dead && target.hp > 0);
                const burstCount = 8; // Increased to 8 for 360-degree coverage
                if (burstCount <= 0) return;

                const baseSpeed = (baseMissile ? baseMissile.speed : 250) * 1.1;
                const baseDamage = (baseMissile ? baseMissile.dmg : 90 * player.dmgMult) * 0.45;
                
                // Calculate reference angle for knockback (direction the missile was traveling)
                const referenceAngle = baseMissile ? Math.atan2(baseMissile.vy, baseMissile.vx) : 0;
                
                // 360-degree spread instead of focused cone
                const fullCircle = Math.PI * 2;

                for (let i = 0; i < burstCount; i++) {
                    // Evenly distribute mini-rockets in 360 degrees
                    const angle = (i / burstCount) * fullCircle;
                    const launchSpeed = baseSpeed * (0.9 + Math.random() * 0.3);
                    let target = null;

                    if (liveTargets.length > 0) {
                        target = liveTargets[(i + Math.floor(Math.random() * liveTargets.length)) % liveTargets.length];
                    }

                    const miniRocket = {
                        x: origin.x,
                        y: origin.y,
                        vx: Math.cos(angle) * launchSpeed,
                        vy: Math.sin(angle) * launchSpeed,
                        speed: launchSpeed,
                        turnRate: 6.5,
                        target,
                        life: 0,
                        dmg: baseDamage * (0.85 + Math.random() * 0.3),
                        cluster: false,
                        pierce: 0,
                        isIceman: false,
                        isStealth: true,
                        fireworkMini: true,
                        maxLife: 1.8,
                        startX: origin.x,
                        startY: origin.y,
                        travelDistance: 0
                    };

                    store.missiles.push(miniRocket);
                }

                if (impactedEnemy && !impactedEnemy.dead) {
                    registerEnemyHit(impactedEnemy, {
                        angle: referenceAngle,
                        knockbackStrength: 35,
                        knockbackDuration: 0.05
                    });
                }

                store.activeEffects.push(createEffect('hitSpark', origin.x, origin.y, 28, { strength: 45 }));
            }

            function stepMissiles(dt) {
                store.missiles.forEach(m => {
                    if (m.chainDetonate && !m.dead) {
                        detonateClusterRocket(m);
                        return;
                    }
                    m.life += dt;
                    const maxLife = m.maxLife !== undefined ? m.maxLife : 6;
                    if (m.life > maxLife) { m.dead = true; return; }
                    
                    // Check if target is still valid and in playfield
                    const playfieldMargin = 50;
                    const targetOffScreen = m.target && (m.target.x < -playfieldMargin || m.target.x > W + playfieldMargin || 
                                                         m.target.y < -playfieldMargin || m.target.y > H + playfieldMargin);
                    if (targetOffScreen) {
                        m.target = null; // Lose target if it goes off screen
                    }
                    
                    if (m.target && !m.target.dead && m.target.hp > 0) {
                        const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 1) {
                            const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                            m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                        }
                    }
                    const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
                    if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }

                    // Track movement distance before updating position
                    const prevX = m.x, prevY = m.y;
                    m.x += m.vx * dt; m.y += m.vy * dt;

                    // Update travel distance if we have start position
                    if (m.startX !== undefined && m.startY !== undefined) {
                        m.travelDistance = Math.sqrt((m.x - m.startX) ** 2 + (m.y - m.startY) ** 2);
                    }

                    if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
                    const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;

                    // For cluster rockets, check proximity detonation only when they should explode
                    if (m.cluster && !m.pierce) {
                        // Original cluster behavior - explode near enemies
                        const proxRadiusSq = 15 * 15;
                        for (const e of targets) {
                            if (!e.dead && ((m.x - e.x) ** 2 + (m.y - e.y) ** 2 < proxRadiusSq)) {
                                detonateClusterRocket(m);
                                return;
                            }
                        }
                    }

                    // Handle collision with enemies
                    for (const e of targets) {
                        if (!e.dead && collide(m, e)) {
                            m.hits = (m.hits || 0) + 1;

                            if (m.cluster && m.pierce > 0) {
                                // Hybrid cluster + piercing: Deal damage, pierce, then set up for delayed explosion
                                let dmg = m.dmg;
                                if (e === store.boss) dmg *= 0.1;
                                if (Math.random() < store.player.critChance) {
                                    dmg *= store.player.critDamage;
                                    store.activeEffects.push(createEffect('critText', e.x, e.y));
                                    if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                                }
                                const missileTags = store.player.subclass === 'demolitioner' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                                const vulResPierce = applySubclassVulnerability(e, dmg, {
                                    subclass: store.player.subclass,
                                    player: store.player,
                                    damageTags: missileTags,
                                    source: 'pierceMissile',
                                    projectile: m,
                                    baseDamage: dmg
                                });
                                dmg = vulResPierce.damage;
                                e.hp -= dmg;

                                // Apply vampirism healing for missile damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = dmg * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 6); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }

                                explode(m.x, m.y, false, true);
                                m.pierce--;

                                if (m.pierce <= 0) {
                                    // No more pierces left - mark for delayed explosion
                                    m.shouldExplodeAfterTravel = true;
                                    m.minTravelTimeForExplosion = 0.5; // 0.5 seconds minimum travel time
                                    m.travelTimeAfterLastHit = 0;
                                } else {
                                    // Find next target for piercing
                                    let farthestTarget = null, maxDistSq = -1;
                                    targets.forEach(p_target => {
                                        if (p_target.dead || p_target === e) return;
                                        const distSq = (p_target.x - e.x) ** 2 + (p_target.y - e.y) ** 2;
                                        if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                                    });
                                    if (farthestTarget) {
                                        m.target = farthestTarget;
                                        const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                                    } else {
                                        // No more targets - explode immediately
                                        detonateClusterRocket(m);
                                    }
                                }
                            } else if (m.cluster) {
                                // Pure cluster rocket - explode immediately
                                detonateClusterRocket(m);
                            } else {
                                // Regular missile logic (non-cluster)
                                let dmg = m.dmg;
                                if (e === store.boss) dmg *= 0.1;
                                if (Math.random() < store.player.critChance) {
                                    dmg *= store.player.critDamage;
                                    store.activeEffects.push(createEffect('critText', e.x, e.y));
                                    if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                                }
                                const missileDamageTags = store.player.subclass === 'demolitioner' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                                const vulRes = applySubclassVulnerability(e, dmg, {
                                    subclass: store.player.subclass,
                                    player: store.player,
                                    damageTags: missileDamageTags,
                                    source: m.cluster ? 'clusterMissile' : 'missileImpact',
                                    projectile: m,
                                    baseDamage: dmg
                                });
                                dmg = vulRes.damage;
                                e.hp -= dmg;

                                // Apply vampirism healing for missile damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = dmg * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }

                                explode(m.x, m.y, false, true);
                                if (m.isStealth && !m.fireworkMini && !m.fireworkBurstTriggered) {
                                    // Only trigger burst if no other rocket in this volley has triggered recently
                                    const now = performance.now();
                                    if (!store.lastFireworkBurstTime || (now - store.lastFireworkBurstTime) > 500) {
                                        spawnRocketmanFireworkBurst({ x: m.x, y: m.y }, m, e);
                                        m.fireworkBurstTriggered = true;
                                        store.lastFireworkBurstTime = now;
                                    }
                                }
                                if ((store.player.subclass === 'railgunner' || store.player.missilePierce > 0) && m.pierce > 0) {
                                    m.pierce--;
                                    let farthestTarget = null, maxDistSq = -1;
                                    targets.forEach(p_target => {
                                        if (p_target.dead || p_target === e) return;
                                        const distSq = (p_target.x - e.x) ** 2 + (p_target.y - e.y) ** 2;
                                        if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                                    });
                                    if (farthestTarget) {
                                        m.target = farthestTarget;
                                        const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                                    } else { m.dead = true; }
                                } else if (m.pierce > 0) {
                                    m.pierce--;
                                } else {
                                    m.dead = true;
                                }
                            }
                            if (m.dead) break;
                        }
                    }

                    // Handle delayed explosion for cluster + pierce missiles
                    if (m.shouldExplodeAfterTravel) {
                        m.travelTimeAfterLastHit += dt;
                        if (m.travelTimeAfterLastHit >= m.minTravelTimeForExplosion) {
                            // Check if we're near any enemies to explode
                            const explosionProximity = 60;
                            let shouldExplode = false;
                            for (const e of targets) {
                                if (!e.dead) {
                                    const distSq = (m.x - e.x) ** 2 + (m.y - e.y) ** 2;
                                    if (distSq < explosionProximity * explosionProximity) {
                                        shouldExplode = true;
                                        break;
                                    }
                                }
                            }
                            if (shouldExplode) {
                                detonateClusterRocket(m);
                            }
                        }
                    }
                });
            }

            function stepLightning(dt) {
                store.lightningBolts.forEach(bolt => {
                    bolt.life -= dt;
                    if (bolt.life <= 0) { bolt.dead = true; }
                });
            }

            function stepFlamePulses(dt) {
                store.flamePulses.forEach(pulse => {
                    // Expand the pulse
                    pulse.radius += pulse.speed * dt;
                    if (pulse.radius > pulse.maxRadius) {
                        pulse.radius = pulse.maxRadius;
                    }

                    // Countdown life
                    pulse.life -= dt;
                    if (pulse.life <= 0) {
                        pulse.dead = true;
                        return;
                    }

                    // Damage and knockback enemies in the expanding ring
                    const ringThickness = 30; // Width of the damage ring
                    store.enemies.forEach(enemy => {
                        if (enemy.dead) return;
                        
                        const dx = enemy.x - pulse.x;
                        const dy = enemy.y - pulse.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check if enemy is within the ring thickness
                        if (dist >= pulse.radius - ringThickness && dist <= pulse.radius + ringThickness) {
                            // Damage enemy
                            enemy.hp -= pulse.damage;
                            if (enemy.hp <= 0) {
                                enemy.dead = true;
                            }
                            
                            // Knockback effect
                            const knockbackAngle = Math.atan2(dy, dx);
                            enemy.x += Math.cos(knockbackAngle) * pulse.knockback * dt;
                            enemy.y += Math.sin(knockbackAngle) * pulse.knockback * dt;
                        }
                    });

                    // Also affect boss
                    if (store.boss && !store.boss.dead) {
                        const dx = store.boss.x - pulse.x;
                        const dy = store.boss.y - pulse.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist >= pulse.radius - ringThickness && dist <= pulse.radius + ringThickness) {
                            store.boss.hp -= pulse.damage * 0.5; // Reduced damage to boss
                            
                            // Knockback (bosses resist more)
                            const knockbackAngle = Math.atan2(dy, dx);
                            store.boss.x += Math.cos(knockbackAngle) * pulse.knockback * 0.3 * dt;
                            store.boss.y += Math.sin(knockbackAngle) * pulse.knockback * 0.3 * dt;
                        }
                    }

                    // Spawn fire particles along the ring edge for visual effect
                    if (Math.random() < 0.3) {
                        const angle = Math.random() * Math.PI * 2;
                        const px = pulse.x + Math.cos(angle) * pulse.radius;
                        const py = pulse.y + Math.sin(angle) * pulse.radius;
                        
                        const particle = new FlameParticle(px, py, null, 0);
                        particle.vx = Math.cos(angle) * 30;
                        particle.vy = Math.sin(angle) * 30;
                        particle.life *= 0.3;
                        particle.maxLife *= 0.3;
                        particle.visualLife *= 0.3;
                        particle.maxVisualLife *= 0.3;
                        particle.isFlamethrowerParticle = false; // Use standard physics
                        store.flameParticles.push(particle);
                    }
                });
            }

            function stepEmpNovas(dt) {
                store.empNovas.forEach(nova => {
                    // Expand the nova
                    nova.radius += nova.speed * dt;
                    if (nova.radius > nova.maxRadius) {
                        nova.radius = nova.maxRadius;
                    }

                    // Countdown life
                    nova.life -= dt;
                    if (nova.life <= 0) {
                        nova.dead = true;
                        return;
                    }

                    // Check if player is within EMP range
                    const dx = store.player.x - nova.x;
                    const dy = store.player.y - nova.y;
                    const distSq = dx * dx + dy * dy;
                    const radiusSq = nova.radius * nova.radius;

                    if (distSq <= radiusSq) {
                        // Player is within EMP range - disable weapons
                        store.player.empDisabled = true;
                        store.player.empDisabledTimer = 0.5; // Sizzle effect duration
                    }
                });

                // Update player EMP disabled state
                if (store.player.empDisabledTimer > 0) {
                    store.player.empDisabledTimer -= dt;
                    if (store.player.empDisabledTimer <= 0) {
                        store.player.empDisabled = false;
                    }
                }
            }

            function stepLasers(dt) {
                store.lasers.forEach(laser => {
                    laser.life -= dt;
                    if (laser.life <= 0) { laser.dead = true; return; }
                    laser.prevX = laser.x; laser.prevY = laser.y;
                    laser.x += laser.vx * dt; laser.y += laser.vy * dt;
                    if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                        const speed = Math.sqrt(laser.vx ** 2 + laser.vy ** 2);
                        let newAngle;
                        if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                        else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                        else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                        else { newAngle = Math.PI + Math.random() * Math.PI; }
                        laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                        laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                        laser.hitEnemies.clear();
                    }
                    store.enemies.forEach(e => {
                        if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) {
                            const laserDmg = 1000 * store.player.dmgMult;
                            e.hp -= laserDmg;
                            laser.hitEnemies.add(e);

                            registerEnemyHit(e, {
                                angle: Math.atan2(e.y - laser.y, e.x - laser.x),
                                knockbackStrength: 90,
                                knockbackDuration: 0.08
                            });

                            // Track damage dealt for beef shield system
                            if (store.player.pilotGenome === 'beef') {
                                store.player.beefShieldDamageDealt += laserDmg;
                            }

                            // Apply vampirism healing for laser damage
                            if (store.player.vampirism > 0) {
                                let healAmount = laserDmg * store.player.vampirism;
                                healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                                healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                        }
                    });
                    if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) {
                        const bossLaserDmg = 500 * store.player.dmgMult;
                        const result = applyBossDamage(store.boss, bossLaserDmg, { point: { x: laser.x, y: laser.y } });
                        laser.hitEnemies.add(store.boss);

                        if (result.amount > 0 && !result.blocked && store.boss) {
                            registerEnemyHit(store.boss, {
                                angle: Math.atan2(store.boss.y - laser.y, store.boss.x - laser.x),
                                knockbackStrength: 70,
                                knockbackDuration: 0.08
                            });
                        }

                        if (store.player.pilotGenome === 'beef') {
                            store.player.beefShieldDamageDealt += result.amount;
                        }

                        if (store.player.vampirism > 0 && result.amount > 0) {
                            let healAmount = result.amount * store.player.vampirism;
                            healAmount = Math.max(healAmount, 2);
                            healAmount = Math.min(healAmount, 10);
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                    }
                });
            }

            function stepMines(dt) {
                store.mines.forEach(mine => {
                    if (mine.dead) return;
                    mine.fuse -= dt;
                    let detonate = mine.fuse <= 0;
                    if (!detonate) {
                        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                        for (const target of targets) { if (!target.dead && collide(mine, target)) { detonate = true; break; } }
                    }
                    if (detonate) { mine.dead = true; explodeMine(mine); }
                });
            }

            function stepFlameParticles(dt) {
                const activeCache = store._activeFlamesCache || (store._activeFlamesCache = []);
                activeCache.length = 0;

                for (let i = store.flameParticles.length - 1; i >= 0; i--) {
                    const p = store.flameParticles[i];
                    let alive = true;
                    if (p.attachedEnemy) {
                        if (p.attachedEnemy.dead) {
                            p.attachedEnemy = null;
                        } else {
                            p.x = p.attachedEnemy.x;
                            p.y = p.attachedEnemy.y;
                            let appliedDamage = p.damage;
                            if (p.attachedEnemy === store.boss) {
                                const result = applyBossDamage(p.attachedEnemy, p.damage, {
                                    point: { x: p.attachedEnemy.x, y: p.attachedEnemy.y },
                                    skipShield: true
                                });
                                appliedDamage = result.amount;
                            } else {
                                p.attachedEnemy.hp -= appliedDamage;
                            }

                            // Apply vampirism healing for attached flame damage
                            if (appliedDamage > 0 && store.player.vampirism > 0) {
                                let healAmount = appliedDamage * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.2); // Minimum 0.2 HP
                                healAmount = Math.min(healAmount, 1); // Cap at 1 HP
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }

                            if (appliedDamage > 0) {
                                p.attachedEnemy.slowTimer = 2.0;
                            }
                        }
                    }
                    if (p.update && !p.update(dt)) {
                        store.flameParticles.splice(i, 1);
                        alive = false;
                    } else if (!p.update) {
                        // Handle legacy flame particles without update function
                        if (p.vx !== undefined) {
                            p.x += p.vx * dt;
                            p.y += p.vy * dt;
                        }
                        p.life -= dt;
                        if (p.life <= 0) {
                            store.flameParticles.splice(i, 1);
                            alive = false;
                        }
                    }

                    if (alive) {
                        activeCache.push(p);
                    }
                }
            }




            const EMPTY_FLAME_CACHE = Object.freeze([]);

            function getHivePuddleLifetime(base, variance, options = {}) {
                const { min = 4, waveBonusPer = 0.35, maxWaveBonus = 5 } = options;
                const wave = (store && store.world && typeof store.world.wave === 'number') ? store.world.wave : 1;
                const waveBonus = Math.min(Math.max(wave - 1, 0) * waveBonusPer, maxWaveBonus);
                const randomized = variance > 0 ? Math.random() * variance : 0;
                return Math.max(min, base + randomized + waveBonus);
            }

            const GOLDEN_ORB_CONFIG = Object.freeze({
                radius: 22,
                pickupRadius: 30,
                floatAmplitude: 12,
                floatSpeed: 2.4,
                homingSpeed: 430,
                homingAcceleration: 6.5,
                maxTrail: 16,
                trailLife: 0.32
            });

            function spawnGoldenSentinelOrbs(count = 3) {
                if (!store || !store.player) return;
                if (!store.goldenOrbs) store.goldenOrbs = [];

                const spawnPositions = [
                    {
                        x: clamp(W * 0.23, 80, W - 80),
                        y: clamp(H - 170, 120, H - 110)
                    },
                    {
                        x: clamp(W * 0.5, 80, W - 80),
                        y: clamp(H - 135, 120, H - 105)
                    },
                    {
                        x: clamp(W * 0.77, 80, W - 80),
                        y: clamp(H - 190, 120, H - 115)
                    }
                ];

                for (let i = 0; i < Math.min(count, spawnPositions.length); i++) {
                    const pos = spawnPositions[i];
                    const orb = {
                        x: pos.x,
                        y: pos.y,
                        baseY: pos.y,
                        r: GOLDEN_ORB_CONFIG.radius,
                        pickupRadius: GOLDEN_ORB_CONFIG.pickupRadius,
                        state: 'idle',
                        floatPhase: Math.random() * Math.PI * 2,
                        floatSpeed: GOLDEN_ORB_CONFIG.floatSpeed * (0.85 + Math.random() * 0.3),
                        floatAmplitude: GOLDEN_ORB_CONFIG.floatAmplitude * (0.85 + Math.random() * 0.25),
                        pulseOffset: Math.random() * Math.PI * 2,
                        created: performance.now(),
                        trail: [],
                        speed: GOLDEN_ORB_CONFIG.homingSpeed
                    };
                    store.goldenOrbs.push(orb);
                    store.activeEffects.push(createEffect('goldenOrbSpawn', orb.x, orb.y, orb.r * 2.2));
                }
            }

            function stepGoldenOrbs(dt) {
                const orbs = store.goldenOrbs;
                if (!orbs || orbs.length === 0) {
                    return;
                }

                if (!store.boss) {
                    orbs.length = 0;
                    return;
                }

                const player = store.player;
                for (let i = orbs.length - 1; i >= 0; i--) {
                    const orb = orbs[i];
                    orb.floatPhase += orb.floatSpeed * dt;

                    if (orb.state === 'idle') {
                        orb.y = orb.baseY + Math.sin(orb.floatPhase) * orb.floatAmplitude;
                        const dx = player.x - orb.x;
                        const dy = player.y - orb.y;
                        if ((dx * dx + dy * dy) <= orb.pickupRadius * orb.pickupRadius) {
                            orb.state = 'homing';
                            orb.vx = 0;
                            orb.vy = 0;
                            orb.trail.length = 0;
                            orb.heading = -Math.PI / 2;
                            playSound('stargun');
                        }
                    } else if (orb.state === 'homing') {
                        const boss = store.boss;
                        if (!boss) {
                            orbs.splice(i, 1);
                            continue;
                        }

                        const dx = boss.x - orb.x;
                        const dy = boss.y - orb.y;
                        const dist = Math.max(0.001, Math.hypot(dx, dy));
                        const desiredVx = (dx / dist) * orb.speed;
                        const desiredVy = (dy / dist) * orb.speed;
                        const accel = GOLDEN_ORB_CONFIG.homingAcceleration;
                        orb.vx = (orb.vx || 0) + (desiredVx - (orb.vx || 0)) * Math.min(1, accel * dt);
                        orb.vy = (orb.vy || 0) + (desiredVy - (orb.vy || 0)) * Math.min(1, accel * dt);
                        orb.x += orb.vx * dt;
                        orb.y += orb.vy * dt;
                        orb.heading = Math.atan2(orb.vy, orb.vx);

                        if (!orb.trail) orb.trail = [];
                        orb.trail.unshift({ x: orb.x, y: orb.y, life: GOLDEN_ORB_CONFIG.trailLife });
                        if (orb.trail.length > GOLDEN_ORB_CONFIG.maxTrail) {
                            orb.trail.pop();
                        }
                        for (let t = orb.trail.length - 1; t >= 0; t--) {
                            orb.trail[t].life -= dt;
                            if (orb.trail[t].life <= 0) {
                                orb.trail.splice(t, 1);
                            }
                        }

                        if (dist <= (boss.r || 70) + 12) {
                            const damage = boss.hpMax * 0.2;
                            const result = applyBossDamage(boss, damage, { point: { x: orb.x, y: orb.y } });
                            store.activeEffects.push(createEffect('goldenOrbDetonation', orb.x, orb.y, 140));
                            playSound('explosion');
                            orbs.splice(i, 1);
                            if (boss.hp <= 0) {
                                return;
                            }
                        }
                    }
                }
            }

            function stepWorld(dt) {
                stepPlayer(dt);
                if (store.boss) {
                    stepBoss(dt);
                }

                stepPowerups(dt);
                stepPlayerChampion(dt);
                stepChampionMinions(dt);
                stepEmpCharges(dt);
                stepHounds(dt);
                stepShadowHounds(dt);
                stepVoidRifts(dt);
                updateGibs(dt);

                stepMissiles(dt);
                stepJuggernautBombs(dt);
                stepLasers(dt);
                stepMines(dt);
                stepFlameParticles(dt);
                updateShadowEchoes(dt);
                updateTemporalEchoes(dt);
                updateTimeShards(dt);
                stepLightning(dt);
                stepEmpNovas(dt);
                stepFlamePulses(dt);
                processWaveSpawnQueue(dt);
                processVulnerabilityEvents(dt);

                if (store.world.pendingVoidReaper) {
                    store.world.pendingVoidReaper.timer -= dt;
                    const plan = store.world.pendingVoidReaper;
                    if (!store.world.voidReaperWarningIssued && plan.timer <= 2.4) {
                        store.world.voidReaperWarningIssued = true;
                        announce('ðŸ“¡ [Encrypted Relay] "A pair of anomalies traveling at an infeasible rate was detected..."');
                        playSound('thunder');
                    }
                    if (plan.timer <= 0) {
                        const spawned = spawnVoidReaper({
                            hpScale: plan.hpScale,
                            damageMult: plan.damageMult,
                            lateGameScaling: plan.lateGameScaling
                        });
                        if (spawned) {
                            store.world.pendingVoidReaper = null;
                            store.world.voidReaperWarningIssued = false;
                        } else {
                            // Retry slightly later if spawn failed
                            plan.timer = 1.5;
                        }
                    }
                }

                // Update beef shield system
                updateBeefShield();

                // Update mech oil/fuel puddles
                for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
                    const puddle = store.mechPuddles[i];
                    puddle.life -= dt;
                    if (puddle.life <= 0) {
                        store.mechPuddles.splice(i, 1);
                    }
                }

                updateVoidStepSystems(store.enemies);
                updateImpactSystem();
                runAutoForge(dt);
                stepGoldenOrbs(dt);

                store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
                if (store.world.powerupCooldown > 0) {
                    store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2));
                }

                let base = store.world.wave < 200 ? 1.065 : 1.04;
                // BETTER BALANCE: Even more gentle scaling
                let dmgScale;
                if (store.world.wave <= 10) {
                    // Very gentle exponential growth for early game
                    dmgScale = Math.pow(1.03, store.world.wave - 1); // Reduced from 1.05 to 1.03
                } else {
                    // Minimal linear scaling after wave 10
                    const wave10Scale = Math.pow(1.03, 9); // ~1.3x at wave 10
                    const veryGentleGrowth = (store.world.wave - 10) * 0.02; // Only +2% per wave after 10
                    dmgScale = wave10Scale * (1 + veryGentleGrowth);
                }
                // Apply collar bonus and late-game scaling to enemy damage
                const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
                const lateGameBonus = store.world.lateGameDamageScaling || 1;
                dmgScale *= collarBonus * lateGameBonus;
                // console.log(`Wave ${store.world.wave}: Damage scale = ${dmgScale.toFixed(2)} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x | LateGameBonus: ${lateGameBonus.toFixed(2)}x`);
                const player = store.player;
                let autoBlinkTriggeredThisFrame = false;

                store.eBullets.forEach(b => {
                    if (b.path === 'aegis_spiral') {
                        const amplitude = ensureFiniteNumber(b.amplitude, 120);
                        const frequency = ensureFiniteNumber(b.frequency, 2.9);
                        const fallSpeed = ensureFiniteNumber(b.fallSpeed, 165);
                        const baseX = b.baseX !== undefined ? b.baseX : (b.baseX = b.x);
                        const phaseOffset = ensureFiniteNumber(b.phaseOffset, 0);
                        b.t = (b.t || 0) + dt;
                        const sway = Math.sin(b.t * frequency + phaseOffset) * amplitude;
                        b.x = baseX + sway;
                        b.y += fallSpeed * dt;
                        if (b.life !== undefined) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                        if (b.baseRadius === undefined) {
                            b.baseRadius = b.r || 5.5;
                        }
                        if (!b.dead && b.pulseOffset !== undefined) {
                            const pulseScale = 1 + Math.sin(performance.now() / 220 + b.pulseOffset) * 0.12;
                            b.r = b.baseRadius * pulseScale;
                        }
                    } else if (b.path === 'aegis_gravity') {
                        const target = store.player;
                        const homingStrength = ensureFiniteNumber(b.homingStrength, 110);
                        const maxSpeed = ensureFiniteNumber(b.maxSpeed, 260);
                        const vx = ensureFiniteNumber(b.vx, 0);
                        const vy = ensureFiniteNumber(b.vy, 0);
                        const angleToPlayer = Math.atan2((target.y ?? b.y) - b.y, (target.x ?? b.x) - b.x);
                        const accelX = Math.cos(angleToPlayer) * homingStrength * dt;
                        const accelY = Math.sin(angleToPlayer) * homingStrength * dt;
                        let nextVx = vx + accelX;
                        let nextVy = vy + accelY;
                        const speed = Math.hypot(nextVx, nextVy) || 0;
                        if (speed > maxSpeed) {
                            const scale = maxSpeed / speed;
                            nextVx *= scale;
                            nextVy *= scale;
                        }
                        b.vx = nextVx;
                        b.vy = nextVy;
                        b.x += nextVx * dt;
                        b.y += nextVy * dt;
                        if (b.life) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                        if (b.pulseOffset !== undefined) {
                            b.rBase = b.rBase || b.r || 8;
                            const pulseScale = 1 + Math.sin(performance.now() / 200 + b.pulseOffset) * 0.1;
                            b.r = b.rBase * pulseScale;
                        }
                    } else {
                        b.x += b.vx * dt;
                        b.y += b.vy * dt;
                        if (b.gravity) { b.vy += b.gravity * dt; }
                        if (b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
                    }

                    // Check if poison blob hits ground
                    if (b.type === 'poisonBlob' && b.y > H - 30) {
                        // Create poison puddle on ground impact
                        if (!store.poisonPuddles) store.poisonPuddles = [];
                        store.poisonPuddles.push({
                            x: b.x,
                            y: H - 20,
                            r: 20 + Math.random() * 10,
                            life: getHivePuddleLifetime(5.5, 4.5, { min: 4.5, maxWaveBonus: 5.5 }),
                            damage: (b.dmg || 15) * 0.5,
                            created: performance.now()
                        });
                        b.dead = true;
                    }

                    // Check if mech volley hits ground or reaches target area - create puddle
                    if (b.isMechVolley && (b.y >= b.targetY - 10 || b.y > H - 30)) {
                        // Use intended target location for puddle placement
                        const puddleX = b.targetX;
                        const puddleY = b.targetY;

                        // console.log('Mech volley landed! Creating puddle at target:', puddleX, puddleY);
                        store.mechPuddles.push({
                            x: puddleX,
                            y: puddleY,
                            r: 10, // Much smaller puddles (half of 20)
                            maxR: 10, // Store original size for shrinking effect
                            life: 1.5, // Reduced to 1.5 seconds
                            maxLife: 1.5, // Store original life for shrinking calculation
                            damage: (b.dmg || 18) * 0.4, // 40% of original damage per tick
                            sourceId: b.sourceId, // Track which mech created this puddle
                            created: performance.now(),
                            pulseOffset: Math.random() * Math.PI * 2, // For animation
                            hp: 15, // Make puddles killable with small HP
                            hpMax: 15 // Store max HP
                        });
                        b.dead = true;
                    }

                    if (!autoBlinkTriggeredThisFrame && !b.dead) {
                        if (attemptAutoBlink(player, b)) {
                            autoBlinkTriggeredThisFrame = true;
                        }
                    }

                    if (b.path === 'aegis_spiral') {
                        if (b.y > H + 70) {
                            b.dead = true;
                        }
                    } else if (b.path === 'aegis_gravity') {
                        if (b.x < -40 || b.x > W + 40 || b.y < -40 || b.y > H + 40) {
                            b.dead = true;
                        }
                    } else if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) {
                        b.dead = true;
                    }

                    if (collide(b, store.player)) {
                        const p = store.player;
                        if (p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                            p.rearGuardReady = false;
                            p.rearGuardCooldown = 8;
                            b.dead = true;
                            store.activeEffects.push(createEffect("rearGuardBlock"));
                        } else {
                            // Check if this is a poison blob for special effects
                            if (b.type === 'poisonBlob') {
                                // Apply poison debuff to player
                                p.isPoisoned = true;
                                p.poisonEndTime = performance.now() + 5000; // 5 second poison
                                p.moveSpeed = Math.max(p.moveSpeed * 0.7, 50); // Slow player

                                // Create poison puddle at impact location
                                if (!store.poisonPuddles) store.poisonPuddles = [];
                                store.poisonPuddles.push({
                                    x: b.x,
                                    y: b.y,
                                    r: 25,
                                    life: getHivePuddleLifetime(5, 3, { min: 4.5, maxWaveBonus: 4 }),
                                    damage: (b.dmg || 15) * 0.3,
                                    created: performance.now()
                                });
                            }

                            // Calculate fade-in damage multiplier for Death Engine bullet rain
                            let damageMultiplier = 1.0;
                            if (b.fadeInTime && b.spawnTime) {
                                const timeAlive = (performance.now() - b.spawnTime) / 1000;
                                damageMultiplier = Math.min(1.0, timeAlive / b.fadeInTime);
                            }

                            takeDamage((b.dmg || 10) * damageMultiplier);
                            b.dead = true;
                        }
                    }
                });

                applyTemporalBeamEffects(dt, dmgScale);

                if (store.boss && store.boss.mines) {
                    store.boss.mines.forEach(mine => {
                        mine.fuse -= dt;
                        if (mine.fuse <= 0) {
                            store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                            mine.dead = true;
                        }
                        if (collide(mine, store.player)) {
                            takeDamage(50 * dmgScale);
                            mine.dead = true;
                        }
                    });
                    store.boss.mines = store.boss.mines.filter(m => !m.dead);
                }


                const activeFlames = store._activeFlamesCache && store._activeFlamesCache.length ? store._activeFlamesCache : EMPTY_FLAME_CACHE;
                const flameCount = activeFlames.length;

                // CONSOLIDATED enemy processing - flame collision + movement in single loop for performance
                store.enemies.forEach(e => {
                    if (e.dead) return;

                    if (e.isVoidReaper) {
                        updateVoidReaper(e, dt);
                        return;
                    }

                    if (e.hitPulseTimer && e.hitPulseTimer > 0) {
                        e.hitPulseTimer = Math.max(0, e.hitPulseTimer - dt);
                    }

                    if (e.hitShakeTimer && e.hitShakeTimer > 0) {
                        e.hitShakeTimer = Math.max(0, e.hitShakeTimer - dt);
                        if (e.hitShakeTimer <= 0) {
                            e.hitShakeIntensity = 0;
                        }
                    }

                    if (e.topClampDelay !== undefined && e.topClampDelay > 0) {
                        e.topClampDelay = Math.max(0, e.topClampDelay - dt);
                    }

                    if (e.spawnPhase === 'teleport') {
                        const duration = Math.max(0.001, e.spawnDuration || 0.6);
                        e.spawnTimer = (e.spawnTimer ?? duration) - dt;
                        const timeRemaining = Math.max(0, e.spawnTimer);
                        const progress = Math.min(1, 1 - timeRemaining / duration);
                        const eased = 1 - Math.pow(1 - progress, 3);
                        const startY = e.spawnStartY ?? (e.spawnTargetY ?? e.y);
                        const targetY = e.spawnTargetY ?? e.y;
                        e.y = startY + (targetY - startY) * eased;
                        e.spawnOpacity = Math.min(1, Math.max(e.spawnOpacity ?? 0, eased * 1.1));
                        e.vulnLastKnownPos = { x: e.x, y: e.y };
                        if (e.spawnTimer <= 0) {
                            e.spawnPhase = null;
                            e.spawnOpacity = 1;
                            e.y = targetY;
                        } else {
                            return;
                        }
                    } else {
                        e.vulnLastKnownPos = { x: e.x, y: e.y };
                        if (e.spawnOpacity !== undefined && e.spawnOpacity < 1) {
                            e.spawnOpacity = Math.min(1, e.spawnOpacity + dt * 2.2);
                        }
                    }

                    if (e.jugPulseTimer) e.jugPulseTimer = Math.max(0, e.jugPulseTimer - dt);
                    if (e.jugFearTimer) e.jugFearTimer = Math.max(0, e.jugFearTimer - dt);
                    if (e.jugBurnTimer) {
                        e.jugBurnTimer = Math.max(0, e.jugBurnTimer - dt);
                        e.jugBurnTick = (e.jugBurnTick || 0) - dt;
                        if (e.jugBurnTimer > 0 && e.jugBurnTick <= 0) {
                            const burnDamage = 10 * (store.player?.dmgMult || 1);
                            const lethalFloor = (e === store.boss) ? 0 : 1;
                            const appliedBurn = Math.min(burnDamage, Math.max(0, e.hp - lethalFloor));
                            e.hp -= appliedBurn;
                            e.jugBurnTick = 0.45;
                            store.activeEffects.push(createEffect('jugFearEmber', e.x, e.y, e.r || 20));
                        }
                    }
                    tickChampionBurn(e, dt);
                    tickChampionVoidMarks(e, dt);
                    tickChampionStormGrid(e, dt);
                    if (e.railgunArmorTimer) e.railgunArmorTimer = Math.max(0, e.railgunArmorTimer - dt);
                    if (e.phaseLockTimer) e.phaseLockTimer = Math.max(0, e.phaseLockTimer - dt);
                    if (e.stormShockTimer) e.stormShockTimer = Math.max(0, e.stormShockTimer - dt);
                    if (e.demolitionPulseWarmup) e.demolitionPulseWarmup = Math.max(0, e.demolitionPulseWarmup - dt);
                    if (e.maraLaunchTimer) e.maraLaunchTimer = Math.max(0, e.maraLaunchTimer - dt);
                    if (e.vulnerabilityPulseStrength) {
                        e.vulnerabilityPulseStrength = Math.max(0, e.vulnerabilityPulseStrength - dt * 0.7);
                    }

                    // OPTIMIZED FLAME PARTICLE COLLISION - batch processing with early exit
                    if (flameCount > 0) {
                        for (let f = 0; f < flameCount; f++) {
                            const flame = activeFlames[f];

                            const dx = flame.x - e.x;
                            const dy = flame.y - e.y;

                            // Early distance culling - skip expensive collision if too far (increased threshold)
                            if (Math.abs(dx) > 120 || Math.abs(dy) > 120) continue;

                            const distSq = dx * dx + dy * dy; // Skip sqrt - use squared distance
                            const collisionRadius = Math.max(5, flame.size + e.r - 50);
                            const collisionRadiusSq = collisionRadius * collisionRadius;

                            if (distSq < collisionRadiusSq) {
                                e.stunTimer = Math.max(e.stunTimer || 0, 0.5);
                                e.hp -= flame.damage;

                                // Apply vampirism healing for flamethrower damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = flame.damage * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                                    healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }

                                e.isBurning = true;
                                setTimeout(() => { if (e) e.isBurning = false; }, 100);
                                break; // Exit early on first collision for performance
                            }
                        }
                    }

                    // MOVEMENT AND AI UPDATES
                    if (e.knockback) {
                        // Handle different knockback formats
                        if (e.knockback.vx !== undefined && e.knockback.vy !== undefined) {
                            // Beef charge knockback format
                            e.x += e.knockback.vx * dt;
                            e.y += e.knockback.vy * dt;
                            e.knockback.duration -= dt;
                            if (e.knockback.duration <= 0) e.knockback = null;
                        } else if (e.knockback.x !== undefined && e.knockback.y !== undefined) {
                            // Blink ability knockback format
                            e.x += e.knockback.x * dt;
                            e.y += e.knockback.y * dt;
                            e.knockback.duration -= dt;
                            if (e.knockback.duration <= 0) e.knockback = null;
                        }

                        // Clamp enemies to screen boundaries so they don't get pushed off-screen
                        const margin = e.r || 15; // Use enemy radius for margin, default to 15
                        e.x = Math.max(margin, Math.min(W - margin, e.x));
                        e.y = Math.max(margin, Math.min(H - margin, e.y));
                        if (e.knockback && e.knockback.type === 'maraLaunch' && !e.maraImpactTriggered) {
                            if (e.x <= margin + 1 || e.x >= W - margin - 1 || e.y <= margin + 1 || e.y >= H - margin - 1) {
                                e.maraImpactTriggered = true;
                                store.activeEffects.push(createEffect('maraImpactShockwave', e.x, e.y, (e.r || 20) * 1.8));
                            }
                        }
                    } else if (e.stunTimer && e.stunTimer > 0) {
                        e.stunTimer -= dt;
                    } else {
                        let speedMultiplier = (e.slowTimer > 0) ? 0.3 : 1.0;
                        if (e.hitSlowTimer && e.hitSlowTimer > 0) {
                            const slowFactor = e.hitSlowFactor !== undefined ? e.hitSlowFactor : 0.85;
                            speedMultiplier *= Math.max(0.3, Math.min(1, slowFactor));
                            e.hitSlowTimer = Math.max(0, e.hitSlowTimer - dt);
                            if (e.hitSlowTimer <= 0) {
                                e.hitSlowFactor = 1;
                            }
                        } else if (e.hitSlowFactor && e.hitSlowFactor !== 1 && (!e.hitSlowTimer || e.hitSlowTimer <= 0)) {
                            e.hitSlowFactor = 1;
                        }
                        if (e.slowTimer > 0) e.slowTimer -= dt;
                        if (e.phaseLockTimer > 0) {
                            speedMultiplier *= e.phaseLockSlowFactor || 0.4;
                        }
                        if (e.stormShockTimer > 0) {
                            speedMultiplier *= 0.6;
                        }

                        // SWARM PROTOCOL: Fast homing enemies (construct_gold, avian_hatchling)
                        if (e.type === 'construct_gold' || e.type === 'avian_hatchling') {
                            const dx = store.player.x - e.x, dy = store.player.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 1) {
                                // Swarm enemies move directly toward player with slight randomness
                                const wobble = Math.sin(e.t * 8) * 15; // Add micro-dodges
                                const perpX = -dy / dist;
                                const perpY = dx / dist;
                                e.x += ((dx / dist) * e.v + perpX * wobble) * speedMultiplier * dt;
                                e.y += ((dy / dist) * e.v + perpY * wobble) * speedMultiplier * dt;
                            }
                        } else if (e.type === 'drone') {
                            // BASIC PROTOCOL: Simple downward movement with slight tracking
                            const wave = store.world.wave || 1;
                            if (wave >= 9) {
                                // In swarm waves, drones get basic homing
                                const dx = store.player.x - e.x;
                                const trackingStrength = 0.3; // Gentle tracking
                                if (Math.abs(dx) > 20) {
                                    e.x += Math.sign(dx) * 25 * trackingStrength * speedMultiplier * dt;
                                }
                            }
                            e.y += e.v * speedMultiplier * dt;
                        } else if (e.type === 'hunter') {
                            // PURSUIT PROTOCOL: Aggressive tracking
                            const dx = store.player.x - e.x;
                            const dy = store.player.y - e.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 1) {
                                // Hunters actively pursue with full 2D movement
                                const pursueFactor = 0.6; // 60% toward player, 40% downward
                                e.x += (dx / dist) * e.v * pursueFactor * speedMultiplier * dt;
                                e.y += ((dy / dist) * e.v * pursueFactor + e.v * (1 - pursueFactor)) * speedMultiplier * dt;
                            } else {
                                e.y += e.v * speedMultiplier * dt;
                            }
                        } else if (e.type === 'angler') {
                            // TANK PROTOCOL: Slow, steady, horizontal tracking only
                            const dx = store.player.x - e.x;
                            if (Math.abs(dx) > 10) e.x += Math.sign(dx) * 30 * speedMultiplier * dt;
                            e.y += e.v * speedMultiplier * dt;
                        } else if (e.type === 'phantom') {
                            // DODGE PROTOCOL: Unpredictable phase-shifting movement
                            const wave = store.world.wave || 1;
                            if (wave >= 13) {
                                // In precision/dodge waves, phantoms weave horizontally
                                const weaveSpeed = 40;
                                const weavePattern = Math.sin(e.t * 2.5) * weaveSpeed;
                                e.x += weavePattern * speedMultiplier * dt;
                                // Clamp to screen
                                e.x = Math.max(e.r + 10, Math.min(W - e.r - 10, e.x));
                            }
                            // Phantoms also move down like normal
                            e.y += e.v * speedMultiplier * dt;
                        } else if (e.type === 'mech') {
                            // HEAVY TANK PROTOCOL: Methodical advance with minimal deviation
                            // Mechs are slow and steady, tracking player horizontally
                            const dx = store.player.x - e.x;
                            const trackSpeed = 20; // Slower than angler
                            if (Math.abs(dx) > 15) {
                                e.x += Math.sign(dx) * trackSpeed * speedMultiplier * dt;
                            }
                            e.y += e.v * speedMultiplier * dt;
                        } else if (e.type === 'manta') {
                            e.t += dt;

                            // WEAVE PROTOCOL: Sinusoidal snake movement
                            // Enhanced for dodge-focused waves
                            const wave = store.world.wave || 1;
                            let waveAmplitude = e.amplitude;
                            let waveFrequency = e.frequency;
                            
                            if (wave >= 30) {
                                // In dodge hell waves, mantas weave more aggressively
                                waveAmplitude *= 1.3;
                                waveFrequency *= 1.2;
                            }
                            
                            e.x = e.startX + waveAmplitude * Math.sin(e.t * waveFrequency);
                            e.y += e.v * speedMultiplier * dt;
                        } else if (e.type === 'shadow_champion') {
                            const boss = store.boss && store.boss.behavior === 'shadow_clone' ? store.boss : null;
                            const enrageThreshold = e.enrageThreshold ?? 0.45;
                            const bossRatio = boss && boss.hpMax ? boss.hp / boss.hpMax : 1;
                            const isEnraged = boss ? (boss.isEnraged || bossRatio <= enrageThreshold) : true;
                            e.isEnraged = isEnraged;

                            if (e.state === 'dash') {
                                e.dashTimer -= dt;
                                e.x += (e.dashVX || 0) * speedMultiplier * dt;
                                e.y += (e.dashVY || 0) * speedMultiplier * dt;
                                addShadowEcho(e.x, e.y);
                                if (e.dashTimer <= 0) {
                                    e.state = null;
                                    e.dashVX = 0;
                                    e.dashVY = 0;
                                }
                            } else {
                                const anchorX = boss ? boss.x : store.player.x;
                                const anchorY = boss ? boss.y + (e.anchorOffsetY ?? 80) : store.player.y - 60;
                                const radius = boss ? (e.guardRadius || 120) : Math.max(80, (e.guardRadius || 120) * 0.65);
                                e.guardAngle = (e.guardAngle ?? 0) + (e.angularSpeed || 0.9) * dt * (isEnraged ? 1.35 : 1);
                                const desiredX = anchorX + Math.cos(e.guardAngle) * radius;
                                const desiredY = anchorY + Math.sin(e.guardAngle) * Math.max(radius * 0.55, 60);
                                const followSpeed = (e.momentum || 3.4) * (isEnraged ? 1.15 : 1);
                                e.x += (desiredX - e.x) * Math.min(1, followSpeed * dt);
                                e.y += (desiredY - e.y) * Math.min(1, followSpeed * 0.9 * dt);
                            }

                            store.shadowChampionLastPos = { x: e.x, y: e.y };
                        } else if (e.type === 'void_champion') {
                            e.baseV = e.baseV || e.v;
                            e.t += dt;
                            if (e.ramming) {
                                e.x += e.dashVX * speedMultiplier * dt;
                                e.y += e.dashVY * speedMultiplier * dt;
                                e.dashDuration -= dt;
                                if (e.dashDuration <= 0) {
                                    e.ramming = false;
                                    e.v = e.baseV;
                                    e.vx = (Math.random() < 0.5 ? -1 : 1) * (30 + Math.random() * 40);
                                }
                            } else {
                                e.v = e.baseV;
                                e.vx += Math.sin(e.t * 2.5) * 20 * dt;
                                e.x += (e.vx || 0) * speedMultiplier * dt;
                                // Void champion is immune to gravity - no automatic downward movement
                            }

                            if (!e.ramming) {
                                e.dashTimer -= dt;
                                if (e.dashTimer <= 0) {
                                    const dx = store.player.x - e.x;
                                    const dy = store.player.y - e.y;
                                    const dist = Math.max(60, Math.sqrt(dx * dx + dy * dy));
                                    e.dashVX = (dx / dist) * 260;
                                    e.dashVY = (dy / dist) * 260;
                                    e.dashDuration = 0.35;
                                    e.ramming = true;
                                    e.dashTimer = e.dashCooldown;
                                }
                            }

                            // Clamp void champion to playfield bounds (both horizontal and vertical)
                            if (e.x < e.r) {
                                e.x = e.r;
                                e.vx = Math.abs(e.vx || 60);
                            } else if (e.x > W - e.r) {
                                e.x = W - e.r;
                                e.vx = -Math.abs(e.vx || 60);
                            }

                            // NEW: Vertical clamping to keep void champion in playfield
                            if (e.y < e.r) {
                                e.y = e.r;
                                if (e.ramming && e.dashVY < 0) e.dashVY = Math.abs(e.dashVY);
                            } else if (e.y > H - e.r) {
                                e.y = H - e.r;
                                if (e.ramming && e.dashVY > 0) e.dashVY = -Math.abs(e.dashVY);
                            }
                        } else if (!e.isOrbiter) {
                            e.x += (e.vx || 0) * speedMultiplier * dt;
                            e.y += e.v * speedMultiplier * dt;
                        } else {
                            // Smooth following behavior for orbiters instead of rigid orbital motion
                            let orbitTarget = null;
                            if (e.orbitTargetId) {
                                orbitTarget = store.enemies.find(en => en.id === e.orbitTargetId && !en.dead);
                            }
                            // Don't fall back to store.boss - orbiters should die with their parent
                            
                            if (orbitTarget) {
                                // Calculate desired position around target using angle
                                e.orbitAngle += e.orbitSpeed * speedMultiplier * dt * 0.5; // Slower rotation
                                const desiredX = orbitTarget.x + e.orbitRadius * Math.cos(e.orbitAngle);
                                const desiredY = orbitTarget.y + e.orbitRadius * Math.sin(e.orbitAngle);
                                
                                // Smoothly interpolate to desired position with damping
                                const followSpeed = 8.0; // Higher = snappier, lower = more laggy/floaty
                                const dx = desiredX - e.x;
                                const dy = desiredY - e.y;
                                
                                e.x += dx * followSpeed * dt;
                                e.y += dy * followSpeed * dt;
                            } else {
                                e.dead = true;
                            }
                        }
                        if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
                    }

                    if (e.jugFearTimer > 0) {
                        const dxFear = e.x - store.player.x;
                        const dyFear = e.y - store.player.y;
                        const distFear = Math.sqrt(dxFear * dxFear + dyFear * dyFear) || 1;
                        const fleeSpeed = Math.max(90, (e.v || 60) * 1.9);
                        e.x += (dxFear / distFear) * fleeSpeed * dt;
                        e.y += (dyFear / distFear) * fleeSpeed * dt * 0.6;
                    }

                    if (e.stormShockTimer > 0) {
                        e.x += (Math.random() - 0.5) * 35 * dt;
                        e.y += (Math.random() - 0.5) * 35 * dt;
                    }

                    const boundaryMargin = e.r || 15;
                    e.x = Math.max(boundaryMargin, Math.min(W - boundaryMargin, e.x));
                    if (!e.topClampDelay || e.topClampDelay <= 0) {
                        if (e.y < boundaryMargin) {
                            e.y = boundaryMargin;
                        }
                    }

                    if (e.fireT > 0) e.fireT -= dt;
                    if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                        const damageMult = e.damageMult || 1;
                        switch (e.type) {
                            case 'hunter': {
                                const a = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                const bullet = getEBulletFromPool({ x: e.x, y: e.y, vx: Math.cos(a) * 180, vy: Math.sin(a) * 180, r: 3, col: e.color, dmg: 6 * dmgScale * damageMult });
                                store.eBullets.push(bullet);
                                e.fireT = 1; break;
                            }
                            case 'phantom': {
                                const bullet = getEBulletFromPool({ x: e.x, y: e.y, vx: 0, vy: 180, r: 3, col: e.color, dmg: 5 * dmgScale * damageMult });
                                store.eBullets.push(bullet);
                                e.fireT = e.fireCooldown; break;
                            }
                            case 'mech': {
                                e.attackPhase = (e.attackPhase || 0) + 1;
                                // Changed from 50/50 to 85% lob attacks, 15% shoulder cannons for more frequent lobs
                                if (e.attackPhase % 7 === 1) {
                                    // Shoulder cannon attack (less frequent now)
                                    const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                                    const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                                    store.eBullets.push({ x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult });
                                    const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                                    store.eBullets.push({ x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult });
                                } else {
                                    // Lob attack with randomized target location (more frequent now)
                                    // Limit target area to stay on screen with reasonable arc
                                    const randomOffsetX = (Math.random() - 0.5) * 300; // Reduced spread to 300 pixels
                                    const targetX = Math.max(80, Math.min(W - 80, store.player.x + randomOffsetX)); // Keep well within bounds

                                    // Limit Y coordinate to prevent extreme arcs
                                    const minY = Math.max(H * 0.5, e.y + 100); // Don't go too high above the mech
                                    const maxY = H - 80;   // Stop well above bottom
                                    const targetY = minY + Math.random() * (maxY - minY);

                                    const dx = targetX - e.x;
                                    const dy = targetY - e.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    // Much slower projectile for visibility and reasonable arc
                                    const timeToTarget = Math.max(1.5, dist / 120); // Slower speed = 120 instead of 180
                                    const gravity = 250; // Reduced gravity for gentler arc
                                    const vx = dx / timeToTarget;
                                    const vy = (dy - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;

                                    store.eBullets.push({
                                        x: e.x, y: e.y, vx: vx, vy: vy, r: 6,
                                        col: '#40e0d0', dmg: 18 * dmgScale * damageMult, // Turquoise projectile color to match mech
                                        gravity: gravity, isMechVolley: true, sourceId: e.id,
                                        targetX: targetX, targetY: targetY // Store intended target location
                                    });
                                }
                                e.fireT = 0.8; break; // Much more frequent attacks - reduced from 1.2 to 0.8
                            }
                            case 'angler': { const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); store.eBullets.push({ x: e.x, y: e.y, vx: Math.cos(a) * 120, vy: Math.sin(a) * 120, r: 4, col: e.color, dmg: 15 * dmgScale * damageMult, life: 5 }); e.fireT = 2.5; break; }
                            case 'manta': { for (let i = -1; i <= 1; i++) { const angle = (90 + i * 30) * Math.PI / 180; store.eBullets.push({ x: e.x, y: e.y, vx: Math.cos(angle) * 150, vy: Math.sin(angle) * 150, r: 3, col: e.color, dmg: 12 * dmgScale * damageMult }); } e.fireT = 2.8; break; }
                            case 'shadow_champion': {
                                const boss = store.boss && store.boss.behavior === 'shadow_clone' ? store.boss : null;
                                const enrageThreshold = e.enrageThreshold ?? 0.45;
                                const bossRatio = boss && boss.hpMax ? boss.hp / boss.hpMax : 1;
                                const isEnraged = boss ? (boss.isEnraged || bossRatio <= enrageThreshold) : true;
                                const attackMult = (e.damageMult || 1) * (isEnraged ? 1.2 : 1);
                                const angle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                if (Math.random() < 0.45) {
                                    const volley = isEnraged ? 6 : 4;
                                    const spread = isEnraged ? 0.18 : 0.14;
                                    for (let i = 0; i < volley; i++) {
                                        const offset = (i - (volley - 1) / 2) * spread;
                                        const speed = 320 + (isEnraged ? 90 : 60);
                                        store.eBullets.push(getEBulletFromPool({
                                            x: e.x + Math.cos(angle) * (e.r * 0.3),
                                            y: e.y + Math.sin(angle) * (e.r * 0.3),
                                            vx: Math.cos(angle + offset) * speed,
                                            vy: Math.sin(angle + offset) * speed,
                                            r: isEnraged ? 6 : 5,
                                            col: isEnraged ? '#a89fff' : '#d6dbff',
                                            dmg: 16 * attackMult,
                                            life: 1.6
                                        }));
                                    }
                                    e.fireT = isEnraged ? 1.05 : 1.35;
                                } else {
                                    e.state = 'dash';
                                    const dashSpeed = isEnraged ? 520 : 440;
                                    e.dashVX = Math.cos(angle) * dashSpeed;
                                    e.dashVY = Math.sin(angle) * dashSpeed;
                                    e.dashTimer = 0.32;
                                    addShadowEcho(e.x, e.y);
                                    e.fireT = isEnraged ? 1.25 : 1.55;
                                }
                                break;
                            }
                            case 'void_champion': {
                                if (e.nextPattern === 'beam') {
                                    const baseAngle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                    const spreads = [-0.25, 0, 0.25];
                                    spreads.forEach((offset, idx) => {
                                        const finalAngle = baseAngle + offset;
                                        const speed = 210 + idx * 25;
                                        store.eBullets.push({
                                            x: e.x,
                                            y: e.y,
                                            vx: Math.cos(finalAngle) * speed,
                                            vy: Math.sin(finalAngle) * speed,
                                            r: 6,
                                            col: '#ffb3ff',
                                            dmg: 18 * dmgScale * damageMult,
                                            life: 5
                                        });
                                    });
                                    e.nextPattern = 'burst';
                                } else {
                                    const bolts = 8;
                                    for (let i = 0; i < bolts; i++) {
                                        const angle = (i / bolts) * Math.PI * 2;
                                        store.eBullets.push({
                                            x: e.x,
                                            y: e.y,
                                            vx: Math.cos(angle) * 150,
                                            vy: Math.sin(angle) * 150,
                                            r: 5,
                                            col: '#de6cff',
                                            dmg: 12 * dmgScale * damageMult,
                                            life: 4
                                        });
                                    }
                                    e.nextPattern = 'beam';
                                    // Trigger orbiting shards to fire immediately
                                    store.enemies.forEach(minion => {
                                        if (minion.orbitTargetId === e.id && !minion.dead) {
                                            minion.fireT = Math.min(minion.fireT || 0, 0.1);
                                        }
                                    });
                                }
                                e.fireT = e.fireCooldown || 1.8;
                                break;
                            }
                            case 'void_champion_orb': {
                                const angle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                const speed = 220;
                                const module = e.attackModule || 'default';
                                const abilityTheme = e.abilityTheme || getChampionMinionAbilityTheme(module);
                                const projectileColor = abilityTheme?.trail || abilityTheme?.ring || e.color || '#ff6ad5';
                                store.eBullets.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    r: 4,
                                    col: projectileColor,
                                    dmg: 6 * dmgScale * damageMult,
                                    life: 4
                                });
                                e.fireT = e.fireCooldown || 1.1;
                                break;
                            }
                            default: { store.eBullets.push({ x: e.x, y: e.y, vx: 0, vy: 150, r: 3, col: e.color, dmg: 5 * dmgScale * damageMult }); e.fireT = .5; }
                        }
                    }

                    if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
                    if (collide(e, store.player)) {
                        const contactDmg = (e.contactDamage || 8) * dmgScale;
                        takeDamage(contactDmg); // Reduced baseline from 15 to 8 for better balance
                        if (e.type === 'shadow_champion') {
                            e.stunTimer = Math.max(e.stunTimer || 0, 0.35);
                            e.state = null;
                            e.dashTimer = 0;
                            e.dashVX = 0;
                            e.dashVY = 0;
                            e.fireT = Math.max(e.fireT, 0.8);
                        } else {
                            const contactGold = Number.isFinite(e.gold) ? e.gold : 0;
                            if (contactGold) addWorldGold(contactGold);
                            e.dead = true;
                        }
                    }
                });

                // BOSS flame collision (reuse pre-filtered active flames)
                if (store.boss && !store.boss.dead && flameCount > 0) {
                    for (let f = 0; f < flameCount; f++) {
                        const flame = activeFlames[f];

                        const dx = flame.x - store.boss.x;
                        const dy = flame.y - store.boss.y;

                        // Early culling for boss collision
                        if (Math.abs(dx) > 150 || Math.abs(dy) > 150) continue;

                        const distSq = dx * dx + dy * dy;
                        const collisionRadius = Math.max(10, flame.size + store.boss.r - 50);
                        const collisionRadiusSq = collisionRadius * collisionRadius;

                        if (distSq < collisionRadiusSq) {
                            store.boss.stunTimer = Math.max(store.boss.stunTimer || 0, 0.3);
                            const bossFlameDmg = flame.damage * 0.5;
                            const result = applyBossDamage(store.boss, bossFlameDmg, { point: { x: flame.x, y: flame.y } });

                            if (store.player.vampirism > 0 && result.amount > 0) {
                                let healAmount = result.amount * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.3);
                                healAmount = Math.min(healAmount, 2);
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }

                            store.boss.isBurning = true;
                            setTimeout(() => { if (store.boss) store.boss.isBurning = false; }, 100);
                            break; // Exit early after first collision
                        }
                    }
                }

                rebuildEnemySpatialIndex();
                const bossTarget = store.boss && !store.boss.dead ? store.boss : null;

                for (let bi = 0; bi < store.bullets.length; bi++) {
                    const b = store.bullets[bi];
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                    
                    // Handle fragment bullet lifetime
                    if (b.isFragment) {
                        b.lifetime = (b.lifetime || 0) + dt;
                        if (b.lifetime >= b.maxLifetime) {
                            b.dead = true;
                        }
                    }
                    
                    if (b.isSwirl) {
                        b.life = (b.life || 0) + dt;
                        b.x += Math.sin(b.life * 15) * 150 * dt;
                    }
                    if (b.isFlame) {
                        b.life -= dt;
                        if (b.life <= 0) b.dead = true;
                        b.particleSpawnT -= dt;
                        if (b.particleSpawnT <= 0) {
                            b.particleSpawnT = b.isLavaChunk ? 0.1 : 0.05;
                            const life = 0.3 + Math.random() * 0.3, angle = Math.random() * 2 * Math.PI, speed = b.isLavaChunk ? 10 + Math.random() * 15 : 20 + Math.random() * 20;
                            b.particles.push({ x: 0, y: 0, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: life, maxLife: life, r: 1 + Math.random() * (b.isLavaChunk ? 1.5 : 2) });
                        }
                        b.particles = b.particles.filter(p => {
                            p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt;
                            return p.life > 0;
                        });
                    } else if (b.isLevelUpPulse) {
                        b.life -= dt;
                        if (b.life <= 0) b.dead = true;
                    }

                    if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

                    if (!b.dead && bossTarget && !bossTarget.dead && collide(b, bossTarget)) {
                        handleBulletImpact(b, bossTarget);
                    }

                    if (!b.dead && store.enemies.length) {
                        const searchRadius = getBulletSearchRadius(b);
                        forEachEnemyNearby(b.x, b.y, searchRadius, enemy => {
                            if (enemy === bossTarget) return false;
                            if (!collide(b, enemy)) return false;
                            handleBulletImpact(b, enemy);
                            return b.dead && !b.pierce;
                        });
                    }

                    if (!b.dead && store.timeShards && store.timeShards.length) {
                        for (let si = store.timeShards.length - 1; si >= 0; si--) {
                            const shard = store.timeShards[si];
                            if (!shard || shard.dead) continue;
                            const hitRadius = (shard.r || 14) + (b.r || 3);
                            const dx = b.x - shard.x;
                            const dy = b.y - shard.y;
                            if (dx * dx + dy * dy > hitRadius * hitRadius) continue;

                            const damage = b.dmg || 12;
                            shard.hp -= damage;
                            shard.hitPulse = 0.22;
                            store.activeEffects.push(createEffect('hitSpark', shard.x, shard.y, (shard.r || 14) * 1.6, { strength: 32 }));

                            if (shard.hp <= 0) {
                                applyTimeShardBuff(shard.buffStacks || 1);
                                store.activeEffects.push(createEffect('spawnTeleport', shard.x, shard.y, 36, { color: '#9df7ff', duration: 0.32 }));
                                playSound('stargun');
                                store.timeShards.splice(si, 1);
                            }

                            if (!b.pierce) {
                                b.dead = true;
                            }
                            break;
                        }
                    }

                    // Check bullet collision with mech puddles (make puddles killable)
                    if (!b.dead && store.mechPuddles) {
                        for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
                            const puddle = store.mechPuddles[i];
                            const dx = b.x - puddle.x;
                            const dy = b.y - puddle.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < puddle.r + (b.r || 2)) {
                                // Puddle hit by bullet - take damage
                                puddle.hp -= (b.dmg || 15);

                                if (puddle.hp <= 0) {
                                    // Puddle destroyed - award rewards
                                    addWorldGold(1);
                                    store.world.xp += 1;

                                    // Small explosion effect
                                    for (let j = 0; j < 5; j++) {
                                        store.flameParticles.push({
                                            x: puddle.x + (Math.random() - 0.5) * 20,
                                            y: puddle.y + (Math.random() - 0.5) * 20,
                                            vx: (Math.random() - 0.5) * 100,
                                            vy: -Math.random() * 100,
                                            life: 0.3 + Math.random() * 0.3,
                                            maxLife: 0.3 + Math.random() * 0.3,
                                            r: 2 + Math.random() * 3,
                                            update: function (dt) {
                                                this.life -= dt;
                                                this.x += this.vx * dt;
                                                this.y += this.vy * dt;
                                                this.vy += 200 * dt; // gravity
                                                return this.life > 0;
                                            },
                                            draw: function () {
                                                if (!ctx) return;
                                                const alpha = this.life / this.maxLife;
                                                ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.r * alpha, 0, Math.PI * 2);
                                                ctx.fill();
                                            }
                                        });
                                    }

                                    // console.log('Puddle destroyed by bullet! +1 gold, +1 xp');
                                    store.mechPuddles.splice(i, 1);
                                }

                                if (!b.pierce) b.dead = true;
                                break;
                            }
                        }
                    }
                }

                updateStarProjectiles(dt);

                const p = store.player;
                const healthRatio = p.hp / p.hpMax;
                const lowHealthThreshold = 0.35;

                if (healthRatio < lowHealthThreshold) {
                    if (!store.world.isLowHealth) {
                        store.world.isLowHealth = true;
                        store.heartbeatT = 5.0;
                        // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                        store.activeEffects.push(createEffect("heartbeatPulse"));
                    } else {
                        if (store.heartbeatT > 0) {
                            store.heartbeatT -= dt;
                        } else {
                            store.heartbeatT = 5.0;
                            // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                            store.activeEffects.push(createEffect("heartbeatPulse"));
                        }
                    }
                } else if (store.world.isLowHealth) {
                    store.world.isLowHealth = false;
                }

                // Optimized cleanup with object pooling
                removeDeadObjects(store.bullets, bullet => bulletPool.release(bullet));
                removeDeadObjects(store.eBullets, bullet => returnEBulletToPool(bullet));

                // Efficient removal for other arrays
                removeDeadObjects(store.enemies);
                removeDeadObjects(store.shadowHounds);
                if (store.championMinions && store.championMinions.length) {
                    removeDeadObjects(store.championMinions);
                }
                removeDeadObjects(store.powerups);
                removeDeadObjects(store.mines);
                removeDeadObjects(store.missiles);
                removeDeadObjects(store.lasers);
                removeDeadObjects(store.flameParticles);
                removeDeadObjects(store.lightningBolts);
                removeDeadObjects(store.empNovas);
                removeDeadObjects(store.flamePulses);
                removeDeadObjects(store.shadowEchoes);
                removeDeadObjects(store.timeShards);
                if (store.playerChampion && store.playerChampion.dead) {
                    store.playerChampion = null;
                }

                // Handle active effects separately (different property name)
                compactInactiveEffects(store.activeEffects);
                
                // Cap active effects to prevent overdraw/performance issues (especially with dense enemy clusters)
                const MAX_ACTIVE_EFFECTS = 120;
                if (store.activeEffects.length > MAX_ACTIVE_EFFECTS) {
                    // Keep most recent effects, drop oldest ones
                    store.activeEffects.splice(0, store.activeEffects.length - MAX_ACTIVE_EFFECTS);
                }

                if (!store.boss && store.enemies.length === 0) {
                    // Add some delay before starting next wave to prevent rapid cycling
                    if (!store.world.waveTransitionTimer) {
                        store.world.waveTransitionTimer = performance.now();
                        return;
                    }

                    // Wait at least 0.5 seconds before progressing to next wave
                    if (performance.now() - store.world.waveTransitionTimer < 500) {
                        return;
                    }

                    // console.log(`Wave ${store.world.wave} completed, transitioning to wave ${store.world.wave + 1}`);

                    if (store.world.waveStartTime > 0 && store.world.wave > 1) {
                        const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;

                        // Guaranteed minimum collar stacks for any reasonable clear
                        let collarStacksToAdd = 0;
                        sanitizeCollarStacks();

                        if (waveClearTime < 2) {
                            // Ultra-instant clear: +9 collar stacks (addresses missing 9 stack issue)
                            collarStacksToAdd = 9;
                            store.world.enemyDensityBonus *= 1.15;
                            store.world.xpMultiplier *= 1.1;
                            announce("ðŸ’¥ ULTRA-INSTANT CLEAR! COLLAR CRUSHES +9 ðŸ’¥");
                        } else if (waveClearTime < 4) {
                            // Instant clear: +6 collar stacks
                            collarStacksToAdd = 6;
                            store.world.enemyDensityBonus *= 1.1;
                            store.world.xpMultiplier *= 1.07;
                            announce("âš¡ INSTANT WAVE CLEAR! COLLAR TIGHTENS +6 âš¡");
                        } else if (waveClearTime < 8) {
                            // Fast clear: +3 collar stacks
                            collarStacksToAdd = 3;
                            store.world.enemyDensityBonus *= 1.05;
                            store.world.xpMultiplier *= 1.03;
                            announce("âš¡ FAST WAVE CLEAR! COLLAR TIGHTENS +3 âš¡");
                        } else if (waveClearTime < 12) {
                            // Normal clear: +1 collar stack
                            collarStacksToAdd = 1;
                            announce("âš¡ COLLAR TIGHTENS +1 âš¡");
                        } else if (waveClearTime > 20) {
                            // Very slow clear: reset collar stacks (except during Death Engine fight)
                            const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
                            if (!isDeathEngineFight) {
                                const loosenedStacks = Math.max(0, sanitizeCollarStacks() - 2);
                                setCollarStacks(loosenedStacks);
                                announce("ðŸŒ SLOW CLEAR - COLLAR LOOSENS");
                            } else {
                                announce("THE DEATH ENGINE'S CURSE MAINTAINS THE COLLAR!");
                            }
                        }

                        // Add collar stacks only after 2nd boss is defeated - let first two bosses play normally
                        collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
                        if (store.world.bosses >= 2) {
                            if (collarStacksToAdd > 0) {
                                scheduleCollarIncrease(collarStacksToAdd);
                            } else {
                                approachCollarTarget();
                            }
                        }
                    }

                    store.world.wave++;
                    store.world.waveTransitionTimer = null; // Reset timer

                    const hpBonus = 1;
                    store.player.hpMax += hpBonus;
                    store.player.hp += hpBonus;
                    initWave();
                } else {
                    // Reset wave transition timer if there are still enemies or boss
                    store.world.waveTransitionTimer = null;
                }

                let xpNeeded = Math.floor(store.world.level * 100 * store.world.xpMultiplier * (store.world.level >= 8 ? 1.3 : store.world.level >= 4 ? 1.1 : 1) * (store.world.wave > 10 ? 1.3 : 1));
                if (store.world.xp >= xpNeeded) {
                    store.world.xp -= xpNeeded;
                    store.world.level++;
                    levelUp();
                }

                // Collar decay system - prevent infinite stacking
                if (!store.world.collarDecayTimer) {
                    store.world.collarDecayTimer = 0;
                }
                store.world.collarDecayTimer += dt;

                // Apply gradual collar decay every 10 seconds if stacks are high (only after 2nd boss, except during Death Engine fight)
                if (store.world.collarDecayTimer >= 10 && store.world.bosses >= 2) {
                    store.world.collarDecayTimer = 0;

                    // Don't decay collar stacks during Death Engine fight due to its intermission phases
                    const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';

                    if (!isDeathEngineFight) {
                        const currentStacks = sanitizeCollarStacks();
                        if (currentStacks > 20) {
                            // Decay faster when collar stacks are very high
                            const decay = Math.max(0.5, currentStacks * 0.02);
                            const newStacks = Math.max(0, currentStacks - decay);
                            setCollarStacks(newStacks);
                            // High collar stacks decay applied
                        } else if (currentStacks > 5) {
                            // Gentle decay for moderate stacks
                            const newStacks = Math.max(0, currentStacks - 0.3);
                            setCollarStacks(newStacks);
                        }
                    }
                }

                if (store.player.hp <= 0) {
                    // Check for nano charge before death
                    if (!triggerNanoSaveCharge()) {
                        handleGameOver();
                    }
                }
            }





            // PERFORMANCE: Efficient dead object removal (300-500% faster than filter)
            function removeDeadObjects(array, disposer) {
                let writeIndex = 0;
                for (let readIndex = 0; readIndex < array.length; readIndex++) {
                    const item = array[readIndex];
                    if (!item || item.dead) {
                        if (item && disposer) {
                            disposer(item);
                        }
                        continue;
                    }

                    if (writeIndex !== readIndex) {
                        array[writeIndex] = item;
                    }
                    writeIndex++;
                }

                if (writeIndex < array.length) {
                    array.length = writeIndex;
                }
            }

            function compactInactiveEffects(effects) {
                let writeIndex = 0;
                for (let readIndex = 0; readIndex < effects.length; readIndex++) {
                    const effect = effects[readIndex];
                    if (effect && effect.isActive !== false) {
                        if (writeIndex !== readIndex) {
                            effects[writeIndex] = effect;
                        }
                        writeIndex++;
                    }
                }

                if (writeIndex < effects.length) {
                    effects.length = writeIndex;
                }
            }

            function ensureSkillTrackingLists() {
                const p = store.player;
                if (!p) return;

                if (!Array.isArray(p.learnedSkills)) {
                    if (p.learnedSkills && typeof p.learnedSkills === 'object') {
                        const legacyKeys = Object.keys(p.learnedSkills).filter(key => p.learnedSkills[key]);
                        p.learnedSkills = legacyKeys;
                    } else {
                        p.learnedSkills = [];
                    }
                }
            }

            // Helper function to ensure progression tracking is initialized
            function initializeProgressionTracking() {
                const p = store.player;
                if (!p) return;

                if (typeof p.totalProgressionPoints !== 'number') p.totalProgressionPoints = 0;
                if (typeof p.unspentProgressionPoints !== 'number') p.unspentProgressionPoints = 0;
                if (typeof p.skillPointsSpent !== 'number') p.skillPointsSpent = 0;
                if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
                    p.signatureAbilities = {};
                }
                p.signatureAbility = Object.keys(p.signatureAbilities).length > 0;

                ensureSkillTrackingLists();

                // Ensure player always has skill points available for purchases (controlled by progression logic)
                if (typeof p.skillPoints !== 'number' || p.skillPoints <= 0) {
                    p.skillPoints = 10; // Generous skill point pool, but availability controlled by progression
                }
            }

            // Helper function to spend progression points when abilities are successfully added
            function spendProgressionPoint() {
                initializeProgressionTracking();
                if (store.player.unspentProgressionPoints > 0) {
                    store.player.unspentProgressionPoints -= 1;
                    return true;
                }
                return false;
            }

            // Helper function for progression logic (used by both boss defeat and upgrade hangar button)
            function checkProgressionLogic(awardPoint = false) {
                // Initialize progression tracking
                initializeProgressionTracking();

                // Award progression point if this is from boss defeat
                if (awardPoint) {
                    store.player.totalProgressionPoints += 1;
                    store.player.unspentProgressionPoints += 1;
                }

                const playerTotalPts = store.player.totalProgressionPoints;
                const playerUnspentPts = store.player.unspentProgressionPoints;
                const currentSpec = store.player.pilotGenome;
                const currentSubclass = store.player.subclass;

                // Progression logic following Python pattern
                if (playerTotalPts === 1 && playerUnspentPts > 0) {
                    // First boss - open class select
                    if (awardPoint) store.player.pilotGenome = 'pending';
                    setTimeout(showPilotSelect, awardPoint ? 1000 : 0);
                    return true;
                } else if (playerTotalPts > 1 && currentSpec && currentSpec !== 'pending' && !currentSubclass && playerUnspentPts > 0) {
                    // Second+ boss with class selected but no subclass - open subclass select
                    setTimeout(showSubclassSelect, awardPoint ? 1500 : 0);
                    return true;
                } else if (playerTotalPts > 2 && currentSpec && currentSpec !== 'pending' && currentSubclass && playerUnspentPts > 0) {
                    // Third+ boss with class and subclass - open skill tree
                    setTimeout(showSkillTreeModal, awardPoint ? 1500 : 0);
                    return true;
                }

                return false; // No progression available
            }

            function handleBossDefeat() {
                const activeBoss = store.boss;
                const snapshot = activeBoss || store.lastBossSnapshot;
                if (!snapshot) {
                    return;
                }

                const world = store.world || {};
                const completedTokens = world.completedBossTokens || (world.completedBossTokens = Object.create(null));
                const activeToken = world.activeBossToken || null;
                const snapshotToken = snapshot.instanceId || snapshot.id || snapshot._instanceId || null;
                const fallbackToken = snapshot.behavior || snapshot.name || null;
                const awardToken = snapshotToken || activeToken || fallbackToken || `legacy-${world.wave || 0}-${world.bosses || 0}`;

                if (completedTokens[awardToken]) {
                    return;
                }

                if (activeToken && awardToken !== activeToken) {
                    return;
                }

                const bossId = snapshotToken || fallbackToken || snapshot.name || 'UNKNOWN';

                const playerRef = store.player || {};
                const fallbackX = Number.isFinite(playerRef.x) ? playerRef.x : W / 2;
                const fallbackY = Number.isFinite(playerRef.y) ? playerRef.y : H / 2;
                const bossX = ensureFiniteNumber(snapshot.x, fallbackX);
                const bossY = ensureFiniteNumber(snapshot.y, fallbackY);
                const bossName = snapshot.name || 'UNKNOWN';

                store.lastBossSnapshot = { x: bossX, y: bossY, name: bossName, id: bossId, instanceId: awardToken };
                store.lastBossDefeatId = awardToken;
                completedTokens[awardToken] = true;
                world.activeBossToken = null;
                world.lastBossAwardToken = awardToken;
                if (activeBoss) {
                    activeBoss.dead = true;
                }

                const now = performance.now();
                const bossSpawnTime = ensureFiniteNumber(store.world.bossSpawnTime, now);
                const fightDuration = ensureFiniteNumber((now - bossSpawnTime) / 1000, 0);

                // Use progression logic with point award
                checkProgressionLogic(true);

                const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                const scoreBonus = Math.floor(2000 * collarBonus);
                const goldBonus = Math.floor(25 * collarBonus);
                const xpBonus = Math.floor(100 * collarBonus);
                if (scoreBonus) store.world.score += scoreBonus;
                if (goldBonus) addWorldGold(goldBonus);
                if (xpBonus) store.world.xp += xpBonus;
                store.world.bosses++;
                if (store.goldenOrbs) {
                    store.goldenOrbs.length = 0;
                }

                // Clear any poison puddles and poison blobs from HIVE SOVEREIGN when boss is defeated
                if (store.poisonPuddles) {
                    store.poisonPuddles = [];
                }
                // Also clear poison blobs still in flight to prevent persistent puddles
                store.bullets = store.bullets.filter(b => {
                    if (b.type === 'poisonBlob') {
                        bulletPool.release(b);
                        return false;
                    }
                    return true;
                });

                store.boss = null;
                announce('âš¡ GUARDIAN DEFEATED âš¡');
                explode(bossX, bossY, true);

                if (bossName === 'SHADOW MIRROR') {
                    finalizeShadowChampionAfterBoss(bossX, bossY);
                }

                let healthBonusMultiplier = 1.0, announcedAdaptation = false;
                // Calculate collar stacks to add based on boss kill speed (more generous)
                let collarStacksToAdd = 0;
                sanitizeCollarStacks();

                if (fightDuration <= 2) {
                    // Ultra-fast boss kill: massive collar bonus
                    collarStacksToAdd = 12;
                    announcedAdaptation = true;
                    if (store.world.wave >= 15) {
                        store.world.consecutiveFastKills++;
                        if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                        healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                        announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
                    } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
                    announce(`ðŸ’¥ COLLAR CRUSHES +${collarStacksToAdd} ðŸ’¥`);
                } else if (fightDuration <= 5) {
                    // Fast boss kill
                    collarStacksToAdd = Math.max(8, Math.floor(12 - (fightDuration * 1.5)));
                    announcedAdaptation = true;
                    if (store.world.wave >= 15) {
                        store.world.consecutiveFastKills++;
                        if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                        healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                        announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
                    } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
                    announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
                } else if (fightDuration < 8) {
                    // Decent boss kill
                    collarStacksToAdd = Math.max(3, Math.floor(10 - fightDuration));
                    announcedAdaptation = true;
                    healthBonusMultiplier = 1.15;
                    store.world.consecutiveFastKills = 0;
                    store.world.fastKillBonus = 0;
                    announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
                } else if (fightDuration < 12) {
                    // Slow boss kill: minimal collar bonus
                    collarStacksToAdd = 1;
                    announcedAdaptation = true;
                    healthBonusMultiplier = 1.05;
                    store.world.consecutiveFastKills = 0;
                    store.world.fastKillBonus = 0;
                    announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
                } else {
                    // Very slow kill: reduce collar stacks (except for DEATH ENGINE)
                    if (bossName !== 'DEATH ENGINE') {
                        const loosened = Math.max(0, sanitizeCollarStacks() - 3);
                        setCollarStacks(loosened);
                        announce("âš–ï¸ COLLAR LOOSENS - ADAPTATION WEAKENS");
                    } else {
                        announce("THE DEATH ENGINE'S CURSE PERSISTS!");
                    }
                    store.world.consecutiveFastKills = 0;
                    store.world.fastKillBonus = 0;
                    healthBonusMultiplier = 1.0;
                }

                // Special handling for Death Engine - restore preserved collar stacks
                if (bossName === 'DEATH ENGINE' && store.world.deathEngineCollarStacks !== undefined) {
                    const originalStacks = ensureFiniteNumber(store.world.deathEngineCollarStacks, sanitizeCollarStacks());
                    const originalTarget = ensureFiniteNumber(store.world.deathEngineCollarTargetStacks, originalStacks);
                    setCollarStacks(Math.max(0, originalStacks));
                    store.world.collarTargetStacks = Math.min(MAX_COLLAR_STACKS, Math.max(store.world.collarStacks, originalTarget));
                    const addAfterRestore = ensureFiniteNumber(collarStacksToAdd, 0);
                    if (addAfterRestore > 0) {
                        scheduleCollarIncrease(addAfterRestore);
                    } else {
                        approachCollarTarget();
                    }
                    delete store.world.deathEngineCollarStacks; // Clean up
                    delete store.world.deathEngineCollarTargetStacks;
                } else {
                    // Add collar stacks only after 2nd boss is defeated - collar system starts with 3rd boss
                    collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
                    if (store.world.bosses >= 2) {
                        if (collarStacksToAdd > 0) {
                            scheduleCollarIncrease(collarStacksToAdd);
                        } else {
                            approachCollarTarget();
                        }
                    }
                }
                // FIXED: Don't permanently modify health bonuses - collar handles this dynamically
                // Instead, only apply temporary density and XP bonuses based on performance
                if (announcedAdaptation) {
                    // Only apply density bonuses, not permanent health increases
                    if (healthBonusMultiplier > 1.3) {
                        store.world.enemyDensityBonus *= 1.15;
                    } else if (healthBonusMultiplier > 1.1) {
                        store.world.enemyDensityBonus *= 1.10;
                    } else if (healthBonusMultiplier > 1.0) {
                        store.world.enemyDensityBonus *= 1.05;
                    }
                    setTimeout(() => announce("GUARDIAN DEFEATED!"), 1000);
                }
            }

            function explode(x, y, isBoss = false, isSmall = false) {
                playSound('explosion');
                if (isBoss) {
                    // Spawn regular powerups
                    for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
                    
                    // Guaranteed boss-tier upgrade drop with delay
                    setTimeout(() => {
                        spawnUpgradePowerup(x + Math.random() * 60 - 30, y + Math.random() * 60 - 30, 'bossTier');
                        
                        // Luck gives small chance for bonus drop (33% of normal luck effectiveness)
                        const luckBonus = (store.player.luckBoost || 0) * 0.33;
                        if (Math.random() < luckBonus) {
                            setTimeout(() => {
                                spawnUpgradePowerup(x + Math.random() * 80 - 40, y + Math.random() * 80 - 40, Math.random() < 0.5 ? 'midTier' : 'bossTier');
                            }, 800);
                        }
                    }, 1500);
                }
                if (isSmall) {
                    const radius = 60;
                    const dmg = 25 * store.player.dmgMult;
                    const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                    targets.forEach(e => {
                        if (!e.dead) {
                            const distSq = (e.x - x) ** 2 + (e.y - y) ** 2;
                            if (distSq < radius ** 2) {
                                e.hp -= dmg;
                                store.world.totalDamage += dmg;

                                // Track damage dealt for beef shield system
                                if (store.player.pilotGenome === 'beef') {
                                    store.player.beefShieldDamageDealt += dmg;
                                }

                                // Apply vampirism healing for explosion damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = dmg * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP
                                    healAmount = Math.min(healAmount, 2); // Cap at 2 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }
                            }
                        }
                    });
                    store.activeEffects.push(createEffect("grenadeExplosion", x, y, radius));
                }
            }

            function levelUp() {
                announce(`LEVEL UP! âš¡ CHOOSE YOUR AUGMENTATION!`);
                pauseGame();

                // Natural health growth: 10% per level
                const healthGrowth = store.player.hpMax * 0.1;
                store.player.hpMax += healthGrowth;
                store.player.hp += healthGrowth;

                store.player.isInvincible = true;
                const speedBoost = store.player.speed * 0.75;
                const fireRateBoost = store.player.fireRate * 0.5;
                store.player.speed += speedBoost;
                store.player.fireRate -= fireRateBoost;

                const levelUpPulse = () => {
                    const p = store.player;
                    const numBullets = 36;
                    for (let i = 0; i < numBullets; i++) {
                        const angle = (i / numBullets) * 2 * Math.PI;
                        const bulletSpeed = 300;
                        spawnBullet({
                            x: p.x,
                            y: p.y,
                            vx: Math.cos(angle) * bulletSpeed,
                            vy: Math.sin(angle) * bulletSpeed,
                            r: 4,
                            col: '#ffddff',
                            dmg: 30 * p.dmgMult,
                            pierce: true,
                            life: 1.5,
                            isLevelUpPulse: true
                        });
                    }
                };

                levelUpPulse();
                setTimeout(levelUpPulse, 250);

                // Store timeout ID to prevent multiple level-ups causing permanent bonuses
                if (store.levelUpTimeoutId) {
                    clearTimeout(store.levelUpTimeoutId);
                }

                store.levelUpTimeoutId = setTimeout(() => {
                    store.player.isInvincible = false;
                    store.player.speed -= speedBoost;
                    store.player.fireRate += fireRateBoost;
                    store.levelUpTimeoutId = null;
                }, 3000);

                const panel = q('levelPanel'), grid = q('skillsGrid');
                const availableUpgrades = LEVEL_UPGRADES.filter(u => {
                    if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
                    // Check if upgrade has availability function
                    if (u.available && typeof u.available === 'function') return u.available();
                    return true;
                });

                for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; }
                const choices = availableUpgrades.slice(0, 3);
                grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');

                const cards = grid.querySelectorAll('.skill-card');
                const clickHandler = (e) => {
                    const card = e.currentTarget;
                    const id = card.dataset.id;
                    const upgrade = LEVEL_UPGRADES.find(s => s.id === id);
                    if (upgrade) upgrade.apply();
                    panel.classList.add('hide');
                    resumeGame();
                    // Clean up event listeners to prevent UI freeze
                    cards.forEach(c => c.removeEventListener('click', clickHandler));
                };

                cards.forEach(card => {
                    card.addEventListener('click', clickHandler);
                });

                panel.classList.remove('hide');
                enterPanel('subclassPanel');
            }

            function handleGameOver() {
                if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score);
                announce('â—¢ NEXUS BREACH - PILOT LOST â—£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide');
            }

            function resetGame() {
                store.player = JSON.parse(JSON.stringify(player_initial_state));
                const prevAutoForge = (store.world && typeof store.world.autoForgeEnabled === 'boolean') ? store.world.autoForgeEnabled : storedAutoForgeEnabled;

                // Ensure dmgMult is initialized
                if (!store.player.dmgMult) store.player.dmgMult = 1;

                const now = performance.now();
                store.world = {
                    wave: 1,
                    score: 0,
                    gold: 0,
                    xp: 0,
                    level: 1,
                    kills: 0,
                    bosses: 0,
                    bossesAtPilotSelection: null,
                    lowHealthTutorialShown: false,
                    mechForgeGoldTriggered: false,
                    mechForgePulseTimeout: null,
                    bossSpawnTime: 0,
                    waveStartTime: 0,
                    activeBossToken: null,
                    activeBossWave: null,
                    completedBossTokens: Object.create(null),
                    lastBossAwardToken: null,
                    enemyHealthBonus: 1.0,
                    bossHealthBonus: 1.0,
                    enemyDensityBonus: 1.0,
                    powerupCooldown: 0,
                    xpMultiplier: 1.0,
                    collarStacks: 0,
                    lateGameDamageScaling: 1,
                    consecutiveFastKills: 0,
                    fastKillBonus: 0,
                    totalDamage: 0,
                    damageStartTime: performance.now(),
                    lastThreatScale: 1,
                    lastSpawnOverflow: 0,
                    lastPlannedSpawnCount: 0,
                    lastSpawnCount: 0,
                    lastSpawnFallback: false,
                    lastSpawnQueueLength: 0,
                    lastSpawnTempo: 0,
                    firstBossOrbsGifted: false,
                    mechForgePromptActive: false,
                    mechForgePromptInterval: 250,
                    nextMechForgePrompt: 135,
                    mechForgePromptCount: 0,
                    autoForgeEnabled: prevAutoForge,
                    autoForgeReserve: 0,
                    autoForgeDecisionTimer: null,
                    autoForgeAnnounceCooldown: 0,
                    totalForgeSpend: 0,
                    autoForgeTutorialShown: false,
                    shopTutorialShown: false,
                    shopSpotlightDismissed: false,
                    currentThemeKey: DEFAULT_MAP_THEME_KEY,
                    targetThemeKey: DEFAULT_MAP_THEME_KEY,
                    themeTransitionProgress: 1,
                    themeTransitionActive: false,
                    gameStartTime: now,
                    autoForgeProfileId: store.settings.autoForgeProfile
                };

                if (store.bullets && store.bullets.length) {
                    store.bullets.forEach(bullet => bulletPool.release(bullet));
                }
                if (store.eBullets && store.eBullets.length) {
                    store.eBullets.forEach(returnEBulletToPool);
                }
                store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = []; store.powerups = []; store.starProjectiles = []; store.pendingStarSalvos = []; store.pendingStarClones = []; store.juggernautBombs = [];
                store.lastBossSnapshot = null;
                store.lastBossDefeatId = null;
                store.drones = []; store.hounds = []; store.shadowHounds = []; store.voidRifts = []; store.missiles = []; store.lasers = []; store.mines = []; store.activeEffects = []; store.flameParticles = [];
                store.lightningBolts = []; store.empNovas = []; store.flamePulses = []; store.poisonPuddles = []; store.goldenOrbs = []; store.shadowEchoes = [];
                store.championMinions = [];
                store.empCharges = [];
                store.empGlobalCooldown = 0;
                store.playerChampion = null;
                store.shadowChampionId = null;
                store.shadowChampionDefeated = false;
                store.shadowChampionTokenDropped = false;
                store.shadowChampionLastPos = null;
                store.iceman = null;
                store.beefClone = null;
                store.escortDrones = [];
                store.waveSpawnQueue = [];
                store.pendingSpawnCount = 0;
                store._startTs = performance.now(); store.isGameOver = false;
                store.cheatsUsed = false;
                store.cheatInvincibilityCooldown = 0;
                store.cheatDogHealCooldown = 0;
                store.cheatChampionCooldown = 0;
                store.ui.shopSpotlightActive = false;
                store.ui.shopSpotlightMessage = 'Upgrade Hangar online. Deploy credits as needed.';
                shopItemOrder = [...SHOP_DISPLAY_ORDER];
                q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide');
                q('subclassPanel').classList.add('hide');
                const mechForgeBtn = q('shopBtn');
                if (mechForgeBtn) {
                    mechForgeBtn.classList.remove('forge-highlight');
                    mechForgeBtn.classList.remove('mech-forge-pulse');
                    if (mechForgeBtn._forgePulseTimeout) {
                        clearTimeout(mechForgeBtn._forgePulseTimeout);
                        mechForgeBtn._forgePulseTimeout = null;
                    }
                }
                setMapThemeImmediate(DEFAULT_MAP_THEME_KEY);
                ensureName();
            }

            // --- RENDER & DRAW FUNCTIONS ---
            const TAU = Math.PI * 2;
            const THEME_TRANSITION_DURATION = 3.3;

            let activeMapThemeState = null;
            let transitioningMapThemeState = null;
            let themeTransitionTimer = 0;

            function ensureValidThemeKey(themeKey) {
                if (themeKey && MAP_THEME_DEFS[themeKey]) return themeKey;
                return DEFAULT_MAP_THEME_KEY;
            }

            function randRange(min, max) {
                return min + Math.random() * (max - min);
            }

            function instantiateMapThemeState(themeKey) {
                const key = ensureValidThemeKey(themeKey);
                const def = MAP_THEME_DEFS[key] || MAP_THEME_DEFS[DEFAULT_MAP_THEME_KEY];
                return {
                    key,
                    def,
                    starLayers: (def.starLayers || []).map(layer => ({
                        config: layer,
                        stars: Array.from({ length: layer.count || 0 }, () => ({
                            x: Math.random() * W,
                            y: Math.random() * H,
                            radius: randRange(layer.minRadius || 0.25, layer.maxRadius || 1.4),
                            twinkleSeed: Math.random() * TAU
                        }))
                    })),
                    auroraBands: def.auroraBands ? def.auroraBands.map(band => ({
                        config: band,
                        phase: Math.random() * TAU
                    })) : null
                };
            }

            function createThemeGradient(def) {
                if (!def || !def.stops || def.stops.length === 0) return null;
                if (def.type === 'radial') {
                    const radius = Math.min(W, H) * (def.radius !== undefined ? def.radius : 1);
                    const cx = W * (def.x !== undefined ? def.x : 0.5);
                    const cy = H * (def.y !== undefined ? def.y : 0.5);
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
                    def.stops.forEach(stop => gradient.addColorStop(stop.offset, stop.color));
                    return gradient;
                }
                const angle = def.angle !== undefined ? def.angle : 0;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const half = Math.max(W, H);
                const cx = W / 2;
                const cy = H / 2;
                const gradient = ctx.createLinearGradient(cx - cos * half, cy - sin * half, cx + cos * half, cy + sin * half);
                def.stops.forEach(stop => gradient.addColorStop(stop.offset, stop.color));
                return gradient;
            }

            function renderThemeStarLayers(state, dt, alpha) {
                if (!state || !state.starLayers || state.starLayers.length === 0 || alpha <= 0) return;
                const alphaClamp = Math.max(0, Math.min(1, alpha));
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (let l = 0; l < state.starLayers.length; l++) {
                    const layer = state.starLayers[l];
                    const cfg = layer.config || {};
                    const stars = layer.stars;
                    const speed = cfg.speed || 28;
                    const driftX = cfg.driftX || 0;
                    const twinkleSpeed = cfg.twinkleSpeed || 1.4;
                    const twinkleAmp = cfg.twinkleAmplitude || 0.45;
                    const baseAlpha = alphaClamp * (cfg.baseAlpha !== undefined ? cfg.baseAlpha : 1);
                    const baseColor = cfg.color || 'rgba(255,255,255,0.7)';
                    const pulseColor = cfg.pulseColor || baseColor;
                    for (let i = 0; i < stars.length; i++) {
                        const star = stars[i];
                        star.y += speed * dt;
                        star.x += driftX * dt;
                        if (star.y > H + 20) star.y -= (H + 40);
                        if (star.y < -20) star.y += (H + 40);
                        if (star.x > W + 20) star.x -= (W + 40);
                        if (star.x < -20) star.x += (W + 40);
                        const twinkle = Math.sin(frameTime * twinkleSpeed + star.twinkleSeed);
                        const radius = Math.max(0.05, star.radius * (1 + Math.abs(twinkle) * twinkleAmp));
                        const glowAlpha = baseAlpha * (0.7 + Math.abs(twinkle) * 0.3);
                        ctx.globalAlpha = glowAlpha;
                        ctx.fillStyle = twinkle >= 0 ? pulseColor : baseColor;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, radius, 0, TAU);
                        ctx.fill();
                    }
                }
                ctx.restore();
            }

            function renderThemeAurora(state, dt, alpha) {
                if (!state || !state.auroraBands || state.auroraBands.length === 0 || alpha <= 0) return;
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                for (let i = 0; i < state.auroraBands.length; i++) {
                    const band = state.auroraBands[i];
                    const cfg = band.config || {};
                    const stops = cfg.colorStops || [];
                    if (stops.length === 0) continue;
                    band.phase += (cfg.waveSpeed || 0) * dt;
                    const bandAlpha = (cfg.alpha !== undefined ? cfg.alpha : 0.4) * alpha;
                    if (bandAlpha <= 0) continue;
                    const baseY = (cfg.y !== undefined ? cfg.y : 0.5) * H;
                    const waveOffset = Math.sin(band.phase) * (cfg.waveAmplitude || 0) * H;
                    const thickness = Math.max(6, (cfg.thickness || 0.16) * H);
                    const gradient = ctx.createLinearGradient(0, 0, W, 0);
                    if (stops.length === 1) {
                        gradient.addColorStop(0, stops[0]);
                        gradient.addColorStop(1, stops[0]);
                    } else {
                        for (let s = 0; s < stops.length; s++) {
                            gradient.addColorStop(stops.length === 1 ? 0.5 : s / (stops.length - 1), stops[s]);
                        }
                    }
                    ctx.save();
                    ctx.translate(W * 0.5, baseY + waveOffset);
                    if (cfg.rotation) ctx.rotate(cfg.rotation);
                    ctx.globalAlpha = bandAlpha;
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-W * 0.8, -thickness * 0.5, W * 1.6, thickness);
                    ctx.restore();
                }
                ctx.restore();
            }

            function renderMapThemeState(state, dt, alpha) {
                if (!state || alpha <= 0) return;
                const def = state.def || {};
                const gradient = createThemeGradient(def.gradient);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = gradient || def.baseFill || '#050008';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
                renderThemeStarLayers(state, dt, alpha);
                renderThemeAurora(state, dt, alpha);
            }

            function setMapThemeImmediate(themeKey) {
                const key = ensureValidThemeKey(themeKey);
                activeMapThemeState = instantiateMapThemeState(key);
                transitioningMapThemeState = null;
                themeTransitionTimer = THEME_TRANSITION_DURATION;
                if (store && store.world) {
                    store.world.currentThemeKey = key;
                    store.world.targetThemeKey = key;
                    store.world.themeTransitionProgress = 1;
                    store.world.themeTransitionActive = false;
                }
            }

            function finalizeMapThemeTransition() {
                if (!transitioningMapThemeState) return;
                activeMapThemeState = transitioningMapThemeState;
                transitioningMapThemeState = null;
                themeTransitionTimer = THEME_TRANSITION_DURATION;
                if (store && store.world) {
                    store.world.currentThemeKey = activeMapThemeState.key;
                    store.world.themeTransitionActive = false;
                    store.world.themeTransitionProgress = 1;
                }
            }

            function transitionMapTheme(themeKey, options = {}) {
                const { immediate = false, force = false } = options;
                const key = ensureValidThemeKey(themeKey);
                if (immediate || !activeMapThemeState) {
                    setMapThemeImmediate(key);
                    return;
                }
                if (!force && activeMapThemeState && activeMapThemeState.key === key && !transitioningMapThemeState) {
                    return;
                }
                transitioningMapThemeState = instantiateMapThemeState(key);
                themeTransitionTimer = 0;
                if (store && store.world) {
                    store.world.targetThemeKey = key;
                    store.world.themeTransitionActive = true;
                    store.world.themeTransitionProgress = 0;
                }
            }

            function queueMapThemeTransition(themeKey, options) {
                transitionMapTheme(themeKey, options);
            }

            function ensureActiveTheme() {
                const desiredKey = ensureValidThemeKey(store?.world?.currentThemeKey);
                if (!activeMapThemeState) {
                    setMapThemeImmediate(desiredKey);
                } else if (activeMapThemeState.key !== desiredKey && !transitioningMapThemeState) {
                    transitionMapTheme(desiredKey, { immediate: true, force: true });
                }
            }

            function advanceMapTheme(dt) {
                ensureActiveTheme();
                if (transitioningMapThemeState) {
                    themeTransitionTimer = Math.min(THEME_TRANSITION_DURATION, themeTransitionTimer + dt);
                    const progress = Math.min(1, themeTransitionTimer / THEME_TRANSITION_DURATION);
                    const fadeOutAlpha = Math.max(0, 1 - progress);
                    if (fadeOutAlpha > 0 && activeMapThemeState) {
                        renderMapThemeState(activeMapThemeState, dt, fadeOutAlpha);
                    }
                    renderMapThemeState(transitioningMapThemeState, dt, progress);
                    if (store && store.world) {
                        store.world.themeTransitionProgress = progress;
                    }
                    if (progress >= 1) {
                        finalizeMapThemeTransition();
                    }
                } else if (activeMapThemeState) {
                    renderMapThemeState(activeMapThemeState, dt, 1);
                } else {
                    ctx.fillStyle = MAP_THEME_DEFS[DEFAULT_MAP_THEME_KEY]?.baseFill || '#050008';
                    ctx.fillRect(0, 0, W, H);
                }
            }

            function getActiveMapThemeKey() {
                if (transitioningMapThemeState) {
                    return transitioningMapThemeState.key;
                }
                if (activeMapThemeState) {
                    return activeMapThemeState.key;
                }
                return ensureValidThemeKey(store?.world?.currentThemeKey);
            }

            function getBossThemeKey(boss) {
                if (!boss) return DEFAULT_MAP_THEME_KEY;
                if (boss.themeKey && MAP_THEME_DEFS[boss.themeKey]) {
                    return boss.themeKey;
                }
                if (boss.name && BOSS_THEME_MAP[boss.name]) {
                    return ensureValidThemeKey(BOSS_THEME_MAP[boss.name]);
                }
                return DEFAULT_MAP_THEME_KEY;
            }

            function applyBossTheme(boss, options = {}) {
                const themeKey = getBossThemeKey(boss);
                const mergedOptions = { force: true, ...options };
                queueMapThemeTransition(themeKey, mergedOptions);
            }

            // Cache for gradient objects to avoid recreation
            let poisonGradientCache = new Map();
            let mechGradientCache = new Map();
            let frameTime = 0;
            let frameCount = 0;

            // Clear caches periodically to prevent memory buildup
            function clearGradientCaches() {
                if (frameCount % 1000 === 0) { // Clear every ~17 seconds at 60fps
                    poisonGradientCache.clear();
                    mechGradientCache.clear();
                }
            }

            function render(dt) {
                frameCount++;
                clearGradientCaches();

                // Performance optimization: Use faster fill method and cache time calculation
                ctx.fillStyle = '#050008';
                ctx.fillRect(0, 0, W, H);
                frameTime = performance.now() / 1000;

                // Render boss-themed background with transitions
                advanceMapTheme(dt);



                const closeBullets = [];
                const farBullets = [];
                const proximityThreshold = 110;
                const playerPos = store.player;

                store.eBullets.forEach(b => {
                    const distSq = (b.x - playerPos.x) ** 2 + (b.y - playerPos.y) ** 2;
                    if (distSq < proximityThreshold ** 2) {
                        closeBullets.push({ bullet: b, dist: Math.sqrt(distSq) });
                    } else {
                        farBullets.push(b);
                    }
                });

                store.powerups.forEach(p => drawPowerup(p));
                drawTimeShards();
                drawGoldenOrbs();
                store.missiles.forEach(m => drawMissile(m));
                store.lightningBolts.forEach(l => drawLightningBolt(l));
                store.empNovas.forEach(n => drawEmpNova(n));
                store.flamePulses.forEach(p => drawFlamePulse(p));
                drawStarProjectiles();


                // Optimized far bullets rendering with batched operations
                for (let i = 0; i < farBullets.length; i++) {
                    const b = farBullets[i];

                    // Apply visual fade-in for Death Engine bullet rain
                    let alpha = 1.0;
                    if (b.fadeInTime && b.spawnTime) {
                        const timeAlive = (performance.now() - b.spawnTime) / 1000;
                        alpha = Math.min(1.0, timeAlive / b.fadeInTime);
                    }

                    if (alpha < 1.0) {
                        ctx.save();
                        ctx.globalAlpha = alpha;
                    }

                    ctx.fillStyle = b.col;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, 6.283185307179586); // Use constant
                    ctx.fill();

                    if (alpha < 1.0) {
                        ctx.restore();
                    }
                }

                store.bullets.forEach(b => {
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.fillStyle = b.col;
                    ctx.beginPath();

                    const r = b.r * 1.5;

                    if (b.isLavaChunk) {
                        ctx.beginPath();
                        ctx.moveTo(0, -r); ctx.lineTo(r, r * 0.2); ctx.lineTo(r * 0.5, r); ctx.lineTo(-r * 0.5, r); ctx.lineTo(-r, r * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        b.particles.forEach(p => {
                            const t = p.life / p.maxLife;
                            const particleR = p.r * t;
                            ctx.fillStyle = `rgba(255, ${60 + Math.random() * 60}, 0, ${0.7 * t})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                            ctx.fill();
                        });
                    } else if (b.isFlame) {
                        ctx.fillStyle = `rgba(255, 150, 50, ${0.3 * (b.life / 50)})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, b.r * 0.5, 0, 2 * Math.PI);
                        ctx.fill();
                        b.particles.forEach(p => {
                            const t = p.life / p.maxLife;
                            const r_particle = p.r * t;
                            const g = Math.floor(255 * (0.4 + t * 0.6));
                            const b_val = Math.floor(100 * t);
                            ctx.fillStyle = `rgba(${g}, ${b_val}, 0, ${0.8 * t})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, r_particle, 0, 2 * Math.PI);
                            ctx.fill();
                        });
                    } else if (b.isSwirl || b.explosive) {
                        ctx.arc(0, 0, b.r, 0, 2 * Math.PI);
                    } else if (b.isIceman) {
                        ctx.moveTo(0, r); ctx.lineTo(r * 0.8, -r * 0.8); ctx.lineTo(-r * 0.8, -r * 0.8);
                    } else {
                        ctx.moveTo(0, -r); ctx.lineTo(r * 0.8, r * 0.8); ctx.lineTo(-r * 0.8, r * 0.8);
                    }

                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                });

                store.lasers.forEach(l => drawLaser(l));
                store.mines.forEach(m => drawMine(m));
                drawJuggernautBombs();
                if (store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(frameTime * 5)})`; ctx.fill(); ctx.restore(); });

                // Draw poison puddles - optimized
                if (store.poisonPuddles) {
                    store.poisonPuddles.forEach(puddle => {
                        const age = (frameTime * 1000 - puddle.created) / 1000;
                        const maxAge = puddle.life + (15 - puddle.life); // Total possible age

                        ctx.save();
                        ctx.translate(puddle.x, puddle.y);

                        // Animate puddle bubbling - cache sin calculation
                        const bubbleOffset = Math.sin(frameTime * 3 + puddle.x * 0.01) * 2;

                        // Create toxic glow effect - cache gradient by radius
                        const glowRadius = puddle.r * 1.5;
                        const radiusKey = Math.round(glowRadius);
                        let gradient = poisonGradientCache.get(radiusKey);
                        if (!gradient) {
                            gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                            gradient.addColorStop(0, 'rgba(124, 252, 0, 1)');
                            gradient.addColorStop(0.7, 'rgba(173, 255, 47, 0.5)');
                            gradient.addColorStop(1, 'rgba(124, 252, 0, 0)');
                            poisonGradientCache.set(radiusKey, gradient);
                        }

                        const glowAlpha = 0.3 * (puddle.life / 15) + 0.2 * Math.sin(frameTime * 4);
                        ctx.globalAlpha = glowAlpha;
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, bubbleOffset, glowRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        // Draw the puddle itself
                        const puddleAlpha = Math.max(0.4, puddle.life / 15);
                        ctx.fillStyle = `rgba(45, 80, 22, ${puddleAlpha})`;
                        ctx.beginPath();
                        ctx.arc(0, bubbleOffset, puddle.r, 0, Math.PI * 2);
                        ctx.fill();

                        // Add surface texture/ripples
                        ctx.strokeStyle = `rgba(124, 252, 0, ${puddleAlpha * 0.8})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            const rippleRadius = puddle.r * (0.3 + i * 0.3) + Math.sin(frameTime * 2 + i) * 3;
                            const rippleAlpha = puddleAlpha * (0.8 - i * 0.2);
                            ctx.globalAlpha = rippleAlpha;
                            ctx.arc(0, bubbleOffset, rippleRadius, 0, Math.PI * 2);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;

                        // Add occasional toxic bubbles - use time-based approach to reduce randomness
                        if (Math.sin(frameTime * 8 + puddle.x * 0.1) > 0.8) {
                            const bubbleX = Math.sin(frameTime * 3 + puddle.x) * puddle.r * 0.3;
                            const bubbleY = Math.cos(frameTime * 2.5 + puddle.y) * puddle.r * 0.3 + bubbleOffset;
                            const bubbleSize = 2 + Math.abs(Math.sin(frameTime * 4 + puddle.x)) * 3;

                            const bubbleAlpha = 0.6 + Math.abs(Math.cos(frameTime * 5 + puddle.y)) * 0.4;
                            ctx.fillStyle = `rgba(124, 252, 0, ${bubbleAlpha})`;
                            ctx.beginPath();
                            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    });
                }

                // Draw mech oil/fuel puddles with aqua color scheme - optimized
                if (store.mechPuddles) {
                    store.mechPuddles.forEach(puddle => {
                        ctx.save();
                        ctx.translate(puddle.x, puddle.y);

                        // Create flickering aqua energy effect - use cached time
                        const flicker = 0.8 + Math.sin(frameTime * 6) * 0.2;
                        const pulseOffset = Math.sin(frameTime * 4 + puddle.x * 0.02) * 1.5;

                        // Calculate shrinking effect as puddle disappears
                        const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
                        const currentRadius = puddle.r * Math.max(0.3, lifePercent); // Shrink to 30% min size

                        // Create aqua hazardous glow effect - cache gradient by radius
                        const glowRadius = currentRadius * 1.4;
                        const radiusKey = Math.round(glowRadius);
                        let gradient = mechGradientCache.get(radiusKey);
                        if (!gradient) {
                            gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                            gradient.addColorStop(0, 'rgba(0, 255, 255, 1)'); // Bright cyan
                            gradient.addColorStop(0.6, 'rgba(32, 178, 170, 0.7)'); // Light sea green
                            gradient.addColorStop(1, 'rgba(0, 139, 139, 0)'); // Dark cyan fade
                            mechGradientCache.set(radiusKey, gradient);
                        }

                        const glowAlpha = 0.4 * lifePercent * flicker;
                        ctx.globalAlpha = glowAlpha;

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, pulseOffset, glowRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw the puddle base (dark aqua/teal liquid) with shrinking
                        const puddleAlpha = Math.max(0.6, lifePercent);
                        ctx.fillStyle = `rgba(14, 75, 92, ${puddleAlpha})`; // Dark aqua blue base
                        ctx.beginPath();
                        ctx.arc(0, pulseOffset, currentRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Add aqua energy surface effects with shrinking
                        ctx.strokeStyle = `rgba(64, 224, 208, ${puddleAlpha * 0.9})`; // Turquoise ripples
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        for (let i = 0; i < 2; i++) {
                            const energyRadius = Math.max(0.1, currentRadius * (0.4 + i * 0.3) + Math.sin(frameTime * 3 + i * 2) * 2);
                            const energyAlpha = puddleAlpha * (0.7 - i * 0.3) * flicker;
                            ctx.globalAlpha = energyAlpha;
                            ctx.arc(0, pulseOffset, energyRadius, 0, Math.PI * 2);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;

                        // Add occasional aqua energy bubbles (only if puddle is large enough)
                        if (currentRadius > 5 && Math.random() < 0.15) {
                            const bubbleX = (Math.random() - 0.5) * currentRadius * 0.8;
                            const bubbleY = (Math.random() - 0.5) * currentRadius * 0.8 + pulseOffset;
                            const bubbleSize = 1 + Math.random() * 2;

                            ctx.fillStyle = `rgba(0, 255, 255, ${0.8 + Math.random() * 0.2})`; // Bright cyan bubbles
                            ctx.beginPath();
                            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    });
                }

                store.enemies.forEach(e => drawEnemy(e));
                drawGibs(ctx); // <-- ADD THIS LINE TO DRAW THE GIBS
                drawTemporalEchoes();
                drawShadowEchoes();
                drawTemporalBeam();
                if (store.boss && store.boss.visible !== false) drawBoss(store.boss);
                store.flameParticles.forEach(p => {
                    if (p.draw) p.draw();
                    else if (p.color) {
                        ctx.save();
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size || 2, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                });
                store.drones.forEach(d => drawDrone(d));
                if (store.shadowHounds) store.shadowHounds.forEach(h => drawShadowHound(h));
                if (store.voidRifts) store.voidRifts.forEach(rift => drawVoidRift(rift));
                store.hounds.forEach(h => drawHound(h));
                const champion = store.playerChampion;
                if (champion && !champion.dead) {
                    const minions = store.championMinions || [];
                    if (minions.length) {
                        ctx.save();
                        minions.forEach(minion => {
                            if (!minion || minion.dead) return;
                            const abilityModule = minion.abilityModule || champion.attackModule || getChampionUpgradeState().attackModule || 'default';
                            const abilityTheme = minion.abilityTheme || getChampionMinionAbilityTheme(abilityModule);
                            const trailColor = abilityTheme?.trail || '#b4c3ff';
                            const ringColor = abilityTheme?.ring || trailColor;
                            const gradient = ctx.createLinearGradient(champion.x, champion.y, minion.x, minion.y);
                            gradient.addColorStop(0, withAlpha(trailColor, 0.55));
                            gradient.addColorStop(1, withAlpha(ringColor, 0.18));
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = 1.4;
                            ctx.globalAlpha = 0.4 + Math.min(0.35, (champion.level || 1) * 0.05);
                            ctx.beginPath();
                            ctx.moveTo(champion.x, champion.y);
                            ctx.lineTo(minion.x, minion.y);
                            ctx.stroke();
                        });
                        ctx.restore();

                        minions.forEach(minion => {
                            if (!minion || minion.dead) return;
                            drawChampionMinion(minion, champion);
                        });
                    }

                    drawPlayerChampion(champion);
                }

                // Draw EMP charges
                if (store.empCharges && store.empCharges.length > 0) {
                    ctx.save();
                    store.empCharges.forEach(charge => {
                        if (!charge || charge.dead) return;
                        
                        const chargeCooldown = EMP_BURST_CONFIG?.chargeCooldown ?? 30;
                        const cooldownRemaining = Math.max(0, charge.cooldown || 0);
                        const cooldownRatio = chargeCooldown > 0 ? Math.min(1, cooldownRemaining / chargeCooldown) : 0;
                        const isRecharging = cooldownRatio > 0;
                        
                        // Draw tether to player - dim significantly when recharging
                        ctx.globalAlpha = isRecharging ? 0.12 : 0.35;
                        const gradient = ctx.createLinearGradient(store.player.x, store.player.y, charge.x, charge.y);
                        if (isRecharging) {
                            gradient.addColorStop(0, 'rgba(60, 80, 120, 0.25)');
                            gradient.addColorStop(1, 'rgba(50, 70, 100, 0.08)');
                        } else {
                            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.4)');
                            gradient.addColorStop(1, 'rgba(150, 220, 255, 0.15)');
                        }
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 1.8;
                        ctx.beginPath();
                        ctx.moveTo(store.player.x, store.player.y);
                        ctx.lineTo(charge.x, charge.y);
                        ctx.stroke();
                    });
                    ctx.restore();

                    store.empCharges.forEach(charge => {
                        if (!charge || charge.dead) return;

                        const chargeCooldown = EMP_BURST_CONFIG?.chargeCooldown ?? 30;
                        const cooldownRemaining = Math.max(0, charge.cooldown || 0);
                        const cooldownRatio = chargeCooldown > 0 ? Math.min(1, cooldownRemaining / chargeCooldown) : 0;
                        const readiness = Math.max(0, 1 - cooldownRatio);

                        const globalCooldown = EMP_BURST_CONFIG?.globalCooldown ?? 0;
                        const globalRemaining = Math.max(0, store.empGlobalCooldown || 0);
                        const globalRatio = globalCooldown > 0 ? Math.min(1, globalRemaining / globalCooldown) : (globalRemaining > 0 ? 1 : 0);
                        const globalFactor = globalRatio > 0 ? Math.max(0.35, 1 - globalRatio * 0.9) : 1;
                        const availability = Math.min(1, readiness * globalFactor);
                        
                        const isRecharging = cooldownRatio > 0;

                        const pulseStrength = isRecharging ? 0.02 : 0.15 * (0.35 + 0.65 * availability);
                        const baseRadius = 8;
                        const pulseScale = 1 + Math.sin(charge.pulsePhase) * pulseStrength;
                        const radius = baseRadius * pulseScale;

                        ctx.save();
                        ctx.translate(charge.x, charge.y);

                        if (isRecharging) {
                            // Deactivated/recharging appearance - very dim and grey
                            ctx.globalAlpha = 0.15;
                            const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2.1);
                            outerGlow.addColorStop(0, 'rgba(60, 80, 120, 0.4)');
                            outerGlow.addColorStop(0.55, 'rgba(50, 70, 100, 0.2)');
                            outerGlow.addColorStop(1, 'rgba(40, 60, 90, 0)');
                            ctx.fillStyle = outerGlow;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius * 2.1, 0, Math.PI * 2);
                            ctx.fill();

                            // Dim grey core when recharging
                            ctx.globalAlpha = 0.25;
                            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                            coreGradient.addColorStop(0, '#8899BB');
                            coreGradient.addColorStop(0.4, '#556688');
                            coreGradient.addColorStop(1, '#334466');
                            ctx.fillStyle = coreGradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Active appearance - bright and pulsing
                            ctx.globalAlpha = 0.18 + 0.42 * availability;
                            const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2.1);
                            outerGlow.addColorStop(0, 'rgba(100, 200, 255, 0.7)');
                            outerGlow.addColorStop(0.55, 'rgba(80, 180, 255, 0.32)');
                            outerGlow.addColorStop(1, 'rgba(60, 160, 255, 0)');
                            ctx.fillStyle = outerGlow;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius * 2.1, 0, Math.PI * 2);
                            ctx.fill();

                            // Core charge brightness tracks readiness
                            ctx.globalAlpha = 0.65 + 0.35 * availability;
                            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                            coreGradient.addColorStop(0, '#FFFFFF');
                            coreGradient.addColorStop(0.4, '#A0E0FF');
                            coreGradient.addColorStop(1, '#4080FF');
                            ctx.fillStyle = coreGradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Cooldown progress ring
                        if (cooldownRatio > 0) {
                            const recoveredRatio = 1 - cooldownRatio;
                            ctx.globalAlpha = 0.8;
                            ctx.strokeStyle = 'rgba(90, 150, 255, 0.85)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius + 3, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * recoveredRatio, false);
                            ctx.stroke();

                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = 'rgba(40, 90, 180, 0.35)';
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.arc(0, 0, radius + 3, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * recoveredRatio, false);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Highlight global cooldown if charge is ready but ability is globally gated
                        if (cooldownRatio === 0 && globalRatio > 0) {
                            ctx.globalAlpha = 0.85;
                            ctx.strokeStyle = 'rgba(255, 180, 80, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([4, 3]);
                            ctx.beginPath();
                            ctx.arc(0, 0, radius + 6, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * (1 - globalRatio), false);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }

                        // Electric arcs remain but fade with availability
                        ctx.globalAlpha = 0.35 + 0.45 * availability;
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            const angle = (charge.pulsePhase * 2 + i * Math.PI * 2 / 3);
                            const arcRadius = radius * 0.6;
                            ctx.beginPath();
                            ctx.arc(0, 0, arcRadius, angle, angle + Math.PI * 0.3);
                            ctx.stroke();
                        }

                        ctx.restore();
                    });
                }

                if (store.iceman) drawIceman(store.iceman);
                drawEscortDrones();
                if (store.beefClone) drawBeefClone(store.beefClone);
                drawShip(store.player.x, store.player.y, store.player);

                // Draw EMP disabled effect on player
                if (store.player.empDisabled) {
                    const sizzleIntensity = 0.5 + 0.5 * Math.sin(frameTime * 15);

                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);

                    // Electric sparks around player
                    ctx.strokeStyle = `rgba(255, 140, 0, ${sizzleIntensity})`;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#FF8C00';
                    ctx.shadowBlur = 8;

                    for (let i = 0; i < 8; i++) {
                        if (Math.random() < 0.7) {
                            const angle = (i / 8) * Math.PI * 2 + frameTime * 5;
                            const radius = store.player.r + 5;
                            const x1 = Math.cos(angle) * radius;
                            const y1 = Math.sin(angle) * radius;
                            const x2 = x1 + (Math.random() - 0.5) * 15;
                            const y2 = y1 + (Math.random() - 0.5) * 15;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }

                    // Purple inner glow
                    ctx.fillStyle = `rgba(138, 43, 226, ${sizzleIntensity * 0.3})`;
                    ctx.shadowColor = '#8A2BE2';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(0, 0, store.player.r * 1.2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Draw poison effect on player
                if (store.player.isPoisoned) {
                    const poisonAlpha = 0.3 + 0.2 * Math.sin(frameTime * 8);

                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = `rgba(0, 255, 0, ${poisonAlpha})`;
                    ctx.beginPath();
                    ctx.arc(store.player.x, store.player.y, store.player.r + 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Add poison particle effect around player
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    for (let i = 0; i < 6; i++) {
                        const angle = frameTime * 2 + i * Math.PI / 3;
                        const x = Math.cos(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
                        const y = Math.sin(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);

                        ctx.fillStyle = `rgba(124, 252, 0, ${0.4 + 0.3 * Math.sin(frameTime * 6 + i)})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 2 + Math.sin(frameTime * 5 + i), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }

                // Draw voidmancer laser beam (Phasestriker only)
                if (store.player.hasVoidLaser && store.player.voidLaserTarget && !store.player.voidLaserTarget.dead) {
                    const p = store.player;
                    const target = p.voidLaserTarget;

                    // Determine laser color based on player ship color
                    let laserColor = '#b266ff'; // Default purple
                    switch (p.subclass) {
                        case 'juggernaut':
                            laserColor = '#ff3333';
                            break;
                        case 'marauder':
                            laserColor = '#33cc33';
                            break;
                        case 'railgunner':
                            laserColor = '#ff6600';
                            break;
                        case 'demolitioner':
                            laserColor = '#ff4500';
                            break;
                        case 'phasestriker':
                            laserColor = '#9900ff';
                            break;
                        case 'stormbringer':
                            laserColor = '#00ccff';
                            break;
                    }

                    const time = performance.now() / 1000;
                    const pulseAlpha = 0.6 + 0.4 * Math.sin(time * 12);

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    // Calculate ramping size for level 2 phasestriker
                    let baseLineWidth = 3;
                    let glowLineWidth = 6;

                    if (p.phasestRikerLevel >= 2) {
                        const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // Same ramp as damage
                        const sizeMultiplier = Math.min(rampMultiplier, 3.0); // Cap at 3x size
                        baseLineWidth *= sizeMultiplier;
                        glowLineWidth *= sizeMultiplier;
                    }

                    // Draw laser beam(s) - double beam for level 4 phasestriker
                    const beamCount = (p.phasestRikerLevel >= 4 && p.doubleBeam) ? 2 : 1;
                    const beamOffsets = beamCount === 2 ? [-8, 8] : [0]; // Parallel beams offset left and right

                    for (let i = 0; i < beamCount; i++) {
                        const offsetX = beamOffsets[i];

                        // Draw main laser beam
                        ctx.strokeStyle = laserColor;
                        ctx.globalAlpha = pulseAlpha;
                        ctx.lineWidth = baseLineWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + offsetX, p.y - 12);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();

                        // Draw laser glow effect - create gradient here
                        const gradient = ctx.createLinearGradient(p.x + offsetX, p.y - 12, target.x, target.y);
                        gradient.addColorStop(0, laserColor + '40');
                        gradient.addColorStop(1, laserColor + '80');

                        ctx.strokeStyle = gradient;
                        ctx.globalAlpha = pulseAlpha * 0.5;
                        ctx.lineWidth = glowLineWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + offsetX, p.y - 12);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();
                    }

                    // Add impact effect at target
                    ctx.fillStyle = laserColor;
                    ctx.globalAlpha = pulseAlpha;
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, 4 + Math.sin(time * 8) * 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Draw wiper lasers (for both Phasestriker and Stormbringer ultimate)
                if (store.player.wiperLasers) {
                    const p = store.player;

                    // Determine laser color based on player ship color
                    let laserColor = '#b266ff'; // Default purple
                    switch (p.subclass) {
                        case 'juggernaut':
                            laserColor = '#ff3333';
                            break;
                        case 'marauder':
                            laserColor = '#33cc33';
                            break;
                        case 'railgunner':
                            laserColor = '#ff6600';
                            break;
                        case 'demolitioner':
                            laserColor = '#ff4500';
                            break;
                        case 'phasestriker':
                            laserColor = '#9900ff';
                            break;
                        case 'stormbringer':
                            laserColor = '#00ccff';
                            break;
                    }

                    const time = performance.now() / 1000;
                    const isSlashing = p.isBlinkSlashing;
                    const basePulseAlpha = 0.8 + 0.2 * Math.sin(time * 10);
                    const pulseAlpha = isSlashing ? basePulseAlpha * 1.3 : basePulseAlpha; // Brighter during slash
                    const laserLength = 180; // Shorter, just long enough to hit boss from safe zone

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    // Draw motion blur trail first (behind main lasers)
                    if (p.wiperLaserBlurTrail && p.wiperLaserBlurTrail.length > 0) {
                        for (const trail of p.wiperLaserBlurTrail) {
                            const trailAlpha = (trail.life / 0.15) * trail.intensity;
                            if (trailAlpha > 0.05) {
                                const trailLasers = [
                                    { angle: trail.angle1, offset: -8 },
                                    { angle: trail.angle2, offset: 8 }
                                ];

                                trailLasers.forEach(trailLaser => {
                                    const trailEndX = p.x + Math.cos(trailLaser.angle) * laserLength;
                                    const trailEndY = p.y + Math.sin(trailLaser.angle) * laserLength;

                                    // Draw blur trail effect
                                    ctx.strokeStyle = laserColor + Math.floor(trailAlpha * 100).toString(16).padStart(2, '0');
                                    ctx.globalAlpha = trailAlpha * 0.6;
                                    ctx.lineWidth = isSlashing ? 8 : 4;
                                    ctx.beginPath();
                                    ctx.moveTo(p.x + trailLaser.offset, p.y - 12);
                                    ctx.lineTo(trailEndX, trailEndY);
                                    ctx.stroke();
                                });
                            }
                        }
                    }

                    // Draw two main wiper lasers
                    const lasers = [
                        { angle: p.wiperLaser1Angle, offset: -8 },
                        { angle: p.wiperLaser2Angle, offset: 8 }
                    ];

                    lasers.forEach(laser => {
                        const endX = p.x + Math.cos(laser.angle) * laserLength;
                        const endY = p.y + Math.sin(laser.angle) * laserLength;

                        // Enhanced visuals during blink slash
                        const coreWidth = isSlashing ? 3 : 2;
                        const mainWidth = isSlashing ? 7 : 5;
                        const glowWidth = isSlashing ? 14 : 10;

                        // Draw lightsaber core (bright white center)
                        ctx.strokeStyle = isSlashing ? '#ffffee' : '#ffffff';
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 1.0 : 0.9);
                        ctx.lineWidth = coreWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw main laser beam (colored)
                        const mainColor = isSlashing ? laserColor + 'ee' : laserColor;
                        ctx.strokeStyle = mainColor;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.9 : 0.8);
                        ctx.lineWidth = mainWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw inner glow
                        const gradient = ctx.createLinearGradient(p.x + laser.offset, p.y - 12, endX, endY);
                        const glowIntensity = isSlashing ? '90' : '80';
                        gradient.addColorStop(0, laserColor + glowIntensity);
                        gradient.addColorStop(0.5, laserColor + (isSlashing ? '70' : '60'));
                        gradient.addColorStop(1, laserColor + (isSlashing ? '40' : '30'));

                        ctx.strokeStyle = gradient;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.7 : 0.6);
                        ctx.lineWidth = glowWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Add outer glow effect
                        const outerGlow = isSlashing ? laserColor + '60' : laserColor + '40';
                        const outerWidth = isSlashing ? 20 : 16;
                        ctx.strokeStyle = outerGlow;
                        ctx.globalAlpha = isSlashing ? 0.5 : 0.4;
                        ctx.lineWidth = outerWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Add sweeping motion trail (skip during slash mode - we have blur trail instead)
                        if (!isSlashing) {
                            const trailAngle = laser.angle - (p.wiperLaserSpeed * 0.3);
                            const trailEndX = p.x + Math.cos(trailAngle) * laserLength * 0.8;
                            const trailEndY = p.y + Math.sin(trailAngle) * laserLength * 0.8;

                            ctx.strokeStyle = laserColor + '20';
                            ctx.globalAlpha = 0.2;
                            ctx.lineWidth = 8;
                            ctx.beginPath();
                            ctx.moveTo(p.x + laser.offset, p.y - 12);
                            ctx.lineTo(trailEndX, trailEndY);
                            ctx.stroke();
                        }

                        // Add polished circular cap at the end of the laser
                        const capRadius = isSlashing ? 10 : 8;

                        // Bright glowing core of the cap
                        ctx.fillStyle = isSlashing ? '#ffffee' : '#ffffff';
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 1.0 : 0.9);
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Main colored cap
                        ctx.fillStyle = isSlashing ? laserColor + 'ee' : laserColor;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.9 : 0.8);
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius * 0.7, 0, Math.PI * 2);
                        ctx.fill();

                        // Outer glow cap
                        const capGradient = ctx.createRadialGradient(endX, endY, 0, endX, endY, capRadius);
                        const capGlowIntensity = isSlashing ? '90' : '80';
                        capGradient.addColorStop(0, laserColor + capGlowIntensity);
                        capGradient.addColorStop(0.5, laserColor + (isSlashing ? '70' : '60'));
                        capGradient.addColorStop(1, laserColor + (isSlashing ? '30' : '20'));

                        ctx.fillStyle = capGradient;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.7 : 0.6);
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Pulsing rim effect
                        const rimIntensity = isSlashing ? '60' : '40';
                        ctx.strokeStyle = laserColor + rimIntensity;
                        const rimPulse = isSlashing ? 0.5 + 0.4 * Math.sin(time * 20) : 0.4 + 0.3 * Math.sin(time * 15);
                        ctx.globalAlpha = rimPulse;
                        ctx.lineWidth = isSlashing ? 3 : 2;
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius * (isSlashing ? 1.3 : 1.2), 0, Math.PI * 2);
                        ctx.stroke();
                    });

                    ctx.restore();
                }


                closeBullets.forEach(item => {
                    const b = item.bullet;
                    const dist = item.dist;

                    // Apply fade-in for Death Engine bullet rain
                    let fadeAlpha = 1.0;
                    if (b.fadeInTime && b.spawnTime) {
                        const timeAlive = (performance.now() - b.spawnTime) / 1000;
                        fadeAlpha = Math.min(1.0, timeAlive / b.fadeInTime);
                    }

                    const proxFactor = 1.0 - (dist / proximityThreshold);

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = proxFactor * fadeAlpha;
                    const glowRadius = b.r * 2;
                    const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
                    gradient.addColorStop(0.3, b.col);
                    gradient.addColorStop(1, b.col + '00');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    ctx.save();
                    ctx.globalAlpha = fadeAlpha;
                    ctx.fillStyle = b.col;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = `rgba(255, 255, 255, ${proxFactor * 0.8 * fadeAlpha})`;
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                store.activeEffects.forEach(e => e.draw && e.draw());
                renderVoidStepSystems(ctx);
                renderImpactSystem(ctx);



                // Throttle HUD updates to avoid layout thrashing on every frame
                if (!window.lastHudUpdate || Date.now() - window.lastHudUpdate > 16) { // ~60fps
                    updateHUD();
                    window.lastHudUpdate = Date.now();
                }
            }

            function takeDamage(dmg) {
                if (store.player.isInvincible || playerIsInvulnerable()) return;
                // Removed boss invincibility check here - that was preventing ALL damage incorrectly

                if (store.player.hasShieldBubble) {
                    store.player.hasShieldBubble = false;
                    store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
                    return;
                }
                const p = store.player;

                // Beef shield takes damage first if pilot is beef
                if (p.pilotGenome === 'beef' && p.beefShield > 0 && p.beefShieldCooldown <= 0) {
                    const beefAbsorbed = Math.min(p.beefShield, dmg);
                    p.beefShield -= beefAbsorbed;
                    dmg -= beefAbsorbed;
                    p.beefShieldDamageTaken += beefAbsorbed;

                    // Reset shield recharge delay when beef shield takes damage
                    if (beefAbsorbed > 0) {
                        p.shieldRechargeDelay = p.shieldRechargeDelayMax;
                        p.shieldRecharging = false;
                    }

                    // If beef shield was depleted, start cooldown
                    if (p.beefShield <= 0) {
                        p.beefShieldCooldown = 2.0; // 2 second cooldown before shield can absorb again
                    }

                    if (dmg <= 0) return; // All damage absorbed by beef shield
                }

                const a = Math.min(p.shield, dmg);
                if (a < dmg) playSound('hit');
                p.shield -= a;
                dmg -= a;

                // Reset shield recharge delay whenever any damage is taken
                if (a > 0 || dmg > 0) {
                    p.shieldRechargeDelay = p.shieldRechargeDelayMax;
                    p.shieldRecharging = false;
                }

                // Old nano save logic removed - now handled in main game loop before death
                p.hp -= dmg;

                if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
                    store.world.lowHealthTutorialShown = true;
                    showShopWithHighlight();
                }
            }

            function resetBeefShieldState(player) {
                if (!player) return;
                if (player.beefShield || player.beefShieldDamageDealt || player.beefShieldDamageTaken || player.beefShieldCooldown) {
                    player.beefShield = 0;
                    player.beefShieldDamageDealt = 0;
                    player.beefShieldDamageTaken = 0;
                    player.beefShieldCooldown = 0;
                }
            }

            function updateBeefShield() {
                const p = store.player;
                if (!p) return;

                if (p.pilotGenome !== 'beef') {
                    resetBeefShieldState(p);
                    return;
                }

                const damageDealt = p.beefShieldDamageDealt;
                const damageTaken = p.beefShieldDamageTaken;

                // Skip if no damage events
                if (damageDealt === 0 && damageTaken === 0) return;

                // Update cooldown
                if (p.beefShieldCooldown > 0) {
                    p.beefShieldCooldown -= 0.016; // Decrease by ~1/60 (assuming 60 FPS)
                    if (p.beefShieldCooldown < 0) p.beefShieldCooldown = 0;
                }

                // Growth rate: 1 shield per 50 damage dealt, shrinkage rate: 1 shield per 30 damage taken
                // Made more responsive for better gameplay feel
                const shieldChange = (damageDealt * 0.02) - (damageTaken * 0.033);

                if (shieldChange > 0) {
                    // Shield grows
                    p.beefShield = Math.min(p.beefShieldMax, p.beefShield + shieldChange);
                } else if (shieldChange < 0) {
                    // Shield shrinks (but not below 0)
                    p.beefShield = Math.max(0, p.beefShield + shieldChange);
                }

                // Reset damage tracking counters
                p.beefShieldDamageDealt = 0;
                p.beefShieldDamageTaken = 0;


            }

            function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
            function announce(text) { const el = q('announce'); el.textContent = text; el.classList.remove('hide'); clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); }
            function updateHUD() {
                const player = store.player;
                if (!player) return;

                const pilotTitle = q("pilotTitle");
                const scoreNum = q("scoreNum");
                const goldNum = q("goldNum");
                const hpBarFill = q("hpBarFill");
                const hpText = q("hpText");
                const beefShieldBar = q("beefShieldBar");
                const beefShieldBarFill = q("beefShieldBarFill");
                const beefShieldText = q("beefShieldText");
                const shieldBar = q("shieldBar");
                const shieldBarFill = q("shieldBarFill");
                const shieldTextEl = q("shieldText");
                const waveNum = q("waveNum");
                const killsNum = q("killsNum");
                const levelNum = q("levelNum");
                const bossContent = q("hudBossContent");
                const bossTitle = q("bossTitle");
                const bossBarFill = q("bossBarFill");
                const powerupEl = q("hudPowerup");
                const powerupList = q("powerupList");
                const equipEl = q("hudEquipment");
                const equipmentList = q("equipmentList");
                const grenadeBtn = q('grenadeBtnUI');
                const fpsEl = q('fps');

                if (!pilotTitle || !scoreNum || !goldNum || !hpBarFill || !hpText || !shieldBar || !shieldBarFill || !shieldTextEl) {
                    if (!store._hudInitWarned && typeof console !== 'undefined') {
                        console.warn('[HUD] Elements missing, skipping update until UI is ready.');
                        store._hudInitWarned = true;
                    }
                    return;
                }
                store._hudInitWarned = false;

                const hpPercent = Math.round((player.hp / player.hpMax) * 100);
                const shieldPercent = player.shieldMax > 0 ? Math.round((player.shield / player.shieldMax) * 100) : 0;
                const beefShieldPercent = player.pilotGenome === 'beef' && player.beefShieldMax > 0 ? Math.round((player.beefShield / player.beefShieldMax) * 100) : 0;

                pilotTitle.textContent = store.name ? `â—¢ ${store.name} â—£` : "â—¢ UNIDENTIFIED â—£";
                scoreNum.textContent = store.world.score;
                const worldGold = getWorldGold();
                goldNum.textContent = worldGold;
                const mechForgeBtn = q('shopBtn');
                if (mechForgeBtn) {
                    const label = store.world.autoForgeEnabled ? 'UPGRADE HANGAR (AUTO)' : 'UPGRADE HANGAR';
                    if (mechForgeBtn.textContent !== label) {
                        mechForgeBtn.textContent = label;
                    }
                }
                const nextForgePrompt = store.world.nextMechForgePrompt ?? 135;
                if (worldGold >= nextForgePrompt && !store.world.mechForgePromptActive) {
                    triggerMechForgeGoldMilestone();
                }

                hpBarFill.style.width = `${hpPercent}%`;
                hpText.textContent = `HP: ${Math.round(player.hp)} / ${player.hpMax}`;

                if (beefShieldBar && beefShieldText && beefShieldBarFill) {
                    if (player.pilotGenome === 'beef' && player.beefShieldMax > 0) {
                        beefShieldBar.style.display = "block";
                        beefShieldBarFill.style.width = `${beefShieldPercent}%`;
                        beefShieldText.textContent = `BEEF SHIELD: ${Math.round(player.beefShield)} / ${player.beefShieldMax}`;
                    } else {
                        beefShieldBar.style.display = "none";
                        beefShieldText.textContent = "";
                    }
                }

                shieldBar.style.display = "block";
                shieldBarFill.style.width = `${shieldPercent}%`;
                shieldTextEl.textContent = player.shieldMax > 0
                    ? `SHIELD: ${Math.round(player.shield)} / ${player.shieldMax}`
                    : 'SHIELD: 0 / 0';

                if (waveNum) waveNum.textContent = store.world.wave;
                if (killsNum) killsNum.textContent = store.world.kills;
                if (levelNum) levelNum.textContent = store.world.level;

                if (bossContent && bossTitle && bossBarFill) {
                    if (store.boss) {
                        bossContent.classList.remove("hide");
                        bossTitle.textContent = `âš¡ ${store.boss.name} âš¡`;
                        bossBarFill.style.width = `${Math.round((store.boss.hp / store.boss.hpMax) * 100)}%`;
                    } else {
                        bossContent.classList.add("hide");
                    }
                }

                if (powerupEl && powerupList) {
                    const timedPowerups = Object.keys(player.powerupTimers || {});
                    if (timedPowerups.length > 0) {
                        let timedContent = '';
                        timedPowerups.forEach(key => {
                            const timer = player.powerupTimers[key];
                            if (!timer || !POWERUP_TYPES[key]) return;
                            const percent = Math.round((timer.remaining / timer.max) * 100);
                            timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`;
                        });
                        powerupList.innerHTML = timedContent;
                        powerupEl.classList.remove('hide');
                    } else {
                        powerupEl.classList.add('hide');
                    }
                }

                if (equipEl && equipmentList) {
                    const hasEquipment = player.hasLauncher || player.hasHounds || player.nanoSaves > 0;
                    if (hasEquipment) {
                        let content = '';
                        if (player.nanoSaves > 0) content += `<div>NANO SAVE [${player.nanoSaves}]</div>`;
                        if (player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`;
                        if (player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`;
                        equipmentList.innerHTML = content;
                        equipEl.classList.remove('hide');
                    } else {
                        equipEl.classList.add('hide');
                    }
                }

                // EMP charges now orbit automatically, no button needed
                if (grenadeBtn) {
                    grenadeBtn.classList.add('hide');
                }

                if (!store.fpsLastTime) {
                    store.fpsLastTime = performance.now();
                    store.fpsFrameCount = 0;
                }
                store.fpsFrameCount++;
                const now = performance.now();
                if (fpsEl && now - store.fpsLastTime >= 1000) {
                    const fps = Math.round((store.fpsFrameCount * 1000) / (now - store.fpsLastTime));
                    fpsEl.textContent = fps;

                    // COMMENTED OUT: Enhanced collar display with better feedback
                    /*
                    const collarStacks = sanitizeCollarStacks();
                    const collarBonus = calculateCollarBonus(collarStacks);
                    const collarPercent = (collarBonus - 1) * 100;
                    const collarStatus = collarStacks === 0 ? 'LOOSE' : 
                                        collarStacks < 25 ? 'CRUSHING' : 'MAXIMUM';
                    q('collar').textContent = `${collarStacks.toFixed(1)} (${collarPercent.toFixed(0)}%) ${collarStatus}`;
                    */

                    // COMMENTED OUT: Calculate damage per bullet and average enemy HP
                    /*
                    const baseDamage = 15; // Updated from 20 to 15 (75% of original)
                    const actualDamage = baseDamage * store.player.dmgMult;
                    q('damagePerBullet').textContent = `${actualDamage.toFixed(1)}`;
                    
                    // Calculate average enemy HP across all enemy types
                    const enemyTypes = [
                    ];
                    const avgBaseHp = enemyTypes.reduce((sum, type) => sum + type.hp, 0) / enemyTypes.length;
                    const waveMultiplier = Math.pow(1.03, store.world.wave - 1);
                    const avgCurrentHp = avgBaseHp * waveMultiplier * collarBonus;
                    q('avgEnemyHp').textContent = `${avgCurrentHp.toFixed(0)}`;
                    */

                    const spawnDebugEl = q('spawnDebug');
                    if (spawnDebugEl) {
                        // Spawn debug info can stay if needed for development
                    }

                    store.fpsFrameCount = 0;
                    store.fpsLastTime = now;

                    // COMMENTED OUT: Update health table
                    /*
                    if (store.enemies.length > 0) {
                        const enemy = store.enemies[0]; // Get first enemy for reference
                        q('enemyCurrentHp').textContent = Math.round(enemy.hp);
                    } else {
                        q('enemyCurrentHp').textContent = '0';
                    }
                    if (store.boss) {
                        q('bossCurrentHp').textContent = Math.round(store.boss.hp);
                        q('bossBaseHp').textContent = Math.round(store.boss.hpMax);
                    } else {
                        q('bossCurrentHp').textContent = '0';
                        q('bossBaseHp').textContent = '0';
                    }
                    */
                }
            }
            function normalizeLeaderboardEntries(source) {
                if (!source) return null;

                if (Array.isArray(source)) {
                    return source;
                }

                if (Array.isArray(source.entries)) {
                    return source.entries;
                }

                if (Array.isArray(source.top50)) {
                    return source.top50;
                }

                if (Array.isArray(source.top10)) {
                    return source.top10;
                }

                if (source.top50 && Array.isArray(source.top50.entries)) {
                    return source.top50.entries;
                }

                if (source.top10 && Array.isArray(source.top10.entries)) {
                    return source.top10.entries;
                }

                if (Array.isArray(source.data)) {
                    return source.data;
                }

                if (source.data && Array.isArray(source.data.entries)) {
                    return source.data.entries;
                }

                return null;
            }

            function updateLeaderboard(leaderboardData) {
                const fallbackData = [
                    { name: "ACE PILOT", score: 50000, waves: 10 },
                    { name: "VOID RUNNER", score: 35000, waves: 8 },
                    { name: "STAR HUNTER", score: 25000, waves: 6 },
                    { name: "NOVA STRIKER", score: 18000, waves: 5 },
                    { name: "COSMIC GUARD", score: 12000, waves: 4 }
                ];

                const entries = normalizeLeaderboardEntries(leaderboardData) ?? fallbackData;

                if (entries === fallbackData && leaderboardData) {
                    console.warn("Leaderboard payload had unexpected shape, using fallback:", leaderboardData);
                }

                const safeEntries = entries.filter(entry => entry && typeof entry === "object");

                const listHtml = safeEntries.map(s => `<li>${escapeHtml(s.name ?? "UNKNOWN PILOT")} â€” ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");
                const popupHtml = safeEntries.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name ?? "UNKNOWN PILOT")} â€” ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");

                const hsList = q("hsList");
                const hsListPopup = q("hsListPopup");
                if (hsList) hsList.innerHTML = listHtml;
                if (hsListPopup) hsListPopup.innerHTML = popupHtml;
            }

            async function refreshScoreList() {
                try {
                    const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 });
                    if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    const data = await res.json();
                    // data.entries contains up to 50 players
                    updateLeaderboard(data);
                } catch (err) {
                    console.warn("Failed to fetch leaderboard, using offline data:", err.message);
                    updateLeaderboard(null);
                }
            }
            async function addScore(score) {
                if (store.cheatsUsed) {
                    announce("Score not submitted: Cheats used");
                    return;
                }
                const name = (store.name || "ROGUE").slice(0, 16);
                try {
                    const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 });
                    if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`);
                    const { nonce } = await nonceRes.json();
                    const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce };
                    const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 });
                    if (!res.ok) throw new Error(`Submit failed: ${res.status}`);
                    const data = await res.json();
                    if (data.ok) {
                        updateLeaderboard(data);
                    } else {
                        console.warn("Score rejected:", data.err);
                        announce(`Score rejected: ${data.err}`);
                        refreshScoreList();
                    }
                } catch (err) {
                    console.warn("Score submission failed, game continues offline:", err.message);
                }
            }
            function fireBullet(x, y, vx, vy, props = {}) {
                const p = store.player;
                const swirlFlag = props.isSwirl !== undefined ? props.isSwirl : !!p.swirlShots;
                return spawnBullet({
                    x, y, vx, vy,
                    r: p.explosive ? 5 : 3,
                    col: p.explosive ? "#ED2F32" : "#b266ff",
                    dmg: 15 * p.dmgMult,
                    pierce: p.piercing,
                    explosive: p.explosive,
                    ...props,
                    isSwirl: swirlFlag
                });
            }
            function fireIcemanShot() {
                const p = store.player;
                if (!p.hasIceman) {
                    console.warn('fireIcemanShot called but hasIceman is false');
                    return;
                }
                if (!store.iceman) {
                    console.error('fireIcemanShot called but store.iceman is missing!');
                    return;
                }
                
                const icemanLevel = store.iceman.level || 1;
                const icemanDamageMult = icemanLevel >= 3 ? 1.5 : 1.0; // Level 3: +50% damage
                
                const baseBulletSpeed = 420;
                const bulletSpeed = baseBulletSpeed + 50 * (p.bulletSpeedLvl || 0);
                const totalMultishot = 1 + (p.multiShot || 0) + (p.multishotReward || 0);
                const angleSpread = totalMultishot > 1 ? 12 : 0;
                
                console.log(`Iceman firing ${totalMultishot} shots from (${store.iceman.x}, ${store.iceman.y}), level ${icemanLevel}`);
                
                for (let i = 0; i < totalMultishot; i++) {
                    const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                    const bullet = spawnBullet({
                        x: store.iceman.x + 10 * Math.sin(angle),
                        y: store.iceman.y - 12,
                        vx: Math.sin(angle) * bulletSpeed,
                        vy: -Math.cos(angle) * bulletSpeed,
                        r: p.explosive ? 5 : 3,
                        col: "#66aaff",
                        dmg: 15 * (p.dmgMult || 1) * 0.35 * icemanDamageMult,
                        pierce: p.piercing || false,
                        explosive: p.explosive || false,
                        isIceman: true,
                        isSwirl: p.swirlShots || false
                    });
                    console.log('Iceman bullet spawned:', bullet);
                }
            }
            function getOmegaMultishotColor(type) {
                switch (type) {
                    case 'marauder_burst': return '#ff6b35'; // Fiery orange
                    case 'juggernaut_hammer': return '#ffd700'; // Golden
                    case 'railgunner_lance': return '#00ffff'; // Cyan
                    case 'demolitioner_nova': return '#ff1744'; // Explosive red
                    case 'phasestriker_void': return '#9c27b0'; // Void purple
                    case 'stormbringer_storm': return '#00bfff'; // Electric blue
                    default: return '#ffffff';
                }
            }
            
            function triggerOmegaMultishotExplosion(bullet, enemy) {
                if (!bullet.isOmegaShot || !bullet.omegaType) return;
                
                const p = store.player;
                const explosionRadius = 90;
                const radiusSq = explosionRadius * explosionRadius;
                
                // Create visual effect
                store.activeEffects.push(createEffect('omegaExplosion', bullet.x, bullet.y, explosionRadius, {
                    color: getOmegaMultishotColor(bullet.omegaType),
                    omegaType: bullet.omegaType
                }));
                
                // Apply AOE damage based on omega type
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                targets.forEach(e => {
                    if (!e || e.dead || e === enemy) return; // Skip the primary target (already hit)
                    const dx = e.x - bullet.x;
                    const dy = e.y - bullet.y;
                    const distSq = dx * dx + dy * dy;
                    
                    if (distSq <= radiusSq) {
                        const aoeDamage = bullet.dmg * 0.7; // 70% damage to nearby enemies
                        const isBoss = e === store.boss;
                        
                        if (isBoss) {
                            applyBossDamage(e, aoeDamage, { point: { x: e.x, y: e.y } });
                        } else {
                            e.hp -= aoeDamage;
                            store.world.totalDamage += aoeDamage;
                        }
                        
                        // Add special effects based on omega type
                        switch (bullet.omegaType) {
                            case 'marauder_burst':
                                e.jugBurnTimer = Math.max(e.jugBurnTimer || 0, 2);
                                break;
                            case 'juggernaut_hammer':
                                e.stunTimer = Math.max(e.stunTimer || 0, 0.8);
                                e.hitSlowFactor = 0.5;
                                e.hitSlowTimer = 1.2;
                                break;
                            case 'railgunner_lance':
                                // Pierce effect - already handled by pierce property
                                break;
                            case 'demolitioner_nova':
                                // Chain explosion - trigger smaller explosions
                                if (Math.random() < 0.4) {
                                    store.activeEffects.push(createEffect('explosion', e.x, e.y, 35));
                                }
                                break;
                            case 'phasestriker_void':
                                e.phaseLockTimer = Math.max(e.phaseLockTimer || 0, 1.5);
                                e.phaseLockSlowFactor = 0.4;
                                break;
                            case 'stormbringer_storm':
                                e.stormShockTimer = Math.max(e.stormShockTimer || 0, 1.8);
                                e.stormShockIntensity = 0.8;
                                break;
                        }
                        
                        store.activeEffects.push(createEffect('hitSpark', e.x, e.y, e.r || 16));
                    }
                });
                
                playSound('explosion');
            }
            
            function firePlayer() {
                const p = store.player;
                if (p.beefChargeState && p.beefChargeState !== 'ready') return;
                
                // OMEGA MULTISHOT: Transform regular multishot into special AOE projectiles
                if (p.hasOmegaMultishot && p.omegaMultishotType) {
                    const baseBulletSpeed = 380;
                    const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0);
                    // Combine shots: fire fewer but more powerful projectiles
                    const orbCount = Math.max(1, Math.ceil(totalMultishot / 3)); // Combine 3 shots into 1 orb
                    const angleSpread = 12;
                    
                    for (let i = 0; i < orbCount; i++) {
                        const angle = (i - (orbCount - 1) / 2) * angleSpread * Math.PI / 180;
                        const damagePerShot = 15 * p.dmgMult;
                        const combinedDamage = damagePerShot * Math.floor(totalMultishot / orbCount) * 1.3; // 30% bonus for omega
                        
                        spawnBullet({
                            x: p.x + 12 * Math.sin(angle),
                            y: p.y - 12,
                            vx: Math.sin(angle) * baseBulletSpeed,
                            vy: -Math.cos(angle) * baseBulletSpeed,
                            r: 8, // Larger projectile
                            col: getOmegaMultishotColor(p.omegaMultishotType),
                            dmg: combinedDamage,
                            pierce: p.piercing,
                            explosive: false, // Handled by omega explosion
                            isSwirl: false,
                            isOmegaShot: true,
                            omegaType: p.omegaMultishotType
                        });
                    }
                    return;
                }
                
                // NORMAL MULTISHOT
                const baseBulletSpeed = 420;
                const bulletSpeed = baseBulletSpeed;
                const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0);
                const angleSpread = 10;
                for (let i = 0; i < totalMultishot; i++) {
                    const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                    spawnBullet({
                        x: p.x + 10 * Math.sin(angle),
                        y: p.y - 12,
                        vx: Math.sin(angle) * bulletSpeed,
                        vy: -Math.cos(angle) * bulletSpeed,
                        r: p.explosive ? 5 : 3,
                        col: p.explosive ? "#cc99ff" : "#b266ff",
                        dmg: 15 * p.dmgMult,
                        pierce: p.piercing,
                        explosive: p.explosive,
                        isSwirl: p.swirlShots
                    });
                }
                if (p.hasBeefClone && store.beefClone && store.beefClone.mode !== 'juggernaut_bomber') {
                    for (let i = 0; i < totalMultishot; i++) {
                        const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                        spawnBullet({
                            x: store.beefClone.x + 10 * Math.sin(angle),
                            y: store.beefClone.y - 12,
                            vx: Math.sin(angle) * bulletSpeed,
                            vy: -Math.cos(angle) * bulletSpeed,
                            r: p.explosive ? 5 : 3,
                            col: "#66ff66", // Green color for beef clone
                            dmg: 15 * p.dmgMult * 0.35,
                            pierce: p.piercing,
                            explosive: p.explosive,
                            isBeefClone: true,
                            isSwirl: p.swirlShots
                        });
                    }
                }
                if (p.rearMultishot > 0) {
                    const rearAngleSpread = 15;
                    for (let i = 0; i < p.rearMultishot; i++) {
                        const angle = (i - (p.rearMultishot - 1) / 2) * rearAngleSpread;
                        const radAngle = angle * Math.PI / 180;
                        spawnBullet({
                            x: p.x + 10 * Math.sin(radAngle),
                            y: p.y + 12,
                            vx: Math.sin(radAngle) * bulletSpeed,
                            vy: Math.cos(radAngle) * bulletSpeed,
                            r: 3,
                            col: "#ffddff",
                            dmg: 11.25 * p.dmgMult,
                            pierce: p.piercing > 0 ? p.piercing - 1 : 0,
                            isSwirl: p.swirlShots
                        });
                    }
                }
                store.drones.forEach(drone => spawnBullet({
                    x: p.x + drone.offset,
                    y: p.y + 20,
                    vx: 0,
                    vy: -bulletSpeed,
                    r: 3,
                    col: "#66aaff",
                    dmg: 15 * p.dmgMult * 0.4,
                    isDrone: true,
                    isSwirl: p.swirlShots
                }));
                if (p.hasLauncher) {
                    const speed = 350;
                    const isMini = p.miniAbilities && p.miniAbilities.has('launcher');
                    const fragmentRadius = isMini ? 2.5 : 4; // Mini fragments are smaller
                    const numPairs = store.player.upgradeLevels.launcher || 1;
                    for (let i = 0; i < numPairs; i++) {
                        const spread = 15 + i * 10;
                        const vx_offset = 50 + i * 20;
                        spawnBullet({ x: p.x - spread, y: p.y, vx: -vx_offset, vy: -speed, r: fragmentRadius, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                        spawnBullet({ x: p.x + spread, y: p.y, vx: vx_offset, vy: -speed, r: fragmentRadius, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                        if (p.hasIceman && store.iceman) {
                            spawnBullet({ x: store.iceman.x - spread, y: store.iceman.y, vx: -vx_offset, vy: -speed, r: fragmentRadius, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                            spawnBullet({ x: store.iceman.x + spread, y: store.iceman.y, vx: vx_offset, vy: -speed, r: fragmentRadius, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                        }
                        if (p.hasBeefClone && store.beefClone && store.beefClone.mode !== 'juggernaut_bomber') {
                            spawnBullet({ x: store.beefClone.x - spread, y: store.beefClone.y, vx: -vx_offset, vy: -speed, r: fragmentRadius, col: '#66ff66', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isBeefClone: true });
                            spawnBullet({ x: store.beefClone.x + spread, y: store.beefClone.y, vx: vx_offset, vy: -speed, r: 4, col: '#66ff66', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isBeefClone: true });
                        }
                    }
                }
            }

            function fireFlamethrower() {
                const p = store.player;
                if (p.beefChargeState && p.beefChargeState !== 'ready') return;

                let numFlames, angleRange, speed, life;
                switch (p.flamethrowerLevel) {
                    case 1: numFlames = 4; angleRange = 40; speed = 250; life = 0.35; break;    // Halved from 8
                    case 2: numFlames = 6; angleRange = 70; speed = 280; life = 0.4; break;     // Halved from 12
                    default: numFlames = 8; angleRange = 90; speed = 320; life = 0.5; break;    // Halved from 16
                }

                for (let i = 0; i < numFlames; i++) {
                    const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                    const currentSpeed = speed + Math.random() * 40;
                    const sideOffset = (i % 2 === 0) ? -15 : 15;
                    const spawnX = p.x + sideOffset;
                    const spawnY = p.y + 5;
                    spawnBullet({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 3, col: `rgba(255, ${60 + Math.random() * 60}, 0, 0.9)`, dmg: 2 * p.dmgMult, life: life * 1.5, isFlame: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
                }

                if (p.hasIceman && store.iceman) {
                    for (let i = 0; i < numFlames; i++) {
                        const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                        const currentSpeed = speed + Math.random() * 40;
                        const sideOffset = (i % 2 === 0) ? -15 : 15;
                        const spawnX = store.iceman.x + sideOffset;
                        const spawnY = store.iceman.y + 5;
                        spawnBullet({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 2, col: `rgba(100, 150, 255, 0.7)`, dmg: 2 * p.dmgMult * 0.35, life: life, isFlame: true, isIceman: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
                    }
                }
            }

            function launchStarProjectile(originX, originY, angle, options = {}) {
                const speedMultiplier = options.speedMultiplier ?? 1;
                const projectile = {
                    x: originX,
                    y: originY,
                    vx: Math.sin(angle) * STAR_CANNON_SPEED * speedMultiplier,
                    vy: -Math.cos(angle) * STAR_CANNON_SPEED * speedMultiplier,
                    size: STAR_CANNON_SIZE,
                    rotation: 0,
                    trail: [],
                    maxTrailLength: 28,
                    hitIds: new Set(),
                    damageScale: options.damageScale ?? 1,
                    isIceman: options.isIceman || false,
                    hitboxScale: options.hitboxScale ?? STAR_CANNON_HITBOX_SCALE,
                    trailColor: options.trailColor || null,
                    primaryColor: options.primaryColor || null,
                    coreColor: options.coreColor || null,
                    shadowColor: options.shadowColor || null,
                    isEnemy: options.isEnemy || false,
                    enemyDamage: options.enemyDamage ?? 0
                };
                store.starProjectiles.push(projectile);
            }

            function fireStarCannon() {
                const p = store.player;
                const level = p.starCannonLevel || 0;
                if (level <= 0) return;

                const alternating = level >= 2;
                const bursts = Math.max(1, getStarCannonBurstCount(level));
                const delayStep = Math.max(0.08, STAR_CANNON_ALTERNATE_DELAY - 0.01 * Math.max(0, level - 2));
                let nextSide = alternating ? (p.starCannonNextSide || 'left') : 'left';
                const speedMultiplier = 1 + Math.min(0.25, Math.max(0, level - 1) * 0.015);

                for (let i = 0; i < bursts; i++) {
                    store.pendingStarSalvos.push({
                        delay: i * delayStep,
                        side: nextSide,
                        damageScale: 1,
                        speedMultiplier,
                        playSound: i === 0,
                        sourceLevel: level
                    });

                    if (alternating) {
                        nextSide = nextSide === 'left' ? 'right' : 'left';
                    }
                }

                p.starCannonNextSide = alternating ? nextSide : 'left';
            }

            function updateStarProjectiles(dt) {
                if (store.pendingStarSalvos.length) {
                    const p = store.player;
                    const originY = p.y - 12;
                    const lateralOffset = 26;
                    for (let i = store.pendingStarSalvos.length - 1; i >= 0; i--) {
                        const salvo = store.pendingStarSalvos[i];
                        salvo.delay -= dt;
                        if (salvo.delay <= 0) {
                            const isRight = salvo.side === 'right';
                            const offset = isRight ? lateralOffset : -lateralOffset;
                            const angle = isRight ? Math.PI / 6 : -Math.PI / 6;
                            const originX = p.x + offset;
                            launchStarProjectile(originX, originY, angle, {
                                hitboxScale: STAR_CANNON_HITBOX_SCALE,
                                damageScale: salvo.damageScale,
                                speedMultiplier: salvo.speedMultiplier
                            });
                            if (salvo.playSound) {
                                playSound('stargun');
                            }

                            if (p.starCannonIcemanSupport && p.hasIceman && store.iceman) {
                                store.pendingStarClones.push({
                                    delay: STAR_CANNON_CLONE_DELAY,
                                    originX: store.iceman.x + offset,
                                    originY: store.iceman.y - 12,
                                    angle,
                                    damageScale: STAR_CANNON_ICEMAN_DAMAGE_SCALE,
                                    playSound: salvo.playSound
                                });
                            }

                            if (p.starCannonIcemanSupport && p.hasBeefClone && store.beefClone && store.beefClone.mode !== 'juggernaut_bomber') {
                                store.pendingStarClones.push({
                                    delay: STAR_CANNON_CLONE_DELAY,
                                    originX: store.beefClone.x + offset,
                                    originY: store.beefClone.y - 12,
                                    angle,
                                    damageScale: STAR_CANNON_ICEMAN_DAMAGE_SCALE,
                                    playSound: salvo.playSound
                                });
                            }

                            store.pendingStarSalvos.splice(i, 1);
                        }
                    }
                }

                if (store.pendingStarClones.length) {
                    for (let i = store.pendingStarClones.length - 1; i >= 0; i--) {
                        const pending = store.pendingStarClones[i];
                        pending.delay -= dt;
                        if (pending.delay <= 0) {
                            launchStarProjectile(pending.originX, pending.originY, pending.angle, {
                                damageScale: pending.damageScale,
                                isIceman: true,
                                hitboxScale: STAR_CANNON_HITBOX_SCALE
                            });
                            if (pending.playSound) {
                                playSound('stargun');
                            }
                            store.pendingStarClones.splice(i, 1);
                        }
                    }
                }

                if (!store.starProjectiles.length) return;
                const p = store.player;
                const baseDamage = STAR_CANNON_DAMAGE * p.dmgMult;
                const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;

                for (let i = store.starProjectiles.length - 1; i >= 0; i--) {
                    const star = store.starProjectiles[i];
                    star.x += star.vx * dt;
                    star.y += star.vy * dt;
                    star.rotation += dt * 2.4;

                    star.trail.push({ x: star.x, y: star.y, life: 1, size: star.size * 0.55 });
                    if (star.trail.length > star.maxTrailLength) star.trail.shift();
                    for (let t = star.trail.length - 1; t >= 0; t--) {
                        const particle = star.trail[t];
                        particle.life -= dt * 2.6;
                        particle.size *= 1 - dt * 1.6;
                        if (particle.life <= 0 || particle.size <= 0.2) star.trail.splice(t, 1);
                    }

                    const hitRadius = star.size * (star.hitboxScale || STAR_CANNON_HITBOX_SCALE);
                    if (star.isEnemy) {
                        const player = store.player;
                        const playerRadius = player.r || 18;
                        const dx = star.x - player.x;
                        const dy = star.y - player.y;
                        const combined = hitRadius + playerRadius;
                        if (dx * dx + dy * dy <= combined * combined) {
                            if (star.enemyDamage > 0) {
                                takeDamage(star.enemyDamage);
                            }
                            store.starProjectiles.splice(i, 1);
                            continue;
                        }

                        if (store.iceman) {
                            const icemanRadius = 18;
                            const iDx = star.x - store.iceman.x;
                            const iDy = star.y - store.iceman.y;
                            const iCombined = hitRadius + icemanRadius;
                            if (iDx * iDx + iDy * iDy <= iCombined * iCombined) {
                                store.starProjectiles.splice(i, 1);
                                continue;
                            }
                        }

                        if (store.beefClone) {
                            const cloneRadius = 18;
                            const cDx = star.x - store.beefClone.x;
                            const cDy = star.y - store.beefClone.y;
                            const cCombined = hitRadius + cloneRadius;
                            if (cDx * cDx + cDy * cDy <= cCombined * cCombined) {
                                store.starProjectiles.splice(i, 1);
                                continue;
                            }
                        }

                        // Check escort drones
                        if (store.escortDrones && store.escortDrones.length > 0) {
                            const droneRadius = 8;
                            let droneHit = false;
                            for (let d = store.escortDrones.length - 1; d >= 0; d--) {
                                const drone = store.escortDrones[d];
                                const dDx = star.x - drone.x;
                                const dDy = star.y - drone.y;
                                const dCombined = hitRadius + droneRadius;
                                if (dDx * dDx + dDy * dDy <= dCombined * dCombined) {
                                    // Drone is destroyed
                                    store.escortDrones.splice(d, 1);
                                    droneHit = true;
                                    break;
                                }
                            }
                            if (droneHit) {
                                store.starProjectiles.splice(i, 1);
                                continue;
                            }
                        }
                    } else {
                        for (const target of targets) {
                            if (!target || target.dead || target.hp <= 0) continue;
                            if (target === store.boss && target.isInvincible) continue;
                            if (target.isHeatDeath) continue;

                            const targetRadius = target.r || target.radius || 18;
                            const dx = star.x - target.x;
                            const dy = star.y - target.y;
                            const combined = hitRadius + targetRadius;
                            if (dx * dx + dy * dy <= combined * combined) {
                                const id = target.id || target.__starId || target;
                                if (!star.hitIds.has(id)) {
                                    const starDamage = baseDamage * (star.damageScale ?? 1);
                                    applyStarDamage(target, starDamage);
                                    star.hitIds.add(id);
                                }
                            }
                        }
                    }

                    if (star.x < -80 || star.x > W + 80 || star.y < -120 || star.y > H + 120) {
                        store.starProjectiles.splice(i, 1);
                    }
                }
            }

            function applyStarDamage(target, dmg) {
                const p = store.player;
                let damage = dmg;

                if (Math.random() < p.critChance) {
                    damage *= p.critDamage;
                    store.activeEffects.push(createEffect('critText', target.x, target.y));
                    if (Math.random() < 0.05) spawnPowerup(target.x, target.y);
                }

                if (target === store.boss) playSound('hit');
                target.hp -= damage;
                store.world.totalDamage = (store.world.totalDamage || 0) + damage;

                if (p.pilotGenome === 'beef') {
                    p.beefShieldDamageDealt = (p.beefShieldDamageDealt || 0) + damage;
                }

                if (p.vampirism > 0) {
                    let healAmount = damage * p.vampirism;
                    healAmount = Math.max(healAmount, 1);
                    healAmount = Math.min(healAmount, 5);
                    p.hp = Math.min(p.hpMax, p.hp + healAmount);
                }

                if (target.hp <= 0) {
                    target.dead = true;
                    if (target.type === 'void_champion') {
                        store.enemies.forEach(minion => {
                            if (minion.orbitTargetId === target.id && !minion.dead) {
                                spawnGibs(minion.x, minion.y, minion.color);
                                minion.dead = true;
                            }
                        });
                        handleVoidChampionReward(target);
                    }

                    if (target === store.boss) {
                        handleBossDefeat();
                    } else {
                        spawnGibs(target.x, target.y, target.color);
                        store.world.score += target.score;
                        addWorldGold(target.gold);
                        store.world.xp += target.xp;
                        store.world.kills++;

                        spawnPowerup(target.x, target.y);
                        explode(target.x, target.y);
                    }
                }
            }

            function drawStarProjectiles() {
                if (!store.starProjectiles.length) return;
                for (const star of store.starProjectiles) {
                    const isEnemyStar = !!star.isEnemy;
                    const isIcemanStar = !!star.isIceman && !isEnemyStar;
                    const trailFillBase = isEnemyStar
                        ? (star.trailColor || 'rgba(150, 160, 220, ')
                        : (isIcemanStar ? 'rgba(190, 225, 255, ' : 'rgba(255, 255, 200, ');
                    const trailShadowBase = isEnemyStar
                        ? 'rgba(80, 90, 160, '
                        : (isIcemanStar ? 'rgba(140, 200, 255, ' : 'rgba(255, 240, 150, ');
                    for (const particle of star.trail) {
                        const trailAlpha = Math.max(0, Math.min(1, particle.life * 0.6));
                        const shadowAlpha = Math.max(0, Math.min(1, particle.life));
                        ctx.fillStyle = `${trailFillBase}${trailAlpha})`;
                        ctx.shadowColor = `${trailShadowBase}${shadowAlpha})`;
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.save();
                    ctx.translate(star.x, star.y);
                    ctx.rotate(star.rotation);

                    ctx.fillStyle = isEnemyStar
                        ? (star.primaryColor || 'rgba(200, 205, 255, 0.82)')
                        : (isIcemanStar ? 'rgba(180, 215, 255, 0.85)' : 'rgba(255, 255, 140, 0.85)');
                    ctx.shadowColor = isEnemyStar
                        ? (star.shadowColor || 'rgba(70, 80, 160, 0.9)')
                        : (isIcemanStar ? 'rgba(140, 200, 255, 0.9)' : 'rgba(255, 220, 120, 0.9)');
                    ctx.shadowBlur = 24;
                    drawStarShape(ctx, 0, 0, 5, star.size, star.size * 0.45);
                    ctx.fill();

                    ctx.fillStyle = isEnemyStar
                        ? (star.coreColor || '#c8ccff')
                        : (isIcemanStar ? '#eef7ff' : '#fffbe6');
                    ctx.shadowBlur = 12;
                    drawStarShape(ctx, 0, 0, 5, star.size * 0.65, star.size * 0.28);
                    ctx.fill();

                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }

            const BEEF_CLONE_SORTIE_COOLDOWN = 12;

            function rollBeefCloneSortieCooldown() {
                return BEEF_CLONE_SORTIE_COOLDOWN;
            }

            function createMirrorClone(player, existingClone = null) {
                const margin = 60;
                const clone = existingClone && existingClone.mode === 'mirror' ? { ...existingClone } : {};
                clone.mode = 'mirror';
                clone.state = 'tether';
                clone.backlineDistance = clone.backlineDistance ?? 140;
                clone.minBacklineDistance = clone.minBacklineDistance ?? 80;
                clone.followEase = clone.followEase ?? 7.2;
                clone.horizontalEase = clone.horizontalEase ?? 6.3;
                clone.topBoundary = clone.topBoundary ?? 60;
                clone.visualScale = clone.visualScale || 0.82;
                clone.shotDamageScale = clone.shotDamageScale ?? 0.35;
                clone.fireRate = clone.fireRate || 0.28;
                clone.fireCooldown = clone.fireCooldown ?? (Math.random() * clone.fireRate);
                clone.bobPhase = typeof clone.bobPhase === 'number' ? clone.bobPhase : Math.random() * Math.PI * 2;
                clone.bobSpeed = clone.bobSpeed || 1.6;
                clone.direction = clone.direction || 1;
                clone.bombCooldown = clone.bombCooldown ?? rollBeefCloneSortieCooldown();
                clone.pendingBombs = clone.pendingBombs ?? 0;
                clone.bombInterval = clone.bombInterval || 0.28;
                clone.bombDamageScale = clone.bombDamageScale ?? 0.45;
                clone.bombRadiusScale = clone.bombRadiusScale ?? 0.65;
                clone.bombSpeedScale = clone.bombSpeedScale ?? 1.05;
                clone.bombSeekStrength = clone.bombSeekStrength ?? 520;
                clone.bombMaxSpeed = clone.bombMaxSpeed ?? 520;
                const clampX = clamp(player.x, margin, W - margin);
                const backline = clone.backlineDistance;
                const initialY = Math.max(clone.topBoundary, player.y - backline);
                clone.x = clamp(clone.x ?? clampX, margin, W - margin);
                clone.y = clamp(clone.y ?? initialY, clone.topBoundary, H * 0.82);
                return clone;
            }

            function fireMirrorCloneShot(clone, player) {
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                if (!potentialTargets || potentialTargets.length === 0) return false;

                let best = null;
                let bestDistSq = Infinity;
                for (const enemy of potentialTargets) {
                    if (!enemy || enemy.dead || enemy.hp <= 0) continue;
                    const dx = enemy.x - clone.x;
                    const dy = enemy.y - clone.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < bestDistSq) {
                        bestDistSq = distSq;
                        best = enemy;
                    }
                }

                if (!best) return false;

                const angle = Math.atan2(best.y - clone.y, best.x - clone.x);
                const bulletSpeed = 620;
                const damageScale = clone.shotDamageScale ?? 0.35;
                const baseDamage = 15 * (player?.dmgMult || 1) * damageScale;
                const startOffset = 12;

                spawnBullet({
                    x: clone.x + Math.cos(angle) * startOffset,
                    y: clone.y + Math.sin(angle) * startOffset,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 2,
                    col: '#6be48e',
                    dmg: baseDamage,
                    pierce: Math.max(0, (player?.piercing || 0) - 1),
                    explosive: false,
                    isBeefClone: true,
                    isSwirl: false
                });

                if (Math.abs(Math.cos(angle)) > 0.15) {
                    clone.direction = Math.cos(angle) >= 0 ? 1 : -1;
                }

                return true;
            }

            function selectMirrorCloneBombTarget(clone) {
                const threats = [];
                if (store.boss && !store.boss.dead && store.boss.hp > 0) {
                    threats.push(store.boss);
                }
                if (Array.isArray(store.enemies)) {
                    for (const enemy of store.enemies) {
                        if (!enemy || enemy.dead || enemy.hp <= 0) continue;
                        threats.push(enemy);
                    }
                }
                if (!threats.length) return null;
                let best = null;
                let bestDistSq = Infinity;
                for (const threat of threats) {
                    const dx = (threat.x ?? clone.x) - clone.x;
                    const dy = (threat.y ?? clone.y) - clone.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < bestDistSq) {
                        bestDistSq = distSq;
                        best = threat;
                    }
                }
                return best;
            }

            function updateMirrorClone(dt) {
                const player = store.player;
                if (!player || player.dead) return;
                if (!store.beefClone || store.beefClone.mode !== 'mirror') {
                    store.beefClone = createMirrorClone(player, store.beefClone);
                }
                const clone = store.beefClone;
                if (!clone || clone.mode !== 'mirror') return;

                const margin = 60;
                const topBoundary = clone.topBoundary ?? 60;
                const followEase = clone.followEase ?? 7.2;
                const horizontalEase = clone.horizontalEase ?? followEase;
                const bobSpeed = clone.bobSpeed || 1.6;
                clone.bobPhase = (clone.bobPhase || 0) + dt * bobSpeed;
                const bobOffset = Math.sin(clone.bobPhase) * 8;

                const targetX = clamp(player.x, margin, W - margin);
                const midfield = H * 0.5;
                const backlineDistance = clone.backlineDistance ?? 140;
                const minBacklineDistance = clone.minBacklineDistance ?? 80;

                let dynamicDistance = backlineDistance;
                if (player.y < midfield) {
                    const blendStart = midfield;
                    const blendEnd = topBoundary + 40;
                    const denom = Math.max(1, blendStart - blendEnd);
                    const t = clamp((blendStart - player.y) / denom, 0, 1);
                    dynamicDistance = backlineDistance - (backlineDistance - minBacklineDistance) * t;
                }

                let desiredY = player.y - dynamicDistance;
                if (desiredY < topBoundary) desiredY = topBoundary;
                const maxAnchor = Math.min(player.y - 30, H * 0.88);
                const adjustedY = clamp(desiredY + bobOffset, topBoundary, maxAnchor);

                const horizontalFactor = 1 - Math.exp(-dt * horizontalEase);
                clone.x += (targetX - clone.x) * horizontalFactor;

                const verticalFactor = 1 - Math.exp(-dt * followEase);
                clone.y += (adjustedY - clone.y) * verticalFactor;

                clone.x = clamp(clone.x, margin, W - margin);
                clone.y = clamp(clone.y, topBoundary, H * 0.9);

                clone.direction = clone.x <= targetX ? 1 : -1;

                clone.fireRate = clone.fireRate || 0.28;
                clone.fireCooldown = Math.max(0, (clone.fireCooldown ?? 0) - dt);
                if (clone.fireCooldown <= 0) {
                    const fired = fireMirrorCloneShot(clone, player);
                    const baseRate = clone.fireRate;
                    const jitter = Math.min(0.1, baseRate * 0.35);
                    clone.fireCooldown = baseRate + (Math.random() - 0.5) * jitter;
                    if (!fired) {
                        clone.fireCooldown = Math.min(baseRate, 0.18);
                    }
                }

                clone.bombCooldown = (clone.bombCooldown ?? rollBeefCloneSortieCooldown()) - dt;
                if (clone.pendingBombs > 0) {
                    clone.bombTimer = (clone.bombTimer ?? 0) - dt;
                    if (clone.bombTimer <= 0) {
                        const target = selectMirrorCloneBombTarget(clone);
                        if (target) {
                            spawnJuggernautBomb(clone, player, {
                                damageScale: clone.bombDamageScale,
                                radiusScale: clone.bombRadiusScale,
                                speedScale: clone.bombSpeedScale,
                                target,
                                seekStrength: clone.bombSeekStrength,
                                maxSpeed: clone.bombMaxSpeed
                            });
                            clone.pendingBombs--;
                            clone.bombTimer = clone.pendingBombs > 0 ? (clone.bombInterval || 0.28) : 0;
                        } else {
                            clone.pendingBombs = 0;
                            clone.bombCooldown = Math.max(clone.bombCooldown, 0.35);
                        }
                    }
                } else if (clone.bombCooldown <= 0 && ((Array.isArray(store.enemies) && store.enemies.some(e => e && !e.dead && e.hp > 0)) || (store.boss && !store.boss.dead && store.boss.hp > 0))) {
                    clone.pendingBombs = 3;
                    clone.bombTimer = 0;
                    clone.bombCooldown = rollBeefCloneSortieCooldown();
                }
            }

            function activateJuggernautClone(p) {
                const margin = 60;
                const clone = store.beefClone && store.beefClone.mode === 'juggernaut_bomber'
                    ? store.beefClone
                    : {};

                store.juggernautBombs = [];

                clone.mode = 'juggernaut_bomber';
                clone.visualScale = clone.visualScale || 0.95;
                clone.backlineDistance = clone.backlineDistance ?? 170;
                clone.minBacklineDistance = clone.minBacklineDistance ?? 110;
                clone.followEase = clone.followEase ?? 7.2;
                clone.horizontalEase = clone.horizontalEase ?? 5.6;
                clone.topBoundary = clone.topBoundary ?? 60;
                clone.bobSpeed = clone.bobSpeed || 1.7;
                clone.bobPhase = typeof clone.bobPhase === 'number' ? clone.bobPhase : Math.random() * Math.PI * 2;
                clone.bombDamageScale = clone.bombDamageScale ?? 1;
                clone.bombRadiusScale = clone.bombRadiusScale ?? 1;
                clone.bombSpeedScale = clone.bombSpeedScale ?? 1.08;
                clone.bombSeekStrength = clone.bombSeekStrength ?? 640;
                clone.bombMaxSpeed = clone.bombMaxSpeed ?? 620;
                clone.baseInterval = p.beefUnstoppableForce ? 0.45 : (clone.baseInterval || 0.6);
                clone.dropTimer = 0;
                clone.direction = clone.direction || 1;
                clone.x = clamp(p.x, margin, W - margin);
                const initialY = clamp(p.y - clone.backlineDistance, clone.topBoundary, H * 0.88);
                clone.y = clamp(clone.y ?? initialY, clone.topBoundary, H * 0.88);

                store.beefClone = clone;
            }

            function updateJuggernautClone(dt) {
                const clone = store.beefClone;
                if (!clone || clone.mode !== 'juggernaut_bomber') return;
                const p = store.player;
                if (!p || p.dead) return;

                const margin = 60;
                const topBoundary = clone.topBoundary ?? 60;
                const followEase = clone.followEase ?? 7.2;
                const horizontalEase = clone.horizontalEase ?? followEase;
                const backlineDistance = clone.backlineDistance ?? 170;
                const minBacklineDistance = clone.minBacklineDistance ?? 110;
                const midfield = H * 0.5;

                const bobSpeed = clone.bobSpeed || 1.7;
                clone.bobPhase = (clone.bobPhase || 0) + dt * bobSpeed;
                const bobBase = 14 + Math.min(12, (p.beefExplosionDamage || 0) * 8);
                const bobOffset = Math.sin(clone.bobPhase) * bobBase;

                const targetX = clamp(p.x, margin, W - margin);

                let dynamicDistance = backlineDistance;
                if (p.y < midfield) {
                    const blendStart = midfield;
                    const blendEnd = topBoundary + 40;
                    const denom = Math.max(1, blendStart - blendEnd);
                    const t = clamp((blendStart - p.y) / denom, 0, 1);
                    dynamicDistance = backlineDistance - (backlineDistance - minBacklineDistance) * t;
                }

                let desiredY = p.y - dynamicDistance;
                if (desiredY < topBoundary) desiredY = topBoundary;
                const maxAnchor = Math.min(p.y - 30, H * 0.88);
                const adjustedY = clamp(desiredY + bobOffset, topBoundary, maxAnchor);

                const horizontalFactor = 1 - Math.exp(-dt * horizontalEase);
                clone.x += (targetX - clone.x) * horizontalFactor;

                const verticalFactor = 1 - Math.exp(-dt * followEase);
                clone.y += (adjustedY - clone.y) * verticalFactor;

                clone.x = clamp(clone.x, margin, W - margin);
                clone.y = clamp(clone.y, topBoundary, H * 0.9);

                clone.direction = clone.x <= targetX ? 1 : -1;

                const unstoppableBonus = p.beefUnstoppableForce ? 0.12 : 0;
                const eliteBonus = p.beefEliteCombat ? 0.08 : 0;
                const intervalBase = clone.baseInterval || 0.6;
                const interval = Math.max(0.24, intervalBase - unstoppableBonus - eliteBonus);
                clone.dropTimer = (clone.dropTimer || 0) - dt;
                if (clone.dropTimer <= 0) {
                    const target = selectMirrorCloneBombTarget(clone);
                    if (target) {
                        spawnJuggernautBomb(clone, p, {
                            damageScale: clone.bombDamageScale,
                            radiusScale: clone.bombRadiusScale,
                            speedScale: clone.bombSpeedScale,
                            target,
                            seekStrength: clone.bombSeekStrength,
                            maxSpeed: clone.bombMaxSpeed
                        });
                        clone.dropTimer = interval;
                    } else {
                        clone.dropTimer = Math.min(interval, 0.35);
                    }
                }
            }

            function spawnJuggernautBomb(clone, player, options = null) {
                const unstoppableBonus = player.beefUnstoppableForce ? 1.4 : 1;
                const eliteBonus = player.beefEliteCombat ? 1.15 : 1;
                const opts = options || {};
                const damageScale = opts.damageScale ?? 1;
                const radiusScale = opts.radiusScale ?? 1;
                const speedScale = opts.speedScale ?? 1;
                const gravityScale = opts.gravityScale ?? 1;
                const target = opts.target || null;
                const seekStrength = opts.seekStrength ?? (target ? 480 : 0);
                const maxSpeed = opts.maxSpeed ?? (target ? 520 : 360);
                const damage = 180 * player.dmgMult * unstoppableBonus * eliteBonus * damageScale;
                const radius = (100 + (player.beefExplosionRadius ? 35 : 0)) * radiusScale;
                if (!Array.isArray(store.juggernautBombs)) store.juggernautBombs = [];

                const spawnX = clone.x;
                const spawnY = clone.y + 18;
                let vx = (clone.direction || 1) * 45 * speedScale;
                let vy = 30;
                let gravity = 520 * gravityScale;

                if (target) {
                    const tx = target.x ?? spawnX;
                    const ty = target.y ?? spawnY;
                    const dx = tx - spawnX;
                    const dy = ty - spawnY;
                    const dist = Math.hypot(dx, dy) || 1;
                    const initialSpeed = maxSpeed;
                    vx = (dx / dist) * initialSpeed;
                    vy = (dy / dist) * initialSpeed;
                    gravity = 0;
                }

                const bomb = {
                    x: spawnX,
                    y: spawnY,
                    vx,
                    vy,
                    gravity,
                    radius,
                    damage,
                    bossDamageScale: 0.48,
                    life: 3.5,
                    rotation: 0,
                    rotationSpeed: (clone.direction || 1) * 5,
                    trailTimer: 0.05,
                    target: target || null,
                    targetX: target ? target.x : undefined,
                    targetY: target ? target.y : undefined,
                    seek: !!target,
                    seekStrength,
                    maxSpeed
                };
                store.juggernautBombs.push(bomb);
                store.activeEffects.push(createEffect('hitSpark', clone.x, clone.y, 24, { strength: 35 }));
            }

            function stepJuggernautBombs(dt) {
                if (!store.juggernautBombs.length) return;
                const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
                const approachValue = (current, target, maxDelta) => {
                    if (current < target) {
                        return Math.min(target, current + maxDelta);
                    }
                    return Math.max(target, current - maxDelta);
                };
                for (let i = store.juggernautBombs.length - 1; i >= 0; i--) {
                    const bomb = store.juggernautBombs[i];
                    bomb.life -= dt;
                    if (bomb.seek) {
                        if (bomb.target && !bomb.target.dead && bomb.target.hp > 0) {
                            bomb.targetX = bomb.target.x;
                            bomb.targetY = bomb.target.y;
                        }
                        if (bomb.targetX !== undefined && bomb.targetY !== undefined) {
                            const dx = bomb.targetX - bomb.x;
                            const dy = bomb.targetY - bomb.y;
                            const dist = Math.hypot(dx, dy) || 1;
                            const desiredSpeed = bomb.maxSpeed || 480;
                            const desiredVx = (dx / dist) * desiredSpeed;
                            const desiredVy = (dy / dist) * desiredSpeed;
                            const steer = (bomb.seekStrength || 420) * dt;
                            bomb.vx = approachValue(bomb.vx, desiredVx, steer);
                            bomb.vy = approachValue(bomb.vy, desiredVy, steer);
                            if (dist <= (bomb.radius || 90) * 0.5) {
                                detonateJuggernautBomb(bomb);
                                store.juggernautBombs.splice(i, 1);
                                continue;
                            }
                        }
                    }
                    if (bomb.gravity) {
                        bomb.vy += bomb.gravity * dt;
                    }
                    bomb.x += bomb.vx * dt;
                    bomb.y += bomb.vy * dt;
                    bomb.rotation = (bomb.rotation || 0) + (bomb.rotationSpeed || 0) * dt;
                    bomb.trailTimer -= dt;
                    if (bomb.trailTimer <= 0) {
                        bomb.trailTimer = 0.1;
                        store.activeEffects.push(createEffect('jugFearEmber', bomb.x, bomb.y, 18));
                    }

                    if ((!bomb.seek && bomb.y >= H - 40) || bomb.life <= 0) {
                        detonateJuggernautBomb(bomb);
                        store.juggernautBombs.splice(i, 1);
                        continue;
                    }

                    let detonated = false;
                    for (const target of targets) {
                        if (!target || target.dead || target.hp <= 0) continue;
                        const targetRadius = target.r || target.radius || 18;
                        const dx = bomb.x - target.x;
                        const dy = bomb.y - target.y;
                        if (dx * dx + dy * dy <= (targetRadius + 12) * (targetRadius + 12)) {
                            detonateJuggernautBomb(bomb);
                            store.juggernautBombs.splice(i, 1);
                            detonated = true;
                            break;
                        }
                    }
                    if (detonated) continue;
                }
            }

            function detonateJuggernautBomb(bomb) {
                if (!bomb || bomb.dead) return;
                bomb.dead = true;
                playSound('explosion');
                const radius = bomb.radius || 90;
                store.activeEffects.push(createEffect('grenadeExplosion', bomb.x, bomb.y, radius));
                const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
                for (const target of targets) {
                    if (!target || target.dead || target.hp <= 0) continue;
                    const targetRadius = target.r || target.radius || 18;
                    const dx = bomb.x - target.x;
                    const dy = bomb.y - target.y;
                    if (dx * dx + dy * dy > (radius + targetRadius) * (radius + targetRadius)) continue;
                    let dmg = bomb.damage;
                    if (target === store.boss) {
                        dmg *= bomb.bossDamageScale || 0.5;
                    }
                    applyStarDamage(target, dmg);
                    registerEnemyHit(target, {
                        angle: Math.atan2(target.y - bomb.y, target.x - bomb.x),
                        knockbackStrength: 120,
                        knockbackDuration: 0.18
                    });
                }
            }

            function drawJuggernautBombs() {
                if (!store.juggernautBombs.length) return;
                ctx.save();
                for (const bomb of store.juggernautBombs) {
                    ctx.save();
                    ctx.translate(bomb.x, bomb.y);
                    ctx.rotate(bomb.rotation || 0);
                    const radius = 12;
                    const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, radius * 1.2);
                    gradient.addColorStop(0, 'rgba(255, 240, 180, 0.95)');
                    gradient.addColorStop(0.5, 'rgba(255, 150, 60, 0.8)');
                    gradient.addColorStop(1, 'rgba(80, 20, 20, 0.2)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radius, radius * 1.35, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 200, 120, 0.85)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radius * 0.7, radius * 0.9, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(255, 130, 80, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-radius * 0.6, radius * 1.2);
                    ctx.lineTo(0, radius * 1.9);
                    ctx.lineTo(radius * 0.6, radius * 1.2);
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.restore();
            }

            function drawShadowEchoes() {
                if (!store.shadowEchoes || !store.shadowEchoes.length) return;
                ctx.save();
                for (const echo of store.shadowEchoes) {
                    const lifeRatio = echo.maxLife ? Math.max(0, Math.min(1, echo.life / echo.maxLife)) : 1;
                    if (lifeRatio <= 0) continue;
                    ctx.globalAlpha = 0.35 * lifeRatio;
                    ctx.fillStyle = `rgba(150, 160, 255, ${0.25 + lifeRatio * 0.35})`;
                    ctx.beginPath();
                    ctx.ellipse(echo.x, echo.y, 24 * lifeRatio, 16 * lifeRatio, echo.rotation || 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            function drawTemporalEchoes() {
                const echoes = store.temporalEchoes;
                if (!Array.isArray(echoes) || echoes.length === 0) return;
                const time = performance.now() / 1000;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const echo of echoes) {
                    if (!echo || echo.dead) continue;
                    const lifeRatio = echo.maxLife ? Math.max(0, Math.min(1, echo.life / echo.maxLife)) : 1;
                    if (lifeRatio <= 0) continue;

                    const baseRadius = echo.radius || 18;
                    const pulse = 1 + Math.sin(time * 5.2 + (echo.pulseOffset || 0)) * 0.08;
                    const auraRadius = baseRadius * (1.7 + (echo.stage === 'dash' ? 0.28 : 0));
                    const coreColor = echo.color || '#8cf5ff';
                    const trailColor = echo.trailColor || '#2a9dff';

                    const auraGradient = ctx.createRadialGradient(echo.x, echo.y, 0, echo.x, echo.y, auraRadius * pulse);
                    auraGradient.addColorStop(0, addAlpha(coreColor, 0.72 * lifeRatio));
                    auraGradient.addColorStop(0.55, addAlpha(coreColor, 0.32 * lifeRatio));
                    auraGradient.addColorStop(1, addAlpha(coreColor, 0));
                    ctx.fillStyle = auraGradient;
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, auraRadius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.lineWidth = 2.2;
                    ctx.strokeStyle = addAlpha(trailColor, 0.55 * lifeRatio);
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, baseRadius * (1.05 + pulse * 0.2), 0, Math.PI * 2);
                    ctx.stroke();

                    if (echo.stage === 'dash') {
                        const vx = echo.vx || 0;
                        const vy = echo.vy || 0;
                        const speed = Math.hypot(vx, vy) || 0;
                        if (speed > 0) {
                            const tailLength = Math.min(120, Math.max(55, speed * 0.24));
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = addAlpha(trailColor, 0.4 * lifeRatio);
                            ctx.beginPath();
                            ctx.moveTo(echo.x, echo.y);
                            ctx.lineTo(echo.x - (vx / speed) * tailLength, echo.y - (vy / speed) * tailLength);
                            ctx.stroke();
                        }
                    }
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            function drawStarShape(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
            }

            function drawGoldenOrbs() {
                if (!store.goldenOrbs || store.goldenOrbs.length === 0) {
                    return;
                }
                const time = performance.now() / 1000;

                for (const orb of store.goldenOrbs) {
                    if (orb.trail && orb.trail.length) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        for (const node of orb.trail) {
                            const lifeRatio = Math.max(0, node.life / GOLDEN_ORB_CONFIG.trailLife);
                            if (lifeRatio <= 0) continue;
                            ctx.globalAlpha = lifeRatio * 0.45;
                            ctx.fillStyle = `rgba(255, 210, 120, ${lifeRatio * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(node.x, node.y, 9 * lifeRatio, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    }

                    ctx.save();
                    ctx.translate(orb.x, orb.y);
                    if (orb.state === 'homing') {
                        ctx.rotate(orb.heading || 0);
                    }
                    ctx.globalCompositeOperation = 'lighter';

                    const pulse = 0.85 + Math.sin(time * 6 + (orb.pulseOffset || 0)) * 0.15;
                    const outerGlowRadius = orb.r * (1.4 + pulse * 0.25);
                    const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerGlowRadius);
                    glowGradient.addColorStop(0, 'rgba(255, 255, 220, 0.18)');
                    glowGradient.addColorStop(0.5, 'rgba(255, 210, 100, 0.4)');
                    glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(0, 0, outerGlowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    const ringOuter = orb.r * (0.95 + pulse * 0.12);
                    const ringInner = ringOuter * 0.55;
                    const ringGradient = ctx.createRadialGradient(0, 0, ringInner * 0.75, 0, 0, ringOuter);
                    ringGradient.addColorStop(0, 'rgba(255, 250, 210, 0.85)');
                    ringGradient.addColorStop(0.45, 'rgba(255, 210, 90, 0.75)');
                    ringGradient.addColorStop(0.9, 'rgba(255, 130, 20, 0.35)');
                    ringGradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
                    ctx.fillStyle = ringGradient;
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 225, 140, 0.95)';
                    ctx.lineWidth = Math.max(3, orb.r * 0.18);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(255, 255, 220, 0.5)';
                    ctx.lineWidth = Math.max(2, orb.r * 0.12);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringInner, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.6 + 0.3 * Math.sin(time * 8 + (orb.pulseOffset || 0));
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, ringInner * 0.45, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }

            function drawTimeShards() {
                const shards = store.timeShards;
                if (!Array.isArray(shards) || shards.length === 0) return;
                const time = performance.now() / 1000;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const shard of shards) {
                    if (!shard || shard.dead) continue;
                    const lifeRatio = shard.maxLife ? Math.max(0, Math.min(1, shard.life / shard.maxLife)) : 1;
                    if (lifeRatio <= 0) continue;

                    const baseRadius = shard.r || 14;
                    const pulse = 1 + Math.sin(time * 4.3 + (shard.sparkle || 0)) * 0.08 + (shard.hitPulse || 0) * 0.35;
                    const glowRadius = baseRadius * (1.9 + (shard.hitPulse || 0) * 0.6);

                    const glowGradient = ctx.createRadialGradient(shard.x, shard.y, 0, shard.x, shard.y, glowRadius * pulse);
                    glowGradient.addColorStop(0, `rgba(157, 247, 255, ${0.55 * lifeRatio})`);
                    glowGradient.addColorStop(0.65, `rgba(122, 231, 255, ${0.28 * lifeRatio})`);
                    glowGradient.addColorStop(1, 'rgba(122, 231, 255, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(shard.x, shard.y, glowRadius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.save();
                    ctx.translate(shard.x, shard.y);
                    ctx.rotate(time * 1.9 + (shard.sparkle || 0));
                    ctx.globalAlpha = 0.92 * lifeRatio;
                    ctx.fillStyle = `rgba(102, 206, 255, ${0.9 * lifeRatio})`;
                    const w = baseRadius * 0.9 * pulse;
                    const h = baseRadius * 1.35 * pulse;
                    ctx.beginPath();
                    ctx.moveTo(0, -h);
                    ctx.lineTo(w, 0);
                    ctx.lineTo(0, h);
                    ctx.lineTo(-w, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();

                    ctx.save();
                    ctx.fillStyle = `rgba(240, 255, 255, ${0.85 * lifeRatio})`;
                    ctx.font = 'bold 12px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.translate(shard.x, shard.y - baseRadius * 1.25);
                    ctx.scale(1, 0.9);
                    ctx.fillText(`x${shard.buffStacks || 1}`, 0, 0);
                    ctx.restore();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            function ensureShadowCloneInit(b) {
                if (b.shadowInitialized) return;
                b.shadowInitialized = true;
                b.shadowAbilityCooldown = 26;
                b.shadowAbilityTimers = {
                    star: 5 + Math.random() * 2,
                    lightning: 10 + Math.random() * 2,
                    hounds: 15 + Math.random() * 2,
                    charge: 20 + Math.random() * 2,
                    pulseWave: 8 + Math.random() * 2,
                    voidRift: 18 + Math.random() * 2
                };
                b.shadowAbilityOrder = ['star', 'pulseWave', 'lightning', 'hounds', 'voidRift', 'charge'];
                b.shadowAbilityIndex = 0;
                b.multishotTimer = 0.9;
                b.shadowChargeVX = 0;
                b.shadowChargeVY = 0;
                b.shadowChargeTrailCooldown = 0;
                b.shadowChargeHit = false;
                b.shadowTelegraph = null;
                b.shadowTelegraphTarget = null;
                spawnShadowChampionEscort(b);
            }

            function getActiveShadowChampion() {
                if (!store.shadowChampionId) return null;
                return store.enemies.find(e => e.id === store.shadowChampionId && !e.dead) || null;
            }

            function spawnShadowChampionEscort(boss) {
                if (!store || !store.enemies) return null;
                if (store.shadowChampionDefeated) return null;
                const existing = getActiveShadowChampion();
                if (existing) {
                    store.shadowChampionLastPos = { x: existing.x, y: existing.y };
                    return existing;
                }

                const guardRadius = 130;
                const spawnAngle = Math.random() * Math.PI * 2;
                const offsetX = Math.cos(spawnAngle) * guardRadius;
                const offsetY = Math.sin(spawnAngle) * Math.max(guardRadius * 0.55, 60);
                const targetY = clamp(boss.y + 90, 120, H * 0.78);
                const spawnX = clamp(boss.x + offsetX, 60, W - 60);
                const spawnProps = {
                    x: spawnX,
                    y: targetY,
                    hpScale: Math.max(1.1, boss.hpMax ? boss.hpMax / 4500 : 1.1),
                    damageMult: 1 + Math.max(0, store.world.wave - 8) * 0.025,
                    guardRadius,
                    guardAngle: spawnAngle,
                    angularSpeed: 0.7 + Math.random() * 0.25,
                    anchorOffsetY: 90,
                    bossLinkId: boss._instanceId || (boss._instanceId = performance.now() + Math.random()),
                    fireCooldown: boss.isEnraged ? 1.1 : 1.35,
                    momentum: 3.6
                };

                const champion = spawnEnemy('shadow_champion', spawnProps);
                if (!champion) return null;

                champion.x = spawnX;
                champion.y = targetY;
                store.enemies.push(champion);
                store.shadowChampionId = champion.id;
                store.shadowChampionDefeated = false;
                store.shadowChampionTokenDropped = false;
                store.shadowChampionLastPos = { x: champion.x, y: champion.y };

                activateSpawnIntro(champion, {
                    duration: 0.75,
                    dropDistance: 200,
                    targetY,
                    effectColor: '#8f9bff',
                    topClampBuffer: 0.7,
                    fireDelayBuffer: 0.6,
                    clusterIndex: -1
                });

                store.activeEffects.push(createEffect('spawnTeleport', champion.x, targetY, champion.r || 22, {
                    duration: 1.1,
                    color: '#8f9bff',
                    clusterIndex: -1,
                    isChampion: true
                }));

                announce('Shadow champion joins the mirror!');
                return champion;
            }

            function dropShadowChampionToken(x, y) {
                if (store.shadowChampionTokenDropped) return;
                if (!store.powerups) store.powerups = [];
                const dropX = clamp(x, 20, W - 20);
                const dropY = clamp(y, 40, H - 40);
                store.powerups.push({ x: dropX, y: dropY, r: 16, type: 'shadow_champion_token' });
                store.shadowChampionTokenDropped = true;
                announce('Champion sigil recovered! Summon secured.');
            }

            function finalizeShadowChampionAfterBoss(bossX, bossY) {
                if (store.shadowChampionTokenDropped) return;
                let dropPos = { x: bossX, y: bossY };
                const champion = getActiveShadowChampion();
                if (champion) {
                    dropPos = { x: champion.x, y: champion.y - 18 };
                    champion.dead = true;
                    spawnGibs(champion.x, champion.y, champion.color);
                } else if (store.shadowChampionLastPos) {
                    dropPos = { x: store.shadowChampionLastPos.x, y: store.shadowChampionLastPos.y - 18 };
                }
                store.shadowChampionId = null;
                store.shadowChampionDefeated = true;
                store.shadowChampionLastPos = { x: dropPos.x, y: dropPos.y };
                dropShadowChampionToken(dropPos.x, dropPos.y);
            }

            const PLAYER_CHAMPION_CONFIG = Object.freeze({
                baseGuardRadius: 110,
                baseAngularSpeed: 1.35,
                baseFireCooldown: 1.25,
                baseDashCooldown: 2.8,
                maxLevel: 5,
                maxMinions: 3
            });

            const CHAMPION_ATTACK_MODULES = Object.freeze([
                // KINETIC MODULES - Physical/Ballistic Damage
                {
                    id: 'precision_strike',
                    name: 'PRECISION STRIKE',
                    icon: ' ',
                    cost: 180,
                    damageType: 'kinetic',
                    attackSpeed: 'slow',
                    targetType: 'single',
                    tradeOff: 'Very slow, devastating single shots',
                    desc: 'Slow-charging railgun shots that deal massive single-target damage. Effective against heavily armored enemies and bosses.',
                    flavor: 'Capacitor-charged tungsten penetrators for maximum impact.',
                    fireRateMult: 0.5, // Very slow
                    damageMult: 2.2,   // Very high damage
                    specialEffect: 'armor_pierce'
                },
                {
                    id: 'kinetic_swarm',
                    name: 'KINETIC SWARM',
                    icon: 'ðŸŒªï¸',
                    cost: 160,
                    damageType: 'kinetic',
                    attackSpeed: 'very_fast',
                    targetType: 'single',
                    tradeOff: 'Rapid-fire, low individual damage',
                    desc: 'Ultra-high rate of fire with small projectiles. Excellent for overwhelming weak enemies and applying constant pressure.',
                    flavor: 'Micro-slug autoloader system for sustained fire.',
                    fireRateMult: 0.4, // Very fast (lower cooldown = faster)
                    damageMult: 0.7,   // Low damage per shot
                    specialEffect: 'rapid_fire'
                },

                // FIRE MODULES - Thermal/Burn Damage
                {
                    id: 'inferno_burst',
                    name: 'INFERNO BURST',
                    icon: 'ðŸ’¥',
                    cost: 220,
                    damageType: 'fire',
                    attackSpeed: 'slow',
                    targetType: 'area',
                    tradeOff: 'Slow charge-up, explosive area damage',
                    desc: 'Charges up explosive plasma bursts that deal heavy area damage and ignite multiple enemies. Perfect for crowd control.',
                    flavor: 'Compressed plasma chambers with magnetic containment.',
                    fireRateMult: 0.7, // Slow
                    damageMult: 1.6,   // High damage
                    specialEffect: 'area_burn'
                },
                {
                    id: 'plasma_stream',
                    name: 'PLASMA STREAM',
                    icon: 'ðŸŒž',
                    cost: 200,
                    damageType: 'fire',
                    attackSpeed: 'medium',
                    targetType: 'single',
                    tradeOff: 'Balanced fire rate with burn over time',
                    desc: 'Sustained plasma bolts that ignite targets for damage over time. Balanced option effective against most enemy types.',
                    flavor: 'Sustained fusion core with thermal dispersal matrix.',
                    fireRateMult: 1.0, // Medium speed
                    damageMult: 1.2,   // Medium damage
                    specialEffect: 'burn_dot'
                },

                // LASER MODULES - Energy/Piercing Damage
                {
                    id: 'focus_beam',
                    name: 'FOCUS BEAM',
                    icon: 'ðŸ”´',
                    cost: 240,
                    damageType: 'laser',
                    attackSpeed: 'slow',
                    targetType: 'single',
                    tradeOff: 'Charge-up required, pierces all armor',
                    desc: 'Concentrated laser beam that charges briefly then pierces through armor and shields. Devastating against heavily protected targets.',
                    flavor: 'Coherent photon lance with quantum focusing array.',
                    fireRateMult: 0.6, // Slow with charge
                    damageMult: 2.0,   // High damage
                    specialEffect: 'armor_ignore'
                },
                {
                    id: 'scatter_array',
                    name: 'SCATTER ARRAY',
                    icon: 'ðŸ’«',
                    cost: 190,
                    damageType: 'laser',
                    attackSpeed: 'fast',
                    targetType: 'multi',
                    tradeOff: 'Fast multi-target, moderate damage each',
                    desc: 'Multiple laser emitters fire simultaneously at different targets. Great for clearing groups of weaker enemies.',
                    flavor: 'Distributed aperture system with target acquisition matrix.',
                    fireRateMult: 0.8, // Fast
                    damageMult: 1.0,   // Moderate damage per beam
                    specialEffect: 'multi_target'
                },

                // LIGHTNING MODULES - Electric/Chain Damage
                {
                    id: 'arc_cannon',
                    name: 'ARC CANNON',
                    icon: 'âš¡',
                    cost: 210,
                    damageType: 'lightning',
                    attackSpeed: 'medium',
                    targetType: 'single_chain',
                    tradeOff: 'High single damage plus chain potential',
                    desc: 'Powerful electrical discharge that hits primary target hard and chains to nearby enemies. Effective against clustered foes.',
                    flavor: 'Tesla coil array with conductive targeting protocols.',
                    fireRateMult: 0.9, // Medium-slow
                    damageMult: 1.5,   // High primary damage
                    specialEffect: 'chain_lightning'
                },
                {
                    id: 'storm_grid',
                    name: 'STORM GRID',
                    icon: 'ðŸŒ©ï¸',
                    cost: 230,
                    damageType: 'lightning',
                    attackSpeed: 'fast',
                    targetType: 'area_control',
                    tradeOff: 'Continuous area damage, lower per-hit',
                    desc: 'Creates persistent electrical fields that continuously damage enemies in the area. Excellent for zone control and area denial.',
                    flavor: 'Ionospheric manipulation with sustained discharge fields.',
                    fireRateMult: 0.75, // Fast
                    damageMult: 0.9,   // Lower individual damage
                    specialEffect: 'continuous_area'
                }
            ]);

            const CHAMPION_ATTACK_MODULE_MAP = Object.freeze(Object.fromEntries(CHAMPION_ATTACK_MODULES.map(mod => [mod.id, mod])));

            const CHAMPION_CADENCE_LEVELS = Object.freeze([
                { level: 0, name: 'BASELINE CADENCE', cost: 0, fireRateMult: 1.0, dashCooldownMult: 1.0, specialCooldownMult: 1.0, desc: 'Standard guardian timing.' },
                { level: 1, name: 'PULSE SYNC', cost: 140, fireRateMult: 0.9, dashCooldownMult: 0.92, specialCooldownMult: 0.94, desc: '-10% firing delay, -8% dash cooldown. Specials rotate 6% faster.' },
                { level: 2, name: 'NOVA RHYTHM', cost: 210, fireRateMult: 0.8, dashCooldownMult: 0.86, specialCooldownMult: 0.9, desc: '-20% firing delay, -14% dash cooldown. Specials rotate 10% faster.' },
                { level: 3, name: 'TEMPORAL WARP', cost: 290, fireRateMult: 0.7, dashCooldownMult: 0.8, specialCooldownMult: 0.85, desc: '-30% firing delay, -20% dash cooldown. Specials rotate 15% faster.' }
            ]);

            const CHAMPION_MINION_PROTOCOL_LEVELS = Object.freeze([
                { level: 0, name: 'ESCORT DRONES', cost: 0, fireRateMult: 1.0, damageMult: 1.0, minionCount: 2, desc: 'Standard escort pattern.' },
                { level: 1, name: 'FLUX SENTINELS', cost: 160, fireRateMult: 0.85, damageMult: 1.12, slowFactor: 0.78, minionCount: 3, desc: 'Minions fire faster and slow targets on hit.' },
                { level: 2, name: 'SINGULARITY LANCES', cost: 230, fireRateMult: 0.75, damageMult: 1.22, novaDamageScale: 0.45, minionCount: 3, desc: 'Minion hits collapse into micro novas dealing splash damage.' }
            ]);

            const CHAMPION_MINION_ABILITY_THEMES = Object.freeze({
                default: {
                    aura: {
                        inner: 'rgba(150, 200, 255, 0.8)',
                        mid: 'rgba(80, 140, 220, 0.55)',
                        outer: 'rgba(20, 40, 80, 0)'
                    },
                    tail: {
                        start: 'rgba(25, 28, 52, 0)',
                        mid: 'rgba(70, 80, 150, 0.28)',
                        end: 'rgba(150, 160, 245, 0.72)'
                    },
                    ring: 'rgba(150, 160, 240, 0.9)',
                    swirlPrimary: 'rgba(100, 160, 255, 0.8)',
                    swirlSecondary: 'rgba(60, 120, 200, 0.65)',
                    highlight: 'rgba(140, 190, 255, 0.92)',
                    core: {
                        inner: '#f2f6ff',
                        mid: '#96b8ff',
                        outer: '#2a3c6f',
                        edge: '#162138'
                    },
                    thruster: {
                        inner: 'rgba(120, 180, 255, 0.85)',
                        outer: 'rgba(40, 80, 160, 0)'
                    },
                    trail: '#4362a8',
                    spark: '#c7d3ff'
                },
                ember: {
                    aura: {
                        inner: 'rgba(255, 190, 120, 0.82)',
                        mid: 'rgba(255, 110, 40, 0.6)',
                        outer: 'rgba(60, 18, 0, 0)'
                    },
                    tail: {
                        start: 'rgba(75, 18, 0, 0)',
                        mid: 'rgba(255, 120, 45, 0.35)',
                        end: 'rgba(255, 215, 140, 0.82)'
                    },
                    ring: 'rgba(255, 205, 135, 0.92)',
                    swirlPrimary: 'rgba(255, 170, 90, 0.82)',
                    swirlSecondary: 'rgba(255, 120, 40, 0.66)',
                    highlight: 'rgba(255, 200, 120, 0.94)',
                    core: {
                        inner: '#fff3c4',
                        mid: '#ffb347',
                        outer: '#5a1b0a',
                        edge: '#3a0d05'
                    },
                    thruster: {
                        inner: 'rgba(255, 185, 105, 0.88)',
                        outer: 'rgba(90, 20, 0, 0)'
                    },
                    trail: '#b6451a',
                    spark: '#ffe2b2'
                },
                tempest: {
                    aura: {
                        inner: 'rgba(120, 235, 255, 0.8)',
                        mid: 'rgba(45, 160, 220, 0.58)',
                        outer: 'rgba(5, 35, 60, 0)'
                    },
                    tail: {
                        start: 'rgba(8, 30, 52, 0)',
                        mid: 'rgba(60, 185, 240, 0.36)',
                        end: 'rgba(180, 250, 255, 0.84)'
                    },
                    ring: 'rgba(120, 210, 255, 0.9)',
                    swirlPrimary: 'rgba(90, 220, 255, 0.82)',
                    swirlSecondary: 'rgba(60, 160, 220, 0.64)',
                    highlight: 'rgba(150, 240, 255, 0.92)',
                    core: {
                        inner: '#e3feff',
                        mid: '#6ed8ff',
                        outer: '#0f344a',
                        edge: '#082330'
                    },
                    thruster: {
                        inner: 'rgba(115, 230, 255, 0.9)',
                        outer: 'rgba(10, 80, 120, 0)'
                    },
                    trail: '#1b6a92',
                    spark: '#d6faff'
                },
                void: {
                    aura: {
                        inner: 'rgba(205, 165, 255, 0.8)',
                        mid: 'rgba(120, 60, 200, 0.58)',
                        outer: 'rgba(25, 5, 45, 0)'
                    },
                    tail: {
                        start: 'rgba(22, 6, 40, 0)',
                        mid: 'rgba(140, 70, 220, 0.32)',
                        end: 'rgba(230, 190, 255, 0.85)'
                    },
                    ring: 'rgba(210, 170, 255, 0.94)',
                    swirlPrimary: 'rgba(190, 120, 255, 0.84)',
                    swirlSecondary: 'rgba(140, 80, 220, 0.68)',
                    highlight: 'rgba(215, 185, 255, 0.93)',
                    core: {
                        inner: '#f2e8ff',
                        mid: '#b088ff',
                        outer: '#2c1546',
                        edge: '#1b0a2d'
                    },
                    thruster: {
                        inner: 'rgba(200, 140, 255, 0.9)',
                        outer: 'rgba(40, 10, 70, 0)'
                    },
                    trail: '#4e2c7a',
                    spark: '#f0daff'
                }
            });

            const CHAMPION_SKIN_THEMES = Object.freeze({
                default: {
                    key: 'default',
                    label: 'Void Vanguard',
                    body: {
                        top: '#2a3560',
                        mid: '#1e2845',
                        bottom: '#3c4f78',
                        outline: '#6090d0',
                        interior: '#1a2440',
                        accent: '#6090d0'
                    },
                    visor: {
                        left: 'rgba(80, 150, 255, 0.85)',
                        center: 'rgba(120, 180, 255, 0.95)',
                        right: 'rgba(60, 120, 200, 0.8)'
                    },
                    aura: {
                        inner: 'rgba(120, 180, 255, 0.25)',
                        mid: 'rgba(45, 85, 160, 0.5)',
                        outer: 'rgba(15, 25, 65, 0)'
                    },
                    trail: '#78b4ff',
                    bullet: 'rgba(162, 170, 255, 0.94)',
                    bulletPierce: 'rgba(205, 210, 255, 0.96)',
                    minion: {
                        core: '#bcd4ff',
                        aura: '#82a7ff',
                        trail: '#4362a8'
                    }
                },
                solstice: {
                    key: 'solstice',
                    label: 'Solstice Radiant',
                    body: {
                        top: '#6f2c0e',
                        mid: '#b34913',
                        bottom: '#ffb347',
                        outline: '#ffd37f',
                        interior: '#532913',
                        accent: '#ffcc7a'
                    },
                    visor: {
                        left: 'rgba(255, 220, 125, 0.9)',
                        center: 'rgba(255, 244, 190, 0.96)',
                        right: 'rgba(255, 196, 110, 0.85)'
                    },
                    aura: {
                        inner: 'rgba(255, 185, 120, 0.3)',
                        mid: 'rgba(255, 135, 60, 0.55)',
                        outer: 'rgba(80, 30, 0, 0)'
                    },
                    trail: '#ffbd63',
                    bullet: 'rgba(255, 176, 88, 0.96)',
                    bulletPierce: 'rgba(255, 214, 140, 0.98)',
                    minion: {
                        core: '#ffd37f',
                        aura: '#ff9f54',
                        trail: '#c86b1c'
                    }
                },
                tempest: {
                    key: 'tempest',
                    label: 'Tempest Breaker',
                    body: {
                        top: '#10506d',
                        mid: '#0c3b53',
                        bottom: '#1a7794',
                        outline: '#6ad1ff',
                        interior: '#082c3f',
                        accent: '#42c6ff'
                    },
                    visor: {
                        left: 'rgba(150, 240, 255, 0.9)',
                        center: 'rgba(210, 255, 255, 0.96)',
                        right: 'rgba(110, 210, 255, 0.88)'
                    },
                    aura: {
                        inner: 'rgba(90, 200, 255, 0.3)',
                        mid: 'rgba(35, 120, 200, 0.55)',
                        outer: 'rgba(8, 30, 60, 0)'
                    },
                    trail: '#54d8ff',
                    bullet: 'rgba(140, 230, 255, 0.96)',
                    bulletPierce: 'rgba(200, 250, 255, 0.98)',
                    minion: {
                        core: '#aef0ff',
                        aura: '#5cd4ff',
                        trail: '#1b6a92'
                    }
                },
                aurora: {
                    key: 'aurora',
                    label: 'Aurora Helix',
                    body: {
                        top: '#1d2c66',
                        mid: '#243a85',
                        bottom: '#3b64b8',
                        outline: '#9fdfff',
                        interior: '#142046',
                        accent: '#8ff4ff'
                    },
                    visor: {
                        left: 'rgba(120, 220, 255, 0.9)',
                        center: 'rgba(200, 240, 255, 0.96)',
                        right: 'rgba(255, 180, 240, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(120, 220, 255, 0.28)',
                        mid: 'rgba(180, 140, 255, 0.45)',
                        outer: 'rgba(30, 40, 90, 0)'
                    },
                    trail: '#8fe7ff',
                    bullet: 'rgba(180, 235, 255, 0.96)',
                    bulletPierce: 'rgba(225, 250, 255, 0.98)',
                    minion: {
                        core: '#d0f6ff',
                        aura: '#8ec2ff',
                        trail: '#3d6fb4'
                    }
                },
                bastion: {
                    key: 'bastion',
                    label: 'Obsidian Bastion',
                    body: {
                        top: '#1b1f2a',
                        mid: '#141720',
                        bottom: '#343746',
                        outline: '#ff9160',
                        interior: '#0a0d16',
                        accent: '#ffb27a'
                    },
                    visor: {
                        left: 'rgba(255, 150, 90, 0.92)',
                        center: 'rgba(255, 190, 130, 0.95)',
                        right: 'rgba(255, 120, 80, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(255, 150, 90, 0.26)',
                        mid: 'rgba(255, 100, 70, 0.38)',
                        outer: 'rgba(40, 20, 10, 0)'
                    },
                    trail: '#ff8654',
                    bullet: 'rgba(255, 168, 120, 0.96)',
                    bulletPierce: 'rgba(255, 210, 180, 0.98)',
                    minion: {
                        core: '#ffd0b5',
                        aura: '#ff976a',
                        trail: '#703a24'
                    }
                },
                umbra: {
                    key: 'umbra',
                    label: 'Umbral Regent',
                    body: {
                        top: '#301554',
                        mid: '#1f0f37',
                        bottom: '#5b2f8f',
                        outline: '#c29bff',
                        interior: '#160b25',
                        accent: '#a378ff'
                    },
                    visor: {
                        left: 'rgba(200, 160, 255, 0.92)',
                        center: 'rgba(235, 210, 255, 0.97)',
                        right: 'rgba(160, 110, 255, 0.88)'
                    },
                    aura: {
                        inner: 'rgba(190, 150, 255, 0.32)',
                        mid: 'rgba(120, 60, 200, 0.58)',
                        outer: 'rgba(40, 10, 90, 0)'
                    },
                    trail: '#b080ff',
                    bullet: 'rgba(200, 160, 255, 0.96)',
                    bulletPierce: 'rgba(235, 210, 255, 0.98)',
                    minion: {
                        core: '#d5c0ff',
                        aura: '#a070ff',
                        trail: '#4e2c7a'
                    }
                },
                blackgold: {
                    key: 'blackgold',
                    label: 'Black Gold Dynasty',
                    body: {
                        top: '#0a0a0c',
                        mid: '#121214',
                        bottom: '#1a1a1c',
                        outline: '#d4af37',
                        interior: '#060608',
                        accent: '#ffd700'
                    },
                    visor: {
                        left: 'rgba(255, 215, 0, 0.95)',
                        center: 'rgba(255, 235, 100, 0.98)',
                        right: 'rgba(212, 175, 55, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(255, 215, 0, 0.35)',
                        mid: 'rgba(180, 130, 30, 0.65)',
                        outer: 'rgba(30, 25, 5, 0)'
                    },
                    trail: '#ffd700',
                    bullet: 'rgba(255, 215, 0, 0.97)',
                    bulletPierce: 'rgba(255, 240, 120, 0.99)',
                    minion: {
                        core: '#ffe87c',
                        aura: '#d4af37',
                        trail: '#8b7355'
                    }
                },
                crimsonhex: {
                    key: 'crimsonhex',
                    label: 'Crimson Hex Protocol',
                    body: {
                        top: '#8b0000',
                        mid: '#5c0000',
                        bottom: '#b71c1c',
                        outline: '#ff1744',
                        interior: '#3d0000',
                        accent: '#ff5252'
                    },
                    visor: {
                        left: 'rgba(255, 23, 68, 0.94)',
                        center: 'rgba(255, 82, 82, 0.98)',
                        right: 'rgba(198, 40, 40, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(255, 23, 68, 0.38)',
                        mid: 'rgba(183, 28, 28, 0.68)',
                        outer: 'rgba(40, 0, 0, 0)'
                    },
                    trail: '#ff1744',
                    bullet: 'rgba(255, 23, 68, 0.97)',
                    bulletPierce: 'rgba(255, 82, 82, 0.99)',
                    minion: {
                        core: '#ff5252',
                        aura: '#ff1744',
                        trail: '#7f0000'
                    }
                },
                prismrift: {
                    key: 'prismrift',
                    label: 'Prismatic Rift Walker',
                    body: {
                        top: '#00d4ff',
                        mid: '#00bfa5',
                        bottom: '#69f0ae',
                        outline: '#b2ff59',
                        interior: '#004d40',
                        accent: '#64ffda'
                    },
                    visor: {
                        left: 'rgba(0, 191, 165, 0.94)',
                        center: 'rgba(100, 255, 218, 0.98)',
                        right: 'rgba(178, 255, 89, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(0, 212, 255, 0.36)',
                        mid: 'rgba(0, 191, 165, 0.62)',
                        outer: 'rgba(0, 40, 35, 0)'
                    },
                    trail: '#64ffda',
                    bullet: 'rgba(100, 255, 218, 0.97)',
                    bulletPierce: 'rgba(178, 255, 89, 0.99)',
                    minion: {
                        core: '#b2ff59',
                        aura: '#64ffda',
                        trail: '#00897b'
                    }
                },
                ghostflame: {
                    key: 'ghostflame',
                    label: 'Ghost Flame Specter',
                    body: {
                        top: '#1de9b6',
                        mid: '#00c9a7',
                        bottom: '#69f0ae',
                        outline: '#00e5ff',
                        interior: '#004d40',
                        accent: '#18ffff'
                    },
                    visor: {
                        left: 'rgba(0, 229, 255, 0.95)',
                        center: 'rgba(29, 233, 182, 0.98)',
                        right: 'rgba(24, 255, 255, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(29, 233, 182, 0.42)',
                        mid: 'rgba(0, 229, 255, 0.7)',
                        outer: 'rgba(0, 60, 50, 0)'
                    },
                    trail: '#18ffff',
                    bullet: 'rgba(24, 255, 255, 0.97)',
                    bulletPierce: 'rgba(29, 233, 182, 0.99)',
                    minion: {
                        core: '#00e5ff',
                        aura: '#1de9b6',
                        trail: '#00695c'
                    }
                },
                voidcrystal: {
                    key: 'voidcrystal',
                    label: 'Void Crystal Architect',
                    body: {
                        top: '#4a148c',
                        mid: '#6a1b9a',
                        bottom: '#8e24aa',
                        outline: '#e040fb',
                        interior: '#311b92',
                        accent: '#d500f9'
                    },
                    visor: {
                        left: 'rgba(213, 0, 249, 0.94)',
                        center: 'rgba(224, 64, 251, 0.98)',
                        right: 'rgba(170, 0, 255, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(224, 64, 251, 0.4)',
                        mid: 'rgba(142, 36, 170, 0.72)',
                        outer: 'rgba(40, 10, 70, 0)'
                    },
                    trail: '#e040fb',
                    bullet: 'rgba(224, 64, 251, 0.97)',
                    bulletPierce: 'rgba(213, 0, 249, 0.99)',
                    minion: {
                        core: '#e1bee7',
                        aura: '#d500f9',
                        trail: '#4a148c'
                    }
                },
                chromestrike: {
                    key: 'chromestrike',
                    label: 'Chrome Strike Edition',
                    body: {
                        top: '#b0bec5',
                        mid: '#90a4ae',
                        bottom: '#cfd8dc',
                        outline: '#00e5ff',
                        interior: '#607d8b',
                        accent: '#80d8ff'
                    },
                    visor: {
                        left: 'rgba(0, 229, 255, 0.96)',
                        center: 'rgba(128, 216, 255, 0.98)',
                        right: 'rgba(224, 247, 250, 0.94)'
                    },
                    aura: {
                        inner: 'rgba(176, 190, 197, 0.38)',
                        mid: 'rgba(96, 125, 139, 0.65)',
                        outer: 'rgba(30, 40, 50, 0)'
                    },
                    trail: '#80d8ff',
                    bullet: 'rgba(128, 216, 255, 0.97)',
                    bulletPierce: 'rgba(224, 247, 250, 0.99)',
                    minion: {
                        core: '#e0f7fa',
                        aura: '#80d8ff',
                        trail: '#455a64'
                    }
                },
                infernalcore: {
                    key: 'infernalcore',
                    label: 'Infernal Core Juggernaut',
                    body: {
                        top: '#ff3d00',
                        mid: '#bf360c',
                        bottom: '#ff6e40',
                        outline: '#ffab40',
                        interior: '#6d1b00',
                        accent: '#ff9e80'
                    },
                    visor: {
                        left: 'rgba(255, 171, 64, 0.95)',
                        center: 'rgba(255, 158, 128, 0.98)',
                        right: 'rgba(255, 61, 0, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(255, 61, 0, 0.44)',
                        mid: 'rgba(191, 54, 12, 0.76)',
                        outer: 'rgba(60, 15, 0, 0)'
                    },
                    trail: '#ff6e40',
                    bullet: 'rgba(255, 158, 128, 0.97)',
                    bulletPierce: 'rgba(255, 171, 64, 0.99)',
                    minion: {
                        core: '#ffccbc',
                        aura: '#ff6e40',
                        trail: '#bf360c'
                    }
                },
                glacialwarden: {
                    key: 'glacialwarden',
                    label: 'Glacial Warden Sovereign',
                    body: {
                        top: '#0277bd',
                        mid: '#01579b',
                        bottom: '#039be5',
                        outline: '#00b8d4',
                        interior: '#004d73',
                        accent: '#00e5ff'
                    },
                    visor: {
                        left: 'rgba(0, 184, 212, 0.95)',
                        center: 'rgba(0, 229, 255, 0.98)',
                        right: 'rgba(129, 212, 250, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(0, 229, 255, 0.4)',
                        mid: 'rgba(2, 119, 189, 0.7)',
                        outer: 'rgba(0, 30, 60, 0)'
                    },
                    trail: '#00b8d4',
                    bullet: 'rgba(0, 229, 255, 0.97)',
                    bulletPierce: 'rgba(129, 212, 250, 0.99)',
                    minion: {
                        core: '#b3e5fc',
                        aura: '#00b8d4',
                        trail: '#01579b'
                    }
                }
            });

            const CHAMPION_PREVIEW_PROFILES = Object.freeze({
                default: {
                    title: 'Shadow Guardian',
                    classLabel: 'Adaptive Void Sentinel',
                    signature: 'Void harmonics auto-adjust to pilot focus.',
                    icon: 'ðŸ’ ',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Fires a staggered spray of plasma bolts that home on the championâ€™s focus target.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Marks a priority enemy, searing them over time while exposing weak points.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Detonates a short-lived gravity bloom that batters clustered threats.' },
                        { id: 'crescent_ricochet', name: 'Crescent Ricochet', icon: 'ðŸŒ€', description: 'Arcing lances ricochet between up to three close targets.' },
                        { id: 'dash', name: 'Shadow Dash', icon: 'ðŸ’¨', description: 'Short-range blink that phases through threats.' }
                    ],
                    previewEffects: {
                        attack: 'core-flare',
                        special: 'void-rings'
                    }
                },
                beef: {
                    title: 'Shadow Guardian',
                    classLabel: 'Titan Vanguard',
                    signature: 'Armored spearhead that mirrors Juggernaut aggression.',
                    icon: 'ðŸ›¡ï¸',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Heavy plasma bolts stagger foes at medium range.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Marks armored targets to soften them for the next charge.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Blast wave that thins out packs before the titan dives in.' },
                        { id: 'charge', name: 'Titan Charge', icon: 'ðŸ’¥', description: 'Accelerates and slams through clustered targets.' }
                    ],
                    previewEffects: {
                        attack: 'shockwave',
                        special: 'overdrive'
                    }
                },
                rocketman: {
                    title: 'Shadow Guardian',
                    classLabel: 'Aerial Artillery',
                    signature: 'Guided ordnance suite pairs with stealth rocket arrays.',
                    icon: 'ðŸš€',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Rotating salvo keeps targets painted between missile strikes.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Sustained burn keeps high-value targets lit for follow-up rockets.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Area blast softens clustered enemies for stealth rockets.' },
                        { id: 'crescent_ricochet', name: 'Crescent Ricochet', icon: 'ðŸŒ€', description: 'Guided arcs pick off stragglers during reload cycles.' }
                    ],
                    previewEffects: {
                        attack: 'rocket-trail',
                        special: 'missile-burst'
                    }
                },
                voidmancer: {
                    title: 'Shadow Guardian',
                    classLabel: 'Void Arcanist',
                    signature: 'Conducts stormlight and void lasers in alternating cadence.',
                    icon: 'âš¡',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Void-aligned bolts extend the pilotâ€™s pressure window.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Infuses enemies with stormlight for damage over time.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Micro-singularity tears through clustered foes.' },
                        { id: 'crescent_ricochet', name: 'Crescent Ricochet', icon: 'ðŸŒ€', description: 'Half-cycle pulses chain through nearby targets.' },
                        { id: 'dash', name: 'Shadow Dash', icon: 'ðŸ’¨', description: 'Blink strike shreds armor during phase transitions.' }
                    ],
                    previewEffects: {
                        attack: 'lightning-arc',
                        special: 'laser-sweep'
                    }
                }
            });

            const CHAMPION_COMBAT_BLUEPRINT = Object.freeze({
                primary: Object.freeze({
                    id: 'starfall_salvo',
                    name: 'Starfall Salvo',
                    icon: 'âœ¨',
                    cadence: 'steady',
                    targeting: 'single',
                    description: 'A quick three-to-five bolt spray that stays on the championâ€™s current target.',
                    baseCooldown: 0.7,
                    jitter: [0.06, 0.12],
                    execute: championFireStarfallSalvo
                }),
                specials: Object.freeze([
                    Object.freeze({
                        id: 'solar_brand',
                        name: 'Solar Brand',
                        icon: 'â˜€ï¸',
                        cadence: 'damage-over-time',
                        targeting: 'single',
                        baseCooldown: 7.5,
                        initialDelay: 2.5,
                        priority: 4,
                        minTargets: 1,
                        vulnerabilities: { default: 1, boss: 1.12, armored: 1.15, swarm: 0.9 },
                        execute: championExecuteSolarBrand
                    }),
                    Object.freeze({
                        id: 'nebula_bloom',
                        name: 'Nebula Bloom',
                        icon: 'ðŸŒŒ',
                        cadence: 'burst',
                        targeting: 'aoe',
                        baseCooldown: 11,
                        initialDelay: 4.8,
                        priority: 5,
                        minNearby: 3,
                        radius: 165,
                        vulnerabilities: { default: 1, swarm: 1.2, nimble: 1.08, armored: 0.9 },
                        execute: championExecuteNebulaBloom
                    }),
                    Object.freeze({
                        id: 'crescent_ricochet',
                        name: 'Crescent Ricochet',
                        icon: 'ðŸŒ€',
                        cadence: 'half-cycle',
                        targeting: 'multi',
                        baseCooldown: 4.6,
                        initialDelay: 1.8,
                        priority: 3,
                        maxTargets: 3,
                        searchRadius: 240,
                        vulnerabilities: { default: 1, nimble: 1.12, swarm: 1.05, boss: 0.95 },
                        execute: championExecuteCrescentRicochet
                    })
                ])
            });

            const CHAMPION_COMBAT_SUMMARY = Object.freeze([
                {
                    id: 'starfall_salvo',
                    name: 'Starfall Salvo',
                    icon: 'âœ¨',
                    cadence: 'Steady primary attack',
                    targeting: 'Single target',
                    description: 'Fires a staggered spray of plasma bolts that track the championâ€™s focus.'
                },
                {
                    id: 'solar_brand',
                    name: 'Solar Brand',
                    icon: 'â˜€ï¸',
                    cadence: 'Timed burn',
                    targeting: 'Single target',
                    description: 'Brands an enemy with radiant fire, dealing a burst of damage followed by damage over time. Strong against armored units.'
                },
                {
                    id: 'nebula_bloom',
                    name: 'Nebula Bloom',
                    icon: 'ðŸŒŒ',
                    cadence: 'Burst detonation',
                    targeting: 'Area of effect',
                    description: 'Collapses a gravity bloom that batters clustered enemies. Excels at clearing swarms.'
                },
                {
                    id: 'crescent_ricochet',
                    name: 'Crescent Ricochet',
                    icon: 'ðŸŒ€',
                    cadence: 'Half-cycle strike',
                    targeting: 'Capped multi-target (3)',
                    description: 'Arc blades ricochet between up to three nearby foes, prioritising nimble threats.'
                }
            ]);

            function cloneChampionAbility(ability) {
                if (!ability) return null;
                return {
                    ...ability,
                    _baseCooldown: ability.baseCooldown,
                    timer: ability.initialDelay != null ? ability.initialDelay : ability.baseCooldown
                };
            }

            function createChampionCombatProfile(overrides = {}) {
                const primaryBlueprint = CHAMPION_COMBAT_BLUEPRINT.primary || {};
                const primary = {
                    ...primaryBlueprint,
                    _baseCooldown: primaryBlueprint.baseCooldown
                };
                const specials = (CHAMPION_COMBAT_BLUEPRINT.specials || []).map(cloneChampionAbility);
                return {
                    primary,
                    specials,
                    specialCooldownMult: overrides.specialCooldownMult ?? 1,
                    lastAbilityId: null
                };
            }

            function ensureChampionCombatProfile(champion, overrides = {}) {
                if (!champion) return null;
                if (!champion.combatProfile) {
                    champion.combatProfile = createChampionCombatProfile(overrides);
                }
                return champion.combatProfile;
            }

            function configureChampionCombatProfile(champion, cadenceOption = null) {
                const profile = ensureChampionCombatProfile(champion);
                if (!profile) return null;

                const cadenceMult = cadenceOption?.specialCooldownMult ?? profile.specialCooldownMult ?? 1;
                const previousMult = profile.specialCooldownMult ?? 1;
                profile.specialCooldownMult = cadenceMult;

                if (profile.primary) {
                    const base = champion.fireCooldown ?? profile.primary.baseCooldown ?? profile.primary._baseCooldown ?? PLAYER_CHAMPION_CONFIG.baseFireCooldown;
                    profile.primary.baseCooldown = base;
                }

                if (Array.isArray(profile.specials)) {
                    profile.specials.forEach(special => {
                        if (!special) return;
                        const base = special._baseCooldown ?? special.baseCooldown ?? 1;
                        special.baseCooldown = base;
                        if (special.timer != null) {
                            if (previousMult !== cadenceMult && special.timer > 0) {
                                const normalized = special.timer / Math.max(0.0001, previousMult);
                                special.timer = Math.min(normalized * cadenceMult, base * cadenceMult);
                            } else {
                                special.timer = Math.min(special.timer, base * cadenceMult);
                            }
                        } else {
                            special.timer = base * cadenceMult;
                        }
                    });
                }

                return profile;
            }

            function classifyEnemyForChampionVulnerabilities(enemy) {
                const tags = new Set();
                if (!enemy) return tags;

                const hpMax = ensureFiniteNumber(enemy.hpMax ?? enemy.maxHp ?? enemy.hp ?? 0, 0);
                const radius = ensureFiniteNumber(enemy.r ?? enemy.radius ?? 0, 0);
                const shield = ensureFiniteNumber(enemy.shield ?? enemy.shieldHp ?? 0, 0);
                const speed = ensureFiniteNumber(enemy.speed ?? enemy.baseSpeed ?? enemy.moveSpeed ?? 0, 0);

                if (enemy === store.boss) {
                    tags.add('boss');
                    tags.add('armored');
                }

                if (hpMax >= 900 || radius >= 34) tags.add('behemoth');
                if (hpMax >= 600 || radius >= 28) tags.add('armored');
                else if (hpMax >= 280 || radius >= 22) tags.add('elite');
                if (hpMax <= 120 || radius <= 14) tags.add('swarm');

                const vx = ensureFiniteNumber(enemy.vx ?? enemy.hvx ?? 0, 0);
                const vy = ensureFiniteNumber(enemy.vy ?? enemy.hvy ?? 0, 0);
                if (speed >= 260 || (vx * vx + vy * vy) > 260 * 260) tags.add('nimble');
                if (shield > 0 || enemy.shielded) tags.add('shielded');
                if (enemy.spawnGroupSize >= 4) tags.add('pack');
                if (enemy.isFlying || enemy.flying || enemy.flight) tags.add('air');

                return tags;
            }

            function applyChampionVulnerabilityScaling(baseDamage, enemy, profile) {
                if (!profile || baseDamage <= 0) return baseDamage;
                const tags = classifyEnemyForChampionVulnerabilities(enemy);
                const map = profile.tags || profile;
                let multiplier = typeof map.default === 'number' ? map.default : 1;

                tags.forEach(tag => {
                    if (typeof map[tag] === 'number') {
                        multiplier *= map[tag];
                    }
                });

                let result = baseDamage * multiplier;
                if (typeof profile.floor === 'number') {
                    result = Math.max(profile.floor, result);
                }
                if (typeof profile.ceiling === 'number') {
                    result = Math.min(profile.ceiling, result);
                }
                return result;
            }

            function countEnemiesAround(x, y, radius, { includeBoss = true } = {}) {
                let count = 0;
                forEachEnemyNearby(x, y, radius, enemy => {
                    if (!enemy || enemy.dead || enemy.hp <= 0) return false;
                    count++;
                    return false;
                });

                if (includeBoss && store.boss && !store.boss.dead) {
                    const boss = store.boss;
                    const dx = boss.x - x;
                    const dy = boss.y - y;
                    const bossRadius = radius + (boss.r || 60);
                    if (dx * dx + dy * dy <= bossRadius * bossRadius) {
                        count++;
                    }
                }

                return count;
            }

            function selectChampionSpecialAbility(champion, target, context = {}) {
                if (!champion || !champion.combatProfile) return null;
                const { combatProfile } = champion;
                if (!combatProfile.specials || combatProfile.specials.length === 0) return null;

                const targetTraits = context.targetTraits || classifyEnemyForChampionVulnerabilities(target);
                const nearbyCount = context.nearbyCount ?? (target ? countEnemiesAround(target.x, target.y, context.scanRadius || 220) : 0);
                let best = null;
                let bestScore = -Infinity;

                combatProfile.specials.forEach(special => {
                    if (!special || special.timer > 0) return;
                    if (special.targeting === 'single' && !target) return;

                    const minTargets = special.minTargets ?? 0;
                    if (minTargets > 0 && nearbyCount < minTargets) return;

                    let score = special.priority ?? 0;

                    if (special.targeting === 'aoe') {
                        const required = special.minNearby ?? 3;
                        const densityBonus = Math.max(0, nearbyCount - required + 1);
                        score += densityBonus * 1.2;
                    } else if (special.targeting === 'multi') {
                        const hits = Math.min(special.maxTargets ?? 3, Math.max(nearbyCount, target ? 1 : 0));
                        score += hits * 0.9;
                    } else if (special.targeting === 'single') {
                        if (targetTraits.has('boss') || targetTraits.has('armored')) score += 2.8;
                        if (targetTraits.has('nimble')) score += 0.6;
                    }

                    if (combatProfile.lastAbilityId && combatProfile.lastAbilityId === special.id) {
                        score -= 0.5; // discourage repeating the same special immediately
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        best = special;
                    }
                });

                return best;
            }

            function executeChampionAbility(champion, ability, context = {}) {
                if (!champion || !ability || typeof ability.execute !== 'function') return null;
                const profile = ensureChampionCombatProfile(champion);
                const cadenceMult = profile?.specialCooldownMult ?? 1;
                const baseCooldown = ability._baseCooldown ?? ability.baseCooldown ?? 1.2;

                const result = ability.execute(champion, {
                    ...context,
                    ability,
                    vulnerabilityProfile: ability.vulnerabilities || null,
                    cadenceMult
                }) || {};

                const cooldown = (typeof result.cooldown === 'number' ? result.cooldown : baseCooldown) * cadenceMult;
                ability.timer = cooldown;
                profile.lastAbilityId = ability.id;

                const baseDelay = typeof result.fireTimer === 'number' ? result.fireTimer : (ability.postFireDelay ?? champion.fireCooldown ?? baseCooldown);
                const jitterRange = result.jitterRange || ability.jitter || [0.05, 0.11];
                let jitter = 0;
                if (typeof result.jitter === 'number') {
                    jitter = result.jitter;
                } else if (Array.isArray(jitterRange)) {
                    const [min = 0, max = 0] = jitterRange;
                    jitter = min + Math.random() * Math.max(0, max - min);
                } else if (typeof jitterRange === 'number') {
                    jitter = jitterRange;
                }

                champion.fireTimer = Math.max(0.2, baseDelay + jitter);
                return result;
            }

            function executeChampionPrimary(champion, target, context = {}) {
                if (!champion) return null;
                const profile = ensureChampionCombatProfile(champion);
                if (!profile || !profile.primary || typeof profile.primary.execute !== 'function') return null;

                const primary = profile.primary;
                const baseDelay = champion.fireCooldown ?? primary.baseCooldown ?? PLAYER_CHAMPION_CONFIG.baseFireCooldown;
                const result = primary.execute(champion, {
                    ...context,
                    target,
                    ability: primary,
                    vulnerabilityProfile: primary.vulnerabilities || null
                }) || {};

                const jitterRange = result.jitterRange || primary.jitter || [0.06, 0.12];
                let jitter = 0;
                if (typeof result.jitter === 'number') {
                    jitter = result.jitter;
                } else if (Array.isArray(jitterRange)) {
                    const [min = 0, max = 0] = jitterRange;
                    jitter = min + Math.random() * Math.max(0, max - min);
                } else if (typeof jitterRange === 'number') {
                    jitter = jitterRange;
                }

                const nextDelay = typeof result.fireTimer === 'number' ? result.fireTimer : baseDelay;
                champion.fireTimer = Math.max(0.2, nextDelay + jitter);
                profile.lastAbilityId = primary.id;
                return result;
            }

            const CHAMPION_SKIN_OPTIONS = Object.freeze([
                { id: 'default', name: 'Void Vanguard', icon: 'ðŸ’ ', cost: 0, desc: 'Baseline guardian plating.', theme: 'default' },
                { id: 'solstice', name: 'Solstice Radiant', icon: 'ðŸŒž', cost: 120, desc: 'Gilded solar alloys with ember trails.', theme: 'solstice' },
                { id: 'tempest', name: 'Tempest Breaker', icon: 'ðŸŒ©ï¸', cost: 120, desc: 'Ionized teal plating that crackles with stormlight.', theme: 'tempest' },
                { id: 'aurora', name: 'Aurora Helix', icon: 'ðŸŒŒ', cost: 140, desc: 'Prismatic plating braided from polar light flows.', theme: 'aurora' },
                { id: 'bastion', name: 'Obsidian Bastion', icon: 'ðŸ›¡ï¸', cost: 180, desc: 'Heavy dusk armor with molten core vents.', theme: 'bastion' },
                { id: 'umbra', name: 'Umbral Regent', icon: 'ðŸŒ‘', cost: 150, desc: 'Abyssal crystal armor forged from void echoes.', theme: 'umbra' },
                { id: 'blackgold', name: 'Black Gold Dynasty', icon: 'ðŸ‘‘', cost: 250, desc: 'Obsidian chassis inlaid with 24K quantum gold tracery.', theme: 'blackgold' },
                { id: 'crimsonhex', name: 'Crimson Hex Protocol', icon: 'â¬¢', cost: 200, desc: 'Crimson war-forged armor with hexagonal energy matrices.', theme: 'crimsonhex' },
                { id: 'prismrift', name: 'Prismatic Rift Walker', icon: 'ðŸŒˆ', cost: 220, desc: 'Reality-bending chrome that shifts through the spectrum.', theme: 'prismrift' },
                { id: 'ghostflame', name: 'Ghost Flame Specter', icon: 'ðŸ‘»', cost: 240, desc: 'Spectral cyan plating wreathed in ethereal ghost fire.', theme: 'ghostflame' },
                { id: 'voidcrystal', name: 'Void Crystal Architect', icon: 'ðŸ’Ž', cost: 260, desc: 'Crystalline void lattice forged from dimensional fractures.', theme: 'voidcrystal' },
                { id: 'chromestrike', name: 'Chrome Strike Edition', icon: 'âš¡', cost: 280, desc: 'Mirror-finish chromium with electric cyan highlights.', theme: 'chromestrike' },
                { id: 'infernalcore', name: 'Infernal Core Juggernaut', icon: 'ðŸ”¥', cost: 300, desc: 'Molten core reactor armor bleeding thermal death glow.', theme: 'infernalcore' },
                { id: 'glacialwarden', name: 'Glacial Warden Sovereign', icon: 'â„ï¸', cost: 220, desc: 'Frost-forged adamant plates radiating absolute zero.', theme: 'glacialwarden' }
            ]);

            const CHAMPION_SKIN_OPTION_MAP = Object.freeze(Object.fromEntries(CHAMPION_SKIN_OPTIONS.map(s => [s.id, s])));

            const CHAMPION_PRESET_SCHEMA_VERSION = 1;
            const CHAMPION_PRESET_MODULE_IDS = Object.freeze([
                'precision_strike',
                'kinetic_swarm',
                'inferno_burst',
                'plasma_stream',
                'focus_beam',
                'scatter_array',
                'arc_cannon',
                'storm_grid',
                'ember',
                'tempest',
                'void'
            ]);
            const CHAMPION_PRESET_MODULE_CHOICES = Object.freeze(['default', ...CHAMPION_PRESET_MODULE_IDS]);
            const CHAMPION_PRESET_SKIN_IDS = Object.freeze(CHAMPION_SKIN_OPTIONS.map(opt => opt.id));
            const CHAMPION_PRESET_UPGRADE_KEYS = Object.freeze([
                'champion_health',
                'champion_damage',
                'champion_speed',
                'champion_shield',
                'champion_regen'
            ]);

            function captureChampionPreset(player = store.player) {
                if (!player) return null;
                const upgrades = ensureChampionUpgradeState(player);
                const upgradeLevels = player.upgradeLevels || {};
                const champion = store.playerChampion && !store.playerChampion.dead ? store.playerChampion : null;

                const unlockedModules = CHAMPION_PRESET_MODULE_IDS.filter(id => upgrades?.unlockedAttacks && upgrades.unlockedAttacks[id]);
                const unlockedSkins = CHAMPION_PRESET_SKIN_IDS.filter(id => upgrades?.unlockedSkins && upgrades.unlockedSkins[id]);
                if (!unlockedSkins.includes('default')) unlockedSkins.push('default');

                const levelSnapshot = {};
                CHAMPION_PRESET_UPGRADE_KEYS.forEach(key => {
                    const value = upgradeLevels[key] || 0;
                    if (value > 0) {
                        levelSnapshot[key] = value;
                    }
                });

                return {
                    version: CHAMPION_PRESET_SCHEMA_VERSION,
                    championUnlocked: !!player.championUnlocked,
                    attackModule: upgrades.attackModule || 'default',
                    cadenceLevel: upgrades.cadenceLevel || 0,
                    minionProtocols: upgrades.minionProtocols || 0,
                    skin: upgrades.skin || 'default',
                    unlockedAttacks: unlockedModules,
                    unlockedSkins,
                    upgradeLevels: levelSnapshot,
                    championLevel: champion?.level || player.championPresetLevel || 1,
                    championXp: champion?.xp || player.championPresetXp || 0
                };
            }

            function encodeChampionPresetCode(preset) {
                if (!preset) return null;

                const modulesSet = new Set(Array.isArray(preset.unlockedAttacks) ? preset.unlockedAttacks : (preset.unlockedModules || []));
                const skinsSet = new Set(Array.isArray(preset.unlockedSkins) ? preset.unlockedSkins : []);
                if (preset.attackModule && preset.attackModule !== 'default') {
                    modulesSet.add(preset.attackModule);
                }
                if (preset.skin) {
                    skinsSet.add(preset.skin);
                }
                skinsSet.add('default');

                const encodeIndex = (value, list, fallbackIndex = 0) => {
                    const idx = list.indexOf(value);
                    return idx >= 0 ? idx : fallbackIndex;
                };
                const encodeBitset = (list, activeSet) => {
                    let mask = 0;
                    list.forEach((id, idx) => {
                        if (activeSet.has(id)) {
                            mask |= (1 << idx);
                        }
                    });
                    return mask.toString(36).toUpperCase();
                };

                const moduleIndex = encodeIndex(preset.attackModule, CHAMPION_PRESET_MODULE_CHOICES, 0);
                const cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, Math.floor(preset.cadenceLevel || 0)));
                const protocolLevel = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, Math.floor(preset.minionProtocols || 0)));
                const skinIndex = encodeIndex(preset.skin, CHAMPION_PRESET_SKIN_IDS, 0);
                const championLevel = Math.max(1, Math.floor(preset.championLevel || 1));
                const championXp = Math.max(0, Math.floor(preset.championXp || 0));

                const upgradeSegments = CHAMPION_PRESET_UPGRADE_KEYS.map(key => {
                    const val = Math.max(0, Math.floor((preset.upgradeLevels && preset.upgradeLevels[key]) || 0));
                    return val.toString(36).toUpperCase();
                }).join('.');

                const parts = [
                    `VN${CHAMPION_PRESET_SCHEMA_VERSION.toString(36).toUpperCase()}`,
                    `AM${moduleIndex.toString(36).toUpperCase()}`,
                    `UM${encodeBitset(CHAMPION_PRESET_MODULE_IDS, modulesSet)}`,
                    `CD${cadenceLevel.toString(36).toUpperCase()}`,
                    `PR${protocolLevel.toString(36).toUpperCase()}`,
                    `SK${skinIndex.toString(36).toUpperCase()}`,
                    `US${encodeBitset(CHAMPION_PRESET_SKIN_IDS, skinsSet)}`,
                    `CU${preset.championUnlocked ? '1' : '0'}`,
                    `LV${championLevel.toString(36).toUpperCase()}`,
                    `XP${championXp.toString(36).toUpperCase()}`,
                    `UG${upgradeSegments}`
                ];
                return parts.join('-');
            }

            function decodeChampionPresetCode(code) {
                if (typeof code !== 'string') return null;
                const trimmed = code.trim();
                if (!trimmed) return null;
                const segments = trimmed.split('-');

                const data = {
                    version: CHAMPION_PRESET_SCHEMA_VERSION,
                    championUnlocked: false,
                    attackModule: 'default',
                    cadenceLevel: 0,
                    minionProtocols: 0,
                    skin: 'default',
                    unlockedAttacks: [],
                    unlockedSkins: ['default'],
                    upgradeLevels: {},
                    championLevel: 1,
                    championXp: 0
                };

                const decodeIndex = (value, list, fallbackValue) => {
                    const idx = parseInt(value || '0', 36);
                    if (!Number.isFinite(idx) || idx < 0) return fallbackValue;
                    return list[idx] || fallbackValue;
                };

                const decodeBitset = (value, list) => {
                    const mask = parseInt(value || '0', 36);
                    if (!Number.isFinite(mask) || mask <= 0) return [];
                    const result = [];
                    list.forEach((id, idx) => {
                        if (mask & (1 << idx)) {
                            result.push(id);
                        }
                    });
                    return result;
                };

                let version = CHAMPION_PRESET_SCHEMA_VERSION;
                for (const segment of segments) {
                    if (!segment) continue;
                    const key = segment.slice(0, 2);
                    const payload = segment.slice(2);
                    switch (key) {
                        case 'VN':
                            version = parseInt(payload || '1', 36);
                            break;
                        case 'AM':
                            data.attackModule = decodeIndex(payload, CHAMPION_PRESET_MODULE_CHOICES, 'default');
                            break;
                        case 'UM':
                            data.unlockedAttacks = decodeBitset(payload, CHAMPION_PRESET_MODULE_IDS);
                            break;
                        case 'CD':
                            data.cadenceLevel = Math.max(0, parseInt(payload || '0', 36) || 0);
                            break;
                        case 'PR':
                            data.minionProtocols = Math.max(0, parseInt(payload || '0', 36) || 0);
                            break;
                        case 'SK':
                            data.skin = decodeIndex(payload, CHAMPION_PRESET_SKIN_IDS, 'default');
                            break;
                        case 'US':
                            data.unlockedSkins = decodeBitset(payload, CHAMPION_PRESET_SKIN_IDS);
                            break;
                        case 'CU':
                            data.championUnlocked = payload === '1';
                            break;
                        case 'LV':
                            data.championLevel = Math.max(1, parseInt(payload || '1', 36) || 1);
                            break;
                        case 'XP':
                            data.championXp = Math.max(0, parseInt(payload || '0', 36) || 0);
                            break;
                        case 'UG': {
                            const values = payload.split('.');
                            const upgrades = {};
                            CHAMPION_PRESET_UPGRADE_KEYS.forEach((keyName, idx) => {
                                const raw = values[idx] || '0';
                                const level = Math.max(0, parseInt(raw || '0', 36) || 0);
                                if (level > 0) {
                                    upgrades[keyName] = level;
                                }
                            });
                            data.upgradeLevels = upgrades;
                            break;
                        }
                        default:
                            break;
                    }
                }

                if (!Number.isFinite(version) || version < 1 || version > CHAMPION_PRESET_SCHEMA_VERSION) {
                    return null;
                }

                if (!Array.isArray(data.unlockedAttacks)) data.unlockedAttacks = [];
                if (!Array.isArray(data.unlockedSkins)) data.unlockedSkins = ['default'];
                if (!data.unlockedSkins.includes('default')) data.unlockedSkins.push('default');

                data.unlockedAttacks = Array.from(new Set(data.unlockedAttacks));
                data.unlockedSkins = Array.from(new Set(data.unlockedSkins));
                data.attackModule = CHAMPION_PRESET_MODULE_CHOICES.includes(data.attackModule) ? data.attackModule : 'default';
                if (!CHAMPION_PRESET_SKIN_IDS.includes(data.skin)) data.skin = 'default';
                data.cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, data.cadenceLevel));
                data.minionProtocols = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, data.minionProtocols));
                data.championLevel = Math.max(1, data.championLevel);
                data.championXp = Math.max(0, data.championXp);
                return data;
            }

            function applyChampionPresetToPlayer(preset, { player = store.player, applyChampion = true } = {}) {
                if (!preset || !player) return false;

                const upgrades = ensureChampionUpgradeState(player);
                const modulesSet = new Set(Array.isArray(preset.unlockedAttacks) ? preset.unlockedAttacks : []);
                const skinsSet = new Set(Array.isArray(preset.unlockedSkins) ? preset.unlockedSkins : []);
                if (preset.attackModule && preset.attackModule !== 'default') {
                    modulesSet.add(preset.attackModule);
                }
                if (preset.skin) {
                    skinsSet.add(preset.skin);
                }
                skinsSet.add('default');

                if (!upgrades.unlockedAttacks || typeof upgrades.unlockedAttacks !== 'object') {
                    upgrades.unlockedAttacks = {};
                }
                CHAMPION_PRESET_MODULE_IDS.forEach(id => {
                    upgrades.unlockedAttacks[id] = modulesSet.has(id);
                });

                upgrades.attackModule = CHAMPION_PRESET_MODULE_CHOICES.includes(preset.attackModule) && (preset.attackModule === 'default' || modulesSet.has(preset.attackModule))
                    ? preset.attackModule
                    : 'default';
                upgrades.cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, Math.floor(preset.cadenceLevel || 0)));
                upgrades.minionProtocols = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, Math.floor(preset.minionProtocols || 0)));

                if (!upgrades.unlockedSkins || typeof upgrades.unlockedSkins !== 'object') {
                    upgrades.unlockedSkins = { default: true };
                }
                CHAMPION_PRESET_SKIN_IDS.forEach(id => {
                    upgrades.unlockedSkins[id] = skinsSet.has(id);
                });
                upgrades.skin = CHAMPION_PRESET_SKIN_IDS.includes(preset.skin) ? preset.skin : 'default';
                if (!upgrades.unlockedSkins[upgrades.skin]) {
                    upgrades.skin = 'default';
                }

                player.championUnlocked = preset.championUnlocked || player.championUnlocked;
                player.upgradeLevels = player.upgradeLevels || {};
                CHAMPION_PRESET_UPGRADE_KEYS.forEach(key => {
                    const value = Math.max(0, Math.floor((preset.upgradeLevels && preset.upgradeLevels[key]) || 0));
                    player.upgradeLevels[key] = value;
                });

                player.championPresetLevel = Math.max(1, Math.floor(preset.championLevel || player.championPresetLevel || 1));
                player.championPresetXp = Math.max(0, Math.floor(preset.championXp || player.championPresetXp || 0));

                store.championPresetCache = {
                    version: preset.version || CHAMPION_PRESET_SCHEMA_VERSION,
                    championUnlocked: player.championUnlocked,
                    attackModule: upgrades.attackModule,
                    cadenceLevel: upgrades.cadenceLevel,
                    minionProtocols: upgrades.minionProtocols,
                    skin: upgrades.skin,
                    unlockedAttacks: Array.from(modulesSet),
                    unlockedSkins: Array.from(skinsSet),
                    upgradeLevels: { ...player.upgradeLevels },
                    championLevel: player.championPresetLevel,
                    championXp: player.championPresetXp
                };

                if (applyChampion && store.playerChampion && !store.playerChampion.dead) {
                    const champion = store.playerChampion;
                    champion.level = player.championPresetLevel;
                    champion.xp = player.championPresetXp;
                    champion.damageScale = 1 + (champion.level - 1) * 0.25;
                    champion.fireCooldownBase = Math.max(0.6, PLAYER_CHAMPION_CONFIG.baseFireCooldown * Math.pow(0.9, champion.level - 1));
                    champion.dashCooldownBase = Math.max(1.5, PLAYER_CHAMPION_CONFIG.baseDashCooldown * Math.pow(0.92, champion.level - 1));
                    champion.momentumBase = Math.min(6.2, 4.1 + 0.25 * (champion.level - 1));
                    champion.momentum = champion.momentumBase;
                    champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + champion.level * 6;
                    champion.guardRadius = champion.guardRadiusBase;
                    champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (champion.level - 1) * 0.08;
                    champion.angularSpeed = champion.angularSpeedBase;
                    champion.volleySize = Math.min(7, 4 + champion.level);
                    champion.volleySpread = Math.min(0.22, 0.16 + (champion.level - 1) * 0.015);
                    champion.roamTimer = 0;
                }

                notifyChampionLoadoutChanged({ refreshMinions: true });
                if (applyChampion && store.playerChampion && !store.playerChampion.dead) {
                    refreshChampionMinionsFromState(store.playerChampion);
                }
                return true;
            }

            function getChampionAttackCatalogue(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const unlockedAttacks = state?.unlockedAttacks || {};
                return CHAMPION_ATTACK_MODULES.map(mod => ({
                    ...mod,
                    unlocked: !!unlockedAttacks[mod.id],
                    active: state.attackModule === mod.id
                }));
            }

            function getNextChampionAttackUnlock(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const modules = getChampionAttackCatalogue(state);
                const nextModule = modules.find(mod => !mod.unlocked);
                if (!nextModule) return null;
                return {
                    module: nextModule,
                    modules,
                    unlockedCount: modules.filter(mod => mod.unlocked).length,
                    total: modules.length,
                    cost: nextModule.cost
                };
            }

            function getChampionCadenceOptions(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                return CHAMPION_CADENCE_LEVELS.map(option => ({
                    ...option,
                    owned: state.cadenceLevel >= option.level,
                    active: state.cadenceLevel === option.level
                }));
            }

            function getNextChampionCadenceUpgrade(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const options = getChampionCadenceOptions(state);
                const next = options.find(option => option.level > state.cadenceLevel);
                if (!next) return null;
                const current = options.find(option => option.level === state.cadenceLevel) || options[0];
                return { option: next, options, current };
            }

            function getChampionProtocolOptions(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                return CHAMPION_MINION_PROTOCOL_LEVELS.map(option => ({
                    ...option,
                    owned: state.minionProtocols >= option.level,
                    active: state.minionProtocols === option.level
                }));
            }

            function getNextChampionProtocolUpgrade(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const options = getChampionProtocolOptions(state);
                const next = options.find(option => option.level > state.minionProtocols);
                if (!next) return null;
                const current = options.find(option => option.level === state.minionProtocols) || options[0];
                return { option: next, options, current };
            }

            function getChampionSkinCatalogue(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const unlockedSkins = state.unlockedSkins || {};
                return CHAMPION_SKIN_OPTIONS.map(option => ({
                    ...option,
                    unlocked: !!unlockedSkins[option.id],
                    active: state.skin === option.id
                }));
            }

            function getNextChampionSkinUnlock(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const catalogue = getChampionSkinCatalogue(state);
                const next = catalogue.find(option => !option.unlocked);
                if (!next) return null;
                const active = catalogue.find(option => option.active) || catalogue[0];
                return { option: next, catalogue, active };
            }

            function notifyChampionLoadoutChanged({ refreshMinions = true } = {}) {
                if (store.playerChampion && !store.playerChampion.dead) {
                    applyChampionUpgradeLoadout(store.playerChampion, { refreshMinions });
                }
                updateChampionQuickStatus();
            }

            function updateChampionQuickStatus() {
                const container = typeof document !== 'undefined' ? q('championQuickStatus') : null;
                if (!container) return;

                if (!store.player?.championUnlocked) {
                    container.classList.add('locked');
                    container.innerHTML = '<div><strong>Champion:</strong> Secure the Shadow Sigil to bind a guardian.</div>';
                    return;
                }

                const state = getChampionUpgradeState();
                const modules = getChampionAttackCatalogue(state);
                const attack = CHAMPION_ATTACK_MODULE_MAP[state.attackModule] || { name: 'Base Volley' };
                const cadence = CHAMPION_CADENCE_LEVELS[state.cadenceLevel] || CHAMPION_CADENCE_LEVELS[0];
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[state.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const unlockedCount = modules.filter(mod => mod.unlocked).length;

                container.classList.remove('locked');
                container.innerHTML = [
                    `<div><strong>Module:</strong> ${escapeHtml(attack.name || 'Base Volley')} <span style="opacity:0.7;">(${unlockedCount}/${modules.length} unlocked)</span></div>`,
                    `<div><strong>Cadence:</strong> ${escapeHtml(cadence.name)} <span style="opacity:0.7;">(Lv ${cadence.level})</span></div>`,
                    `<div><strong>Protocols:</strong> ${escapeHtml(protocol.name)} <span style="opacity:0.7;">(Lv ${protocol.level})</span></div>`
                ].join('');
            }

            function createDefaultChampionUpgradeState() {
                return {
                    attackModule: 'default',
                    unlockedAttacks: {
                        // Legacy modules (for backwards compatibility)
                        ember: false, tempest: false, void: false,
                        // New attack modules - some available for testing
                        precision_strike: true, kinetic_swarm: true,
                        inferno_burst: true, plasma_stream: true,
                        focus_beam: false, scatter_array: false,
                        arc_cannon: true, storm_grid: false
                    },
                    cadenceLevel: 0,
                    minionProtocols: 0,
                    skin: 'default',
                    unlockedSkins: { default: true }
                };
            }

            function ensureChampionUpgradeState(player = store.player) {
                if (!player) return createDefaultChampionUpgradeState();
                if (!player.championUpgrades || typeof player.championUpgrades !== 'object') {
                    player.championUpgrades = createDefaultChampionUpgradeState();
                }
                const state = player.championUpgrades;
                if (!state.unlockedAttacks) {
                    state.unlockedAttacks = {
                        ember: false, tempest: false, void: false,
                        precision_strike: true, kinetic_swarm: true,
                        inferno_burst: true, plasma_stream: true,
                        focus_beam: false, scatter_array: false,
                        arc_cannon: true, storm_grid: false
                    };
                } else {
                    // Migrate existing saves and ensure new modules have defaults
                    state.unlockedAttacks.ember = !!state.unlockedAttacks.ember;
                    state.unlockedAttacks.tempest = !!state.unlockedAttacks.tempest;
                    state.unlockedAttacks.void = !!state.unlockedAttacks.void;
                    // Add new modules with default availability for testing
                    if (state.unlockedAttacks.precision_strike === undefined) state.unlockedAttacks.precision_strike = true;
                    if (state.unlockedAttacks.kinetic_swarm === undefined) state.unlockedAttacks.kinetic_swarm = true;
                    if (state.unlockedAttacks.inferno_burst === undefined) state.unlockedAttacks.inferno_burst = true;
                    if (state.unlockedAttacks.plasma_stream === undefined) state.unlockedAttacks.plasma_stream = true;
                    if (state.unlockedAttacks.focus_beam === undefined) state.unlockedAttacks.focus_beam = false;
                    if (state.unlockedAttacks.scatter_array === undefined) state.unlockedAttacks.scatter_array = false;
                    if (state.unlockedAttacks.arc_cannon === undefined) state.unlockedAttacks.arc_cannon = true;
                    if (state.unlockedAttacks.storm_grid === undefined) state.unlockedAttacks.storm_grid = false;
                }
                if (typeof state.attackModule !== 'string' || !CHAMPION_ATTACK_MODULE_MAP[state.attackModule]) {
                    state.attackModule = 'default';
                }
                if (typeof state.cadenceLevel !== 'number' || Number.isNaN(state.cadenceLevel)) {
                    state.cadenceLevel = 0;
                }
                state.cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, Math.floor(state.cadenceLevel)));
                if (typeof state.minionProtocols !== 'number' || Number.isNaN(state.minionProtocols)) {
                    state.minionProtocols = 0;
                }
                state.minionProtocols = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, Math.floor(state.minionProtocols)));
                if (!state.unlockedSkins || typeof state.unlockedSkins !== 'object') {
                    state.unlockedSkins = { default: true };
                } else {
                    state.unlockedSkins.default = true;
                }
                if (typeof state.skin !== 'string' || !CHAMPION_SKIN_OPTION_MAP[state.skin]) {
                    state.skin = 'default';
                }
                return state;
            }

            function getChampionUpgradeState(player = store.player) {
                return ensureChampionUpgradeState(player);
            }

            function getChampionSkinTheme(key) {
                return CHAMPION_SKIN_THEMES[key] || CHAMPION_SKIN_THEMES.default;
            }

            function getChampionMinionAbilityTheme(moduleId) {
                const key = (moduleId && CHAMPION_MINION_ABILITY_THEMES[moduleId]) ? moduleId : 'default';
                return CHAMPION_MINION_ABILITY_THEMES[key] || CHAMPION_MINION_ABILITY_THEMES.default;
            }

            function refreshChampionMinionsFromState(owner, tuning = null) {
                if (!owner || !Array.isArray(store.championMinions) || !store.championMinions.length) {
                    return;
                }
                const state = getChampionUpgradeState();
                const protocol = tuning || (CHAMPION_MINION_PROTOCOL_LEVELS[state.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0]);
                const abilityModule = owner.attackModule || state.attackModule || 'default';
                const abilityTheme = getChampionMinionAbilityTheme(abilityModule);
                const theme = owner.skinTheme ? owner.skinTheme.minion : getChampionSkinTheme(state.skin || 'default').minion;
                const ownerLevel = owner.level || 1;
                const baseCooldown = Math.max(0.9, 1.4 - ownerLevel * 0.12);
                const baseDamageScale = 1 + Math.max(0, ownerLevel - 1) * 0.18;

                for (let i = store.championMinions.length - 1; i >= 0; i--) {
                    const minion = store.championMinions[i];
                    if (!minion || minion.dead) continue;
                    minion.fireCooldownBase = baseCooldown;
                    minion.fireCooldown = Math.max(0.24, minion.fireCooldownBase * (protocol.fireRateMult || 1));
                    minion.damageScaleBase = baseDamageScale;
                    minion.damageScale = minion.damageScaleBase * (protocol.damageMult || 1);
                    minion.protocolLevel = protocol.level || 0;
                    minion.protocolSlowFactor = protocol.slowFactor || null;
                    minion.protocolNovaDamageScale = protocol.novaDamageScale || 0;
                    minion.skinTheme = theme;
                    minion.abilityModule = abilityModule;
                    minion.abilityTheme = abilityTheme;
                }
            }

            function applyChampionUpgradeLoadout(champion, { refreshMinions = true } = {}) {
                if (!champion) return;
                const state = getChampionUpgradeState();
                const cadence = CHAMPION_CADENCE_LEVELS[state.cadenceLevel] || CHAMPION_CADENCE_LEVELS[0];
                const minionProtocol = CHAMPION_MINION_PROTOCOL_LEVELS[state.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const attack = CHAMPION_ATTACK_MODULE_MAP[state.attackModule] || null;
                const skinOption = CHAMPION_SKIN_OPTION_MAP[state.skin] || CHAMPION_SKIN_OPTION_MAP.default;
                const skinTheme = getChampionSkinTheme(skinOption.theme || skinOption.id || 'default');

                champion.fireCooldownBase = Math.max(0.35, champion.fireCooldownBase || champion.fireCooldown || PLAYER_CHAMPION_CONFIG.baseFireCooldown);
                champion.dashCooldownBase = Math.max(0.8, champion.dashCooldownBase || champion.dashCooldown || PLAYER_CHAMPION_CONFIG.baseDashCooldown);
                champion.momentumBase = champion.momentumBase || champion.momentum || 4.1;
                champion.guardRadiusBase = champion.guardRadiusBase || champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius;
                champion.angularSpeedBase = champion.angularSpeedBase || champion.angularSpeed || PLAYER_CHAMPION_CONFIG.baseAngularSpeed;

                // Apply cadence multipliers first
                let finalFireRateMult = cadence.fireRateMult || 1;
                let finalDamageMult = 1;

                // Apply attack module modifiers
                if (attack && attack.fireRateMult) {
                    finalFireRateMult *= attack.fireRateMult;
                }
                if (attack && attack.damageMult) {
                    finalDamageMult = attack.damageMult;
                }

                champion.fireCooldown = Math.max(0.24, champion.fireCooldownBase * finalFireRateMult);
                champion.dashCooldown = Math.max(0.6, champion.dashCooldownBase * (cadence.dashCooldownMult || 1));
                champion.momentum = champion.momentumBase;
                champion.guardRadius = champion.guardRadiusBase;
                champion.angularSpeed = champion.angularSpeedBase;
                champion.attackDamageMultiplier = finalDamageMult; // Store for bullet damage calculation

                champion.attackModule = attack ? attack.id : 'default';
                champion.cadenceLevel = state.cadenceLevel;
                champion.minionProtocols = state.minionProtocols;
                champion.skinKey = skinOption.id;
                champion.skinTheme = skinTheme;
                champion.bulletPrimary = skinTheme.bullet;
                champion.bulletPiercing = skinTheme.bulletPierce || skinTheme.bullet;

                if (refreshMinions) {
                    refreshChampionMinionsFromState(champion, minionProtocol);
                }

                configureChampionCombatProfile(champion, cadence);
            }

            function ensureChampionCollections() {
                if (!store.championMinions) store.championMinions = [];
            }

            function spawnChampionMinion(owner) {
                ensureChampionCollections();
                if (!owner) return null;
                const level = owner.level || 1;
                const minionCount = store.championMinions.length;
                if (minionCount >= PLAYER_CHAMPION_CONFIG.maxMinions) return null;
                const id = performance.now() + Math.random();

                // Position minions in a triangle formation (120 degrees apart)
                const baseAngle = (minionCount * Math.PI * 2) / 3; // 120 degrees apart
                const orbitRadius = 58 + minionCount * 8; // Slight radius variation

                const minion = {
                    id,
                    ownerId: owner.id,
                    orbitRadius: orbitRadius,
                    orbitAngle: baseAngle + Math.random() * 0.2 - 0.1, // Small random offset
                    orbitSpeed: 1.65 + minionCount * 0.15, // Slight speed variation
                    pulsePhase: Math.random() * Math.PI * 2,
                    swirlPhase: Math.random() * Math.PI * 2,
                    fireCooldown: Math.max(0.9, 1.4 - level * 0.12),
                    fireTimer: 0.35 + Math.random() * 0.4,
                    damageScale: 1 + (level - 1) * 0.18,
                    dead: false
                };
                const anchorX = owner.x + Math.cos(minion.orbitAngle) * minion.orbitRadius;
                const anchorY = owner.y + Math.sin(minion.orbitAngle) * minion.orbitRadius * 0.55;
                minion.x = anchorX;
                minion.y = anchorY;
                minion.fireCooldownBase = minion.fireCooldown;
                minion.damageScaleBase = minion.damageScale;

                const upgrades = getChampionUpgradeState();
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[upgrades.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const abilityModule = owner.attackModule || upgrades.attackModule || 'default';
                const abilityTheme = getChampionMinionAbilityTheme(abilityModule);
                minion.fireCooldown = Math.max(0.24, minion.fireCooldownBase * (protocol.fireRateMult || 1));
                minion.damageScale = minion.damageScaleBase * (protocol.damageMult || 1);
                minion.protocolLevel = protocol.level || 0;
                minion.protocolSlowFactor = protocol.slowFactor || null;
                minion.protocolNovaDamageScale = protocol.novaDamageScale || 0;
                const minionTheme = owner?.skinTheme ? owner.skinTheme.minion : getChampionSkinTheme(upgrades.skin).minion;
                minion.skinTheme = minionTheme;
                minion.abilityModule = abilityModule;
                minion.abilityTheme = abilityTheme;
                store.championMinions.push(minion);
                store.activeEffects.push(createEffect('spawnTeleport', owner.x, owner.y, owner.r * 1.6, {
                    duration: 0.6,
                    color: owner?.skinTheme ? owner.skinTheme.trail : '#e7e9ff',
                    clusterIndex: -1,
                    isChampion: true
                }));
                return minion;
            }

            function grantChampionCompanion() {
                ensureChampionCollections();
                ensureChampionUpgradeState();
                const now = performance.now();
                if (!store.playerChampion || store.playerChampion.dead) {
                    const champion = {
                        id: now + Math.random(),
                        x: clamp(store.player.x, 60, W - 60),
                        y: clamp(store.player.y - 90, 80, H - 120),
                        r: 20,
                        guardRadius: PLAYER_CHAMPION_CONFIG.baseGuardRadius,
                        guardAngle: Math.random() * Math.PI * 2,
                        angularSpeed: PLAYER_CHAMPION_CONFIG.baseAngularSpeed,
                        anchorOffsetY: -80,
                        fireCooldown: PLAYER_CHAMPION_CONFIG.baseFireCooldown,
                        fireTimer: 0.45,
                        dashCooldown: PLAYER_CHAMPION_CONFIG.baseDashCooldown,
                        dashTimer: 0,
                        dashDuration: 0,
                        dashVX: 0,
                        dashVY: 0,
                        dashCooldownTimer: 1.4,
                        state: null,
                        level: 1,
                        damageScale: 1,
                        volleySpread: 0.16,
                        volleySize: 4,
                        momentum: 4.1,
                        auraPulse: Math.random() * Math.PI * 2,
                        swirlPhase: Math.random() * Math.PI * 2,
                        roamAnchor: null,
                        roamTimer: 0,
                        roamMode: 'idle',
                        echoCooldown: 0,
                        dead: false,
                        isPlayerChampion: true,
                        fireCooldownBase: PLAYER_CHAMPION_CONFIG.baseFireCooldown,
                        dashCooldownBase: PLAYER_CHAMPION_CONFIG.baseDashCooldown,
                        guardRadiusBase: PLAYER_CHAMPION_CONFIG.baseGuardRadius,
                        angularSpeedBase: PLAYER_CHAMPION_CONFIG.baseAngularSpeed,
                        momentumBase: 4.1
                    };
                    store.playerChampion = champion;
                    store.player.championUnlocked = true;
                    store.championMinions.length = 0;

                    const presetLevel = Math.max(1, store.player?.championPresetLevel || 1);
                    const presetXp = Math.max(0, store.player?.championPresetXp || 0);
                    if (presetLevel > 1) {
                        champion.level = presetLevel;
                        champion.damageScale = 1 + (champion.level - 1) * 0.25;
                        champion.fireCooldownBase = Math.max(0.6, champion.fireCooldownBase * Math.pow(0.9, champion.level - 1));
                        champion.dashCooldownBase = Math.max(1.5, champion.dashCooldownBase * Math.pow(0.92, champion.level - 1));
                        champion.momentumBase = Math.min(6.2, champion.momentumBase + 0.25 * (champion.level - 1));
                        champion.momentum = champion.momentumBase;
                        champion.volleySize = Math.min(7, 4 + champion.level);
                        champion.volleySpread = Math.min(0.22, 0.16 + (champion.level - 1) * 0.015);
                        champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + champion.level * 6;
                        champion.guardRadius = champion.guardRadiusBase;
                        champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (champion.level - 1) * 0.08;
                        champion.angularSpeed = champion.angularSpeedBase;
                    }
                    champion.xp = presetXp;

                    applyChampionUpgradeLoadout(champion, { refreshMinions: false });
                    // Spawn 3 minions immediately for better visual formation
                    for (let i = 0; i < 3; i++) {
                        spawnChampionMinion(champion);
                    }
                    refreshChampionMinionsFromState(champion);
                    store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.y, champion.r * 2.1, {
                        duration: 1.05,
                        color: champion.skinTheme ? champion.skinTheme.trail : '#cbd4ff',
                        clusterIndex: -1,
                        isChampion: true
                    }));
                    updateChampionQuickStatus();
                    announce('âš”ï¸ Champion sigil aligned! Guardian bound to you.');
                    playSound('epicHorn');
                    return;
                }

                const champion = store.playerChampion;
                if (champion.dead) {
                    store.playerChampion = null;
                    grantChampionCompanion();
                    return;
                }

                store.player.championUnlocked = true;

                const nextLevel = Math.min((champion.level || 1) + 1, PLAYER_CHAMPION_CONFIG.maxLevel);
                const levelDelta = nextLevel - (champion.level || 1);
                champion.level = nextLevel;
                champion.damageScale = 1 + (champion.level - 1) * 0.25;
                champion.fireCooldownBase = Math.max(0.6, champion.fireCooldownBase * (levelDelta > 0 ? 0.9 : 1));
                champion.dashCooldownBase = Math.max(1.5, champion.dashCooldownBase * (levelDelta > 0 ? 0.92 : 1));
                champion.momentumBase = Math.min(6.2, champion.momentumBase + 0.25 * levelDelta);
                champion.volleySize = Math.min(7, 4 + champion.level);
                champion.volleySpread = Math.min(0.22, 0.16 + (champion.level - 1) * 0.015);
                champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + champion.level * 6;
                champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (champion.level - 1) * 0.08;
                champion.roamTimer = 0;

                applyChampionUpgradeLoadout(champion, { refreshMinions: true });

                store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.y, champion.r * 2.4, {
                    duration: 0.7,
                    color: champion.skinTheme ? champion.skinTheme.trail : '#f4f0ff',
                    clusterIndex: -1,
                    isChampion: true
                }));
                updateChampionQuickStatus();
                announce(`Champion ascends to rank ${champion.level}!`);
                playSound('epicHorn');
            }

            function startShadowAbility(b, ability) {
                b.currentAbility = ability;
                b.abilityStage = 'windup';
                b.shadowTelegraph = { type: ability, progress: 0 };
                b.shadowTelegraphTarget = { x: store.player.x, y: store.player.y };
                let windupBase;
                switch (ability) {
                    case 'star': windupBase = b.isEnraged ? 0.6 : 0.8; break;
                    case 'lightning': windupBase = b.isEnraged ? 0.65 : 0.85; break;
                    case 'hounds': windupBase = b.isEnraged ? 0.7 : 0.9; break;
                    case 'charge': windupBase = b.isEnraged ? 0.9 : 1.1; break;
                    case 'pulseWave': windupBase = b.isEnraged ? 0.5 : 0.7; break;
                    case 'voidRift': windupBase = b.isEnraged ? 0.75 : 0.95; break;
                    default: windupBase = 0.8; break;
                }
                b.abilityWindupTotal = windupBase;
                b.abilityTimer = windupBase;
            }

            function finishShadowAbility(b) {
                b.currentAbility = null;
                b.abilityStage = null;
                b.abilityTimer = 0;
                b.abilityWindupTotal = 0;
                b.shadowTelegraph = null;
                b.shadowTelegraphTarget = null;
                b.shadowChargeVX = 0;
                b.shadowChargeVY = 0;
                b.shadowChargeTrailCooldown = 0;
                b.shadowChargeHit = false;
            }

            function shadowClonePulseWave(b, dmgScale) {
                // Create expanding ring of bullets
                const bulletCount = b.isEnraged ? 18 : 14;
                const speed = b.isEnraged ? 240 : 200;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (i / bulletCount) * Math.PI * 2;
                    const bullet = getEBulletFromPool({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: 5,
                        col: '#b0b8ff',
                        dmg: 18 * dmgScale,
                        life: 3.5
                    });
                    store.eBullets.push(bullet);
                }
                store.activeEffects.push(createEffect('explosion', b.x, b.y, 30));
                playSound('explosion');
            }

            function shadowCloneVoidRift(b, dmgScale) {
                // Spawn void rifts at player location that deal damage over time
                if (!store.voidRifts) store.voidRifts = [];
                const riftCount = b.isEnraged ? 3 : 2;
                for (let i = 0; i < riftCount; i++) {
                    const spread = 80;
                    const offsetX = (Math.random() - 0.5) * spread;
                    const offsetY = (Math.random() - 0.5) * spread;
                    store.voidRifts.push({
                        x: store.player.x + offsetX,
                        y: store.player.y + offsetY,
                        r: 28,
                        life: 4.5,
                        maxLife: 4.5,
                        damageTimer: 0,
                        damage: 8 * dmgScale,
                        dead: false
                    });
                }
                playSound('warp');
            }

            function shadowCloneFireMultishot(b, dmgScale) {
                const volley = b.isEnraged ? 7 : 5;
                const spread = Math.PI / 6;
                const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                const bulletSpeed = 320 + (b.isEnraged ? 40 : 0);
                for (let i = 0; i < volley; i++) {
                    const offset = i - (volley - 1) / 2;
                    const angle = baseAngle + offset * (spread / Math.max(1, volley - 1));
                    const bullet = getEBulletFromPool({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * bulletSpeed,
                        vy: Math.sin(angle) * bulletSpeed,
                        r: 4,
                        col: '#aab0ff',
                        dmg: 14 * dmgScale,
                        life: 3.2
                    });
                    store.eBullets.push(bullet);
                }
            }

            function shadowCloneFireStarVolley(b, dmgScale) {
                const player = store.player;
                const baseAngle = Math.atan2(player.y - b.y, player.x - b.x);
                const starCount = b.isEnraged ? 5 : 3;
                const angleStep = 0.16;
                const radialOffset = 28;
                for (let i = 0; i < starCount; i++) {
                    const offsetIdx = i - (starCount - 1) / 2;
                    const angle = baseAngle + offsetIdx * angleStep;
                    // Fire from boss center towards player (removed perpendicular offset)
                    const originX = b.x + Math.cos(angle) * radialOffset;
                    const originY = b.y + Math.sin(angle) * radialOffset;
                    launchStarProjectile(originX, originY, angle, {
                        isEnemy: true,
                        enemyDamage: 20 * dmgScale * (b.isEnraged ? 1.2 : 1),
                        speedMultiplier: b.isEnraged ? 1.05 : 0.92,
                        trailColor: 'rgba(170, 180, 255, ',
                        primaryColor: '#e0e4ff',
                        coreColor: '#545b99',
                        shadowColor: '#2c2f58'
                    });
                }
                playSound('stargun');
            }

            function generateShadowLightningPath(start, end, segments) {
                segments = segments || 5;
                const points = [{ x: start.x, y: start.y }];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy) || 1;
                const nx = -dy / length;
                const ny = dx / length;
                for (let i = 1; i < segments; i++) {
                    const t = i / segments;
                    const jitterScale = 1 - Math.abs(0.5 - t) * 1.4;
                    const jitter = (Math.random() - 0.5) * 90 * jitterScale;
                    points.push({
                        x: start.x + dx * t + nx * jitter,
                        y: start.y + dy * t + ny * jitter
                    });
                }
                points.push({ x: end.x, y: end.y });
                return points;
            }

            function shadowCloneCastLightning(b, dmgScale) {
                const start = { x: b.x, y: b.y - b.r * 0.25 };
                const targets = [{ type: 'player', x: store.player.x, y: store.player.y }];
                if (store.iceman) targets.push({ type: 'iceman', x: store.iceman.x, y: store.iceman.y });
                if (store.beefClone) targets.push({ type: 'beefClone', x: store.beefClone.x, y: store.beefClone.y });
                const maxTargets = b.isEnraged ? 3 : 2;
                while (targets.length > maxTargets) targets.pop();
                for (let i = 0; i < targets.length; i++) {
                    const target = targets[i];
                    const endPoint = { x: target.x, y: target.y };
                    const points = generateShadowLightningPath(start, endPoint, 5);
                    store.lightningBolts.push({
                        points,
                        life: 0.45,
                        maxLife: 0.45,
                        dead: false,
                        isEnemy: true,
                        color: '#d7dcff',
                        glowColor: '#4a58c7'
                    });
                    store.activeEffects.push(createEffect('lightningFlash', endPoint.x, endPoint.y));
                    if (target.type === 'player') {
                        takeDamage(24 * dmgScale * (b.isEnraged ? 1.2 : 1));
                    }
                };
            }

            function spawnShadowHoundsFromBoss(b, count, dmgScale) {
                if (!store.shadowHounds) store.shadowHounds = [];
                count = count || 3;
                for (let i = 0; i < count; i++) {
                    const offsetIdx = i - (count - 1) / 2;
                    const lifespan = 11 + (b.isEnraged ? 4 : 0);
                    store.shadowHounds.push({
                        x: b.x + offsetIdx * 24,
                        y: b.y + 24 + Math.abs(offsetIdx) * 6,
                        vx: 0,
                        vy: 0,
                        speed: (b.isEnraged ? 260 : 220),
                        damage: 8 * dmgScale * (b.isEnraged ? 1.2 : 1),
                        life: lifespan,
                        maxLife: lifespan,
                        attackCooldown: 0.4,
                        wobble: Math.random() * Math.PI * 2,
                        dead: false
                    });
                }
                playSound('dogs');
            }

            function addShadowEcho(x, y) {
                if (!store.shadowEchoes) store.shadowEchoes = [];
                store.shadowEchoes.push({
                    x,
                    y,
                    life: 0.4,
                    maxLife: 0.4,
                    rotation: Math.random() * Math.PI * 2,
                    dead: false
                });
            }

            function updateShadowEchoes(dt) {
                if (!store.shadowEchoes || !store.shadowEchoes.length) return;
                for (let i = store.shadowEchoes.length - 1; i >= 0; i--) {
                    const echo = store.shadowEchoes[i];
                    echo.life -= dt;
                    if (echo.life <= 0) {
                        store.shadowEchoes.splice(i, 1);
                    }
                }
            }

            function normalizeAngle(angle) {
                if (!Number.isFinite(angle)) return 0;
                return Math.atan2(Math.sin(angle), Math.cos(angle));
            }

            function ensureTemporalSystems() {
                if (!Array.isArray(store.temporalEchoes)) {
                    store.temporalEchoes = [];
                }
                if (!Array.isArray(store.timeShards)) {
                    store.timeShards = [];
                }
                if (!store.temporalBeam) {
                    store.temporalBeam = {
                        anchorBossId: null,
                        angle: 0,
                        width: 32,
                        telegraph: 0,
                        skipPulse: 0,
                        rotationSpeed: 0,
                        length: Math.max(W, H),
                        originOffset: 1,
                        active: false
                    };
                }
            }

            function ensureAsynchronosState(b) {
                if (b.asynchronosState) {
                    return b.asynchronosState;
                }

                const state = {
                    phase: 1,
                    motionSamples: [],
                    motionSampleInterval: 0.14,
                    motionSampleTimer: 0.05,
                    bossHistory: [],
                    bossSampleInterval: 0.08,
                    bossSampleTimer: 0.08,
                    historyDurationMs: 6000,
                    echoTimer: 2.4,
                    baseEchoCooldown: 3.8,
                    phaseEchoCooldown: 2.5,
                    echoSensitivity: 0.3,
                    rewindTimer: 9.5,
                    baseRewindInterval: 9.5,
                    phaseRewindInterval: 6.4,
                    rewindLookback: 2.7,
                    phaseRewindLookback: 2.0,
                    rewinding: false,
                    rewindDuration: 0.65,
                    rewindElapsed: 0,
                    rewindPath: null,
                    beamAngle: -Math.PI / 2,
                    baseBeamRotationSpeed: 0.55,
                    phaseBeamRotationSpeed: 0.82,
                    beamRotationSpeed: 0.55,
                    beamSkipTimer: 3.4,
                    baseBeamSkipInterval: 3.4,
                    phaseBeamSkipInterval: 2.3,
                    beamTelegraphWindow: 0.75,
                    beamTelegraphActive: false,
                    beamSkipAngle: Math.PI / 4,
                    skipPulseTimer: 0,
                    skipPulseDuration: 0.45,
                    burstTimer: 2.4,
                    baseBurstInterval: 2.6,
                    phaseBurstInterval: 1.8,
                    movePhase: 0,
                    lastPlayerSample: null,
                    lastPlayerDirection: 0
                };

                b.asynchronosState = state;
                return state;
            }

            function recordAsynchronosSamples(b, state, dt) {
                const now = performance.now();

                state.motionSampleTimer -= dt;
                if (state.motionSampleTimer <= 0) {
                    state.motionSampleTimer += state.motionSampleInterval;
                    const player = store.player;
                    if (player) {
                        const last = state.lastPlayerSample;
                        const sample = { x: player.x, y: player.y, t: now };
                        if (last) {
                            const dtMs = Math.max(16, now - last.t);
                            const dtSeconds = dtMs / 1000;
                            const dx = player.x - last.x;
                            const dy = player.y - last.y;
                            const dist = Math.hypot(dx, dy);
                            const speed = dtSeconds > 0 ? dist / dtSeconds : 0;
                            const dir = dist > 2 ? Math.atan2(dy, dx) : state.lastPlayerDirection;
                            state.motionSamples.push({ pos: { x: player.x, y: player.y }, dir, speed, t: now });
                            state.lastPlayerDirection = dir;
                            while (state.motionSamples.length > 24) {
                                state.motionSamples.shift();
                            }
                        }
                        state.lastPlayerSample = sample;
                    }
                }

                state.bossSampleTimer -= dt;
                if (state.bossSampleTimer <= 0) {
                    state.bossSampleTimer += state.bossSampleInterval;
                    state.bossHistory.push({ x: b.x, y: b.y, t: now });
                }

                while (state.bossHistory.length && now - state.bossHistory[0].t > state.historyDurationMs) {
                    state.bossHistory.shift();
                }

                while (state.motionSamples.length && now - state.motionSamples[0].t > state.historyDurationMs) {
                    state.motionSamples.shift();
                }
            }

            function evaluateAsynchronosEcho(state) {
                if (state.echoTimer > 0 || state.motionSamples.length < 6) {
                    return null;
                }

                const recent = state.motionSamples.slice(-6);
                const active = recent.filter(sample => sample.speed > 40);
                if (active.length < 5) {
                    return null;
                }

                let totalDrift = 0;
                let maxSpeed = active[0].speed;
                let minSpeed = active[0].speed;
                for (let i = 1; i < active.length; i++) {
                    const prev = active[i - 1];
                    const curr = active[i];
                    const delta = Math.atan2(Math.sin(curr.dir - prev.dir), Math.cos(curr.dir - prev.dir));
                    totalDrift += Math.abs(delta);
                    maxSpeed = Math.max(maxSpeed, curr.speed);
                    minSpeed = Math.min(minSpeed, curr.speed);
                }

                const avgDrift = totalDrift / (active.length - 1);
                const avgSpeed = active.reduce((sum, sample) => sum + sample.speed, 0) / active.length;
                const speedEnvelope = avgSpeed > 0 ? (maxSpeed - minSpeed) / avgSpeed : 1;
                const driftThreshold = state.phase === 2 ? 0.22 : 0.3;
                const speedThreshold = state.phase === 2 ? 0.5 : 0.65;

                if (avgDrift <= driftThreshold && speedEnvelope <= speedThreshold) {
                    const originIndex = Math.max(0, state.motionSamples.length - (state.phase === 2 ? 9 : 11));
                    const originSample = state.motionSamples[originIndex];
                    const last = active[active.length - 1];
                    if (originSample && originSample.pos && last) {
                        return {
                            position: { x: originSample.pos.x, y: originSample.pos.y },
                            dir: last.dir,
                            speed: avgSpeed
                        };
                    }
                }

                return null;
            }

            function spawnTemporalEcho(b, state, trigger, dmgScale) {
                if (!trigger || !trigger.position) {
                    return;
                }

                ensureTemporalSystems();
                const dashSpeed = clamp(trigger.speed * 0.9, 220, state.phase === 2 ? 520 : 460);
                const life = 1.2;
                const distance = dashSpeed * (life * 0.68);

                store.temporalEchoes.push({
                    bossId: b.instanceId,
                    x: trigger.position.x,
                    y: trigger.position.y,
                    vx: Math.cos(trigger.dir) * dashSpeed,
                    vy: Math.sin(trigger.dir) * dashSpeed,
                    distance,
                    traveled: 0,
                    radius: 18,
                    damage: 22 * dmgScale * (state.phase === 2 ? 1.35 : 1),
                    life,
                    maxLife: life,
                    phase: state.phase,
                    trailTimer: 0,
                    trailInterval: 0.08,
                    linger: 0.55,
                    stage: 'dash',
                    color: '#8cf5ff',
                    trailColor: '#2a9dff'
                });

                store.activeEffects.push(createEffect('spawnTeleport', trigger.position.x, trigger.position.y, 42, {
                    color: '#8cf5ff',
                    duration: 0.4
                }));
                // Sound removed - no temporal echo sound spam
            }

            function dropTimeShardsAlongPath(path, b, state) {
                ensureTemporalSystems();
                if (!path || path.length < 2) {
                    return;
                }

                const shardCount = state.phase === 2 ? 5 : 4;
                const segmentCount = path.length - 1;
                for (let i = 1; i <= shardCount; i++) {
                    const t = i / (shardCount + 1);
                    const position = t * segmentCount;
                    const index = Math.floor(position);
                    const frac = position - index;
                    const start = path[index];
                    const end = path[Math.min(segmentCount, index + 1)];
                    if (!start || !end) {
                        continue;
                    }

                    const shardX = start.x + (end.x - start.x) * frac;
                    const shardY = start.y + (end.y - start.y) * frac;

                    store.timeShards.push({
                        bossId: b.instanceId,
                        x: shardX,
                        y: shardY,
                        baseY: shardY,
                        r: 14,
                        pickupRadius: 24,
                        hp: 12,
                        maxHp: 12,
                        life: 8,
                        maxLife: 8,
                        buffStacks: 1,
                        sparkle: Math.random() * Math.PI * 2,
                        floatPhase: Math.random() * Math.PI * 2,
                        floatSpeed: 2.6,
                        dead: false
                    });

                    store.activeEffects.push(createEffect('spawnTeleport', shardX, shardY, 30, {
                        color: '#9df7ff',
                        duration: 0.45
                    }));
                }
            }

            function beginAsynchronosRewind(b, state) {
                const now = performance.now();
                const lookbackMs = (state.phase === 2 ? state.phaseRewindLookback : state.rewindLookback) * 1000;
                const targetTime = now - lookbackMs;
                const path = [{ x: b.x, y: b.y }];

                for (let i = state.bossHistory.length - 1; i >= 0; i--) {
                    const sample = state.bossHistory[i];
                    path.push({ x: sample.x, y: sample.y });
                    if (sample.t <= targetTime) {
                        break;
                    }
                }

                if (path.length < 3) {
                    state.rewindTimer = (state.phase === 2 ? state.phaseRewindInterval : state.baseRewindInterval) * 0.6;
                    return false;
                }

                state.rewindPath = path;
                state.rewindDuration = state.phase === 2 ? 0.5 : 0.65;
                state.rewindElapsed = 0;
                state.rewinding = true;
                state.rewindTimer = state.phase === 2 ? state.phaseRewindInterval : state.baseRewindInterval;
                b.isInvincible = true;

                dropTimeShardsAlongPath(path, b, state);
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(50, (b.r || 40) + 28), {
                    color: '#6ff2ff',
                    duration: 0.4
                }));
                playSound('thunder');
                return true;
            }

            function updateAsynchronosRewind(b, state, dt) {
                if (!state.rewinding || !state.rewindPath || state.rewindPath.length < 2) {
                    return;
                }

                state.rewindElapsed += dt;
                const duration = Math.max(0.001, state.rewindDuration);
                const progress = clamp(state.rewindElapsed / duration, 0, 1);
                const segments = state.rewindPath.length - 1;
                const position = progress * segments;
                const index = Math.floor(position);
                const frac = position - index;
                const start = state.rewindPath[index];
                const end = state.rewindPath[Math.min(segments, index + 1)];

                if (start && end) {
                    b.x = start.x + (end.x - start.x) * frac;
                    b.y = start.y + (end.y - start.y) * frac;
                }

                if (progress >= 1) {
                    state.rewinding = false;
                    state.rewindPath = null;
                    b.isInvincible = false;
                    store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(50, (b.r || 40) + 34), {
                        color: '#6ff2ff',
                        duration: 0.5
                    }));
                }
            }

            function updateAsynchronosBeam(b, state, dt) {
                ensureTemporalSystems();

                state.beamAngle = normalizeAngle(state.beamAngle + state.beamRotationSpeed * dt);
                state.beamSkipTimer -= dt;

                if (!state.beamTelegraphActive && state.beamSkipTimer <= state.beamTelegraphWindow) {
                    state.beamTelegraphActive = true;
                    store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(40, (b.r || 40) + 18), {
                        color: '#8cf5ff',
                        duration: state.beamTelegraphWindow
                    }));
                    // Sound removed - no telegraph sound spam
                }

                if (state.beamSkipTimer <= 0) {
                    state.beamAngle = normalizeAngle(state.beamAngle + state.beamSkipAngle);
                    state.beamSkipTimer += state.phase === 2 ? state.phaseBeamSkipInterval : state.baseBeamSkipInterval;
                    state.beamTelegraphActive = false;
                    state.skipPulseTimer = state.skipPulseDuration;
                    store.activeEffects.push(createEffect('spawnTeleport', b.x + Math.cos(state.beamAngle) * 60, b.y + Math.sin(state.beamAngle) * 60, 48, {
                        color: '#6ff2ff',
                        duration: 0.4
                    }));
                    // Sound removed - no beam skip sound spam
                }

                if (state.skipPulseTimer > 0) {
                    state.skipPulseTimer = Math.max(0, state.skipPulseTimer - dt);
                }

                const beam = store.temporalBeam;
                beam.anchorBossId = b.instanceId;
                beam.active = true;
                beam.angle = state.beamAngle;
                beam.width = state.phase === 2 ? 38 : 32;
                beam.telegraph = state.beamTelegraphActive ? clamp(1 - Math.max(0, state.beamSkipTimer) / state.beamTelegraphWindow, 0, 1) : 0;
                beam.skipPulse = state.skipPulseTimer > 0 ? state.skipPulseTimer / state.skipPulseDuration : 0;
                beam.rotationSpeed = state.beamRotationSpeed;
                beam.length = Math.max(W, H) + 120;
                beam.originOffset = state.rewinding ? 0.85 : 1;
            }

            function fireAsynchronosVolley(b, dmgScale, state) {
                const count = state.phase === 2 ? 12 : 8; // More projectiles
                const speed = state.phase === 2 ? 280 : 240; // Faster projectiles
                const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                const spread = state.phase === 2 ? 0.5 : 0.35; // Wider spread

                // Create warning indicator
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(50, (b.r || 40) + 25), {
                    color: state.phase === 2 ? '#ff66aa' : '#66eaff',
                    duration: 0.4
                }));

                for (let i = 0; i < count; i++) {
                    const t = count > 1 ? i / (count - 1) : 0.5;
                    const offset = (t - 0.5) * spread;
                    const angle = baseAngle + offset;
                    const bullet = getEBulletFromPool({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: state.phase === 2 ? 5 : 4.5,
                        col: state.phase === 2 ? '#ff66ff' : '#66eaff',
                        dmg: 15 * dmgScale * (state.phase === 2 ? 1.3 : 1),
                        life: 4.5,
                        type: 'temporal_spear'
                    });
                    bullet.spin = (i - (count - 1) / 2) * 0.7;
                    store.eBullets.push(bullet);
                }
                
                // Phase 2: Add secondary radial burst
                if (state.phase === 2) {
                    const radialCount = 8;
                    const radialSpeed = 180;
                    for (let i = 0; i < radialCount; i++) {
                        const angle = (i / radialCount) * Math.PI * 2;
                        const bullet = getEBulletFromPool({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * radialSpeed,
                            vy: Math.sin(angle) * radialSpeed,
                            r: 3.5,
                            col: '#aa66ff',
                            dmg: 12 * dmgScale,
                            life: 3,
                            type: 'temporal_spear'
                        });
                        bullet.spin = i * 0.5;
                        store.eBullets.push(bullet);
                    }
                }
            }

            function performAsynchronosDash(b, state, dmgScale) {
                // Asynchronos teleports behind the player and dashes through them
                const player = store.player;
                if (!player) return;
                
                // Calculate position behind player
                const angleToPlayer = Math.atan2(player.y - b.y, player.x - b.x);
                const behindDistance = 280;
                const targetX = player.x - Math.cos(angleToPlayer) * behindDistance;
                const targetY = player.y - Math.sin(angleToPlayer) * behindDistance;
                
                // Clamp to screen bounds with padding
                const clampedX = clamp(targetX, 80, W - 80);
                const clampedY = clamp(targetY, 80, H - 200);
                
                // Teleport effect at current position
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, b.r * 1.8, {
                    color: '#6ff2ff',
                    duration: 0.5
                }));
                
                // Teleport boss
                b.x = clampedX;
                b.y = clampedY;
                
                // Arrival effect
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, b.r * 2.2, {
                    color: '#ff6f6f',
                    duration: 0.6
                }));
                
                // Launch 3 waves of temporal spears in rapid succession toward player
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        if (!b || b.dead) return;
                        const count = 5;
                        const speed = 320;
                        const baseAngle = Math.atan2(player.y - b.y, player.x - b.x);
                        const spread = 0.6;
                        
                        for (let i = 0; i < count; i++) {
                            const t = count > 1 ? i / (count - 1) : 0.5;
                            const offset = (t - 0.5) * spread;
                            const angle = baseAngle + offset;
                            const bullet = getEBulletFromPool({
                                x: b.x,
                                y: b.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                r: 5,
                                col: wave === 0 ? '#ff6f6f' : wave === 1 ? '#ffaa6f' : '#ffff6f',
                                dmg: 14 * dmgScale,
                                life: 4,
                                type: 'temporal_spear'
                            });
                            bullet.spin = (i - (count - 1) / 2) * 0.8;
                            store.eBullets.push(bullet);
                        }
                    }, wave * 250);
                }
                
                announce('âš¡ ASYNCHRONOS WARPS BEHIND YOU!');
            }

            function stepBossAsynchronos(dt, b, dmgScale) {
                const state = ensureAsynchronosState(b);
                ensureTemporalSystems();
                recordAsynchronosSamples(b, state, dt);

                const hpRatio = b.hpMax > 0 ? b.hp / b.hpMax : 1;
                if (state.phase === 1 && hpRatio <= 0.5) {
                    state.phase = 2;
                    b.isEnraged = true;
                    state.beamRotationSpeed = state.phaseBeamRotationSpeed * 1.3; // Even faster in phase 2
                    state.beamSkipTimer = Math.min(state.beamSkipTimer, state.phaseBeamSkipInterval);
                    state.rewindTimer = Math.min(state.rewindTimer, state.phaseRewindInterval);
                    state.burstTimer = Math.min(state.burstTimer, state.phaseBurstInterval);
                    state.dashAttackTimer = 4.0; // New dash attack ability
                    announce('âš¡ ASYNCHRONOS FRACTURES TIME ITSELF! âš¡');
                    playSound('epicHorn');
                    screenFlash(3, 200, 'rgba(111, 242, 255, 0.4)');
                }

                if (state.rewinding) {
                    updateAsynchronosRewind(b, state, dt);
                } else if (b.y < 110) {
                    b.y = Math.min(110, b.y + 160 * dt);
                } else {
                    // More dynamic movement patterns
                    state.movePhase += dt * (state.phase === 2 ? 1.5 : 0.85);
                    const erraticFactor = state.phase === 2 ? Math.sin(state.movePhase * 3.2) * 60 : 0;
                    const targetX = W / 2 + Math.sin(state.movePhase * 0.9) * (260 + erraticFactor) + Math.cos(state.movePhase * 1.7) * 80;
                    const targetY = 120 + Math.sin(state.movePhase * 1.4) * (state.phase === 2 ? 45 : 26) + Math.cos(state.movePhase * 2.1) * 25;
                    const moveSpeed = state.phase === 2 ? 3.5 : 2.8;
                    b.x += (targetX - b.x) * Math.min(1, moveSpeed * dt);
                    b.y += (targetY - b.y) * Math.min(1, (state.phase === 2 ? 2.2 : 1.6) * dt);
                    
                    // Phase 2: Add teleport dash attacks
                    if (state.phase === 2) {
                        state.dashAttackTimer = (state.dashAttackTimer || 5.0) - dt;
                        if (state.dashAttackTimer <= 0) {
                            performAsynchronosDash(b, state, dmgScale);
                            state.dashAttackTimer = 6.5; // Dash every 6.5 seconds in phase 2
                        }
                    }
                }

                state.echoTimer = Math.max(0, state.echoTimer - dt);
                state.rewindTimer -= dt;
                state.burstTimer -= dt;

                const echoTrigger = evaluateAsynchronosEcho(state);
                if (echoTrigger) {
                    spawnTemporalEcho(b, state, echoTrigger, dmgScale);
                    state.echoTimer = state.phase === 2 ? state.phaseEchoCooldown : state.baseEchoCooldown;
                }

                if (!state.rewinding && state.rewindTimer <= 0) {
                    beginAsynchronosRewind(b, state);
                }

                updateAsynchronosBeam(b, state, dt);

                if (state.burstTimer <= 0 && !state.rewinding) {
                    fireAsynchronosVolley(b, dmgScale, state);
                    state.burstTimer = state.phase === 2 ? state.phaseBurstInterval : state.baseBurstInterval;
                }
            }

            function applyTimeShardBuff(stacks = 1) {
                const p = store.player;
                if (!p) return;
                const additional = Math.max(1, Math.floor(stacks));
                const current = Math.max(0, p.timeShardStacks || 0);
                const newStacks = clamp(current + additional, 1, 5);
                p.timeShardStacks = newStacks;
                p.timeShardTimer = 6.5;
                p.timeShardMultiplier = Math.pow(0.88, newStacks);

                if (typeof announce === 'function') {
                    const percent = Math.round((1 - p.timeShardMultiplier) * 100);
                    announce(`Temporal surge x${newStacks}! Fire cadence +${percent}%`);
                }
            }

            function updateTemporalEchoes(dt) {
                const echoes = store.temporalEchoes;
                if (!Array.isArray(echoes) || echoes.length === 0) return;
                const player = store.player;

                for (let i = echoes.length - 1; i >= 0; i--) {
                    const echo = echoes[i];
                    if (!echo) continue;

                    echo.life -= dt;
                    if (echo.life <= 0) {
                        echo.dead = true;
                    }

                    if (echo.dead) {
                        store.activeEffects.push(createEffect('spawnTeleport', echo.x, echo.y, 26, {
                            color: '#8cf5ff',
                            duration: 0.28
                        }));
                        echoes.splice(i, 1);
                        continue;
                    }

                    if (echo.stage === 'dash') {
                        const stepX = echo.vx * dt;
                        const stepY = echo.vy * dt;
                        echo.x += stepX;
                        echo.y += stepY;
                        echo.traveled += Math.hypot(stepX, stepY);
                        echo.trailTimer -= dt;
                        if (echo.trailTimer <= 0) {
                            echo.trailTimer += echo.trailInterval || 0.10; // Slower trail spawn rate
                            const trail = getEBulletFromPool({
                                x: echo.x,
                                y: echo.y,
                                vx: 0,
                                vy: 0,
                                r: 5, // Smaller radius
                                col: echo.trailColor || '#4de0ff',
                                dmg: 0, // Trail doesn't damage - only the echo itself damages on direct hit
                                life: 0.5, // Visible longer for better telegraph
                                type: 'temporal_trail'
                            });
                            store.eBullets.push(trail);
                        }
                        if (echo.traveled >= echo.distance) {
                            echo.stage = 'linger';
                            echo.vx = 0;
                            echo.vy = 0;
                            echo.life = Math.max(echo.life, echo.linger || 0.4);
                        }
                    } else if (echo.stage === 'linger') {
                        echo.linger -= dt;
                        if (echo.linger <= 0) {
                            echo.dead = true;
                        }
                    }

                    if (player && !player.isInvincible) {
                        const radius = (player.r || 16) + (echo.radius || 18) * 0.7;
                        const dx = player.x - echo.x;
                        const dy = player.y - echo.y;
                        if (dx * dx + dy * dy <= radius * radius) {
                            takeDamage(echo.damage || 20);
                            echo.stage = 'linger';
                            echo.linger = Math.min(echo.linger || 0.5, 0.25);
                            echo.vx = 0;
                            echo.vy = 0;
                        }
                    }
                }
            }

            function updateTimeShards(dt) {
                const shards = store.timeShards;
                if (!Array.isArray(shards) || shards.length === 0) return;
                const player = store.player;
                for (let i = shards.length - 1; i >= 0; i--) {
                    const shard = shards[i];
                    if (!shard) continue;
                    shard.life -= dt;
                    shard.floatPhase = (shard.floatPhase || 0) + (shard.floatSpeed || 2.4) * dt;
                    if (shard.hitPulse) {
                        shard.hitPulse = Math.max(0, shard.hitPulse - dt);
                    }
                    if (shard.baseY !== undefined) {
                        shard.y = shard.baseY + Math.sin(shard.floatPhase) * 8;
                    }

                    if (shard.life <= 0 || shard.hp <= 0 || shard.dead) {
                        store.activeEffects.push(createEffect('spawnTeleport', shard.x, shard.y, 24, {
                            color: '#9df7ff',
                            duration: 0.3
                        }));
                        shards.splice(i, 1);
                    }
                }
            }

            function applyTemporalBeamEffects(dt, dmgScale) {
                const beam = store.temporalBeam;
                const boss = store.boss;
                if (!beam || !beam.active || !boss || boss.dead || boss.behavior !== 'asynchronos') return;

                beam.damageCooldown = Math.max(0, (beam.damageCooldown || 0) - dt);

                const player = store.player;
                if (!player || player.isInvincible) return;

                const originX = boss.x;
                const originY = boss.y;
                const ux = Math.cos(beam.angle || 0);
                const uy = Math.sin(beam.angle || 0);
                const px = player.x - originX;
                const py = player.y - originY;
                const along = px * ux + py * uy;
                if (along < -(player.r || 16)) return;

                const perpX = -uy;
                const perpY = ux;
                const dist = Math.abs(px * perpX + py * perpY);
                const effectiveWidth = (beam.width || 32) * (beam.telegraph > 0 ? (0.45 + 0.55 * (1 - beam.telegraph)) : 1);

                if (dist <= effectiveWidth) {
                    if (beam.damageCooldown <= 0) {
                        const damage = 22 * (dmgScale || 1);
                        takeDamage(damage);
                        beam.damageCooldown = 0.35;
                        store.activeEffects.push(createEffect('hurtPulse', player.x, player.y, (player.r || 16) * 1.6, {
                            color: '#9df7ff',
                            duration: 0.25
                        }));
                    }
                }
            }

            function stepBossShadowClone(dt, b, dmgScale) {
                ensureShadowCloneInit(b);
                if (!b.isEnraged && b.hp / b.hpMax <= 0.35) {
                    b.isEnraged = true;
                    b.shadowAbilityCooldown = 24;
                    playSound('horn');
                    announce('THE SHADOW MIRROR UNLEASHES ITS POWER!');
                }

                for (const key in b.shadowAbilityTimers) {
                    if (Object.prototype.hasOwnProperty.call(b.shadowAbilityTimers, key)) {
                        b.shadowAbilityTimers[key] -= dt;
                    }
                }

                if (b.currentAbility) {
                    if (b.abilityStage === 'windup') {
                        b.abilityTimer -= dt;
                        if (b.shadowTelegraph) {
                            const total = b.abilityWindupTotal || 1;
                            b.shadowTelegraph.progress = Math.min(1, Math.max(0, 1 - (b.abilityTimer / total)));
                        }
                        if (b.currentAbility === 'lightning') {
                            b.shadowTelegraphTarget = { x: store.player.x, y: store.player.y };
                        }
                        if (b.abilityTimer <= 0) {
                            switch (b.currentAbility) {
                                case 'star':
                                    shadowCloneFireStarVolley(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.55;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'lightning':
                                    shadowCloneCastLightning(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.65;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'hounds':
                                    spawnShadowHoundsFromBoss(b, b.isEnraged ? 4 : 3, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.6;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'pulseWave':
                                    shadowClonePulseWave(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.5;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'voidRift':
                                    shadowCloneVoidRift(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.7;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'charge':
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    b.abilityStage = 'charge';
                                    b.abilityTimer = b.isEnraged ? 0.85 : 1.05;
                                    const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    const speed = b.isEnraged ? 640 : 560;
                                    b.shadowChargeVX = Math.cos(angle) * speed;
                                    b.shadowChargeVY = Math.sin(angle) * speed;
                                    b.shadowChargeTrailCooldown = 0;
                                    b.shadowChargeHit = false;
                                    addShadowEcho(b.x, b.y);
                                    break;
                            }
                        }
                    } else if (b.abilityStage === 'charge') {
                        b.abilityTimer -= dt;
                        b.x += b.shadowChargeVX * dt;
                        b.y += b.shadowChargeVY * dt;
                        addShadowEcho(b.x, b.y);
                        b.shadowChargeTrailCooldown -= dt;
                        if (b.shadowChargeTrailCooldown <= 0) {
                            b.shadowChargeTrailCooldown = 0.08;
                            const pulse = getEBulletFromPool({
                                x: b.x,
                                y: b.y,
                                vx: 0,
                                vy: 0,
                                r: 7,
                                col: '#5460d8',
                                dmg: 10 * dmgScale,
                                life: 0.35
                            });
                            store.eBullets.push(pulse);
                        }
                        const margin = b.r;
                        if (b.x <= margin || b.x >= W - margin || b.y <= margin || b.y >= H * 0.92) {
                            b.abilityTimer = 0;
                        }
                        const player = store.player;
                        const playerRadius = player.r || 18;
                        const dx = player.x - b.x;
                        const dy = player.y - b.y;
                        if (!b.shadowChargeHit && dx * dx + dy * dy <= Math.pow(playerRadius + b.r * 0.55, 2)) {
                            takeDamage(30 * dmgScale * (b.isEnraged ? 1.25 : 1));
                            b.shadowChargeHit = true;
                        }
                        if (b.abilityTimer <= 0) {
                            b.abilityStage = 'recover';
                            b.abilityTimer = 0.55;
                            b.shadowChargeVX = 0;
                            b.shadowChargeVY = 0;
                        }
                    } else if (b.abilityStage === 'recover') {
                        b.abilityTimer -= dt;
                        if (b.abilityTimer <= 0) {
                            finishShadowAbility(b);
                        }
                    }
                } else {
                    const abilities = b.shadowAbilityOrder;
                    for (let i = 0; i < abilities.length; i++) {
                        const index = (b.shadowAbilityIndex + i) % abilities.length;
                        const abilityName = abilities[index];
                        if (b.shadowAbilityTimers[abilityName] <= 0) {
                            startShadowAbility(b, abilityName);
                            b.shadowAbilityTimers[abilityName] = b.shadowAbilityCooldown;
                            b.shadowAbilityIndex = (index + 1) % abilities.length;
                            break;
                        }
                    }
                }

                if (!b.currentAbility) {
                    b.multishotTimer -= dt;
                    if (b.multishotTimer <= 0) {
                        shadowCloneFireMultishot(b, dmgScale);
                        b.multishotTimer = b.isEnraged ? 0.45 : 0.65;
                    }
                }

                if (b.abilityStage !== 'charge') {
                    b.moveT += dt;
                    const follow = clamp(store.player.x, b.r + 40, W - b.r - 40);
                    const strafe = Math.sin(b.moveT * (b.isEnraged ? 1.4 : 1.0)) * (140 + (b.isEnraged ? 40 : 0));
                    const desiredX = clamp(follow + strafe * 0.3, b.r, W - b.r);
                    b.x += (desiredX - b.x) * dt * 3.2;
                    const targetY = 130 + Math.sin(b.moveT * 0.9) * 16;
                    b.y += (targetY - b.y) * dt * 2.6;
                }
            }

            function stepBossOmegaSentinel(dt, b, dmgScale) {
                // Movement behavior
                if (b.y >= 100) {
                    b.moveT += dt;
                    b.x += Math.sin(b.moveT * 2) * 200 * dt;
                    b.x = clamp(b.x, 100, W - 100);
                }

                // Initialize EMP nova timer if not set
                if (b.empNovaTimer === undefined) {
                    b.empNovaTimer = 8; // EMP nova every 8 seconds
                }

                // EMP Nova attack countdown
                b.empNovaTimer -= dt;
                if (b.empNovaTimer <= 0) {
                    // Create EMP nova
                    store.empNovas.push({
                        x: b.x,
                        y: b.y,
                        radius: 0,
                        maxRadius: H / 3, // 1/3 of screen height
                        speed: 80, // Slow expansion speed
                        life: 15, // Lives for 15 seconds
                        dead: false
                    });
                    b.empNovaTimer = 8; // Reset timer
                }

                // Regular attack patterns
                b.fireT -= dt;
                if (b.fireT <= 0) {
                    if (b.patternPhase % 4 === 0) {
                        // Radial burst
                        b.fireT = 1.5;
                        const n = 12;
                        for (let i = 0; i < n; i++) {
                            const a = (i * Math.PI / 6) + b.t;
                            store.eBullets.push({
                                x: b.x,
                                y: b.y,
                                vx: 150 * Math.cos(a),
                                vy: 150 * Math.sin(a),
                                r: 4,
                                col: '#4169e1',
                                dmg: 12 * dmgScale
                            });
                        }
                    } else {
                        // Aimed shot
                        b.fireT = 0.2;
                        const a = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: 250 * Math.cos(a),
                            vy: 250 * Math.sin(a),
                            r: 5,
                            col: '#add8e6',
                            dmg: 18 * dmgScale
                        });
                    }
                    b.patternPhase++;
                }
            }
            function ensureAegisArchitectState(b) {
                if (b.aegisState) {
                    return b.aegisState;
                }

                const rawCycle = Math.max(0, Math.floor((ensureFiniteNumber(b.spawnWave, store.world.wave) - 5) / 5));
                const loopIndex = Math.max(0, Math.floor(rawCycle / BOSS_DEFINITIONS.length));
                const difficultyScale = 1 + loopIndex * 0.2;
                const segmentHp = Math.max(320, b.hpMax * 0.18 * difficultyScale);
                const segmentDefs = [
                    { id: 'solar', label: 'Solar Keystone', color: '#ffb347', baseAngle: 0, arc: Math.PI * 0.58, unlock: 'solar_burst', unlockMessage: 'Solar torrents ignite the field!' },
                    { id: 'prismatic', label: 'Prismatic Keystone', color: '#7de8ff', baseAngle: (2 * Math.PI) / 3, arc: Math.PI * 0.58, unlock: 'prismatic_grid', unlockMessage: 'Prismatic lattices refract across the arena!' },
                    { id: 'gravity', label: 'Gravimetric Keystone', color: '#c5a7ff', baseAngle: (4 * Math.PI) / 3, arc: Math.PI * 0.58, unlock: 'gravity_well', unlockMessage: 'Gravity wells distort your footing!' }
                ];

                const segments = segmentDefs.map(def => ({
                    ...def,
                    hp: segmentHp,
                    maxHp: segmentHp,
                    destroyed: false,
                    hitPulse: 0,
                    lastHitTime: 0
                }));

                const state = {
                    rotationAngle: 0,
                    rotationSpeed: 0.45,
                    rotationDirection: 1,
                    shieldRadius: Math.max(90, b.r * 1.08),
                    coreRadius: Math.max(44, b.r * 0.62),
                    segments,
                    attackTimer: 1.6,
                    availablePatterns: ['baseline', 'baseline'],
                    patternIndex: -1,
                    unlocks: Object.create(null),
                    difficultyScale,
                    loopIndex,
                    corePulse: 0,
                    enraged: false,
                    coreExposed: false
                };

                b.aegisState = state;
                return state;
            }

            function getAegisSegmentForAngle(state, angle) {
                if (!state || !state.segments) return null;
                for (const segment of state.segments) {
                    if (!segment || segment.destroyed) continue;
                    const center = state.rotationAngle + segment.baseAngle;
                    const delta = Math.atan2(Math.sin(angle - center), Math.cos(angle - center));
                    if (Math.abs(delta) <= segment.arc * 0.5) {
                        return segment;
                    }
                }
                return null;
            }

            function handleAegisSegmentDestroyed(boss, segment, state) {
                if (!boss || !segment || !state) return;

                state.rotationDirection *= -1;
                state.rotationSpeed *= 1.1;
                state.availablePatterns.push(segment.unlock);
                state.availablePatterns.push('baseline');
                state.unlocks[segment.id] = true;
                state.attackTimer = Math.min(state.attackTimer, state.enraged ? 0.9 : 1.2);

                store.activeEffects.push(createEffect('spawnTeleport', boss.x, boss.y, state.shieldRadius + 24, {
                    color: segment.color,
                    duration: 0.8
                }));

                if (typeof announce === 'function') {
                    announce(`${segment.label} shattered! ${segment.unlockMessage}`);
                }

                if (state.segments.every(seg => seg.destroyed)) {
                    if (!state.coreExposed) {
                        state.coreExposed = true;
                        state.availablePatterns.push('cataclysm');
                        if (typeof announce === 'function') {
                            announce('Architect core exposed! Cataclysm routines engaged!');
                        }
                    }
                }
            }

            function applyAegisShieldDamage(boss, damage, options = {}) {
                if (!boss || boss.behavior !== 'aegis_architect' || damage <= 0) {
                    return { blocked: false, damageApplied: 0 };
                }

                const state = options.state || ensureAegisArchitectState(boss);
                if (!state) {
                    return { blocked: false, damageApplied: 0 };
                }

                let angle = options.angle;
                if (angle === undefined && options.point) {
                    angle = Math.atan2(options.point.y - boss.y, options.point.x - boss.x);
                }
                if (angle === undefined || !Number.isFinite(angle)) {
                    return { blocked: false, damageApplied: 0 };
                }

                const segment = getAegisSegmentForAngle(state, angle);
                if (!segment) {
                    return { blocked: false, damageApplied: 0 };
                }

                const applied = Math.max(0, damage);
                segment.hp = Math.max(0, segment.hp - applied);
                segment.hitPulse = 0.22;
                segment.lastHitTime = performance.now();

                const impactRadius = Math.max(18, options.hitRadius || 18);
                const impactX = boss.x + Math.cos(angle) * state.shieldRadius;
                const impactY = boss.y + Math.sin(angle) * state.shieldRadius;

                store.activeEffects.push(createEffect('hitSpark', impactX, impactY, impactRadius, {
                    color: segment.color
                }));
                store.activeEffects.push(createEffect('spawnTeleport', impactX, impactY, impactRadius + 6, {
                    color: segment.color,
                    duration: 0.35
                }));

                store.world.totalDamage += applied;

                if (segment.hp <= 0 && !segment.destroyed) {
                    segment.destroyed = true;
                    handleAegisSegmentDestroyed(boss, segment, state);
                }

                return { blocked: true, damageApplied: applied, segment };
            }

            function tryAegisShieldInterceptBullet(boss, bullet, damage) {
                if (!boss || !bullet || damage <= 0 || boss.behavior !== 'aegis_architect') {
                    return null;
                }

                const state = ensureAegisArchitectState(boss);
                if (!state) {
                    return null;
                }

                const dx = bullet.x - boss.x;
                const dy = bullet.y - boss.y;
                const dist = Math.hypot(dx, dy);
                if (!Number.isFinite(dist) || dist < state.coreRadius * 0.72) {
                    return null;
                }

                const angle = Math.atan2(dy, dx);
                const result = applyAegisShieldDamage(boss, damage, { state, angle, hitRadius: (bullet.r || 4) + 6 });
                if (!result.blocked) {
                    return null;
                }

                if (bullet.pierce) {
                    bullet.pierceHits = (bullet.pierceHits || 0) + 1;
                    if (bullet.pierceHits >= bullet.pierce) {
                        bullet.dead = true;
                    }
                } else {
                    bullet.dead = true;
                }

                return result;
            }

            function fireAegisBaselineVolley(b, dmgScale, state) {
                const aim = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                const count = 5;
                const spread = Math.PI / 18;
                const speed = (state && state.enraged) ? 290 : 240;
                for (let i = 0; i < count; i++) {
                    const offset = (i - (count - 1) / 2) * spread;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(aim + offset) * speed,
                        vy: Math.sin(aim + offset) * speed,
                        r: 5,
                        col: '#6bd6ff',
                        dmg: 16 * dmgScale,
                        life: 4
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, 34, {
                    color: '#6bd6ff',
                    duration: 0.4
                }));
            }

            function fireAegisSolarBurst(b, dmgScale, state) {
                const baseX = b.x;
                const originY = b.y + 34;
                const count = (state && state.enraged) ? 12 : 10;
                for (let i = 0; i < count; i++) {
                    const offsetIndex = i - (count - 1) / 2;
                    const amplitude = 110 + Math.abs(offsetIndex) * 14;
                    const frequency = 2.4 + Math.random() * 0.35;
                    const fallSpeed = 160 + Math.random() * 40;
                    const phaseOffset = offsetIndex * 0.42;

                    store.eBullets.push({
                        x: baseX + offsetIndex * 18,
                        y: originY,
                        r: 6,
                        col: '#ffb347',
                        dmg: 18 * dmgScale * ((state && state.enraged) ? 1.15 : 1),
                        path: 'aegis_spiral',
                        amplitude,
                        frequency,
                        fallSpeed,
                        phaseOffset,
                        life: 7.5 + Math.random() * 1.5,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', baseX, originY, 44, {
                    color: '#ffb347',
                    duration: 0.75
                }));
            }

            function fireAegisPrismaticGrid(b, dmgScale, state) {
                const lanes = (state && state.enraged) ? 6 : 5;
                const usableWidth = W - 120;
                const baseX = 60;
                for (let i = 0; i < lanes; i++) {
                    const laneX = baseX + (i + 0.5) * (usableWidth / lanes);
                    const downwardSpeed = 240 + i * 12;
                    store.eBullets.push({
                        x: laneX,
                        y: b.y + 20,
                        vx: ((i % 2 === 0) ? -1 : 1) * 80,
                        vy: downwardSpeed,
                        r: 5,
                        col: '#90f2ff',
                        dmg: 18 * dmgScale,
                        life: 3.6
                    });
                    store.eBullets.push({
                        x: laneX,
                        y: b.y + 20,
                        vx: 0,
                        vy: downwardSpeed + 40,
                        r: 7,
                        col: '#abf5ff',
                        dmg: 22 * dmgScale,
                        life: 3.2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y + 20, 52, {
                    color: '#90f2ff',
                    duration: 0.6
                }));
            }

            function fireAegisGravityAnchors(b, dmgScale, state) {
                const orbs = (state && state.enraged) ? 3 : 2;
                const radius = state ? state.shieldRadius : b.r + 24;
                const baseAngle = Math.random() * Math.PI * 2;
                for (let i = 0; i < orbs; i++) {
                    const angle = baseAngle + (i / orbs) * Math.PI * 2;
                    const spawnX = b.x + Math.cos(angle) * radius;
                    const spawnY = b.y + Math.sin(angle) * radius;
                    const speed = 90 + Math.random() * 40;
                    store.eBullets.push({
                        x: spawnX,
                        y: spawnY,
                        vx: Math.cos(angle) * speed * 0.35,
                        vy: Math.sin(angle) * speed * 0.35,
                        r: 9,
                        col: '#c8b2ff',
                        dmg: 26 * dmgScale,
                        life: 6.5,
                        path: 'aegis_gravity',
                        homingStrength: 125 + (state ? state.difficultyScale : 1) * 15,
                        maxSpeed: 260,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, radius + 18, {
                    color: '#c8b2ff',
                    duration: 0.7
                }));
            }

            function fireAegisCataclysm(b, dmgScale, state) {
                const count = (state && state.enraged) ? 18 : 14;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const speed = (state && state.enraged) ? 320 : 250;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: 5,
                        col: '#5dd0ff',
                        dmg: 18 * dmgScale,
                        life: 4.2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, (state ? state.shieldRadius : b.r + 24) + 30, {
                    color: '#5dd0ff',
                    duration: 0.8
                }));
            }

            function nextAegisPattern(state) {
                if (!state || !state.availablePatterns.length) {
                    return 'baseline';
                }
                state.patternIndex = (state.patternIndex + 1) % state.availablePatterns.length;
                return state.availablePatterns[state.patternIndex];
            }

            function getAegisPatternCooldown(pattern, state) {
                const base = state && state.enraged ? 1.4 : 2.2;
                let cooldown = base;
                switch (pattern) {
                    case 'baseline':
                        cooldown = base * 0.9;
                        break;
                    case 'solar_burst':
                        cooldown = base * 1.05;
                        break;
                    case 'prismatic_grid':
                        cooldown = base * 1.15;
                        break;
                    case 'gravity_well':
                        cooldown = base * 1.2;
                        break;
                    case 'cataclysm':
                        cooldown = Math.max(1.1, base * 0.85);
                        break;
                }
                if (state && state.enraged) {
                    cooldown *= 0.75;
                }
                return Math.max(0.7, cooldown);
            }

            function stepBossCoreAegisArchitect(dt, b, dmgScale) {
                const state = ensureAegisArchitectState(b);
                if (!state) return;

                const hpRatio = b.hpMax > 0 ? b.hp / b.hpMax : 1;
                if (hpRatio <= 0.35 && !state.enraged) {
                    state.enraged = true;
                    b.isEnraged = true;
                    state.rotationSpeed *= 1.35;
                    if (typeof announce === 'function') {
                        announce('Architect protocols enraged! Shield rotation accelerating!');
                    }
                }

                if (b.y < 130) {
                    b.y = Math.min(130, b.y + 140 * dt);
                } else {
                    // Smooth circular/figure-8 movement pattern
                    b.moveT += dt * (state.enraged ? 0.65 : 0.5);
                    const radiusX = 180;
                    const radiusY = 50;
                    b.x = W / 2 + Math.sin(b.moveT) * radiusX;
                    b.y = 130 + Math.sin(b.moveT * 2) * radiusY; // Figure-8 pattern
                }

                const spinMultiplier = state.enraged ? 1.35 : 1;
                state.rotationAngle += state.rotationSpeed * dt * state.rotationDirection * spinMultiplier;
                if (state.rotationAngle > Math.PI * 2 || state.rotationAngle < -Math.PI * 2) {
                    state.rotationAngle = Math.atan2(Math.sin(state.rotationAngle), Math.cos(state.rotationAngle));
                }

                state.corePulse += dt * (state.enraged ? 4.0 : 2.8);
                state.segments.forEach(segment => {
                    if (segment.hitPulse > 0) {
                        segment.hitPulse = Math.max(0, segment.hitPulse - dt);
                    }
                });

                state.attackTimer -= dt;
                if (state.attackTimer <= 0) {
                    const pattern = nextAegisPattern(state);
                    switch (pattern) {
                        case 'solar_burst':
                            fireAegisSolarBurst(b, dmgScale, state);
                            break;
                        case 'prismatic_grid':
                            fireAegisPrismaticGrid(b, dmgScale, state);
                            break;
                        case 'gravity_well':
                            fireAegisGravityAnchors(b, dmgScale, state);
                            break;
                        case 'cataclysm':
                            fireAegisCataclysm(b, dmgScale, state);
                            break;
                        default:
                            fireAegisBaselineVolley(b, dmgScale, state);
                            break;
                    }
                    state.attackTimer = getAegisPatternCooldown(pattern, state);
                }
            }
            function stepBossTheHex(dt, b, dmgScale) {
                if (b.y >= 100) {
                    b.moveT += dt;
                    if (b.dashTimer && b.dashTimer > 0) {
                        b.dashTimer -= dt;
                        b.x += b.vx * dt;
                        b.x = clamp(b.x, b.r, W - b.r);
                        if (b.dashTimer <= 0) {
                            b.dashTimer = 0;
                            b.vx = 0;
                            b.dashTrailCooldown = 0;
                        }
                    } else {
                        const desiredX = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4));
                        const followSpeed = 6;
                        b.x += (desiredX - b.x) * Math.min(1, followSpeed * dt);
                    }
                }

                b.fireT -= dt;
                if (b.hp / b.hpMax < 0.5 && !b.isEnraged) {
                    b.isEnraged = true;
                    playSound('trap');
                }
                const fireRate = b.isEnraged ? 0.8 : 1.5;
                if (b.fireT <= 0) {
                    b.fireT = fireRate;
                    b.attackPhase = (b.attackPhase + 1) % 3;
                    switch (b.attackPhase) {
                        case 0:
                            // Gold rain with interspersed powerups for strategic gambling
                            b.rainEvent = {
                                remaining: 20,
                                interval: 0.05,
                                timer: 0
                            };
                            break;
                        case 1:
                            for (let i = 0; i < 4; i++) {
                                const isHorizontal = i < 2;
                                const y = isHorizontal ? 100 + i * 150 : 0;
                                const x = isHorizontal ? 0 : 200 + (i - 2) * 250;
                                const vx = isHorizontal ? 300 : 0;
                                const vy = isHorizontal ? 0 : 300;
                                store.eBullets.push({
                                    x: x,
                                    y: y,
                                    vx: vx,
                                    vy: vy,
                                    r: 4,
                                    col: '#80ffff',
                                    dmg: 20 * dmgScale,
                                    isLaser: true,
                                    life: 2.5
                                });
                            }
                            break;
                        case 2:
                            const targetX = store.player.x;
                            const dx = targetX - b.x;
                            const dashSpeed = 800;
                            const direction = dx === 0 ? (Math.random() < 0.5 ? -1 : 1) : Math.sign(dx);
                            b.vx = direction * dashSpeed;
                            b.dashTimer = 0.5;
                            b.dashTrailCooldown = 0;
                            break;
                    }
                }
                if (b.rainEvent && b.rainEvent.remaining > 0) {
                    b.rainEvent.timer -= dt;
                    while (b.rainEvent.timer <= 0 && b.rainEvent.remaining > 0) {
                        b.rainEvent.timer += b.rainEvent.interval;
                        b.rainEvent.remaining--;
                        if (Math.random() < 0.2) {
                            const powerupTypes = ['double', 'missile', 'drones', 'shield'];
                            const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];

                            store.powerups.push({
                                x: Math.random() * W,
                                y: 0,
                                vx: 0,
                                vy: 250,
                                r: 6,
                                type: randomType,
                                life: H / 250 + 2
                            });
                        } else {
                            store.eBullets.push({
                                x: Math.random() * W,
                                y: 0,
                                vx: 0,
                                vy: 250,
                                r: 5,
                                col: '#ffc83d',
                                dmg: 15 * dmgScale
                            });
                        }
                    }
                    if (b.rainEvent.remaining <= 0) {
                        b.rainEvent = null;
                    }
                }
                if (b.dashTimer && b.dashTimer > 0) {
                    b.dashTrailCooldown -= dt;
                    if (b.dashTrailCooldown <= 0) {
                        b.dashTrailCooldown += 0.12;
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: 0,
                            vy: 0,
                            r: 8,
                            col: '#ff8080',
                            dmg: 25 * dmgScale,
                            life: 1
                        });
                    }
                }
            }
            function stepBossGeometron(dt, b, dmgScale) {
                // Handle DEATH ENGINE specific behavior
                if (b.name === 'DEATH ENGINE') {
                    // Initialize skull ship specific properties
                    if (!b.skullPhaseInitialized) {
                        b.skullPhaseInitialized = true;
                        b.phase = 1;
                        b.disappearPhase = false;
                        b.disappearStartTime = 0;
                        b.safeZoneY = H * 0.5; // Start safe zone in middle
                        b.safeZoneChanges = 0;
                        b.maxSafeZoneChanges = 3;
                        b.hasDoneSecondDisappear = false;
                    }

                    // Phase 1: Normal attacks until 50% HP
                    if (b.phase === 1 && b.hp / b.hpMax > 0.5) {
                        // Movement
                        if (b.y >= 100) {
                            b.moveT += dt;
                            b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * 0.3);
                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }
                        }

                        // Normal attack pattern
                        b.fireT -= dt;
                        if (b.fireT <= 0) {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = 2.5;
                            switch (b.attackPhase) {
                                case 0:
                                    // Trigger Death Engine laugh
                                    b.isLaughing = true;
                                    b.laughStartTime = performance.now();
                                    if (b.skullRenderer) {
                                        b.skullRenderer.triggerAttack(true);
                                    }
                                    const n = 12;
                                    for (let i = 0; i < n; i++) {
                                        const a = (i * 2 * Math.PI / n) + b.t * 0.5;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 160 * Math.cos(a), vy: 160 * Math.sin(a), r: 4, col: '#8B0000', dmg: 18 * dmgScale });
                                    }
                                    break;
                                case 1:
                                    // Aimed shots at player
                                    const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    for (let i = 0; i < 5; i++) {
                                        const angle = angleToPlayer + (i - 2) * 0.15;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 280 * Math.cos(angle), vy: 280 * Math.sin(angle), r: 5, col: '#FF4500', dmg: 22 * dmgScale });
                                    }
                                    break;
                                case 2:
                                    // Spawn construct gold
                                    const numgold = 2 + Math.floor(store.world.wave / 10);
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (Math.random() - 0.5) * 120;
                                        gold.y = b.y + 60;
                                        gold.color = '#8B0000';
                                        store.enemies.push(gold);
                                    }
                                    break;
                                case 3:
                                    // New attack phase: Bouncing skull projectiles
                                    for (let i = 0; i < 6; i++) {
                                        const angle = (i * Math.PI / 3) + (Math.random() - 0.5) * 0.3;
                                        const speed = 150 + Math.random() * 50;
                                        store.eBullets.push({
                                            x: b.x,
                                            y: b.y,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            r: 6,
                                            col: '#DC143C',
                                            dmg: 20 * dmgScale,
                                            bounces: 2, // Special bouncing bullets
                                            life: 4.0
                                        });
                                    }
                                    break;
                            }
                        }
                    }
                    // Phase transition: Disappear and start train bullet pattern
                    else if (b.phase === 1 && b.hp / b.hpMax <= 0.5) {
                        b.phase = 2;
                        b.disappearPhase = true;
                        b.disappearStartTime = performance.now();
                        b.isInvincible = true;
                        b.visible = false; // Hide the boss

                        // Move boss offscreen below player so it can't be shot
                        b.x = W / 2;
                        b.y = H + 200; // Move well below the screen

                        // Update skull renderer position to be offscreen too
                        if (b.skullRenderer) {
                            b.skullRenderer.x = b.x;
                            b.skullRenderer.y = b.y;
                        }

                        playSound('shao_kahn'); // Skull laugh when disappearing
                        announce('THE DEATH ENGINE VANISHES INTO THE VOID!');

                        // Reset safe zone position and changes
                        b.safeZoneY = H * 0.5;
                        b.safeZoneChanges = 0;
                    }
                    // Phase 2: Disappear phase with train bullets
                    else if (b.disappearPhase) {
                        const disappearTime = (performance.now() - b.disappearStartTime) / 1000;

                        // Spawn train bullets continuously - 2 chunks moving opposite directions with safe zone in middle
                        if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                        b.trainBulletTimer -= dt;

                        if (b.trainBulletTimer <= 0) {
                            b.trainBulletTimer = 0.08; // Very frequent spawning

                            const safeZoneHeight = 120; // Safe zone in middle
                            const safeZoneY = H * 0.5; // Center of screen
                            const bulletSpeed = 280;
                            const bulletSpacing = 25;

                            // Top chunk: bullets moving right to left (from top)
                            const topBoundary = safeZoneY - safeZoneHeight / 2;
                            if (topBoundary > 30) {
                                for (let y = 0; y < topBoundary; y += bulletSpacing) {
                                    store.eBullets.push({
                                        x: -10, y: y,
                                        vx: bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }
                            }

                            // Bottom chunk: bullets moving left to right (from bottom)
                            const bottomBoundary = safeZoneY + safeZoneHeight / 2;
                            if (bottomBoundary < H - 30) {
                                for (let y = bottomBoundary; y < H; y += bulletSpacing) {
                                    store.eBullets.push({
                                        x: W + 10, y: y,
                                        vx: -bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }
                            }
                        }

                        // Return after 4 seconds (single phase)
                        if (disappearTime > 4) {
                            b.disappearPhase = false;
                            b.visible = true;
                            b.isInvincible = false;
                            b.fireT = 1.0;

                            // Reposition boss
                            b.x = W / 2;
                            b.y = 100;

                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }

                            playSound('shao_kahn'); // Another laugh as he returns
                            announce('THE DEATH ENGINE RETURNS!');
                        }
                    }
                    // Second disappear phase (enraged) - 2 fields of bullets with contact safe zone
                    else if (b.disappearPhase && b.hasDoneSecondDisappear) {
                        const disappearTime = (performance.now() - b.disappearStartTime) / 1000;

                        // Spawn train bullets continuously - 2 fields going opposite directions with contact safe zone
                        if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                        b.trainBulletTimer -= dt;

                        if (b.trainBulletTimer <= 0) {
                            b.trainBulletTimer = 0.06; // Even more frequent spawning for enraged phase

                            const safeZoneWidth = 60; // Narrower safe zone - contact without buffer
                            const safeZoneX = W * 0.5; // Center of screen
                            const bulletSpeed = 320; // Faster bullets
                            const bulletSpacing = 20;

                            // Left field: bullets moving right (from left side)
                            const leftBoundary = safeZoneX - safeZoneWidth / 2;
                            if (leftBoundary > 30) {
                                for (let x = 0; x < leftBoundary; x += bulletSpacing) {
                                    for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                        store.eBullets.push({
                                            x: x, y: y,
                                            vx: bulletSpeed, vy: 0,
                                            r: 5, col: '#FF0000',
                                            dmg: 30 * dmgScale, // Higher damage
                                            life: (W + 20) / bulletSpeed + 1,
                                            fadeInTime: 2.0, // 2 second fade-in
                                            spawnTime: performance.now()
                                        });
                                    }
                                }
                            }

                            // Right field: bullets moving left (from right side)
                            const rightBoundary = safeZoneX + safeZoneWidth / 2;
                            if (rightBoundary < W - 30) {
                                for (let x = rightBoundary; x < W; x += bulletSpacing) {
                                    for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                        store.eBullets.push({
                                            x: x, y: y,
                                            vx: -bulletSpeed, vy: 0,
                                            r: 5, col: '#FF0000',
                                            dmg: 30 * dmgScale, // Higher damage
                                            life: (W + 20) / bulletSpeed + 1,
                                            fadeInTime: 2.0, // 2 second fade-in
                                            spawnTime: performance.now()
                                        });
                                    }
                                }
                            }
                        }

                        // Return after 5 seconds (longer enraged phase)
                        if (disappearTime > 5) {
                            b.disappearPhase = false;
                            b.visible = true;
                            b.isInvincible = false;
                            b.fireT = 0.5; // Very aggressive after returning

                            // Reposition boss
                            b.x = W / 2;
                            b.y = 100;

                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }

                            playSound('shao_kahn'); // Final laugh as he returns
                            announce('THE DEATH ENGINE RETURNS FOR THE FINAL ASSAULT!');
                        }
                    }
                    // Phase 2: Normal combat after returning
                    else if (b.phase === 2 && !b.disappearPhase) {
                        // Calculate health percentage for final phase mechanics
                        const healthPercent = b.hp / b.hpMax;
                        const isFinalPhase = healthPercent <= 0.25; // Final phase at 25% health

                        // Second disappear phase when enraged (red)
                        if (isFinalPhase && !b.hasDoneSecondDisappear) {
                            b.hasDoneSecondDisappear = true;
                            b.disappearPhase = true;
                            b.disappearStartTime = performance.now();
                            b.isInvincible = true;
                            b.visible = false;

                            // Move boss offscreen
                            b.x = W / 2;
                            b.y = H + 200;

                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }

                            playSound('shao_kahn'); // Skull laugh when disappearing again
                            announce('THE DEATH ENGINE VANISHES INTO THE VOID AGAIN!');

                            // Reset bullet timer
                            b.trainBulletTimer = 0;
                        }

                        // Red coloration and faster movement in final phase
                        const moveSpeed = isFinalPhase ? 0.9 : 0.6; // Faster movement when low on health
                        if (b.y >= 100) {
                            b.moveT += dt;
                            b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed);
                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }
                        }

                        // Override skull ship color to red when in final phase
                        if (isFinalPhase && b.color !== '#FF0000') {
                            b.color = '#FF0000'; // Turn red in final phase
                        }

                        // ENRAGE PHASE: Spawn 1/4 density of intermission bullets passing through play field
                        if (isFinalPhase) {
                            if (!b.enrageBulletTimer) b.enrageBulletTimer = 0;
                            b.enrageBulletTimer -= dt;

                            if (b.enrageBulletTimer <= 0) {
                                b.enrageBulletTimer = 0.32; // 1/4 density of normal intermission (0.08 * 4)

                                const bulletSpeed = 280;
                                const bulletSpacing = 25;

                                // Spawn bullets from left side moving right (top half)
                                for (let y = 0; y < H * 0.5; y += bulletSpacing * 4) { // Every 4th bullet spacing
                                    store.eBullets.push({
                                        x: -10, y: y,
                                        vx: bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }

                                // Spawn bullets from right side moving left (bottom half)
                                for (let y = H * 0.5; y < H; y += bulletSpacing * 4) { // Every 4th bullet spacing
                                    store.eBullets.push({
                                        x: W + 10, y: y,
                                        vx: -bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }
                            }
                        }

                        // More aggressive attacks, even faster in final phase
                        const fireRate = isFinalPhase ? 1.2 : 1.8; // Faster attacks in final phase
                        b.fireT -= dt;
                        if (b.fireT <= 0) {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = fireRate;
                            switch (b.attackPhase) {
                                case 0:
                                    // Trigger Death Engine laugh
                                    b.isLaughing = true;
                                    b.laughStartTime = performance.now();
                                    if (b.skullRenderer) {
                                        b.skullRenderer.triggerAttack(true);
                                    }
                                    // Dense spiral (more bullets in final phase)
                                    const n = isFinalPhase ? 20 : 16;
                                    for (let i = 0; i < n; i++) {
                                        const a = (i * 2 * Math.PI / n) + b.t * 1.2;
                                        const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 200 * Math.cos(a), vy: 200 * Math.sin(a), r: 5, col: bulletColor, dmg: 20 * dmgScale });
                                    }
                                    break;
                                case 1:
                                    // Triple aimed shots (more spread in final phase)
                                    const shotCount = isFinalPhase ? 9 : 7;
                                    const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    for (let i = 0; i < shotCount; i++) {
                                        const angle = angleToPlayer + (i - Math.floor(shotCount / 2)) * 0.12;
                                        const bulletColor = isFinalPhase ? '#FF0000' : '#FF4500';
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 320 * Math.cos(angle), vy: 320 * Math.sin(angle), r: 5, col: bulletColor, dmg: 25 * dmgScale });
                                    }
                                    break;
                                case 2:
                                    // More gold (significantly more in final phase)
                                    const basegold = 3 + Math.floor(store.world.wave / 8);
                                    const finalPhaseBonus = isFinalPhase ? Math.floor(basegold * 0.75) : 0; // 75% more adds in final phase
                                    const numgold = basegold + finalPhaseBonus;
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (Math.random() - 0.5) * 150;
                                        gold.y = b.y + 60;
                                        gold.color = isFinalPhase ? '#FF0000' : '#FF0000';
                                        gold.hp *= isFinalPhase ? 1.5 : 1.3; // Tougher adds in final phase
                                        store.enemies.push(gold);
                                    }
                                    break;
                                case 3:
                                    // Cross pattern (more layers in final phase)
                                    const layers = isFinalPhase ? 4 : 3;
                                    for (let i = 0; i < 4; i++) {
                                        const angle = i * Math.PI / 2;
                                        for (let j = 1; j <= layers; j++) {
                                            const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                            store.eBullets.push({
                                                x: b.x, y: b.y,
                                                vx: 180 * j * 0.7 * Math.cos(angle),
                                                vy: 180 * j * 0.7 * Math.sin(angle),
                                                r: 4, col: bulletColor, dmg: 18 * dmgScale
                                            });
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                } else {
                    // Original GEOMETRON logic (unchanged)
                    if (b.hp / b.hpMax < 0.5 && b.phase === 1) {
                        b.phase = 2;
                        b.isInvincible = true;
                        playSound('horn');
                        store.activeEffects.push(createEffect("bossPhaseChange", b.x, b.y));
                        b.attackPhase = 0;
                        b.fireT = 2.0;
                        setTimeout(() => { b.isInvincible = false; }, 2000);
                        announce('GEOMETRON ENRAGED!');
                    }

                    // Movement logic
                    if (b.y >= 100) {
                        b.moveT += dt;
                        const moveSpeed = (b.phase === 1) ? 0.3 : 0.7;
                        b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed);
                    }

                    // Attack logic
                    b.fireT -= dt;
                    if (b.fireT <= 0) {
                        if (b.phase === 1) {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = 2.5;
                            switch (b.attackPhase) {
                                case 0:
                                case 2:
                                    const n = 16;
                                    for (let i = 0; i < n; i++) {
                                        const a = (i * 2 * Math.PI / n) + b.t * 0.5;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale });
                                    }
                                    break;
                                case 1:
                                case 3:
                                    const numgold = 3 + Math.floor(store.world.wave / 10);
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (Math.random() - 0.5) * 100;
                                        gold.y = b.y + 50;
                                        store.enemies.push(gold);
                                    }
                                    break;
                            }
                        } else {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = 2.0;
                            switch (b.attackPhase) {
                                case 0:
                                case 2:
                                    const spread = 8;
                                    const numShots = 8;
                                    const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    for (let i = 0; i < numShots; i++) {
                                        const angle = angleToPlayer + (i - (numShots - 1) / 2) * (spread * Math.PI / 180) * 0.1;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 350 * Math.cos(angle), vy: 350 * Math.sin(angle), r: 4, col: '#ff4500', dmg: 22 * dmgScale, life: 2.0 });
                                    }
                                    break;
                                case 1:
                                case 3:
                                    const numgold = 2;
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (i === 0 ? -50 : 50);
                                        gold.y = b.y + 50;
                                        gold.hp *= 1.5;
                                        gold.v *= 1.3;
                                        gold.color = '#ff4500';
                                        store.enemies.push(gold);
                                    }
                                    break;
                            }
                        }
                    }
                }
            }
            function stepBossVoidRaven(dt, b, dmgScale) { b.moveT += dt; if (!b.isDiving) { b.y = 100 + Math.sin(b.moveT * 2) * 20; b.x = W / 2 + Math.cos(b.moveT * 0.5) * (W / 2 - 100); } b.fireT -= dt; if (b.fireT <= 0) { b.attackPhase = (b.attackPhase + 1) % 5; switch (b.attackPhase) { case 0: case 2: b.fireT = 1.2; for (let i = 0; i < 7; i++) { const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: '#4169e1', dmg: 18 * dmgScale }); } break; case 1: case 3: b.fireT = 2.0; const numHatchlings = 2 + Math.floor(store.world.wave / 15); for (let i = 0; i < numHatchlings; i++) { const hatchling = spawnEnemy('avian_hatchling'); hatchling.x = b.x + (Math.random() - 0.5) * 80; hatchling.y = b.y + 40; store.enemies.push(hatchling); } break; case 4: b.fireT = 4.0; b.isDiving = true; b.diveTarget = { x: store.player.x, y: store.player.y }; const dx = b.diveTarget.x - b.x; const dy = b.diveTarget.y - b.y; const dist = Math.sqrt(dx * dx + dy * dy); b.vx = (dx / dist) * 400; b.vy = (dy / dist) * 400; setTimeout(() => { b.isDiving = false; b.vx = 0; b.vy = 30; }, 1500); break; } } if (b.isDiving) { b.x += b.vx * dt; b.y += b.vy * dt; } }

            function stepBossBroodlord(dt, b, dmgScale) {
                // Initialize poison puddles array if not exists
                if (!store.poisonPuddles) {
                    store.poisonPuddles = [];
                }

                // Broodlord skittering movement
                b.moveT += dt;
                if (!b.spiderInit) {
                    b.spiderInit = true;
                    b.spiderVX = (Math.random() < 0.5 ? -1 : 1) * (120 + Math.random() * 40);
                    b.spiderVY = 90 + Math.random() * 50;
                    b.webRetargetT = 1.4;
                    b.poisonTrailT = 1.2;
                }

                const speedScale = 1 + Math.min(0.75, Math.max(0, store.world.wave - 10) * 0.02);
                b.x += b.spiderVX * speedScale * dt;
                b.y += b.spiderVY * speedScale * dt;

                const minX = 90;
                const maxX = W - 90;
                const minY = 90;
                const maxY = Math.min(H - 170, H * 0.78);

                if (b.x <= minX && b.spiderVX < 0) {
                    b.x = minX;
                    b.spiderVX = Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
                    b.spiderVY += (Math.random() - 0.5) * 140;
                } else if (b.x >= maxX && b.spiderVX > 0) {
                    b.x = maxX;
                    b.spiderVX = -Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
                    b.spiderVY += (Math.random() - 0.5) * 140;
                }

                if (b.y <= minY && b.spiderVY < 0) {
                    b.y = minY;
                    b.spiderVY = Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
                    b.spiderVX += (Math.random() - 0.5) * 110;
                } else if (b.y >= maxY && b.spiderVY > 0) {
                    b.y = maxY;
                    b.spiderVY = -Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
                    b.spiderVX += (Math.random() - 0.5) * 110;
                }

                b.spiderVX = clamp(b.spiderVX, -260, 260);
                b.spiderVY = clamp(b.spiderVY, -240, 240);

                b.webRetargetT -= dt;
                if (b.webRetargetT <= 0) {
                    const player = store.player;
                    const dx = player.x - b.x;
                    const dy = (player.y - 40) - b.y;
                    const dist = Math.max(120, Math.hypot(dx, dy));
                    const chaseStrengthX = 180 + Math.random() * 60;
                    const chaseStrengthY = 170 + Math.random() * 60;
                    b.spiderVX = clamp(b.spiderVX * 0.5 + (dx / dist) * chaseStrengthX, -260, 260);
                    b.spiderVY = clamp(b.spiderVY * 0.5 + (dy / dist) * chaseStrengthY, -240, 240);
                    b.webRetargetT = 1.3 + Math.random() * 0.9;
                }

                b.poisonTrailT -= dt;
                if (b.poisonTrailT <= 0) {
                    const puddleX = clamp(b.x + (Math.random() - 0.5) * 120, 40, W - 40);
                    const puddleY = clamp(b.y + Math.random() * 120, 80, H - 80);
                    store.poisonPuddles.push({
                        x: puddleX,
                        y: puddleY,
                        r: 18 + Math.random() * 12,
                        life: getHivePuddleLifetime(4.8, 3.2, { min: 4.2, maxWaveBonus: 4.5 }),
                        damage: 10 * dmgScale,
                        created: performance.now()
                    });
                    const trailReset = 2.4 - Math.min(1.4, store.world.wave * 0.035);
                    b.poisonTrailT = Math.max(0.9, trailReset);
                }

                // Attack phases
                b.fireT -= dt;
                if (b.fireT <= 0) {
                    b.attackPhase = (b.attackPhase + 1) % 4;

                    switch (b.attackPhase) {
                        case 0:
                        case 2:
                            // Poison blob barrage
                            b.fireT = 1.8;
                            const numBlobs = 5 + Math.floor(store.world.wave / 10);
                            for (let i = 0; i < numBlobs; i++) {
                                const spread = Math.PI * 0.6;
                                const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                const angle = baseAngle + (Math.random() - 0.5) * spread;
                                const speed = 180 + Math.random() * 80;

                                store.eBullets.push({
                                    x: b.x,
                                    y: b.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    r: 8,
                                    col: '#7cfc00',
                                    dmg: 22 * dmgScale,
                                    life: 4,
                                    type: 'poisonBlob'
                                });
                            }
                            break;

                        case 1:
                            // Acid spit pattern
                            b.fireT = 2.2;
                            for (let i = 0; i < 8; i++) {
                                const angle = (i * Math.PI / 4) + b.t * 0.5;
                                store.eBullets.push({
                                    x: b.x,
                                    y: b.y,
                                    vx: Math.cos(angle) * 160,
                                    vy: Math.sin(angle) * 160,
                                    r: 6,
                                    col: '#adff2f',
                                    dmg: 20 * dmgScale,
                                    life: 3,
                                    type: 'poisonBlob'
                                });
                            }
                            break;

                        case 3:
                            // Toxic ground slam - saturate arena with dangerous puddles
                            b.fireT = 2.6;
                            const playerPos = store.player;
                            const webSpots = [
                                { x: clamp(playerPos.x, 80, W - 80), y: clamp(playerPos.y + 40, 120, H - 90) },
                                { x: clamp(playerPos.x + 180, 80, W - 80), y: clamp(playerPos.y - 20, 120, H - 90) },
                                { x: clamp(playerPos.x - 180, 80, W - 80), y: clamp(playerPos.y + 80, 120, H - 90) },
                                { x: W * 0.25 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                                { x: W * 0.75 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                                { x: W * 0.5 + (Math.random() - 0.5) * 220, y: H * 0.55 + (Math.random() - 0.5) * 140 }
                            ];
                            for (let i = 0; i < 6; i++) {
                                const node = webSpots[i % webSpots.length];
                                const puddleX = clamp(node.x + (Math.random() - 0.5) * 70, 40, W - 40);
                                const puddleY = clamp(node.y + (Math.random() - 0.5) * 70, 80, H - 70);
                                store.poisonPuddles.push({
                                    x: puddleX,
                                    y: puddleY,
                                    r: 28 + Math.random() * 18,
                                    life: getHivePuddleLifetime(7.5, 4.5, { min: 6.5, waveBonusPer: 0.4, maxWaveBonus: 6.5 }),
                                    damage: 15 * dmgScale,
                                    created: performance.now()
                                });
                            }
                            break;
                    }
                }

                const now = performance.now();
                const bossRadius = b.r || 80;
                const puddleDamageInterval = 600; // ms between damage ticks while boss is in the acid

                for (let i = store.poisonPuddles.length - 1; i >= 0; i--) {
                    const puddle = store.poisonPuddles[i];
                    puddle.life -= dt;
                    if (puddle.life <= 0) {
                        store.poisonPuddles.splice(i, 1);
                        continue;
                    }

                    const dx = b.x - puddle.x;
                    const dy = b.y - puddle.y;
                    const dist = Math.hypot(dx, dy);
                    const effectiveRadius = puddle.r + bossRadius * 0.55;

                    if (dist < effectiveRadius) {
                        // Standing in the acid slows and harms the Hive Sovereign
                        b.slowTimer = Math.max(b.slowTimer || 0, 0.45);

                        if (!b.lastPuddleDamageTime || now - b.lastPuddleDamageTime >= puddleDamageInterval) {
                            const puddleDamage = Math.max(8, puddle.damage * 0.9);
                            b.hp -= puddleDamage;
                            store.world.totalDamage += puddleDamage;
                            b.lastPuddleDamageTime = now;

                            if (b.hp <= 0) {
                                handleBossDefeat();
                                return;
                            }
                        }
                    }
                }
            }

            function stepBoss(dt) {
                const b = store.boss;
                b.t += dt;
                if (b.y < 100) { b.y += b.vy * dt; }
                const dmgScale = Math.pow(1.065, store.world.wave - 1);
                tickChampionBurn(b, dt);
                tickChampionVoidMarks(b, dt);

                if (b.slowTimer > 0) { b.slowTimer -= dt; dt *= 0.3; }

                switch (b.behavior) {
                    case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break;
                    case 'aegis_architect': stepBossCoreAegisArchitect(dt, b, dmgScale); break;
                    case 'hex': stepBossTheHex(dt, b, dmgScale); break;
                    case 'construct': stepBossGeometron(dt, b, dmgScale); break;
                    case 'shadow_clone': stepBossShadowClone(dt, b, dmgScale); break;
                    case 'avian': stepBossVoidRaven(dt, b, dmgScale); break;
                    case 'broodlord': stepBossBroodlord(dt, b, dmgScale); break;
                    case 'asynchronos': stepBossAsynchronos(dt, b, dmgScale); break;
                }
            }
            function drawMissile(m) {
                ctx.save();
                ctx.translate(m.x, m.y);
                ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2);

                if (m.isStealth) {
                    // Advanced stealth rocket design - sleeker and more futuristic
                    ctx.fillStyle = "#2a2a2a"; // Dark metallic body
                    ctx.strokeStyle = "#00ffff"; // Cyan highlights
                    ctx.lineWidth = 1;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 15;

                    // Main body - longer and sleeker
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(3, 0);
                    ctx.lineTo(2, 6);
                    ctx.lineTo(-2, 6);
                    ctx.lineTo(-3, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Stealth fins
                    ctx.beginPath();
                    ctx.moveTo(-2, 2);
                    ctx.lineTo(-5, 4);
                    ctx.lineTo(-2, 6);
                    ctx.moveTo(2, 2);
                    ctx.lineTo(5, 4);
                    ctx.lineTo(2, 6);
                    ctx.stroke();

                    // Advanced plasma exhaust
                    const flameSize = 10 + 3 * Math.sin(performance.now() / 30);
                    const grad = ctx.createLinearGradient(0, 6, 0, 6 + flameSize);
                    grad.addColorStop(0, 'rgba(0, 255, 255, 0.9)');
                    grad.addColorStop(0.5, 'rgba(0, 150, 255, 0.7)');
                    grad.addColorStop(1, 'rgba(0, 100, 200, 0.3)');
                    ctx.fillStyle = grad;

                    ctx.beginPath();
                    ctx.moveTo(-2, 6);
                    ctx.lineTo(2, 6);
                    ctx.lineTo(1, 6 + flameSize * 0.7);
                    ctx.lineTo(0, 6 + flameSize);
                    ctx.lineTo(-1, 6 + flameSize * 0.7);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Regular missile design
                    ctx.fillStyle = m.isIceman ? "#a0e9ff" : "#ffddff";
                    ctx.shadowColor = m.isIceman ? '#3c9aed' : '#ff8080';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(4, 5);
                    ctx.lineTo(-4, 5);
                    ctx.closePath();
                    ctx.fill();

                    ctx.shadowBlur = 0;

                    const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
                    ctx.fillStyle = m.isIceman ? `rgba(60, 154, 237, ${0.6 + 0.4 * Math.random()})` : `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;

                    ctx.beginPath();
                    ctx.moveTo(-3, 5);
                    ctx.lineTo(3, 5);
                    ctx.lineTo(0, 5 + flameSize);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
            function drawPowerup(p) {
                const cfg = POWERUP_TYPES[p.type];
                ctx.save();
                ctx.translate(p.x, p.y);

                const time = performance.now();
                const pulse = 0.8 + 0.2 * Math.sin(time / 150 + (p.pulseOffset || 0));
                ctx.scale(pulse, pulse);

                let glowInner = '#FFD70099';
                let glowOuter = '#FFD70000';
                let coreFill = '#FFD70044';
                let borderColor = '#FFD700';
                let iconColor = '#FFFFFF';
                let iconFont = 'bold 16px Orbitron';

                if (p.type === 'shadow_champion_token') {
                    glowInner = 'rgba(160, 180, 255, 0.85)';
                    glowOuter = 'rgba(80, 100, 235, 0)';
                    coreFill = 'rgba(80, 100, 220, 0.5)';
                    borderColor = 'rgba(220, 230, 255, 0.95)';
                    iconColor = '#f8f9ff';
                    iconFont = 'bold 18px Orbitron';
                } else if (p.type === 'collar_fragment') {
                    glowInner = 'rgba(90, 255, 210, 0.85)';
                    glowOuter = 'rgba(30, 150, 140, 0)';
                    coreFill = 'rgba(50, 220, 190, 0.5)';
                    borderColor = 'rgba(180, 255, 235, 0.95)';
                    iconColor = '#eafff5';
                    iconFont = 'bold 18px Orbitron';
                } else if (p.isVoidReaper && p.type === 'cash') {
                    // New Orleans style - purple & gold
                    glowInner = 'rgba(138, 43, 226, 0.85)'; // Purple
                    glowOuter = 'rgba(255, 215, 0, 0)'; // Gold fade
                    coreFill = 'rgba(138, 43, 226, 0.6)';
                    borderColor = 'rgba(255, 215, 0, 0.95)'; // Gold border
                    iconColor = '#FFD700';
                    iconFont = 'bold 18px Orbitron';
                }

                ctx.beginPath();
                ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2);
                const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3);
                glow.addColorStop(0, glowInner);
                glow.addColorStop(1, glowOuter);
                ctx.fillStyle = glow;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, 0, p.r, 0, Math.PI * 2);
                ctx.fillStyle = coreFill;
                ctx.fill();

                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                if (p.type === 'shadow_champion_token') {
                    const spin = (time / 480) % (Math.PI * 2);
                    ctx.save();
                    ctx.rotate(spin);
                    ctx.strokeStyle = 'rgba(245, 247, 255, 0.75)';
                    ctx.lineWidth = 1.2;
                    ctx.beginPath();
                    const runeRadius = p.r * 0.65;
                    ctx.moveTo(-runeRadius, 0);
                    ctx.lineTo(runeRadius, 0);
                    ctx.moveTo(0, -runeRadius);
                    ctx.lineTo(0, runeRadius);
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(235, 240, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.r * 0.45, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.type === 'collar_fragment') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(160, 255, 235, 0.8)';
                    ctx.lineWidth = 1.4;
                    ctx.beginPath();
                    const ringRadius = p.r * (0.55 + 0.08 * Math.sin(time / 260 + (p.pulseOffset || 0)));
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.fillStyle = iconColor;
                ctx.font = iconFont;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(cfg.icon, 0, 1);
                ctx.restore();
            }
            function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }

            function drawLaser(laser) {
                ctx.save();
                const trailLength = 200;
                const angle = Math.atan2(laser.vy, laser.vx);
                const startX = laser.x - Math.cos(angle) * trailLength;
                const startY = laser.y - Math.sin(angle) * trailLength;

                const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
                grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
                grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

                ctx.strokeStyle = grad;
                ctx.lineWidth = laser.r * 1.5;
                ctx.lineCap = 'round';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 25;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(laser.x, laser.y);
                ctx.stroke();

                // Inner bright core
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = `rgba(200, 220, 255, 0.8)`;
                ctx.shadowBlur = 10;
                ctx.stroke();

                ctx.restore();
            }

            function drawTemporalBeam() {
                const beam = store.temporalBeam;
                const boss = store.boss;
                if (!beam || !beam.active || !boss || boss.dead || boss.behavior !== 'asynchronos') return;

                const angle = beam.angle || 0;
                const length = beam.length || Math.max(W, H) + 160;
                const width = beam.width || 32;
                const telegraph = clamp(beam.telegraph || 0, 0, 1);
                const skipPulse = clamp(beam.skipPulse || 0, 0, 1);
                const originOffset = beam.originOffset !== undefined ? beam.originOffset : 1;
                const now = performance.now() / 1000;

                ctx.save();
                ctx.translate(boss.x, boss.y);
                ctx.rotate(angle);
                ctx.globalCompositeOperation = 'lighter';

                const baseWidth = width * (telegraph > 0 ? (0.45 + 0.55 * (1 - telegraph)) : 1);
                const auraWidth = baseWidth * (2.5 + skipPulse * 0.6); // Wider, more visible aura
                const startOffset = -length * 0.12 * (1 - originOffset);

                // Enhanced outer glow for better visibility
                const outerGlowGradient = ctx.createLinearGradient(0, -auraWidth * 1.4, 0, auraWidth * 1.4);
                outerGlowGradient.addColorStop(0, 'rgba(111, 242, 255, 0)');
                outerGlowGradient.addColorStop(0.3, 'rgba(111, 242, 255, 0.15)');
                outerGlowGradient.addColorStop(0.7, 'rgba(111, 242, 255, 0.15)');
                outerGlowGradient.addColorStop(1, 'rgba(111, 242, 255, 0)');
                ctx.fillStyle = outerGlowGradient;
                ctx.fillRect(startOffset, -auraWidth * 1.4, length, auraWidth * 2.8);

                // Main aura - brighter and more menacing
                const auraGradient = ctx.createLinearGradient(0, -auraWidth, 0, auraWidth);
                auraGradient.addColorStop(0, 'rgba(140, 246, 255, 0)');
                auraGradient.addColorStop(0.35, 'rgba(140, 246, 255, 0.45)'); // Increased from 0.24
                auraGradient.addColorStop(0.65, 'rgba(140, 246, 255, 0.45)');
                auraGradient.addColorStop(1, 'rgba(140, 246, 255, 0)');
                ctx.fillStyle = auraGradient;
                ctx.fillRect(startOffset, -auraWidth, length, auraWidth * 2);

                // Animated energy pulses traveling along beam
                const pulseCount = 3;
                for (let i = 0; i < pulseCount; i++) {
                    const pulsePhase = (now * 2 + i * (Math.PI * 2 / pulseCount)) % (Math.PI * 2);
                    const pulsePos = (Math.sin(pulsePhase) * 0.5 + 0.5) * length * 0.8;
                    const pulseRadius = baseWidth * 0.8;
                    const pulseGradient = ctx.createRadialGradient(pulsePos, 0, 0, pulsePos, 0, pulseRadius * 2);
                    pulseGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                    pulseGradient.addColorStop(0.5, 'rgba(140, 246, 255, 0.3)');
                    pulseGradient.addColorStop(1, 'rgba(140, 246, 255, 0)');
                    ctx.fillStyle = pulseGradient;
                    ctx.beginPath();
                    ctx.arc(pulsePos, 0, pulseRadius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Brighter core with pulsing effect
                const coreWidth = Math.max(8, baseWidth * 0.5); // Slightly thicker
                const corePulse = 0.8 + Math.sin(now * 6) * 0.2;
                const coreGradient = ctx.createLinearGradient(0, -coreWidth, 0, coreWidth);
                coreGradient.addColorStop(0, 'rgba(255,255,255,0)');
                coreGradient.addColorStop(0.5, `rgba(255, 255, 255, ${(0.85 + skipPulse * 0.45) * corePulse})`); // Brighter white core
                coreGradient.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = coreGradient;
                ctx.fillRect(startOffset, -coreWidth, length, coreWidth * 2);

                if (telegraph > 0.01) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = clamp(telegraph * 0.95, 0.3, 0.85); // More visible warning
                    ctx.lineWidth = Math.max(3, baseWidth * 0.7);
                    ctx.strokeStyle = addAlpha('#ff6666', 0.9); // Red warning color
                    const dash = baseWidth * 1.2;
                    ctx.setLineDash([dash * 0.5, dash * 0.5]);
                    ctx.beginPath();
                    ctx.moveTo(startOffset, 0);
                    ctx.lineTo(startOffset + length, 0);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Add visible edge markers to show danger zone boundaries
                const markerCount = 12;
                const markerPulse = 0.7 + Math.sin(now * 8) * 0.3;
                ctx.fillStyle = `rgba(255, 100, 100, ${0.7 * markerPulse})`;
                for (let i = 0; i < markerCount; i++) {
                    const markerX = startOffset + (i / (markerCount - 1)) * length;
                    const markerSize = telegraph > 0.01 ? 6 : 4;
                    // Top edge markers
                    ctx.beginPath();
                    ctx.arc(markerX, -baseWidth, markerSize, 0, Math.PI * 2);
                    ctx.fill();
                    // Bottom edge markers
                    ctx.beginPath();
                    ctx.arc(markerX, baseWidth, markerSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (skipPulse > 0.01) {
                    const pulseRadius = baseWidth * (1.6 + skipPulse * 1.2);
                    const pulseCenter = Math.min(length * 0.5, length - pulseRadius * 1.2);
                    const pulseGradient = ctx.createRadialGradient(pulseCenter, 0, 0, pulseCenter, 0, pulseRadius);
                    pulseGradient.addColorStop(0, `rgba(210, 255, 255, ${0.55 + skipPulse * 0.4})`);
                    pulseGradient.addColorStop(1, 'rgba(210, 255, 255, 0)');
                    ctx.fillStyle = pulseGradient;
                    ctx.beginPath();
                    ctx.arc(pulseCenter, 0, pulseRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
            // Helper: safely add alpha to a hex color (falls back if not hex)
            function addAlpha(color, alpha) {
                const a = Math.max(0, Math.min(1, alpha));
                if (typeof color === 'string' && color.startsWith('#')) {
                    let hex = color.slice(1);
                    if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
                    if (hex.length >= 6) {
                        const r = parseInt(hex.slice(0, 2), 16);
                        const g = parseInt(hex.slice(2, 4), 16);
                        const b = parseInt(hex.slice(4, 6), 16);
                        return `rgba(${r},${g},${b},${a})`;
                    }
                }
                // If it's not hex, return as-is (the caller can tweak globalAlpha if needed)
                return color;
            }

            // Skull Ship Drawing Functions

            /**
             * @class Boss
             * Represents the main antagonist character.
             * This class encapsulates all logic for rendering, animating, and managing the state of the boss.
             */
            class Boss {
                /**
                 * @param {CanvasRenderingContext2D} ctx The 2D rendering context for the canvas.
                 * @param {number} x The initial X position of the boss.
                 * @param {number} y The initial Y position of the boss.
                 * @param {string} skullColor The color for the skull (supports red final phase).
                 */
                constructor(ctx, x, y, skullColor = '#e54d24') {
                    this.ctx = ctx;
                    this.x = x;
                    this.y = y;
                    this.skullColor = skullColor;

                    this.width = 180;
                    this.height = 280;

                    // Animation state
                    this.isAttacking = false;
                    this.attackStartTime = 0;
                    this.bloodDrips = [];
                }

                /**
                 * Triggers the boss's attack animation (laugh and scythe swipe).
                 * This should be called from the main game logic (e.g., on a timer or player action).
                 * @param {boolean} playAudio - Whether to play the laugh sound effect.
                 */
                triggerAttack(playAudio = true) {
                    if (!this.isAttacking) {
                        this.isAttacking = true;
                        this.attackStartTime = Date.now();

                        // Play death engine laugh sound using game's sound system
                        if (playAudio && typeof playSound !== 'undefined') {
                            playSound('shao_kahn');
                        }

                        // Reset the attack state after the animation duration
                        setTimeout(() => {
                            this.isAttacking = false;
                        }, 3000);
                    }
                }

                /**
                 * Updates the boss's state. This should be called every frame in the game loop.
                 * It handles internal animations like the blood drips.
                 */
                update() {
                    this._updateBloodDrips();
                }

                /**
                 * Renders the boss on the canvas. This should be called every frame in the game loop after `update`.
                 */
                draw() {
                    this.ctx.save();
                    this.ctx.translate(this.x, this.y);
                    this._drawHorns();
                    this._drawHead();
                    this._drawFacialFeatures();
                    this._addWeathering(); // Scars
                    this._drawBloodDrips();
                    this.ctx.restore();
                }

                // --- Private Helper Methods ---

                _drawHorns() {
                    const { ctx, width: skullWidth, height: skullHeight } = this;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    let swipeAngle = 0;
                    if (this.isAttacking) {
                        const elapsedTime = Date.now() - this.attackStartTime;
                        const duration = 1000;
                        if (elapsedTime < duration) {
                            const progress = elapsedTime / duration;
                            swipeAngle = Math.sin(progress * Math.PI) * -0.3;
                        }
                    }

                    const drawHornScythe = (isFlipped) => {
                        const side = isFlipped ? -1 : 1;
                        ctx.save();

                        const handleGradient = ctx.createLinearGradient(0, -200, 0, 100);
                        handleGradient.addColorStop(0, '#111111');
                        handleGradient.addColorStop(0.5, '#333333');
                        handleGradient.addColorStop(1, '#222222');
                        ctx.fillStyle = handleGradient;
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 18;

                        ctx.beginPath();
                        ctx.moveTo(side * skullWidth * 0.35, -skullHeight * 0.4);
                        const handleEndX = side * 400;
                        const handleEndY = -skullHeight * 0.20;
                        ctx.bezierCurveTo(side * 220, -skullHeight * 0.9, side * 350, -skullHeight * 0.1, handleEndX, handleEndY);
                        ctx.bezierCurveTo(side * 360, 0, side * 230, -skullHeight * 0.55, side * skullWidth * 0.25, -skullHeight * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#4a4a4a';
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.ellipse(handleEndX - side * 10, handleEndY, 14, 20, side * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.ellipse(handleEndX - side * 35, handleEndY - 5, 12, 18, side * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        ctx.translate(handleEndX, handleEndY);
                        const baseRotation = Math.PI / 4;
                        ctx.rotate(side * baseRotation + side * swipeAngle);

                        const bladeGradient = ctx.createLinearGradient(side * 50, 0, side * 150, 300);
                        bladeGradient.addColorStop(0, '#ffffff');
                        bladeGradient.addColorStop(0.5, '#e3dac9');
                        bladeGradient.addColorStop(1, '#c1b8a8');
                        ctx.fillStyle = bladeGradient;
                        ctx.strokeStyle = '#8c8273';
                        ctx.lineWidth = 4;

                        ctx.beginPath();
                        const tipX = side * 150;
                        const tipY = 220;
                        ctx.moveTo(0, -15);
                        ctx.bezierCurveTo(side * 180, 80, side * 200, 200, tipX, tipY);
                        ctx.bezierCurveTo(side * 130, 160, side * 40, 70, 0, 15);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.save();
                        ctx.clip();
                        ctx.strokeStyle = 'rgba(80, 70, 60, 0.2)';
                        ctx.lineWidth = 1.5;
                        for (let i = 0; i < 30; i++) {
                            ctx.beginPath();
                            const startX = side * (Math.random() * 250);
                            const startY = -15 + Math.random() * 300;
                            const length = 20 + Math.random() * 30;
                            const angle = Math.random() * Math.PI * 2;
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
                            ctx.stroke();
                        }
                        ctx.restore();

                        if (this.isAttacking && Math.random() < 0.3) {
                            const dripSpawnPoint = { x: tipX / 2, y: tipY / 1.5 };
                            const rotatedPoint = {
                                x: dripSpawnPoint.x * Math.cos(side * baseRotation) - dripSpawnPoint.y * Math.sin(side * baseRotation),
                                y: dripSpawnPoint.x * Math.sin(side * baseRotation) + dripSpawnPoint.y * Math.cos(side * baseRotation)
                            };
                            this._addBloodDrip(handleEndX + rotatedPoint.x, handleEndY + rotatedPoint.y);
                        }

                        ctx.restore();
                    };

                    drawHornScythe(false);
                    drawHornScythe(true);
                }

                _drawHead() {
                    const { ctx, width: skullWidth, height: skullHeight, skullColor } = this;
                    const gradient = ctx.createRadialGradient(0, -50, skullWidth * 0.1, 0, 0, skullWidth * 1.2);

                    if (skullColor === '#FF0000') {
                        // Red final phase colors
                        gradient.addColorStop(0, '#ff6666');
                        gradient.addColorStop(0.5, '#ff0000');
                        gradient.addColorStop(1, '#660000');
                    } else {
                        // Original orange colors
                        gradient.addColorStop(0, '#ff8c66');
                        gradient.addColorStop(0.5, '#e54d24');
                        gradient.addColorStop(1, '#661a00');
                    }

                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#1a0a05';
                    ctx.lineWidth = 8;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                    ctx.shadowBlur = 20;

                    ctx.beginPath();
                    ctx.moveTo(0, -skullHeight * 0.55);
                    ctx.bezierCurveTo(-skullWidth * 0.6, -skullHeight * 0.6, -skullWidth * 0.6, -skullHeight * 0.1, -skullWidth * 0.5, -skullHeight * 0.2);
                    ctx.bezierCurveTo(-skullWidth * 0.6, skullHeight * 0.3, -skullWidth * 0.2, skullHeight * 0.55, 0, skullHeight * 0.52);
                    ctx.bezierCurveTo(skullWidth * 0.2, skullHeight * 0.55, skullWidth * 0.6, skullHeight * 0.3, skullWidth * 0.5, -skullHeight * 0.2);
                    ctx.bezierCurveTo(skullWidth * 0.6, -skullHeight * 0.1, skullWidth * 0.6, -skullHeight * 0.6, 0, -skullHeight * 0.55);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowColor = 'transparent';
                }

                _drawFacialFeatures() {
                    const { ctx, height: skullHeight } = this;

                    const drawMirrorEye = (offsetX, isFlipped) => {
                        ctx.save();
                        ctx.translate(offsetX, -10);
                        if (isFlipped) ctx.scale(-1, 1);
                        const eyePath = new Path2D();
                        eyePath.moveTo(-30, -20); eyePath.lineTo(30, -30); eyePath.lineTo(25, 28); eyePath.lineTo(-25, 25); eyePath.closePath();
                        for (let i = 0; i < 6; i++) {
                            ctx.fillStyle = (i % 2 === 0 || i === 5) ? '#1a0a05' : '#ff3300';
                            ctx.fill(eyePath);
                            ctx.scale(0.8, 0.75);
                        }
                        ctx.restore();
                    };
                    drawMirrorEye(-35, true);
                    drawMirrorEye(35, false);

                    let mouthOpenness = 0;
                    if (this.isAttacking) {
                        const elapsedTime = Date.now() - this.attackStartTime;
                        mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 15;
                    }

                    ctx.strokeStyle = 'rgba(26, 10, 5, 0.8)';
                    ctx.lineWidth = 2;

                    for (let i = -6; i <= 6; i++) {
                        if (i === 0) continue;
                        let toothWidth = 10;
                        let toothHeight = 25 - Math.abs(i) * 1.2;
                        const isCanine = Math.abs(i) === 5 || Math.abs(i) === 6;
                        if (isCanine) {
                            toothHeight += 18;
                            toothWidth -= 2;
                        }
                        const xPos = i * 9;
                        let yPos = skullHeight * 0.53;
                        yPos -= Math.pow(i, 2) * 1.8;
                        yPos += mouthOpenness;
                        ctx.save();
                        ctx.translate(xPos, yPos);
                        ctx.beginPath();
                        ctx.moveTo(-toothWidth / 2, 0);
                        ctx.lineTo(toothWidth / 2, 0);
                        ctx.lineTo(0, toothHeight);
                        ctx.closePath();
                        ctx.fillStyle = '#e8d9a9';
                        ctx.fill();
                        ctx.stroke();
                        const tipY = toothHeight;
                        ctx.fillStyle = '#8c1803';
                        ctx.beginPath();
                        ctx.ellipse(0, tipY, toothWidth / 3, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.ellipse(0, tipY, toothWidth / 5, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }

                _addWeathering() {
                    const { ctx } = this;
                    ctx.strokeStyle = 'rgba(26, 10, 5, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(40, -30);
                    ctx.lineTo(70, 10);
                    ctx.lineTo(65, 15);
                    ctx.stroke();
                }

                _addBloodDrip(x, y) {
                    if (this.bloodDrips.length > 100) return;
                    this.bloodDrips.push({
                        x: x,
                        y: y,
                        speed: 2 + Math.random() * 3,
                        size: 2 + Math.random() * 3
                    });
                }

                _updateBloodDrips() {
                    for (let i = this.bloodDrips.length - 1; i >= 0; i--) {
                        const drip = this.bloodDrips[i];
                        drip.y += drip.speed;
                        if (drip.y > this.ctx.canvas.height) {
                            this.bloodDrips.splice(i, 1);
                        }
                    }
                }

                _drawBloodDrips() {
                    const { ctx } = this;
                    ctx.fillStyle = '#8c1803';
                    for (const drip of this.bloodDrips) {
                        ctx.beginPath();
                        ctx.arc(drip.x, drip.y, drip.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            function drawBoss(t) {
                // Special rendering for Heat Death of the Universe
                if (t.isHeatDeath) {
                    // Darken the top half of screen with haze effect
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, W, H / 2);

                    // Add dark gray haze
                    ctx.fillStyle = 'rgba(32, 32, 32, 0.6)';
                    ctx.fillRect(0, 0, W, H / 2);

                    // No health bar or physical form - just the void
                    ctx.restore();
                    return;
                }

                ctx.save();
                ctx.translate(t.x, t.y);
                if (t.isEnraged) {
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50);
                }

                const activeBoss = (typeof store !== 'undefined' && store && store.boss) ? store.boss : null;
                const sameBoss = !!(activeBoss && (activeBoss === t || (activeBoss.instanceId && activeBoss.instanceId === t.instanceId) || (activeBoss._instanceId && activeBoss._instanceId === t._instanceId)));
                let bossHp = ensureFiniteNumber(t.hp, 0);
                let bossHpMax = ensureFiniteNumber(t.hpMax, 1);

                if (sameBoss) {
                    bossHp = ensureFiniteNumber(activeBoss.hp, bossHp);
                    bossHpMax = ensureFiniteNumber(activeBoss.hpMax, bossHpMax);
                    t.hp = bossHp;
                    t.hpMax = bossHpMax;
                }

                const hpRatio = bossHpMax > 0 ? clamp(bossHp / bossHpMax, 0, 1) : 0;

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(-60, -t.r - 20, 120, 8);
                const healthBarColor = t.name === 'EVIL BABYMOON' ? '#ffd700' : (t.color || '#ff4444');
                ctx.fillStyle = healthBarColor;
                ctx.fillRect(-60, -t.r - 20, 120 * hpRatio, 8);
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.strokeRect(-60, -t.r - 20, 120, 8);
                if (t.behavior === "aegis_architect") {
                    const state = ensureAegisArchitectState(t);
                    const now = performance.now() / 1000;
                    const baseCoreRadius = state ? state.coreRadius : t.r * 0.6;
                    const pulse = state ? Math.sin(state.corePulse) : Math.sin(now * 2.6);
                    const coreRadius = baseCoreRadius * (1 + 0.08 * pulse);

                    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    coreGradient.addColorStop(0, addAlpha('#ffffff', 0.9));
                    coreGradient.addColorStop(0.35, addAlpha(t.color || '#5dd0ff', 0.85));
                    coreGradient.addColorStop(1, addAlpha('#042033', 0.8));
                    ctx.fillStyle = coreGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                    ctx.fill();

                    const latticeRadius = coreRadius * 0.62;
                    ctx.strokeStyle = addAlpha('#ffffff', 0.35);
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, latticeRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.save();
                    ctx.rotate(now * 0.6);
                    ctx.globalAlpha = 0.75;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-latticeRadius, 0);
                        ctx.lineTo(latticeRadius, 0);
                        ctx.stroke();
                        ctx.rotate(Math.PI / 4);
                    }
                    ctx.restore();
                    ctx.globalAlpha = 1;

                    if (state) {
                        const outerRadius = state.shieldRadius;
                        const innerRadius = Math.max(outerRadius - 18, coreRadius + 12);

                        ctx.save();
                        ctx.rotate(state.rotationAngle);
                        state.segments.forEach(segment => {
                            ctx.save();
                            ctx.rotate(segment.baseAngle);
                            const arc = segment.arc;
                            if (segment.destroyed) {
                                const flicker = 0.25 + 0.25 * Math.sin(now * 4 + segment.baseAngle);
                                ctx.globalAlpha = flicker;
                                ctx.strokeStyle = addAlpha(segment.color, 0.6);
                                ctx.lineWidth = 4;
                                ctx.beginPath();
                                ctx.arc(0, 0, outerRadius, -arc / 2, arc / 2);
                                ctx.stroke();
                            } else {
                                const pulseScale = 0.65 + (segment.hitPulse || 0);
                                ctx.globalAlpha = 0.7 + (segment.hitPulse || 0);
                                ctx.fillStyle = addAlpha(segment.color, 0.45 + (segment.hitPulse || 0) * 0.4);
                                ctx.strokeStyle = addAlpha(segment.color, 0.9);
                                ctx.lineWidth = 3 + (segment.hitPulse || 0) * 10;
                                ctx.beginPath();
                                ctx.arc(0, 0, outerRadius, -arc / 2, arc / 2);
                                ctx.arc(0, 0, innerRadius, arc / 2, -arc / 2, true);
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();

                                const hpRatio = segment.maxHp > 0 ? clamp(segment.hp / segment.maxHp, 0, 1) : 0;
                                const barWidth = innerRadius * 0.32;
                                ctx.globalAlpha = 0.92;
                                ctx.fillStyle = addAlpha('#ffffff', 0.55);
                                ctx.fillRect(-2, -outerRadius - 12, 4, 2);
                                ctx.fillStyle = addAlpha(segment.color, 0.9);
                                ctx.fillRect(-barWidth / 2, -outerRadius - 20, barWidth * hpRatio, 3);
                            }
                            ctx.restore();
                        });
                        ctx.restore();

                        ctx.globalAlpha = 0.4 + 0.2 * Math.sin(now * 3.4);
                        ctx.strokeStyle = addAlpha(t.color || '#5dd0ff', 0.6);
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, outerRadius + 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                } else if (t.behavior === "hex") {
                    ctx.translate(0, 30);
                    const bodyW_top = t.r * 1.5;
                    const bodyW_bottom = t.r * 2.5;
                    const bodyH = t.r * 1.5;
                    ctx.fillStyle = "#66aaff";
                    ctx.strokeStyle = "#5599e5";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-bodyW_top / 2, -bodyH / 2);
                    ctx.lineTo(bodyW_top / 2, -bodyH / 2);
                    ctx.lineTo(bodyW_bottom / 2, bodyH / 2);
                    ctx.lineTo(-bodyW_bottom / 2, bodyH / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = "#e03434";
                    ctx.strokeStyle = "#c02d2d";
                    const crownH = t.r * 0.8, crownW = bodyW_top * 0.9;
                    ctx.beginPath();
                    ctx.moveTo(-crownW / 2, -bodyH / 2);
                    ctx.lineTo(-crownW / 2 + crownW / 4, -bodyH / 2 - crownH);
                    ctx.lineTo(0, -bodyH / 2 - crownH / 2);
                    ctx.lineTo(crownW / 2 - crownW / 4, -bodyH / 2 - crownH);
                    ctx.lineTo(crownW / 2, -bodyH / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = "#000";
                    ctx.fillRect(-t.r * 0.6, -t.r * 0.3, t.r * 0.4, t.r * 0.15);
                    ctx.fillRect(t.r * 0.2, -t.r * 0.3, t.r * 0.4, t.r * 0.15);
                    ctx.fillRect(-t.r * 0.4, 0, t.r * 0.8, t.r * 0.1);
                    ctx.strokeStyle = "#ffd700";
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, t.r * 1.1, 0.5, Math.PI - 0.5);
                    ctx.stroke();
                    ctx.fillStyle = "#ffd700";
                    ctx.strokeStyle = "#daa520";
                    ctx.lineWidth = 3;
                    const medR = t.r * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, t.r * 1.1 + medR);
                    for (let i = 1; i <= 8; i++) {
                        const angle = i * (2 * Math.PI / 8);
                        ctx.lineTo(medR * Math.sin(angle), t.r * 1.1 + medR * Math.cos(angle));
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (t.behavior === "construct") {
                    // Check if this is the DEATH ENGINE boss
                    if (t.name === 'DEATH ENGINE') {
                        // Update skull renderer position and color for red final phase
                        if (t.skullRenderer) {
                            t.skullRenderer.x = 0; // Relative position since we're already translated
                            t.skullRenderer.y = 0; // Relative position since we're already translated  
                            t.skullRenderer.skullColor = t.color || '#e54d24';

                            // Handle attack animation
                            if (t.isLaughing && !t.skullRenderer.isAttacking) {
                                // Trigger attack animation with sound effect
                                t.skullRenderer.triggerAttack(true);
                            }

                            // Update and draw using Boss class
                            t.skullRenderer.update();
                            t.skullRenderer.draw();
                        } else {
                            // Fallback to original drawing if skullRenderer is missing (shouldn't happen)
                            const skullWidth = t.r * 2;
                            const skullHeight = t.r * 2.8;

                            // Calculate mouth openness for animation
                            let mouthOpenness = 0;
                            if (t.isLaughing) {
                                const elapsedTime = performance.now() - t.laughStartTime;
                                mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 7;
                            }

                            // Draw all parts of the skull ship (pass boss color for red final phase)
                            const skullColor = t.color || '#e54d24';
                            drawSkullHorns(ctx, skullWidth, skullHeight, skullColor);
                            drawSkullMain(ctx, skullWidth, skullHeight, skullColor);
                            drawSkullFace(ctx, skullWidth, skullHeight, mouthOpenness, skullColor);
                            drawSkullWeathering(ctx, skullWidth, skullHeight, skullColor);
                        }
                    } else {
                        // Original GEOMETRON drawing code
                        const phaseColor = t.phase === 1 ? (t.color || "#ff4500") : "#ff4500"; ctx.fillStyle = addAlpha(phaseColor, 0.67); ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; if (t.phase === 2) { ctx.shadowColor = phaseColor; ctx.shadowBlur = 25; } const bodyW = t.r * 1.2, bodyH = t.r * 1.5, headH = t.r * 0.7; ctx.beginPath(); ctx.moveTo(-bodyW * 0.5, bodyH * 0.5); ctx.lineTo(-bodyW * 0.6, bodyH * 0.2); ctx.lineTo(-bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(0, -bodyH * 0.5); ctx.lineTo(bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(bodyW * 0.6, bodyH * 0.2); ctx.lineTo(bodyW * 0.5, bodyH * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); const shoulderY = -bodyH * 0.3, shoulderX = bodyW * 0.4; const armW = 0.4 * t.r, armH = 0.9 * t.r; ctx.beginPath(); ctx.moveTo(-shoulderX, shoulderY); ctx.lineTo(-shoulderX - armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(-shoulderX, shoulderY + armH); ctx.lineTo(-shoulderX + armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(shoulderX + armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(shoulderX, shoulderY + armH); ctx.lineTo(shoulderX - armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); const eyeR = Math.max(1, t.r * 0.2 + 2 * Math.sin(performance.now() / 200)); ctx.fillStyle = "#ffffff"; ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -headH * 0.1, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    }
                } else if (t.behavior === "avian") { ctx.save(); ctx.rotate(-Math.PI / 2); const wingY = -t.r * 0.4; ctx.strokeStyle = "#FFFFFF"; ctx.fillStyle = t.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-t.r * 0.4, wingY); ctx.quadraticCurveTo(-t.r * 0.8, wingY - t.r * 0.6, -t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(-t.r * 0.9, wingY - t.r * 0.1, -t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(t.r * 0.4, wingY); ctx.quadraticCurveTo(t.r * 0.8, wingY - t.r * 0.6, t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(t.r * 0.9, wingY - t.r * 0.1, t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0, 0, t.r * 0.6, t.r * 0.8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); const eyeSize = t.r * 0.15; ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = "#FF6600"; ctx.beginPath(); ctx.moveTo(0, t.r * 0.1); ctx.lineTo(-t.r * 0.15, t.r * 0.3); ctx.lineTo(t.r * 0.15, t.r * 0.3); ctx.closePath(); ctx.fill(); ctx.restore(); } else if (t.behavior === "sentinel") {
                    // Cyberpunk VOID SENTINEL with purple-orange sunset gradient
                    const time = performance.now() / 1000;

                    // Create radial gradient for cyberpunk sunset effect
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
                    gradient.addColorStop(0, '#FF6B35'); // Orange center
                    gradient.addColorStop(0.4, '#FF8E53'); // Orange-purple transition
                    gradient.addColorStop(0.7, '#8B4A9C'); // Purple
                    gradient.addColorStop(1, '#2D1B69'); // Deep purple edge

                    // Main body - hexagonal cyberpunk shape
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FF6B35';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const sides = 6;
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const x = Math.cos(angle) * t.r;
                        const y = Math.sin(angle) * t.r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Inner core with pulsing effect
                    const pulseSize = 0.6 + 0.2 * Math.sin(time * 3);
                    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 0.5);
                    coreGradient.addColorStop(0, '#FFFFFF');
                    coreGradient.addColorStop(0.3, '#FF6B35');
                    coreGradient.addColorStop(1, '#8B4A9C');

                    ctx.fillStyle = coreGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, t.r * 0.4 * pulseSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Cyberpunk energy rings
                    ctx.strokeStyle = '#FF6B35';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        const ringTime = time * (2 + i * 0.5);
                        const opacity = 0.3 + 0.4 * Math.sin(ringTime);
                        ctx.globalAlpha = opacity;

                        ctx.beginPath();
                        ctx.arc(0, 0, t.r * (0.7 + i * 0.15), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;

                    // Rotating cyberpunk elements
                    ctx.strokeStyle = '#8B4A9C';
                    ctx.fillStyle = '#FF6B35';
                    ctx.lineWidth = 2;

                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate(i * Math.PI / 4 + time * 0.5);
                        ctx.translate(t.r * 0.8, 0);

                        // Small diamond-shaped elements
                        ctx.beginPath();
                        ctx.moveTo(0, -t.r * 0.08);
                        ctx.lineTo(t.r * 0.06, 0);
                        ctx.lineTo(0, t.r * 0.08);
                        ctx.lineTo(-t.r * 0.06, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Glowing eyes with cyberpunk effect
                    ctx.shadowColor = '#FF6B35';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFFFFF';

                    const eyeOffset = t.r * 0.25;
                    ctx.beginPath();
                    ctx.arc(-eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;

                } else if (t.behavior === "broodlord") {
                    // Draw cyberpunk HIVE SOVEREIGN - sleek and menacing
                    const time = performance.now() / 1000;
                    const pulseFactor = 1 + 0.08 * Math.sin(time * 3);

                    // Create sunset gradient for main body
                    const mainGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
                    mainGradient.addColorStop(0, '#FF6B35'); // Orange center
                    mainGradient.addColorStop(0.4, '#FF8E53'); // Orange-purple blend
                    mainGradient.addColorStop(0.7, '#8B4A9C'); // Purple
                    mainGradient.addColorStop(1, '#2D1B69'); // Deep void purple

                    // Main carapace body with cyberpunk glow
                    ctx.fillStyle = mainGradient;
                    ctx.strokeStyle = '#FF6B35';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#8B4A9C';
                    ctx.shadowBlur = 20 * pulseFactor;

                    ctx.beginPath();
                    ctx.ellipse(0, 0, t.r * 1.2 * pulseFactor, t.r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Segmented armor plating with energy lines
                    ctx.strokeStyle = "#FF8E53";
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;

                    for (let i = -2; i <= 2; i++) {
                        const segmentPulse = 0.9 + 0.1 * Math.sin(time * 4 + i * 0.5);
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.ellipse(0, i * t.r * 0.25, t.r * 1.1 * pulseFactor * segmentPulse, t.r * 0.15, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;

                    // Cyberpunk energy claws/appendages
                    for (let side = -1; side <= 1; side += 2) {
                        for (let i = 0; i < 3; i++) {
                            ctx.save();
                            ctx.translate(side * t.r * 0.8, (i - 1) * t.r * 0.4);
                            ctx.rotate(side * (Math.PI / 6 + i * Math.PI / 12) + Math.sin(time * 2 + i) * 0.15);

                            // Energy claw with gradient
                            const clawGradient = ctx.createLinearGradient(0, 0, t.r * 0.8, 0);
                            clawGradient.addColorStop(0, '#8B4A9C');
                            clawGradient.addColorStop(0.7, '#FF6B35');
                            clawGradient.addColorStop(1, '#FFFFFF');

                            ctx.fillStyle = clawGradient;
                            ctx.strokeStyle = '#FF8E53';
                            ctx.lineWidth = 3;
                            ctx.shadowColor = '#FF6B35';
                            ctx.shadowBlur = 8;

                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(t.r * 0.6, 0);
                            ctx.lineTo(t.r * 0.7, -t.r * 0.1);
                            ctx.lineTo(t.r * 0.8, 0);
                            ctx.lineTo(t.r * 0.7, t.r * 0.1);
                            ctx.lineTo(t.r * 0.6, 0);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            ctx.restore();
                        }
                    }
                    ctx.shadowBlur = 0;

                    // Cyberpunk energy eyes
                    const eyeGlow = 0.6 + 0.4 * Math.sin(time * 5);

                    for (let side = -1; side <= 1; side += 2) {
                        // Outer eye glow
                        ctx.shadowColor = '#FF6B35';
                        ctx.shadowBlur = 20 * eyeGlow;
                        ctx.fillStyle = '#FF6B35';

                        ctx.beginPath();
                        ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.18 * eyeGlow, 0, Math.PI * 2);
                        ctx.fill();

                        // Main eye
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.12, 0, Math.PI * 2);
                        ctx.fill();

                        // Energy core pupil
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#8B4A9C';
                        ctx.fillStyle = '#2D1B69';
                        ctx.beginPath();
                        ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Cyberpunk mandibles with energy effect
                    ctx.shadowBlur = 0;
                    const mandibleOffset = Math.sin(time * 3) * 0.12;

                    for (let side = -1; side <= 1; side += 2) {
                        ctx.save();
                        ctx.translate(side * t.r * 0.2, t.r * 0.2);
                        ctx.rotate(side * (Math.PI / 8 + mandibleOffset));

                        // Mandible gradient
                        const mandibleGradient = ctx.createLinearGradient(0, 0, t.r * 0.4, 0);
                        mandibleGradient.addColorStop(0, '#2D1B69');
                        mandibleGradient.addColorStop(0.6, '#8B4A9C');
                        mandibleGradient.addColorStop(1, '#FF6B35');

                        ctx.fillStyle = mandibleGradient;
                        ctx.strokeStyle = '#FF8E53';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#8B4A9C';
                        ctx.shadowBlur = 5;

                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(t.r * 0.3, -t.r * 0.1);
                        ctx.lineTo(t.r * 0.4, 0);
                        ctx.lineTo(t.r * 0.3, t.r * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.shadowBlur = 0;

                } else if (t.behavior === "shadow_clone") {
                    const player = (typeof store !== 'undefined' && store && store.player) ? store.player : {};
                    const subclass = player && player.subclass ? player.subclass : '';
                    const time = performance.now() / 1000;
                    const basePulse = 0.6 + 0.25 * Math.sin(time * 4.3);
                    let accent = '#8fa0ff';
                    switch (subclass) {
                        case 'juggernaut': accent = '#ff6b6b'; break;
                        case 'marauder': accent = '#66ff99'; break;
                        case 'demolitioner': accent = '#ffd166'; break;
                        case 'railgunner': accent = '#b794ff'; break;
                        case 'phasestriker': accent = '#ff91d2'; break;
                        case 'stormbringer': accent = '#6dd0ff'; break;
                    }
                    const glowStrength = t.isEnraged ? 1.0 : 0.7;
                    let facing = Math.atan2(((player && player.y) ? player.y : t.y) - t.y, ((player && player.x) ? player.x : t.x) - t.x) + Math.PI / 2;
                    if (t.abilityStage === 'charge' && (Math.abs(t.shadowChargeVX || 0) + Math.abs(t.shadowChargeVY || 0)) > 16) {
                        facing = Math.atan2(t.shadowChargeVY || 0, t.shadowChargeVX || 0) + Math.PI / 2;
                    }
                    const wobble = Math.sin(time * 3 + (t.moveT || 0)) * 0.05;
                    ctx.save();
                    ctx.rotate(facing + wobble);
                    const scalePulse = 1 + (t.currentAbility ? basePulse * 0.05 : 0);
                    ctx.scale(scalePulse, 1);

                    ctx.shadowColor = addAlpha(accent, glowStrength);
                    ctx.shadowBlur = t.isEnraged ? 30 : 18;

                    const bodyGradient = ctx.createLinearGradient(0, -t.r * 1.4, 0, t.r * 1.3);
                    bodyGradient.addColorStop(0, addAlpha('#f4f7ff', 0.85));
                    bodyGradient.addColorStop(0.45, addAlpha('#3b4268', 0.95));
                    bodyGradient.addColorStop(1, addAlpha('#060712', 0.95));
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -t.r * 1.35);
                    ctx.lineTo(t.r * 0.92, t.r * 0.88);
                    ctx.lineTo(0, t.r * 1.15);
                    ctx.lineTo(-t.r * 0.92, t.r * 0.88);
                    ctx.closePath();
                    ctx.fill();
                    ctx.lineWidth = 2.4;
                    ctx.strokeStyle = addAlpha('#ccd2ef', 0.55);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0, -t.r * 0.95);
                    ctx.lineTo(t.r * 0.55, t.r * 0.68);
                    ctx.lineTo(0, t.r * 0.9);
                    ctx.lineTo(-t.r * 0.55, t.r * 0.68);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(22, 26, 52, 0.9)';
                    ctx.fill();
                    ctx.lineWidth = 1.4;
                    ctx.strokeStyle = addAlpha(accent, 0.55 + 0.3 * basePulse);
                    ctx.stroke();

                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = addAlpha('#f7fbff', 0.85);
                    ctx.beginPath();
                    ctx.arc(0, -t.r * 0.32, t.r * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = addAlpha(accent, 0.6 + 0.3 * Math.sin(time * 6));
                    ctx.beginPath();
                    ctx.arc(0, -t.r * 0.32, t.r * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    ctx.lineWidth = 3;
                    ctx.strokeStyle = addAlpha(accent, 0.45 + 0.35 * basePulse);
                    for (let side = -1; side <= 1; side += 2) {
                        ctx.beginPath();
                        ctx.moveTo(side * t.r * 0.65, -t.r * 0.1);
                        ctx.quadraticCurveTo(side * t.r * 1.2, t.r * 0.15, side * t.r * 0.95, t.r * 0.95);
                        ctx.stroke();
                    }

                    ctx.lineWidth = 1.2;
                    ctx.strokeStyle = addAlpha('#dde3ff', 0.4);
                    ctx.beginPath();
                    ctx.moveTo(-t.r * 0.35, -t.r * 0.2);
                    ctx.lineTo(-t.r * 0.55, t.r * 0.6);
                    ctx.moveTo(t.r * 0.35, -t.r * 0.2);
                    ctx.lineTo(t.r * 0.55, t.r * 0.6);
                    ctx.stroke();

                    const exhaustPulse = 0.6 + 0.35 * Math.sin(time * 10 + (t.isEnraged ? Math.PI / 4 : 0));
                    ctx.globalAlpha = 0.45 + 0.4 * exhaustPulse;
                    ctx.fillStyle = addAlpha(accent, 0.8);
                    ctx.beginPath();
                    ctx.ellipse(-t.r * 0.38, t.r * 1.08, t.r * 0.2, t.r * (0.45 + 0.12 * exhaustPulse), 0, 0, Math.PI * 2);
                    ctx.ellipse(t.r * 0.38, t.r * 1.08, t.r * 0.2, t.r * (0.45 + 0.12 * exhaustPulse), 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    if (t.abilityStage === 'charge') {
                        ctx.lineWidth = 2.6;
                        ctx.strokeStyle = addAlpha(accent, 0.85);
                        ctx.beginPath();
                        ctx.moveTo(-t.r * 0.5, t.r * 0.6);
                        ctx.lineTo(-t.r * 0.75, t.r * 1.4);
                        ctx.moveTo(t.r * 0.5, t.r * 0.6);
                        ctx.lineTo(t.r * 0.75, t.r * 1.4);
                        ctx.stroke();
                    }

                    ctx.shadowBlur = 0;
                    ctx.restore();

                    if (t.shadowTelegraph) {
                        const telegraph = t.shadowTelegraph;
                        const progress = Math.max(0, Math.min(1, telegraph.progress || 0));
                        if (telegraph.type === 'star') {
                            const ringRadius = t.r * (1.05 + progress * 0.65);
                            ctx.save();
                            ctx.globalAlpha = 0.4 + 0.4 * progress;
                            ctx.lineWidth = 2 + progress * 3;
                            ctx.strokeStyle = addAlpha(accent, 0.8);
                            ctx.setLineDash([5, 3]);
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.globalAlpha = 0.6;
                            const starCount = 6;
                            for (let i = 0; i < starCount; i++) {
                                ctx.save();
                                ctx.rotate(time * (t.isEnraged ? 2.1 : 1.6) + i * (Math.PI * 2 / starCount));
                                ctx.translate(0, ringRadius);
                                const size = 7 + progress * 6;
                                ctx.fillStyle = addAlpha('#f6f8ff', 0.9);
                                ctx.beginPath();
                                ctx.moveTo(0, -size);
                                ctx.lineTo(size * 0.45, 0);
                                ctx.lineTo(0, size);
                                ctx.lineTo(-size * 0.45, 0);
                                ctx.closePath();
                                ctx.fill();
                                ctx.lineWidth = 1.2;
                                ctx.strokeStyle = addAlpha(accent, 0.6);
                                ctx.stroke();
                                ctx.restore();
                            }
                            ctx.restore();
                            ctx.globalAlpha = 1;
                        } else if (telegraph.type === 'lightning' && t.shadowTelegraphTarget) {
                            const targetX = t.shadowTelegraphTarget.x - t.x;
                            const targetY = t.shadowTelegraphTarget.y - t.y;
                            const dist = Math.sqrt(targetX * targetX + targetY * targetY) || 1;
                            const segments = 7;
                            ctx.globalAlpha = 0.25 + 0.55 * progress;
                            ctx.lineWidth = 2 + progress * 2.5;
                            ctx.strokeStyle = addAlpha(accent, 0.7);
                            ctx.beginPath();
                            ctx.moveTo(0, -t.r * 0.25);
                            for (let i = 1; i <= segments; i++) {
                                const tSeg = i / segments;
                                const px = targetX * tSeg;
                                const py = targetY * tSeg;
                                const offsetScale = (1 - Math.abs(0.5 - tSeg) * 1.8);
                                const offset = Math.sin(time * 12 + i * 1.7) * offsetScale * 24 * (0.3 + progress);
                                const nx = -targetY / dist;
                                const ny = targetX / dist;
                                const jitterX = px + nx * offset;
                                const jitterY = py + ny * offset;
                                ctx.lineTo(jitterX, jitterY);
                            }
                            ctx.stroke();
                            ctx.setLineDash([10, 8]);
                            ctx.lineWidth = 1.4;
                            ctx.strokeStyle = addAlpha('#f1f3ff', 0.6);
                            ctx.beginPath();
                            ctx.moveTo(0, -t.r * 0.3);
                            ctx.lineTo(targetX, targetY);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.globalAlpha = 0.6;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(targetX, targetY, 14 + progress * 18, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        } else if (telegraph.type === 'hounds') {
                            const baseRadius = t.r * 0.9;
                            const ringRadius = baseRadius + progress * t.r * 0.6;
                            ctx.save();
                            ctx.translate(0, t.r * 1.1);
                            ctx.scale(1, 0.55);
                            ctx.globalAlpha = 0.3 + 0.4 * progress;
                            ctx.fillStyle = 'rgba(10, 12, 28, 0.9)';
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = addAlpha(accent, 0.7);
                            ctx.setLineDash([4, 3]);
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.shadowColor = addAlpha(accent, 0.6);
                            ctx.shadowBlur = 15;
                            const pawCount = 4;
                            for (let i = 0; i < pawCount; i++) {
                                const angle = time * (t.isEnraged ? 2.4 : 1.6) + i * (Math.PI * 2 / pawCount);
                                const radius = ringRadius * (0.45 + 0.25 * Math.sin(time * 3 + i));
                                const px = Math.cos(angle) * radius;
                                const py = Math.sin(angle) * radius;
                                ctx.save();
                                ctx.translate(px, py);
                                ctx.rotate(angle);
                                const size = 6 + progress * 4;
                                ctx.fillStyle = addAlpha('#f4f7ff', 0.85);
                                ctx.beginPath();
                                ctx.ellipse(0, 0, size, size * 0.6, 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            ctx.shadowBlur = 0;
                            ctx.restore();
                        } else if (telegraph.type === 'charge' && t.shadowTelegraphTarget) {
                            const targetX = t.shadowTelegraphTarget.x - t.x;
                            const targetY = t.shadowTelegraphTarget.y - t.y;
                            const dist = Math.sqrt(targetX * targetX + targetY * targetY) || 1;
                            const dirX = targetX / dist;
                            const dirY = targetY / dist;
                            const reach = Math.min(dist, t.r * (2.8 + 1.4 * progress));
                            ctx.globalAlpha = 0.4 + 0.45 * progress;
                            ctx.lineWidth = 3.2;
                            ctx.strokeStyle = addAlpha(accent, 0.8);
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(dirX * reach, dirY * reach);
                            ctx.stroke();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = addAlpha('#f3f6ff', 0.75);
                            ctx.beginPath();
                            ctx.moveTo(dirX * (reach + 12), dirY * (reach + 12));
                            ctx.lineTo(dirX * (reach - 10) - dirY * 8, dirY * (reach - 10) + dirX * 8);
                            ctx.lineTo(dirX * (reach - 10) + dirY * 8, dirY * (reach - 10) - dirX * 8);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 0.5;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([6, 4]);
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(targetX, targetY);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.arc(targetX, targetY, 14 + progress * 14, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        }
                    }
                } else if (t.behavior === "asynchronos") {
                    // Chronovore boss design
                    const time = performance.now() / 1000;
                    const pulse = 0.95 + 0.05 * Math.sin(time / 0.4);
                    const coreRadius = t.r;

                    // Draw Horns
                    ctx.fillStyle = '#4c1d95'; // Deep purple
                    ctx.shadowColor = '#a78bfa';
                    ctx.shadowBlur = 20;
                    // Left Horn
                    ctx.beginPath();
                    ctx.moveTo(-coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.quadraticCurveTo(-coreRadius * 2, -coreRadius * 2, -coreRadius * 1.5, coreRadius * 1.5);
                    ctx.quadraticCurveTo(-coreRadius, 0, -coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.fill();
                    // Right Horn
                    ctx.beginPath();
                    ctx.moveTo(coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.quadraticCurveTo(coreRadius * 2, -coreRadius * 2, coreRadius * 1.5, coreRadius * 1.5);
                    ctx.quadraticCurveTo(coreRadius, 0, coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.fill();

                    // Draw Dinosaur Head Shape
                    ctx.fillStyle = '#1e1b4b'; // Dark indigo
                    ctx.strokeStyle = '#818cf8';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, -coreRadius * 1.5); // Top of head
                    ctx.quadraticCurveTo(coreRadius * 1.5, -coreRadius, coreRadius, coreRadius * 1.2); // Jaw right
                    ctx.lineTo(-coreRadius, coreRadius * 1.2); // Jaw left
                    ctx.quadraticCurveTo(-coreRadius * 1.5, -coreRadius, 0, -coreRadius * 1.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Draw Temporal Eye (Core)
                    const eyeRadius = coreRadius * pulse;
                    const gradient = ctx.createRadialGradient(0, 0, eyeRadius * 0.2, 0, 0, eyeRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(0.7, 'rgba(129, 140, 248, 0.8)');
                    gradient.addColorStop(1, 'rgba(55, 48, 163, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, eyeRadius * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Clock tick marks
                    ctx.strokeStyle = '#fde047'; // Gold/Yellow
                    ctx.lineWidth = 3;
                    for(let i = 0; i < 12; i++) {
                        const angle = (i/12) * Math.PI * 2;
                        const startRadius = eyeRadius * 0.9;
                        const endRadius = eyeRadius * 1.1;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * startRadius, Math.sin(angle) * startRadius);
                        ctx.lineTo(Math.cos(angle) * endRadius, Math.sin(angle) * endRadius);
                        ctx.stroke();
                    }

                    // Draw Orbiting Clock Hands
                    ctx.shadowColor = '#fde047';
                    ctx.shadowBlur = 10;
                    const state = t.asynchronosState;
                    const beamAngle = (state && state.beam) ? state.beam.angle : time * 0.5;
                    // Hour hand
                    ctx.save();
                    ctx.rotate(beamAngle / 12);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(eyeRadius * 0.7, 0);
                    ctx.stroke();
                    ctx.restore();
                    // Minute hand
                    ctx.save();
                    ctx.rotate(beamAngle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(eyeRadius, 0);
                    ctx.stroke();
                    ctx.restore();
                    ctx.shadowBlur = 0;

                    // Draw Evil Eye in the Center
                    const eyeHeight = eyeRadius * 0.7;
                    const eyeWidth = eyeRadius * 1.2;
                    
                    // Iris
                    ctx.fillStyle = '#facc15'; // Vivid yellow for the iris
                    ctx.shadowColor = '#f59e0b'; // Amber shadow
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.moveTo(0, -eyeHeight / 2);
                    ctx.quadraticCurveTo(eyeWidth / 2, 0, 0, eyeHeight / 2);
                    ctx.quadraticCurveTo(-eyeWidth / 2, 0, 0, -eyeHeight / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Pupil (vertical slit) that pulses
                    const pupilWidth = eyeRadius * 0.15;
                    const pupilHeight = eyeHeight * (0.9 * pulse);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-pupilWidth / 2, -pupilHeight / 2, pupilWidth, pupilHeight);

                } else { const time = performance.now() / 1000; ctx.fillStyle = '#2c2c54'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, t.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#706fd3'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f0932b'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.3, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 6; i++) { ctx.save(); ctx.rotate(i * Math.PI / 3 + time * 0.3); ctx.translate(t.r * 0.6, 0); ctx.fillStyle = '#ff6348'; ctx.strokeStyle = '#2f3542'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore(); } const eyeSize = t.r * 0.12; ctx.fillStyle = '#ff3838'; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 4; i++) { ctx.save(); ctx.rotate(i * Math.PI / 2 + time * -0.5); ctx.translate(t.r * 0.9, 0); ctx.fillStyle = '#3c6382'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 2; ctx.fillRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.strokeRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.restore(); } } ctx.restore();
            }

            function drawShip(t, e, player) {
                let mainColor = '#b266ff', accentColor1 = '#7a49cc', accentColor2 = '#4d2a80',
                    wingStrokeColor = '#c49cff', engineColor = '#cc99ff';

                switch (player.subclass) {
                    case 'juggernaut':
                        mainColor = '#ff3333'; accentColor1 = '#cc0000'; accentColor2 = '#990000';
                        wingStrokeColor = '#ff6666'; engineColor = '#ffaaaa';
                        break;
                    case 'marauder':
                        mainColor = '#33cc33'; accentColor1 = '#009900'; accentColor2 = '#006600';
                        wingStrokeColor = '#66ff66'; engineColor = '#aaffaa';
                        break;
                    case 'demolitioner':
                        mainColor = '#ffcc00'; accentColor1 = '#ffaa00'; accentColor2 = '#cc8800';
                        wingStrokeColor = '#ffeeaa'; engineColor = '#ffffcc';
                        break;
                    case 'railgunner':
                        mainColor = '#9933ff'; accentColor1 = '#6600cc'; accentColor2 = '#440088';
                        wingStrokeColor = '#cc99ff'; engineColor = '#e6ccff';
                        break;
                    case 'phasestriker':
                        mainColor = '#ff69b4'; accentColor1 = '#ff1493'; accentColor2 = '#c71585';
                        wingStrokeColor = '#ffb6c1'; engineColor = '#ffc0cb';
                        break;
                    case 'stormbringer':
                        mainColor = '#00bfff'; accentColor1 = '#1e90ff'; accentColor2 = '#0000cd';
                        wingStrokeColor = '#87cefa'; engineColor = '#add8e6';
                        break;
                }

                ctx.save();
                ctx.translate(t, e);
                if (player.isInvincible || player.hasShieldBubble) {
                    ctx.beginPath(); ctx.arc(0, 0, 24, 0, 2 * Math.PI);
                    const g = ctx.createRadialGradient(0, 0, 18, 0, 0, 24);
                    g.addColorStop(0, "#9a66ff11"); g.addColorStop(1, "#9a66ff");
                    ctx.fillStyle = g; ctx.fill()
                }
                ctx.beginPath();
                ctx.moveTo(0, -20); ctx.lineTo(12, 8); ctx.lineTo(8, 14); ctx.lineTo(0, 10); ctx.lineTo(-8, 14); ctx.lineTo(-12, 8);
                ctx.closePath();
                const o = ctx.createLinearGradient(0, -20, 0, 14);
                o.addColorStop(0, mainColor); o.addColorStop(.5, accentColor1); o.addColorStop(1, accentColor2);
                ctx.fillStyle = o; ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = wingStrokeColor; ctx.stroke();
                ctx.strokeStyle = mainColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-12, 5); ctx.lineTo(-20, -2); ctx.lineTo(-18, 8); ctx.moveTo(12, 5); ctx.lineTo(20, -2); ctx.lineTo(18, 8); ctx.stroke();
                const r = performance.now() / 1e3;
                ctx.globalAlpha = .8 + .2 * Math.sin(10 * r);
                ctx.fillStyle = engineColor;
                ctx.beginPath(); ctx.ellipse(-5, 16, 3, 6, 0, 0, 2 * Math.PI); ctx.ellipse(5, 16, 3, 6, 0, 0, 2 * Math.PI); ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(0, -8, 3, 0, 2 * Math.PI); ctx.fill();

                const time = performance.now() / 1000;

                // Draw beef shield bubble if pilot is beef and shield is active
                if (player.pilotGenome === 'beef' && player.beefShield > 0) {
                    const shieldPercent = player.beefShield / player.beefShieldMax;
                    const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 2.5);

                    // Base radius scales with shield level (8px minimum, up to 30px at full shield)
                    const baseRadius = 8 + (22 * shieldPercent); // 8px at 0%, 30px at 100%
                    // Add wobbling effect on top of the scaled base
                    const wobbleAmount = 4 * shieldPercent; // Wobble gets stronger as shield grows
                    const shieldRadius = baseRadius + wobbleAmount * Math.sin(time * 3);

                    // Create void power shield gradient (dark purple/black energy)
                    const shieldGradient = ctx.createRadialGradient(0, 0, shieldRadius * 0.2, 0, 0, shieldRadius);
                    shieldGradient.addColorStop(0, `rgba(75, 0, 130, ${0.8 * shieldPercent})`); // Dark purple core (increased opacity)
                    shieldGradient.addColorStop(0.4, `rgba(25, 25, 112, ${0.6 * shieldPercent * pulseIntensity})`); // Midnight blue (increased)
                    shieldGradient.addColorStop(0.7, `rgba(72, 61, 139, ${0.7 * shieldPercent})`); // Dark slate blue (increased)
                    shieldGradient.addColorStop(1, `rgba(138, 43, 226, ${0.5 * shieldPercent})`); // Purple edge (was black, now purple)

                    ctx.beginPath();
                    ctx.arc(0, 0, shieldRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = shieldGradient;
                    ctx.fill();

                    // Add void energy sparkles
                    ctx.strokeStyle = `rgba(138, 43, 226, ${0.9 * shieldPercent * pulseIntensity})`; // Blue violet sparkles (increased opacity)
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset line dash

                    // Add inner void energy core
                    if (shieldPercent > 0.2) {
                        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shieldRadius * 0.3);
                        coreGradient.addColorStop(0, `rgba(147, 0, 211, ${0.6 * shieldPercent})`); // Dark violet (increased)
                        coreGradient.addColorStop(1, `rgba(75, 0, 130, ${0.3 * shieldPercent})`); // (increased)
                        ctx.fillStyle = coreGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, shieldRadius * 0.3 * Math.abs(Math.sin(time * 4)), 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }

                // Draw universal health and shield meters above ship for all pilots
                const meterWidth = 55;
                const meterHeight = 3;
                const meterSpacing = 6;
                const cornerRadius = 1.5;
                let meterY = -35;

                // Helper function for rounded rectangles
                const drawRoundedRect = (x, y, width, height, radius, fill = true, stroke = false) => {
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                    if (fill) ctx.fill();
                    if (stroke) ctx.stroke();
                };

                // Health bar (always visible)
                const healthPercent = player.hp / player.hpMax;

                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius);

                // Health bar fill
                if (healthPercent > 0) {
                    const healthGradient = ctx.createLinearGradient(-meterWidth / 2, meterY, meterWidth / 2, meterY);
                    if (healthPercent > 0.6) {
                        healthGradient.addColorStop(0, 'rgba(50, 205, 50, 0.8)'); // Lime green
                        healthGradient.addColorStop(1, 'rgba(34, 139, 34, 0.8)'); // Forest green
                    } else if (healthPercent > 0.3) {
                        healthGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)'); // Orange
                        healthGradient.addColorStop(1, 'rgba(255, 140, 0, 0.8)'); // Dark orange
                    } else {
                        healthGradient.addColorStop(0, 'rgba(255, 69, 0, 0.8)'); // Red orange
                        healthGradient.addColorStop(1, 'rgba(178, 34, 34, 0.8)'); // Fire brick red
                    }

                    ctx.fillStyle = healthGradient;
                    drawRoundedRect(-meterWidth / 2, meterY, meterWidth * healthPercent, meterHeight, cornerRadius);
                }

                // Health bar border
                ctx.strokeStyle = healthPercent > 0.6 ? 'rgba(50, 205, 50, 0.6)' :
                    healthPercent > 0.3 ? 'rgba(255, 165, 0, 0.6)' : 'rgba(255, 69, 0, 0.6)';
                ctx.lineWidth = 0.5;
                drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius, false, true);

                // Health text
                ctx.fillStyle = healthPercent > 0.6 ? 'rgba(50, 205, 50, 0.9)' :
                    healthPercent > 0.3 ? 'rgba(255, 165, 0, 0.9)' : 'rgba(255, 69, 0, 0.9)';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                const healthText = `${Math.round(player.hp)}/${Math.round(player.hpMax)}`;
                ctx.fillText(healthText, 0, meterY - 2);

                // Shield bars (show if any shield type exists)
                const hasRegularShield = player.shieldMax > 0;
                const hasBeefShield = player.pilotGenome === 'beef' && player.beefShieldMax > 0;

                if (hasRegularShield || hasBeefShield) {
                    meterY -= meterSpacing;

                    // Regular shield bar
                    if (hasRegularShield) {
                        const shieldPercent = player.shield / player.shieldMax;

                        // Shield bar background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius);

                        // Shield bar fill
                        if (shieldPercent > 0) {
                            const shieldGradient = ctx.createLinearGradient(-meterWidth / 2, meterY, meterWidth / 2, meterY);
                            shieldGradient.addColorStop(0, 'rgba(100, 149, 237, 0.8)'); // Cornflower blue
                            shieldGradient.addColorStop(1, 'rgba(65, 105, 225, 0.8)'); // Royal blue

                            ctx.fillStyle = shieldGradient;
                            drawRoundedRect(-meterWidth / 2, meterY, meterWidth * shieldPercent, meterHeight, cornerRadius);
                        }

                        // Shield bar border
                        ctx.strokeStyle = 'rgba(100, 149, 237, 0.6)';
                        ctx.lineWidth = 0.5;
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius, false, true);

                        // Shield text
                        ctx.fillStyle = 'rgba(100, 149, 237, 0.9)';
                        ctx.font = '8px monospace';
                        ctx.textAlign = 'center';
                        const shieldText = `${Math.round(player.shield)}/${Math.round(player.shieldMax)}`;
                        ctx.fillText(shieldText, 0, meterY - 2);

                        if (hasBeefShield) meterY -= meterSpacing;
                    }

                    // Beef shield bar
                    if (hasBeefShield) {
                        const beefShieldPercent = player.beefShield / player.beefShieldMax;

                        // Beef shield bar background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius);

                        // Beef shield bar fill
                        if (beefShieldPercent > 0) {
                            const beefShieldGradient = ctx.createLinearGradient(-meterWidth / 2, meterY, meterWidth / 2, meterY);
                            beefShieldGradient.addColorStop(0, 'rgba(75, 0, 130, 0.8)'); // Dark purple
                            beefShieldGradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.8)'); // Blue violet
                            beefShieldGradient.addColorStop(1, 'rgba(147, 0, 211, 0.8)'); // Dark violet

                            ctx.fillStyle = beefShieldGradient;
                            drawRoundedRect(-meterWidth / 2, meterY, meterWidth * beefShieldPercent, meterHeight, cornerRadius);
                        }

                        // Beef shield bar border
                        ctx.strokeStyle = 'rgba(138, 43, 226, 0.6)';
                        ctx.lineWidth = 0.5;
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius, false, true);

                        // Beef shield text
                        ctx.fillStyle = 'rgba(138, 43, 226, 0.9)';
                        ctx.font = '8px monospace';
                        ctx.textAlign = 'center';
                        const beefShieldText = `${Math.round(player.beefShield)}/${Math.round(player.beefShieldMax)}`;
                        ctx.fillText(beefShieldText, 0, meterY - 2);
                    }
                }

                if (player.pilotGenome === 'rocketman' && player.hasFirewall) {
                    const flameCharge = Math.max(0, Math.min(1, player.flameWallCharge || 0));
                    const noseY = -20;
                    const tailY = 14;
                    const band = Math.max(0.04, 0.12 - flameCharge * 0.05);
                    const boundary = Math.max(0, Math.min(1, 1 - flameCharge));
                    const waveTime = performance.now() / 1000;

                    // Show afterburner indicators when active
                    if (player.afterburnerActive) {
                        const afterburnerProgress = 1 - (player.afterburnerTimer / player.afterburnerMaxDuration);
                        const glowIntensity = 0.3 + 0.7 * Math.sin(waveTime * 8);

                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';

                        // Left and right afterburner glows
                        for (let side = -1; side <= 1; side += 2) {
                            ctx.fillStyle = `rgba(255, 140, 20, ${glowIntensity * 0.4})`;
                            ctx.beginPath();
                            ctx.ellipse(side * 12, tailY + 6, 8, 12, 0, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = `rgba(255, 200, 60, ${glowIntensity * 0.6})`;
                            ctx.beginPath();
                            ctx.ellipse(side * 12, tailY + 6, 4, 8, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    }

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();
                    ctx.clip();

                    const gradient = ctx.createLinearGradient(0, noseY, 0, tailY);
                    const yellowAlpha = 0.35 + flameCharge * 0.2;
                    const orangeAlpha = 0.25 + flameCharge * 0.45;
                    const yellow = `rgba(255, 210, 80, ${yellowAlpha})`;
                    const orange = `rgba(255, 110, 0, ${orangeAlpha})`;
                    const lowerCut = Math.max(0, boundary - band);
                    const upperCut = Math.min(1, boundary + band);

                    gradient.addColorStop(0, yellow);
                    gradient.addColorStop(lowerCut, yellow);
                    gradient.addColorStop(Math.max(lowerCut, boundary), orange);
                    gradient.addColorStop(upperCut, orange);
                    gradient.addColorStop(1, orange);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(-22, noseY - 2, 44, tailY - noseY + 4);

                    const shimmerOffset = Math.sin(waveTime * 3.1) * (8 + flameCharge * 10);
                    const shimmer = ctx.createLinearGradient(-14, noseY - 10 + shimmerOffset, 14, tailY + 4 - shimmerOffset);
                    shimmer.addColorStop(0, `rgba(255, 240, 180, ${0.04 + flameCharge * 0.12})`);
                    shimmer.addColorStop(0.5, `rgba(255, 190, 120, ${0.08 + flameCharge * 0.16})`);
                    shimmer.addColorStop(1, `rgba(255, 120, 40, ${0.05 + flameCharge * 0.14})`);

                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = shimmer;
                    ctx.fillRect(-20, noseY - 8, 40, tailY - noseY + 12);

                    ctx.restore();

                    ctx.save();
                    ctx.shadowColor = `rgba(255, 120, 0, ${0.4 + flameCharge * 0.4})`;
                    ctx.shadowBlur = 12 + flameCharge * 14;
                    ctx.strokeStyle = `rgba(255, 220, 120, ${0.3 + flameCharge * 0.5})`;
                    ctx.lineWidth = 1.2 + flameCharge;
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                }

                // Rocketman flame pulse cooldown gradient timer (hourglass fill effect)
                if (player.pilotGenome === 'rocketman' && player.hasFirewall) {
                    const cooldownProgress = player.flamePulseCharge || 0; // 0 = empty, 1 = full/ready
                    
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();
                    ctx.clip();

                    // Create gradient that fills from bottom to top like an hourglass
                    const shipHeight = 34; // From nose (-20) to tail (14)
                    const shipTop = -20;
                    const shipBottom = 14;
                    const fillHeight = shipTop + (shipHeight * (1 - cooldownProgress)); // Fill from bottom up
                    
                    const gradient = ctx.createLinearGradient(0, shipBottom, 0, shipTop);
                    
                    // Filled portion (orange/red glow)
                    if (cooldownProgress < 1) {
                        gradient.addColorStop(0, 'rgba(255, 80, 0, 0.25)'); // Bottom (filled)
                        gradient.addColorStop(Math.max(0, cooldownProgress - 0.05), 'rgba(255, 120, 20, 0.3)');
                        gradient.addColorStop(Math.min(1, cooldownProgress), 'rgba(255, 180, 60, 0.15)'); // Fill line
                        gradient.addColorStop(Math.min(1, cooldownProgress + 0.05), 'rgba(0, 0, 0, 0)'); // Fade to transparent
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Top (empty)
                    } else {
                        // Fully charged - bright glow
                        gradient.addColorStop(0, 'rgba(255, 140, 0, 0.4)');
                        gradient.addColorStop(0.5, 'rgba(255, 180, 60, 0.35)');
                        gradient.addColorStop(1, 'rgba(255, 220, 100, 0.3)');
                    }

                    ctx.fillStyle = gradient;
                    ctx.fillRect(-22, shipTop - 2, 44, shipHeight + 4);

                    // Add pulsing effect when ready
                    if (cooldownProgress >= 1) {
                        const pulse = 0.5 + 0.5 * Math.sin(time * 4);
                        ctx.globalAlpha = pulse * 0.3;
                        ctx.fillStyle = 'rgba(255, 200, 80, 1)';
                        ctx.fillRect(-22, shipTop - 2, 44, shipHeight + 4);
                    }

                    ctx.restore();
                }

                if (player.hasRearGuard && player.rearGuardReady) {
                    const pulse = 0.4 + 0.3 * Math.sin(performance.now() / 200);
                    ctx.fillStyle = `rgba(100, 255, 255, ${pulse})`;
                    ctx.beginPath();
                    ctx.arc(0, 15, 8, 0, 2 * Math.PI);
                    ctx.fill();
                }

                ctx.restore();
            }

            function drawMine(m) {
                ctx.save();
                ctx.translate(m.x, m.y);
                const time = performance.now();
                const pulse = 0.8 + 0.2 * Math.sin(time / 150);
                const fuseRatio = m.fuse / 5;
                const color = `rgb(255, ${100 * fuseRatio}, ${80 * fuseRatio})`;

                ctx.beginPath();
                ctx.arc(0, 0, m.r * 1.5 * pulse, 0, 2 * Math.PI);
                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, m.r * 1.5 * pulse);
                grad.addColorStop(0, color + '99');
                grad.addColorStop(1, color + '00');
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.fillStyle = "#333";
                ctx.beginPath();
                ctx.arc(0, 0, m.r, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = "#555";
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, 0, m.r * 0.4 * pulse, 0, 2 * Math.PI);
                ctx.fill();

                ctx.restore();
            }
            const VOID_CHAMPION_SCHEME_BY_MODULE = Object.freeze({
                default: 'purple',
                ember: 'crimson',
                tempest: 'azure',
                void: 'purple'
            });

            const VOID_CHAMPION_COLOR_SCHEMES = {
                purple: {
                    name: 'Void Wraith',
                    shadowColor: '#b56bff',
                    auraColor: '#7a34ff',
                    hullGradient: ['#5f18c4', '#1b0635', '#320a63'],
                    strokeColor: '#c6a4ff',
                    finColor: [155, 69, 255],
                    visorGradient: ['#f5d9ff', '#7d2cff'],
                    eyeColor: '#ff508f',
                    coreGlow: '#e499ff',
                    coreColor: '#ffe6ff',
                    thrusterColor: '#732bff'
                },
                crimson: {
                    name: 'Crimson Reaper',
                    shadowColor: '#ff4444',
                    auraColor: '#cc1100',
                    hullGradient: ['#8b0000', '#330000', '#4a0000'],
                    strokeColor: '#ff6666',
                    finColor: [200, 50, 50],
                    visorGradient: ['#ffcccc', '#990000'],
                    eyeColor: '#ffff00',
                    coreGlow: '#ff8888',
                    coreColor: '#ffffff',
                    thrusterColor: '#cc0000'
                },
                azure: {
                    name: 'Azure Phantom',
                    shadowColor: '#4488ff',
                    auraColor: '#0044cc',
                    hullGradient: ['#1144aa', '#001122', '#002244'],
                    strokeColor: '#66aaff',
                    finColor: [100, 150, 255],
                    visorGradient: ['#ccddff', '#0066cc'],
                    eyeColor: '#00ffff',
                    coreGlow: '#88bbff',
                    coreColor: '#ffffff',
                    thrusterColor: '#0088ff'
                },
                emerald: {
                    name: 'Emerald Specter',
                    shadowColor: '#44ff44',
                    auraColor: '#00cc44',
                    hullGradient: ['#006600', '#001100', '#003300'],
                    strokeColor: '#66ff66',
                    finColor: [50, 200, 50],
                    visorGradient: ['#ccffcc', '#009900'],
                    eyeColor: '#ffff00',
                    coreGlow: '#88ff88',
                    coreColor: '#ffffff',
                    thrusterColor: '#00cc00'
                },
                golden: {
                    name: 'Golden Harbinger',
                    shadowColor: '#ffcc44',
                    auraColor: '#cc8800',
                    hullGradient: ['#b8860b', '#4a3c00', '#6b5b00'],
                    strokeColor: '#ffd700',
                    finColor: [255, 200, 50],
                    visorGradient: ['#fffacd', '#daa520'],
                    eyeColor: '#ff4500',
                    coreGlow: '#ffd700',
                    coreColor: '#ffffff',
                    thrusterColor: '#b8860b'
                }
            };

            function getVoidChampionColorScheme(enemy) {
                if (!enemy.colorScheme) {
                    const schemes = Object.keys(VOID_CHAMPION_COLOR_SCHEMES);
                    const seed = enemy.id || (enemy.x + enemy.y * 1000);
                    const schemeIndex = Math.abs(Math.floor(seed)) % schemes.length;
                    enemy.colorScheme = schemes[schemeIndex];
                    enemy.displayName = VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme].name;
                }
                return VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme];
            }

            function drawEnemy(e) {
                const { x: t, y: o, r: a, type: r, color: n, hp: l, hpMax: s, t: c } = e;
                ctx.save();
                let drawX = t;
                let drawY = o;
                if (e.hitShakeTimer && e.hitShakeTimer > 0 && e.hitShakeIntensity) {
                    const baseDuration = e.hitShakeDuration || 0.16;
                    const ratio = baseDuration > 0 ? Math.max(0, Math.min(1, e.hitShakeTimer / baseDuration)) : 0;
                    const intensity = e.hitShakeIntensity * Math.pow(ratio, 0.6);
                    const phaseSeed = (e.id || 0) * 13.37;
                    const time = performance.now() * 0.006 + phaseSeed;
                    drawX += Math.sin(time) * intensity;
                    drawY += Math.cos(time * 1.6) * intensity * 0.7;
                }
                ctx.translate(drawX, drawY);
                const spawnAlpha = e.spawnOpacity !== undefined ? Math.max(0.2, Math.min(1, e.spawnOpacity)) : 1;
                ctx.globalAlpha *= spawnAlpha;
                if (e.spawnPhase === 'teleport') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const time = performance.now() / 200;
                    const ringRadius = (a + 8) * (0.9 + 0.05 * Math.sin(time + (e.spawnClusterIndex || 0)));
                    const ringAlpha = 0.35 + 0.25 * spawnAlpha;
                    ctx.globalAlpha = ringAlpha;
                    ctx.strokeStyle = e.spawnEffectColor || '#9ad7ff';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = ringAlpha * 0.7;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius * 0.65, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                // Apply flattening effect if enemy has flattenScale property
                if (e.flattenScale !== undefined) {
                    if (typeof e.flattenScale === 'number') {
                        ctx.scale(1, e.flattenScale);
                    } else {
                        ctx.scale(e.flattenScale.x || 1, e.flattenScale.y || 1);
                    }
                }
                l < s && l > 0 && (ctx.fillStyle = 'rgba(0,0,0,0.5)', ctx.fillRect(-a, -a - 8, 2 * a, 3), ctx.fillStyle = "#b266ff", ctx.fillRect(-a, -a - 8, 2 * a * (l / s), 3)); ctx.lineWidth = 2; ctx.beginPath(); switch (r) {
                    case "avian_hatchling": ctx.fillStyle = n + "aa"; ctx.strokeStyle = n; ctx.lineWidth = 2; ctx.moveTo(0, -a * 1.2); ctx.lineTo(a, -a * 0.5); ctx.lineTo(a, a * 0.5); ctx.lineTo(0, a * 1.2); ctx.lineTo(-a, a * 0.5); ctx.lineTo(-a, -a * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); break; case "construct_gold": ctx.fillStyle = n + "aa"; ctx.strokeStyle = n; ctx.lineWidth = 2; ctx.moveTo(0, -a); ctx.lineTo(a, 0); ctx.lineTo(0, a); ctx.lineTo(-a, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); break; case "trap_king_add": case "drone": const droneGradient = ctx.createLinearGradient(-a, -a, a, a); droneGradient.addColorStop(0, "#E0E0E0"); droneGradient.addColorStop(1, "#A0A0A0"); ctx.fillStyle = droneGradient; ctx.strokeStyle = "#808080"; ctx.beginPath(); ctx.moveTo(-1.2 * a, 0); ctx.quadraticCurveTo(0, -a, 1.2 * a, 0); ctx.quadraticCurveTo(0, .6 * a, -1.2 * a, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#aaddff"; ctx.strokeStyle = "#FFFFFF"; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, -.2 * a, .6 * a, Math.PI, 0); ctx.fill(); ctx.stroke(); ctx.fillStyle = r === "trap_king_add" ? "#ffc83d" : "#32CD32"; ctx.beginPath(); ctx.ellipse(0, -.2 * a, .3 * a, .4 * a, 0, 0, 2 * Math.PI); ctx.fill(); ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.ellipse(-.1 * a, -.25 * a, .08 * a, .15 * a, -.5, 0, 2 * Math.PI); ctx.ellipse(.1 * a, -.25 * a, .08 * a, .15 * a, .5, 0, 2 * Math.PI); ctx.fill(); break;
                    case "hunter": {
                        const time = performance.now() / 1000;
                        const segments = 8;
                        const length = a * 2;
                        const amplitude = a * 0.5;

                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                        ctx.setLineDash([]);

                        const top = [];
                        const bottom = [];

                        for (let i = 0; i <= segments; i++) {
                            const progress = i / segments;
                            const width = a * Math.sin(progress * Math.PI) * 0.4;
                            const x = Math.sin(progress * 2 * Math.PI + c * 4) * amplitude;
                            const y = (progress - 0.5) * length;
                            top.push({ x: x + width, y });
                            bottom.push({ x: x - width, y });
                        }

                        ctx.fillStyle = '#cc3344';
                        ctx.strokeStyle = '#7a1b24';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(top[0].x, top[0].y);
                        for (let i = 1; i < top.length; i++) ctx.lineTo(top[i].x, top[i].y);
                        for (let i = bottom.length - 1; i >= 0; i--) ctx.lineTo(bottom[i].x, bottom[i].y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        const headX = Math.sin(c * 4) * amplitude;
                        const headY = -0.5 * length;

                        ctx.fillStyle = '#e47777';
                        ctx.strokeStyle = '#7a1b24';
                        ctx.beginPath();
                        ctx.arc(headX, headY, a * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#250b0b';
                        const eyeOffsetX = a * 0.12;
                        const eyeOffsetY = a * 0.05;
                        const eyeRadius = a * 0.08;
                        ctx.beginPath();
                        ctx.arc(headX - eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                        ctx.arc(headX + eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = '#7a1b24';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(headX, headY + a * 0.1);
                        ctx.lineTo(headX, headY + a * 0.4);
                        ctx.stroke();

                        break;
                    }
                    case "phantom":
                        ctx.globalAlpha = .6 + .4 * Math.sin(5 * c); ctx.strokeStyle = n; ctx.fillStyle = n + "99"; ctx.moveTo(0, -.8 * a); ctx.quadraticCurveTo(a, -.5 * a, .8 * a, .8 * a); ctx.quadraticCurveTo(0, .5 * a, -.8 * a, .8 * a); ctx.quadraticCurveTo(-a, -.5 * a, 0, -.8 * a); ctx.closePath(); ctx.fill(); ctx.stroke(); for (let e = -1; e <= 1; e++)ctx.beginPath(), ctx.moveTo(e * .4 * a, .6 * a), ctx.quadraticCurveTo(e * .5 * a, a, e * .3 * a + 2 * Math.sin(4 * c + e), 1.2 * a), ctx.stroke(); break;
                    case "mech":
                        // Enhanced mechanical tank enemy with Aquaman aqua blue theme
                        const time = performance.now() / 1000;
                        const pulseFactor = 1 + 0.05 * Math.sin(time * 4);

                        // Aquaman color scheme: aqua blues and ocean greens
                        const mainColor = '#0e4b5c'; // Deep aqua blue
                        const accentColor = '#20b2aa'; // Light sea green
                        const metalColor = '#2e8b8b'; // Dark cyan/teal
                        const glowColor = '#00ffff'; // Bright cyan glow
                        const highlightColor = '#40e0d0'; // Turquoise highlights

                        ctx.lineWidth = 2;

                        // Main chassis with aqua gradient shading
                        const chassisGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.2);
                        chassisGradient.addColorStop(0, highlightColor);
                        chassisGradient.addColorStop(0.6, mainColor);
                        chassisGradient.addColorStop(1, '#051e28'); // Deep ocean blue

                        ctx.fillStyle = chassisGradient;
                        ctx.strokeStyle = accentColor;
                        ctx.beginPath();
                        ctx.moveTo(-a * 1.2, -a * 1.0);
                        ctx.lineTo(a * 1.2, -a * 1.0);
                        ctx.lineTo(a * 0.7, a * 0.6);
                        ctx.lineTo(-a * 0.7, a * 0.6);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        // Armor plating with rivets
                        ctx.strokeStyle = metalColor;
                        ctx.lineWidth = 1;
                        for (let i = -2; i <= 2; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * a * 0.2, -a * 0.8);
                            ctx.lineTo(i * a * 0.15, a * 0.4);
                            ctx.stroke();
                        }

                        // Rivets with aqua metallic finish
                        ctx.fillStyle = '#5f9ea0'; // Cadet blue rivets
                        for (let i = -1; i <= 1; i++) {
                            for (let j = -1; j <= 1; j++) {
                                ctx.beginPath();
                                ctx.arc(i * a * 0.3, j * a * 0.3, a * 0.08, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }

                        // Weapon turrets with menacing design
                        ctx.lineWidth = 3;
                        // Left turret
                        ctx.fillStyle = mainColor;
                        ctx.strokeStyle = accentColor;
                        ctx.beginPath();
                        ctx.rect(-a * 1.6, -a * 0.9, a * 0.7, a * 1.8);
                        ctx.fill(); ctx.stroke();

                        // Left cannon barrel
                        ctx.fillStyle = metalColor;
                        ctx.beginPath();
                        ctx.rect(-a * 1.3 - a * 0.5, -a * 0.1, a * 0.8, a * 0.2);
                        ctx.fill(); ctx.stroke();

                        // Right turret
                        ctx.fillStyle = mainColor;
                        ctx.strokeStyle = accentColor;
                        ctx.beginPath();
                        ctx.rect(a * 0.9, -a * 0.9, a * 0.7, a * 1.8);
                        ctx.fill(); ctx.stroke();

                        // Right cannon barrel
                        ctx.fillStyle = metalColor;
                        ctx.beginPath();
                        ctx.rect(a * 1.3, -a * 0.1, a * 0.8, a * 0.2);
                        ctx.fill(); ctx.stroke();

                        // Aqua blue eyes/sensors with oceanic glow
                        ctx.shadowColor = glowColor;
                        ctx.shadowBlur = 8 * pulseFactor;
                        ctx.fillStyle = glowColor;
                        ctx.beginPath();
                        ctx.arc(-a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Tank treads with aqua metallic detail
                        ctx.fillStyle = '#1c4e4e'; // Dark teal treads
                        ctx.strokeStyle = metalColor;
                        ctx.lineWidth = 2;

                        // Left tread
                        ctx.beginPath();
                        ctx.arc(-a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
                        ctx.fill(); ctx.stroke();

                        // Tread segments
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2 + time * 2;
                            const x = -a * 1.3 + Math.cos(angle) * a * 0.4;
                            const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                            ctx.fillStyle = '#4682b4'; // Steel blue segments
                            ctx.beginPath();
                            ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                            ctx.fill();
                        }

                        // Right tread
                        ctx.fillStyle = '#1c4e4e'; // Dark teal treads
                        ctx.beginPath();
                        ctx.arc(a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
                        ctx.fill(); ctx.stroke();

                        // Right tread segments
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2 + time * 2;
                            const x = a * 1.3 + Math.cos(angle) * a * 0.4;
                            const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                            ctx.fillStyle = '#4682b4'; // Steel blue segments
                            ctx.beginPath();
                            ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                            ctx.fill();
                        }

                        // Command center/cockpit with aqua gradient
                        const cockpitGradient = ctx.createLinearGradient(0, -a * 1.4, 0, -a * 1.0);
                        cockpitGradient.addColorStop(0, accentColor);
                        cockpitGradient.addColorStop(0.5, mainColor);
                        cockpitGradient.addColorStop(1, '#0a2533'); // Deep ocean blue

                        ctx.fillStyle = cockpitGradient;
                        ctx.strokeStyle = metalColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.rect(-a * 0.4, -a * 1.4, a * 0.8, a * 0.5);
                        ctx.fill(); ctx.stroke();

                        // Antenna/communication array
                        ctx.strokeStyle = metalColor;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, -a * 1.4);
                        ctx.lineTo(-a * 0.2, -a * 1.8);
                        ctx.moveTo(0, -a * 1.4);
                        ctx.lineTo(a * 0.2, -a * 1.8);
                        ctx.stroke();

                        // Aqua warning lights
                        ctx.fillStyle = time % 1 < 0.5 ? glowColor : '#004d4d';
                        ctx.beginPath();
                        ctx.arc(-a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
                        ctx.fill();

                        // Aqua energy exhaust vents
                        ctx.fillStyle = '#00bfff'; // Deep sky blue exhaust
                        ctx.shadowColor = '#00bfff';
                        ctx.shadowBlur = 4;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.rect(-a * 0.1 + i * a * 0.1, a * 0.4, a * 0.05, a * 0.2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                        break;
                    case "shadow_champion": {
                        const time = performance.now() / 1000;
                        const pulse = 0.8 + 0.2 * Math.sin(time * 5 + c * 3);
                        const swirl = c * 6;

                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.25 * pulse;
                        ctx.fillStyle = '#8f9bff';
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.45, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.globalCompositeOperation = 'source-over';
                        ctx.globalAlpha = 1;

                        const bodyGradient = ctx.createLinearGradient(0, -a * 1.2, 0, a * 1.1);
                        bodyGradient.addColorStop(0, '#eef1ff');
                        bodyGradient.addColorStop(0.55, '#cbd4ff');
                        bodyGradient.addColorStop(1, '#7a80d4');
                        ctx.fillStyle = bodyGradient;
                        ctx.strokeStyle = '#4f55b7';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -a * 1.05);
                        ctx.quadraticCurveTo(a * 0.95, -a * 0.05, a * 0.5, a * 0.95);
                        ctx.lineTo(-a * 0.5, a * 0.95);
                        ctx.quadraticCurveTo(-a * 0.95, -a * 0.05, 0, -a * 1.05);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#191a33';
                        ctx.beginPath();
                        ctx.ellipse(0, -a * 0.25, a * 0.52, a * 0.34, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#7b86ff';
                        ctx.beginPath();
                        ctx.ellipse(0, -a * 0.22, a * 0.45, a * 0.18, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.save();
                        ctx.rotate(swirl);
                        for (let i = 0; i < 4; i++) {
                            ctx.beginPath();
                            ctx.moveTo(0, a * 0.2);
                            ctx.lineTo(0, a * 1.3);
                            ctx.stroke();
                            ctx.rotate(Math.PI / 2);
                        }
                        ctx.restore();

                        ctx.fillStyle = 'rgba(139, 149, 255, 0.45)';
                        ctx.beginPath();
                        ctx.arc(0, a * 0.35, a * 0.42, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                        break;
                    }
                    case "void_champion": {
                        const time = performance.now() / 1000;
                        const shimmer = 0.55 + 0.45 * Math.sin(time * 6 + c * 3);
                        const wingPulse = 0.8 + 0.2 * Math.sin(time * 5 + c * 2);
                        const breathe = 0.92 + 0.08 * Math.sin(time * 3);

                        // Get color scheme for this specific enemy
                        const colors = getVoidChampionColorScheme(e);
                        const scheme = e.colorScheme || 'purple';

                        ctx.save();
                        ctx.shadowColor = colors.shadowColor;
                        ctx.shadowBlur = 12 * shimmer;

                        // Outer aura/energy field
                        ctx.globalAlpha = 0.35 * shimmer;
                        ctx.fillStyle = colors.auraColor;
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        // Draw based on scheme - each gets unique shape
                        if (scheme === 'crimson') {
                            // CRIMSON REAPER - Demonic berserker with horns and spikes
                            ctx.shadowBlur = 15 * shimmer;
                            
                            // Spiked armor plating
                            const plateGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.3);
                            plateGrad.addColorStop(0, colors.hullGradient[0]);
                            plateGrad.addColorStop(0.6, colors.hullGradient[1]);
                            plateGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = plateGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.5;
                            
                            // Bulky armored body
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 1.3);
                            ctx.lineTo(a * 0.95, -a * 0.2);
                            ctx.lineTo(a * 0.85, a * 0.6);
                            ctx.lineTo(a * 0.5, a * 1.15);
                            ctx.lineTo(0, a * 0.95);
                            ctx.lineTo(-a * 0.5, a * 1.15);
                            ctx.lineTo(-a * 0.85, a * 0.6);
                            ctx.lineTo(-a * 0.95, -a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Demonic horns
                            ctx.fillStyle = colors.strokeColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.5, -a * 1.1);
                            ctx.quadraticCurveTo(-a * 0.9, -a * 1.5, -a * 0.7, -a * 1.7);
                            ctx.lineTo(-a * 0.6, -a * 1.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 0.5, -a * 1.1);
                            ctx.quadraticCurveTo(a * 0.9, -a * 1.5, a * 0.7, -a * 1.7);
                            ctx.lineTo(a * 0.6, -a * 1.4);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Shoulder spikes
                            for (let spike of [[-1.1, -0.1], [1.1, -0.1], [-0.95, 0.3], [0.95, 0.3]]) {
                                ctx.fillStyle = colors.thrusterColor;
                                ctx.beginPath();
                                ctx.moveTo(a * spike[0], a * spike[1]);
                                ctx.lineTo(a * spike[0] * 1.4, a * spike[1]);
                                ctx.lineTo(a * spike[0] * 1.15, a * (spike[1] + 0.2));
                                ctx.closePath();
                                ctx.fill();
                            }
                            
                            // Glowing eyes
                            ctx.shadowBlur = 20;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.fillRect(-a * 0.35, -a * 0.65, a * 0.2, a * 0.12);
                            ctx.fillRect(a * 0.15, -a * 0.65, a * 0.2, a * 0.12);
                            
                            // Molten core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 18 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.arc(0, a * 0.25, a * 0.45 * breathe, 0, Math.PI * 2);
                            ctx.fill();
                            
                        } else if (scheme === 'azure') {
                            // AZURE PHANTOM - Sleek energy being with crystalline features
                            ctx.shadowBlur = 14 * shimmer;
                            
                            // Streamlined crystal body
                            const crystalGrad = ctx.createLinearGradient(-a, -a * 1.2, a, a * 1.2);
                            crystalGrad.addColorStop(0, colors.hullGradient[0]);
                            crystalGrad.addColorStop(0.5, colors.strokeColor);
                            crystalGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = crystalGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2;
                            
                            // Diamond-like hull
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 1.4);
                            ctx.lineTo(a * 0.65, -a * 0.3);
                            ctx.lineTo(a * 0.75, a * 0.4);
                            ctx.lineTo(a * 0.3, a * 1.2);
                            ctx.lineTo(0, a * 0.9);
                            ctx.lineTo(-a * 0.3, a * 1.2);
                            ctx.lineTo(-a * 0.75, a * 0.4);
                            ctx.lineTo(-a * 0.65, -a * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Energy wings
                            ctx.globalAlpha = 0.6 + 0.3 * wingPulse;
                            ctx.fillStyle = colors.auraColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.7, -a * 0.2);
                            ctx.quadraticCurveTo(-a * 1.6 * wingPulse, 0, -a * 0.8, a * 0.6);
                            ctx.lineTo(-a * 0.5, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 0.7, -a * 0.2);
                            ctx.quadraticCurveTo(a * 1.6 * wingPulse, 0, a * 0.8, a * 0.6);
                            ctx.lineTo(a * 0.5, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                            
                            // Visor with data streams
                            ctx.fillStyle = colors.visorGradient[0];
                            ctx.beginPath();
                            ctx.ellipse(0, -a * 0.6, a * 0.45, a * 0.25, 0, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Cyan eyes
                            ctx.shadowBlur = 16;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.beginPath();
                            ctx.arc(-a * 0.22, -a * 0.6, a * 0.1, 0, Math.PI * 2);
                            ctx.arc(a * 0.22, -a * 0.6, a * 0.1, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Pulsing energy core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 20 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.ellipse(0, a * 0.1, a * 0.35, a * 0.5 * breathe, 0, 0, Math.PI * 2);
                            ctx.fill();
                            
                        } else if (scheme === 'emerald') {
                            // EMERALD SPECTER - Bio-organic fusion with tendrils
                            ctx.shadowBlur = 13 * shimmer;
                            
                            // Organic carapace
                            const bioGrad = ctx.createRadialGradient(0, -a * 0.3, 0, 0, 0, a * 1.4);
                            bioGrad.addColorStop(0, colors.hullGradient[0]);
                            bioGrad.addColorStop(0.5, colors.hullGradient[1]);
                            bioGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = bioGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.2;
                            
                            // Segmented body
                            ctx.beginPath();
                            ctx.ellipse(0, -a * 0.5, a * 0.75, a * 0.85, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.ellipse(0, a * 0.4, a * 0.85, a * 0.8, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            
                            // Writhing tendrils
                            ctx.lineCap = 'round';
                            ctx.lineWidth = a * 0.15;
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const wave = Math.sin(time * 4 + i) * 0.3;
                                ctx.strokeStyle = colors.finColor[0] > 100 ? `rgba(${colors.finColor[0]}, ${colors.finColor[1]}, ${colors.finColor[2]}, 0.7)` : colors.auraColor;
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(angle) * a * 0.8, Math.sin(angle) * a * 0.6);
                                ctx.quadraticCurveTo(
                                    Math.cos(angle + wave) * a * 1.3,
                                    Math.sin(angle + wave) * a * 1,
                                    Math.cos(angle + wave * 1.5) * a * 1.6,
                                    Math.sin(angle + wave * 1.5) * a * 1.3
                                );
                                ctx.stroke();
                            }
                            ctx.lineCap = 'butt';
                            
                            // Insectoid eyes
                            ctx.shadowBlur = 14;
                            ctx.fillStyle = colors.eyeColor;
                            for (let eye of [[-0.3, -0.6], [-0.15, -0.65], [0.15, -0.65], [0.3, -0.6]]) {
                                ctx.beginPath();
                                ctx.arc(a * eye[0], a * eye[1], a * 0.08, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // Bio core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 16 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.arc(0, a * 0.05, a * 0.38 * breathe, 0, Math.PI * 2);
                            ctx.fill();
                            
                        } else if (scheme === 'golden') {
                            // GOLDEN HARBINGER - Ancient artifact with geometric patterns
                            ctx.shadowBlur = 18 * shimmer;
                            
                            // Ornate plated armor
                            const goldenGrad = ctx.createLinearGradient(0, -a * 1.4, 0, a * 1.2);
                            goldenGrad.addColorStop(0, colors.strokeColor);
                            goldenGrad.addColorStop(0.3, colors.hullGradient[0]);
                            goldenGrad.addColorStop(0.7, colors.hullGradient[1]);
                            goldenGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = goldenGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.8;
                            
                            // Hexagonal core body
                            ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                                const x = Math.cos(angle) * a * 0.9;
                                const y = Math.sin(angle) * a * 0.9;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Ornate crown
                            ctx.fillStyle = colors.strokeColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.6, -a * 0.9);
                            ctx.lineTo(-a * 0.5, -a * 1.5);
                            ctx.lineTo(-a * 0.3, -a * 1.0);
                            ctx.lineTo(0, -a * 1.6);
                            ctx.lineTo(a * 0.3, -a * 1.0);
                            ctx.lineTo(a * 0.5, -a * 1.5);
                            ctx.lineTo(a * 0.6, -a * 0.9);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Geometric shoulders
                            ctx.fillStyle = colors.thrusterColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 1.1, -a * 0.3);
                            ctx.lineTo(-a * 1.4, -a * 0.1);
                            ctx.lineTo(-a * 1.3, a * 0.3);
                            ctx.lineTo(-a * 0.9, a * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 1.1, -a * 0.3);
                            ctx.lineTo(a * 1.4, -a * 0.1);
                            ctx.lineTo(a * 1.3, a * 0.3);
                            ctx.lineTo(a * 0.9, a * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Regal eyes
                            ctx.shadowBlur = 20;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.fillRect(-a * 0.3, -a * 0.5, a * 0.15, a * 0.2);
                            ctx.fillRect(a * 0.15, -a * 0.5, a * 0.15, a * 0.2);
                            
                            // Sacred relic core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 22 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 0.15);
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const radius = (i % 2 === 0 ? 0.5 : 0.35) * breathe;
                                ctx.lineTo(Math.cos(angle) * a * radius, Math.sin(angle) * a * radius);
                            }
                            ctx.closePath();
                            ctx.fill();
                            
                        } else {
                            // VOID WRAITH (purple/default) - Classic void champion with ethereal features
                            ctx.shadowBlur = 12 * shimmer;
                            
                            // Ethereal hull
                            const voidGrad = ctx.createLinearGradient(0, -a * 1.3, 0, a * 1.1);
                            voidGrad.addColorStop(0, colors.hullGradient[0]);
                            voidGrad.addColorStop(0.45, colors.hullGradient[1]);
                            voidGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = voidGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.2;
                            
                            // Wraith-like body
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 1.25);
                            ctx.lineTo(a * 0.85, a * 0.25);
                            ctx.lineTo(a * 0.4, a * 1.15);
                            ctx.lineTo(0, a * 0.95);
                            ctx.lineTo(-a * 0.4, a * 1.15);
                            ctx.lineTo(-a * 0.85, a * 0.25);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Flowing void tendrils
                            ctx.globalAlpha = 0.5 + 0.4 * wingPulse;
                            ctx.fillStyle = `rgba(${colors.finColor[0]}, ${colors.finColor[1]}, ${colors.finColor[2]}, 0.7)`;
                            ctx.beginPath();
                            ctx.moveTo(-a * 1.05, -a * 0.05);
                            ctx.quadraticCurveTo(-a * 1.5 * wingPulse, a * 0.35, -a * 0.55, a * 0.65);
                            ctx.lineTo(-a * 0.4, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 1.05, -a * 0.05);
                            ctx.quadraticCurveTo(a * 1.5 * wingPulse, a * 0.35, a * 0.55, a * 0.65);
                            ctx.lineTo(a * 0.4, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                            
                            // Void visor
                            const visorGrad = ctx.createLinearGradient(0, -a * 0.8, 0, -a * 0.2);
                            visorGrad.addColorStop(0, colors.visorGradient[0]);
                            visorGrad.addColorStop(1, colors.visorGradient[1]);
                            ctx.fillStyle = visorGrad;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.5, -a * 0.5);
                            ctx.quadraticCurveTo(0, -a * 1, a * 0.5, -a * 0.5);
                            ctx.quadraticCurveTo(0, -a * 0.2, -a * 0.5, -a * 0.5);
                            ctx.fill();
                            
                            // Piercing eyes
                            ctx.shadowBlur = 16;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.beginPath();
                            ctx.ellipse(-a * 0.2, -a * 0.6, a * 0.12, a * 0.09, -0.3, 0, Math.PI * 2);
                            ctx.ellipse(a * 0.2, -a * 0.6, a * 0.12, a * 0.09, 0.3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Void core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 16 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.arc(0, a * 0.2, a * (0.4 + 0.08 * breathe), 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Thruster flames (all variants)
                        ctx.shadowBlur = 10 * shimmer;
                        ctx.globalAlpha = 0.85;
                        ctx.fillStyle = colors.thrusterColor;
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.35, a * 1.0);
                        ctx.lineTo(0, a * (1.5 + 0.25 * shimmer));
                        ctx.lineTo(a * 0.35, a * 1.0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        ctx.restore();
                        break;
                    }
                    case "void_champion_orb": {
                        const time = performance.now() / 1000;
                        const flicker = 0.6 + 0.4 * Math.sin(time * 10 + c * 8);
                        const pulse = 0.85 + 0.15 * Math.sin(time * 7 + c * 5);
                        const radius = a * pulse;
                        
                        // Draw energy tether to parent champion
                        let orbitTarget = null;
                        if (e.orbitTargetId) {
                            orbitTarget = store.enemies.find(en => en.id === e.orbitTargetId && !en.dead);
                        }
                        if (!orbitTarget && store.boss && !store.boss.dead) {
                            orbitTarget = store.boss;
                        }
                        
                        if (orbitTarget) {
                            ctx.save();
                            ctx.globalAlpha = 0.25 + 0.15 * flicker;
                            ctx.strokeStyle = e.trailColor || e.color || '#ff7deb';
                            ctx.lineWidth = 2.5;
                            ctx.setLineDash([6, 8]);
                            ctx.lineDashOffset = -time * 20;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(orbitTarget.x - e.x, orbitTarget.y - e.y);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.restore();
                        }

                        const module = e.attackModule || 'default';
                        const abilityTheme = e.abilityTheme || getChampionMinionAbilityTheme(module);
                        const trailColor = abilityTheme?.trail || e.trailColor || e.color || '#ff7deb';
                        const ringColor = abilityTheme?.ring || e.color || '#ff7deb';

                        ctx.save();
                        
                        // Outer glow aura
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.6 * flicker;
                        const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2);
                        auraGradient.addColorStop(0, withAlpha(trailColor, 0.8));
                        auraGradient.addColorStop(0.5, withAlpha(trailColor, 0.4));
                        auraGradient.addColorStop(1, withAlpha(trailColor, 0));
                        ctx.fillStyle = auraGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius * 2.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        // Rotating energy ring
                        ctx.save();
                        ctx.rotate(time * 3);
                        ctx.strokeStyle = withAlpha(ringColor, 0.7);
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            const angle = (i / 3) * Math.PI * 2;
                            const arcStart = angle;
                            const arcEnd = angle + Math.PI * 0.4;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius * 1.4, arcStart, arcEnd);
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Main orb body with layered spheres
                        const bodyGrad = ctx.createRadialGradient(radius * -0.2, radius * -0.2, 0, 0, 0, radius * 1.2);
                        bodyGrad.addColorStop(0, '#ffffff');
                        bodyGrad.addColorStop(0.4, ringColor);
                        bodyGrad.addColorStop(0.8, trailColor);
                        bodyGrad.addColorStop(1, withAlpha(trailColor, 0.5));
                        ctx.fillStyle = bodyGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Outer shell highlight
                        ctx.strokeStyle = withAlpha('#ffffff', 0.6);
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius * 0.95, 0, Math.PI * 2);
                        ctx.stroke();

                        // Energy core sparkle
                        ctx.save();
                        ctx.shadowBlur = 10 * flicker;
                        ctx.shadowColor = '#ffffff';
                        ctx.fillStyle = withAlpha('#ffffff', 0.9 * flicker);
                        ctx.beginPath();
                        ctx.arc(radius * -0.25, radius * -0.25, radius * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        // Orbiting particles
                        ctx.fillStyle = withAlpha(ringColor, 0.8);
                        for (let i = 0; i < 4; i++) {
                            const angle = time * 5 + (i / 4) * Math.PI * 2;
                            const dist = radius * 1.8;
                            const px = Math.cos(angle) * dist;
                            const py = Math.sin(angle) * dist;
                            ctx.beginPath();
                            ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        break;
                    }
                    case "void_reaper": {
                        const time = performance.now() / 1000;
                        const warningPhase = e.phase === 'warning';
                        const emergingPhase = e.phase === 'emerging';
                        const lungePhase = e.phase === 'lunge';
                        const pulse = 0.55 + 0.45 * Math.sin(time * 4.6 + (e.riftSeed || 0));

                        // Spectral aura
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.55 + 0.25 * pulse;
                        const outerRadius = a * 1.8;
                        const aura = ctx.createRadialGradient(0, 0, outerRadius * 0.2, 0, 0, outerRadius);
                        aura.addColorStop(0, 'rgba(180, 120, 255, 0.7)');
                        aura.addColorStop(0.6, 'rgba(120, 60, 200, 0.4)');
                        aura.addColorStop(1, 'rgba(40, 0, 80, 0)');
                        ctx.fillStyle = aura;
                        ctx.beginPath();
                        ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        ctx.save();
                        const heading = e.heading || 0;
                        ctx.rotate(heading - Math.PI / 2); // Rotate so it faces movement direction
                        
                        // Scale for visual effect
                        const scale = 0.9;
                        ctx.scale(scale, scale);
                        
                        // Spectral transparency and glow
                        ctx.globalAlpha = 0.85;
                        ctx.shadowColor = 'rgba(180, 120, 255, 0.7)';
                        ctx.shadowBlur = 20;

                        // Tattered robe body with fade
                        const bodyGradient = ctx.createLinearGradient(0, -a * 2, 0, a * 2);
                        bodyGradient.addColorStop(0, 'rgba(5, 0, 10, 1)');
                        bodyGradient.addColorStop(1, 'rgba(5, 0, 10, 0.4)');
                        ctx.fillStyle = bodyGradient;
                        
                        ctx.beginPath();
                        ctx.moveTo(-a, a * 1.4); // Tattered edge starts
                        ctx.lineTo(-a * 0.7, a * 2);
                        ctx.lineTo(-a * 0.3, a * 1.5);
                        ctx.lineTo(a * 0.15, a * 2);
                        ctx.lineTo(a * 0.6, a * 1.4);
                        ctx.lineTo(a, a * 2); // Tattered edge ends
                        ctx.quadraticCurveTo(a * 1.5, 0, a * 0.9, -a * 1.4); // Right side
                        ctx.quadraticCurveTo(0, -a * 2.1, -a * 0.9, -a * 1.4); // Top hood
                        ctx.quadraticCurveTo(-a * 1.5, 0, -a, a * 1.4); // Left side
                        ctx.closePath();
                        ctx.fill();

                        // Reset shadow for skull and scythe
                        ctx.shadowBlur = 0;

                        // Skull
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.45, -a * 1.3);
                        ctx.quadraticCurveTo(0, -a * 1.7, a * 0.45, -a * 1.3);
                        ctx.quadraticCurveTo(a * 0.6, -a * 0.6, 0, -a * 0.3);
                        ctx.quadraticCurveTo(-a * 0.6, -a * 0.6, -a * 0.45, -a * 1.3);
                        ctx.closePath();
                        ctx.fill();

                        // Eye sockets
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(-a * 0.25, -a, a * 0.18, 0, Math.PI * 2);
                        ctx.arc(a * 0.25, -a, a * 0.18, 0, Math.PI * 2);
                        ctx.fill();

                        // Nose cavity
                        ctx.beginPath();
                        ctx.moveTo(0, -a * 0.8);
                        ctx.lineTo(a * 0.12, -a * 0.6);
                        ctx.lineTo(-a * 0.12, -a * 0.6);
                        ctx.closePath();
                        ctx.fill();

                        // Scythe with swing animation
                        ctx.save();
                        const swingProgress = lungePhase ? Math.min(1, (e.lungeProgress || 0) * 1.4) : (emergingPhase ? (e.emergeProgress || 0) * 0.8 : 0);
                        const swingAngle = Math.sin(swingProgress * Math.PI) * -1.8;
                        ctx.rotate(swingAngle);

                        // Scythe handle
                        ctx.fillStyle = 'black';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = a * 0.25;
                        ctx.beginPath();
                        ctx.moveTo(a * 0.3, -a * 2.3);
                        ctx.lineTo(a * 0.3, a * 1.7);
                        ctx.stroke();

                        // Scythe blade
                        ctx.beginPath();
                        ctx.moveTo(a * 0.3, -a * 2.3);
                        ctx.quadraticCurveTo(a * 1.8, -a * 2.9, a * 2.6, -a * 1.4);
                        ctx.quadraticCurveTo(a * 1.9, -a * 2.4, a * 0.3, -a * 2);
                        ctx.closePath();
                        ctx.fill();

                        // Skeletal hand gripping scythe
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.rect(-a * 0.15, -a * 0.15, a * 0.5, a * 0.5);
                        ctx.rect(-a * 0.2, -a * 0.15, a * 0.12, a * 0.35);
                        ctx.rect(-a * 0.2, a * 0.2, a * 0.12, a * 0.35);
                        ctx.fill();
                        
                        ctx.restore(); // End scythe rotation

                        ctx.restore(); // End main rotation

                        // Afterimage trail during lunge
                        if (lungePhase) {
                            const afterImageCount = 5;
                            const baseAlpha = 0.22;
                            const lungeProgress = e.lungeProgress || 0;
                            for (let i = 1; i <= afterImageCount; i++) {
                                const decay = i / (afterImageCount + 1);
                                const offset = a * 3 * decay;
                                ctx.save();
                                ctx.globalAlpha = baseAlpha * (1 - decay);
                                ctx.translate(-Math.cos(heading) * offset, -Math.sin(heading) * offset);
                                ctx.rotate(heading - Math.PI / 2);
                                ctx.fillStyle = `rgba(130, 70, 220, ${0.6 * (1 - decay)})`;
                                ctx.beginPath();
                                ctx.ellipse(0, 0, a * (1.2 - decay * 0.3) * 0.9, a * (1.6 - decay * 0.4) * 0.9, 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        }

                        break;
                    }
                    case "angler": {
                        const scale = a / 20;
                        ctx.save(); ctx.scale(scale, scale);
                        ctx.fillStyle = n + "99"; ctx.strokeStyle = n; ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-20, 0);
                        ctx.quadraticCurveTo(0, -18, 24, 0);
                        ctx.quadraticCurveTo(0, 16, -20, 0);
                        ctx.closePath(); ctx.fill(); ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-6, 5);
                        ctx.quadraticCurveTo(2, 10, 10, 4);
                        ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(8, -6);
                        ctx.quadraticCurveTo(20, -24, 32, -28); ctx.stroke();
                        ctx.shadowColor = "#00FFD5"; ctx.shadowBlur = 12;
                        ctx.beginPath(); ctx.arc(32, -28, 4, 0, Math.PI * 2); ctx.fillStyle = "#00FFD5"; ctx.fill();
                        ctx.restore();
                        break;
                    }
                    case "manta": {
                        const scale = a / 36;
                        ctx.save(); ctx.scale(scale, scale);
                        ctx.fillStyle = n + "cc"; ctx.strokeStyle = n; ctx.lineWidth = 2;

                        ctx.beginPath();
                        ctx.moveTo(-36, 0);
                        ctx.quadraticCurveTo(-8, -18, 0, -8);
                        ctx.quadraticCurveTo(8, -18, 36, 0);
                        ctx.quadraticCurveTo(8, 14, 0, 8);
                        ctx.quadraticCurveTo(-8, 14, -36, 0);
                        ctx.closePath(); ctx.fill(); ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(0, 8);
                        ctx.quadraticCurveTo(4, 22, 0, 30);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.stroke();
                        ctx.restore();
                        break;
                    }
                }
                if (e.stunTimer && e.stunTimer > 0) {
                    ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + 0.3 * Math.sin(performance.now() / 100)})`;
                    ctx.font = 'bold 12px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('STUN', 0, -a - 12);
                }
                // Check if this enemy should show vulnerability visuals based on clustering
                const shouldShowVulnVisuals = (() => {
                    // Count nearby enemies with vulnerability visuals
                    const clusterRadius = 140; // Increased radius to cover more area
                    const maxVisualsPerCluster = 2; // Reduced from 3 to 2 to prevent overdraw
                    let nearbyWithVisuals = 0;
                    
                    for (const other of store.enemies) {
                        if (other === e || other.dead) continue;
                        const dx = other.x - e.x;
                        const dy = other.y - e.y;
                        const distSq = dx * dx + dy * dy;
                        
                        if (distSq < clusterRadius * clusterRadius) {
                            // Check if this nearby enemy has any vulnerability visual
                            if ((other.vulnerabilityPulseStrength && other.vulnerabilityPulseColor) || 
                                other.railgunArmorTimer > 0 || 
                                other.phaseLockTimer > 0) {
                                nearbyWithVisuals++;
                                // If this other enemy has higher priority (more health or closer to player), skip current enemy
                                if (nearbyWithVisuals >= maxVisualsPerCluster && other.hp > e.hp) {
                                    return false;
                                }
                            }
                        }
                    }
                    return nearbyWithVisuals < maxVisualsPerCluster;
                })();

                if (shouldShowVulnVisuals) {
                    if (e.vulnerabilityPulseStrength && e.vulnerabilityPulseColor) {
                        const pulse = (Math.sin(performance.now() / 120) + 1) * 0.5;
                        ctx.save();
                        ctx.globalAlpha = Math.min(0.9, e.vulnerabilityPulseStrength);
                        ctx.strokeStyle = e.vulnerabilityPulseColor;
                        ctx.lineWidth = 2.5 + pulse * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, a * (1.05 + 0.2 * pulse), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                    if (e.railgunArmorTimer > 0) {
                        ctx.save();
                        ctx.strokeStyle = `rgba(215,240,255,${Math.min(0.8, e.railgunArmorTimer / 2)})`;
                        ctx.lineWidth = 1.4;
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.6, -a * 0.3);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(a * 0.5, -a * 0.2);
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-a * 0.2, a * 0.5);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
                if (shouldShowVulnVisuals && e.phaseLockTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.4 + 0.2 * Math.sin(performance.now() / 60);
                    ctx.strokeStyle = '#9e7cff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-a * 1.2, 0);
                    ctx.lineTo(a * 1.2, 0);
                    ctx.moveTo(0, -a * 1.2);
                    ctx.lineTo(0, a * 1.2);
                    ctx.stroke();
                    ctx.restore();
                }
                if (e.stormShockTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.8, 0.4 + e.stormShockTimer * 0.3);
                    ctx.strokeStyle = '#66d6ff';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + performance.now() / 250;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * a * 0.4, Math.sin(angle) * a * 0.4);
                        ctx.lineTo(Math.cos(angle) * a * 1.3, Math.sin(angle) * a * 1.3);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
                if (e.demolitionPulseWarmup > 0) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.6, e.demolitionPulseWarmup * 1.2);
                    const grad = ctx.createRadialGradient(0, 0, a * 0.2, 0, 0, a * 1.4);
                    grad.addColorStop(0, 'rgba(255, 170, 90, 0.7)');
                    grad.addColorStop(1, 'rgba(255, 90, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * (1 + (1 - e.demolitionPulseWarmup) * 0.4), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                ctx.restore()
            }
            function createEffect(type, x, y, radius, options = {}) {
                const opts = options || {};
                let effect = { isActive: !0, life: 1, maxLife: 1, x, y, radius, opts };
                switch (type) {
                    case "heartbeatPulse":
                        effect.maxLife = 0.6;
                        effect.life = effect.maxLife;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const alpha = Math.sin((this.life / this.maxLife) * Math.PI) * 0.4;
                            ctx.save();
                            ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
                            ctx.fillRect(0, 0, W, H);
                            ctx.restore();
                        };
                        break;
                    case "beefCharge":
                        effect.maxLife = opts.duration ?? 0.38;
                        effect.origin = x;
                        effect.target = y;
                        effect.opts = opts;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - this.life;
                            const eased = 1 - Math.pow(1 - progress, 2.2);
                            const currentX = this.origin.x + (this.target.x - this.origin.x) * eased;
                            const currentY = this.origin.y + (this.target.y - this.origin.y) * eased;
                            const subclass = this.opts.subclass;
                            const chain = this.opts.segmentLabel === 'chain';
                            const colorMain = subclass === 'juggernaut' ? '255, 210, 120' : '255, 120, 120';
                            const colorEdge = subclass === 'juggernaut' ? '255, 180, 70' : '255, 80, 80';

                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';

                            if (progress > 0.45) {
                                const shockwaveProgress = (progress - 0.45) / 0.55;
                                const decay = 1 - shockwaveProgress;
                                ctx.strokeStyle = `rgba(${colorEdge}, ${0.55 * decay})`;
                                ctx.lineWidth = 6 * decay;
                                ctx.beginPath();
                                ctx.arc(this.target.x, this.target.y, (this.opts.rangeOverride ?? 85) * shockwaveProgress, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            ctx.strokeStyle = `rgba(${colorMain}, ${0.85 * this.life})`;
                            ctx.lineWidth = (chain ? 10 : 13) * this.life;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(this.origin.x, this.origin.y);
                            ctx.lineTo(currentX, currentY);
                            ctx.stroke();

                            ctx.globalAlpha = 0.6 * this.life;
                            ctx.lineWidth = 2.5 * (chain ? 1.2 : 1);
                            ctx.strokeStyle = `rgba(${colorEdge}, ${0.9 * this.life})`;
                            ctx.beginPath();
                            ctx.moveTo(this.origin.x, this.origin.y);
                            ctx.lineTo(currentX, currentY);
                            ctx.stroke();

                            ctx.restore();
                        };
                        break;
                    case "marauderImpact":
                        effect.maxLife = 0.48;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 90;
                        effect.opts = opts;
                        effect.shards = Array.from({ length: opts.subclass === 'juggernaut' ? 22 : 16 }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            speed: 140 + Math.random() * 160,
                            width: 5 + Math.random() * 3.5
                        }));
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const subclass = this.opts.subclass;
                            const primary = subclass === 'juggernaut' ? '255, 205, 120' : '255, 120, 120';
                            const secondary = subclass === 'juggernaut' ? '255, 175, 60' : '255, 90, 70';

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';

                            const coreRadius = this.radius * (0.45 + 0.25 * Math.sin(performance.now() / 140));
                            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * (0.8 + t * 0.4));
                            gradient.addColorStop(0, `rgba(${primary}, ${0.65 * this.life})`);
                            gradient.addColorStop(0.55, `rgba(${secondary}, ${0.45 * this.life})`);
                            gradient.addColorStop(1, 'rgba(255, 70, 20, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.8 + 0.35 * t), 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * this.life})`;
                            ctx.lineWidth = 6 * (1 - t) + 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, coreRadius * (0.9 + t * 0.6), 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.globalAlpha = 0.9 * this.life;
                            this.shards.forEach((shard, index) => {
                                const length = this.radius * (0.25 + t * 1.1);
                                const decay = Math.pow(1 - t, 0.5);
                                const sx = Math.cos(shard.angle) * length * decay;
                                const sy = Math.sin(shard.angle) * length * decay;
                                ctx.lineWidth = Math.max(1.2, shard.width * this.life * 0.75);
                                ctx.strokeStyle = subclass === 'juggernaut' ? '#ffe7a0' : '#ffc1b1';
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(sx, sy);
                                ctx.stroke();
                            });

                            ctx.restore();
                        };
                        break;
                    case "spawnTeleport":
                        effect.maxLife = opts.duration ?? 0.85;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 18;
                        effect.color = opts.color || '#9ad7ff';
                        effect.clusterIndex = opts.clusterIndex ?? 0;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const eased = 1 - Math.pow(1 - t, 2.4);
                            const alpha = Math.max(0, 0.75 * (1 - eased));
                            const ringPulse = 0.8 + Math.sin(performance.now() / 140 + this.clusterIndex) * 0.15;
                            const baseRadius = this.radius * (0.85 + eased * 0.55);
                            ctx.save();
                            ctx.translate(this.x, this.y + (opts.fallback ? 6 : 0));
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = alpha;
                            const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, baseRadius * 1.15);
                            gradient.addColorStop(0, `${this.color}aa`);
                            gradient.addColorStop(1, `${this.color}00`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, baseRadius * 1.15, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = this.color;
                            ctx.lineWidth = 2.5;
                            ctx.beginPath();
                            ctx.arc(0, 0, baseRadius * ringPulse, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.lineWidth = 1.2;
                            ctx.globalAlpha *= 0.8;
                            ctx.beginPath();
                            ctx.arc(0, 0, baseRadius * (0.55 + Math.sin(performance.now() / 180 + this.clusterIndex) * 0.1), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "voidReaperRift":
                        effect.maxLife = opts.duration ?? 2.0;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 80;
                        effect.edge = opts.edge || 'top';
                        effect.seed = Math.random() * Math.PI * 2;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const time = performance.now() / 1000;
                            const spin = time * 4 + this.seed;
                            const alpha = 0.45 + 0.35 * Math.sin(time * 6 + progress * 8);
                            const coreRadius = this.radius * (0.45 + progress * 0.25);
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = alpha;

                            const portal = ctx.createRadialGradient(0, 0, coreRadius * 0.25, 0, 0, coreRadius * 2.1);
                            portal.addColorStop(0, 'rgba(215, 180, 255, 0.85)');
                            portal.addColorStop(0.35, 'rgba(145, 90, 220, 0.6)');
                            portal.addColorStop(0.75, 'rgba(60, 20, 120, 0.35)');
                            portal.addColorStop(1, 'rgba(20, 4, 60, 0)');
                            ctx.fillStyle = portal;
                            ctx.beginPath();
                            ctx.arc(0, 0, coreRadius * (2 + progress * 0.3), 0, Math.PI * 2);
                            ctx.fill();

                            const shardCount = 18;
                            for (let i = 0; i < shardCount; i++) {
                                const angle = spin + (i / shardCount) * Math.PI * 2;
                                const length = coreRadius * (1.4 + Math.sin(time * 5 + i) * 0.25);
                                ctx.globalAlpha = 0.25 + progress * 0.45;
                                ctx.strokeStyle = 'rgba(240, 220, 255, 0.9)';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(angle) * coreRadius * 0.6, Math.sin(angle) * coreRadius * 0.6);
                                ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
                                ctx.stroke();
                            }

                            ctx.restore();
                        };
                        break;
                    case "voidReaperStrike":
                        effect.maxLife = opts.duration ?? 0.35;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 36;
                        effect.heading = opts.heading || 0;
                        effect.warmup = opts.warmup || false;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const eased = this.warmup ? Math.pow(t, 0.6) : t;
                            const radius = this.radius * (1 + eased * 0.45);
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.rotate(this.heading);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = this.warmup ? 0.35 + 0.4 * (1 - eased) : 0.45 * (1 - t) + 0.3;

                            const gradient = ctx.createLinearGradient(-radius * 0.4, 0, radius * 1.2, 0);
                            gradient.addColorStop(0, 'rgba(255, 220, 255, 0.65)');
                            gradient.addColorStop(0.4, 'rgba(180, 140, 255, 0.5)');
                            gradient.addColorStop(1, 'rgba(70, 20, 160, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.moveTo(-radius * 0.4, -radius * 0.35);
                            ctx.lineTo(radius * 1.2, 0);
                            ctx.lineTo(-radius * 0.4, radius * 0.35);
                            ctx.closePath();
                            ctx.fill();

                            ctx.strokeStyle = 'rgba(255, 240, 255, 0.85)';
                            ctx.lineWidth = 2.5;
                            ctx.beginPath();
                            ctx.moveTo(-radius * 0.4, -radius * 0.42);
                            ctx.quadraticCurveTo(radius * 0.6, 0, -radius * 0.4, radius * 0.42);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "voidReaperReward":
                        effect.maxLife = 1.8;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 90;
                        effect.gold = opts.gold || 0;
                        effect.shards = Array.from({ length: 28 }, (_, i) => ({
                            angle: (i / 28) * Math.PI * 2,
                            speed: 140 + Math.random() * 90,
                            size: 6 + Math.random() * 4
                        }));
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const fade = 1 - t;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = 0.8 * fade;

                            const core = ctx.createRadialGradient(0, 0, this.radius * 0.1, 0, 0, this.radius * (0.7 + t * 0.5));
                            core.addColorStop(0, 'rgba(255, 235, 200, 0.85)');
                            core.addColorStop(0.55, 'rgba(210, 150, 255, 0.55)');
                            core.addColorStop(1, 'rgba(120, 60, 200, 0)');
                            ctx.fillStyle = core;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.8 + t * 0.4), 0, Math.PI * 2);
                            ctx.fill();

                            ctx.globalAlpha = 0.6 * fade;
                            this.shards.forEach((shard, index) => {
                                const dist = shard.speed * t * 0.8;
                                const x = Math.cos(shard.angle) * dist;
                                const y = Math.sin(shard.angle) * dist;
                                ctx.fillStyle = index % 2 === 0 ? '#ffe6ff' : '#ffbfef';
                                ctx.beginPath();
                                ctx.arc(x, y, shard.size * (1 - t * 0.6), 0, Math.PI * 2);
                                ctx.fill();
                            });

                            if (this.gold) {
                                ctx.globalAlpha = 0.85 * fade;
                                ctx.fillStyle = '#ffe896';
                                ctx.font = 'bold 16px Orbitron';
                                ctx.textAlign = 'center';
                                ctx.fillText(`+${this.gold}G`, 0, -this.radius * 0.2);
                            }
                            ctx.restore();
                        };
                        break;
                    case "voidReaperDissolve":
                        effect.maxLife = opts.duration ?? 1.4;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 70;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            const ringRadius = this.radius * (0.6 + t * 0.7);
                            ctx.globalAlpha = 0.55 * (1 - t);
                            ctx.strokeStyle = 'rgba(210, 160, 255, 0.8)';
                            ctx.lineWidth = 4 - t * 2.5;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.globalAlpha = 0.35 * (1 - t);
                            ctx.fillStyle = 'rgba(120, 60, 200, 0.55)';
                            for (let i = 0; i < 5; i++) {
                                const angle = (i / 5) * Math.PI * 2 + performance.now() / 400;
                                const offset = ringRadius * 0.65;
                                ctx.beginPath();
                                ctx.arc(Math.cos(angle) * offset, Math.sin(angle) * offset, 8 + Math.sin(angle * 4) * 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.restore();
                        };
                        break;
                    case "goldenOrbSpawn":
                        effect.maxLife = 0.65;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 70;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const currentRadius = this.radius * (0.55 + progress * 0.7);
                            const time = performance.now() / 1000;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            const glow = ctx.createRadialGradient(0, 0, currentRadius * 0.25, 0, 0, currentRadius);
                            glow.addColorStop(0, 'rgba(255, 245, 200, 0.75)');
                            glow.addColorStop(0.6, 'rgba(255, 210, 90, 0.55)');
                            glow.addColorStop(1, 'rgba(255, 110, 20, 0)');
                            ctx.globalAlpha = 0.85 - progress * 0.5;
                            ctx.fillStyle = glow;
                            ctx.beginPath();
                            ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 220, 120, ${0.9 - progress})`;
                            ctx.lineWidth = 3 + 4 * (1 - progress);
                            ctx.beginPath();
                            ctx.arc(0, 0, currentRadius * (0.7 + Math.sin(time * 12) * 0.08), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "goldenOrbDetonation":
                        effect.maxLife = 0.6;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 150;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const ringRadius = this.radius * t;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, ringRadius);
                            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.75)');
                            gradient.addColorStop(0.35, 'rgba(255, 210, 90, 0.55)');
                            gradient.addColorStop(0.8, 'rgba(255, 120, 0, 0.15)');
                            gradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 200, 80, ${1 - t})`;
                            ctx.lineWidth = 6 * (1 - t);
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius * 0.72, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "hitSpark":
                        effect.maxLife = 0.22;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 14;
                        effect.sparks = Array.from({ length: opts.crit ? 8 : 5 }, (_, i) => {
                            const spread = (Math.random() - 0.5) * 0.9;
                            const angle = (opts.angle ?? 0) + spread;
                            const power = (opts.strength ?? 120) * (0.45 + Math.random() * 0.35);
                            return {
                                angle,
                                speed: power * 0.015,
                                length: effect.radius * (opts.crit ? 1.6 : 1.2) * (0.9 + Math.random() * 0.3),
                                offset: (i / Math.max(1, (opts.crit ? 8 : 5))) * 0.35
                            };
                        });
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const fade = 1 - t;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = 0.75 * fade;
                            ctx.strokeStyle = opts.crit ? '#ffd6ff' : '#ff9adb';
                            ctx.lineWidth = opts.crit ? 2.6 * fade : 1.8 * fade;
                            this.sparks.forEach(spark => {
                                const dist = spark.length * fade;
                                const dx = Math.cos(spark.angle) * dist;
                                const dy = Math.sin(spark.angle) * dist;
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(spark.angle) * spark.offset * this.radius, Math.sin(spark.angle) * spark.offset * this.radius);
                                ctx.lineTo(dx, dy);
                                ctx.stroke();
                            });
                            ctx.restore();
                        };
                        break;
                    case "rearGuardBlock":
                        effect.maxLife = 0.5;
                        effect.step = function (dt) { this.life -= dt / this.maxLife; if (this.life <= 0) this.isActive = false; };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(store.player.x, store.player.y);
                            ctx.strokeStyle = `rgba(100, 255, 255, ${this.life})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 5, 20 * (1.2 - this.life), Math.PI * 0.2, Math.PI * 0.8);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "omegaExplosion":
                        effect.maxLife = 0.75;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 90;
                        effect.color = opts.color || '#ffffff';
                        effect.omegaType = opts.omegaType;
                        effect.particles = Array.from({ length: 16 }, (_, i) => ({
                            angle: (i / 16) * Math.PI * 2,
                            speed: 120 + Math.random() * 60,
                            size: 4 + Math.random() * 3
                        }));
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const fade = 1 - t;
                            const time = performance.now() / 1000;
                            
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            
                            // Core explosion
                            const coreRadius = this.radius * (0.4 + t * 0.6);
                            ctx.globalAlpha = 0.7 * fade;
                            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                            gradient.addColorStop(0, this.color);
                            gradient.addColorStop(0.5, this.color + '88');
                            gradient.addColorStop(1, this.color + '00');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Expanding ring
                            ctx.globalAlpha = 0.9 * fade;
                            ctx.strokeStyle = this.color;
                            ctx.lineWidth = 4 * fade;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * t, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Flying particles
                            ctx.globalAlpha = 0.8 * fade;
                            this.particles.forEach(particle => {
                                const dist = particle.speed * t;
                                const px = Math.cos(particle.angle) * dist;
                                const py = Math.sin(particle.angle) * dist;
                                ctx.fillStyle = this.color;
                                ctx.beginPath();
                                ctx.arc(px, py, particle.size * (1 - t * 0.5), 0, Math.PI * 2);
                                ctx.fill();
                            });
                            
                            ctx.restore();
                        };
                        break;
                    case "gravityWell":
                        // Use radius parameter as scale factor (default 1.0 for normal, 0.4 for mini)
                        const scale = radius || 1.0;
                        effect.scale = scale;
                        effect.maxLife = 7;
                        effect.life = 7;
                        effect.radius = 0;
                        effect.maxRadius = scale < 1.0 ? 60 : 150; // Mini version much smaller visual
                        effect.effectRadius = scale < 1.0 ? 72 : 150; // Mini has 20% smaller AOE than before (was 90)
                        effect.damagePulseT = 1;
                        effect.totalDamageDealtToBoss = 0;
                        effect.stars = [];
                        const starCount = scale < 1.0 ? 20 : 50; // Fewer stars for mini version
                        for (let i = 0; i < starCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * effect.maxRadius;
                            effect.stars.push({
                                x: Math.cos(angle) * dist,
                                y: Math.sin(angle) * dist,
                                r: scale < 1.0 ? Math.random() * 0.8 : Math.random() * 1.5, // Smaller stars for mini
                                initialDist: dist
                            });
                        }
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) {
                                this.isActive = false;
                                screenFlash(1, 400, 'rgba(255, 255, 255, 0.5)');
                                return;
                            }
                            if (this.radius < this.maxRadius) {
                                this.radius += 200 * dt;
                            }

                            this.damagePulseT -= dt;
                            const damageThisFrame = this.damagePulseT <= 0;
                            if (damageThisFrame) {
                                this.damagePulseT = 1;
                            }

                            const pullStrength = 300;
                            const effectiveRadius = this.effectRadius || this.maxRadius;
                            const damageRadiusSq = (effectiveRadius * 0.7) ** 2;

                            store.enemies.forEach(e => {
                                if (e.dead) {
                                    return;
                                }
                                const dx = this.x - e.x;
                                const dy = this.y - e.y;
                                const distSq = dx * dx + dy * dy;

                                if (distSq < effectiveRadius ** 2) {
                                    const dist = Math.sqrt(distSq);
                                    if (dist > 10) {
                                        const resistance = (e.type === 'mech' || e.type === 'hunter') ? 0.7 : 1.0;
                                        e.x += (dx / dist) * pullStrength * resistance * dt;
                                        e.y += (dy / dist) * pullStrength * resistance * dt;
                                    }

                                    if (damageThisFrame && distSq < damageRadiusSq) {
                                        const damage = e.hpMax * (0.25 * store.player.dmgMult);
                                        e.hp -= damage;
                                        store.world.totalDamage += damage;

                                        // Apply vampirism healing for blink damage
                                        if (store.player.vampirism > 0) {
                                            let healAmount = damage * store.player.vampirism;
                                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                        }
                                    }
                                }
                            });
                            if (store.boss) {
                                const b = store.boss;
                                const dx = this.x - b.x;
                                const dy = this.y - b.y;
                                const distSq = dx * dx + dy * dy;
                                const effectiveRadius = this.effectRadius || this.maxRadius;
                                if (distSq < effectiveRadius ** 2) {
                                    const dist = Math.sqrt(distSq);
                                    if (dist > 50) {
                                        b.x += (dx / dist) * pullStrength * 0.5 * dt;
                                        b.y += (dy / dist) * pullStrength * 0.5 * dt;
                                    }
                                    if (damageThisFrame && distSq < damageRadiusSq) {
                                        const damageToDeal = b.hpMax * (0.10 * store.player.dmgMult);
                                        const cap = b.hpMax * 0.5;
                                        let actualDamage = damageToDeal;
                                        if (this.totalDamageDealtToBoss + actualDamage > cap) {
                                            actualDamage = cap - this.totalDamageDealtToBoss;
                                        }
                                        if (actualDamage > 0) {
                                            b.hp -= actualDamage;
                                            this.totalDamageDealtToBoss += actualDamage;
                                            store.world.totalDamage += actualDamage;

                                            // Apply vampirism healing for blink damage on boss
                                            if (store.player.vampirism > 0) {
                                                let healAmount = actualDamage * store.player.vampirism;
                                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                                healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                            }
                                        }
                                    }
                                }
                            }
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            const time = performance.now();
                            const lifeRatio = this.life / this.maxLife;

                            ctx.fillStyle = 'white';
                            this.stars.forEach(star => {
                                const pullFactor = 1 - lifeRatio;
                                const currentDist = star.initialDist * (1 - pullFactor * 0.95);
                                const angle = Math.atan2(star.y, star.x) + pullFactor * 3;
                                const sx = Math.cos(angle) * currentDist;
                                const sy = Math.sin(angle) * currentDist;

                                if (currentDist < this.radius) {
                                    ctx.globalAlpha = lifeRatio * (currentDist / this.radius);
                                    ctx.beginPath();
                                    ctx.arc(sx, sy, star.r, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            });
                            ctx.globalAlpha = 1;

                            for (let i = 0; i < 5; i++) {
                                const rotation = (time / (2000 + i * 200)) % (2 * Math.PI);
                                ctx.strokeStyle = `rgba(0, 0, 5, ${0.4 * lifeRatio})`;
                                ctx.lineWidth = (2 + i) * 2;
                                ctx.beginPath();
                                ctx.arc(0, 0, (this.radius / 5) * (i + 1), rotation, rotation + Math.PI * 1.5);
                                ctx.stroke();
                            }

                            const coreScale = this.scale < 1.0 ? 0.5 : 1.0; // Much smaller core for mini version
                            const corePulse = (3 + Math.sin(time / 100) * 2) * coreScale;
                            const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse * 2);
                            coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            coreGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.7)');
                            coreGrad.addColorStop(1, 'rgba(150, 150, 255, 0)');
                            ctx.fillStyle = coreGrad;
                            ctx.shadowColor = 'white';
                            ctx.shadowBlur = 15 * coreScale;
                            ctx.beginPath();
                            ctx.arc(0, 0, corePulse * 2, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        };
                        break;
                    case "grenadeExplosion":
                        effect.maxLife = .5;
                        effect.radius = radius || 60;
                        effect.step = function (dt) { this.life -= 2 * dt; this.life <= 0 && (this.isActive = !1) };
                        effect.draw = function () {
                            // Make clusters more transparent, especially larger ones
                            const alphaScale = this.radius > 100 ? 0.25 : (this.radius > 70 ? 0.35 : 0.5);
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius * (1 - this.life), 0, 2 * Math.PI);
                            ctx.fillStyle = `rgba(255, 153, 51, ${alphaScale * this.life})`;
                            ctx.fill()
                        };
                        break;
                    case "shieldBreak": effect.maxLife = .6; effect.step = function (dt) { this.life -= 1.5 * dt; this.life <= 0 && (this.isActive = !1) }; effect.draw = function () { ctx.strokeStyle = `rgba(154, 102, 255, ${this.life})`; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(this.x, this.y, 24 * (1.5 - this.life), 0, 2 * Math.PI); ctx.stroke() }; break;
                    case "nanoHeal":
                        effect.maxLife = 0.7;
                        effect.step = function (dt) { this.life -= dt / this.maxLife; if (this.life <= 0) this.isActive = false; };
                        effect.draw = function () {
                            const p = 1 - this.life;
                            ctx.save();
                            ctx.translate(store.player.x, store.player.y);
                            ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                            ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                            ctx.stroke();
                            ctx.fill();
                            ctx.restore();
                        };
                        break;
                    case "jugFearIgnite":
                        effect.maxLife = 0.6;
                        effect.radius = radius || 40;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            const progress = 1 - this.life;
                            ctx.globalAlpha = 0.5 + 0.4 * Math.sin(performance.now() / 60);
                            ctx.fillStyle = 'rgba(255,80,40,0.6)';
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.7 + progress * 0.6), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = 'rgba(255,200,120,0.5)';
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.4 + progress * 0.3), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        };
                        break;
                    case "jugFearEmber":
                        effect.maxLife = 0.4;
                        effect.radius = radius || 20;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            this.y -= 40 * dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.fillStyle = 'rgba(255,150,80,0.8)';
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.4 + 0.6 * this.life), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        };
                        break;
                    case "marauderLaunchTrail":
                        const trailCfg = radius || {};
                        effect.maxLife = trailCfg.duration || 0.5;
                        effect.life = effect.maxLife;
                        effect.followEnemy = trailCfg.enemy || null;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.followEnemy) {
                                this.x = this.followEnemy.x;
                                this.y = this.followEnemy.y;
                            }
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                            ctx.strokeStyle = 'rgba(170, 209, 255, 0.7)';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, 30 * (1 + (1 - this.life / this.maxLife)), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "maraImpactShockwave":
                        effect.maxLife = 0.4;
                        effect.radius = radius || 45;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(150, 210, 255, 0.9)';
                            ctx.lineWidth = 6 - (5 * (1 - this.life));
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "armorCrackFlash":
                        effect.maxLife = 0.5;
                        effect.level = radius || 1;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(210, 240, 255, 0.8)';
                            ctx.lineWidth = 1.2;
                            for (let i = 0; i < 3 + this.level; i++) {
                                const angle = (i / (3 + this.level)) * Math.PI * 2;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                                ctx.stroke();
                            }
                            ctx.restore();
                        };
                        break;
                    case "demolitionPulseCharge":
                        effect.maxLife = 0.7;
                        effect.radius = radius || 40;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(255, 170, 90, 0.8)';
                            ctx.lineWidth = 2 + (1 - this.life) * 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "voidLockChains":
                        effect.maxLife = 0.6;
                        effect.radius = radius || 45;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            const rotation = performance.now() / 200;
                            ctx.globalAlpha = 0.5 + 0.3 * this.life;
                            ctx.strokeStyle = 'rgba(140, 120, 255, 0.9)';
                            ctx.lineWidth = 3;
                            for (let i = 0; i < 4; i++) {
                                const angle = rotation + (i / 4) * Math.PI * 2;
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                                ctx.lineTo(Math.cos(angle + Math.PI) * this.radius * 0.4, Math.sin(angle + Math.PI) * this.radius * 0.4);
                                ctx.stroke();
                            }
                            ctx.restore();
                        };
                        break;
                    case "stormDischarge":
                        effect.maxLife = 0.35;
                        effect.radius = radius || 60;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life * 0.8;
                            ctx.strokeStyle = 'rgba(110, 210, 255, 1)';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1.1 - this.life * 0.4), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "empShockwave":
                        effect.maxLife = opts.duration ?? 0.6;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 220;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const outerRadius = this.radius * (0.4 + progress * 0.6);
                            const innerRadius = outerRadius * 0.65;
                            const alpha = Math.max(0, 0.6 * (1 - progress));

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';

                            ctx.strokeStyle = `rgba(110, 210, 255, ${alpha})`;
                            ctx.lineWidth = 6 * (1 - progress) + 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.setLineDash([8, 6]);
                            ctx.strokeStyle = `rgba(190, 140, 255, ${alpha * 0.8})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.fillStyle = `rgba(60, 160, 255, ${alpha * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, innerRadius * 0.75, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        };
                        break;
                    case "empStatic":
                        effect.maxLife = opts.duration ?? 0.35;
                        effect.radius = radius || 20;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - this.life;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = Math.max(0, 0.8 * this.life);

                            ctx.fillStyle = `rgba(130, 210, 255, ${0.5 * this.life})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.6 + 0.5 * t), 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * this.life})`;
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.35 + 0.4 * t), 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.restore();
                        };
                        break;
                    case "stormArc":
                        const arcTarget = radius || { x, y };
                        effect.maxLife = 0.2;
                        effect.target = arcTarget;
                        effect.x = x;
                        effect.y = y;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(120, 220, 255, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            const controlX = (this.x + this.target.x) / 2 + (Math.random() - 0.5) * 30;
                            const controlY = (this.y + this.target.y) / 2 + (Math.random() - 0.5) * 30;
                            ctx.quadraticCurveTo(controlX, controlY, this.target.x, this.target.y);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "delayedFlamePulse":
                        effect.maxLife = 0.5;
                        effect.radius = radius || 90;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(255, 150, 60, 0.8)';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1 + (1 - this.life) * 0.3), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "critText":
                        effect.maxLife = 0.6;
                        effect.text = "CRITICAL!";
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            this.y -= 30 * dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                            ctx.font = 'bold 14px Orbitron';
                            ctx.textAlign = 'center';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText(this.text, this.x, this.y);
                            ctx.restore();
                        };
                        break;
                    case "bossPhaseChange":
                        effect.maxLife = 0.8;
                        effect.radius = 0;
                        effect.step = function (dt) { this.life -= dt / this.maxLife; if (this.life <= 0) this.isActive = false; this.radius += 600 * dt; };
                        effect.draw = function () {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                            ctx.lineWidth = 1 + 4 * this.life;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                            ctx.stroke();
                        };
                        break;
                    case "screenFlash":
                        effect.maxLife = y / 1000;
                        effect.life = effect.maxLife;
                        effect.color = radius;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.globalAlpha = this.life / this.maxLife;
                            ctx.fillStyle = this.color;
                            ctx.fillRect(0, 0, W, H);
                            ctx.restore();
                        };
                        break;
                    case "timeRippleExplosion":
                        effect.maxLife = 0.8;
                        effect.radius = 0;
                        effect.maxRadius = 80;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            this.radius = this.maxRadius * (1 - this.life);
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);

                            // Create time ripple effect with concentric circles
                            for (let i = 0; i < 3; i++) {
                                const rippleRadius = this.radius * (0.3 + i * 0.3);
                                const alpha = this.life * (1 - i * 0.2);

                                // Outer ripple ring
                                ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                                ctx.lineWidth = 3 - i;
                                ctx.beginPath();
                                ctx.arc(0, 0, rippleRadius, 0, 2 * Math.PI);
                                ctx.stroke();

                                // Inner glow
                                ctx.fillStyle = `rgba(150, 220, 255, ${alpha * 0.3})`;
                                ctx.beginPath();
                                ctx.arc(0, 0, rippleRadius * 0.8, 0, 2 * Math.PI);
                                ctx.fill();
                            }

                            // Central time distortion effect
                            const centerAlpha = this.life * 0.6;
                            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                            grad.addColorStop(0, `rgba(200, 240, 255, ${centerAlpha})`);
                            grad.addColorStop(0.7, `rgba(100, 200, 255, ${centerAlpha * 0.5})`);
                            grad.addColorStop(1, `rgba(50, 150, 255, 0)`);

                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
                            ctx.fill();

                            ctx.restore();
                        };
                        break;
                    case "lightningFlash":
                        effect.maxLife = 0.15; // Very short flash duration
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);

                            // Calculate flash intensity based on remaining life
                            const intensity = Math.sin(this.life * Math.PI); // Sine wave for smooth fade
                            const alpha = intensity * 0.8;

                            // Outer blue glow
                            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                            grad.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                            grad.addColorStop(0.5, `rgba(50, 150, 255, ${alpha * 0.6})`);
                            grad.addColorStop(1, `rgba(30, 100, 255, 0)`);

                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                            ctx.fill();

                            // Inner bright white core
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, 8, 0, 2 * Math.PI);
                            ctx.fill();

                            // Electric sparks around the edge
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * 2 * Math.PI + this.life * 10; // Rotate sparks
                                const sparkX = Math.cos(angle) * (20 + Math.random() * 10);
                                const sparkY = Math.sin(angle) * (20 + Math.random() * 10);

                                ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.7})`;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(sparkX * 0.7, sparkY * 0.7);
                                ctx.lineTo(sparkX, sparkY);
                                ctx.stroke();
                            }

                            ctx.restore();
                        };
                        break;
                }
                return effect
            }


            function explodeMine(mine) {
                playSound('explosion');
                const p = store.player;

                const numBullets = 18;
                for (let i = 0; i < numBullets; i++) {
                    const angle = (i / numBullets) * 2 * Math.PI;
                    const bulletSpeed = 300;
                    spawnBullet({
                        x: mine.x,
                        y: mine.y,
                        vx: Math.cos(angle) * bulletSpeed,
                        vy: Math.sin(angle) * bulletSpeed,
                        r: 3,
                        col: '#ff9966',
                        dmg: 20 * p.dmgMult,
                        pierce: false,
                        life: 0.28
                    });
                }

                const numFlames = 15;
                for (let i = 0; i < numFlames; i++) {
                    const angle = (Math.random() - 0.5) * 120 * Math.PI / 180;
                    const speed = 250 + Math.random() * 50;
                    spawnBullet({
                        x: mine.x,
                        y: mine.y,
                        vx: Math.sin(angle) * speed,
                        vy: -Math.cos(angle) * speed,
                        r: 3 + Math.random() * 2,
                        col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`,
                        dmg: 2 * p.dmgMult,
                        life: 0.3,
                        isFlame: true
                    });
                }

                store.activeEffects.push(createEffect("grenadeExplosion", mine.x, mine.y, 55));
            }

            function sanitizeGoldValue(value) {
                if (!Number.isFinite(value)) return 0;
                return Math.max(0, Math.round(value));
            }

            function getWorldGold() {
                const world = store.world || (store.world = {});
                world.gold = sanitizeGoldValue(world.gold);
                return world.gold;
            }

            function setWorldGold(value) {
                const world = store.world || (store.world = {});
                world.gold = sanitizeGoldValue(value);
                return world.gold;
            }

            function addWorldGold(delta = 0) {
                const world = store.world || (store.world = {});
                const current = sanitizeGoldValue(world.gold);
                const change = Number.isFinite(delta) ? delta : 0;
                const next = sanitizeGoldValue(current + change);
                world.gold = next;
                return next;
            }

            let shopItemOrder = [...SHOP_DISPLAY_ORDER];

            const AUTO_FORGE_GLOBAL_FALLBACK_KEYS = Object.freeze([
                'luck_boost',
                'nano_save',
                'hp',
                'max_shield',
                'vampirism',
                'crit_chance',
                'speed',
                'dmg'
            ]);
            const AUTO_FORGE_MIN_DECISION_TIME = 2.9;
            const AUTO_FORGE_MAX_DECISION_TIME = 6.1;
            const AUTO_FORGE_REPAIR_WASTE_THRESHOLD = 0.82;

            function scheduleNextAutoForgeDecision(world, extraDelay = 0) {
                if (!world) return;
                const span = Math.max(0, AUTO_FORGE_MAX_DECISION_TIME - AUTO_FORGE_MIN_DECISION_TIME);
                const base = AUTO_FORGE_MIN_DECISION_TIME + (span > 0 ? Math.random() * span : 0);
                world.autoForgeDecisionTimer = base + (extraDelay || 0);
            }

            function getAffordableUpgrades(keys, gold, options = {}) {
                if (!Array.isArray(keys) || keys.length === 0) return [];
                const includeRestricted = !!options.includeRestricted;
                const seen = new Set();
                const results = [];
                for (const key of keys) {
                    if (seen.has(key)) continue;
                    seen.add(key);
                    const upgrade = SHOP_UPGRADES[key];
                    if (!upgrade) continue;
                    if (!includeRestricted && upgrade.autoForgeEligible === false) continue;
                    if (typeof upgrade.isVisible === 'function' && !upgrade.isVisible()) continue;
                    const info = getNextUpgradeCost(key);
                    if (!info || !Number.isFinite(info.cost)) continue;
                    if (info.available && gold >= info.cost) {
                        results.push({ key, info });
                    }
                }
                return results;
            }

            function rankAutoForgeCandidates(candidates, sortMode) {
                if (!Array.isArray(candidates) || candidates.length <= 1) return candidates;
                switch (sortMode) {
                    case 'cost-asc':
                        candidates.sort((a, b) => (a.info.cost ?? Infinity) - (b.info.cost ?? Infinity));
                        break;
                    case 'random':
                        candidates.sort(() => Math.random() - 0.5);
                        break;
                    default:
                        candidates.sort((a, b) => (b.info.cost ?? -Infinity) - (a.info.cost ?? -Infinity));
                        break;
                }
                return candidates;
            }

            function selectAutoForgeCandidate(candidates, pickMode) {
                if (!Array.isArray(candidates) || candidates.length === 0) return null;
                if (pickMode === 'random') {
                    return candidates[Math.floor(Math.random() * candidates.length)];
                }
                return candidates[0];
            }

            function pickMaximallySuboptimalUpgrade(gold) {
                if (!Number.isFinite(gold) || gold <= 0) return null;
                const player = store.player;
                if (!player) return null;

                const profile = getActiveAutoForgeProfile();
                const repairInfo = getNextUpgradeCost('repair');
                if (repairInfo && isFinite(repairInfo.cost) && gold >= repairInfo.cost) {
                    const hpRatio = player.hpMax > 0 ? player.hp / player.hpMax : 1;
                    const repairThreshold = profile && Number.isFinite(profile.repairThreshold)
                        ? profile.repairThreshold
                        : AUTO_FORGE_REPAIR_WASTE_THRESHOLD;
                    const repairCoinFlip = profile && Number.isFinite(profile.repairCoinFlip)
                        ? profile.repairCoinFlip
                        : 0.5;
                    if (hpRatio <= 0.35) {
                        return { key: 'repair', info: repairInfo, isFun: false, reason: 'criticalRepair' };
                    }
                    if (hpRatio >= repairThreshold || (hpRatio > 0.4 && Math.random() < repairCoinFlip)) {
                        return { key: 'repair', info: repairInfo, isFun: false, reason: 'doctrineRepair' };
                    }
                }

                const groups = profile?.groups || [];
                for (const group of groups) {
                    const candidates = getAffordableUpgrades(group.keys, gold, { includeRestricted: !!group.includeRestricted });
                    if (!candidates.length) continue;
                    rankAutoForgeCandidates(candidates, group.sort);
                    const chosen = selectAutoForgeCandidate(candidates, group.pick);
                    if (chosen) {
                        return {
                            key: chosen.key,
                            info: chosen.info,
                            isFun: !!group.isFun,
                            reason: `${profile?.id || 'profile'}:${group.reason || 'priority'}`
                        };
                    }
                }

                const fallbackKeys = profile?.fallback && profile.fallback.length
                    ? profile.fallback
                    : AUTO_FORGE_GLOBAL_FALLBACK_KEYS;
                const fallbackCandidates = getAffordableUpgrades(fallbackKeys, gold);
                if (fallbackCandidates.length) {
                    rankAutoForgeCandidates(fallbackCandidates, 'cost-desc');
                    const fallbackPick = fallbackCandidates[0];
                    if (fallbackPick) {
                        return {
                            key: fallbackPick.key,
                            info: fallbackPick.info,
                            isFun: false,
                            reason: `${profile?.id || 'profile'}:fallback`
                        };
                    }
                }

                const everything = getAffordableUpgrades(Object.keys(SHOP_UPGRADES), gold);
                if (everything.length) {
                    rankAutoForgeCandidates(everything, 'cost-desc');
                    const desperatePick = selectAutoForgeCandidate(everything, 'random');
                    if (desperatePick) {
                        return {
                            key: desperatePick.key,
                            info: desperatePick.info,
                            isFun: false,
                            reason: 'lastResort'
                        };
                    }
                }

                return null;
            }

            function getNextUpgradeCost(key) {
                const upgrade = SHOP_UPGRADES[key];
                if (!upgrade) return { cost: Infinity, available: false };
                const world = store.world || (store.world = {});
                const availableGold = getWorldGold();
                const player = store.player || {};

                if (typeof upgrade.getCost === 'function') {
                    const raw = upgrade.getCost();
                    if (!raw) {
                        return { cost: Infinity, available: false, premium: !!upgrade.isPremium };
                    }
                    const cost = Number.isFinite(raw.cost) ? raw.cost : Infinity;
                    const available = raw.available !== undefined ? !!raw.available : (Number.isFinite(cost) && availableGold >= cost);
                    return {
                        cost,
                        available,
                        premium: !!upgrade.isPremium,
                        detail: raw.detail,
                        meta: raw,
                        reason: raw.reason,
                        level: raw.level
                    };
                }
                if (upgrade.isPremium) {
                    if (key === 'repair') {
                        if (!player.hpMax || player.hp >= player.hpMax) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Health is already full.' };
                        }
                        return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                    }
                    if (key === 'vampirism') {
                        const currentLevel = player.vampirismLevel || 0;
                        if (currentLevel >= upgrade.max) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Max level reached.' };
                        }
                        const cost = 12 + (currentLevel * 5);
                        return { cost, available: availableGold >= cost, premium: true, level: currentLevel };
                    }
                    if (key === 'nano_save') {
                        if (player.nanoSaves >= upgrade.max) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Max charges reached.' };
                        }
                        return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                    }
                    if (key === 'grenade') {
                        if (player.grenades >= upgrade.max) {
                            return { cost: Infinity, available: false, premium: true, reason: 'At maximum capacity.' };
                        }
                        return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                    }
                    if (upgrade.isUnlock) {
                        const alreadyUnlocked =
                            (key === 'gravity_well' && player.hasVoidBeam) ||
                            (key === 'lazarus_beam' && player.hasLazarusBeam) ||
                            (key === 'launcher' && player.hasLauncher) ||
                            (key === 'luck_boost' && player.luckBoost > 0) ||
                            (key === 'magnet_pull' && player.magnetRadius > 0) ||
                            (key === 'rear_guard' && player.hasRearGuard);
                        if (alreadyUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Already unlocked.' };
                        }
                    }
                    
                    // Handle premium items with level-based costs (iceman, ghost_hounds, etc.)
                    if (upgrade.baseCost && upgrade.scale && upgrade.maxLevel) {
                        const currentLevel = (player.upgradeLevels && player.upgradeLevels[key]) || 0;
                        if (currentLevel >= upgrade.maxLevel) {
                            return { cost: Infinity, available: false, premium: true, level: currentLevel, reason: 'Max level reached.' };
                        }
                        const cost = upgrade.increment
                            ? upgrade.baseCost + (currentLevel * upgrade.increment)
                            : Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                        return { cost, available: availableGold >= cost, premium: true, level: currentLevel };
                    }
                    
                    return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                } else {
                    const currentLevel = (player.upgradeLevels && player.upgradeLevels[key]) || 0;
                    if (upgrade.maxLevel && currentLevel >= upgrade.maxLevel) {
                        return { cost: Infinity, available: false, level: currentLevel, reason: 'Max level reached.' };
                    }
                    const cost = upgrade.increment
                        ? upgrade.baseCost + (currentLevel * upgrade.increment)
                        : Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                    return { cost, available: availableGold >= cost, level: currentLevel };
                }
            }

            function attemptPurchaseUpgrade(key, options = {}) {
                const upgrade = SHOP_UPGRADES[key];
                if (!upgrade) return { success: false, cost: 0, key };

                let cost = 0;
                let success = false;

                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const info = getNextUpgradeCost(key);
                        if (isFinite(info.cost) && getWorldGold() >= info.cost) {
                            const prevGold = getWorldGold();
                            success = upgrade.apply();
                            if (success) {
                                const currentGold = getWorldGold();
                                cost = Math.max(0, prevGold - currentGold);
                            }
                        }
                    } else if (upgrade.baseCost && upgrade.scale && upgrade.maxLevel && upgrade.effect) {
                        // Handle leveled premium items (iceman, ghost_hounds, lazarus_beam, etc.)
                        const info = getNextUpgradeCost(key);
                        const isFree = options.free === true;
                        const canAfford = isFree || (info && info.available && Number.isFinite(info.cost) && getWorldGold() >= info.cost);
                        
                        if (canAfford) {
                            const currentLevel = (store.player.upgradeLevels && store.player.upgradeLevels[key]) || 0;
                            if (!isFree) {
                                addWorldGold(-info.cost);
                                cost = info.cost;
                            }
                            upgrade.effect(currentLevel);
                            if (!store.player.upgradeLevels) store.player.upgradeLevels = {};
                            store.player.upgradeLevels[key] = currentLevel + 1;
                            success = true;
                        }
                    } else {
                        const info = getNextUpgradeCost(key);
                        const isFree = options.free === true;
                        const canAfford = isFree || (info && info.available && Number.isFinite(info.cost) && getWorldGold() >= info.cost);
                        
                        if (canAfford) {
                            if (!isFree) {
                                addWorldGold(-info.cost);
                                cost = info.cost;
                            }
                            success = upgrade.apply(info);
                            if (!success && !isFree) {
                                addWorldGold(info.cost);
                                cost = 0;
                            }
                        }
                    }
                } else {
                    const info = getNextUpgradeCost(key);
                    const isFree = options.free === true;
                    const canAfford = isFree || (isFinite(info.cost) && getWorldGold() >= info.cost);
                    
                    if (canAfford) {
                        const currentLevel = store.player.upgradeLevels[key] || 0;
                        if (!isFree) {
                            addWorldGold(-info.cost);
                            cost = info.cost;
                        }
                        upgrade.effect(currentLevel);
                        store.player.upgradeLevels[key] = currentLevel + 1;
                        success = true;
                    }
                }

                if (success) {
                    if (!shopItemOrder.includes(key)) {
                        shopItemOrder.push(key);
                    }
                    store.world.totalForgeSpend = (store.world.totalForgeSpend || 0) + cost;
                    if (!options.silent) {
                        requestAnimationFrame(() => showShop());
                    }
                    if (typeof options.onSuccess === 'function') {
                        options.onSuccess({ key, upgrade, cost });
                    }
                }

                // Refresh champion dressing room if open and upgrade affects champion
                if (success && (key.includes('champion') || key === 'champion_health' || key === 'champion_damage' || key === 'champion_speed' || key === 'champion_shield' || key === 'champion_regen')) {
                    refreshPrimordialSoldierLaboratory();
                }

                return { success, cost, key, name: upgrade ? upgrade.name : key };
            }

            function setShopTutorialEnabled(enabled) {
                const normalized = !!enabled;
                store.settings.showShopTutorial = normalized;
                if (normalized) {
                    store.world.shopSpotlightDismissed = false;
                } else {
                    dismissShopSpotlight();
                }
                try {
                    if (window.localStorage) {
                        window.localStorage.setItem('voidShopTutorial', normalized ? 'on' : 'off');
                    }
                } catch (err) { }

                const toggle = q('shopTutorialToggle');
                if (toggle && toggle.checked !== normalized) {
                    toggle.checked = normalized;
                }

                const checkbox = q('shopTutorialDontShow');
                if (checkbox) {
                    checkbox.checked = !normalized;
                }
            }

            function showShopSpotlight(message, options = {}) {
                if (!store.settings.showShopTutorial && !options.force) return;
                if (store.world.shopSpotlightDismissed && !options.force) return;
                const container = q('shopSpotlight');
                const messageEl = q('shopSpotlightMessage');
                if (!container || !messageEl) return;

                if (message) {
                    store.ui.shopSpotlightMessage = message;
                }
                if (store.ui.shopSpotlightMessage) {
                    messageEl.textContent = store.ui.shopSpotlightMessage;
                }

                container.classList.remove('hide');
                store.ui.shopSpotlightActive = true;
                if (options.flashButton) {
                    const btn = q('shopBtn');
                    if (btn) {
                        btn.classList.add('mech-forge-pulse');
                    }
                }
            }

            function hideShopSpotlight() {
                const container = q('shopSpotlight');
                if (container) {
                    container.classList.add('hide');
                }
                store.ui.shopSpotlightActive = false;
            }

            function dismissShopSpotlight() {
                store.world.shopSpotlightDismissed = true;
                hideShopSpotlight();
            }

            function showShopTutorial(force = false, message) {
                if (!force) {
                    if (!store.settings.showShopTutorial) return;
                    if (store.world.shopTutorialShown) return;
                }
                const panel = q('shopTutorialPanel');
                if (!panel) return;
                pauseGame();
                panel.classList.remove('hide');
                const checkbox = q('shopTutorialDontShow');
                if (checkbox) {
                    checkbox.checked = !store.settings.showShopTutorial;
                }
                if (message) {
                    store.ui.shopSpotlightMessage = message;
                }
                store.world.shopTutorialShown = true;
            }

            function renderShopPowerupView(container) {
                if (!container) return;
                const player = store.player;
                if (!player) {
                    container.innerHTML = '<div class="shop-empty">Pilot telemetry unavailable.</div>';
                    return;
                }

                const timedEntries = Object.entries(player.powerupTimers || {}).filter(([key, timer]) => {
                    const type = POWERUP_TYPES[key];
                    if (!type || type.type !== 'timed') return false;
                    if (!timer) return false;
                    const remaining = Number(timer.remaining ?? 0);
                    return Number.isFinite(remaining) && remaining > 0.05;
                });

                const timedCards = timedEntries.map(([key, timer]) => {
                    const type = POWERUP_TYPES[key];
                    const remaining = Math.max(0, Number(timer.remaining ?? 0));
                    const maxRaw = Number(timer.max ?? timer.duration ?? remaining);
                    const max = Number.isFinite(maxRaw) && maxRaw > 0 ? maxRaw : Math.max(remaining, 1);
                    const pct = max > 0 ? clamp(Math.round((remaining / max) * 100), 0, 100) : 0;
                    return `<div class="shop-power-card">
    <div class="shop-power-card-title">${type.icon} ${type.name}</div>
    <div class="shop-power-card-meta">${Math.ceil(remaining)}s remaining</div>
    <div class="shop-power-bar"><span style="width:${pct}%;"></span></div>
</div>`;
                });

                const timedSection = timedCards.length
                    ? `<div class="shop-powerup-grid">${timedCards.join('')}</div>`
                    : '<div class="shop-empty-subtle">No timed powerups are currently active.</div>';

                const reserves = [];
                if (player.grenades > 0) reserves.push(`<li><strong>Shield Pulses</strong> â€¢ Charges: ${player.grenades}</li>`);
                if (player.nanoSaves > 0) reserves.push(`<li><strong>Nano Saves</strong> â€¢ Emergency rewinds: ${player.nanoSaves}</li>`);
                if (player.hasLauncher) reserves.push('<li><strong>Fragment Launcher</strong> â€¢ Passive ordnance online</li>');
                if (player.hasHounds) reserves.push('<li><strong>Ghost Hounds</strong> â€¢ Spectral escorts deployed</li>');
                if (player.hasStormbringer) reserves.push('<li><strong>Stormbringer Arsenal</strong> â€¢ Storm grid discharges ready</li>');
                if (player.hasPhasestriker) reserves.push('<li><strong>Phasestriker Arsenal</strong> â€¢ Blink strikes primed</li>');
                if (player.missileVolley > 0) reserves.push(`<li><strong>Missile Salvos</strong> â€¢ Stored volleys: ${player.missileVolley}</li>`);
                if ((store.world?.collarStacks || 0) > 0) reserves.push(`<li><strong>Collar Charges</strong> â€¢ Stacks: ${store.world.collarStacks}</li>`);

                const reserveSection = reserves.length
                    ? `<ul class="shop-powerup-list">${reserves.join('')}</ul>`
                    : '<div class="shop-empty-subtle">No reserve systems stocked. Acquire upgrades to expand your arsenal.</div>';

                container.innerHTML = `
                    <div class="shop-power-section">
                        <h4>Active Powerups</h4>
                        <p>Monitor timed combat boosts currently affecting your fighter.</p>
                        ${timedSection}
                    </div>
                    <div class="shop-power-section">
                        <h4>Support Inventory</h4>
                        <p>Review reserve systems, charges, and passive modules standing by.</p>
                        ${reserveSection}
                    </div>
                `;
            }

            function closeShopTutorial({ dismiss = false, openShop = false } = {}) {
                const panel = q('shopTutorialPanel');
                if (panel) {
                    panel.classList.add('hide');
                }
                if (dismiss) {
                    setShopTutorialEnabled(false);
                } else if (store.settings.showShopTutorial) {
                    showShopSpotlight(store.ui.shopSpotlightMessage, { flashButton: true });
                }
                if (openShop) {
                    showShop();
                } else if (typeof isAnyPanelOpen === 'function') {
                    if (!isAnyPanelOpen()) {
                        resumeGame();
                    }
                } else {
                    resumeGame();
                }
            }

            function flashForgeButton(duration = 1200) {
                const mechForgeBtn = q('shopBtn');
                if (!mechForgeBtn) return;
                mechForgeBtn.classList.add('mech-forge-pulse');
                if (mechForgeBtn._forgePulseTimeout) {
                    clearTimeout(mechForgeBtn._forgePulseTimeout);
                }
                const timeoutId = setTimeout(() => {
                    mechForgeBtn.classList.remove('mech-forge-pulse');
                    mechForgeBtn._forgePulseTimeout = null;
                    store.world.mechForgePulseTimeout = null;
                }, duration);
                mechForgeBtn._forgePulseTimeout = timeoutId;
                store.world.mechForgePulseTimeout = timeoutId;

                const hudBtn = q('shopBtnHUD');
                if (hudBtn) {
                    hudBtn.classList.add('mech-forge-pulse');
                    if (hudBtn._forgePulseTimeout) {
                        clearTimeout(hudBtn._forgePulseTimeout);
                    }
                    const hudTimeout = setTimeout(() => {
                        hudBtn.classList.remove('mech-forge-pulse');
                        hudBtn._forgePulseTimeout = null;
                    }, duration);
                    hudBtn._forgePulseTimeout = hudTimeout;
                }

                showShopSpotlight(null, { flashButton: false });
            }

            function computeNextForgePromptInterval(currentInterval, promptCount) {
                const base = currentInterval || 250;
                const multiplier = 1.18 + Math.min(promptCount, 5) * 0.12;
                const scaled = Math.round(base * multiplier);
                return Math.max(250, Math.min(scaled, 2200));
            }

            function runAutoForge(dt) {
                const world = store.world;
                if (!world) return;

                world.autoForgeAnnounceCooldown = Math.max(0, (world.autoForgeAnnounceCooldown || 0) - dt);

                if (!world.autoForgeEnabled || store.isPaused || store.isGameOver) {
                    return;
                }

                const shopPanel = q('shopPanel');
                if (shopPanel && !shopPanel.classList.contains('hide')) return;
                if (typeof isAnyPanelOpen === 'function' && isAnyPanelOpen()) return;

                if (!store.player || store.player.hp <= 0) return;

                if (typeof world.autoForgeDecisionTimer !== 'number' || Number.isNaN(world.autoForgeDecisionTimer)) {
                    scheduleNextAutoForgeDecision(world);
                } else {
                    world.autoForgeDecisionTimer = Math.max(0, world.autoForgeDecisionTimer - dt);
                }

                if (world.autoForgeDecisionTimer > 0) {
                    return;
                }

                const gold = getWorldGold();
                if (!Number.isFinite(gold) || gold <= 0) {
                    scheduleNextAutoForgeDecision(world, 1.25);
                    return;
                }

                const decision = pickMaximallySuboptimalUpgrade(gold);
                if (!decision) {
                    scheduleNextAutoForgeDecision(world, 1.4);
                    return;
                }

                const purchases = [];
                const result = attemptPurchaseUpgrade(decision.key, { silent: true });
                if (result.success) {
                    result.isFun = !!decision.isFun;
                    result.reason = decision.reason;
                    purchases.push(result);
                }

                const hadPurchase = purchases.length > 0;
                const extraDelay = hadPurchase ? (purchases.some(p => p.isFun) ? 3.6 : 2.45) : 1.35;
                scheduleNextAutoForgeDecision(world, extraDelay);

                if (!hadPurchase) {
                    return;
                }

                const activeProfile = typeof getActiveAutoForgeProfile === 'function' ? getActiveAutoForgeProfile() : null;
                const doctrineName = activeProfile ? `${activeProfile.label} doctrine` : 'Auto-buy doctrine';

                if (!store.world.autoForgeTutorialShown) {
                    store.world.autoForgeTutorialShown = true;
                    announce(`Auto-buy online. ${activeProfile ? `${activeProfile.label} doctrine is now overseeing requisitions.` : 'Hangar logistics will monitor your loadout.'}`);
                } else if ((store.world.autoForgeAnnounceCooldown || 0) <= 0) {
                    const names = purchases.map(p => p.name).join(', ');
                    if (purchases.length === 1 && purchases[0].key === 'repair') {
                        announce(`${doctrineName} rerouted credits toward emergency repairs.`);
                    } else if (purchases.some(p => p.isFun)) {
                        announce(`${doctrineName} queued experimental modules: ${names}.`);
                    } else {
                        announce(`${doctrineName} acquired: ${names}.`);
                    }
                    store.world.autoForgeAnnounceCooldown = purchases.some(p => p.isFun) ? 5.5 : 4.2;
                }

                flashForgeButton(1100 + (purchases.some(p => p.isFun) ? 450 : 0));
            }

            function showShop(defaultView = 'upgrades') {
                pauseGame();
                const panel = q("shopPanel"),
                    grid = q("shopGrid"),
                    goldEl = q("shopgold"),
                    autoStatusEl = q('autoForgeStatusLabel'),
                    powerupView = q('shopPowerupView'),
                    upgradeView = q('shopUpgradeView'),
                    powerupTab = q('shopTabPowerups'),
                    upgradeTab = q('shopTabUpgrades'),
                    mobileToggle = q('shopMobileToggle'),
                    autoToggle = q('shopAutoToggle'),
                    gameMenuBtn = q('shopGameMenuBtn');

                const mechMenu = q('mechForgeMenuPanel');
                if (mechMenu) {
                    mechMenu.classList.add('hide');
                }

                goldEl.textContent = getWorldGold();
                if (autoStatusEl) {
                    autoStatusEl.textContent = getAutoForgeStatusText();
                }



                hideShopSpotlight();

                if (mobileToggle) {
                    mobileToggle.checked = document.body.classList.contains('mobile-controls-active');
                    mobileToggle.onchange = () => {
                        const enabled = !!mobileToggle.checked;
                        if (enabled) {
                            document.body.classList.add('mobile-controls-active');
                        } else {
                            document.body.classList.remove('mobile-controls-active');
                        }
                        try {
                            if (window.localStorage) {
                                window.localStorage.setItem('mobileControlsEnabled', enabled ? 'true' : 'false');
                            }
                        } catch (err) { }
                    };
                }

                if (autoToggle) {
                    autoToggle.checked = !!store.world.autoForgeEnabled;
                    autoToggle.onchange = () => {
                        const enabled = !!autoToggle.checked;
                        store.world.autoForgeEnabled = enabled;
                        store.world.autoForgeAnnounceCooldown = 0;
                        if (enabled) {
                            scheduleNextAutoForgeDecision(store.world, 0.75);
                        } else {
                            store.world.autoForgeDecisionTimer = null;
                        }
                        try {
                            if (window.localStorage) {
                                window.localStorage.setItem('voidAutoForge', enabled ? 'on' : 'off');
                            }
                        } catch (err) { }
                        const profile = getActiveAutoForgeProfile();
                        const statusMessage = enabled
                            ? `Auto-buy enabled. ${profile ? `${profile.label} doctrine engaged.` : 'Hangar logistics will handle repairs and resupply.'}`
                            : 'Auto-buy disabled. Route purchases through the Upgrade Hangar manually.';
                        if (typeof announce === 'function') {
                            announce(statusMessage);
                        }
                        updateAutoForgeStatusLabel();
                        updateAutoForgeProfileButtons();
                    };
                }

                if (gameMenuBtn) {
                    gameMenuBtn.onclick = () => {
                        panel.classList.add('hide');
                        showMechForgeMenu();
                    };
                }

                renderShopPowerupView(powerupView);

                const activateView = (view) => {
                    if (powerupView) powerupView.classList.toggle('hide', view !== 'powerups');
                    if (upgradeView) upgradeView.classList.toggle('hide', view !== 'upgrades');
                    if (powerupTab) powerupTab.classList.toggle('active', view === 'powerups');
                    if (upgradeTab) upgradeTab.classList.toggle('active', view === 'upgrades');
                    if (panel) panel.dataset.shopView = view;
                };

                if (powerupTab) powerupTab.onclick = () => activateView('powerups');
                if (upgradeTab) upgradeTab.onclick = () => activateView('upgrades');

                const normalizedView = defaultView === 'powerups' ? 'powerups' : 'upgrades';
                activateView(normalizedView);

                const rawItems = Object.keys(SHOP_UPGRADES)
                    .map(key => {
                        const upgrade = SHOP_UPGRADES[key];
                        if (!upgrade) return null;
                        if (typeof upgrade.isVisible === 'function' && !upgrade.isVisible()) return null;
                        return { key, upgrade };
                    })
                    .filter(Boolean);

                const currentItems = rawItems.map(item => ({ ...item, info: getNextUpgradeCost(item.key) }));

                const currentKeys = new Set(currentItems.map(item => item.key));
                shopItemOrder = shopItemOrder.filter(key => currentKeys.has(key));
                for (const predefinedKey of SHOP_DISPLAY_ORDER) {
                    if (currentKeys.has(predefinedKey) && !shopItemOrder.includes(predefinedKey)) {
                        shopItemOrder.push(predefinedKey);
                    }
                }
                currentItems.forEach(item => {
                    if (!shopItemOrder.includes(item.key)) {
                        shopItemOrder.push(item.key);
                    }
                });

                const shopItems = shopItemOrder
                    .map(key => currentItems.find(item => item && item.key === key))
                    .filter(Boolean);

                const buildCard = (entry) => {
                    const { key, upgrade, info } = entry;
                    const category = upgrade.category || 'utility';
                    const icon = upgrade.icon ?? 'ðŸ’ ';
                    const level = (store.player?.upgradeLevels && store.player.upgradeLevels[key]) || 0;
                    const name = typeof upgrade.getName === 'function' ? upgrade.getName(info, level) : upgrade.name;
                    let desc = typeof upgrade.desc === 'function' ? upgrade.desc(level, info) : upgrade.desc;
                    const costValue = info && Number.isFinite(info.cost) ? info.cost : upgrade.cost;
                    const costText = Number.isFinite(costValue) ? costValue : '---';
                    const available = info ? !!info.available : (Number.isFinite(costValue) && (store.world?.gold ?? 0) >= costValue);
                    const isDisabled = !available;
                    if (isDisabled && info && info.reason) {
                        desc = info.reason;
                    }
                    return `<div class="skill-card shop-item ${isDisabled ? 'disabled' : ''} shop-item-${category}" data-key="${key}">
                <div class="skill-icon">${icon}</div>
                <div>
                    <div class="skill-title">${name || ''}</div>
                    <div class="skill-desc">${desc || ''}</div>
                </div>
                <div class="shop-item-cost">Cost: ${costText}</div>
            </div>`;
                };

                const playerCards = [];

                for (const entry of shopItems) {
                    if (entry.upgrade?.category === 'champion') {
                        // Champion upgrades moved to Primordial Soldier Laboratory
                        continue;
                    } else {
                        playerCards.push(buildCard(entry));
                    }
                }

                const renderSection = (title, subtitle, cards, extraClass = '') => {
                    if (!cards.length) return '';
                    const headerSubtitle = subtitle ? `<p class="shop-section-subtitle">${subtitle}</p>` : '';
                    return `<div class="shop-section ${extraClass}">
                <div class="shop-section-header">
                    <h3 class="shop-section-title">${title}</h3>
                    ${headerSubtitle}
                </div>
                <div class="shop-section-grid">${cards.join('')}</div>
            </div>`;
                };

                const sections = [];
                sections.push(renderSection('Pilot Systems', 'Enhance your fighter and core modules.', playerCards));
                // Champion Arsenal section removed - moved to Primordial Soldier Laboratory

                if (sections.filter(Boolean).length === 0) {
                    grid.innerHTML = '<div class="shop-empty">No upgrades available right now.</div>';
                } else {
                    grid.innerHTML = sections.filter(Boolean).join('');
                }
                grid.querySelectorAll(".shop-item").forEach(item => {
                    item.addEventListener("click", () => {
                        if (item.classList.contains('disabled')) return;
                        const key = item.dataset.key;
                        attemptPurchaseUpgrade(key);
                    })
                });

                panel.classList.remove("hide");
                enterPanel('shopPanel');
            }

            function showMechForgeMenu() {
                pauseGame();
                const panel = q("mechForgeMenuPanel");

                const tutorialToggle = q('shopTutorialToggle');
                if (tutorialToggle) {
                    tutorialToggle.checked = !!store.settings.showShopTutorial;
                    tutorialToggle.onchange = () => {
                        const enabled = !!tutorialToggle.checked;
                        setShopTutorialEnabled(enabled);
                        if (enabled) {
                            showShopSpotlight('Upgrade Hangar alerts reactivated.', { flashButton: true, force: true });
                        }
                    };
                }

                ensureAutoForgeProfileGrid();
                updateAutoForgeProfileButtons();

                // Enable/disable skill tree button based on subclass
                const skillTreeBtn = q('openSkillTreeReadonly');
                if (skillTreeBtn) {
                    const hasSubclass = store.player && store.player.subclass;
                    skillTreeBtn.disabled = !hasSubclass;
                    if (!hasSubclass) {
                        skillTreeBtn.querySelector('.forge-menu-desc').textContent = 'Select a specialization first';
                    } else {
                        skillTreeBtn.querySelector('.forge-menu-desc').textContent = 'Review specialization progress';
                    }
                }

                updateChampionQuickStatus();

                const player = store.player;
                const isChampionUnlocked = player && player.championUnlocked;

                const labMenuBtn = q('openPrimordialLabFromMenu');
                if (labMenuBtn) {
                    labMenuBtn.disabled = !isChampionUnlocked;
                    labMenuBtn.setAttribute('aria-disabled', isChampionUnlocked ? 'false' : 'true');
                }

                // Show/hide champion preview button based on champion unlock status
                const championPreviewBtn = q('openChampionDressingRoom');
                if (championPreviewBtn) {
                    if (isChampionUnlocked) {
                        championPreviewBtn.classList.remove('hide');
                    } else {
                        championPreviewBtn.classList.add('hide');
                    }
                }

                panel.classList.remove("hide");
                enterPanel('mechForgeMenuPanel');
            }

            function showCharacterSheet() {
                pauseGame();
                const panel = q("characterSheetPanel");
                const body = q("characterSheetBody");

                if (body) {
                    renderCharacterSheet(body);
                }

                panel.classList.remove("hide");
                enterPanel('characterSheetPanel');
            }

            function showSkillTreeReadonly() {
                if (!store.player || !store.player.subclass) {
                    announce('Select a specialization first!');
                    return;
                }

                // Use the existing skill tree modal system but mark it as read-only from forge
                showSkillTreeModal(true);

                // Update the title to indicate it's read-only after the modal opens
                setTimeout(() => {
                    const panel = q("subclassPanel");
                    if (panel) {
                        const title = panel.querySelector('h2');
                        if (title) {
                            title.textContent = `â­ ${store.player.subclass.toUpperCase()} SKILL TREE (VIEW-ONLY)`;
                        }
                        // Disable all skill buttons to make it truly read-only
                        const skillButtons = panel.querySelectorAll('.skill-icon-button, .skill-card');
                        skillButtons.forEach(btn => {
                            btn.style.pointerEvents = 'none';
                            btn.style.opacity = '0.8';
                        });
                    }
                }, 50);
            }

            function renderCharacterSheet(container) {
                if (!container) {
                    return;
                }

                const player = store.player || {};
                const world = store.world || {};
                const gold = getWorldGold();

                const toNumber = (value, fallback = 0) => {
                    const num = Number(value);
                    return Number.isFinite(num) ? num : fallback;
                };

                const fmt = (value, digits = 2) => {
                    const num = toNumber(value);
                    return num.toFixed(digits);
                };

                const pct = (value, digits = 1) => {
                    const num = toNumber(value);
                    return (num * 100).toFixed(digits) + '%';
                };

                const escapeHtml = (value) => {
                    if (value === undefined || value === null) return '';
                    return String(value)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                };

                const getSkillTreeContext = () => {
                    if (typeof getActiveSubclassAndTree !== 'function') {
                        return { subclass: player.subclass || null, treeData: null };
                    }
                    const { subclass, treeData } = getActiveSubclassAndTree();
                    return { subclass, treeData };
                };

                const { subclass, treeData } = getSkillTreeContext();
                const genomeName = player.pilotGenome ? player.pilotGenome.toUpperCase() : 'PENDING';

                // Only show subclass if actually selected, not just from tree data
                const actualSubclass = player.subclass;
                let subclassDisplay;
                if (actualSubclass && treeData && treeData.title) {
                    subclassDisplay = treeData.title.replace(' MASTERY TREE', '').toUpperCase();
                } else if (actualSubclass) {
                    subclassDisplay = actualSubclass.toUpperCase();
                } else {
                    subclassDisplay = 'PENDING SELECTION';
                }

                const summaryLines = [
                    `GENOME ROUTE â–¸ ${genomeName} âžœ ${subclassDisplay}${player.hasOmegaMultishot ? ' â­ OMEGA' : ''}`,
                    `MISSION STATUS â–¸ W${pad(world.wave || 1)} | LV ${pad(world.level || 1)} | BOSSES ${pad(world.bosses || 0)} | KILLS ${pad(world.kills || 0, 3)}`,
                    `FORGE LEDGER â–¸ GOLD ${pad(gold, 4)} | XP ${pad(world.xp || 0, 4)} | SCORE ${pad(world.score || 0, 6)}`,
                    `PROGRESSION â–¸ TOTAL ${pad(player.totalProgressionPoints || 0)} | SPENT ${pad(player.skillPointsSpent || 0)} | UNSPENT ${pad(player.unspentProgressionPoints || 0)}`
                ];

                // Only show skill matrix if subclass is actually selected
                const skillMatrixData = actualSubclass ? computeSkillMatrix(treeData, player, subclassDisplay) : null;
                if (skillMatrixData && skillMatrixData.laneSummaries.length) {
                    skillMatrixData.laneSummaries.forEach(line => summaryLines.push(line));
                }

                const sections = [];
                sections.push(renderSummarySection(summaryLines));

                const coreRows = [
                    {
                        key: 'Hull Integrity',
                        value: `${pad(toNumber(player.hp || 0), 3)}/${pad(toNumber(player.hpMax || player.hp || 0), 3)}`,
                        detail: player.damageReduction ? `Damage Reduction ${pct(player.damageReduction)} â€¢ Knockback ${player.knockbackImmunity ? 'Immune' : 'Normal'}` : null
                    },
                    {
                        key: 'Shield Matrix',
                        value: `${pad(toNumber(player.shield || 0), 3)}/${pad(toNumber(player.shieldMax || 0), 3)}`,
                        detail: player.shieldRechargeDelayMax ? `Recharge Delay ${fmt(player.shieldRechargeDelayMax, 2)}s` : null
                    },
                    {
                        key: 'Beef Shield',
                        value: player.beefShieldMax > 0 ? `${pad(Math.floor(player.beefShield || 0), 3)}/${pad(Math.floor(player.beefShieldMax), 3)}` : 'LOCKED',
                        detail: player.beefShieldMax > 0 ? `Regen ${fmt(player.beefShieldRegenRate || 5, 1)}/s â€¢ Cooldown ${fmt(player.beefShieldCooldown || 0, 1)}s` : 'Unlock via Beef class skill tree'
                    },
                    {
                        key: 'Velocity',
                        value: `${pad(toNumber(player.speed || 0), 3)}`,
                        detail: `Magnet ${pad(toNumber(player.magnetRadius || 0), 3)} â€¢ Luck ${pct(player.luckBoost || 0)}`
                    },
                    {
                        key: 'Safety Net',
                        value: `Nano ${pad(player.nanoSaves || 0)} â€¢ Vamp ${pct(player.vampirism || 0)}`,
                        detail: `Shield Pulses ${pad(player.grenades || 0)} â€¢ Collar ${pad(world.collarStacks || 0)}`
                    }
                ];
                sections.push(renderGridSection('Core Systems', coreRows));

                const fireRate = toNumber(player.fireRate || 0);
                const shotsPerSecond = fireRate > 0 ? 1 / fireRate : 0;
                const offenseRows = [
                    {
                        key: 'Damage Suite',
                        value: `x${fmt(player.dmgMult || 1, 2)}`,
                        detail: `Crit ${pct(player.critChance || 0)} | Crit Dmg x${fmt(player.critDamage || 1.5, 2)}`
                    },
                    {
                        key: 'Volley Matrix',
                        value: `${fmt(shotsPerSecond, 1)} /s`,
                        detail: `Projectiles ${pad(player.multishot || 1)} â€¢ Pierce ${pad(player.piercing || player.missilePierce || 0)}${player.hasOmegaMultishot ? ' â€¢ OMEGA MODE' : ''}`
                    },
                    {
                        key: 'Arsenal',
                        value: `Missiles ${pad(player.missileVolley || 0)} â€¢ Shield Pulses ${pad(player.grenades || 0)}`,
                        detail: `Fragment Launcher ${player.hasLauncher ? 'ONLINE' : 'LOCKED'} â€¢ Lazarus ${player.hasLazarusBeam ? 'ONLINE' : 'LOCKED'}`
                    },
                    {
                        key: 'Special Ammo',
                        value: `Storm ${player.hasStormbringer ? 'ONLINE' : 'LOCKED'} â€¢ Phase ${player.hasPhasestriker ? 'ONLINE' : 'LOCKED'}`,
                        detail: player.hasBlink ? `Blink ${player.autoBlinkEnabled ? 'AUTO' : 'MANUAL'}` : 'Blink locked'
                    },
                    {
                        key: 'Special Weapons',
                        value: `Star Cannon ${player.starCannonLevel ? `MK${player.starCannonLevel}` : 'LOCKED'}`,
                        detail: `Gravity Well ${player.hasVoidBeam ? 'ONLINE' : 'LOCKED'} â€¢ Iceman ${player.hasIceman ? 'ACTIVE' : 'LOCKED'}`
                    },
                    {
                        key: 'Beef Class',
                        value: player.beefMaxCharges > 0 ? `Charges ${player.beefCharges || 0}/${player.beefMaxCharges}` : 'N/A',
                        detail: player.beefMaxCharges > 0 ? `Chain Mode ${player.beefChainMode ? 'ON' : 'OFF'} â€¢ Elite Combat ${player.beefEliteCombat ? 'ON' : 'OFF'}` : null
                    },
                    {
                        key: 'Rocketman Class',
                        value: player.missilePierce > 0 || player.missileCluster ? `Pierce ${player.missilePierce || 0} â€¢ Cluster ${player.missileCluster ? 'ON' : 'OFF'}` : 'N/A',
                        detail: player.missileClusterCount ? `Cluster Count ${player.missileClusterCount} â€¢ Radius x${fmt(player.missileClusterRadius || 1, 1)}` : null
                    }
                ];
                sections.push(renderGridSection('Offensive Matrix', offenseRows));

                const economyRows = [
                    {
                        key: 'Resources',
                        value: `Gold ${pad(gold, 4)} â€¢ XP ${pad(world.xp || 0, 4)}`,
                        detail: `Score ${pad(world.score || 0, 6)} â€¢ Threat ${fmt(world.lastThreatScale || 1, 2)}`
                    },
                    {
                        key: 'Boss Progress',
                        value: `Bosses ${pad(world.bosses || 0)} â€¢ Wave ${pad(world.wave || 1)}`,
                        detail: `Kills ${pad(world.kills || 0, 4)} â€¢ XP Mult ${fmt(world.xpMultiplier || 1, 2)}`
                    }
                ];
                sections.push(renderGridSection('Economy & Progress', economyRows));

                const forgeUpgrades = buildForgeUpgradeList(player);
                sections.push(renderListSection('Forge Upgrades', forgeUpgrades, 'No forge upgrades purchased yet.'));

                const systemList = buildSystemList(player);
                sections.push(renderListSection('Active Systems', systemList, 'No special systems online.'));

                if (skillMatrixData) {
                    sections.push(renderSkillMatrixSection(skillMatrixData));
                    if (skillMatrixData.powerSummaries.length) {
                        sections.push(renderListSection('Power Summary', skillMatrixData.powerSummaries));
                    }
                }

                const learnedSkillList = buildLearnedSkillList(player);
                if (learnedSkillList.length) {
                    sections.push(renderListSection('Unlocked Skills', learnedSkillList));
                }

                const calibrationList = buildCalibrationList(player);
                if (calibrationList.length) {
                    sections.push(renderListSection('Calibrations', calibrationList));
                }

                const championSection = renderChampionSection();
                if (championSection) {
                    sections.push(championSection);
                }

                container.innerHTML = sections.join('');

                function renderSummarySection(lines) {
                    if (!lines || !lines.length) return '';
                    return `
                <div class="intel-section">
                    <div class="intel-title">Route Overview</div>
                    <div class="intel-summary">
                        ${lines.map(line => `<div class="intel-summary-line">${escapeHtml(line)}</div>`).join('')}
                    </div>
                </div>`;
                }

                function renderGridSection(title, rows, note) {
                    if (!rows || !rows.length) return '';
                    return `
                <div class="intel-section">
                    <div class="intel-title">${escapeHtml(title)}</div>
                    <div class="intel-grid">
                        ${rows.map(row => `
                            <div class="intel-cell">
                                <div class="intel-key">${escapeHtml(row.key)}</div>
                                <div class="intel-val">${escapeHtml(row.value)}</div>
                                ${row.detail ? `<div class="intel-detail">${escapeHtml(row.detail)}</div>` : ''}
                            </div>`).join('')}
                    </div>
                    ${note ? `<div class="intel-note">${escapeHtml(note)}</div>` : ''}
                </div>`;
                }

                function renderListSection(title, items, emptyText) {
                    if (!items || !items.length) {
                        if (!emptyText) return '';
                        return `
                    <div class="intel-section">
                        <div class="intel-title">${escapeHtml(title)}</div>
                        <div class="intel-note">${escapeHtml(emptyText)}</div>
                    </div>`;
                    }
                    return `
                <div class="intel-section">
                    <div class="intel-title">${escapeHtml(title)}</div>
                    <ul class="intel-list">
                        ${items.map(item => `<li>${escapeHtml(item)}</li>`).join('')}
                    </ul>
                </div>`;
                }

                function buildForgeUpgradeList(p) {
                    if (!p.upgradeLevels) return [];
                    const entries = Object.entries(p.upgradeLevels).filter(([, lvl]) => lvl > 0);
                    if (!entries.length) return [];
                    entries.sort((a, b) => {
                        const upA = SHOP_UPGRADES[a[0]];
                        const upB = SHOP_UPGRADES[b[0]];
                        const catA = upA && upA.category ? upA.category : '';
                        const catB = upB && upB.category ? upB.category : '';
                        if (catA !== catB) return catA.localeCompare(catB);
                        const nameA = upA && upA.name ? upA.name : a[0];
                        const nameB = upB && upB.name ? upB.name : b[0];
                        return nameA.localeCompare(nameB);
                    });
                    return entries.map(([key, lvl]) => {
                        const upg = SHOP_UPGRADES[key];
                        const name = upg && upg.name ? upg.name.toUpperCase() : key.replace(/_/g, ' ').toUpperCase();
                        const category = upg && upg.category ? upg.category.toUpperCase() : 'GENERAL';
                        return `${name} â€¢ L${pad(lvl)} â€¢ ${category}`;
                    });
                }

                function buildSystemList(p) {
                    const systems = [];
                    
                    // Defense Systems
                    if (p.hasRearGuard) {
                        const cooldown = p.rearGuardReady ? 'READY' : `${fmt(p.rearGuardCooldown || 8, 1)}s`;
                        systems.push(`Aft Flank Shield â–¸ ${cooldown} â€¢ REAPER COUNTER`);
                    }
                    if (p.grenades > 0) {
                        systems.push(`Shield Pulse (EMP) â–¸ ${pad(p.grenades)} charges â€¢ REAPER COUNTER`);
                    }
                    if (p.beefShieldMax > 0) {
                        systems.push(`Beef Shield â–¸ ${pad(Math.floor(p.beefShield || 0))}/${pad(Math.floor(p.beefShieldMax))} armor`);
                    }
                    
                    // Offensive Systems
                    if (p.hasVoidBeam) systems.push('Gravity Well â–¸ Singularity generator ready');
                    if (p.hasLazarusBeam) {
                        const level = p.upgradeLevels?.lazarus_beam || 1;
                        systems.push(`Lazarus Beam â–¸ Level ${level} ${level > 1 ? 'dual' : 'single'} beam`);
                    }
                    if (p.hasLauncher) {
                        const level = p.upgradeLevels?.launcher || 1;
                        const projectiles = 2 * level;
                        systems.push(`Fragment Launcher â–¸ ${projectiles} projectiles`);
                    }
                    if (p.hasHounds) {
                        const packSize = Array.isArray(store.hounds) ? store.hounds.filter(h => h && !h.dead).length : 2;
                        systems.push(`Ghost Hounds â–¸ Pack of ${pad(packSize)}`);
                    }
                    if (p.hasIceman) {
                        const level = store.iceman?.level || 1;
                        systems.push(`The Iceman â–¸ Level ${level} mirror support`);
                    }
                    if (p.starCannonLevel) {
                        const support = p.starCannonIcemanSupport ? ' + Iceman sync' : '';
                        systems.push(`Star Cannon â–¸ MK${pad(p.starCannonLevel)}${support}`);
                    }
                    
                    // Mobility & Special
                    if (p.hasBlink) {
                        const mode = p.autoBlinkEnabled ? 'Auto-response' : 'Manual trigger';
                        systems.push(`Blink Teleport â–¸ ${mode} â€¢ Range ${pad(Math.floor(p.blinkRange || 250))}`);
                    }
                    if (p.hasVoidLaser || p.hasPhasestriker) {
                        const level = p.phasestRikerLevel || 0;
                        const range = level >= 1 ? 'Unlimited' : 'Short';
                        systems.push(`Void Laser â–¸ ${range} range â€¢ ${p.doubleBeam ? 'Double beam' : 'Single beam'}`);
                    }
                    if (p.hasChainLightning || p.hasStormbringer) {
                        const level = p.stormstrikerLevel || 1;
                        const bolts = level >= 3 ? '4 bolts' : level >= 2 ? 'Twin bolts' : 'Single bolt';
                        systems.push(`Chain Lightning â–¸ ${bolts} â€¢ Damage x${fmt(p.chainLightningDamage || 1, 1)}`);
                    }
                    if (p.hasBeefClone) {
                        const mode = p.juggernautCloneActive ? 'Bomber' : 'Marauder';
                        systems.push(`Battle Clone â–¸ ${mode} mode active`);
                    }
                    if (p.wiperLasers) {
                        systems.push(`Wiper Lasers â–¸ Sweeping laser array online`);
                    }
                    
                    // Omega Multishot
                    if (p.hasOmegaMultishot && p.omegaMultishotType) {
                        const omegaNames = {
                            'marauder_burst': 'Omega Burst',
                            'juggernaut_hammer': 'Omega Hammer',
                            'railgunner_lance': 'Omega Lance',
                            'demolitioner_nova': 'Omega Nova',
                            'phasestriker_void': 'Omega Void',
                            'stormbringer_storm': 'Omega Storm'
                        };
                        const name = omegaNames[p.omegaMultishotType] || 'Omega Multishot';
                        systems.push(`â­ ${name} â–¸ AOE projectile transformation active`);
                    }
                    
                    // Buffs & Stacks
                    if (p.attackSpeedStacks) systems.push(`Hyper Drive â–¸ ${pad(p.attackSpeedStacks)} stacks active`);
                    if (p.timeShardStacks) systems.push(`Time Shards â–¸ ${pad(p.timeShardStacks)} stacks â€¢ x${fmt(p.timeShardMultiplier || 1, 2)} rate`);
                    
                    return systems;
                }

                function computeSkillMatrix(treeData, p, subclassDisplay) {
                    if (!treeData || !p.subclass) return null; // Don't show matrix without actual subclass selection
                    const result = {
                        rows: [],
                        laneSummaries: [],
                        laneNotes: [],
                        powerSummaries: []
                    };
                    const skillTree = p.skillTree || {};

                    const lanes = [];
                    // Lane 1: Core progression path
                    if (treeData.path && Array.isArray(treeData.path.nodes)) {
                        const lane = {
                            index: 1,
                            name: treeData.path.name || 'Core Path',
                            nodes: []
                        };
                        treeData.path.nodes.forEach((node, idx) => {
                            const unlocked = !!skillTree[node.id];
                            const order = idx + 1;
                            result.rows.push({
                                tier: `T${order}`,
                                lane: 'Lane Î± â€“ Core Path',
                                name: node.name,
                                status: unlocked ? 'ONLINE' : 'LOCKED',
                                desc: node.desc,
                                active: unlocked
                            });
                            lane.nodes.push({
                                order,
                                name: node.name,
                                desc: node.desc,
                                unlocked,
                                statusSymbol: unlocked ? 'âœ”' : 'âœ–'
                            });
                            if (unlocked) {
                                result.powerSummaries.push(`${node.name} â€” ${node.desc}`);
                            }
                        });
                        lanes.push(lane);
                    }

                    // Lane 2: Signature â†’ Crossover â†’ Ultimate progression
                    const succession = [];
                    if (treeData.classAbility) {
                        succession.push({ node: treeData.classAbility, kind: 'Signature' });
                    }
                    const crossDetails = typeof getCrossUnlockNode === 'function' ? getCrossUnlockNode(treeData) : null;
                    if (crossDetails && crossDetails.node) {
                        succession.push({ node: crossDetails.node, kind: 'Crossover', requirement: crossDetails.config && crossDetails.config.requiredInvestments });
                    }
                    if (treeData.ultimateAbility) {
                        succession.push({ node: treeData.ultimateAbility, kind: 'Ultimate' });
                    }

                    if (succession.length) {
                        const lane = {
                            index: 2,
                            name: `${subclassDisplay || 'SIGNATURE'} Abilities`,
                            nodes: []
                        };
                        succession.forEach((entry, idx) => {
                            const id = entry.node.id;
                            const unlocked = !!skillTree[id];
                            const laneLabel = `Lane Î² â€“ ${entry.kind}`;
                            result.rows.push({
                                tier: entry.kind.toUpperCase(),
                                lane: laneLabel,
                                name: entry.node.name,
                                status: unlocked ? 'ONLINE' : 'LOCKED',
                                desc: entry.node.desc,
                                active: unlocked
                            });
                            lane.nodes.push({
                                order: entry.kind, // Use ability type instead of number
                                name: entry.node.name,
                                desc: entry.node.desc,
                                unlocked,
                                statusSymbol: unlocked ? 'âœ”' : 'âœ–',
                                requirement: entry.requirement,
                                kind: entry.kind
                            });
                            if (unlocked) {
                                result.powerSummaries.push(`${entry.node.name} â€” ${entry.node.desc}`);
                            }
                        });
                        lanes.push(lane);
                    }

                    if (!result.rows.length) {
                        return null;
                    }

                    lanes.forEach(lane => {
                        if (lane.index === 1) {
                            // Core path uses numbered nodes
                            const nodeStatus = lane.nodes.map(node => `${node.statusSymbol}${node.order}`);
                            result.laneSummaries.push(`LANE ${lane.index} â–¸ ${lane.name.toUpperCase()} â†’ Nodes ${nodeStatus.join(' ')}`);
                        } else {
                            // Ability path uses ability types
                            const nodeStatus = lane.nodes.map(node => `${node.statusSymbol}${node.kind.substring(0, 3)}`);
                            result.laneSummaries.push(`LANE ${lane.index} â–¸ ${lane.name.toUpperCase()} â†’ ${nodeStatus.join(' ')}`);
                        }

                        result.laneNotes.push(lane.nodes.map(node => {
                            const requirement = node.requirement ? ` (req ${node.requirement})` : '';
                            return `${node.kind || node.order}. ${node.name}${requirement} (${node.unlocked ? 'active' : 'locked'})`;
                        }).join(' | '));
                    });

                    return result;
                }

                function renderSkillMatrixSection(data) {
                    if (!data.rows.length) return '';
                    return `
                <div class="intel-section">
                    <div class="intel-title">Skill Path Matrix</div>
                    <table class="intel-table">
                        <thead>
                            <tr>
                                <th>Tier</th>
                                <th>Lane</th>
                                <th>Node</th>
                                <th>Status</th>
                                <th>Effect</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.rows.map(row => `
                                <tr class="${row.active ? 'active' : 'inactive'}">
                                    <td>${escapeHtml(row.tier)}</td>
                                    <td>${escapeHtml(row.lane)}</td>
                                    <td>${escapeHtml(row.name)}</td>
                                    <td>${escapeHtml(row.status)}</td>
                                    <td>${escapeHtml(row.desc)}</td>
                                </tr>`).join('')}
                        </tbody>
                    </table>
                    ${data.laneNotes.length ? `
                        <div class="intel-subtitle">Lane Breakdown</div>
                        <div class="intel-summary">
                            ${data.laneNotes.map(note => `<div class="intel-summary-line">${escapeHtml(note)}</div>`).join('')}
                        </div>` : ''}
                </div>`;
                }

                function buildLearnedSkillList(p) {
                    if (!Array.isArray(p.learnedSkills) || !p.learnedSkills.length) return [];
                    const unique = Array.from(new Set(p.learnedSkills));
                    return unique.map(id => {
                        const meta = resolveSkillMeta(id);
                        if (meta) {
                            return `${meta.name.toUpperCase()}`;
                        }
                        return id.replace(/_/g, ' ').toUpperCase();
                    });
                }

                function buildCalibrationList(p) {
                    const list = [];
                    if (p.attackSpeedStacks) list.push(`Hyper Drive Stacks â–¸ ${pad(p.attackSpeedStacks)}`);
                    if (p.voidCoreStacks) {
                        list.push(`Void Core Resonance â–¸ ${pad(p.voidCoreStacks)} (Damage x${fmt(p.voidCoreDmgMult || 1, 2)} | Fire ${fmt(p.voidCoreFireRateMult || 1, 2)}x)`);
                    }
                    if (p.stormstrikerLevel) list.push(`Stormbringer Intensity â–¸ L${fmt(p.stormstrikerLevel, 1)}`);
                    if (p.phasestRikerLevel) list.push(`Phase Laser Ramp â–¸ L${fmt(p.phasestRikerLevel, 1)}`);
                    if (p.starCannonLevel) list.push(`Star Cannon Calibration â–¸ MK${pad(p.starCannonLevel)}`);
                    if (p.vampirismLevel) list.push(`Vampiric Augments â–¸ L${pad(p.vampirismLevel)} (${pct(p.vampirism)})`);
                    return list;
                }

                function renderChampionSection() {
                    const champion = store.playerChampion;
                    if (!champion || champion.dead) {
                        return renderListSection('Champion Companion', [], 'Champion offline. Secure sigils to deploy guardian.');
                    }
                    const minions = Array.isArray(store.championMinions) ? store.championMinions.filter(m => m && !m.dead).length : 0;
                    const rows = [
                        { key: 'Level', value: pad(champion.level || 1), detail: `Damage x${fmt(champion.damageScale || 1, 2)}` },
                        { key: 'Volley', value: `${pad(champion.volleySize || 0)} rounds`, detail: `Cooldown ${fmt(champion.fireCooldown || 0, 2)}s` },
                        { key: 'Dash', value: `${fmt(champion.dashCooldown || 0, 2)}s`, detail: `Momentum ${fmt(champion.momentum || 0, 2)}` },
                        { key: 'Minions', value: pad(minions), detail: `Guard Radius ${fmt(champion.guardRadius || 0, 1)}` }
                    ];
                    return renderGridSection('Champion Companion', rows);
                }

                function resolveSkillName(skillId) {
                    const meta = resolveSkillMeta(skillId);
                    if (meta && meta.name) {
                        return meta.name;
                    }
                    return skillId ? skillId.replace(/_/g, ' ') : '';
                }

                function resolveSkillMeta(skillId) {
                    if (!skillId || typeof SKILL_TREE_DATA === 'undefined') return null;
                    for (const key of Object.keys(SKILL_TREE_DATA)) {
                        const tree = SKILL_TREE_DATA[key];
                        if (!tree) continue;
                        if (tree.path && Array.isArray(tree.path.nodes)) {
                            const node = tree.path.nodes.find(n => n.id === skillId);
                            if (node) return node;
                        }
                        if (tree.classAbility && tree.classAbility.id === skillId) return tree.classAbility;
                        if (tree.ultimateAbility && tree.ultimateAbility.id === skillId) return tree.ultimateAbility;
                        const cross = typeof getCrossUnlockNode === 'function' ? getCrossUnlockNode(tree) : null;
                        if (cross && cross.node && cross.node.id === skillId) return cross.node;
                    }
                    return null;
                }
            }

            function showShopWithHighlight() { showShop(); announce('Low integrity! Route to the Upgrade Hangar for repairs.'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }

            function triggerNanoSaveCharge() {
                const p = store.player;
                if (!p || p.nanoSaves <= 0) return false;
                
                // Block death, set life to 10
                p.nanoSaves--;
                p.hp = 10;
                
                // Increase max health
                p.hpMax += 15;
                
                // Trigger heal effect
                store.activeEffects.push(createEffect("nanoHeal"));
                announce('âš¡ NANO CHARGE ACTIVATED! âš¡');
                
                // Open shop
                showShop();
                
                return true;
            }

            function triggerMechForgeGoldMilestone(forceShop = false) {
                const world = store.world;
                if (!world) return;

                world.mechForgePromptActive = true;
                if (!world.mechForgeGoldTriggered || forceShop) {
                    world.mechForgeGoldTriggered = true;
                }

                const promptCount = (world.mechForgePromptCount || 0) + 1;
                world.mechForgePromptCount = promptCount;

                const interval = computeNextForgePromptInterval(world.mechForgePromptInterval, promptCount);
                world.mechForgePromptInterval = interval;
                world.nextMechForgePrompt = getWorldGold() + interval;

                flashForgeButton(promptCount <= 2 ? 10000 : 5000);

                const autoEnabled = !!world.autoForgeEnabled;
                if (store.settings.showShopTutorial && (!world.shopTutorialShown || forceShop)) {
                    showShopTutorial(forceShop, 'Upgrade Hangar unlocked. Allocate your credits.');
                    showShopSpotlight('Upgrade Hangar unlocked. Allocate your credits.', { flashButton: true, force: true });
                } else if (!autoEnabled || forceShop) {
                    announce('Upgrade Hangar unlocked. Deploy your credits.');
                    showShopSpotlight('Upgrade Hangar unlocked. Deploy your credits.', { flashButton: true });
                    if (forceShop) {
                        showShop();
                    }
                } else {
                    const profile = typeof getActiveAutoForgeProfile === 'function' ? getActiveAutoForgeProfile() : null;
                    const doctrineName = profile ? `${profile.label} doctrine` : 'Auto-buy doctrine';
                    announce(`${doctrineName} stocked up. Open the Upgrade Hangar to adjust priorities.`);
                    showShopSpotlight(`${doctrineName} stocked up. Adjust priorities in the Upgrade Hangar.`, { flashButton: false });
                }

                setTimeout(() => {
                    world.mechForgePromptActive = false;
                }, 600);
            }
            function getChampionPrimaryTarget(origin) {
                if (!origin) return null;
                const ox = origin.x ?? store.player.x;
                const oy = origin.y ?? store.player.y;
                let best = null;
                let bestDist = Infinity;
                let bestChampion = null;
                let bestChampionDist = Infinity;

                // Always prioritize boss first
                if (store.boss && !store.boss.dead) {
                    const dx = store.boss.x - ox;
                    const dy = store.boss.y - oy;
                    const dist = dx * dx + dy * dy;
                    if (dist < bestDist) {
                        bestDist = dist;
                        best = store.boss;
                    }
                }

                // Search for enemy champions and regular enemies
                for (let i = 0; i < store.enemies.length; i++) {
                    const enemy = store.enemies[i];
                    if (!enemy || enemy.dead || enemy.hp <= 0) continue;
                    const dx = enemy.x - ox;
                    const dy = enemy.y - oy;
                    const dist = dx * dx + dy * dy;

                    // Check if this is a champion type enemy
                    const isChampion = enemy.type === 'void_champion' || enemy.type === 'shadow_champion';

                    if (isChampion) {
                        // Track the closest champion separately
                        if (dist < bestChampionDist) {
                            bestChampionDist = dist;
                            bestChampion = enemy;
                        }
                    } else {
                        // Regular enemy - only consider if no champions found yet
                        if (dist < bestDist) {
                            bestDist = dist;
                            best = enemy;
                        }
                    }
                }

                // Prioritize champions over regular enemies (unless boss exists)
                if (bestChampion && (!store.boss || store.boss.dead)) {
                    return bestChampion;
                }

                return best;
            }

            function resolveChampionTarget(entity, options = {}) {
                if (!entity) return null;
                const now = performance.now();
                const stickRange = options.stickRange ?? 620;
                const lingerMs = options.lingerMs ?? 260;
                const originX = entity.x ?? store.player?.x ?? 0;
                const originY = entity.y ?? store.player?.y ?? 0;
                const stickRangeSq = stickRange * stickRange;

                const existing = entity.currentTarget;
                if (existing && !existing.dead && existing.hp > 0) {
                    const dx = existing.x - originX;
                    const dy = existing.y - originY;
                    if (dx * dx + dy * dy <= stickRangeSq) {
                        entity.currentTarget = existing;
                        entity._lastTargetSeen = now;
                        return existing;
                    }
                }

                const fresh = getChampionPrimaryTarget(entity);
                if (fresh) {
                    entity.currentTarget = fresh;
                    entity._lastTargetSeen = now;
                    return fresh;
                }

                if (existing && !existing.dead && existing.hp > 0 && entity._lastTargetSeen && (now - entity._lastTargetSeen) < lingerMs) {
                    return existing;
                }

                entity.currentTarget = null;
                return null;
            }

            function championDealDamage(target, damage, options = {}) {
                if (!target || target.dead || damage <= 0) return 0;
                const champion = store.playerChampion;
                const upgradeState = getChampionUpgradeState();
                let finalDamage = damage;

                if (options.vulnerabilityProfile) {
                    finalDamage = applyChampionVulnerabilityScaling(finalDamage, target, options.vulnerabilityProfile);
                }
                if (typeof options.damageMultiplier === 'number') {
                    finalDamage *= options.damageMultiplier;
                }
                if (typeof options.damageBonus === 'number') {
                    finalDamage += options.damageBonus;
                }
                finalDamage = Math.max(0, finalDamage);

                const pseudoBullet = {
                    x: options.x ?? target.x,
                    y: options.y ?? target.y,
                    dmg: finalDamage,
                    pierce: true,
                    explosive: false,
                    isChampionShot: true,
                    skipChampionEffects: !!options.skipChampionEffects,
                    championAttackModule: options.sourceAttackModule ?? (champion?.attackModule || upgradeState.attackModule || 'default'),
                    championLevel: options.championLevel ?? (champion?.level || 1),
                    vulnerabilityProfile: options.vulnerabilityProfile || null,
                    fromChampionMinion: !!options.fromChampionMinion,
                    minionProtocolLevel: options.minionProtocolLevel ?? 0,
                    minionProtocolSlowFactor: options.minionProtocolSlowFactor ?? null,
                    minionProtocolNovaDamageScale: options.minionProtocolNovaDamageScale ?? 0
                };
                handleBulletImpact(pseudoBullet, target);
                return finalDamage;
            }

            function championFireStarfallSalvo(champion, target, context = {}) {
                if (!champion || champion.dead || !target) return null;
                const player = store.player;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const baseAngle = Math.atan2(target.y - champion.y, target.x - champion.x);
                const volley = Math.max(3, champion.volleySize || 4);
                const spread = champion.volleySpread || 0.16;
                const projectileSpeed = 360 + (champion.level || 1) * 45;
                const baseDamage = (26 + (champion.level || 1) * 8) * dmgMult * (champion.attackDamageMultiplier || 1);
                const vulnerabilityProfile = context.vulnerabilityProfile || null;
                let highestDamage = 0;

                for (let i = 0; i < volley; i++) {
                    const offsetIdx = i - (volley - 1) / 2;
                    const angle = baseAngle + offsetIdx * spread;
                    const bullet = spawnBullet({
                        x: champion.x + Math.cos(baseAngle) * 10,
                        y: champion.y + Math.sin(baseAngle) * 10,
                        vx: Math.cos(angle) * projectileSpeed,
                        vy: Math.sin(angle) * projectileSpeed,
                        r: champion.level >= 4 ? 6 : 5,
                        col: champion.level >= 4 ? 'rgba(205, 210, 255, 0.96)' : 'rgba(162, 170, 255, 0.94)',
                        dmg: baseDamage,
                        life: 1.9,
                        pierce: champion.level >= 4,
                        isChampionShot: true,
                        championAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default',
                        championLevel: champion.level || 1
                    });
                    bullet.collisionSearchRadius = 160;
                    if (vulnerabilityProfile) {
                        bullet.vulnerabilityProfile = vulnerabilityProfile;
                    }
                    highestDamage = Math.max(highestDamage, bullet.dmg || 0);
                }

                const jitter = 0.06 + Math.random() * 0.08;
                const now = performance.now();
                if (!champion.lastShotTime || (now - champion.lastShotTime) > 200) {
                    champion.lastShotTime = now;
                }
                store.activeEffects.push(createEffect('hitSpark', champion.x + Math.cos(baseAngle) * 6, champion.y + Math.sin(baseAngle) * 6, 14, { strength: 45 }));
                return {
                    fireTimer: champion.fireCooldown || 1,
                    jitter,
                    damageApplied: highestDamage
                };
            }


            function championPerformCharge(champion, target, dmgMult) {
                const dx = target.x - champion.x;
                const dy = target.y - champion.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const chargeSpeed = 600;

                // Play charge sound
                playSound('beefCharge');

                champion.state = 'special_charge';
                champion.dashTimer = 0.4;
                champion.dashDuration = 0.4;
                champion.dashVX = (dx / dist) * chargeSpeed;
                champion.dashVY = (dy / dist) * chargeSpeed;
                champion.visualAim = Math.atan2(champion.dashVY, champion.dashVX);
                champion.dashHits = new Set();
                champion.echoCooldown = 0;

                // Enhanced charge damage
                champion.chargeDamage = (80 + (champion.level || 1) * 20) * dmgMult;

                // Visual effect - charge trail
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 30;
                    const particle = createParticle(
                        champion.x + Math.random() * 10 - 5,
                        champion.y + Math.random() * 10 - 5,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        '#4080ff',
                        200 + Math.random() * 100
                    );
                    if (particle) particle.size = 2 + Math.random() * 2;
                    store.flameParticles.push(particle);
                }

                addShadowEcho(champion.x, champion.y);
                champion.fireTimer = 1.2;
                playSound('beefCharge');
            }

            function championExecuteCrescentRicochet(champion, context = {}) {
                const target = context.target;
                if (!champion || champion.dead || !target) return null;

                const player = store.player;
                const level = champion.level || 1;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const baseDamage = (22 + level * 9) * dmgMult * (champion.attackDamageMultiplier || 1);
                const maxTargets = context.ability?.maxTargets ?? 3;
                const radius = context.ability?.searchRadius ?? 240;
                const vulnerabilityProfile = context.vulnerabilityProfile || null;

                const candidates = [];
                forEachEnemyNearby(target.x, target.y, radius, enemy => {
                    if (!enemy || enemy.dead || enemy.hp <= 0) return false;
                    const dx = enemy.x - target.x;
                    const dy = enemy.y - target.y;
                    const distSq = dx * dx + dy * dy;
                    candidates.push({ enemy, distSq });
                    return false;
                });

                if (store.boss && !store.boss.dead) {
                    const boss = store.boss;
                    const dx = boss.x - target.x;
                    const dy = boss.y - target.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= Math.pow(radius + (boss.r || 60), 2)) {
                        candidates.push({ enemy: boss, distSq });
                    }
                }

                candidates.sort((a, b) => a.distSq - b.distSq);

                let totalDamage = 0;
                let hits = 0;
                const arcPoints = [];

                for (let i = 0; i < candidates.length && hits < maxTargets; i++) {
                    const foe = candidates[i].enemy;
                    if (!foe || foe.dead || foe.hp <= 0) continue;
                    const applied = championDealDamage(foe, baseDamage, {
                        x: champion.x,
                        y: champion.y,
                        vulnerabilityProfile,
                        sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                    });
                    totalDamage += applied;
                    hits++;
                    arcPoints.push({ x: foe.x, y: foe.y });
                    foe.vulnerabilityPulseColor = '#7c9dff';
                    foe.vulnerabilityPulseStrength = Math.max(foe.vulnerabilityPulseStrength || 0, 0.7);
                }

                if (hits > 0) {
                    let prevPoint = { x: champion.x, y: champion.y };
                    arcPoints.forEach(point => {
                        store.activeEffects.push(createEffect('lightning', prevPoint.x, prevPoint.y, 20, {
                            targetX: point.x,
                            targetY: point.y,
                            strength: 48
                        }));
                        prevPoint = point;
                    });
                    playSound('chainLightning');
                }

                return {
                    fireTimer: 0.85,
                    cooldown: context.ability?._baseCooldown ?? context.ability?.baseCooldown ?? 4.6,
                    appliedDamage: totalDamage,
                    hits
                };
            }

            function championExecuteSolarBrand(champion, context = {}) {
                const target = context.target;
                if (!champion || champion.dead || !target) return null;

                const player = store.player;
                const level = champion.level || 1;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const burstDamage = (34 + level * 11) * dmgMult * (champion.attackDamageMultiplier || 1);
                const burnPayload = (18 + level * 6) * dmgMult;
                const vulnerabilityProfile = context.vulnerabilityProfile || null;

                const applied = championDealDamage(target, burstDamage, {
                    x: champion.x,
                    y: champion.y,
                    vulnerabilityProfile,
                    sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                });

                applyChampionEmberBurn(target, {
                    finalDamage: burnPayload,
                    championLevel: level
                });

                target.vulnerabilityPulseColor = '#ffb347';
                target.vulnerabilityPulseStrength = Math.max(target.vulnerabilityPulseStrength || 0, 1.0);

                store.activeEffects.push(createEffect('jugFearEmber', target.x, target.y, (target.r || 20) * 1.35));
                store.activeEffects.push(createEffect('hitSpark', target.x, target.y, (target.r || 18) * 1.1, { strength: 70 }));
                playSound('stargun');

                return {
                    fireTimer: 0.95,
                    cooldown: context.ability?._baseCooldown ?? context.ability?.baseCooldown ?? 7.5,
                    appliedDamage: applied
                };
            }

            function championExecuteNebulaBloom(champion, context = {}) {
                const target = context.target;
                if (!champion || champion.dead || !target) return null;

                const player = store.player;
                const level = champion.level || 1;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const baseDamage = (24 + level * 9) * dmgMult * (champion.attackDamageMultiplier || 1);
                const radius = context.ability?.radius ?? 165;
                const vulnerabilityProfile = context.vulnerabilityProfile || null;
                const radiusSq = radius * radius;
                let hits = 0;
                let totalDamage = 0;

                const originX = target.x;
                const originY = target.y;

                forEachEnemyNearby(originX, originY, radius, enemy => {
                    if (!enemy || enemy.dead || enemy.hp <= 0) return false;
                    const dx = enemy.x - originX;
                    const dy = enemy.y - originY;
                    if (dx * dx + dy * dy > radiusSq) return false;
                    const applied = championDealDamage(enemy, baseDamage, {
                        x: originX,
                        y: originY,
                        vulnerabilityProfile,
                        sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                    });
                    totalDamage += applied;
                    hits++;
                    enemy.vulnerabilityPulseColor = '#96c8ff';
                    enemy.vulnerabilityPulseStrength = Math.max(enemy.vulnerabilityPulseStrength || 0, 0.85);
                    return false;
                });

                if (store.boss && !store.boss.dead) {
                    const boss = store.boss;
                    const dx = boss.x - originX;
                    const dy = boss.y - originY;
                    if (dx * dx + dy * dy <= Math.pow(radius + (boss.r || 60), 2)) {
                        const applied = championDealDamage(boss, baseDamage, {
                            x: originX,
                            y: originY,
                            vulnerabilityProfile,
                            sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                        });
                        totalDamage += applied;
                        hits++;
                        boss.vulnerabilityPulseColor = '#96c8ff';
                        boss.vulnerabilityPulseStrength = Math.max(boss.vulnerabilityPulseStrength || 0, 0.55);
                    }
                }

                store.activeEffects.push(createEffect('grenadeExplosion', originX, originY, radius * 1.2, { strength: 75 }));
                store.activeEffects.push(createEffect('hitSpark', originX, originY, radius, { strength: 55 }));
                playSound('explosion');

                return {
                    fireTimer: 1.15,
                    cooldown: context.ability?._baseCooldown ?? context.ability?.baseCooldown ?? 11,
                    appliedDamage: totalDamage,
                    hits,
                    jitterRange: [0.08, 0.14]
                };
            }

            // Primordial Soldier Laboratory Functions
            function showPrimordialSoldierLaboratory() {
                const player = store.player;
                if (!player || !player.championUnlocked) {
                    announce('Champion must be unlocked first! Collect the Shadow Sigil.');
                    return;
                }

                pauseGame();
                const panel = q("championDressingRoom");
                populateChampionBuilder();
                populateChampionUpgradeGrid();
                updateChampionPreview();
                updateChampionStats();
                resetChampionPresetPanel();
                panel.classList.remove("hide");
                enterPanel('championDressingRoom');
            }

            function getSelectedChampionPresentation() {
                const player = store.player;
                const champion = store.playerChampion;
                const upgradeState = getChampionUpgradeState(player);

                // Override with selected values
                const selectedAttackModule = q('attackModuleSelect')?.value;
                const selectedCadence = parseInt(q('cadenceSelect')?.value || 0);
                const selectedProtocol = parseInt(q('protocolSelect')?.value || 0);
                const selectedSkin = q('skinSelect')?.value;

                const previewState = {
                    ...upgradeState,
                    attackModule: selectedAttackModule || upgradeState.attackModule,
                    cadenceLevel: selectedCadence >= 0 ? selectedCadence : upgradeState.cadenceLevel,
                    minionProtocols: selectedProtocol >= 0 ? selectedProtocol : upgradeState.minionProtocols,
                    skin: selectedSkin || upgradeState.skin
                };

                const skinId = previewState.skin || 'default';
                const skinOption = CHAMPION_SKIN_OPTION_MAP[skinId] || CHAMPION_SKIN_OPTION_MAP.default;
                const skinTheme = getChampionSkinTheme(skinOption.theme || skinOption.id || skinOption.key || 'default');
                const profile = (player && CHAMPION_PREVIEW_PROFILES[player.pilotGenome]) || CHAMPION_PREVIEW_PROFILES.default;
                return { player, champion, upgradeState: previewState, skinOption, skinTheme, profile };
            }

            function applyChampionLoadoutLabels(presentation) {
                if (!presentation) return;
                const { profile, skinOption, upgradeState, player } = presentation;
                const nameEl = q('previewChampionName');
                if (nameEl) {
                    const profileTitle = profile?.title || 'Shadow Guardian';
                    const skinName = skinOption?.name || 'Void Vanguard';
                    nameEl.textContent = `${profileTitle} Â· ${skinName}`;
                }

                const classEl = q('previewChampionClass');
                if (classEl) {
                    const subclass = player?.subclass ? player.subclass.replace(/_/g, ' ').toUpperCase() : '';
                    const baseLabel = profile?.classLabel || '';
                    classEl.textContent = subclass ? `${baseLabel}${baseLabel ? ' â€” ' : ''}${subclass}` : baseLabel;
                }

                const skinLabel = q('championSkinLabel');
                if (skinLabel) skinLabel.textContent = skinOption?.name || 'Void Vanguard';

                const attackModuleLabel = q('championAttackModuleLabel');
                const attackModule = (upgradeState?.attackModule && CHAMPION_ATTACK_MODULE_MAP[upgradeState.attackModule]) || null;
                if (attackModuleLabel) attackModuleLabel.textContent = attackModule?.name || 'Starfall Salvo';

                const cadenceLabel = q('championCadenceLabel');
                const cadenceOption = CHAMPION_CADENCE_LEVELS[upgradeState?.cadenceLevel || 0] || CHAMPION_CADENCE_LEVELS[0];
                if (cadenceLabel) cadenceLabel.textContent = cadenceOption?.name || 'BASELINE CADENCE';

                const protocolLabel = q('championProtocolLabel');
                const protocolOption = CHAMPION_MINION_PROTOCOL_LEVELS[upgradeState?.minionProtocols || 0] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                if (protocolLabel) protocolLabel.textContent = protocolOption?.name || 'ESCORT DRONES';

                const signatureLabel = q('championSignatureLabel');
                if (signatureLabel) signatureLabel.textContent = profile?.signature || 'Adaptive Void Sentinel';
            }

            function updateChampionPreview(animationType = currentPreviewAnimationType) {
                currentPreviewAnimationType = animationType;
                const canvas = q("championPreviewCanvas");
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const presentation = getSelectedChampionPresentation();
                const { champion, skinTheme, profile, upgradeState } = presentation;
                applyChampionLoadoutLabels(presentation);

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background
                const gradient = ctx.createRadialGradient(100, 110, 20, 100, 110, 120);
                const aura = skinTheme?.aura || CHAMPION_SKIN_THEMES.default.aura;
                gradient.addColorStop(0, withAlpha(aura.inner || 'rgba(51, 0, 68, 0.4)', 0.65));
                gradient.addColorStop(0.55, withAlpha(aura.mid || 'rgba(51, 0, 68, 0.3)', 0.55));
                gradient.addColorStop(1, withAlpha(aura.outer || 'rgba(5, 0, 15, 0.8)', 0.9));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!champion) {
                    // Draw placeholder champion
                    drawPlaceholderChampion(ctx, animationType, presentation);
                } else {
                    // Draw actual champion
                    drawChampionPreview(ctx, presentation, animationType);
                }
            }

            function drawChampionPreview(ctx, presentation, animationType, options = {}) {
                const { champion, skinTheme, profile, upgradeState } = presentation;
                const centerX = 100;
                const centerY = 118;
                const time = performance.now() / 1000;
                const isPlaceholder = options.forcePlaceholder || !champion;

                const level = champion?.level || 1;
                const health = champion?.hp ?? champion?.hpMax ?? (160 + level * 40);
                const maxHealth = champion?.hpMax ?? (180 + level * 45);
                const shield = champion?.shield ?? Math.max(0, (upgradeState?.champion_shield || 0) * 30);
                const auraPhase = (champion?.auraPulse || 0) + time * 2.1;

                let offsetY = 0;
                let scale = 1;
                let rotation = 0;

                switch (animationType) {
                    case 'attack':
                        offsetY = Math.sin(time * 7.5) * 2.6;
                        scale = 1 + Math.sin(time * 9) * 0.12;
                        rotation = Math.sin(time * 8) * 0.12;
                        break;
                    case 'special':
                        offsetY = Math.sin(time * 4.2) * 3.5;
                        scale = 1 + Math.sin(time * 5.4) * 0.18;
                        rotation = Math.sin(time * 3.3) * 0.11;
                        break;
                    default:
                        offsetY = Math.sin(time * 2.4) * 2.2;
                        scale = 1 + Math.sin(time * 1.8) * 0.06;
                        rotation = Math.sin(time * 1.7) * 0.04;
                        break;
                }

                const bodyTheme = skinTheme?.body || CHAMPION_SKIN_THEMES.default.body;
                const visorTheme = skinTheme?.visor || CHAMPION_SKIN_THEMES.default.visor;
                const auraTheme = skinTheme?.aura || CHAMPION_SKIN_THEMES.default.aura;
                const trailColor = skinTheme?.trail || '#78b4ff';

                const baseSize = 20 + Math.min(5, level) * 2.2;
                const accentColor = bodyTheme.accent || trailColor;

                ctx.save();
                ctx.translate(centerX, centerY + offsetY);
                ctx.scale(scale, scale);
                ctx.rotate(rotation);

                // Aura
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const auraRadius = baseSize * (2.1 + Math.sin(auraPhase) * 0.28);
                const auraGradient = ctx.createRadialGradient(0, 0, baseSize * 0.35, 0, 0, auraRadius);
                auraGradient.addColorStop(0, withAlpha(auraTheme.inner || '#7ab0ff', isPlaceholder ? 0.5 : 0.85));
                auraGradient.addColorStop(0.55, withAlpha(auraTheme.mid || '#2d559f', isPlaceholder ? 0.35 : 0.55));
                auraGradient.addColorStop(1, withAlpha(auraTheme.outer || '#0f1732', 0));
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Body - Shape based on skin
                const bodyGradient = ctx.createLinearGradient(0, -baseSize * 1.1, 0, baseSize * 1.05);
                bodyGradient.addColorStop(0, bodyTheme.top || '#2a3560');
                bodyGradient.addColorStop(0.45, bodyTheme.mid || bodyTheme.top || '#1e2845');
                bodyGradient.addColorStop(1, bodyTheme.bottom || bodyTheme.mid || '#3c4f78');

                ctx.globalAlpha = isPlaceholder ? 0.85 : 1;
                ctx.fillStyle = bodyGradient;
                ctx.strokeStyle = bodyTheme.outline || accentColor;
                ctx.lineWidth = 2.1;
                ctx.beginPath();

                // Different shapes based on skin
                const skinId = upgradeState?.skin || 'default';
                switch (skinId) {
                    case 'solstice': // Angular, sharp design
                        ctx.moveTo(0, -baseSize * 1.2);
                        ctx.lineTo(baseSize * 0.8, -baseSize * 0.3);
                        ctx.lineTo(baseSize * 0.9, baseSize * 0.2);
                        ctx.lineTo(baseSize * 0.4, baseSize * 1.0);
                        ctx.lineTo(0, baseSize * 1.1);
                        ctx.lineTo(-baseSize * 0.4, baseSize * 1.0);
                        ctx.lineTo(-baseSize * 0.9, baseSize * 0.2);
                        ctx.lineTo(-baseSize * 0.8, -baseSize * 0.3);
                        ctx.closePath();
                        break;
                    case 'tempest': // Flowing, curved design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.quadraticCurveTo(baseSize * 0.6, -baseSize * 0.8, baseSize * 0.8, -baseSize * 0.1);
                        ctx.quadraticCurveTo(baseSize * 0.9, baseSize * 0.4, baseSize * 0.5, baseSize * 0.9);
                        ctx.quadraticCurveTo(baseSize * 0.2, baseSize * 1.1, 0, baseSize * 1.05);
                        ctx.quadraticCurveTo(-baseSize * 0.2, baseSize * 1.1, -baseSize * 0.5, baseSize * 0.9);
                        ctx.quadraticCurveTo(-baseSize * 0.9, baseSize * 0.4, -baseSize * 0.8, -baseSize * 0.1);
                        ctx.quadraticCurveTo(-baseSize * 0.6, -baseSize * 0.8, 0, -baseSize * 1.1);
                        ctx.closePath();
                        break;
                    case 'aurora': // Spiral/helix design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.lineTo(baseSize * 0.7, -baseSize * 0.4);
                        ctx.quadraticCurveTo(baseSize * 1.0, -baseSize * 0.1, baseSize * 0.8, baseSize * 0.3);
                        ctx.quadraticCurveTo(baseSize * 0.6, baseSize * 0.7, baseSize * 0.3, baseSize * 0.9);
                        ctx.lineTo(0, baseSize * 1.0);
                        ctx.lineTo(-baseSize * 0.3, baseSize * 0.9);
                        ctx.quadraticCurveTo(-baseSize * 0.6, baseSize * 0.7, -baseSize * 0.8, baseSize * 0.3);
                        ctx.quadraticCurveTo(-baseSize * 1.0, -baseSize * 0.1, -baseSize * 0.7, -baseSize * 0.4);
                        ctx.closePath();
                        break;
                    case 'bastion': // Blocky, armored design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.lineTo(baseSize * 0.9, -baseSize * 0.3);
                        ctx.lineTo(baseSize * 0.9, baseSize * 0.1);
                        ctx.lineTo(baseSize * 0.6, baseSize * 0.1);
                        ctx.lineTo(baseSize * 0.6, baseSize * 0.8);
                        ctx.lineTo(baseSize * 0.3, baseSize * 0.8);
                        ctx.lineTo(baseSize * 0.3, baseSize * 1.0);
                        ctx.lineTo(0, baseSize * 1.05);
                        ctx.lineTo(-baseSize * 0.3, baseSize * 1.0);
                        ctx.lineTo(-baseSize * 0.3, baseSize * 0.8);
                        ctx.lineTo(-baseSize * 0.6, baseSize * 0.8);
                        ctx.lineTo(-baseSize * 0.6, baseSize * 0.1);
                        ctx.lineTo(-baseSize * 0.9, baseSize * 0.1);
                        ctx.lineTo(-baseSize * 0.9, -baseSize * 0.3);
                        ctx.closePath();
                        break;
                    case 'umbra': // Spiky, crystalline design
                        ctx.moveTo(0, -baseSize * 1.2);
                        ctx.lineTo(baseSize * 0.4, -baseSize * 0.8);
                        ctx.lineTo(baseSize * 0.8, -baseSize * 0.2);
                        ctx.lineTo(baseSize * 0.6, baseSize * 0.2);
                        ctx.lineTo(baseSize * 0.9, baseSize * 0.6);
                        ctx.lineTo(baseSize * 0.4, baseSize * 0.9);
                        ctx.lineTo(0, baseSize * 1.1);
                        ctx.lineTo(-baseSize * 0.4, baseSize * 0.9);
                        ctx.lineTo(-baseSize * 0.9, baseSize * 0.6);
                        ctx.lineTo(-baseSize * 0.6, baseSize * 0.2);
                        ctx.lineTo(-baseSize * 0.8, -baseSize * 0.2);
                        ctx.lineTo(-baseSize * 0.4, -baseSize * 0.8);
                        ctx.closePath();
                        break;
                    default: // Void Vanguard - original design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.lineTo(baseSize * 0.92, -baseSize * 0.12);
                        ctx.lineTo(baseSize * 0.58, baseSize * 0.92);
                        ctx.lineTo(0, baseSize * 1.06);
                        ctx.lineTo(-baseSize * 0.58, baseSize * 0.92);
                        ctx.lineTo(-baseSize * 0.92, -baseSize * 0.12);
                        ctx.closePath();
                        break;
                }

                ctx.fill();
                ctx.stroke();

                // Interior panel
                ctx.globalAlpha = 0.75;
                ctx.fillStyle = bodyTheme.interior || '#1a2440';
                ctx.beginPath();
                ctx.moveTo(-baseSize * 0.28, -baseSize * 0.28);
                ctx.lineTo(baseSize * 0.28, -baseSize * 0.28);
                ctx.lineTo(baseSize * 0.42, baseSize * 0.16);
                ctx.lineTo(-baseSize * 0.42, baseSize * 0.16);
                ctx.closePath();
                ctx.fill();

                // Visor
                ctx.globalAlpha = 0.92;
                const visorGradient = ctx.createLinearGradient(-baseSize * 0.42, -baseSize * 0.26, baseSize * 0.42, 0);
                visorGradient.addColorStop(0, visorTheme.left || 'rgba(80, 150, 255, 0.85)');
                visorGradient.addColorStop(0.5, visorTheme.center || 'rgba(120, 180, 255, 0.95)');
                visorGradient.addColorStop(1, visorTheme.right || 'rgba(60, 120, 200, 0.8)');
                ctx.fillStyle = visorGradient;
                ctx.beginPath();
                ctx.moveTo(0, -baseSize * 0.48);
                ctx.lineTo(baseSize * 0.42, -baseSize * 0.22);
                ctx.lineTo(baseSize * 0.32, 0);
                ctx.lineTo(-baseSize * 0.32, 0);
                ctx.lineTo(-baseSize * 0.42, -baseSize * 0.22);
                ctx.closePath();
                ctx.fill();

                // Accent struts
                ctx.globalAlpha = 0.85;
                ctx.strokeStyle = withAlpha(accentColor, level >= 4 ? 0.95 : 0.8);
                ctx.lineWidth = 1.9;
                ctx.beginPath();
                ctx.moveTo(-baseSize * 0.36, baseSize * 0.26);
                ctx.lineTo(baseSize * 0.36, baseSize * 0.26);
                ctx.moveTo(-baseSize * 0.25, baseSize * 0.62);
                ctx.lineTo(baseSize * 0.25, baseSize * 0.62);
                ctx.stroke();

                // Core glow
                ctx.globalAlpha = 0.78;
                const coreGradient = ctx.createRadialGradient(0, baseSize * 0.18, 0, 0, baseSize * 0.18, baseSize * 0.52);
                coreGradient.addColorStop(0, withAlpha(accentColor, 0.85));
                coreGradient.addColorStop(1, withAlpha(trailColor, 0.26));
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, baseSize * 0.18, baseSize * 0.48, 0, Math.PI * 2);
                ctx.fill();

                // Level indicators
                ctx.globalAlpha = 0.85;
                const levelCount = Math.min(6, level);
                for (let i = 0; i < levelCount; i++) {
                    const angle = (i / levelCount) * Math.PI * 2 + auraPhase * 0.18;
                    const lx = Math.cos(angle) * (baseSize + 6);
                    const ly = Math.sin(angle) * (baseSize + 6);
                    ctx.fillStyle = withAlpha(accentColor, 0.88);
                    ctx.beginPath();
                    ctx.arc(lx, ly, 2.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Shield ring
                if (shield > 0) {
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(trailColor, 0.85);
                    ctx.lineWidth = 2.4;
                    const shieldRatio = Math.min(1, shield / (champion?.shieldMax || shield + 60));
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 1.28, -Math.PI / 2, -Math.PI / 2 + shieldRatio * Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                drawChampionPreviewMinions(ctx, centerX, centerY + offsetY, presentation, baseSize, time);
                drawChampionPreviewEffect(ctx, centerX, centerY + offsetY, animationType, presentation, baseSize, time);
            }

            function drawPlaceholderChampion(ctx, animationType, presentation) {
                drawChampionPreview(ctx, presentation, animationType, { forcePlaceholder: true });
            }

            function drawChampionPreviewMinions(ctx, x, y, presentation, baseSize, time) {
                const { skinTheme, champion, upgradeState } = presentation;
                const theme = skinTheme?.minion || CHAMPION_SKIN_THEMES.default.minion;
                const selectedProtocol = upgradeState?.minionProtocols || 0;
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[selectedProtocol] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                let minionCount = protocol.minionCount || 2;

                if (minionCount <= 0) return;

                const radius = baseSize * (1.9 + minionCount * 0.14);
                for (let i = 0; i < minionCount; i++) {
                    const angle = time * 0.9 + (i / minionCount) * Math.PI * 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius * 0.6;

                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = withAlpha(theme.trail || '#4362a8', 0.4);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(px, py);
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.translate(px, py);
                    ctx.globalAlpha = 0.82;
                    ctx.fillStyle = withAlpha(theme.core || '#bcd4ff', 0.9);
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.32, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(theme.aura || '#82a7ff', 0.75);
                    ctx.lineWidth = 1.5;
                    const pulse = 1 + Math.sin(time * 3.2 + i) * 0.18;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.44 * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            function drawChampionPreviewEffect(ctx, x, y, animationType, presentation, baseSize, time) {
                const { upgradeState, skinTheme } = presentation;
                const trailColor = skinTheme?.trail || '#78b4ff';
                const accent = skinTheme?.body?.accent || trailColor;

                // Get selected modules
                const attackModule = upgradeState?.attackModule || 'default';
                const cadenceLevel = upgradeState?.cadenceLevel || 0;
                const minionProtocol = upgradeState?.minionProtocols || 0;

                switch (animationType) {
                    case 'idle': // Attack Module demo
                        drawAttackModuleEffect(ctx, x, y, attackModule, baseSize * 1.2, time, accent, trailColor);
                        break;
                    case 'attack': // Cadence Core demo
                        drawCadenceEffect(ctx, x, y, cadenceLevel, baseSize * 1.2, time, accent, trailColor);
                        break;
                    case 'special': // Minion Protocol demo
                        drawMinionProtocolEffect(ctx, x, y, minionProtocol, baseSize * 1.2, time, accent, trailColor);
                        break;
                }
            }

            function drawAttackModuleEffect(ctx, x, y, moduleId, baseSize, time, accent, trailColor) {
                const module = CHAMPION_ATTACK_MODULE_MAP[moduleId];
                if (!module) return;

                switch (moduleId) {
                    case 'charge_cannon':
                        // Charge up effect
                        const chargeProgress = Math.sin(time * 3) * 0.5 + 0.5;
                        ctx.save();
                        ctx.globalAlpha = 0.9;
                        ctx.strokeStyle = withAlpha(accent, chargeProgress * 0.8);
                        ctx.lineWidth = 4 + chargeProgress * 3;
                        ctx.beginPath();
                        ctx.arc(x, y, baseSize * (1.3 + chargeProgress * 0.6), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                        break;
                    case 'lightning_storm':
                        // Lightning arcs
                        const bolts = 3;
                        ctx.globalAlpha = 0.85;
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = withAlpha('#d4e6ff', 0.95);
                        for (let i = 0; i < bolts; i++) {
                            const angle = time * 2.4 + i * (Math.PI * 2 / bolts);
                            const ex = x + Math.cos(angle) * baseSize * 1.8;
                            const ey = y + Math.sin(angle) * baseSize * 1.4;
                            ctx.beginPath();
                            ctx.moveTo(x, y - baseSize * 0.3);
                            ctx.lineTo((x + ex) / 2 + Math.sin(time * 8 + i) * 8, (y + ey) / 2 + Math.cos(time * 7 + i) * 6);
                            ctx.lineTo(ex, ey);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                        break;
                    case 'plasma_burst':
                        // Plasma projectiles
                        const burstCount = 5;
                        for (let i = 0; i < burstCount; i++) {
                            const angle = time * 1.5 + i * (Math.PI * 2 / burstCount);
                            const px = x + Math.cos(angle) * baseSize * 1.4;
                            const py = y + Math.sin(angle) * baseSize * 1.0;
                            ctx.save();
                            ctx.translate(px, py);
                            ctx.globalAlpha = 0.9;
                            ctx.fillStyle = withAlpha('#4adeff', 0.95);
                            ctx.beginPath();
                            ctx.arc(0, 0, baseSize * 0.18, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                        break;
                    case 'void_beam':
                        // Void beam
                        ctx.save();
                        ctx.globalAlpha = 0.9;
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = withAlpha('#c6a4ff', 0.8);
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.moveTo(x, y - baseSize * 0.4);
                        ctx.lineTo(x, y - baseSize * 4.0);
                        ctx.stroke();
                        ctx.restore();
                        break;
                    case 'cluster_launcher':
                        // Cluster missiles
                        const clusterCount = 6;
                        for (let i = 0; i < clusterCount; i++) {
                            const angle = time * 1.2 + i * (Math.PI * 2 / clusterCount);
                            const px = x + Math.cos(angle) * baseSize * 1.5;
                            const py = y + Math.sin(angle) * baseSize * 1.1;
                            ctx.save();
                            ctx.translate(px, py);
                            ctx.rotate(angle + Math.PI / 2);
                            ctx.globalAlpha = 0.8;
                            ctx.fillStyle = withAlpha('#ff6b35', 0.95);
                            ctx.beginPath();
                            ctx.moveTo(0, -baseSize * 0.22);
                            ctx.lineTo(baseSize * 0.09, baseSize * 0.22);
                            ctx.lineTo(-baseSize * 0.09, baseSize * 0.22);
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        }
                        break;
                    default: // Starfall Salvo volley
                        const volleyCount = 3;
                        for (let i = 0; i < volleyCount; i++) {
                            const angle = time * 2 + i * (Math.PI * 2 / volleyCount);
                            const px = x + Math.cos(angle) * baseSize * 1.2;
                            const py = y + Math.sin(angle) * baseSize * 0.8;
                            ctx.save();
                            ctx.translate(px, py);
                            ctx.globalAlpha = 0.8;
                            ctx.fillStyle = withAlpha(accent, 0.9);
                            ctx.beginPath();
                            ctx.arc(0, 0, baseSize * 0.12, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                        break;
                }
            }

            function drawCadenceEffect(ctx, x, y, cadenceLevel, baseSize, time, accent, trailColor) {
                const cadence = CHAMPION_CADENCE_LEVELS[cadenceLevel] || CHAMPION_CADENCE_LEVELS[0];

                // Show firing pattern based on cadence
                const fireRate = cadence.fireRate || 1.4;
                const burstSize = cadence.burstSize || 1;

                // Simulate firing pattern
                const fireInterval = 1 / fireRate;
                const timeInCycle = time % fireInterval;
                const progress = timeInCycle / fireInterval;

                if (progress < 0.3) { // Firing phase
                    for (let i = 0; i < burstSize; i++) {
                        const offset = (i - (burstSize - 1) / 2) * baseSize * 0.35;
                        ctx.save();
                        ctx.translate(x + offset, y - baseSize * 0.6);
                        ctx.globalAlpha = 0.95;
                        ctx.fillStyle = withAlpha(accent, 0.98);
                        ctx.beginPath();
                        ctx.arc(0, 0, baseSize * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }

                // Show cooldown ring
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = withAlpha(trailColor, 0.9);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, baseSize * 1.2, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            function drawMinionProtocolEffect(ctx, x, y, protocolLevel, baseSize, time, accent, trailColor) {
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[protocolLevel] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const minionCount = protocol.minionCount || 2;

                // Draw orbiting minions
                const radius = baseSize * 2.0;
                for (let i = 0; i < minionCount; i++) {
                    const angle = time * 0.8 + (i / minionCount) * Math.PI * 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius * 0.6;

                    // Minion tether
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = withAlpha(trailColor, 0.7);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(px, py);
                    ctx.stroke();
                    ctx.restore();

                    // Minion body
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = withAlpha(accent, 0.95);
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.28, 0, Math.PI * 2);
                    ctx.fill();

                    // Minion aura
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(trailColor, 0.8);
                    ctx.lineWidth = 2;
                    const pulse = 1 + Math.sin(time * 3 + i) * 0.25;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.4 * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            function updateChampionStats() {
                const presentation = getSelectedChampionPresentation();
                const { champion, player } = presentation;
                const levels = player?.upgradeLevels || {};

                const stats = {
                    health: 180,
                    maxHealth: 180,
                    shield: 0,
                    maxShield: 0,
                    attackPower: 28,
                    fireRate: 1.4,
                    level: champion?.level || 1,
                    experience: champion?.xp || 0,
                    maxExp: getChampionLevelUpCost(champion?.level || 1)
                };

                if (champion) {
                    stats.health = Math.floor(champion.hp || 0);
                    stats.maxHealth = Math.floor(champion.hpMax || 0) || 180;
                    stats.shield = Math.floor(champion.shield || 0);
                    stats.maxShield = Math.floor(champion.shieldMax || 0);
                    stats.level = champion.level || 1;
                    stats.experience = champion.xp || 0;
                    stats.maxExp = getChampionLevelUpCost(stats.level);
                    stats.fireRate = 1 / Math.max(0.2, champion.fireCooldown || 1.5);

                    const baseDamage = 25 + stats.level * 8;
                    const damageScale = champion.damageScale || 1;
                    stats.attackPower = Math.floor(baseDamage * damageScale);
                } else {
                    const healthBonus = 1 + (levels.champion_health || 0) * 0.2;
                    stats.maxHealth = Math.round(stats.maxHealth * healthBonus);
                    stats.health = stats.maxHealth;
                    stats.maxShield = (levels.champion_shield || 0) * 30;
                    stats.shield = stats.maxShield;
                    stats.attackPower = Math.round(stats.attackPower + (levels.champion_damage || 0) * 25);
                    stats.fireRate = 1.4 + (levels.champion_speed || 0) * 0.12;
                }

                applyChampionLoadoutLabels(presentation);

                q('championHealthStat').textContent = `${stats.health}/${stats.maxHealth}`;
                q('championShieldStat').textContent = stats.maxShield > 0 ? `${stats.shield}/${stats.maxShield}` : 'None';
                q('championAttackStat').textContent = stats.attackPower;
                q('championFireRateStat').textContent = `${stats.fireRate.toFixed(1)}/s`;
                q('championLevelStat').textContent = stats.level;
                q('championExpStat').textContent = `${stats.experience}/${stats.maxExp}`;

                updateChampionAttackTypes(presentation);
                updateChampionUpgrades(presentation);
            }

            function updateChampionAttackTypes(presentation = getSelectedChampionPresentation()) {
                const container = q('championAttackTypesList');
                if (!container) return;

                container.innerHTML = '';

                const { profile, upgradeState } = presentation;
                const attackTypes = [];
                const seen = new Set();

                if (upgradeState?.attackModule && upgradeState.attackModule !== 'default') {
                    const module = CHAMPION_ATTACK_MODULE_MAP[upgradeState.attackModule];
                    if (module) {
                        attackTypes.push({
                            id: `module-${module.id}`,
                            name: `${module.name}`,
                            icon: module.icon || 'ðŸ› ï¸',
                            description: module.desc
                        });
                        seen.add(`module-${module.id}`);
                    }
                }

                (profile?.abilityHighlights || []).forEach(ability => {
                    if (!ability) return;
                    const key = ability.id || ability.name;
                    if (seen.has(key)) return;
                    seen.add(key);
                    attackTypes.push(ability);
                });

                CHAMPION_COMBAT_SUMMARY.forEach(summary => {
                    if (!summary) return;
                    const key = summary.id || summary.name;
                    if (key && seen.has(key)) return;
                    if (key) seen.add(key);
                    attackTypes.push(summary);
                });

                if (!attackTypes.length) {
                    attackTypes.push({
                        name: 'Starfall Salvo',
                        icon: 'âœ¨',
                        description: 'Staggered plasma bolts that lock to the guardianâ€™s focus.'
                    });
                }

                attackTypes.forEach(attack => {
                    const div = document.createElement('div');
                    div.className = 'attack-type-item';
                    const iconHtml = attack.icon ? `<span class="ability-icon">${attack.icon}</span>` : '';
                    div.innerHTML = `
                <div class="attack-name">${iconHtml}${attack.name}</div>
                <div>${attack.description || ''}</div>
            `;
                    container.appendChild(div);
                });
            }

            function updateChampionUpgrades(presentation = getSelectedChampionPresentation()) {
                const container = q('championUpgradesList');
                if (!container) return;

                container.innerHTML = '';

                const { player, champion, upgradeState, skinOption, profile } = presentation;
                const levels = player?.upgradeLevels || {};
                const upgrades = [];

                const cadenceOption = CHAMPION_CADENCE_LEVELS[upgradeState?.cadenceLevel || 0] || CHAMPION_CADENCE_LEVELS[0];
                upgrades.push({
                    name: `Cadence Â· ${cadenceOption.name}`,
                    description: cadenceOption.desc
                });

                const protocolOption = CHAMPION_MINION_PROTOCOL_LEVELS[upgradeState?.minionProtocols || 0] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                upgrades.push({
                    name: `Minion Protocol Â· ${protocolOption.name}`,
                    description: protocolOption.desc
                });

                if (upgradeState?.attackModule && upgradeState.attackModule !== 'default') {
                    const module = CHAMPION_ATTACK_MODULE_MAP[upgradeState.attackModule];
                    if (module) {
                        upgrades.push({
                            name: `Attack Module Â· ${module.name}`,
                            description: module.desc
                        });
                    }
                } else {
                    upgrades.push({
                        name: 'Attack Module Â· Starfall Salvo',
                        description: 'Baseline plasma barrage configured for sustained guardian fire.'
                    });
                }

                if (skinOption) {
                    upgrades.push({
                        name: `Skin Â· ${skinOption.name}`,
                        description: skinOption.desc || profile?.signature || ''
                    });
                }

                if (levels.champion_health > 0) {
                    upgrades.push({
                        name: 'Enhanced Vitality',
                        description: `Health increased by ${levels.champion_health * 20}%`,
                        level: levels.champion_health
                    });
                }

                if (levels.champion_damage > 0) {
                    upgrades.push({
                        name: 'Combat Amplifier',
                        description: `Attack power increased by ${levels.champion_damage * 25}%`,
                        level: levels.champion_damage
                    });
                }

                if (levels.champion_speed > 0) {
                    upgrades.push({
                        name: 'Mobility Enhancement',
                        description: `Movement and attack speed increased by ${levels.champion_speed * 15}%`,
                        level: levels.champion_speed
                    });
                }

                if (levels.champion_shield > 0) {
                    upgrades.push({
                        name: 'Defensive Matrix',
                        description: `Shield capacity increased by ${levels.champion_shield * 30} points`,
                        level: levels.champion_shield
                    });
                }

                if (levels.champion_regen > 0) {
                    upgrades.push({
                        name: 'Auto-Repair System',
                        description: `Regenerates ${levels.champion_regen * 2} health per second`,
                        level: levels.champion_regen
                    });
                }

                if (champion && champion.level > 1) {
                    upgrades.push({
                        name: 'Combat Experience',
                        description: `Level ${champion.level} â€” Guardian combat AI unlocked new tactics`,
                        level: champion.level
                    });
                }

                if (!upgrades.length) {
                    const div = document.createElement('div');
                    div.className = 'upgrade-item';
                    div.innerHTML = `
                <div class="upgrade-name">No Active Upgrades</div>
                <div>Visit the Upgrade Hangar to enhance your champion</div>
            `;
                    container.appendChild(div);
                    return;
                }

                upgrades.forEach(upgrade => {
                    const div = document.createElement('div');
                    div.className = 'upgrade-item';
                    const levelTag = upgrade.level && upgrade.level > 1 ? ` (Lv.${upgrade.level})` : '';
                    div.innerHTML = `
                <div class="upgrade-name">${upgrade.name}${levelTag}</div>
                <div>${upgrade.description || ''}</div>
            `;
                    container.appendChild(div);
                });
            }

            function setChampionPresetStatus(message, type = '') {
                const statusEl = q('championPresetStatus');
                if (!statusEl) return;
                statusEl.textContent = message || '';
                statusEl.classList.remove('success', 'error');
                if (type) {
                    statusEl.classList.add(type);
                }
            }

            function resetChampionPresetPanel({ preserveInput = false } = {}) {
                const output = q('championPresetCodeOutput');
                if (output) {
                    output.value = store.lastChampionPresetCode || '';
                }
                if (!preserveInput) {
                    const input = q('championPresetCodeInput');
                    if (input) input.value = '';
                }
                if (!preserveInput) {
                    setChampionPresetStatus('');
                }
            }

            function loadChampionPresetCode(code, options = {}) {
                const preset = decodeChampionPresetCode(code);
                if (!preset) {
                    return { success: false, message: 'Invalid or corrupted champion code.' };
                }
                const applied = applyChampionPresetToPlayer(preset, options);
                if (!applied) {
                    return { success: false, message: 'Unable to apply champion configuration.' };
                }
                store.lastChampionPresetCode = code;
                return { success: true, preset };
            }

            function updateChampionBuilderDetails() {
                const formatLabel = (value) => {
                    if (value === undefined || value === null) return '';
                    return String(value)
                        .replace(/[_-]+/g, ' ')
                        .split(' ')
                        .filter(Boolean)
                        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
                        .join(' ');
                };

                const pluralize = (count, singular, plural = `${singular}s`) => {
                    const safeCount = Number(count);
                    if (!Number.isFinite(safeCount)) return plural;
                    return safeCount === 1 ? singular : plural;
                };

                const attackDetail = q('attackModuleDetail');
                if (attackDetail) {
                    const select = q('attackModuleSelect');
                    const value = select ? select.value : 'default';
                    const module = value && value !== 'default' ? CHAMPION_ATTACK_MODULE_MAP[value] : null;
                    const info = module ? module : {
                        icon: 'âœ¨',
                        name: 'Starfall Salvo',
                        desc: 'Radiant starfire bolts cascade toward your focus target and nearby threats.',
                        damageType: 'adaptive',
                        targetType: 'multi-role',
                        attackSpeed: 'balanced',
                        tradeOff: 'Reliable baseline pattern without specialized amplification.'
                    };
                    const meta = [];
                    if (info.damageType) {
                        meta.push(`<li><strong>Damage Type:</strong> ${escapeHtml(formatLabel(info.damageType))}</li>`);
                    }
                    if (info.attackSpeed) {
                        meta.push(`<li><strong>Tempo:</strong> ${escapeHtml(formatLabel(info.attackSpeed))}</li>`);
                    }
                    if (info.targetType) {
                        meta.push(`<li><strong>Target Profile:</strong> ${escapeHtml(formatLabel(info.targetType))}</li>`);
                    }
                    if (info.tradeOff) {
                        meta.push(`<li><strong>Trade-Off:</strong> ${escapeHtml(info.tradeOff)}</li>`);
                    }
                    if (module && module.specialEffect) {
                        meta.push(`<li><strong>Signature Effect:</strong> ${escapeHtml(formatLabel(module.specialEffect))}</li>`);
                    }
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    attackDetail.innerHTML = `
                        <div class="builder-detail-title"><span>${escapeHtml(info.icon || 'âœ¨')}</span><span>${escapeHtml(info.name || 'Starfall Salvo')}</span></div>
                        <p>${escapeHtml(info.desc || 'Radiant starfire bolts cascade toward your focus target and nearby threats.')}</p>
                        ${metaHtml}
                    `;
                }

                const cadenceDetail = q('cadenceDetail');
                if (cadenceDetail) {
                    const select = q('cadenceSelect');
                    const selected = select ? parseInt(select.value, 10) : 0;
                    const cadence = CHAMPION_CADENCE_LEVELS[selected] || CHAMPION_CADENCE_LEVELS[0];
                    const meta = [];
                    if (Number.isFinite(cadence.fireRateMult)) {
                        const fireMult = cadence.fireRateMult;
                        const fireDelta = Math.round((1 - fireMult) * 100);
                        const fireLabel = Math.abs(fireDelta) < 1
                            ? 'Matches baseline timing'
                            : fireDelta > 0
                                ? `${fireDelta}% faster firing cadence`
                                : `${Math.abs(fireDelta)}% slower firing cadence`;
                        meta.push(`<li><strong>Weapon Tempo:</strong> ${escapeHtml(fireLabel)} (Ã—${fireMult.toFixed(2)})</li>`);
                    }
                    if (Number.isFinite(cadence.dashCooldownMult)) {
                        const dashMult = cadence.dashCooldownMult;
                        const dashDelta = Math.round((1 - dashMult) * 100);
                        const dashLabel = Math.abs(dashDelta) < 1
                            ? 'Baseline dash cooldown'
                            : dashDelta > 0
                                ? `${dashDelta}% quicker recovery`
                                : `${Math.abs(dashDelta)}% longer recovery`;
                        meta.push(`<li><strong>Dash Systems:</strong> ${escapeHtml(dashLabel)} (Ã—${dashMult.toFixed(2)})</li>`);
                    }
                    meta.push(`<li><strong>Cadence Tier:</strong> Level ${escapeHtml(cadence.level ?? 0)}</li>`);
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    cadenceDetail.innerHTML = `
                        <div class="builder-detail-title"><span>ðŸŽµ</span><span>${escapeHtml(cadence.name || 'Baseline Cadence')}</span></div>
                        <p>${escapeHtml(cadence.desc || 'Standard guardian timing.')}</p>
                        ${metaHtml}
                    `;
                }

                const protocolDetail = q('protocolDetail');
                if (protocolDetail) {
                    const select = q('protocolSelect');
                    const selected = select ? parseInt(select.value, 10) : 0;
                    const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[selected] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                    const meta = [];
                    if (Number.isFinite(protocol.minionCount)) {
                        const droneWord = pluralize(protocol.minionCount, 'drone');
                        meta.push(`<li><strong>Escort Count:</strong> ${escapeHtml(`${protocol.minionCount} ${droneWord}`)}</li>`);
                    }
                    if (Number.isFinite(protocol.damageMult)) {
                        const dmgDelta = Math.round((protocol.damageMult - 1) * 100);
                        const dmgLabel = Math.abs(dmgDelta) < 1
                            ? 'Baseline damage output'
                            : dmgDelta > 0
                                ? `+${dmgDelta}% damage`
                                : `${dmgDelta}% damage`;
                        meta.push(`<li><strong>Damage Output:</strong> ${escapeHtml(dmgLabel)} (Ã—${protocol.damageMult.toFixed(2)})</li>`);
                    }
                    if (Number.isFinite(protocol.fireRateMult)) {
                        const rateDelta = Math.round((1 - protocol.fireRateMult) * 100);
                        const rateLabel = Math.abs(rateDelta) < 1
                            ? 'Baseline firing tempo'
                            : rateDelta > 0
                                ? `${rateDelta}% faster firing`
                                : `${Math.abs(rateDelta)}% slower firing`;
                        meta.push(`<li><strong>Fire Tempo:</strong> ${escapeHtml(rateLabel)} (Ã—${protocol.fireRateMult.toFixed(2)})</li>`);
                    }
                    if (Number.isFinite(protocol.slowFactor)) {
                        const slow = Math.round((1 - protocol.slowFactor) * 100);
                        if (slow > 0) {
                            meta.push(`<li><strong>Debilitation:</strong> Slows enemies by ${escapeHtml(slow)}%</li>`);
                        }
                    }
                    if (Number.isFinite(protocol.novaDamageScale) && protocol.novaDamageScale > 0) {
                        meta.push(`<li><strong>Nova Splash:</strong> ${escapeHtml(Math.round(protocol.novaDamageScale * 100))}% of minion damage in an area</li>`);
                    }
                    meta.push(`<li><strong>Protocol Tier:</strong> Level ${escapeHtml(protocol.level ?? 0)}</li>`);
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    protocolDetail.innerHTML = `
                        <div class="builder-detail-title"><span>ðŸ›°ï¸</span><span>${escapeHtml(protocol.name || 'Escort Drones')}</span></div>
                        <p>${escapeHtml(protocol.desc || 'Standard escort pattern.')}</p>
                        ${metaHtml}
                    `;
                }

                const skinDetail = q('skinDetail');
                if (skinDetail) {
                    const select = q('skinSelect');
                    const value = select ? select.value : 'default';
                    const skin = CHAMPION_SKIN_OPTION_MAP[value] || CHAMPION_SKIN_OPTION_MAP.default;
                    const meta = [];
                    if (Number.isFinite(skin.cost)) {
                        if (skin.cost <= 0) {
                            meta.push('<li><strong>Cost:</strong> Unlocked by default</li>');
                        } else {
                            meta.push(`<li><strong>Cost:</strong> ${escapeHtml(skin.cost)} credits</li>`);
                        }
                    }
                    if (skin.theme) {
                        meta.push(`<li><strong>Theme:</strong> ${escapeHtml(formatLabel(skin.theme))}</li>`);
                    }
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    skinDetail.innerHTML = `
                        <div class="builder-detail-title"><span>${escapeHtml(skin.icon || 'ðŸ’ ')}</span><span>${escapeHtml(skin.name || 'Void Vanguard')}</span></div>
                        <p>${escapeHtml(skin.desc || 'Baseline guardian plating.')}</p>
                        ${metaHtml}
                    `;
                }
            }

            function populateChampionBuilder() {
                const state = getChampionUpgradeState();

                // Attack Module Select
                const attackSelect = q('attackModuleSelect');
                if (attackSelect) {
                    attackSelect.innerHTML = '<option value="default">Starfall Salvo</option>';
                    const unlockedModules = Object.entries(state.unlockedAttacks || {})
                        .filter(([, unlocked]) => !!unlocked)
                        .map(([moduleId]) => moduleId);

                    // Group modules by damage type for better organization
                    const modulesByType = {
                        kinetic: [],
                        fire: [],
                        laser: [],
                        lightning: []
                    };

                    unlockedModules.forEach(moduleId => {
                        const module = CHAMPION_ATTACK_MODULE_MAP[moduleId];
                        if (module && module.damageType) {
                            modulesByType[module.damageType].push(module);
                        }
                    });

                    // Add grouped options with enhanced descriptions
                    Object.entries(modulesByType).forEach(([damageType, modules]) => {
                        if (modules.length > 0) {
                            const group = document.createElement('optgroup');
                            group.label = `${damageType.toUpperCase()} MODULES`;

                            modules.forEach(module => {
                                const option = document.createElement('option');
                                option.value = module.id;
                                option.textContent = `${module.icon} ${module.name} - ${module.tradeOff}`;
                                option.title = module.desc;
                                group.appendChild(option);
                            });

                            attackSelect.appendChild(group);
                        }
                    });

                    const desiredModule = state.attackModule || 'default';
                    attackSelect.value = attackSelect.querySelector(`option[value="${desiredModule}"]`) ? desiredModule : 'default';
                    if (attackSelect.value !== desiredModule) {
                        state.attackModule = attackSelect.value;
                    }
                }

                // Cadence Select
                const cadenceSelect = q('cadenceSelect');
                if (cadenceSelect) {
                    cadenceSelect.innerHTML = '';
                    CHAMPION_CADENCE_LEVELS.forEach((level, index) => {
                        if (index <= (state.cadenceLevel || 0)) {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = level.name;
                            cadenceSelect.appendChild(option);
                        }
                    });
                    const desiredCadence = state.cadenceLevel || 0;
                    cadenceSelect.value = cadenceSelect.querySelector(`option[value="${desiredCadence}"]`) ? desiredCadence : 0;
                    if (parseInt(cadenceSelect.value) !== desiredCadence) {
                        state.cadenceLevel = parseInt(cadenceSelect.value);
                    }
                }

                // Protocol Select
                const protocolSelect = q('protocolSelect');
                if (protocolSelect) {
                    protocolSelect.innerHTML = '';
                    CHAMPION_MINION_PROTOCOL_LEVELS.forEach((level, index) => {
                        if (index <= (state.minionProtocols || 0)) {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = level.name;
                            protocolSelect.appendChild(option);
                        }
                    });
                    const desiredProtocol = state.minionProtocols || 0;
                    protocolSelect.value = protocolSelect.querySelector(`option[value="${desiredProtocol}"]`) ? desiredProtocol : 0;
                    if (parseInt(protocolSelect.value) !== desiredProtocol) {
                        state.minionProtocols = parseInt(protocolSelect.value);
                    }
                }

                // Skin Select
                const skinSelect = q('skinSelect');
                if (skinSelect) {
                    skinSelect.innerHTML = '<option value="default">Void Vanguard</option>';
                    const unlockedSkins = Object.entries(state.unlockedSkins || {})
                        .filter(([skinId, unlocked]) => skinId !== 'default' && !!unlocked)
                        .map(([skinId]) => skinId);
                    unlockedSkins.forEach(skinId => {
                        const skin = CHAMPION_SKIN_OPTION_MAP[skinId];
                        if (skin && !skinSelect.querySelector(`option[value="${skinId}"]`)) {
                            const option = document.createElement('option');
                            option.value = skinId;
                            option.textContent = skin.name;
                            skinSelect.appendChild(option);
                        }
                    });
                    const desiredSkin = state.skin || 'default';
                    skinSelect.value = skinSelect.querySelector(`option[value="${desiredSkin}"]`) ? desiredSkin : 'default';
                    if (skinSelect.value !== desiredSkin) {
                        state.skin = skinSelect.value;
                    }
                }

                updateChampionBuilderDetails();
            }

            function populateChampionUpgradeGrid() {
                const grid = q('championUpgradeGrid');
                if (!grid) return;

                const rawItems = Object.keys(SHOP_UPGRADES)
                    .map(key => {
                        const upgrade = SHOP_UPGRADES[key];
                        if (!upgrade || upgrade.category !== 'champion') return null;
                        if (typeof upgrade.isVisible === 'function' && !upgrade.isVisible()) return null;
                        return { key, upgrade };
                    })
                    .filter(Boolean);

                const currentItems = rawItems.map(item => ({ ...item, info: getNextUpgradeCost(item.key) }));

                grid.innerHTML = '';

                for (const entry of currentItems) {
                    const { key, upgrade, info } = entry;
                    const icon = upgrade.icon ?? 'âš”ï¸';
                    const level = (store.player?.upgradeLevels && store.player.upgradeLevels[key]) || 0;
                    const name = typeof upgrade.getName === 'function' ? upgrade.getName(info, level) : upgrade.name;
                    let desc = typeof upgrade.desc === 'function' ? upgrade.desc(level, info) : upgrade.desc;
                    const costValue = info && Number.isFinite(info.cost) ? info.cost : upgrade.cost;
                    const costText = Number.isFinite(costValue) ? costValue : '---';
                    const available = info ? !!info.available : (Number.isFinite(costValue) && (store.world?.gold ?? 0) >= costValue);
                    const isDisabled = !available;
                    if (isDisabled && info && info.reason) {
                        desc = info.reason;
                    }

                    const div = document.createElement('div');
                    div.className = `upgrade-card ${isDisabled ? 'disabled' : ''}`;
                    div.innerHTML = `
                <div class="upgrade-icon">${icon}</div>
                <div class="upgrade-content">
                    <div class="upgrade-title">${name || ''}</div>
                    <div class="upgrade-desc">${desc || ''}</div>
                    <div class="upgrade-cost">Cost: ${costText}</div>
                </div>
            `;
                    div.addEventListener('click', () => {
                        if (!isDisabled) {
                            attemptPurchaseUpgrade(key);
                            populateChampionUpgradeGrid();
                            populateChampionBuilder();
                            updateChampionPreview();
                            updateChampionStats();
                        }
                    });
                    grid.appendChild(div);
                }
            }

            function getChampionLevelUpCost(currentLevel) {
                // Progressive XP cost for champion levels
                return Math.floor(100 * Math.pow(1.5, currentLevel - 1));
            }

            // Function to refresh laboratory if it's currently open
            function refreshPrimordialSoldierLaboratory() {
                const panel = q("championDressingRoom");
                if (panel && !panel.classList.contains("hide")) {
                    populateChampionBuilder();
                    populateChampionUpgradeGrid();
                    updateChampionPreview();
                    updateChampionStats();
                    resetChampionPresetPanel({ preserveInput: true });
                }
            }

            // Animation loop for champion preview
            let championPreviewAnimationFrame = null;

            function startChampionPreviewAnimation() {
                if (championPreviewAnimationFrame) return; // Already running

                function animate() {
                    const panel = q("championDressingRoom");
                    if (panel && !panel.classList.contains("hide")) {
                        updateChampionPreview();
                        championPreviewAnimationFrame = requestAnimationFrame(animate);
                    } else {
                        championPreviewAnimationFrame = null;
                    }
                }

                animate();
            }

            // Override the showPrimordialSoldierLaboratory function to start animation
            const originalShowPrimordialSoldierLaboratory = showPrimordialSoldierLaboratory;
            showPrimordialSoldierLaboratory = function () {
                originalShowPrimordialSoldierLaboratory();
                startChampionPreviewAnimation();
            };

            function stepPlayerChampion(dt) {
                const champion = store.playerChampion;
                const player = store.player;
                if (!champion || champion.dead || !player) return;

                champion.auraPulse = (champion.auraPulse || 0) + dt * 2.4;
                if (champion.dashCooldownTimer > 0) {
                    champion.dashCooldownTimer -= dt;
                }

                const hadTarget = !!(champion.currentTarget && !champion.currentTarget.dead && champion.currentTarget.hp > 0);
                const fireTimerBase = champion.fireTimer ?? champion.fireCooldown ?? PLAYER_CHAMPION_CONFIG.baseFireCooldown;
                champion.fireTimer = Math.max(0, fireTimerBase - dt);
                const combatProfile = ensureChampionCombatProfile(champion);
                if (combatProfile && Array.isArray(combatProfile.specials)) {
                    combatProfile.specials.forEach(special => {
                        if (!special) return;
                        special.timer = Math.max(0, (special.timer ?? 0) - dt);
                    });
                }

                const target = resolveChampionTarget(champion);
                if (!hadTarget && target && champion.fireTimer > 0.15) {
                    champion.fireTimer = Math.min(champion.fireTimer, 0.15);
                }

                if (target) {
                    champion.visualAim = Math.atan2(target.y - champion.y, target.x - champion.x);
                } else if (champion.roamAnchor) {
                    champion.visualAim = Math.atan2(champion.roamAnchor.y - champion.y, champion.roamAnchor.x - champion.x);
                } else {
                    const dx = champion.x - player.x;
                    const dy = champion.y - player.y;
                    champion.visualAim = Math.atan2(dy, dx);
                }

                const dashActive = champion.state === 'dash' || champion.state === 'special_charge';
                champion.swirlPhase = (champion.swirlPhase || 0) + dt * (dashActive ? 9 : 5.4);
                if (champion.swirlPhase > Math.PI * 2) champion.swirlPhase -= Math.PI * 2;

                // Handle laser beam damage over time
                if (champion.laserTimer > 0) {
                    champion.laserTimer -= dt;
                    if (champion.laserTarget && !champion.laserTarget.dead && champion.laserDamage) {
                        championDealDamage(champion.laserTarget, champion.laserDamage * dt * 2, { x: champion.x, y: champion.y });
                    }
                    if (champion.laserTimer <= 0) {
                        champion.laserTarget = null;
                        champion.laserDamage = 0;
                    }
                }

                const marginX = champion.r || 18;
                const marginY = champion.r || 18;
                const clampAnchor = (x, y) => ({
                    x: clamp(x, marginX, W - marginX),
                    y: clamp(y, marginY, H - marginY)
                });

                if (!champion.roamAnchor) {
                    champion.roamAnchor = clampAnchor(player.x, player.y - 120);
                    champion.roamMode = 'idle';
                    champion.roamTimer = 0;
                } else {
                    champion.roamAnchor = clampAnchor(champion.roamAnchor.x, champion.roamAnchor.y);
                }

                champion.roamTimer = (champion.roamTimer || 0) - dt;

                if (target) {
                    if (champion.roamMode !== 'target' || champion.roamTimer <= 0) {
                        const baseRadius = Math.max(120, Math.min(210, champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius));
                        const offsetAngle = Math.random() * Math.PI * 2;
                        const offsetDist = baseRadius * (0.4 + Math.random() * 0.8);
                        const anchorX = target.x + Math.cos(offsetAngle) * offsetDist;
                        const anchorY = target.y + Math.sin(offsetAngle) * offsetDist * 0.65;
                        champion.roamAnchor = clampAnchor(anchorX, anchorY);
                        champion.roamMode = 'target';
                        champion.roamTimer = 1.1 + Math.random() * 1.8;
                    }
                } else if (champion.roamMode !== 'idle' || champion.roamTimer <= 0) {
                    const px = clamp(player.x, 80, W - 80);
                    const py = clamp(player.y - 140, 80, H - 160);
                    const idleAngle = Math.random() * Math.PI * 2;
                    const idleDist = 140 + Math.random() * 160;
                    const anchorX = px + Math.cos(idleAngle) * idleDist;
                    const anchorY = py + Math.sin(idleAngle) * 90;
                    champion.roamAnchor = clampAnchor(anchorX, anchorY);
                    champion.roamMode = 'idle';
                    champion.roamTimer = 2.4 + Math.random() * 1.8;
                }

                if (dashActive) {
                    champion.dashTimer -= dt;
                    if (champion.dashVX || champion.dashVY) {
                        champion.visualAim = Math.atan2(champion.dashVY || 0, champion.dashVX || 0);
                    }
                    champion.x += (champion.dashVX || 0) * dt;
                    champion.y += (champion.dashVY || 0) * dt;
                    champion.echoCooldown = (champion.echoCooldown || 0) - dt;
                    if ((champion.echoCooldown || 0) <= 0) {
                        addShadowEcho(champion.x, champion.y);
                        champion.echoCooldown = 0.035;
                    }

                    const dashRadius = (champion.r || 20) + (champion.state === 'special_charge' ? 10 : 6);
                    const damage = champion.state === 'special_charge' && champion.chargeDamage ?
                        champion.chargeDamage :
                        (120 + (champion.level || 1) * 28) * (player.dmgMult || 1) * (champion.damageScale || 1);

                    if (!champion.dashHits) champion.dashHits = new Set();

                    if (store.boss && !store.boss.dead) {
                        const boss = store.boss;
                        const dx = boss.x - champion.x;
                        const dy = boss.y - champion.y;
                        const hitRadius = (boss.r || 70) + dashRadius;
                        if (dx * dx + dy * dy <= hitRadius * hitRadius && !champion.dashHits.has('boss')) {
                            championDealDamage(boss, damage, { x: champion.x, y: champion.y });
                            champion.dashHits.add('boss');
                            store.activeEffects.push(createEffect('hitSpark', boss.x, boss.y, boss.r || 60, { strength: 90 }));
                        }
                    }

                    forEachEnemyNearby(champion.x, champion.y, dashRadius + 48, enemy => {
                        if (!enemy || enemy.dead) return false;
                        if (enemy.id && champion.dashHits.has(enemy.id)) return false;
                        const dx = enemy.x - champion.x;
                        const dy = enemy.y - champion.y;
                        const hitRadius = (enemy.r || 18) + dashRadius;
                        if (dx * dx + dy * dy <= hitRadius * hitRadius) {
                            championDealDamage(enemy, damage, { x: champion.x, y: champion.y });
                            if (enemy.id) champion.dashHits.add(enemy.id);
                            store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, enemy.r || 18, { strength: 65 }));
                        }
                        return false;
                    });

                    if (champion.dashTimer <= 0) {
                        champion.state = null;
                        champion.dashVX = 0;
                        champion.dashVY = 0;
                        champion.dashHits = null;
                    }
                } else {
                    const guardRadius = Math.max(100, champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius);
                    const orbitAspect = 0.55 + Math.min(0.25, (champion.level || 1) * 0.04);
                    champion.guardAngle = (champion.guardAngle || Math.random() * Math.PI * 2) + (champion.angularSpeed || 1.2) * dt * (target ? 1.2 : 0.85);
                    const desiredX = champion.roamAnchor.x + Math.cos(champion.guardAngle) * guardRadius;
                    const desiredY = champion.roamAnchor.y + Math.sin(champion.guardAngle) * guardRadius * orbitAspect;
                    const followFactor = Math.min(1, (champion.momentum || 4.3) * dt);
                    champion.x += (desiredX - champion.x) * followFactor;
                    champion.y += (desiredY - champion.y) * followFactor * 0.92;

                    if (target) {
                        const dx = target.x - champion.x;
                        const dy = target.y - champion.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        if (dist > 420) {
                            const chase = Math.min(220, (dist - 420) * 0.6);
                            champion.x += (dx / dist) * chase * dt;
                            champion.y += (dy / dist) * chase * dt * 0.85;
                        }
                    }

                    if (target && champion.fireTimer <= 0) {
                        const dx = target.x - champion.x;
                        const dy = target.y - champion.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const canDash = (champion.dashCooldownTimer || 0) <= 0 && dist <= 420;
                        const dashChance = dist <= 220 ? 0.65 : dist <= 320 ? 0.45 : 0.28;

                        if (canDash && Math.random() < dashChance) {
                            const dashSpeed = 480 + (champion.level || 1) * 55;
                            champion.state = 'dash';
                            champion.dashTimer = 0.32;
                            champion.dashDuration = 0.32;
                            champion.dashVX = (dx / dist) * dashSpeed;
                            champion.dashVY = (dy / dist) * dashSpeed;
                            champion.dashCooldownTimer = champion.dashCooldown || PLAYER_CHAMPION_CONFIG.baseDashCooldown;
                            champion.visualAim = Math.atan2(champion.dashVY, champion.dashVX);
                            champion.dashHits = new Set();
                            champion.echoCooldown = 0;
                            addShadowEcho(champion.x, champion.y);
                            champion.fireTimer = 0.4;
                        } else {
                            const targetTraits = classifyEnemyForChampionVulnerabilities(target);
                            const nearbyCount = countEnemiesAround(target.x, target.y, 220);
                            const selectedSpecial = selectChampionSpecialAbility(champion, target, {
                                targetTraits,
                                nearbyCount,
                                scanRadius: 240
                            });

                            if (selectedSpecial) {
                                executeChampionAbility(champion, selectedSpecial, {
                                    target,
                                    targetTraits,
                                    nearbyCount,
                                    ability: selectedSpecial,
                                    vulnerabilityProfile: selectedSpecial.vulnerabilities || null
                                });
                            } else {
                                executeChampionPrimary(champion, target, {
                                    ability: combatProfile?.primary,
                                    targetTraits,
                                    vulnerabilityProfile: combatProfile?.primary?.vulnerabilities || null
                                });
                            }
                        }
                    }
                }

                champion.x = clamp(champion.x, marginX, W - marginX);
                champion.y = clamp(champion.y, marginY, H - marginY);
            }

            function stepChampionMinions(dt) {
                if (!store.championMinions || store.championMinions.length === 0) return;
                const owner = store.playerChampion;
                if (!owner || owner.dead) {
                    store.championMinions.length = 0;
                    return;
                }

                for (let i = store.championMinions.length - 1; i >= 0; i--) {
                    const minion = store.championMinions[i];
                    if (!minion || minion.dead) {
                        store.championMinions.splice(i, 1);
                        continue;
                    }

                    minion.orbitAngle += (minion.orbitSpeed || 1.6) * dt;
                    minion.pulsePhase = (minion.pulsePhase || 0) + dt * 3.1;
                    const radius = minion.orbitRadius * (1 + Math.sin(minion.pulsePhase) * 0.03);
                    const targetX = owner.x + Math.cos(minion.orbitAngle) * radius;
                    const targetY = owner.y + Math.sin(minion.orbitAngle) * radius * 0.55;
                    minion.x += (targetX - minion.x) * Math.min(1, 10 * dt);
                    minion.y += (targetY - minion.y) * Math.min(1, 10 * dt);

                    const desiredCooldown = Math.max(0.75, 1.4 - (owner.level || 1) * 0.12);
                    minion.fireCooldown += (desiredCooldown - minion.fireCooldown) * Math.min(1, dt * 3);
                    minion.damageScale = 1 + ((owner.level || 1) - 1) * 0.18;

                    const hadTarget = !!(minion.currentTarget && !minion.currentTarget.dead && minion.currentTarget.hp > 0);
                    const fireBase = minion.fireTimer ?? minion.fireCooldown ?? desiredCooldown;
                    minion.fireTimer = Math.max(0, fireBase - dt);

                    const target = resolveChampionTarget(minion, { stickRange: 520, lingerMs: 220 });
                    if (!hadTarget && target && minion.fireTimer > 0.2) {
                        minion.fireTimer = Math.min(minion.fireTimer, 0.2);
                    }
                    if (minion.fireTimer <= 0 && target) {
                        const angle = Math.atan2(target.y - minion.y, target.x - minion.x);
                        const speed = 340 + (owner.level || 1) * 30;
                        const damage = (18 + (owner.level || 1) * 6) * (store.player?.dmgMult || 1) * (minion.damageScale || 1);
                        const abilityModule = minion.abilityModule || owner.attackModule || getChampionUpgradeState().attackModule || 'default';
                        const abilityTheme = minion.abilityTheme || getChampionMinionAbilityTheme(abilityModule);
                        const projectileColor = abilityTheme?.trail || abilityTheme?.ring || '#cdd0ff';
                        const bullet = spawnBullet({
                            x: minion.x,
                            y: minion.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 4,
                            col: projectileColor,
                            dmg: damage,
                            life: 1.6,
                            pierce: owner.level >= 4,
                            isChampionShot: true,
                            championAttackModule: owner.attackModule || getChampionUpgradeState().attackModule || 'default',
                            championLevel: owner.level || 1,
                            fromChampionMinion: true,
                            minionProtocolLevel: minion.protocolLevel || 0,
                            minionProtocolSlowFactor: minion.protocolSlowFactor ?? null,
                            minionProtocolNovaDamageScale: minion.protocolNovaDamageScale || 0
                        });
                        bullet.collisionSearchRadius = 150;
                        minion.fireTimer = minion.fireCooldown + Math.random() * 0.1;
                    }
                }
            }

            function createHound(side, isMini = false) {
                const isTuxedo = side === -1 || side === -2;
                let color = isTuxedo ? { main: '#222222', accent: '#FFFFFF' } : { main: '#F0E68C', accent: '#BDB76B' };

                let isUpgraded = false;
                let eyeType = 'normal';
                let expression = 'normal';
                let breed = 'standard';
                let eyeConfig = null;
                let radius = isMini ? 8 : 12; // Mini hounds are smaller

                if (Math.abs(side) > 1) {
                    isUpgraded = true;
                    if (side === -2) {
                        color = { main: '#c4b5a0', accent: '#333' };
                        eyeType = 'swirly';
                        expression = 'silly';
                    } else if (side === 2) {
                        color = { main: '#ffb366', accent: '#000' };
                        eyeType = 'dilated';
                        expression = 'mischievous';
                    } else if (side === 3 || side === 4) {
                        breed = 'bernese';
                        color = { main: '#1C1C1C', accent: '#FFFFFF', tan: '#6E4C2E' };
                        radius = isMini ? 10 : 14; // Mini bernese are smaller too
                        if (side === 3) {
                            eyeType = 'heterochromia';
                            eyeConfig = { type: 'heterochromia', colors: ['#5DADE2', '#8B4513'] };
                        } else {
                            eyeType = 'swirly';
                            eyeConfig = { type: 'swirly' };
                        }
                        expression = 'loyal';
                    }
                }

                return {
                    x: store.player.x + 50 * side,
                    y: store.player.y + 20,
                    side,
                    target: null,
                    attackT: 0,
                    r: radius,
                    killCount: 0,
                    color,
                    isUpgraded,
                    eyeType,
                    eyeConfig,
                    expression,
                    breed,
                    isMini
                };
            }
            function stepHounds(dt) { if (!store.player.hasHounds) return; store.hounds.forEach(h => { if (!h.target || h.target.dead || h.target.hp <= 0) { let closest = null, closestDist = Infinity; const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies; potentialTargets.forEach(e => { if (e.dead || e.hp <= 0) return; const dist = (h.x - e.x) ** 2 + (h.y - e.y) ** 2; if (dist < closestDist) { closestDist = dist; closest = e; } }); h.target = closest; } if (h.target) { const tx = h.target.x, ty = h.target.y; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); const speed = 350; if (dist > 30) { h.x += (dx / dist) * speed * dt; h.y += (dy / dist) * speed * dt; } else { h.attackT -= dt; if (h.attackT <= 0) { h.attackT = 0.25; let dmg = 8 * store.player.dmgMult; if (h.target === store.boss) dmg *= 0.3; if (!h.target.dead && h.target.hp > 0) { h.target.hp -= dmg; if (store.player.vampirism > 0) { let healAmount = dmg * store.player.vampirism; healAmount = Math.max(healAmount, 0.5); healAmount = Math.min(healAmount, 2); store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount); } if (h.target.hp <= 0) { h.killCount++; if (h.killCount > 0 && h.killCount % 12 === 0) { playSound('dogs'); } } } } } } else { const tx = store.player.x + h.side * 50, ty = store.player.y + 20; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 5) { h.x += dx * 5 * dt; h.y += dy * 5 * dt; } } }); }

            function stepVoidRifts(dt) {
                if (!store.voidRifts || !store.voidRifts.length) return;
                const player = store.player;
                for (let i = store.voidRifts.length - 1; i >= 0; i--) {
                    const rift = store.voidRifts[i];
                    if (!rift) {
                        store.voidRifts.splice(i, 1);
                        continue;
                    }
                    rift.life -= dt;
                    if (rift.life <= 0 || rift.dead) {
                        store.voidRifts.splice(i, 1);
                        continue;
                    }
                    
                    // Damage player if standing in rift
                    rift.damageTimer -= dt;
                    if (rift.damageTimer <= 0) {
                        rift.damageTimer = 0.3;
                        const dx = player.x - rift.x;
                        const dy = player.y - rift.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= rift.r + (player.r || 18)) {
                            takeDamage(rift.damage);
                        }
                    }
                }
            }

            function stepShadowHounds(dt) {
                if (!store.shadowHounds || !store.shadowHounds.length) return;
                const player = store.player;
                for (let i = store.shadowHounds.length - 1; i >= 0; i--) {
                    const h = store.shadowHounds[i];
                    if (!h) {
                        store.shadowHounds.splice(i, 1);
                        continue;
                    }
                    h.life -= dt;
                    if (h.life <= 0 || h.dead) {
                        store.shadowHounds.splice(i, 1);
                        continue;
                    }
                    h.attackCooldown = Math.max(0, h.attackCooldown - dt);
                    h.wobble += dt * 3.4;
                    const targetOffsetX = Math.sin(h.wobble) * 16;
                    const targetOffsetY = Math.cos(h.wobble * 0.7) * 12;
                    const targetX = clamp(player.x + targetOffsetX, 20, W - 20);
                    const targetY = clamp(player.y + targetOffsetY, 40, H - 40);
                    const dx = targetX - h.x;
                    const dy = targetY - h.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const step = Math.min(dist, h.speed * dt);
                    h.x += (dx / dist) * step;
                    h.y += (dy / dist) * step;

                    const px = player.x - h.x;
                    const py = player.y - h.y;
                    const hitRadius = (player.r || 18) + 10;
                    if (px * px + py * py <= hitRadius * hitRadius && h.attackCooldown <= 0) {
                        takeDamage(h.damage);
                        h.attackCooldown = 0.7;
                    }
                }
            }
            function drawBerneseGhostHound(ctx, r, eyeConfig, timeMs) {
                ctx.save();

                const now = typeof timeMs === 'number' ? timeMs : performance.now();
                const anim = now * 0.001;
                const auraRadius = r * 2.2;

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.32;
                const auraGradient = ctx.createRadialGradient(0, 0, r * 0.4, 0, 0, auraRadius);
                auraGradient.addColorStop(0, 'rgba(210, 230, 255, 0.9)');
                auraGradient.addColorStop(0.6, 'rgba(140, 170, 255, 0.25)');
                auraGradient.addColorStop(1, 'rgba(110, 150, 255, 0)');
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                const bodyAlpha = 0.88;

                // Main body silhouette
                ctx.globalAlpha = bodyAlpha;
                ctx.fillStyle = 'rgba(28, 28, 36, 0.9)';
                ctx.beginPath();
                ctx.moveTo(-r, -r * 0.5);
                ctx.quadraticCurveTo(0, -r * 1.55, r, -r * 0.5);
                ctx.quadraticCurveTo(r * 1.28, 0, r, r * 1.08);
                ctx.quadraticCurveTo(0, r * 1.38, -r, r * 1.08);
                ctx.quadraticCurveTo(-r * 1.28, 0, -r, -r * 0.5);
                ctx.closePath();
                ctx.fill();

                // White chest blaze
                ctx.globalAlpha = 0.85;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.92)';
                ctx.beginPath();
                ctx.moveTo(-r * 0.7, r * 0.42);
                ctx.quadraticCurveTo(0, r * 1.25, r * 0.7, r * 0.42);
                ctx.lineTo(r * 0.45, -r * 0.15);
                ctx.quadraticCurveTo(0, r * 0.18, -r * 0.45, -r * 0.15);
                ctx.closePath();
                ctx.fill();

                // Brown cheek and eyebrow markings
                ctx.globalAlpha = 0.86;
                ctx.fillStyle = 'rgba(110, 76, 46, 0.9)';
                ctx.beginPath();
                ctx.arc(-r * 0.4, -r * 0.7, r * 0.16, 0, Math.PI * 2);
                ctx.arc(r * 0.4, -r * 0.7, r * 0.16, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(-r * 0.6, r * 0.1, r * 0.26, 0, Math.PI * 2);
                ctx.arc(r * 0.6, r * 0.1, r * 0.26, 0, Math.PI * 2);
                ctx.fill();

                // Floppy ears
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = 'rgba(22, 22, 30, 0.95)';
                ctx.beginPath();
                ctx.moveTo(-r, -r * 0.42);
                ctx.lineTo(-r * 0.5, -r * 1.28);
                ctx.lineTo(-r * 1.18, -r * 1.02);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(r, -r * 0.42);
                ctx.lineTo(r * 0.5, -r * 1.28);
                ctx.lineTo(r * 1.18, -r * 1.02);
                ctx.closePath();
                ctx.fill();

                // Snout blaze
                ctx.globalAlpha = 0.94;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.92)';
                ctx.beginPath();
                ctx.moveTo(0, -r * 0.62);
                ctx.quadraticCurveTo(-r * 0.12, 0, 0, r * 0.22);
                ctx.quadraticCurveTo(r * 0.12, 0, 0, -r * 0.62);
                ctx.fill();

                // Nose
                ctx.globalAlpha = 0.95;
                ctx.fillStyle = 'rgba(26, 26, 32, 0.95)';
                ctx.beginPath();
                ctx.moveTo(-r * 0.16, r * 0.22);
                ctx.lineTo(r * 0.16, r * 0.22);
                ctx.lineTo(0, r * 0.35);
                ctx.closePath();
                ctx.fill();

                // Eyes
                const scleraRadius = r * 0.22;
                const pupilRadius = scleraRadius * 0.6;
                const eyeY = -r * 0.24;
                const step = Math.PI * 4 / 26;
                const eyeType = eyeConfig?.type || 'normal';

                ctx.globalAlpha = 0.98;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.arc(-r * 0.4, eyeY, scleraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(r * 0.4, eyeY, scleraRadius, 0, Math.PI * 2);
                ctx.fill();

                if (eyeType === 'heterochromia' && Array.isArray(eyeConfig?.colors)) {
                    ctx.fillStyle = eyeConfig.colors[0] || '#5DADE2';
                    ctx.beginPath();
                    ctx.arc(-r * 0.4, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = eyeConfig.colors[1] || '#8B4513';
                    ctx.beginPath();
                    ctx.arc(r * 0.4, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (eyeType === 'swirly') {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.lineWidth = Math.max(0.6, r * 0.035);
                    ctx.beginPath();
                    for (let t = 0; t <= Math.PI * 4; t += step) {
                        const radiusFactor = t * r * 0.015;
                        const sx = -r * 0.4 + Math.cos(t + anim * 2) * radiusFactor;
                        const sy = eyeY + Math.sin(t + anim * 2) * radiusFactor;
                        if (t === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();

                    ctx.beginPath();
                    for (let t = 0; t <= Math.PI * 4; t += step) {
                        const radiusFactor = t * r * 0.015;
                        const sx = r * 0.4 + Math.cos(t - anim * 2.2) * radiusFactor;
                        const sy = eyeY + Math.sin(t - anim * 2.2) * radiusFactor;
                        if (t === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'rgba(12, 12, 18, 0.9)';
                    ctx.beginPath();
                    ctx.arc(-r * 0.4, eyeY, pupilRadius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(r * 0.4, eyeY, pupilRadius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Mouth and tongue
                ctx.globalAlpha = 0.92;
                ctx.fillStyle = 'rgba(255, 110, 170, 0.85)';
                ctx.beginPath();
                ctx.moveTo(0, r * 0.4);
                ctx.quadraticCurveTo(r * 0.22, r * 0.78, 0, r * 0.84);
                ctx.quadraticCurveTo(-r * 0.22, r * 0.78, 0, r * 0.4);
                ctx.fill();

                ctx.strokeStyle = 'rgba(20, 20, 28, 0.95)';
                ctx.lineWidth = Math.max(0.6, r * 0.05);
                ctx.beginPath();
                ctx.arc(0, r * 0.35, r * 0.22, 0, Math.PI);
                ctx.stroke();

                // Soft highlights
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = 'rgba(240, 250, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-r * 0.2, -r * 0.2, r * 0.4, r * 0.18, 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawHound(h) {
                ctx.save();
                ctx.translate(h.x, h.y);
                const time = performance.now();
                ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time / 1000 + h.side);
                let r = h.r;

                // Make the 4th dog (tanish orange one with regular pupils) half size
                if (h.side === 2) {
                    r = r * 0.5;
                }

                if (!h.isUpgraded) {
                    const { main, accent } = h.color;
                    const isTuxedo = accent === '#FFFFFF';

                    ctx.fillStyle = main;
                    ctx.beginPath();
                    ctx.moveTo(-r, -r * 0.5);
                    ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
                    ctx.quadraticCurveTo(r * 1.2, 0, r, r);
                    ctx.lineTo(-r, r);
                    ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = isTuxedo ? main : accent;
                    ctx.beginPath();
                    ctx.moveTo(-r, -r * 0.4);
                    ctx.lineTo(-r * 0.5, -r * 1.2);
                    ctx.lineTo(-r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r, -r * 0.4);
                    ctx.lineTo(r * 0.5, -r * 1.2);
                    ctx.lineTo(r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();

                    if (isTuxedo) {
                        ctx.fillStyle = accent;
                        ctx.beginPath();
                        ctx.moveTo(-r * 0.6, r * 0.2);
                        ctx.quadraticCurveTo(0, r, r * 0.6, r * 0.2);
                        ctx.lineTo(0, r * 0.5);
                        ctx.closePath();
                        ctx.fill();
                    }

                    ctx.fillStyle = "#FFF";
                    ctx.beginPath();
                    ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = "#000";
                    ctx.beginPath();
                    ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = isTuxedo ? main : accent;
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.3, r * 0.5, r * 0.4, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = "#FFF";
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, r * 0.5);
                    ctx.lineTo(-r * 0.1, r * 0.5);
                    ctx.lineTo(-r * 0.2, r * 0.9);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, r * 0.5);
                    ctx.lineTo(r * 0.1, r * 0.5);
                    ctx.lineTo(r * 0.2, r * 0.9);
                    ctx.closePath();
                    ctx.fill();
                } else if (h.breed === 'bernese') {
                    drawBerneseGhostHound(ctx, r, h.eyeConfig || { type: h.eyeType }, time);
                } else {
                    const color = h.color.main;
                    const opacity = ctx.globalAlpha;
                    const eyeType = h.eyeType;
                    const expression = h.expression;
                    const radius = r * 1.5;

                    if (h.side === 2) {
                        ctx.save();
                        ctx.globalAlpha = 0.7 * opacity;
                        ctx.fillStyle = '#9966ff';
                        ctx.beginPath();
                        ctx.moveTo(0, -radius * 1.8);
                        ctx.lineTo(-radius * 0.8, -radius * 0.9);
                        ctx.lineTo(radius * 0.8, -radius * 0.9);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-radius * 0.6, -radius * 0.7);
                    ctx.lineTo(-radius * 0.4, -radius * 1.2);
                    ctx.lineTo(-radius * 0.2, -radius * 0.8);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(radius * 0.6, -radius * 0.7);
                    ctx.lineTo(radius * 0.4, -radius * 1.2);
                    ctx.lineTo(radius * 0.2, -radius * 0.8);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-radius, 0);
                    for (let i = 0; i <= 6; i++) {
                        let waveX = -radius + (radius * 2 / 6) * i;
                        let waveY = radius + Math.sin(i * 0.8 + time * 0.005) * radius * 0.2;
                        ctx.lineTo(waveX, waveY);
                    }
                    ctx.lineTo(radius, 0);
                    ctx.fill();

                    ctx.fillStyle = 'white';

                    if (eyeType === 'dilated') {
                        ctx.beginPath();
                        ctx.ellipse(-radius * 0.35, -radius * 0.1, radius * 0.28, radius * 0.35, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.ellipse(radius * 0.35, -radius * 0.15, radius * 0.25, radius * 0.32, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(-radius * 0.3 + Math.sin(time * 0.001) * radius * 0.05,
                            -radius * 0.05, radius * 0.08, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(radius * 0.4,
                            -radius * 0.2 + Math.cos(time * 0.001) * radius * 0.05,
                            radius * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                    } else { // 'swirly'
                        ctx.beginPath();
                        ctx.arc(-radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = radius * 0.04;

                        ctx.beginPath();
                        for (let t = 0; t < Math.PI * 4; t += 0.1) {
                            let r_swirl = t * radius * 0.02;
                            let sx = -radius * 0.35 + Math.cos(t + time * 0.001) * r_swirl;
                            let sy = -radius * 0.1 + Math.sin(t + time * 0.001) * r_swirl;
                            if (t === 0) ctx.moveTo(sx, sy);
                            else ctx.lineTo(sx, sy);
                        }
                        ctx.stroke();

                        ctx.beginPath();
                        for (let t = 0; t < Math.PI * 4; t += 0.1) {
                            let r_swirl = t * radius * 0.02;
                            let sx = radius * 0.35 + Math.cos(t - time * 0.001) * r_swirl;
                            let sy = -radius * 0.1 + Math.sin(t - time * 0.001) * r_swirl;
                            if (t === 0) ctx.moveTo(sx, sy);
                            else ctx.lineTo(sx, sy);
                        }
                        ctx.stroke();
                    }

                    ctx.fillStyle = 'white';

                    ctx.beginPath();
                    ctx.moveTo(-radius * 0.25, radius * 0.2);
                    ctx.lineTo(-radius * 0.2, radius * 0.5);
                    ctx.lineTo(-radius * 0.15, radius * 0.2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(radius * 0.25, radius * 0.2);
                    ctx.lineTo(radius * 0.2, radius * 0.5);
                    ctx.lineTo(radius * 0.15, radius * 0.2);
                    ctx.fill();

                    for (let i = -1; i <= 1; i++) {
                        if (i === 0) continue;
                        ctx.beginPath();
                        ctx.moveTo(i * radius * 0.08, radius * 0.2);
                        ctx.lineTo(i * radius * 0.08 + radius * 0.02, radius * 0.35);
                        ctx.lineTo(i * radius * 0.08 - radius * 0.02, radius * 0.35);
                        ctx.fill();
                    }

                    ctx.strokeStyle = expression === 'silly' ? '#000' : '#333';
                    ctx.lineWidth = radius * 0.03;
                    ctx.beginPath();

                    if (expression === 'silly') {
                        ctx.moveTo(-radius * 0.3, radius * 0.15);
                        ctx.quadraticCurveTo(-radius * 0.1, radius * 0.05, 0, radius * 0.15);
                        ctx.quadraticCurveTo(radius * 0.1, radius * 0.25, radius * 0.3, radius * 0.15);
                    } else {
                        ctx.arc(0, 0, radius * 0.35, Math.PI * 0.2, Math.PI * 0.8);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawVoidRift(rift) {
                ctx.save();
                ctx.translate(rift.x, rift.y);
                const time = performance.now() / 1000;
                const lifeRatio = Math.max(0, Math.min(1, rift.life / rift.maxLife));
                const pulse = 0.6 + 0.4 * Math.sin(time * 4);
                const rotation = time * 0.5;

                // Outer swirling void
                ctx.globalAlpha = 0.4 * lifeRatio;
                const outerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, rift.r * 1.3);
                outerGrad.addColorStop(0, 'rgba(80, 40, 120, 0.8)');
                outerGrad.addColorStop(0.5, 'rgba(40, 20, 80, 0.6)');
                outerGrad.addColorStop(1, 'rgba(20, 10, 40, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(0, 0, rift.r * 1.3 * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Inner void core
                ctx.globalAlpha = 0.7 * lifeRatio;
                ctx.rotate(rotation);
                const innerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, rift.r);
                innerGrad.addColorStop(0, 'rgba(140, 80, 180, 0.9)');
                innerGrad.addColorStop(0.6, 'rgba(80, 40, 120, 0.7)');
                innerGrad.addColorStop(1, 'rgba(40, 20, 80, 0.2)');
                ctx.fillStyle = innerGrad;
                ctx.beginPath();
                ctx.arc(0, 0, rift.r, 0, Math.PI * 2);
                ctx.fill();

                // Swirl pattern
                ctx.strokeStyle = `rgba(180, 140, 220, ${0.5 * lifeRatio})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, rift.r * 0.7, angle, angle + Math.PI * 0.6);
                    ctx.stroke();
                }

                ctx.restore();
            }

            function drawShadowHound(h) {
                ctx.save();
                ctx.translate(h.x, h.y);
                const time = performance.now() / 1000;
                const lifeRatio = h.maxLife ? Math.max(0, Math.min(1, h.life / h.maxLife)) : 1;
                const pulse = 0.5 + 0.4 * Math.sin(time * 6 + h.wobble);

                ctx.globalAlpha = 0.55 + 0.35 * lifeRatio;

                const bodyWidth = 18;
                const bodyHeight = 12;

                const gradient = ctx.createRadialGradient(0, 0, bodyHeight * 0.4, 0, 0, bodyWidth);
                gradient.addColorStop(0, `rgba(35, 38, 62, ${0.9})`);
                gradient.addColorStop(1, `rgba(18, 20, 34, ${0.9 * lifeRatio})`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(205, 211, 255, ${0.8})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowColor = 'rgba(120, 130, 220, 0.7)';
                ctx.shadowBlur = 18 * lifeRatio;
                ctx.fillStyle = `rgba(200, 210, 255, ${0.55 + pulse * 0.25})`;
                ctx.beginPath();
                ctx.arc(-6, -2, 3, 0, Math.PI * 2);
                ctx.arc(6, -2, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#2a2f4e';
                ctx.beginPath();
                ctx.moveTo(-bodyWidth * 0.25, bodyHeight * 0.2);
                ctx.lineTo(-bodyWidth * 0.45, bodyHeight * 0.95);
                ctx.lineTo(-bodyWidth * 0.28, bodyHeight * 0.95);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(bodyWidth * 0.25, bodyHeight * 0.2);
                ctx.lineTo(bodyWidth * 0.45, bodyHeight * 0.95);
                ctx.lineTo(bodyWidth * 0.28, bodyHeight * 0.95);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = `rgba(150, 160, 240, ${0.8})`;
                ctx.lineWidth = 1.4;
                ctx.beginPath();
                ctx.moveTo(-bodyWidth * 0.6, -bodyHeight * 0.2);
                ctx.quadraticCurveTo(-bodyWidth * 0.1, -bodyHeight * 0.9, 0, -bodyHeight * 0.4);
                ctx.quadraticCurveTo(bodyWidth * 0.1, -bodyHeight * 0.9, bodyWidth * 0.6, -bodyHeight * 0.2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(bodyWidth * 0.4, -bodyHeight * 0.05);
                ctx.quadraticCurveTo(bodyWidth * 0.9, -bodyHeight * 0.4, bodyWidth * 0.7, bodyHeight * 0.2);
                ctx.stroke();

                ctx.restore();
            }

            function drawChampionMinion(minion, owner) {
                if (!minion) return;
                const level = owner?.level || 1;
                const baseRadius = 6 + Math.min(level, 3);
                const now = performance.now() / 1000;
                const pulse = 0.6 + 0.35 * Math.sin(now * 6 + (minion.pulsePhase || 0));
                const swirl = now * 5.2 + (minion.swirlPhase || 0);
                const fireCooldown = Math.max(0.12, minion.fireCooldown || 0.6);
                const fireRatio = Math.max(0, Math.min(1, (minion.fireTimer || 0) / fireCooldown));

                const upgrades = getChampionUpgradeState();
                const abilityModule = minion.abilityModule || owner?.attackModule || (upgrades ? upgrades.attackModule : 'default') || 'default';
                const abilityTheme = minion.abilityTheme || getChampionMinionAbilityTheme(abilityModule);
                const fallbackSkin = owner?.skinTheme?.minion || (upgrades ? getChampionSkinTheme(upgrades.skin).minion : getChampionSkinTheme('default').minion);
                const skinTheme = minion.skinTheme || fallbackSkin || {};

                const auraTheme = abilityTheme.aura || {};
                const tailTheme = abilityTheme.tail || {};
                const thrusterTheme = abilityTheme.thruster || {};
                const coreTheme = abilityTheme.core || {};
                const swirlPrimary = abilityTheme.swirlPrimary || withAlpha(skinTheme.aura || '#82a7ff', 0.75);
                const swirlSecondary = abilityTheme.swirlSecondary || withAlpha(skinTheme.trail || '#4362a8', 0.6);
                const highlightFill = abilityTheme.highlight || withAlpha(skinTheme.core || '#bcd4ff', 0.9);
                const ringColor = abilityTheme.ring || withAlpha(skinTheme.aura || '#82a7ff', level >= 5 ? 0.9 : 0.8);
                const thrusterInner = thrusterTheme.inner || withAlpha(skinTheme.aura || '#82a7ff', 0.85);
                const thrusterOuter = thrusterTheme.outer || 'rgba(20, 40, 80, 0)';
                const trailColor = abilityTheme.trail || skinTheme.trail || '#4362a8';
                const tailStart = tailTheme.start || withAlpha(trailColor, 0);
                const tailMid = tailTheme.mid || withAlpha(trailColor, 0.35);
                const tailEnd = tailTheme.end || withAlpha(trailColor, 0.75);
                const auraInner = auraTheme.inner || withAlpha(skinTheme.aura || '#82a7ff', 0.78);
                const auraMid = auraTheme.mid || withAlpha(skinTheme.aura || '#82a7ff', 0.5);
                const auraOuter = auraTheme.outer || 'rgba(20, 40, 80, 0)';
                const coreInner = coreTheme.inner || skinTheme.core || '#f2f6ff';
                const coreMid = coreTheme.mid || withAlpha(skinTheme.core || '#bcd4ff', 0.9);
                const coreOuter = coreTheme.outer || withAlpha(skinTheme.trail || '#4362a8', 0.95);
                const coreEdge = coreTheme.edge || withAlpha(trailColor, 1);

                ctx.save();
                ctx.translate(minion.x, minion.y);

                if (owner) {
                    const angleToOwner = Math.atan2(owner.y - minion.y, owner.x - minion.x);
                    const tailLength = baseRadius * (2.2 + level * 0.35);

                    ctx.save();
                    ctx.rotate(angleToOwner + Math.PI);
                    ctx.globalAlpha = 0.32 + 0.28 * (1 - fireRatio);
                    const tailGradient = ctx.createLinearGradient(-tailLength, 0, 0, 0);
                    tailGradient.addColorStop(0, tailStart);
                    tailGradient.addColorStop(0.85, tailMid);
                    tailGradient.addColorStop(1, tailEnd);
                    ctx.fillStyle = tailGradient;
                    ctx.beginPath();
                    ctx.moveTo(-tailLength, -baseRadius * 0.55);
                    ctx.quadraticCurveTo(-tailLength * 0.6, -baseRadius, -baseRadius * 0.25, -baseRadius * 0.4);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(-baseRadius * 0.25, baseRadius * 0.4);
                    ctx.quadraticCurveTo(-tailLength * 0.6, baseRadius, -tailLength, baseRadius * 0.55);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.4 + 0.25 * (1 - fireRatio);
                const auraRadius = baseRadius * (1.9 + pulse * 0.35 + level * 0.1);
                const auraGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, auraRadius);
                auraGradient.addColorStop(0, auraInner);
                auraGradient.addColorStop(0.55, auraMid);
                auraGradient.addColorStop(1, auraOuter);
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';

                ctx.save();
                ctx.rotate(swirl * 0.4);
                ctx.globalAlpha = 0.4 + 0.2 * (1 - fireRatio);
                ctx.lineWidth = 1.25;
                ctx.strokeStyle = swirlPrimary;
                ctx.beginPath();
                ctx.ellipse(0, 0, baseRadius * (1.18 + 0.08 * Math.sin(swirl)), baseRadius * (0.62 + 0.1 * Math.cos(swirl * 1.3)), 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                ctx.save();
                ctx.rotate(-swirl * 0.45);
                ctx.globalAlpha = 0.25 + 0.2 * (1 - fireRatio);
                ctx.lineWidth = 0.9;
                ctx.strokeStyle = swirlSecondary;
                ctx.beginPath();
                ctx.ellipse(0, 0, baseRadius * 1.45, baseRadius * 0.78, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                ctx.globalAlpha = 0.95;
                const coreGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.22, 0, 0, baseRadius * 0.92);
                coreGradient.addColorStop(0, withAlpha(coreInner, 0.98));
                coreGradient.addColorStop(0.42, withAlpha(coreMid, 0.92));
                coreGradient.addColorStop(0.78, withAlpha(coreOuter, 0.96));
                coreGradient.addColorStop(1, withAlpha(coreEdge, 1));
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius * (0.95 + pulse * 0.05), 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 0.8;
                ctx.lineWidth = 1.6;
                ctx.strokeStyle = level >= 5 ? withAlpha(ringColor, 1) : ringColor;
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius * 1.1, 0, Math.PI * 2);
                ctx.stroke();

                ctx.save();
                ctx.rotate(0.12 * Math.sin(swirl));
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = highlightFill;
                ctx.beginPath();
                ctx.moveTo(-baseRadius * 0.52, -baseRadius * 0.12);
                ctx.quadraticCurveTo(-baseRadius * 0.12, -baseRadius * 0.58, baseRadius * 0.48, -baseRadius * 0.05);
                ctx.quadraticCurveTo(-baseRadius * 0.08, baseRadius * 0.28, -baseRadius * 0.45, baseRadius * 0.1);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 0.65;
                ctx.strokeStyle = withAlpha(trailColor, 0.85);
                ctx.lineWidth = 0.9;
                ctx.stroke();
                ctx.restore();

                ctx.globalAlpha = 0.6 * (1 - fireRatio);
                const thrusterGradient = ctx.createRadialGradient(0, baseRadius * 0.95, baseRadius * 0.1, 0, baseRadius * 1.25, baseRadius * 0.6);
                thrusterGradient.addColorStop(0, thrusterInner);
                thrusterGradient.addColorStop(1, thrusterOuter);
                ctx.fillStyle = thrusterGradient;
                ctx.beginPath();
                ctx.ellipse(0, baseRadius * 1.05, baseRadius * 0.6, baseRadius * 0.36, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawPlayerChampion(champion) {
                if (!champion) return;

                const level = champion.level || 1;
                const baseRadius = champion.r || 20;
                const now = performance.now() / 1000;
                const auraPhase = champion.auraPulse || 0;
                const auraPulse = 0.8 + 0.18 * Math.sin(now * 3 + auraPhase);
                const dashActive = champion.state === 'dash';
                const facing = typeof champion.visualAim === 'number' ? champion.visualAim : 0;
                const swirl = champion.swirlPhase || 0;
                const skinTheme = champion.skinTheme || getChampionSkinTheme(champion.skinKey || 'default');
                const bodyTheme = skinTheme.body;
                const visorTheme = skinTheme.visor;
                const auraTheme = skinTheme.aura;
                const trailColor = skinTheme.trail || '#78b4ff';
                const accentColor = bodyTheme.accent || trailColor || '#6090d0';
                
                // Check if star power is active
                const isStarPowerActive = champion.isInvincible && champion.starPowerEndTime > performance.now();

                ctx.save();
                ctx.translate(champion.x, champion.y);
                
                // â­ STAR POWER EFFECT (Mario/Mario Kart style invincibility) â­
                if (isStarPowerActive) {
                    const starProgress = (champion.starPowerEndTime - performance.now()) / 5000;
                    const rainbowPhase = now * 8; // Fast rainbow cycling
                    
                    // Rainbow rotating aura rings
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    for (let i = 0; i < 4; i++) {
                        const ringAngle = (now * 4 + i * Math.PI / 2) % (Math.PI * 2);
                        const ringRadius = baseRadius * (1.8 + i * 0.3);
                        const hue = ((rainbowPhase + i * 60) % 360);
                        ctx.globalAlpha = 0.6 * starProgress;
                        ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 0.8)`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, ringAngle, ringAngle + Math.PI / 2);
                        ctx.stroke();
                    }
                    
                    // Rainbow sparkle particles
                    for (let i = 0; i < 8; i++) {
                        const sparklePhase = (now * 5 + i * 0.8) % 3;
                        const sparkleAlpha = Math.max(0, 1 - sparklePhase / 3) * starProgress;
                        const sparkleAngle = (i / 8) * Math.PI * 2 + now * 2;
                        const sparkleDist = baseRadius * (1.2 + sparklePhase * 0.8);
                        const sparkleX = Math.cos(sparkleAngle) * sparkleDist;
                        const sparkleY = Math.sin(sparkleAngle) * sparkleDist;
                        const sparkleHue = ((rainbowPhase + i * 45) % 360);
                        
                        ctx.globalAlpha = sparkleAlpha;
                        ctx.fillStyle = `hsla(${sparkleHue}, 100%, 70%, 1)`;
                        ctx.shadowColor = `hsla(${sparkleHue}, 100%, 80%, 0.9)`;
                        ctx.shadowBlur = 8;
                        
                        // Four-pointed star shape
                        ctx.save();
                        ctx.translate(sparkleX, sparkleY);
                        ctx.rotate(sparklePhase * Math.PI);
                        ctx.beginPath();
                        for (let j = 0; j < 4; j++) {
                            const angle = (j / 4) * Math.PI * 2;
                            const r = j % 2 === 0 ? 4 : 2;
                            const px = Math.cos(angle) * r;
                            const py = Math.sin(angle) * r;
                            if (j === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Pulsing rainbow glow around ship
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.4 * starProgress * (0.7 + 0.3 * Math.sin(now * 12));
                    const glowHue = (rainbowPhase % 360);
                    const glowGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.5, 0, 0, baseRadius * 2.5);
                    glowGradient.addColorStop(0, `hsla(${glowHue}, 100%, 70%, 0.8)`);
                    glowGradient.addColorStop(0.5, `hsla(${(glowHue + 60) % 360}, 100%, 60%, 0.4)`);
                    glowGradient.addColorStop(1, `hsla(${(glowHue + 120) % 360}, 100%, 50%, 0)`);
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Premium multi-layered aura with pulsing rings
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                // Outer expanding rings for premium skins
                const isPremiumSkin = ['blackgold', 'crimsonhex', 'prismrift', 'ghostflame', 'voidcrystal', 'chromestrike', 'infernalcore', 'glacialwarden'].includes(skinTheme.key);
                if (isPremiumSkin) {
                    for (let i = 0; i < 3; i++) {
                        const ringPhase = (now * 1.5 + i * 0.8) % 2;
                        const ringAlpha = Math.max(0, 0.3 - ringPhase * 0.15);
                        ctx.globalAlpha = ringAlpha;
                        ctx.strokeStyle = withAlpha(accentColor, 0.6);
                        ctx.lineWidth = 2 + level * 0.3;
                        ctx.beginPath();
                        ctx.arc(0, 0, baseRadius * (2.2 + ringPhase * 0.8 + level * 0.15), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Main aura
                ctx.globalAlpha = 0.32 + 0.24 * Math.sin(now * 2.5 + auraPhase * 0.9);
                const auraRadius = baseRadius * (2.0 + auraPulse * 0.7 + level * 0.1);
                const auraGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.3, 0, 0, auraRadius);
                auraGradient.addColorStop(0, withAlpha(auraTheme.inner, 0.9));
                auraGradient.addColorStop(0.5, withAlpha(auraTheme.mid, 0.4 + Math.min(0.3, level * 0.04)));
                auraGradient.addColorStop(1, withAlpha(auraTheme.outer, 0));
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                if (dashActive && (champion.dashVX || champion.dashVY)) {
                    const dashDuration = champion.dashDuration || 0.01;
                    const dashProgress = Math.max(0, Math.min(1, 1 - (champion.dashTimer || 0) / dashDuration));
                    const streakLength = baseRadius * (3.2 + level * 0.35);
                    const trailAngle = Math.atan2(champion.dashVY || 0, champion.dashVX || 1);

                    ctx.save();
                    ctx.rotate(trailAngle);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.6 + 0.3 * dashProgress;
                    const streakGradient = ctx.createLinearGradient(-streakLength, 0, baseRadius * 0.9, 0);
                    streakGradient.addColorStop(0, withAlpha(bodyTheme.mid || '#1e2845', 0));
                    streakGradient.addColorStop(0.4, withAlpha(trailColor, 0.45));
                    streakGradient.addColorStop(1, withAlpha(trailColor, 0.85));
                    ctx.fillStyle = streakGradient;
                    ctx.beginPath();
                    ctx.moveTo(-streakLength, -baseRadius * 0.6);
                    ctx.lineTo(baseRadius * 0.9, -baseRadius * 0.2);
                    ctx.lineTo(baseRadius * 0.9, baseRadius * 0.2);
                    ctx.lineTo(-streakLength, baseRadius * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                // Angular diamond body
                ctx.save();
                ctx.rotate(facing);

                // Main diamond body - darker blue gradient
                const bodyGradient = ctx.createLinearGradient(0, -baseRadius * 1.2, 0, baseRadius * 1.1);
                bodyGradient.addColorStop(0, bodyTheme.top || '#2a3560');
                bodyGradient.addColorStop(0.45, bodyTheme.mid || bodyTheme.top || '#1e2845');
                bodyGradient.addColorStop(1, bodyTheme.bottom || bodyTheme.mid || '#3c4f78');
                ctx.fillStyle = bodyGradient;
                ctx.strokeStyle = bodyTheme.outline || accentColor;
                ctx.lineWidth = 2.2;
                ctx.globalAlpha = 0.95;

                // Angular diamond shape
                ctx.beginPath();
                ctx.moveTo(0, -baseRadius * 1.1);                    // Top point
                ctx.lineTo(baseRadius * 0.9, -baseRadius * 0.15);    // Top-right
                ctx.lineTo(baseRadius * 0.6, baseRadius * 0.9);      // Bottom-right
                ctx.lineTo(0, baseRadius * 1.05);                    // Bottom point
                ctx.lineTo(-baseRadius * 0.6, baseRadius * 0.9);     // Bottom-left
                ctx.lineTo(-baseRadius * 0.9, -baseRadius * 0.15);   // Top-left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Angular inner sections
                ctx.fillStyle = bodyTheme.interior || '#1a2440';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(-baseRadius * 0.25, -baseRadius * 0.3);
                ctx.lineTo(baseRadius * 0.25, -baseRadius * 0.3);
                ctx.lineTo(baseRadius * 0.4, baseRadius * 0.15);
                ctx.lineTo(-baseRadius * 0.4, baseRadius * 0.15);
                ctx.closePath();
                ctx.fill();

                // Visor - angular hexagonal shape
                ctx.fillStyle = bodyTheme.interior || '#0f1525';
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(0, -baseRadius * 0.55);
                ctx.lineTo(baseRadius * 0.45, -baseRadius * 0.25);
                ctx.lineTo(baseRadius * 0.35, baseRadius * 0.05);
                ctx.lineTo(-baseRadius * 0.35, baseRadius * 0.05);
                ctx.lineTo(-baseRadius * 0.45, -baseRadius * 0.25);
                ctx.closePath();
                ctx.fill();

                // Glowing visor
                const visorGradient = ctx.createLinearGradient(-baseRadius * 0.4, -baseRadius * 0.3, baseRadius * 0.4, 0);
                visorGradient.addColorStop(0, visorTheme.left || 'rgba(80, 150, 255, 0.8)');
                visorGradient.addColorStop(0.5, visorTheme.center || 'rgba(120, 180, 255, 0.95)');
                visorGradient.addColorStop(1, visorTheme.right || 'rgba(60, 120, 200, 0.7)');
                ctx.fillStyle = visorGradient;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(0, -baseRadius * 0.5);
                ctx.lineTo(baseRadius * 0.4, -baseRadius * 0.22);
                ctx.lineTo(baseRadius * 0.3, 0);
                ctx.lineTo(-baseRadius * 0.3, 0);
                ctx.lineTo(-baseRadius * 0.4, -baseRadius * 0.22);
                ctx.closePath();
                ctx.fill();

                // Angular accent lines with premium glow effects
                const accentLevelColor = level >= 4 ? withAlpha(accentColor, 0.95) : withAlpha(accentColor, 0.82);
                
                // Premium skins get glowing accent lines
                if (isPremiumSkin) {
                    ctx.shadowColor = accentColor;
                    ctx.shadowBlur = 8 + level * 2;
                    ctx.globalAlpha = 0.9;
                } else {
                    ctx.globalAlpha = 0.8;
                }
                
                ctx.strokeStyle = accentLevelColor;
                ctx.lineWidth = isPremiumSkin ? 2.2 : 1.8;
                ctx.beginPath();
                ctx.moveTo(-baseRadius * 0.35, baseRadius * 0.25);
                ctx.lineTo(baseRadius * 0.35, baseRadius * 0.25);
                ctx.moveTo(-baseRadius * 0.25, baseRadius * 0.6);
                ctx.lineTo(baseRadius * 0.25, baseRadius * 0.6);
                ctx.stroke();
                
                ctx.shadowBlur = 0;

                // Level indicators with premium effects
                if (level >= 2) {
                    ctx.globalAlpha = 0.6 + 0.25 * Math.sin(now * 5.5 + auraPhase);
                    ctx.lineWidth = level >= 4 ? 2.5 : 1.8;
                    ctx.strokeStyle = accentLevelColor;
                    
                    // Premium skins get crown/halo indicators
                    if (isPremiumSkin && level >= 4) {
                        ctx.shadowColor = accentColor;
                        ctx.shadowBlur = 12;
                        ctx.lineWidth = 3;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -baseRadius * 1.5);
                    ctx.lineTo(0, -baseRadius * 2.0);
                    ctx.moveTo(-baseRadius * 0.3, -baseRadius * 1.75);
                    ctx.lineTo(baseRadius * 0.3, -baseRadius * 1.75);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // Special skin-specific effects
                if (skinTheme.key === 'blackgold') {
                    // Gold shimmer particles
                    for (let i = 0; i < 4; i++) {
                        const sparklePhase = (now * 3 + i * 1.5) % 4;
                        const sparkleAlpha = Math.max(0, 0.8 - sparklePhase * 0.2);
                        const sparkleSize = 2 + sparklePhase * 0.5;
                        const sparkleAngle = (i / 4) * Math.PI * 2 + now * 0.5;
                        const sparkleX = Math.cos(sparkleAngle) * baseRadius * 1.4;
                        const sparkleY = Math.sin(sparkleAngle) * baseRadius * 1.4;
                        ctx.globalAlpha = sparkleAlpha;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (skinTheme.key === 'ghostflame') {
                    // Ethereal flame wisps
                    ctx.globalAlpha = 0.4 + 0.2 * Math.sin(now * 4);
                    ctx.strokeStyle = withAlpha('#18ffff', 0.7);
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 5; i++) {
                        const wispAngle = (i / 5) * Math.PI * 2 + now * 2;
                        const wispDist = baseRadius * (1.6 + 0.3 * Math.sin(now * 3 + i));
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(wispAngle) * baseRadius * 1.2, Math.sin(wispAngle) * baseRadius * 1.2);
                        ctx.lineTo(Math.cos(wispAngle) * wispDist, Math.sin(wispAngle) * wispDist);
                        ctx.stroke();
                    }
                } else if (skinTheme.key === 'prismrift') {
                    // Prismatic light refraction
                    const prismColors = ['#00d4ff', '#00bfa5', '#69f0ae', '#b2ff59'];
                    for (let i = 0; i < 4; i++) {
                        const prismPhase = (now * 2 + i * 0.8) % 3;
                        const prismAlpha = Math.max(0, 0.5 - prismPhase * 0.15);
                        const prismAngle = (i / 4) * Math.PI * 2 + now * 1.2;
                        ctx.globalAlpha = prismAlpha;
                        ctx.strokeStyle = prismColors[i];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(prismAngle) * baseRadius * 0.8, Math.sin(prismAngle) * baseRadius * 0.8, 
                               baseRadius * (0.3 + prismPhase * 0.2), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Special ability charge indicator
                if (champion.specialAbilityCooldown > 0) {
                    const cooldownRatio = champion.specialAbilityCooldown / 5000; // 5 second cooldown
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(accentColor, 0.78);
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * 1.2, -Math.PI / 2, -Math.PI / 2 + (1 - cooldownRatio) * Math.PI * 2);
                    ctx.stroke();

                    // Class ability icons when ready
                    if (cooldownRatio <= 0) {
                        const iconPulse = 0.8 + 0.2 * Math.sin(now * 4);
                        ctx.globalAlpha = 0.9 * iconPulse;

                        // Determine next ability type (same logic as the special ability function)
                        const player = store.player;
                        let abilityType = 'beef'; // default
                        if (player) {
                            if (player.pilotGenome === 'rocketman') abilityType = 'rocket';
                            else if (player.pilotGenome === 'voidmancer') {
                                abilityType = champion.lastVoidmancerAbility === 'lightning' ? 'laser' : 'lightning';
                            }
                        }

                        // Draw ability icon
                        ctx.fillStyle = withAlpha(accentColor, 0.9);
                        ctx.font = `${baseRadius * 0.4}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        let iconText = 'âš¡';
                        if (abilityType === 'beef') iconText = 'ðŸ’¨';
                        else if (abilityType === 'rocket') iconText = 'ðŸš€';
                        else if (abilityType === 'laser') iconText = 'ðŸ”«';

                        ctx.fillText(iconText, 0, baseRadius * 1.8);
                    }
                }

                ctx.restore();

                // Rotating energy field
                ctx.save();
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = withAlpha(accentColor, 0.6);
                ctx.lineWidth = 1.8;
                ctx.rotate(swirl * 0.8);
                for (let i = 0; i < 6; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, baseRadius * 0.3);
                    ctx.lineTo(0, baseRadius * 1.4);
                    ctx.stroke();
                    ctx.rotate(Math.PI / 3);
                }
                ctx.restore();

                // Core energy orb
                ctx.globalAlpha = 0.7;
                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 0.5);
                coreGradient.addColorStop(0, withAlpha(accentColor, 0.8));
                coreGradient.addColorStop(1, withAlpha(trailColor, 0.25));
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, baseRadius * 0.15, baseRadius * 0.45, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawIceman(iceman) {
                const { x, y, isMini } = iceman;
                ctx.save();
                ctx.translate(x, y);
                const scale = isMini ? 0.4 : 1.0; // Mini iceman is 40% the size (smaller for boss token)
                ctx.scale(scale, scale);
                ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(12, 8);
                ctx.lineTo(8, 14);
                ctx.lineTo(0, 10);
                ctx.lineTo(-8, 14);
                ctx.lineTo(-12, 8);
                ctx.closePath();

                const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
                bodyGrad.addColorStop(0, "#a0e9ff");
                bodyGrad.addColorStop(1, "#3c9aed");
                ctx.fillStyle = bodyGrad;
                ctx.fill();

                ctx.lineWidth = 2;
                ctx.strokeStyle = "#d0f8ff";
                ctx.stroke();

                ctx.strokeStyle = "#a0e9ff";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-12, 5);
                ctx.lineTo(-20, -2);
                ctx.lineTo(-18, 8);
                ctx.moveTo(12, 5);
                ctx.lineTo(20, -2);
                ctx.lineTo(18, 8);
                ctx.stroke();

                ctx.fillStyle = "#ffffff";
                ctx.beginPath();
                ctx.arc(0, -8, 3, 0, 2 * Math.PI);
                ctx.fill();

                ctx.restore();
            }

            function stepEscortDrones(dt) {
                const p = store.player;
                if (!store.escortDrones || store.escortDrones.length === 0) return;

                for (let i = 0; i < store.escortDrones.length; i++) {
                    const drone = store.escortDrones[i];
                    
                    // Position drones out front of the player, alternating left/right
                    const targetX = p.x + (drone.side === 'left' ? -80 : 80);
                    const targetY = p.y - 60 - (drone.offset * 25); // Stagger vertically
                    
                    // Smooth movement towards target position
                    drone.x += (targetX - drone.x) * 0.15;
                    drone.y += (targetY - drone.y) * 0.15;
                    
                    // Update fire timer
                    drone.fireT += dt;
                    
                    // Fire a burst that mirrors the player's multishot pattern (every 0.25s)
                    if (drone.fireT >= 0.25) {
                        drone.fireT = 0;

                        const totalMultishot = Math.max(1, (p.multishot || 1) + (p.cheatMultishotBonus || 0));
                        const angleSpread = 10;
                        const bulletSpeed = 900;
                        const damagePerVolley = (15 * p.dmgMult * 0.35) * 0.5; // Preserve previous total volley damage
                        const damagePerBullet = damagePerVolley / totalMultishot;
                        const swirlShot = !!p.swirlShots;

                        for (let shotIndex = 0; shotIndex < totalMultishot; shotIndex++) {
                            const angleDegrees = (shotIndex - (totalMultishot - 1) / 2) * angleSpread;
                            const angle = angleDegrees * Math.PI / 180;
                            spawnBullet({
                                x: drone.x + 6 * Math.sin(angle),
                                y: drone.y - 8,
                                vx: Math.sin(angle) * bulletSpeed,
                                vy: -Math.cos(angle) * bulletSpeed,
                                r: 1.3,
                                col: '#66d1ff',
                                dmg: damagePerBullet,
                                pierce: p.piercing,
                                explosive: false,
                                isEscortDrone: true,
                                isSwirl: swirlShot
                            });
                        }
                    }
                }
            }

            function stepFragmentBlasters(dt, p) {
                if (!p.fragmentBlasters || p.fragmentBlasters.length === 0) return;

                const meleeRange = 120; // Maximum range for fragments
                const triggerRange = 60; // Half of melee range - when to fire

                for (let i = 0; i < p.fragmentBlasters.length; i++) {
                    const barrel = p.fragmentBlasters[i];
                    
                    // Update cooldowns
                    if (barrel.cooldown > 0) {
                        barrel.cooldown -= dt;
                    }
                    if (barrel.barrelDelay > 0) {
                        barrel.barrelDelay -= dt;
                    }

                    // Skip if on cooldown or in barrel delay
                    if (barrel.cooldown > 0 || barrel.barrelDelay > 0) continue;

                    // Find nearest enemy within trigger range
                    let nearestEnemy = null;
                    let nearestDist = triggerRange;

                    for (const e of store.enemies) {
                        if (e.dead) continue;
                        const dx = e.x - p.x;
                        const dy = e.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = e;
                        }
                    }

                    // Fire if enemy found
                    if (nearestEnemy) {
                        // Calculate angle to target
                        const dx = nearestEnemy.x - p.x;
                        const dy = nearestEnemy.y - p.y;
                        const angle = Math.atan2(dy, dx);

                        // Fire a shotgun blast of fragments
                        const fragmentCount = 10;
                        const spreadAngle = 0.5; // ~30 degrees spread
                        
                        for (let j = 0; j < fragmentCount; j++) {
                            const offsetAngle = angle + (Math.random() - 0.5) * spreadAngle;
                            const speed = 400 + Math.random() * 100;
                            
                            store.bullets.push({
                                x: p.x,
                                y: p.y,
                                vx: Math.cos(offsetAngle) * speed,
                                vy: Math.sin(offsetAngle) * speed,
                                r: 2,
                                col: '#ff9944',
                                dmg: 8 * p.dmgMult,
                                pierce: p.piercing,
                                explosive: false,
                                isFragment: true,
                                lifetime: 0,
                                maxLifetime: meleeRange / speed // Die after traveling melee range
                            });
                        }

                        // Set cooldown for this barrel
                        barrel.cooldown = 10; // 10 second cooldown

                        // Trigger barrel delay for ALL barrels
                        for (const b of p.fragmentBlasters) {
                            b.barrelDelay = 1.0; // 1 second delay before any barrel can fire again
                        }
                    }
                }
            }

            function drawEscortDrones() {
                if (!store.escortDrones || store.escortDrones.length === 0) return;

                for (const drone of store.escortDrones) {
                    ctx.save();
                    ctx.translate(drone.x, drone.y);
                    
                    // Small pulsing opacity
                    ctx.globalAlpha = 0.7 + 0.15 * Math.sin(performance.now() / 150);
                    
                    // Draw a small triangular drone
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(6, 4);
                    ctx.lineTo(0, 2);
                    ctx.lineTo(-6, 4);
                    ctx.closePath();
                    
                    const gradient = ctx.createLinearGradient(0, -8, 0, 4);
                    gradient.addColorStop(0, '#a0e9ff');
                    gradient.addColorStop(1, '#4c9aed');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = '#d0f8ff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Small glowing core
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, -2, 1.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            function drawBeefClone(beefClone) {
                const { x, y, mode } = beefClone;
                ctx.save();
                ctx.translate(x, y);

                const facing = beefClone.direction || 1;
                const visualScale = beefClone.visualScale || 1;
                if (facing < 0) {
                    ctx.scale(-visualScale, visualScale);
                } else {
                    ctx.scale(visualScale, visualScale);
                }

                if (mode === 'juggernaut_bomber') {
                    const time = performance.now();
                    const tilt = (Math.sin((beefClone.bobPhase || 0) * 0.8) * 0.08) + ((beefClone.direction || 1) * 0.05);
                    ctx.rotate(tilt);
                    ctx.globalAlpha = 0.6 + 0.12 * Math.sin(time / 140);

                    ctx.beginPath();
                    ctx.moveTo(0, -24);
                    ctx.lineTo(22, -6);
                    ctx.lineTo(18, 10);
                    ctx.lineTo(0, 20);
                    ctx.lineTo(-18, 10);
                    ctx.lineTo(-22, -6);
                    ctx.closePath();

                    const hullGrad = ctx.createLinearGradient(0, -24, 0, 20);
                    hullGrad.addColorStop(0, '#f5c8a2');
                    hullGrad.addColorStop(0.45, '#e28553');
                    hullGrad.addColorStop(1, '#3a1e1e');
                    ctx.fillStyle = hullGrad;
                    ctx.fill();

                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(230, 160, 115, 0.6)';
                    ctx.stroke();

                    // Nose glow
                    ctx.fillStyle = 'rgba(245, 220, 185, 0.65)';
                    ctx.beginPath();
                    ctx.arc(0, -20, 4, 0, 2 * Math.PI);
                    ctx.fill();

                    // Cockpit canopy
                    ctx.fillStyle = 'rgba(240, 228, 208, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(0, -8, 6, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Thruster flames
                    const pulse = 0.7 + 0.3 * Math.sin(time / 90 + (beefClone.bobPhase || 0) * 2);
                    const flameHeight = 12 + pulse * 6;
                    ctx.fillStyle = `rgba(240, 140, 60, ${0.28 + 0.22 * pulse})`;
                    ctx.beginPath();
                    ctx.moveTo(-10, 12);
                    ctx.lineTo(-20, 12 + flameHeight);
                    ctx.lineTo(-4, 18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(10, 12);
                    ctx.lineTo(20, 12 + flameHeight);
                    ctx.lineTo(4, 18);
                    ctx.closePath();
                    ctx.fill();

                    // Bomb bay glow
                    ctx.fillStyle = 'rgba(255, 200, 110, 0.45)';
                    ctx.beginPath();
                    ctx.ellipse(0, 8, 12, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.globalAlpha = 0.46 + 0.12 * Math.sin(performance.now() / 220);

                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();

                    const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
                    bodyGrad.addColorStop(0, '#7dd8a3');
                    bodyGrad.addColorStop(1, '#269960');
                    ctx.fillStyle = bodyGrad;
                    ctx.fill();

                    ctx.lineWidth = 1.6;
                    ctx.strokeStyle = 'rgba(168, 228, 185, 0.65)';
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(140, 215, 165, 0.55)';
                    ctx.lineWidth = 1.4;
                    ctx.beginPath();
                    ctx.moveTo(-12, 5);
                    ctx.lineTo(-20, -2);
                    ctx.lineTo(-18, 8);
                    ctx.moveTo(12, 5);
                    ctx.lineTo(20, -2);
                    ctx.lineTo(18, 8);
                    ctx.stroke();

                    ctx.fillStyle = 'rgba(230, 245, 235, 0.75)';
                    ctx.beginPath();
                    ctx.arc(0, -8, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }

                ctx.restore();
            }
            function drawLightningBolt(bolt) {
                const { points, life, maxLife } = bolt;
                const t = life / maxLife;
                if (t <= 0) return;

                ctx.save();
                ctx.lineWidth = 4 * t;
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * t})`;
                ctx.shadowColor = '#9a66ff';
                ctx.shadowBlur = 20 * t;

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();

                ctx.lineWidth = 1.5 * t;
                ctx.strokeStyle = `rgba(200, 220, 255, ${t})`;
                ctx.shadowBlur = 10 * t;
                ctx.stroke();

                ctx.restore();
            }

            function drawFlamePulse(pulse) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                const time = performance.now() / 1000;
                const lifeRatio = pulse.life / 2.0;
                const opacity = Math.min(1, lifeRatio);

                // Outer fire ring (orange)
                const outerGradient = ctx.createRadialGradient(pulse.x, pulse.y, pulse.radius - 20, pulse.x, pulse.y, pulse.radius + 10);
                outerGradient.addColorStop(0, `rgba(255, 69, 0, 0)`);
                outerGradient.addColorStop(0.4, `rgba(255, 120, 0, ${opacity * 0.6})`);
                outerGradient.addColorStop(0.7, `rgba(255, 80, 0, ${opacity * 0.8})`);
                outerGradient.addColorStop(1, `rgba(255, 40, 0, 0)`);

                ctx.fillStyle = outerGradient;
                ctx.beginPath();
                ctx.arc(pulse.x, pulse.y, pulse.radius + 10, 0, Math.PI * 2);
                ctx.arc(pulse.x, pulse.y, Math.max(0, pulse.radius - 20), 0, Math.PI * 2, true);
                ctx.fill();

                // Inner hot core (yellow/white)
                const innerGradient = ctx.createRadialGradient(pulse.x, pulse.y, pulse.radius - 15, pulse.x, pulse.y, pulse.radius + 5);
                innerGradient.addColorStop(0, `rgba(255, 255, 200, 0)`);
                innerGradient.addColorStop(0.5, `rgba(255, 220, 100, ${opacity * 0.7})`);
                innerGradient.addColorStop(1, `rgba(255, 150, 50, 0)`);

                ctx.fillStyle = innerGradient;
                ctx.beginPath();
                ctx.arc(pulse.x, pulse.y, pulse.radius + 5, 0, Math.PI * 2);
                ctx.arc(pulse.x, pulse.y, Math.max(0, pulse.radius - 15), 0, Math.PI * 2, true);
                ctx.fill();

                // Pulsing glow effect
                const pulseEffect = 0.5 + 0.5 * Math.sin(time * 10);
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                ctx.shadowBlur = 20 * pulseEffect;
                ctx.strokeStyle = `rgba(255, 180, 80, ${opacity * 0.8 * pulseEffect})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            function drawEmpNova(nova) {
                ctx.save();

                // Create pulsing effect
                const time = performance.now() / 1000;
                const pulse = 0.8 + 0.2 * Math.sin(time * 8);
                const opacity = Math.min(1, nova.life / 2) * 0.3; // Fade in over 2 seconds

                // Draw expanding EMP ring
                ctx.strokeStyle = `rgba(255, 140, 0, ${opacity * pulse})`; // Orange cyberpunk color
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]); // Dashed line for tech effect
                ctx.shadowColor = '#FF8C00';
                ctx.shadowBlur = 15;

                ctx.beginPath();
                ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner energy ring
                ctx.strokeStyle = `rgba(138, 43, 226, ${opacity * pulse * 0.7})`; // Purple
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.shadowColor = '#8A2BE2';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.arc(nova.x, nova.y, nova.radius * 0.7, 0, Math.PI * 2);
                ctx.stroke();

                // Add some sparking effects around the perimeter
                ctx.setLineDash([]);
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * pulse})`;
                ctx.lineWidth = 1;

                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + time * 2;
                    const x1 = nova.x + Math.cos(angle) * (nova.radius - 5);
                    const y1 = nova.y + Math.sin(angle) * (nova.radius - 5);
                    const x2 = nova.x + Math.cos(angle) * (nova.radius + 5);
                    const y2 = nova.y + Math.sin(angle) * (nova.radius + 5);

                    if (Math.random() < 0.3) { // Random sparking
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            function activateGravityWell(scale = 1.0) {
                if (!store.isPaused) {
                    const spawnX = W * 0.2 + Math.random() * W * 0.6;
                    const spawnY = H * 0.2 + Math.random() * H * 0.6;
                    store.activeEffects.push(createEffect("gravityWell", spawnX, spawnY, scale));
                    announce(scale < 1.0 ? 'MINI GRAVITY WELL ACTIVATED' : 'GRAVITY WELL ACTIVATED');
                    screenFlash(2, 250, 'rgba(255, 255, 255, 0.7)');
                }
            }
            function activateLazarus(scale = 1.0) {
                if (store.player.hasLazarusBeam && !store.isPaused) {
                    const angle = Math.random() * 2 * Math.PI,
                        speed = 800,
                        p = store.player;
                    const laserRadius = scale < 1.0 ? 6 : 12; // Mini version has half the width
                    store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 6, r: laserRadius, hitEnemies: new Set, isMini: scale < 1.0 });

                    if (p.upgradeLevels.lazarus_beam > 1) {
                        const oppositeAngle = angle + Math.PI;
                        store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(oppositeAngle) * speed, vy: Math.sin(oppositeAngle) * speed, life: 6, r: laserRadius, hitEnemies: new Set, isMini: scale < 1.0 });
                    }
                }
            }
            // Shield Pulse System Configuration (internal name: EMP_BURST_CONFIG for backwards compatibility)
            const EMP_BURST_CONFIG = {
                radius: 480, // Doubled from 240
                baseDamage: 62,
                bossDamageScale: 0.45,
                baseStun: 2.8,
                mechanicalDamageBonus: 0.25,
                mechanicalStunBonus: 1.2,
                electrifiedDamageBonus: 0.35,
                electrifiedStunBonus: 1.1,
                burningDamageBonus: 0.2,
                shockDuration: 1.6,
                slowFactor: 0.5,
                projectilePurgeRadiusRatio: 0.75,
                proximityTriggerRadius: 180, // Auto-activate when enemy within this range (imminent threat)
                chargeCooldown: 30, // Per-charge cooldown in seconds
                globalCooldown: 4.5, // Prevent overlapping bursts while effects resolve
                maxCharges: 3,
                orbitRadius: 85,
                orbitSpeed: 1.2
            };

            function createEmpCharge() {
                if (!store.empCharges) store.empCharges = [];
                if (store.empCharges.length >= (EMP_BURST_CONFIG.maxCharges || 3)) {
                    return;
                }
                const chargeCount = store.empCharges.length;
                const charge = {
                    x: store.player.x,
                    y: store.player.y,
                    orbitAngle: (chargeCount / (chargeCount + 1)) * Math.PI * 2,
                    orbitRadius: EMP_BURST_CONFIG.orbitRadius,
                    orbitSpeed: EMP_BURST_CONFIG.orbitSpeed,
                    pulsePhase: Math.random() * Math.PI * 2,
                    cooldown: 0, // Track cooldown per charge
                    dead: false
                };
                store.empCharges.push(charge);

                const total = store.empCharges.length;
                if (total > 0) {
                    for (let i = 0; i < total; i++) {
                        const c = store.empCharges[i];
                        if (!c) continue;
                        c.orbitAngle = (i / total) * Math.PI * 2;
                    }
                }
            }

            function stepEmpCharges(dt) {
                if (!store.empCharges || store.empCharges.length === 0) return;
                const p = store.player;
                if (!p || p.dead) {
                    store.empCharges.length = 0;
                    store.empGlobalCooldown = 0;
                    return;
                }

                store.empGlobalCooldown = Math.max(0, (store.empGlobalCooldown || 0) - dt);

                const proximityRadiusSq = EMP_BURST_CONFIG.proximityTriggerRadius ** 2;
                const targets = store.boss
                    ? [...(store.enemies || []), store.boss]
                    : [...(store.enemies || [])];

                for (let i = store.empCharges.length - 1; i >= 0; i--) {
                    const charge = store.empCharges[i];
                    if (!charge || charge.dead) {
                        store.empCharges.splice(i, 1);
                        continue;
                    }

                    // Update orbit position
                    charge.orbitAngle += charge.orbitSpeed * dt;
                    charge.pulsePhase += dt * 4;
                    const radius = charge.orbitRadius * (1 + Math.sin(charge.pulsePhase) * 0.05);
                    const targetX = p.x + Math.cos(charge.orbitAngle) * radius;
                    const targetY = p.y + Math.sin(charge.orbitAngle) * radius * 0.6;
                    charge.x += (targetX - charge.x) * Math.min(1, 12 * dt);
                    charge.y += (targetY - charge.y) * Math.min(1, 12 * dt);

                    // Update cooldown
                    charge.cooldown = Math.max(0, (charge.cooldown || 0) - dt);
                    if (charge.cooldown > 0) {
                        continue; // Skip trigger check if on cooldown
                    }

                    if ((store.empGlobalCooldown || 0) > 0) {
                        continue; // Ability still in global cooldown window
                    }

                    if (!targets.length) {
                        continue;
                    }

                    // Count unaffected enemies within blast radius to avoid wasteful triggering
                    let unaffectedEnemiesInRange = 0;
                    const empBlastRadius = EMP_BURST_CONFIG.radius || 480;
                    const empBlastRadiusSq = empBlastRadius * empBlastRadius;
                    
                    for (const enemy of targets) {
                        if (!enemy || enemy.dead) continue;
                        
                        // First check if enemy is in proximity trigger range (close threat)
                        const dxProximity = enemy.x - charge.x;
                        const dyProximity = enemy.y - charge.y;
                        const distSqProximity = dxProximity * dxProximity + dyProximity * dyProximity;
                        
                        if (distSqProximity < proximityRadiusSq) {
                            // Now check if they're within the actual EMP blast radius
                            if (distSqProximity < empBlastRadiusSq) {
                                // Check if this enemy would actually be affected by EMP
                                const hasRecentEmpStun = enemy.stunTimer && enemy.stunTimer > 1.5; // Has >1.5s stun left
                                const hasRecentEmpShock = enemy.stormShockTimer && enemy.stormShockTimer > 1.0; // Has >1s shock left
                                const isRecentlyAffected = hasRecentEmpStun || hasRecentEmpShock;
                                
                                if (!isRecentlyAffected) {
                                    unaffectedEnemiesInRange++;
                                }
                            }
                        }
                    }

                    // Only trigger if we have at least 2 valid targets (or 1 boss)
                    const isBossNearby = store.boss && !store.boss.dead && 
                        ((store.boss.x - charge.x) ** 2 + (store.boss.y - charge.y) ** 2 < proximityRadiusSq);
                    const minTargetsRequired = isBossNearby ? 1 : 2;
                    
                    if (unaffectedEnemiesInRange >= minTargetsRequired) {
                        // Trigger Shield Pulse burst at charge location
                        triggerEmpBurst(charge.x, charge.y);
                        // Set cooldown - Shield Pulse charges recharge after use
                        charge.cooldown = EMP_BURST_CONFIG.chargeCooldown;
                        store.empGlobalCooldown = Math.max(store.empGlobalCooldown || 0, EMP_BURST_CONFIG.globalCooldown || 0);
                    }
                }
            }

            function triggerEmpBurst(x, y) {
                const p = store.player;
                if (!p || store.isPaused) return;

                playSound('thunder');

                const isMini = p.miniAbilities && p.miniAbilities.has('grenade');
                const radius = isMini ? EMP_BURST_CONFIG.radius * 0.6 : EMP_BURST_CONFIG.radius; // Mini EMP is 60% radius
                screenFlash(1, 140, 'rgba(100, 200, 255, 0.2)');
                store.activeEffects.push(createEffect('empShockwave', x, y, radius));

                const radiusSq = radius * radius;
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;

                targets.forEach(enemy => {
                    if (!enemy || enemy.dead) return;
                    const dx = enemy.x - x;
                    const dy = enemy.y - y;
                    if (dx * dx + dy * dy > radiusSq) return;

                    const isBoss = enemy === store.boss;
                    const type = typeof enemy.type === 'string' ? enemy.type.toLowerCase() : '';
                    const isMechanical = /mech|drone|sentinel|turret|construct|omega/.test(type);

                    let damage = EMP_BURST_CONFIG.baseDamage * p.dmgMult;
                    let stunDuration = EMP_BURST_CONFIG.baseStun;
                    let shockDuration = EMP_BURST_CONFIG.shockDuration;

                    if (isMechanical) {
                        damage *= 1 + EMP_BURST_CONFIG.mechanicalDamageBonus;
                        stunDuration += EMP_BURST_CONFIG.mechanicalStunBonus;
                        shockDuration += 0.8;
                    }

                    const isElectrified = enemy.stormShockTimer && enemy.stormShockTimer > 0;
                    if (isElectrified) {
                        damage *= 1 + EMP_BURST_CONFIG.electrifiedDamageBonus;
                        stunDuration += EMP_BURST_CONFIG.electrifiedStunBonus;
                        shockDuration += 0.9;
                    }

                    const isBurning = (enemy.jugBurnTimer && enemy.jugBurnTimer > 0) || enemy.isBurning;
                    if (isBurning) {
                        damage *= 1 + EMP_BURST_CONFIG.burningDamageBonus;
                        store.activeEffects.push(createEffect('demolitionPulseCharge', enemy.x, enemy.y, (enemy.r || 24) * 1.4));
                    }

                    if (enemy.phaseLockTimer && enemy.phaseLockTimer > 0) {
                        stunDuration += 0.8;
                        enemy.phaseLockTimer = Math.max(enemy.phaseLockTimer, 1.8);
                        enemy.phaseLockSlowFactor = Math.min(enemy.phaseLockSlowFactor || 1, 0.35);
                    }

                    if (enemy.shield !== undefined) {
                        enemy.shield = Math.max(0, enemy.shield - 75);
                    }

                    if (isBoss) {
                        damage *= EMP_BURST_CONFIG.bossDamageScale;
                        stunDuration = Math.min(stunDuration, 2.2);
                        shockDuration = Math.min(shockDuration, 2.0);
                    }

                    const vulnResult = applySubclassVulnerability(enemy, damage, {
                        player: p,
                        damageTags: ['lightning', 'emp'],
                        source: 'empBurst',
                        allowVulnerabilityTrigger: true
                    });
                    const finalDamage = vulnResult.damage;
                    let damageApplied = finalDamage;
                    let shieldBlocked = false;

                    if (isBoss) {
                        const bossResult = applyBossDamage(enemy, finalDamage, {
                            point: { x: enemy.x, y: enemy.y }
                        });
                        if (bossResult.blocked || bossResult.amount <= 0) {
                            damageApplied = 0;
                            shieldBlocked = true;
                        } else {
                            damageApplied = bossResult.amount;
                        }
                    } else {
                        enemy.hp -= finalDamage;
                        store.world.totalDamage += finalDamage;
                    }

                    if (shieldBlocked) {
                        return;
                    }

                    enemy.stunTimer = Math.max(enemy.stunTimer || 0, stunDuration);
                    enemy.stormShockTimer = Math.max(enemy.stormShockTimer || 0, shockDuration);
                    enemy.stormShockIntensity = Math.max(enemy.stormShockIntensity || 0, 1);

                    enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, EMP_BURST_CONFIG.slowFactor);
                    enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, 2.6);

                    store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, Math.max(enemy.r || 24, 24) * 1.6));
                });

                if (store.eBullets && store.eBullets.length) {
                    const purgeRadius = EMP_BURST_CONFIG.radius * EMP_BURST_CONFIG.projectilePurgeRadiusRatio;
                    const purgeRadiusSq = purgeRadius * purgeRadius;
                    for (let i = store.eBullets.length - 1; i >= 0; i--) {
                        const bullet = store.eBullets[i];
                        if (!bullet) continue;
                        const dx = bullet.x - x;
                        const dy = bullet.y - y;
                        if (dx * dx + dy * dy <= purgeRadiusSq) {
                            store.eBullets.splice(i, 1);
                            store.activeEffects.push(createEffect('empStatic', bullet.x, bullet.y, 20));
                        }
                    }
                }
            }

            function stepVoidLaser(dt) {
                const p = store.player;

                // Determine range based on phasestriker level
                let maxRange;
                if (p.phasestRikerLevel >= 1) {
                    // Level 1+: Global range - can hit anything on screen (unlimited range upgrade)
                    maxRange = Math.max(W, H) * 2; // Unlimited range using game dimensions
                } else if (p.phasestRikerLevel >= 0.5) {
                    // Base phasestriker: Use voidLaserRange (medium range)
                    maxRange = p.voidLaserRange || 250;
                } else {
                    // No phasestriker: Default short range
                    maxRange = p.r * 12;
                }

                // Timer for retargeting - check for new targets every 0.1 seconds
                p.voidLaserRetargetTimer -= dt;
                if (p.voidLaserRetargetTimer <= 0) {
                    p.voidLaserRetargetTimer = 0.1;

                    // Find highest priority (HP) enemy within range AND in playfield
                    const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
                    
                    // Filter enemies within range and in playfield, then sort by HP descending
                    const playfieldMargin = 50; // Allow some margin for bosses
                    const enemiesInRange = allEnemies.filter(e => {
                        const distSq = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                        const inPlayfield = e.x >= -playfieldMargin && e.x <= W + playfieldMargin && 
                                           e.y >= -playfieldMargin && e.y <= H + playfieldMargin;
                        return distSq <= maxRange * maxRange && inPlayfield;
                    });
                    
                    let highestPriorityTarget = null;
                    if (enemiesInRange.length > 0) {
                        // Prioritize: Boss > Champion > Highest HP
                        const bosses = enemiesInRange.filter(e => e.isBoss);
                        const champions = enemiesInRange.filter(e => e.isChampion && !e.isBoss);
                        const regular = enemiesInRange.filter(e => !e.isBoss && !e.isChampion);
                        
                        if (bosses.length > 0) {
                            highestPriorityTarget = bosses.sort((a, b) => b.hp - a.hp)[0];
                        } else if (champions.length > 0) {
                            highestPriorityTarget = champions.sort((a, b) => b.hp - a.hp)[0];
                        } else {
                            highestPriorityTarget = regular.sort((a, b) => b.hp - a.hp)[0];
                        }
                    }

                    // Reset ramp time if target changed
                    if (highestPriorityTarget !== p.voidLaserLastTarget) {
                        p.voidLaserRampTime = 0;
                        p.voidLaserLastTarget = highestPriorityTarget;
                    }

                    p.voidLaserTarget = highestPriorityTarget;
                }

                // Apply continuous damage if we have a target
                if (p.voidLaserTarget && !p.voidLaserTarget.dead) {
                    // Check if target is still in range
                    const distSq = (p.x - p.voidLaserTarget.x) ** 2 + (p.y - p.voidLaserTarget.y) ** 2;
                    if (distSq <= maxRange * maxRange) {
                        // Increase ramp time for level 2 phasestriker
                        if (p.phasestRikerLevel >= 2) {
                            p.voidLaserRampTime += dt;
                        }

                        // Damage timer - apply damage every 0.1 seconds for smooth continuous damage
                        p.voidLaserDamageTimer -= dt;
                        if (p.voidLaserDamageTimer <= 0) {
                            p.voidLaserDamageTimer = 0.1;

                            // Base damage
                            let damage = 8.5 * p.dmgMult;

                            // Level 2 phasestriker: Ramping damage based on time on target
                            if (p.phasestRikerLevel >= 2) {
                                const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // +80% damage per second
                                damage *= Math.min(rampMultiplier, 4.0); // Cap at 4x damage
                            }

                            // Level 4 phasestriker: Double Long Range Intensifying Beam - double damage with intensification
                            if (p.phasestRikerLevel >= 4 && p.doubleBeam) {
                                damage *= 2; // Double beam doubles the damage
                                // Additional intensification over time
                                if (p.beamIntensifyRate && p.voidLaserRampTime > 0) {
                                    const intensifyMultiplier = 1 + (p.voidLaserRampTime * p.beamIntensifyRate);
                                    damage *= Math.min(intensifyMultiplier, 2.0); // Cap at 2x additional intensification
                                }
                            }

                            if (p.voidLaserTarget === store.boss) damage *= 0.4; // Reduced damage to boss

                            const voidLaserVuln = applySubclassVulnerability(p.voidLaserTarget, damage, {
                                subclass: p.subclass,
                                player: p,
                                damageTags: ['void', 'magic'],
                                source: 'voidLaser',
                                baseDamage: damage
                            });
                            damage = voidLaserVuln.damage;

                            p.voidLaserTarget.hp -= damage;
                            store.world.totalDamage += damage;

                            // Apply vampirism healing for laser damage
                            if (store.player.vampirism > 0) {
                                let healAmount = damage * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.1); // Minimum heal
                                healAmount = Math.min(healAmount, 0.6); // Increased heal cap slightly
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                        }
                    } else {
                        // Target out of range
                        p.voidLaserTarget = null;
                        p.voidLaserRampTime = 0;
                        p.voidLaserLastTarget = null;
                    }
                } else {
                    // No target or target dead - reset ramp
                    p.voidLaserTarget = null;
                    p.voidLaserRampTime = 0;
                    p.voidLaserLastTarget = null;
                }
            }

            function stepWiperLasers(dt) {
                const p = store.player;
                const time = performance.now() / 1000;

                // Initialize wiper laser blur tracking if needed
                if (!p.wiperLaserBlurTrail) p.wiperLaserBlurTrail = [];

                // Different behavior during blink slash vs normal mode
                if (p.isBlinkSlashing) {
                    // SLASH MODE: Focused, dramatic blade-like movement
                    const slashSpeed = 4.5; // Faster, more dramatic during slash
                    const slashRange = Math.PI; // Wider sweep range (Â±180Â°)

                    // Create synchronized slashing motion
                    const slashPhase = time * slashSpeed;
                    p.wiperLaser1Angle = Math.sin(slashPhase) * slashRange * 0.5;
                    p.wiperLaser2Angle = p.wiperLaser1Angle + Math.PI; // Opposite side

                    // Add motion blur during slash
                    p.wiperLaserBlurTrail.unshift({
                        angle1: p.wiperLaser1Angle,
                        angle2: p.wiperLaser2Angle,
                        life: 0.15,
                        intensity: 0.8
                    });

                } else {
                    // NORMAL MODE: Ninja-like variable speed movement
                    const baseSpeed = 1.8; // Slightly slower for better control
                    const speedVariation = 1.2 * Math.sin(time * 2.5) + 0.6 * Math.cos(time * 4.8);
                    const currentSpeed = baseSpeed + speedVariation;

                    // Add occasional direction changes for more dynamic movement
                    if (Math.random() < 0.001) { // Less frequent for smoother flow
                        p.wiperLaserSpeed *= -1;
                    }

                    // Update wiper laser angles with variable speed
                    const adjustedSpeed = p.wiperLaserSpeed * currentSpeed;
                    p.wiperLaser1Angle += adjustedSpeed * dt;
                    p.wiperLaser2Angle += adjustedSpeed * dt;

                    // Normal range limits (Â±135Â°)
                    const normalRange = Math.PI * 0.75;
                    if (p.wiperLaser1Angle > normalRange) {
                        p.wiperLaserSpeed = -Math.abs(p.wiperLaserSpeed);
                    } else if (p.wiperLaser1Angle < -normalRange) {
                        p.wiperLaserSpeed = Math.abs(p.wiperLaserSpeed);
                    }

                    // Keep second laser offset by PI (opposite side)
                    p.wiperLaser2Angle = p.wiperLaser1Angle + Math.PI;

                    // Add subtle motion blur for normal movement
                    if (Math.abs(adjustedSpeed) > 2.0) { // Only blur during fast movement
                        p.wiperLaserBlurTrail.unshift({
                            angle1: p.wiperLaser1Angle,
                            angle2: p.wiperLaser2Angle,
                            life: 0.08,
                            intensity: 0.3
                        });
                    }
                }

                // Update blur trail
                for (let i = p.wiperLaserBlurTrail.length - 1; i >= 0; i--) {
                    p.wiperLaserBlurTrail[i].life -= dt;
                    if (p.wiperLaserBlurTrail[i].life <= 0) {
                        p.wiperLaserBlurTrail.splice(i, 1);
                    }
                }

                // Cap blur trail length
                if (p.wiperLaserBlurTrail.length > 8) {
                    p.wiperLaserBlurTrail.length = 8;
                }

                // Apply damage continuously
                p.wiperLaserDamageTimer -= dt;
                if (p.wiperLaserDamageTimer <= 0) {
                    p.wiperLaserDamageTimer = 0.15; // Damage every 0.15 seconds

                    // Calculate laser endpoints
                    const laserLength = 180; // Fixed laser length - matches visual
                    const laser1EndX = p.x + Math.cos(p.wiperLaser1Angle) * laserLength;
                    const laser1EndY = p.y + Math.sin(p.wiperLaser1Angle) * laserLength;
                    const laser2EndX = p.x + Math.cos(p.wiperLaser2Angle) * laserLength;
                    const laser2EndY = p.y + Math.sin(p.wiperLaser2Angle) * laserLength;

                    // Check for enemies hit by laser beams
                    const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
                    const laserWidth = 20; // Width of laser beam for collision

                    allEnemies.forEach(enemy => {
                        // Check collision with laser 1
                        if (isPointNearLine(enemy.x, enemy.y, p.x, p.y, laser1EndX, laser1EndY, laserWidth)) {
                            let damage = 6 * p.dmgMult; // Base wiper laser damage
                            const hittingBoss = enemy === store.boss;
                            if (hittingBoss) damage *= 0.3; // Reduced damage to boss

                            const wiperVuln = applySubclassVulnerability(enemy, damage, {
                                subclass: p.subclass,
                                player: p,
                                damageTags: ['void', 'magic'],
                                source: 'wiperLaser',
                                baseDamage: damage
                            });
                            damage = wiperVuln.damage;

                            let applied = damage;
                            if (hittingBoss) {
                                const result = applyBossDamage(store.boss, damage, { point: { x: enemy.x, y: enemy.y } });
                                applied = result.amount;
                            } else {
                                enemy.hp -= damage;
                                store.world.totalDamage += damage;
                            }

                            if (p.vampirism > 0 && applied > 0) {
                                let healAmount = applied * p.vampirism;
                                healAmount = Math.max(healAmount, 0.1);
                                healAmount = Math.min(healAmount, 0.4);
                                p.hp = Math.min(p.hpMax, p.hp + healAmount);
                            }
                        }

                        // Check collision with laser 2
                        if (isPointNearLine(enemy.x, enemy.y, p.x, p.y, laser2EndX, laser2EndY, laserWidth)) {
                            let damage = 6 * p.dmgMult; // Base wiper laser damage
                            const hittingBoss = enemy === store.boss;
                            if (hittingBoss) damage *= 0.3; // Reduced damage to boss

                            const wiperVuln = applySubclassVulnerability(enemy, damage, {
                                subclass: p.subclass,
                                player: p,
                                damageTags: ['void', 'magic'],
                                source: 'wiperLaser',
                                baseDamage: damage
                            });
                            damage = wiperVuln.damage;

                            let applied = damage;
                            if (hittingBoss) {
                                const result = applyBossDamage(store.boss, damage, { point: { x: enemy.x, y: enemy.y } });
                                applied = result.amount;
                            } else {
                                enemy.hp -= damage;
                                store.world.totalDamage += damage;
                            }

                            if (p.vampirism > 0 && applied > 0) {
                                let healAmount = applied * p.vampirism;
                                healAmount = Math.max(healAmount, 0.1);
                                healAmount = Math.min(healAmount, 0.4);
                                p.hp = Math.min(p.hpMax, p.hp + healAmount);
                            }
                        }
                    });
                }
            }

            // Helper function to check if a point is near a line segment
            function isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;

                if (lenSq === 0) return Math.sqrt(A * A + B * B) <= threshold;

                let param = dot / lenSq;
                param = Math.max(0, Math.min(1, param));

                const xx = x1 + param * C;
                const yy = y1 + param * D;

                const dx = px - xx;
                const dy = py - yy;

                return Math.sqrt(dx * dx + dy * dy) <= threshold;
            }

            function fireChainLightning() {
                const p = store.player;

                if (p.stormstrikerLevel >= 3) {
                    // Level 3: Fire four simultaneous chain lightning bolts from all positions (Thunder Lord)
                    const positions = [
                        { x: p.x - 25, y: p.y - 15 }, // Far left
                        { x: p.x - 8, y: p.y - 8 },  // Left wing
                        { x: p.x + 8, y: p.y - 8 },  // Right wing  
                        { x: p.x + 25, y: p.y - 15 } // Far right
                    ];

                    // Fire all four bolts simultaneously
                    positions.forEach(pos => {
                        fireChainLightningBolt(1.0, pos);
                    });
                } else if (p.stormstrikerLevel >= 2) {
                    // Level 2: Fire simultaneous twin lightning from both wing guns
                    const leftWing = { x: p.x - 18, y: p.y - 8 };
                    const rightWing = { x: p.x + 18, y: p.y - 8 };
                    fireChainLightningBolt(1.0, leftWing);
                    fireChainLightningBolt(1.0, rightWing);
                } else if (p.hasHybridVoid) {
                    // Fire single lightning bolt (reduced power for hybrid)
                    fireChainLightningBolt(0.7); // 70% damage for hybrid mode
                } else {
                    // Standard single chain lightning from ship center (default stormbringer)
                    fireChainLightningBolt();
                }
            }

            function fireChainLightningBolt(damageMultiplier = 1.0, startPos = null) {
                const p = store.player;
                const playfieldMargin = 50;
                const allEnemies = (store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead))
                    .filter(e => e.x >= -playfieldMargin && e.x <= W + playfieldMargin && 
                                 e.y >= -playfieldMargin && e.y <= H + playfieldMargin);
                if (allEnemies.length === 0) return;

                // Use custom start position or default to center above player
                const startPoint = startPos || { x: p.x, y: p.y - 20 };

                // Find highest priority initial target (Boss > Champion > Highest HP)
                const bosses = allEnemies.filter(e => e.isBoss);
                const champions = allEnemies.filter(e => e.isChampion && !e.isBoss);
                const regular = allEnemies.filter(e => !e.isBoss && !e.isChampion);
                
                let currentTarget = null;
                if (bosses.length > 0) {
                    currentTarget = bosses.sort((a, b) => b.hp - a.hp)[0];
                } else if (champions.length > 0) {
                    currentTarget = champions.sort((a, b) => b.hp - a.hp)[0];
                } else if (regular.length > 0) {
                    currentTarget = regular.sort((a, b) => b.hp - a.hp)[0];
                }

                if (!currentTarget) return;

                const maxJumps = 100; // High limit for unlimited potential with probabilistic limiting
                const chainChance = 0.65; // 65% chance to chain each jump
                let currentDamage = 95 * p.dmgMult * damageMultiplier * (p.chainLightningDamage || 1.0);
                const targetsHit = new Set();
                const chainPoints = [startPoint];

                for (let i = 0; i < maxJumps && currentTarget; i++) {
                    targetsHit.add(currentTarget);
                    chainPoints.push({ x: currentTarget.x, y: currentTarget.y });

                    // Create blue lightning flash at hit point
                    store.activeEffects.push(createEffect('lightningFlash', currentTarget.x, currentTarget.y));

                    let dmg = currentDamage;
                    const hittingBoss = currentTarget === store.boss;
                    if (hittingBoss) dmg *= 0.3;
                    const lightningResult = applySubclassVulnerability(currentTarget, dmg, {
                        subclass: store.player.subclass,
                        player: store.player,
                        damageTags: ['lightning', 'magic'],
                        source: 'chainLightning',
                        baseDamage: dmg
                    });
                    dmg = lightningResult.damage;
                    let applied = dmg;
                    if (hittingBoss) {
                        const result = applyBossDamage(store.boss, dmg, { point: { x: currentTarget.x, y: currentTarget.y } });
                        applied = result.amount;
                    } else {
                        currentTarget.hp -= dmg;
                        store.world.totalDamage += dmg;
                    }

                    // Apply vampirism healing for chain lightning damage
                    if (store.player.vampirism > 0) {
                        let healAmount = applied * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for lightning
                        healAmount = Math.min(healAmount, 3); // Cap at 3 HP for lightning
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }

                    // Check if the lightning should chain (50% chance each jump)
                    if (Math.random() >= chainChance) {
                        // Chain failed - stop here
                        break;
                    }

                    // Find next target for chaining
                    let nextTarget = null;
                    let nextDistSq = Infinity;
                    allEnemies.forEach(e => {
                        if (e.dead || targetsHit.has(e)) return;
                        const distSq = (currentTarget.x - e.x) ** 2 + (currentTarget.y - e.y) ** 2;
                        if (distSq < nextDistSq) {
                            nextDistSq = distSq;
                            nextTarget = e;
                        }
                    });

                    // If no valid target found, stop chaining
                    if (!nextTarget) break;

                    currentTarget = nextTarget;
                    currentDamage *= 0.85; // Slightly less decay since we have probabilistic limiting
                }

                if (chainPoints.length > 1) {
                    store.lightningBolts.push({
                        points: chainPoints,
                        life: 0.4,
                        maxLife: 0.4,
                        dead: false
                    });
                }
            }

            const VOIDSTEP = {
                cooldownMs: 2500,
                iframeMs: 450,
                riftMs: 600,
                edgePadding: 6
            };
            let lastVoidStep = -9999;
            let invulUntil = 0;
            const rifts = [];
            const blinkFlashes = [];

            // Ensure the result is never NaN

            function spawnBlinkFlash(x, y, life = 200) { blinkFlashes.push({ x, y, life, birth: performance.now(), dead: false }); }
            function spawnRift(x1, y1, x2, y2, life = VOIDSTEP.riftMs) {
                rifts.push({ x1, y1, x2, y2, birth: performance.now(), life, dead: false });
            }

            function executeBlinkLineDamage(player, start, end, damageMultiplier = 1) {
                if (!player || !player.blinkDamage) return;

                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distSq = dx * dx + dy * dy;
                if (distSq <= 0.001) return;

                // Reduced blink damage for better balance - blink is mobility first, damage second
                const baseDamage = (player.blinkDamageEnhanced ? 45 : 30) * player.dmgMult * damageMultiplier; // Reduced from 200/150

                store.enemies.forEach(e => {
                    if (e.dead) return;
                    const dot = (((e.x - start.x) * dx) + ((e.y - start.y) * dy)) / distSq;
                    if (dot <= 0 || dot >= 1) return;

                    const closestX = start.x + dot * dx;
                    const closestY = start.y + dot * dy;
                    const distToLine = Math.sqrt((e.x - closestX) ** 2 + (e.y - closestY) ** 2);
                    if (distToLine > e.r + 10) return;

                    e.hp -= baseDamage;
                    store.world.totalDamage += baseDamage;

                    if (player.vampirism > 0) {
                        let healAmount = baseDamage * player.vampirism;
                        healAmount = Math.max(healAmount, 1);
                        healAmount = Math.min(healAmount, 6);
                        player.hp = Math.min(player.hpMax, player.hp + healAmount);
                    }
                });
            }

            function clampToField(nx, ny) {
                const pad = VOIDSTEP.edgePadding;
                nx = Math.max(pad, Math.min(W - pad, nx));
                ny = Math.max(pad, Math.min(H - pad, ny));
                return { nx, ny };
            }

            function tryVoidStep(player, target, now = performance.now()) {
                const cd = VOIDSTEP.cooldownMs;
                if (now - lastVoidStep < cd) return false;

                const start = { x: player.x, y: player.y };
                let { nx, ny } = clampToField(target.x, target.y);

                if (player.blinkDamage) {
                    executeBlinkLineDamage(player, start, { x: nx, y: ny });
                }

                spawnRift(start.x, start.y, nx, ny, VOIDSTEP.riftMs);

                player.x = nx; player.y = ny;

                if (typeof mouse !== 'undefined' && !document.body.classList.contains('mobile-controls-active')) {
                    mouse.x = nx;
                    mouse.y = ny;
                }
                invulUntil = now + VOIDSTEP.iframeMs;
                lastVoidStep = now;

                // Phasestriker mastery: Time ripple explosion at destination
                if (player.blinkDamageEnhanced) {
                    // Create time ripple explosion effect
                    store.activeEffects.push(createEffect("timeRippleExplosion", nx, ny));

                    // Damage enemies in explosion radius (reduced for balance)
                    const explosionRadius = 80;
                    const explosionDamage = 40 * player.dmgMult; // Reduced from 120
                    const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
                    targets.forEach(e => {
                        if (e.dead) return;
                        const distSq = (e.x - nx) ** 2 + (e.y - ny) ** 2;
                        if (distSq < explosionRadius ** 2) {
                            e.hp -= explosionDamage;
                            store.world.totalDamage += explosionDamage;
                        }
                    });
                }

                // Impact shockwave for earthquake enhancement
                if (player.hasImpactPhase) {
                    createImpactShockwave(nx, ny, player.dmgMult);
                }

                spawnBlinkFlash(nx, ny);
                return true;
            }
            function performBlinkSlash(player, bullet, now = performance.now()) {
                const cd = VOIDSTEP.cooldownMs;
                if (player.isBlinkSlashing) return false;
                if (now - lastVoidStep < cd) return false;

                const origin = { x: player.x, y: player.y };

                let dirX = -(bullet?.vx || 0);
                let dirY = -(bullet?.vy || 0);
                if (Math.abs(dirX) < 0.001 && Math.abs(dirY) < 0.001 && bullet) {
                    dirX = bullet.x - origin.x;
                    dirY = bullet.y - origin.y;
                }
                let mag = Math.hypot(dirX, dirY);
                if (mag < 0.001) {
                    dirX = 0;
                    dirY = -1;
                    mag = 1;
                }
                dirX /= mag;
                dirY /= mag;

                const blinkRange = Math.min(player.blinkRange || 250, 320);
                const searchRadius = blinkRange * 1.1;

                const candidates = [];
                store.enemies.forEach(e => {
                    if (e.dead) return;
                    const dx = e.x - origin.x;
                    const dy = e.y - origin.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= searchRadius * searchRadius) {
                        candidates.push({ x: e.x, y: e.y, dist: Math.sqrt(distSq) });
                    }
                });

                candidates.sort((a, b) => a.dist - b.dist);
                const maxTargets = 4;
                const selected = candidates.slice(0, maxTargets);
                for (let i = selected.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [selected[i], selected[j]] = [selected[j], selected[i]];
                }

                const slashPoints = selected.map(candidate => {
                    const offsetAngle = Math.random() * Math.PI * 2;
                    const offsetDist = Math.random() * 35;
                    const tx = candidate.x + Math.cos(offsetAngle) * offsetDist;
                    const ty = candidate.y + Math.sin(offsetAngle) * offsetDist;
                    const clamped = clampToField(tx, ty);
                    return { x: clamped.nx, y: clamped.ny };
                });

                if (!slashPoints.length) {
                    const fallbackCount = 3;
                    for (let i = 0; i < fallbackCount; i++) {
                        const angleVariance = (Math.random() - 0.5) * Math.PI * 0.9;
                        const baseAngle = Math.atan2(dirY, dirX);
                        const angle = baseAngle + angleVariance;
                        const dist = blinkRange * (0.35 + Math.random() * 0.4);
                        const clampPos = clampToField(
                            origin.x + Math.cos(angle) * dist,
                            origin.y + Math.sin(angle) * dist
                        );
                        slashPoints.push({ x: clampPos.nx, y: clampPos.ny });
                    }
                }

                const legDelay = 120;
                const initialDelay = 60;
                const totalDuration = initialDelay + legDelay * (slashPoints.length + 1);

                invulUntil = now + VOIDSTEP.iframeMs + totalDuration;
                lastVoidStep = now;
                player.autoBlinkLastTrigger = now;
                player.isBlinkSlashing = true;
                if (bullet) {
                    bullet.dead = true;
                }

                spawnBlinkFlash(origin.x, origin.y, 320);

                const runSlashStep = (index, currentPos) => {
                    const isReturn = index >= slashPoints.length;
                    const dest = isReturn ? origin : slashPoints[index];
                    const dx = dest.x - currentPos.x;
                    const dy = dest.y - currentPos.y;
                    const hasTravel = Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5;

                    if (hasTravel) {
                        spawnRift(currentPos.x, currentPos.y, dest.x, dest.y, VOIDSTEP.riftMs * 1.5);
                        const damageMultiplier = isReturn
                            ? (slashPoints.length ? 1.1 : 1.0)
                            : (index === 0 ? 1.2 : 1.0);
                        executeBlinkLineDamage(player, currentPos, dest, damageMultiplier);
                    }

                    spawnBlinkFlash(dest.x, dest.y, isReturn ? 340 : 280);
                    player.x = dest.x;
                    player.y = dest.y;

                    if (isReturn) {
                        player.isBlinkSlashing = false;
                        player.autoBlinkLastTrigger = performance.now();
                        invulUntil = performance.now() + VOIDSTEP.iframeMs * 1.2;
                        spawnBlinkFlash(origin.x, origin.y, 360);
                        return;
                    }

                    setTimeout(() => runSlashStep(index + 1, dest), legDelay);
                };

                setTimeout(() => runSlashStep(0, origin), initialDelay);
                return true;
            }

            const AUTO_BLINK_DEFAULT_LOOKAHEAD = 0.45;
            const AUTO_BLINK_MIN_SPEED = 40;

            function attemptAutoBlink(player, bullet, now = performance.now()) {
                if (!player || !bullet) return false;
                if (!player.autoBlinkEnabled || !player.hasBlink) return false;
                if (player.isBlinkSlashing) return false;
                if (store.isPaused || store.isGameOver) return false;
                if (store.boss && !store.boss.dead) return false;
                if (playerIsInvulnerable()) return false;

                const range = player.autoBlinkRange || Math.max(150, (player.blinkRange || 0) * 0.6);
                const dx = player.x - bullet.x;
                const dy = player.y - bullet.y;
                const distSq = dx * dx + dy * dy;
                if (distSq > range * range) return false;

                const vx = bullet.vx || 0;
                const vy = bullet.vy || 0;
                const speedSq = vx * vx + vy * vy;
                if (speedSq < AUTO_BLINK_MIN_SPEED * AUTO_BLINK_MIN_SPEED) return false;

                const dist = Math.sqrt(distSq) || 1;
                const speed = Math.sqrt(speedSq);
                const approach = vx * dx + vy * dy;
                if (approach <= 0) return false; // Bullet moving away or across

                const lookahead = player.autoBlinkLookahead ?? AUTO_BLINK_DEFAULT_LOOKAHEAD;
                if (dist / speed > lookahead) return false; // Too early to react

                if (player.autoBlinkLastTrigger && now - player.autoBlinkLastTrigger < 200) return false;

                return performBlinkSlash(player, bullet, now);
            }

            // Impact shockwave system for earthquake enhancement
            const impactRipples = [];

            function createImpactShockwave(x, y, dmgMult) {
                const shockDamage = 200 * dmgMult;  // High impact damage
                const maxRadius = 120;  // Large earthquake radius

                // Create expanding ripple effect
                impactRipples.push({
                    x: x, y: y,
                    radius: 0,
                    maxRadius: maxRadius,
                    life: 0.8,
                    maxLife: 0.8,
                    birth: performance.now(),
                    dead: false
                });

                // Damage all enemies in impact radius
                store.enemies.forEach(e => {
                    if (e.dead) return;
                    const dist = Math.sqrt((e.x - x) ** 2 + (e.y - y) ** 2);
                    if (dist <= maxRadius) {
                        const damageFalloff = 1.0 - (dist / maxRadius) * 0.3; // 30% falloff at edge
                        const actualDamage = shockDamage * damageFalloff;
                        e.hp -= actualDamage;
                        store.world.totalDamage += actualDamage;

                        // Knockback effect
                        if (dist > 0) {
                            const knockbackForce = 200;
                            const knockbackX = (e.x - x) / dist * knockbackForce;
                            const knockbackY = (e.y - y) / dist * knockbackForce;
                            e.knockback = { x: knockbackX, y: knockbackY, duration: 0.3, timer: 0.3 };
                        }
                    }
                });

                // Damage boss if in range
                if (store.boss && !store.boss.dead) {
                    const dist = Math.sqrt((store.boss.x - x) ** 2 + (store.boss.y - y) ** 2);
                    if (dist <= maxRadius) {
                        const damageFalloff = 1.0 - (dist / maxRadius) * 0.3;
                        const bossDamage = shockDamage * damageFalloff * 0.4;
                        applyBossDamage(store.boss, bossDamage, { point: { x, y } });
                    }
                }
            }

            function updateImpactSystem() {
                const now = performance.now();
                for (const ripple of impactRipples) {
                    if (ripple.dead) continue;

                    const age = (now - ripple.birth) / 1000; // Convert to seconds
                    ripple.radius = (age / ripple.maxLife) * ripple.maxRadius;

                    if (age >= ripple.maxLife) {
                        ripple.dead = true;
                    }
                }

                // Remove dead ripples
                for (let i = impactRipples.length - 1; i >= 0; i--) {
                    if (impactRipples[i].dead) {
                        impactRipples.splice(i, 1);
                    }
                }
            }

            function renderImpactSystem(ctx) {
                for (const ripple of impactRipples) {
                    if (ripple.dead) continue;

                    const now = performance.now();
                    const age = (now - ripple.birth) / 1000;
                    const progress = age / ripple.maxLife;
                    const alpha = 1.0 - progress; // Fade out over time

                    ctx.save();
                    ctx.globalAlpha = alpha * 0.6;
                    ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;  // Yellow earthquake ripples
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner ripple for more impact
                    if (progress < 0.7) {
                        ctx.globalAlpha = alpha * 0.4;
                        ctx.strokeStyle = `rgba(255, 200, 0, ${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(ripple.x, ripple.y, ripple.radius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            function updateVoidStepSystems(enemies) {
                for (const r of rifts) if (!r.dead) {
                    if (performance.now() - r.birth >= r.life) r.dead = true;
                }
                for (const f of blinkFlashes) if (!f.dead) {
                    if (performance.now() - f.birth >= f.life) f.dead = true;
                }
                for (let i = rifts.length - 1; i >= 0; i--) if (rifts[i].dead) rifts.splice(i, 1);
                for (let i = blinkFlashes.length - 1; i >= 0; i--) if (blinkFlashes[i].dead) blinkFlashes.splice(i, 1);
            }

            function renderVoidStepSystems(ctx) {
                rifts.forEach(r => {
                    const t = (performance.now() - r.birth) / r.life;
                    if (t >= 1) { r.dead = true; return; }
                    const a = (1 - t) * 0.8 + 0.2;
                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.strokeStyle = "#ff99cc";
                    ctx.lineWidth = 10 * (1 - t);
                    ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 25 * (1 - t);
                    ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
                    ctx.restore();
                });
                blinkFlashes.forEach(f => {
                    const t = (performance.now() - f.birth) / f.life;
                    if (t >= 1) { f.dead = true; return; }
                    ctx.save();
                    ctx.globalAlpha = 1 - t;
                    ctx.strokeStyle = "#ff99cc";
                    ctx.lineWidth = 4 * (1 - t);
                    ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, 20 + 30 * t, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 1 - t * t;
                    ctx.beginPath(); ctx.arc(f.x, f.y, 20 * (1 - t), 0, Math.PI * 2);
                    ctx.fillStyle = "#ffddff"; ctx.fill();
                    ctx.restore();
                });
            }

            function playerIsInvulnerable() { return performance.now() < invulUntil; }

            function screenFlash(count, duration, color) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        store.activeEffects.push(createEffect("screenFlash", 0, duration, color));
                    }, i * (duration / 2));
                }
            }

            // --- PAUSE & MENU LOGIC ---
            const PANELS = ['namePanel', 'pilotPanel', 'scorePanel', 'levelPanel', 'shopPanel', 'storyPanel', 'subclassPanel', 'teleportTutorialPanel', 'championDressingRoom', 'mechForgeMenuPanel', 'characterSheetPanel', 'upgradePopupPanel'];
            function isAnyPanelOpen() {
                return PANELS.some(id => !q(id).classList.contains('hide'));
            }

            function pauseGame() {
                if (!store.isPaused) {
                    store.isPaused = true;
                    q('pauseBtn').classList.add('hide');
                }
            }

            function resumeGame() {
                if (!isAnyPanelOpen()) {
                    clearPanelStack();
                    store.isPaused = false;
                    q('pauseBtn').classList.remove('hide');
                    q('pauseBtn').textContent = 'PAUSE';
                }
            }

            function showUpgradePopup(upgradeInfo) {
                if (!upgradeInfo) return;
                
                const panel = q('upgradePopupPanel');
                const icon = q('upgradePopupIcon');
                const title = q('upgradePopupTitle');
                const desc = q('upgradePopupDesc');
                const tier = q('upgradePopupTier');
                
                if (icon) icon.textContent = upgradeInfo.icon || 'âš¡';
                if (title) title.textContent = upgradeInfo.name || 'UPGRADE ACQUIRED';
                if (desc) desc.textContent = upgradeInfo.desc || 'Enhancement applied to your systems.';
                if (tier) {
                    const tierText = upgradeInfo.tier === 'bossTier' ? 'BOSS-TIER UPGRADE' : 'MID-TIER UPGRADE';
                    tier.textContent = tierText;
                    tier.style.color = upgradeInfo.tier === 'bossTier' ? '#ff6b6b' : '#4ecdc4';
                }
                
                pauseGame();
                panel.classList.remove('hide');
            }

            // --- EVENT LISTENERS & INITIALIZATION ---
            function showPilotSelect() {
                playSound('epicHorn');
                pauseGame();
                const panel = q('pilotPanel');

                panel.classList.remove('hide');
                const cards = panel.querySelectorAll('.skill-card');

                const clickHandler = (e) => {
                    const card = e.currentTarget;
                    const genome = card.dataset.genome;
                    store.player.pilotGenome = genome;
                    panel.classList.add('hide');
                    applyGenomeBonus(genome);

                    // Spend progression point for successful class selection
                    spendProgressionPoint();

                    // Update mobile controls ability button icon
                    updateAbilityButtonIcon();

                    // Resume game for all genomes (removed teleport tutorial popup)
                    resumeGame();
                    cards.forEach(c => c.removeEventListener('click', clickHandler));
                };

                cards.forEach(card => {
                    card.addEventListener('click', clickHandler);
                });
            }

            function showTeleportTutorial() {
                const panel = q('teleportTutorialPanel');
                panel.classList.remove('hide');

                // Set up close button handler
                const closeBtn = q('closeTeleportTutorial');
                const closeHandler = () => {
                    panel.classList.add('hide');
                    closeBtn.removeEventListener('click', closeHandler);
                    resumeGame();
                };

                closeBtn.addEventListener('click', closeHandler);
            }

            // --- GIBBING EFFECT ---

            // Initialize the gibs array in your game's store
            store.gibs = [];

            /**
             * Spawns a cluster of gib particles at a specific location.
             * Call this function when an enemy dies.
             * @param {number} x - The x-coordinate of the enemy.
             * @param {number} y - The y-coordinate of the enemy.
             * @param {string} color - The base color of the enemy.
             * @param {number} [amount=15] - The number of gibs to create.
             */
            function spawnGibs(x, y, color, amount = 12) {
                for (let i = 0; i < amount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 150;
                    const size = 2 + Math.random() * 4;
                    const life = 0.5 + Math.random() * 0.5;

                    store.gibs.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: size,
                        life,
                        maxLife: life,
                        color,
                        gravity: 300, // Pulls gibs downward
                    });
                }
            }

            /**
             * Updates the position and lifetime of all active gibs.
             * This should be called once per frame from your main game loop.
             * @param {number} dt - Delta time, the time since the last frame.
             */
            function updateGibs(dt) {
                for (let i = store.gibs.length - 1; i >= 0; i--) {
                    const gib = store.gibs[i];

                    // Apply physics
                    gib.vy += gib.gravity * dt;
                    gib.x += gib.vx * dt;
                    gib.y += gib.vy * dt;
                    gib.life -= dt;

                    // Remove gibs that have expired
                    if (gib.life <= 0) {
                        store.gibs.splice(i, 1);
                    }
                }
            }

            /**
             * Draws all active gibs to the canvas.
             * This is called from the main render() function.
             * @param {object} ctx - The 2D rendering context of the canvas.
             */
            function drawGibs(ctx) {
                store.gibs.forEach(gib => {
                    const alpha = gib.life / gib.maxLife; // Fade out effect

                    ctx.save();
                    ctx.globalAlpha = Math.max(0, alpha);
                    ctx.fillStyle = gib.color;
                    ctx.beginPath();
                    ctx.fillRect(gib.x - gib.r / 2, gib.y - gib.r / 2, gib.r, gib.r);
                    ctx.restore();
                });
            }

            function applyGenomeBonus(genome) {
                if (!genome) return;

                // Reset all potential subclass stats to their defaults
                const p = store.player;
                p.subclass = null;
                p.beefMaxCharges = 1;
                p.missilePierce = 0;
                p.missileCluster = false;
                p.blinkDamage = false;
                resetPlayerLightningState(p);
                p.phasestRikerLevel = 0;
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = null;
                p.hasVoidLaser = false;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                p.isBlinkSlashing = false;

                store.world.bossesAtPilotSelection = store.world.bosses;

                switch (genome) {
                    case 'beef':
                        // Base beef no longer gets abilities by default - subclasses must unlock them via skill trees
                        break;
                    case 'voidmancer':
                        // Give +2 multishot base and mild speed boost for base voidmancer
                        p.multishot = (p.multishot || 2) + 2; // Base 2 + 2 = 4 bullets total
                        p.speed = (p.speed || 2.5) * 1.05; // 5% speed boost
                        break;
                    case 'rocketman':
                        // Rocketman no longer auto-gains the frag launcher; keep any previously unlocked state
                        p.hasLauncher = !!p.hasLauncher;
                        break;
                }
            }

            // 5-Node Skill Tree Data Structure + Separate Class Ability - Single focused path per subclass with Omega node
            const SKILL_TREE_DATA = {
                // Each subclass gets a focused 4-node skill tree + Omega node (tier 5) + separate class ability (available immediately)
                marauder: {
                    title: 'MARAUDER MASTERY TREE',
                    path: {
                        name: 'MARAUDER PATH',
                        nodes: [
                            { id: 'marauder_multi_charge', name: 'Multi Charge', desc: 'Gain 3 charge attacks with enhanced chain capability', icon: 'mar11.png', tier: 1 },
                            { id: 'marauder_chain_assault', name: 'Chain Assault', desc: 'Keep charge chains active and add +50% chain damage.', icon: 'mar2.png', tier: 2 },
                            { id: 'marauder_combat_mastery', name: 'Combat Mastery', desc: 'Double chain damage bonuses and boost attack speed by 30%.', icon: 'mar3.png', tier: 3 },
                            { id: 'marauder_elite_warrior', name: 'Elite Warrior', desc: 'Unlock 5 charges and elite double-hits that strike for 3x damage.', icon: 'mar4.png', tier: 4 },
                            { id: 'marauder_omega_burst', name: 'OMEGA BURST', desc: 'Transform multishot into explosive energy orbs that detonate on impact with massive AOE.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' },
                    crossUnlock: { subclass: 'juggernaut', requiredInvestments: 3 },
                    ultimateAbility: { id: 'marauder_clone', name: 'Battle Clone', desc: 'Summon a powerful green clone ally that fights alongside you', icon: 'clone.png', tier: 'ultimate' }
                },
                juggernaut: {
                    title: 'JUGGERNAUT MASTERY TREE',
                    path: {
                        name: 'CHARGE PATH',
                        nodes: [
                            { id: 'juggernaut_charge_power', name: 'Charge Power', desc: '+100% charge damage and knockback, +50% charge range', icon: 'jug1.png', tier: 1 },
                            { id: 'juggernaut_charge_mastery', name: 'Charge Mastery', desc: 'Charge creates damaging shockwave, +2 charge capacity', icon: 'jug22.png', tier: 2 },
                            { id: 'juggernaut_heavy_armor', name: 'Heavy Armor', desc: '+50 HP, 25% damage reduction, knockback immunity', icon: 'jug33.png', tier: 3 },
                            { id: 'juggernaut_unstoppable', name: 'Unstoppable Force', desc: '2.5x explosion radius, 3x damage - devastating impact', icon: 'jug4.png', tier: 4 },
                            { id: 'juggernaut_omega_hammer', name: 'OMEGA HAMMER', desc: 'Transform multishot into devastating hammer projectiles that shatter on impact with shockwave AOE.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' },
                    crossUnlock: { subclass: 'marauder', requiredInvestments: 3 },
                    ultimateAbility: { id: 'juggernaut_clone', name: 'War Clone', desc: 'Summon a powerful green clone ally that fights alongside you', icon: 'clone.png', tier: 'ultimate' }
                },
                railgunner: {
                    title: 'RAILGUNNER MASTERY TREE',
                    path: {
                        name: 'RAILGUN PATH',
                        nodes: [
                            { id: 'railgunner_super_pierce', name: 'Super Pierce', desc: 'Missiles pierce 5 enemies with +30% pierce damage', icon: 'one.png', tier: 1 },
                            { id: 'railgunner_perfect_aim', name: 'Perfect Aim', desc: '+25% critical hit chance with +50% accuracy', icon: 'two.png', tier: 2 },
                            { id: 'railgunner_advanced_ballistics', name: 'Advanced Ballistics', desc: 'Pierce 8 enemies with +80% velocity and homing', icon: 'three.png', tier: 3 },
                            { id: 'railgunner_precision_master', name: 'Precision Master', desc: '+50% critical chance, 2x crit damage, and full railgun mastery.', icon: 'four.png', tier: 4 },
                            { id: 'railgunner_omega_lance', name: 'OMEGA LANCE', desc: 'Transform multishot into piercing energy lances that explode in a line on impact.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'firewall_unlock', name: 'FLAME PULSE', desc: 'UNLOCK: Expanding ring of fire that damages and pushes enemies back', icon: 'firewall.png', tier: 'class' },
                    crossUnlock: { subclass: 'demolitioner', requiredInvestments: 3 },
                    ultimateAbility: { id: 'railgunner_stealth_rockets', name: 'Stealth Rockets', desc: 'More badass rockets!', icon: 'badass.png', tier: 'ultimate' }
                },
                demolitioner: {
                    title: 'DEMOLITIONER MASTERY TREE',
                    path: {
                        name: 'CLUSTER PATH',
                        nodes: [
                            { id: 'demolitioner_bigger_clusters', name: 'Bigger Clusters', desc: 'Cluster bombs are 2x larger with increased blast radius', icon: 'demo1.png', tier: 1 },
                            { id: 'demolitioner_cluster_mastery', name: 'Cluster Mastery', desc: 'Clusters split into secondary explosions, +50% cluster count', icon: 'demo2.png', tier: 2 },
                            { id: 'demolitioner_explosive_mastery', name: 'Explosive Mastery', desc: 'Guarantee 12 cluster bombs and chain detonations across explosions.', icon: 'demo3.png', tier: 3 },
                            { id: 'demolitioner_demolition_expert', name: 'Demolition Expert', desc: 'Double cluster blast radius and add a 30% mega explosion chance.', icon: 'demo4.png', tier: 4 },
                            { id: 'demolitioner_omega_nova', name: 'OMEGA NOVA', desc: 'Transform multishot into unstable nova orbs that create massive chain explosions on impact.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'firewall_unlock', name: 'FLAME PULSE', desc: 'UNLOCK: Expanding ring of fire that damages and pushes enemies back', icon: 'firewall.png', tier: 'class' },
                    crossUnlock: { subclass: 'railgunner', requiredInvestments: 3 },
                    ultimateAbility: { id: 'demolitioner_stealth_rockets', name: 'Stealth Rockets', desc: 'More badass rockets!', icon: 'badass.png', tier: 'ultimate' }
                },
                phasestriker: {
                    title: 'PHASESTRIKER MASTERY TREE',
                    path: {
                        name: 'LASER PATH',
                        nodes: [
                            { id: 'phasestriker_unlimited_range', name: 'Unlimited Range', desc: 'Void laser can target enemies anywhere on screen - no range limitations', icon: 'phase1.png', tier: 1 },
                            { id: 'phasestriker_ramping_power', name: 'Ramping Power', desc: 'Laser increases in size and damage each millisecond on the same target', icon: 'phase2.png', tier: 2 },
                            { id: 'phasestriker_dimensional_control', name: 'Dimensional Control', desc: 'Void laser phases through reality with 2.5x damage', icon: 'phase3.png', tier: 3 },
                            { id: 'phasestriker_double_beam', name: 'Double Long Range Intensifying Beam', desc: 'Fires two parallel beams that intensify over time, dealing massive damage', icon: 'phase4.png', tier: 4 },
                            { id: 'phasestriker_omega_void', name: 'OMEGA VOID', desc: 'Transform multishot into void discs that implode on impact, creating collapsing singularities.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' },
                    crossUnlock: { subclass: 'stormbringer', requiredInvestments: 3 },
                    ultimateAbility: { id: 'phasestriker_wiper_lasers', name: 'Wiper Lasers', desc: 'Two lasers sweep back and forth like windshield wipers!', icon: 'sweep.png', tier: 'ultimate' }
                },
                stormbringer: {
                    title: 'STORMBRINGER MASTERY TREE',
                    path: {
                        name: 'LIGHTNING PATH',
                        nodes: [
                            { id: 'stormbringer_chain_boost', name: 'Twin Lightning', desc: 'Alternating left/right wing lightning at double fire rate', icon: 'storm1.png', tier: 1 },
                            { id: 'stormbringer_storm_mastery', name: 'Storm Mastery', desc: '+50% jump range and +80% chain lightning damage', icon: 'storm2.png', tier: 2 },
                            { id: 'stormbringer_thunder_lord', name: 'Thunder Lord', desc: '4 simultaneous lightning bolts from all positions - devastating coverage', icon: 'storm3.png', tier: 3 },
                            { id: 'stormbringer_storm_god', name: 'Storm God', desc: '3x lightning damage multiplier - omnipotent electrical dominance', icon: 'storm4.png', tier: 4 },
                            { id: 'stormbringer_omega_storm', name: 'OMEGA STORM', desc: 'Transform multishot into charged plasma spheres that unleash chain lightning explosions on impact.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' },
                    crossUnlock: { subclass: 'phasestriker', requiredInvestments: 3 },
                    ultimateAbility: { id: 'stormbringer_wiper_lasers', name: 'Wiper Lasers', desc: 'Two lasers sweep back and forth like windshield wipers!', icon: 'sweep.png', tier: 'ultimate' }
                }
            };

            const SUBCLASSES = {
                rocketman: [
                    { id: 'railgunner', name: 'Railgunner', desc: 'Missiles pierce through multiple enemies with devastating precision.', icon: 'rail.png' },
                    { id: 'demolitioner', name: 'Demolitioner', desc: 'Missiles explode into deadly cluster bombs on impact.', icon: 'demo.png' }
                ],
                beef: [
                    { id: 'juggernaut', name: 'juggernaut', desc: 'Charge ability creates a damaging explosion on impact.', icon: 'jug2.png' },
                    { id: 'marauder', name: 'Marauder', desc: 'Gain a second charge for your special ability.', icon: 'marauder.png' }
                ],
                voidmancer: [
                    { id: 'phasestriker', name: 'Phase Striker', desc: 'Basic short-range void laser that can be upgraded for unlimited range and power.', icon: 'phase.png' },
                    { id: 'stormbringer', name: 'Stormbringer', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                ]
            };

            function showSubclassSelect() {
                pauseGame();
                const panel = q('subclassPanel');
                const grid = q('subclassGrid');
                const skillTree = q('skillTree');
                const genome = store.player.pilotGenome;

                if (!panel || !grid) {
                    console.warn('Subclass UI unavailable; skipping selection.');
                    resumeGame();
                    return;
                }

                // Show traditional card selection for all pilots (including beef)
                const choices = SUBCLASSES[genome];
                if (!choices) {
                    resumeGame();
                    return;
                }
                if (skillTree) {
                    skillTree.classList.add('hide');
                }
                grid.classList.remove('hide');
                panel.classList.remove('skill-tree-active'); // Ensure normal panel size for subclass selection

                grid.innerHTML = choices.map(s => `<div class="skill-card" data-subclass="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');

                grid.querySelectorAll('.skill-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const subclassId = card.dataset.subclass;
                        store.player.subclass = subclassId;
                        applySubclassBonus(subclassId);

                        // Spend progression point for successful subclass selection
                        spendProgressionPoint();

                        // Update mobile controls ability button icon
                        updateAbilityButtonIcon();

                        panel.classList.add('hide');
                        exitPanel('subclassPanel');
                        resumeGame();
                    }, { once: true });
                });

                const heading = panel.querySelector('h2');
                if (heading) {
                    heading.style.display = 'block'; // Show h2 for subclass selection
                }
                panel.classList.remove('hide');
            }

            function showProgressiveSkillTree() {
                showSkillTreeModal();
            }

            function showSkillTreeModal(openedFromForge = false) {
                if (!store.player.pilotGenome || store.player.pilotGenome === 'pending') {
                    return;
                }

                const panel = q('subclassPanel');
                if (!panel) {
                    console.warn('Skill tree panel unavailable; skipping modal open.');
                    resumeGame();
                    return;
                }

                const grid = q('subclassGrid');
                let skillTree = q('skillTree');

                window.skillTreeOpenedFromForge = openedFromForge;
                window.skillTreePinnedOpen = openedFromForge;
                clearSkillTreeAutoCloseTimers();

                if (!openedFromForge) {
                    playSound('epicHorn');
                }

                pauseGame();

                if (grid) {
                    grid.classList.add('hide');
                }

                if (!skillTree) {
                    skillTree = document.createElement('div');
                    skillTree.id = 'skillTree';
                    panel.appendChild(skillTree);
                } else if (!panel.contains(skillTree)) {
                    panel.appendChild(skillTree);
                }

                skillTree.classList.remove('hide');

                panel.classList.remove('hide');
                panel.classList.add('skill-tree-active');
                panel.classList.add('panel-floating-close');
                panel.scrollTop = 0;
                enterPanel('subclassPanel');

                const heading = panel.querySelector('h2');
                if (heading) {
                    if (!panel.dataset.originalHeading) {
                        panel.dataset.originalHeading = heading.textContent || '';
                    }
                    heading.textContent = 'SPECIALIZATION MASTERY';
                    heading.style.display = 'block';
                }

                generateDynamicSkillTree();

                const closeBtn = q('skillTreeCloseBtn');
                if (closeBtn) closeBtn.onclick = () => closeSkillTree();
                const closeBottomBtn = q('skillTreeCloseBottomBtn');
                if (closeBottomBtn) closeBottomBtn.onclick = () => closeSkillTree();
            }

            function viewCurrentSkillTree() {
                showSkillTreeModal(true);
            }

            function isSkillTreePinnedOpen() {
                return window.skillTreePinnedOpen === true;
            }

            function clearSkillTreeAutoCloseTimers() {
                if (Array.isArray(window.skillTreeAutoCloseTimers)) {
                    window.skillTreeAutoCloseTimers.forEach(id => clearTimeout(id));
                    window.skillTreeAutoCloseTimers.length = 0;
                } else {
                    window.skillTreeAutoCloseTimers = [];
                }
            }

            function scheduleSkillTreeAutoClose(delay) {
                if (isSkillTreePinnedOpen()) {
                    return;
                }
                if (!Array.isArray(window.skillTreeAutoCloseTimers)) {
                    window.skillTreeAutoCloseTimers = [];
                }
                const timerId = setTimeout(() => {
                    if (isSkillTreePinnedOpen()) {
                        return;
                    }
                    clearSkillTreeAutoCloseTimers();
                    closeSkillTree();
                }, ensureFiniteNumber(delay, 0));
                window.skillTreeAutoCloseTimers.push(timerId);
            }



            function generateDynamicSkillTree() {
                const skillTreeElement = q('skillTree');
                const genome = store.player.pilotGenome;

                // Map pilot genome to default subclass for skill tree display
                let subclass = store.player.subclass;
                if (!subclass) {
                    // Default subclass based on genome if none selected
                    switch (genome) {
                        case 'rocketman': subclass = 'railgunner'; break;
                        case 'beef': subclass = 'marauder'; break;
                        case 'voidmancer': subclass = 'phasestriker'; break;
                        default:
                            console.error('Unknown pilot genome:', genome);
                            return;
                    }
                }

                // Get the skill tree data for the current subclass
                const treeData = SKILL_TREE_DATA[subclass];
                if (!treeData) {
                    console.error('No skill tree data found for subclass:', subclass);
                    return;
                }

                const buildSkillCard = (node, options = {}) => {
                    const {
                        tier,
                        parentId,
                        extraClasses = '',
                        note = '',
                        crossSource,
                        crossRequired,
                        imageExtraClass = ''
                    } = options;

                    const escapeAttr = value => String(value).replace(/"/g, '&quot;');

                    const classList = ['skill-icon-button', 'locked'];
                    if (extraClasses) {
                        extraClasses.split(' ').filter(Boolean).forEach(cls => classList.push(cls));
                    }

                    const tierAttr = tier ? ` data-tier="${tier}"` : '';
                    const parentAttr = parentId ? ` data-parent="${parentId}"` : '';
                    const crossSourceAttr = crossSource ? ` data-cross-source="${crossSource}"` : '';
                    const crossRequiredAttr = crossRequired ? ` data-cross-required="${crossRequired}"` : '';
                    const noteAttr = note ? ` data-note="${escapeAttr(note)}"` : '';
                    const titleAttr = node.name ? ` data-title="${escapeAttr(node.name)}"` : '';
                    const imageClass = `skill-icon-image${imageExtraClass ? ` ${imageExtraClass}` : ''}`;
                    const noteHTML = note ? `<div class="skill-info-note">${note}</div>` : '';

                    return `
                        <div class="${classList.join(' ')}" data-skill="${node.id}"${tierAttr}${parentAttr}${crossSourceAttr}${crossRequiredAttr}${noteAttr}${titleAttr}>
                            <div class="skill-icon-frame">
                                <img src="${node.icon}" alt="${node.name}" class="${imageClass}">
                            </div>
                            <div class="skill-info-table">
                                <div class="skill-info-row">
                                    <div class="skill-info-label">Ability</div>
                                    <div class="skill-info-value">${node.name}</div>
                                </div>
                                <div class="skill-info-row">
                                    <div class="skill-info-label">Details</div>
                                    <div class="skill-info-value">${node.desc}</div>
                                </div>
                                ${noteHTML}
                            </div>
                        </div>`;
                };

                const formatTitle = (text) => {
                    if (!text) return '';
                    return text
                        .replace(/_/g, ' ')
                        .toLowerCase()
                        .replace(/\b\w/g, char => char.toUpperCase());
                };

                const path = treeData.path;
                const classAbility = treeData.classAbility;
                const crossDetails = getCrossUnlockNode(treeData);
                let crossSummary = '';
                let crossTitle = '';
                if (crossDetails) {
                    crossTitle = crossDetails.tree.title ? crossDetails.tree.title.replace(' MASTERY TREE', '').trim() : crossDetails.tree.path.name;
                }
                const friendlyCrossTitle = crossTitle ? formatTitle(crossTitle) : '';
                if (friendlyCrossTitle) {
                    crossSummary = ` Unlock your signature ability to cross-train into <strong>${friendlyCrossTitle}</strong>.`;
                }

                const pathCardsHTML = path.nodes.map((node, index) => {
                    const card = buildSkillCard(node, {
                        tier: `${index + 1}`,
                        parentId: index > 0 ? path.nodes[index - 1].id : undefined
                    });
                    const connector = index < path.nodes.length - 1 ? '<div class="skill-track-connector" aria-hidden="true"></div>' : '';
                    return card + connector;
                }).join('');

                const signatureEntries = [];
                if (classAbility) {
                    signatureEntries.push({
                        node: classAbility,
                        options: {
                            tier: 'class',
                            extraClasses: 'class-ability-solo',
                            note: 'Unlock this to access crossover training.',
                            imageExtraClass: 'class-ability'
                        }
                    });
                }
                if (crossDetails) {
                    signatureEntries.push({
                        node: crossDetails.node,
                        options: {
                            tier: 'cross',
                            parentId: classAbility ? classAbility.id : undefined,
                            extraClasses: 'cross-ability',
                            note: 'Unlocks after mastering your signature ability.',
                            crossSource: crossDetails.config.subclass
                        }
                    });
                }
                if (treeData.ultimateAbility) {
                    const ultimateOptions = {
                        tier: 'ultimate',
                        parentId: crossDetails ? crossDetails.node.id : 'cross',
                        extraClasses: 'ultimate-ability',
                        note: crossDetails && friendlyCrossTitle ? `Unlocks once your ${friendlyCrossTitle} crossover is mastered.` : 'Unlocks once crossover training is complete.',
                        crossRequired: 'true'
                    };
                    signatureEntries.push({ node: treeData.ultimateAbility, options: ultimateOptions });
                }

                const signatureCardsHTML = signatureEntries.map((entry, index, arr) => {
                    const card = buildSkillCard(entry.node, entry.options);
                    const connector = index < arr.length - 1 ? '<div class="skill-track-connector" aria-hidden="true"></div>' : '';
                    return card + connector;
                }).join('');

                const subclassTitle = formatTitle(subclass);
                const genomeTitle = formatTitle(store.player.pilotGenome || '') || 'Signature';
                const pathToggleLabel = treeData.toggleLabels?.path || `${subclassTitle} Tree (Main Track)`;
                const signatureToggleLabel = treeData.toggleLabels?.signature || `${genomeTitle} Tree`;

                skillTreeElement.innerHTML = `
            <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
            <div class="skill-tree-title">${treeData.title}</div>
            <div class="skill-view-wrapper">
                <div class="skill-view-toggle" role="group" aria-label="Skill tree view">
                    <button type="button" class="skill-view-btn active" data-view="main">
                        <span class="skill-view-badge" aria-hidden="true">PRIMARY</span>
                        <span class="skill-view-label">${pathToggleLabel}</span>
                    </button>
                    <button type="button" class="skill-view-btn" data-view="signature">
                        <span class="skill-view-badge" aria-hidden="true">SIGNATURE</span>
                        <span class="skill-view-label">${signatureToggleLabel}</span>
                    </button>
                </div>
            </div>
            <div class="skill-grid" data-active-view="main">
                <div class="skill-row">
                    <div class="skill-track view-main">
                        <div class="track-title">${path.name}</div>
                        ${pathCardsHTML}
                    </div>
                    <div class="skill-track class-ability-track view-signature">
                        <div class="track-title" style="color: #FFD700;">SIGNATURE TRAINING</div>
                        ${signatureCardsHTML}
                    </div>
                </div>
            </div>
            <div class="skill-description" id="skillDescription">
                Master your ${subclass} specialization through focused training. Spend progression points to unlock path upgrades and your signature ability.${crossSummary}
            </div>
            <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;

                initializeSkillTreeViewToggle();

                // Initialize skill tree progression
                initializeSkillTree();
            }

            function initializeSkillTreeViewToggle() {
                const skillTreeElement = q('skillTree');
                if (!skillTreeElement) return;

                const grid = skillTreeElement.querySelector('.skill-grid');
                const buttons = skillTreeElement.querySelectorAll('.skill-view-btn');
                if (!grid || buttons.length === 0) return;

                const setActiveView = (view) => {
                    const normalized = view === 'signature' ? 'signature' : 'main';
                    grid.dataset.activeView = normalized;
                    buttons.forEach(btn => {
                        const isActive = btn.dataset.view === normalized;
                        btn.classList.toggle('active', isActive);
                        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                    });
                };

                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        setActiveView(btn.dataset.view);
                    });
                });

                setActiveView('main');
            }

            function getActiveSubclassAndTree() {
                const p = store.player;
                let subclass = p.subclass;

                if (!subclass) {
                    switch (p.pilotGenome) {
                        case 'rocketman':
                            subclass = 'railgunner';
                            break;
                        case 'beef':
                            subclass = 'marauder';
                            break;
                        case 'voidmancer':
                            subclass = 'phasestriker';
                            break;
                        default:
                            console.error('Unknown pilot genome for skill tree:', p.pilotGenome);
                            return { subclass: null, treeData: null };
                    }
                }

                const treeData = SKILL_TREE_DATA[subclass];
                if (!treeData) {
                    console.error('Missing skill tree data for subclass:', subclass);
                    return { subclass: null, treeData: null };
                }

                return { subclass, treeData };
            }

            function getCrossUnlockNode(treeData) {
                if (!treeData || !treeData.crossUnlock) return null;
                const otherTree = SKILL_TREE_DATA[treeData.crossUnlock.subclass];
                if (!otherTree || !otherTree.path || !otherTree.path.nodes || otherTree.path.nodes.length === 0) return null;
                return {
                    config: treeData.crossUnlock,
                    tree: otherTree,
                    node: otherTree.path.nodes[0]
                };
            }

            // Old skill tree code - now commented out as we use dynamic trees
            /*
            function generateOldSkillTree() {
                // Old static skill trees removed - now using SKILL_TREE_DATA structure
            }
                    // Create voidmancer skill tree
                    skillTreeElement.innerHTML = `
                        <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
                        <div class="skill-tree-title">VOIDMANCER SPECIALIZATION TREE</div>
                        <div class="skill-grid">
                            <div class="skill-row">
                                <div class="skill-track">
                                    <div class="track-title">PHASE STRIKER</div>
                                    <div class="skill-icon-button available" data-skill="phasestriker" data-tier="1">
                                        <img src="phase.png" alt="Phase Striker" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">PHASE STRIKER</div>
                                            <div class="skill-overlay-desc">Void manipulation specialist with damaging blink teleportation</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="phasestriker_enhanced" data-tier="2" data-parent="phasestriker">
                                        <img src="phase.png" alt="Ramping Laser" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">RAMPING LASER</div>
                                            <div class="skill-overlay-desc">MASTERY: Laser grows in size and damage while fixated on the same target</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="skill-track">
                                    <div class="track-title">STORMBRINGER</div>
                                    <div class="skill-icon-button available" data-skill="stormbringer" data-tier="1">
                                        <img src="storm.png" alt="Stormbringer" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">STORMBRINGER</div>
                                            <div class="skill-overlay-desc">Lightning manipulation specialist with chain lightning weaponry</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="stormbringer_enhanced" data-tier="2" data-parent="stormbringer">
                                        <img src="storm.png" alt="Chain Storm" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">CHAIN STORM</div>
                                            <div class="skill-overlay-desc">MASTERY: Enhanced stormbringer with maximum chain lightning power</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="skill-track">
                                    <div class="track-title">BLINK ABILITY</div>
                                    <div class="skill-icon-button available" data-skill="blink_ability" data-tier="1">
                                        <img src="blink.png" alt="Blink Ability" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">BLINK ABILITY</div>
                                            <div class="skill-overlay-desc">Mobility specialist with instant teleportation and damage</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="blink_ability_enhanced" data-tier="2" data-parent="blink_ability">
                                        <img src="blink.png" alt="Void Step" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">VOID STEP</div>
                                            <div class="skill-overlay-desc">MASTERY: Enhanced blink with area damage and faster cooldown</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="skill-track">
                                    <div class="track-title">VOID LASER</div>
                                    <div class="skill-icon-button available" data-skill="void_laser" data-tier="1">
                                        <img src="voidlaser.png" alt="Void Laser" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">VOID LASER</div>
                                            <div class="skill-overlay-desc">Energy weapons specialist with focused beam attacks</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="void_laser_enhanced" data-tier="2" data-parent="void_laser">
                                        <img src="voidlaser.png" alt="Annihilation Beam" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">ANNIHILATION BEAM</div>
                                            <div class="skill-overlay-desc">MASTERY: Enhanced void laser with ramping damage and wider beam</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-description" id="skillDescription">
                            Choose your specialization path: Phase Striker for void teleportation, Stormbringer for chain lightning, Blink Ability for mobility, Void Laser for focused damage. Mix and match for powerful combos!
                        </div>
                        <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
                } else {
                    // Fallback for unknown pilot types
                    skillTreeElement.innerHTML = `
                        <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
                        <div class="skill-tree-title">UNKNOWN PILOT TYPE</div>
                        <div class="skill-description" id="skillDescription">
                            Skill tree not available for this pilot type.
                        </div>
                        <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
                }
            }
            
            */

            function initializeSkillTree() {
                const p = store.player;
                const { subclass, treeData } = getActiveSubclassAndTree();
                if (!subclass || !treeData) {
                    return;
                }

                // Initialize skill tree properties if needed
                if (!p.skillTree) {
                    p.skillTree = {};
                }

                ensureSkillTrackingLists();
                const learnedSkillSet = new Set(p.learnedSkills || []);

                // Ensure current subclass nodes exist on the player's skill tree map
                treeData.path.nodes.forEach(node => {
                    if (p.skillTree[node.id] === undefined) {
                        p.skillTree[node.id] = false;
                    }
                    if (learnedSkillSet.has(node.id)) {
                        p.skillTree[node.id] = true;
                    }
                });

                if (p.skillTree[treeData.classAbility.id] === undefined) {
                    p.skillTree[treeData.classAbility.id] = false;
                }
                if (learnedSkillSet.has(treeData.classAbility.id)) {
                    p.skillTree[treeData.classAbility.id] = true;
                }

                const crossDetails = getCrossUnlockNode(treeData);
                if (crossDetails && p.skillTree[crossDetails.node.id] === undefined) {
                    p.skillTree[crossDetails.node.id] = false;
                }
                if (crossDetails && learnedSkillSet.has(crossDetails.node.id)) {
                    p.skillTree[crossDetails.node.id] = true;
                }

                if (treeData.ultimateAbility) {
                    const ultimateId = treeData.ultimateAbility.id;
                    if (p.skillTree[ultimateId] === undefined) {
                        p.skillTree[ultimateId] = false;
                    }
                    if (learnedSkillSet.has(ultimateId)) {
                        p.skillTree[ultimateId] = true;
                    }
                }

                if (!p.skillTreeProgress) p.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
                if (typeof p.skillPoints !== 'number') p.skillPoints = 0;
                if (typeof p.skillPointsSpent !== 'number') p.skillPointsSpent = 0;

                // Don't award skill points here - they're awarded in handleBossDefeat
                // Just update the UI with whatever points we have
                updateSkillTreeUI();
                setupSkillTreeHandlers();
            }

            function updateSkillTreeUI() {
                const p = store.player;
                const panel = q('subclassPanel');

                // Early return if skill tree panel is not visible - major performance optimization
                if (!panel || panel.classList.contains('hide') || !panel.classList.contains('skill-tree-active')) {
                    return;
                }

                const iconButtons = document.querySelectorAll('.skill-icon-button');

                // Update button states first, regardless of whether tree will close
                iconButtons.forEach(button => {
                    const skill = button.dataset.skill;
                    const tierRaw = button.dataset.tier;
                    let tier;
                    if (tierRaw === 'class') {
                        tier = 'class';
                    } else if (tierRaw === 'cross') {
                        tier = 'cross';
                    } else if (tierRaw === 'ultimate') {
                        tier = 'ultimate';
                    } else {
                        tier = parseInt(tierRaw, 10);
                    }
                    const parent = button.dataset.parent;

                    // Remove all state classes
                    button.classList.remove('available', 'active', 'locked');

                    if (p.skillTree && p.skillTree[skill]) {
                        // Skill is learned - show active glow effect
                        button.classList.add('active');
                    } else if (canLearnSkill(skill, tier, parent)) {
                        // Skill can be learned - show available state
                        button.classList.add('available');
                    } else {
                        // Skill is locked - show dim state
                        button.classList.add('locked');
                    }
                });

                // Update skill description based on progression state
                const skillDescription = document.getElementById('skillDescription');
                const unspentProgPts = p.unspentProgressionPoints || 0;
                const skillPointsSpent = p.skillPointsSpent || 0;

                const { treeData } = getActiveSubclassAndTree();
                const pathNodes = treeData && Array.isArray(treeData.path?.nodes) ? treeData.path.nodes : [];
                const unlockedPathNodes = pathNodes.filter(node => p.skillTree && p.skillTree[node.id]).length;
                const signatureId = treeData && treeData.classAbility ? treeData.classAbility.id : null;
                const signatureUnlocked = signatureId ? !!(p.skillTree && p.skillTree[signatureId]) : false;
                const crossDetails = treeData ? getCrossUnlockNode(treeData) : null;
                const crossTitle = crossDetails ? (crossDetails.tree.title ? crossDetails.tree.title.replace(' MASTERY TREE', '').trim() : crossDetails.tree.path.name) : '';
                const crossUnlocked = crossDetails ? !!(p.skillTree && p.skillTree[crossDetails.node.id]) : false;
                const ultimateAbility = treeData ? treeData.ultimateAbility : null;
                const ultimateUnlocked = ultimateAbility ? !!(p.skillTree && p.skillTree[ultimateAbility.id]) : false;

                const statusLines = [];
                if (pathNodes.length) {
                    statusLines.push(`<div class="skill-status-line">Path progress: <strong>${unlockedPathNodes}/${pathNodes.length}</strong></div>`);
                }
                if (signatureId) {
                    statusLines.push(`<div class="skill-status-line">Signature ability: <strong>${signatureUnlocked ? 'Unlocked' : 'Locked'}</strong></div>`);
                }
                if (crossDetails) {
                    const crossStateText = crossUnlocked
                        ? `${crossTitle} active`
                        : signatureUnlocked
                            ? `${crossTitle} available`
                            : 'Locked â€” master your signature ability first';
                    statusLines.push(`<div class="skill-status-line">Crossover: <strong>${crossStateText}</strong></div>`);
                }
                if (ultimateAbility) {
                    statusLines.push(`<div class="skill-status-line">Ultimate ability: <strong>${ultimateUnlocked ? 'Ready' : 'Locked'}</strong></div>`);
                }

                if (skillDescription) {
                    const statusMarkup = statusLines.join('');
                    if (unspentProgPts === 0) {
                        skillDescription.innerHTML = `
                    <div class="skill-status-heading readonly">Read-only overview</div>
                    <div class="skill-status-body">Defeat bosses to earn specialization points, then invest them to advance your path.</div>
                    ${statusMarkup}
                    <div class="skill-status-line">Points spent so far: <strong>${skillPointsSpent}</strong></div>
                `;
                    } else {
                        skillDescription.innerHTML = `
                    <div class="skill-status-heading">Progression ready</div>
                    <div class="skill-status-body">You have <strong>${unspentProgPts}</strong> specialization point${unspentProgPts !== 1 ? 's' : ''} awaiting assignment.</div>
                    ${statusMarkup}
                `;
                    }
                    skillDescription.dataset.defaultDescription = skillDescription.innerHTML;
                }

                const availableNodes = Array.from(iconButtons).some(button => button.classList.contains('available'));
                const openedFromMechForge = window.skillTreeOpenedFromForge;
                if (!unspentProgPts && !availableNodes && !openedFromMechForge) {
                    const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
                    scheduleSkillTreeAutoClose(delay);
                    return;
                }

                // If tree is fully capped, also close it
                if (isSkillTreeFullyCapped()) {
                    const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
                    scheduleSkillTreeAutoClose(delay);
                    return;
                }

                // If 4 skill points have been spent, don't auto-close (allow viewing)
                // const skillPointsSpent = p.skillPointsSpent || 0;
                // if (skillPointsSpent >= 4 && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                //     setTimeout(() => {
                //         console.log(`Auto-closing skill tree from updateSkillTreeUI - 4 skill points spent (${skillPointsSpent}/4)`);
                //         closeSkillTree();
                //     }, 100);
                //     return;
                // }
            }

            function canLearnSkill(skill, tier, parent) {
                const p = store.player;

                // Can't learn a skill that's already learned
                if (p.skillTree && p.skillTree[skill]) return false;

                // Initialize progression tracking
                initializeProgressionTracking();

                const totalUnspentPts = p.unspentProgressionPoints || 0;
                const totalSpentPts = p.skillPointsSpent || 0;

                // NEW PROGRESSION SYSTEM:
                if (tier === 'class') {
                    // Signature abilities become available as soon as a progression point is free
                    return totalUnspentPts > 0;
                }

                if (tier === 'cross') {
                    const hasSignatureUnlocked = parent && p.skillTree && p.skillTree[parent];
                    return totalUnspentPts > 0 && !!hasSignatureUnlocked;
                }

                if (tier === 1) {
                    // Tier 1 skills: First unlock once a progression point is available
                    return totalUnspentPts > 0;
                }

                if (tier === 2) {
                    // Tier 2 skills: Need one prior spend and the tier 1 parent
                    return totalUnspentPts > 0 && totalSpentPts >= 1 && p.skillTree && p.skillTree[parent];
                }

                if (tier === 3) {
                    // Tier 3 skills: Need two prior spends and the tier 2 parent
                    return totalUnspentPts > 0 && totalSpentPts >= 2 && p.skillTree && p.skillTree[parent];
                }

                if (tier === 4) {
                    // Tier 4 skills: Need three prior spends and the tier 3 parent
                    return totalUnspentPts > 0 && totalSpentPts >= 3 && p.skillTree && p.skillTree[parent];
                }

                if (tier === 'ultimate') {
                    // Ultimate skills: Need the crossover skill (parent) to be unlocked
                    const hasCrossoverUnlocked = parent && p.skillTree && p.skillTree[parent];
                    return totalUnspentPts > 0 && !!hasCrossoverUnlocked;
                }

                return false;
            }

            function setupSkillTreeHandlers() {
                const iconButtons = document.querySelectorAll('.skill-icon-button');
                const description = q('skillDescription');
                if (description) {
                    description.dataset.defaultDescription = description.dataset.defaultDescription || description.innerHTML;
                }

                // Remove any existing handlers first to prevent duplicates
                iconButtons.forEach(button => {
                    button.replaceWith(button.cloneNode(true));
                });

                // Re-query after cloning to get fresh elements
                const freshButtons = document.querySelectorAll('.skill-icon-button');

                // Updated skill descriptions sourced from tree data + key legacy abilities
                const skillDescriptions = {};
                const addSkillDescription = (id, name, desc) => {
                    if (!id || !name || !desc) return;
                    skillDescriptions[id] = { name, desc };
                };

                Object.values(SKILL_TREE_DATA).forEach(treeData => {
                    if (treeData.path && Array.isArray(treeData.path.nodes)) {
                        treeData.path.nodes.forEach(node => {
                            addSkillDescription(node.id, node.name, node.desc);
                        });
                    }
                    if (treeData.classAbility) {
                        addSkillDescription(treeData.classAbility.id, treeData.classAbility.name, treeData.classAbility.desc);
                    }
                    if (treeData.ultimateAbility) {
                        addSkillDescription(treeData.ultimateAbility.id, treeData.ultimateAbility.name, treeData.ultimateAbility.desc);
                    }
                });

                [
                    { id: 'blink_ability', name: 'Blink Assault', desc: 'Unlocks a damaging blink teleport for rapid repositioning.' },
                    { id: 'blink_ability_enhanced', name: 'Blink Assault+', desc: 'Enhances blink with wider range, area damage, and faster recharge.' },
                    { id: 'void_laser', name: 'Void Laser', desc: 'Activates the void laser beam weapon for precise, sustained damage.' },
                    { id: 'void_laser_enhanced', name: 'Void Laser+', desc: 'Supercharges the void laser with ramping power and a wider beam.' },
                    { id: 'flame_barrier', name: 'Flame Barrier', desc: 'Deploys a protective wall of fire that scorches incoming threats.' },
                    { id: 'flame_barrier_enhanced', name: 'Flame Barrier+', desc: 'Fortifies the flame barrier with explosive retaliation and longer uptime.' },
                    { id: 'missile_volley', name: 'Missile Volley', desc: 'Fires a multi-missile salvo for overwhelming burst damage.' },
                    { id: 'missile_volley_enhanced', name: 'Missile Volley+', desc: 'Maximizes missile volleys with faster reload and additional rockets.' },
                    { id: 'beef_shield', name: 'Beef Shield', desc: 'Activates regenerating armor plating that absorbs incoming damage.' },
                    { id: 'beef_shield_enhanced', name: 'Beef Shield+', desc: 'Improves the beef shield with faster regeneration and reflective plating.' },
                    { id: 'beef_charge', name: 'Beef Charge', desc: 'Unlocks a devastating beef charge rush attack.' },
                    { id: 'beef_charge_enhanced', name: 'Beef Charge+', desc: 'Boosts charge range and impact for unstoppable momentum.' },
                    { id: 'firewall_unlock', name: 'Flame Pulse', desc: 'Unlocks Flame Pulse: expanding fire ring that damages and pushes enemies away.' },
                    { id: 'blink_unlock', name: 'Blink', desc: 'Unlocks the Blink signature ability for instantaneous teleportation.' },
                    { id: 'beef_shield_unlock', name: 'Beef Shield', desc: 'Unlocks the Beef Shield signature ability for defensive fortification.' }
                ].forEach(entry => addSkillDescription(entry.id, entry.name, entry.desc));

                const defaultDescriptionHTML = description ? (description.dataset.defaultDescription || description.innerHTML) : '';

                // Add hover effects to icon buttons
                freshButtons.forEach(button => {
                    const skill = button.dataset.skill;

                    button.addEventListener('mouseenter', () => {
                        if (!description) return;
                        const info = skillDescriptions[skill];
                        const note = button.dataset.note ? `<div class="skill-hover-note">${button.dataset.note}</div>` : '';
                        if (info) {
                            description.innerHTML = `
                        <div class="skill-hover-title">${info.name}</div>
                        <div class="skill-hover-body">${info.desc}</div>
                        ${note}
                    `;
                        } else {
                            const fallbackTitle = button.dataset.title || (button.querySelector('.skill-info-value')?.textContent?.trim() || 'Specialization Node');
                            description.innerHTML = `
                        <div class="skill-hover-title">${fallbackTitle}</div>
                        <div class="skill-hover-body">Review the specialization card for full details.</div>
                        ${note}
                    `;
                        }
                    });

                    button.addEventListener('mouseleave', () => {
                        if (!description) return;
                        const fallback = description.dataset.defaultDescription || defaultDescriptionHTML;
                        if (fallback) {
                            description.innerHTML = fallback;
                        }
                    });
                });

                // Click handlers - icon buttons are directly clickable
                freshButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // Skill button clicked
                        if (button.classList.contains('available')) {
                            const skill = button.dataset.skill;
                            // About to learn skill
                            learnSkill(skill);
                        }
                    });
                });
            }

            let isLearningSkill = false;

            function learnSkill(skill) {
                if (isLearningSkill) {
                    // Already learning a skill, ignoring duplicate call
                    return;
                }

                isLearningSkill = true;

                try {
                    const p = store.player;
                    const skillButton = document.querySelector(`[data-skill="${skill}"]`);
                    if (!skillButton) {
                        console.warn(`Skill button for ${skill} not found.`);
                        isLearningSkill = false;
                        return;
                    }

                    const tierRaw = skillButton.dataset.tier;
                    let tier;
                    if (tierRaw === 'class') {
                        tier = 'class';
                    } else if (tierRaw === 'cross') {
                        tier = 'cross';
                    } else if (tierRaw === 'ultimate') {
                        tier = 'ultimate';
                    } else {
                        tier = parseInt(tierRaw, 10);
                    }
                    const parentId = skillButton.dataset.parent;

                    if (!canLearnSkill(skill, tier, parentId)) {
                        isLearningSkill = false;
                        return;
                    }

                    const spentPoint = spendProgressionPoint();
                    if (!spentPoint) {
                        isLearningSkill = false;
                        return;
                    }

                    if (!p.skillTree) p.skillTree = {};
                    p.skillTree[skill] = true;
                    ensureSkillTrackingLists();
                    if (!p.learnedSkills.includes(skill)) {
                        p.learnedSkills.push(skill);
                    }
                    if (p.skillPoints > 0) {
                        p.skillPoints--;
                    }
                    p.skillPointsSpent = (p.skillPointsSpent || 0) + 1; // Track total spent

                    // Handle signature ability flag for class tier skills
                    if (tier === 'class') {
                        if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
                            p.signatureAbilities = {};
                        }
                        p.signatureAbilities[skill] = true;
                        p.signatureAbility = true;
                    }

                    // Apply the skill effects
                    applySkillBonus(skill);

                    // Check for combo when both base skills are learned
                    // Check for combo when both base skills are learned
                    const pilotType = p.pilotGenome;
                    if (tier === 1) {
                        if (pilotType === 'beef' && p.skillTree.marauder && p.skillTree.juggernaut) {
                            p.beefDoubleCharge = true;
                            announce('DOUBLE CHARGE COMBO ACTIVATED!');
                        } else if (pilotType === 'rocketman' && p.skillTree.railgunner && p.skillTree.demolitioner) {
                            p.rocketmanHybrid = true;
                            announce('HYBRID MISSILES COMBO ACTIVATED!');
                        } else if (pilotType === 'voidmancer' && p.skillTree.phasestriker && p.skillTree.stormbringer) {
                            p.voidmancerHybrid = true;
                            announce('VOID STORM COMBO ACTIVATED!');
                        }
                    }

                    updateSkillTreeUI();

                    // Update remaining skill points display

                    // Check if tree is now fully capped
                    if (isSkillTreeFullyCapped()) {
                        const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                        scheduleSkillTreeAutoClose(delay);
                    } else {
                        // Check if no progression is available
                        const unspentProgPts = p.unspentProgressionPoints || 0;
                        const skillPointsSpent = p.skillPointsSpent || 0;
                        const hasSignature = p.signatureAbility;
                        const canProgress = unspentProgPts > 0 || (!hasSignature && unspentProgPts > 0) || (skillPointsSpent >= 2 && skillPointsSpent < 5);

                        if (!canProgress) {
                            const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                            scheduleSkillTreeAutoClose(delay);
                        }
                    }
                    // Note: No longer auto-closing when 4 skill points are spent - allow viewing
                } catch (error) {
                    console.error('Error in learnSkill:', error);
                } finally {
                    isLearningSkill = false;
                }
            }

            function closeSkillTree() {
                // Clear the flag for Upgrade Hangar opened skill tree
                window.skillTreeOpenedFromForge = false;
                window.skillTreePinnedOpen = false;
                clearSkillTreeAutoCloseTimers();

                const panel = q('subclassPanel');
                if (!panel) {
                    resumeGame();
                    return;
                }

                const skillTree = q('skillTree');
                if (skillTree) {
                    skillTree.classList.add('hide');
                }

                if (panel.dataset && panel.dataset.originalHeading) {
                    const heading = panel.querySelector('h2');
                    if (heading) {
                        heading.textContent = panel.dataset.originalHeading;
                    }
                }

                panel.classList.add('hide');
                panel.classList.remove('skill-tree-active');
                panel.classList.remove('panel-floating-close');
                exitPanel('subclassPanel');
                resumeGame();
            }

            function isSkillTreeFullyCapped() {
                const p = store.player;
                const { subclass, treeData } = getActiveSubclassAndTree();

                if (!p.skillTree || !subclass || !treeData) return false;

                const pathNodes = treeData.path.nodes.map(node => node.id);
                const pathComplete = pathNodes.every(skill => p.skillTree[skill] === true);
                if (!pathComplete) return false;

                const crossDetails = getCrossUnlockNode(treeData);
                if (crossDetails && !p.skillTree[crossDetails.node.id]) return false;

                // Check ultimate ability if it exists
                if (treeData.ultimateAbility && !p.skillTree[treeData.ultimateAbility.id]) return false;

                return true;
            }

            function ensurePhasestrikerLoadout(p) {
                let newlyUnlocked = false;

                if (!p.hasPhasestriker) {
                    p.hasPhasestriker = true;
                    newlyUnlocked = true;
                }

                if (!p.hasVoidLaser) {
                    p.hasVoidLaser = true;
                    newlyUnlocked = true;
                }

                if (p.voidLaserTarget === undefined) {
                    p.voidLaserTarget = null;
                }
                if (p.voidLaserDamageTimer === undefined) {
                    p.voidLaserDamageTimer = 0;
                }
                if (p.voidLaserRetargetTimer === undefined) {
                    p.voidLaserRetargetTimer = 0;
                }

                const baseRange = 250;
                if (!p.voidLaserRange || p.voidLaserRange < baseRange) {
                    p.voidLaserRange = baseRange;
                }
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel || 0, 0.5);

                return newlyUnlocked;
            }

            function resetPlayerLightningState(p, { preserveUnlock = false } = {}) {
                if (!p) return;

                if (!preserveUnlock) {
                    p.hasStormbringer = false;
                }

                const keepAbility = preserveUnlock && p.hasStormbringer;
                if (!keepAbility) {
                    p.hasChainLightning = false;
                    p.chainLightningDamage = 1.0;
                    p.stormstrikerLevel = 0;
                    p.chainLightningEnhanced = false;
                    p.hasDoubleStorm = false;
                    p.chainLightningRange = undefined;
                }

                p.chainLightningCooldown = 0;
                p.lightningAlternate = false;
                p.lightningCycleIndex = 0;
            }

            function grantPlayerChainLightning(p, { unlock = false, initialLevel = 1 } = {}) {
                if (!p) return false;

                const wasUnlocked = !!p.hasStormbringer;
                const hadLightning = !!p.hasChainLightning;

                if (unlock) {
                    p.hasStormbringer = true;
                }

                p.hasChainLightning = true;
                if (p.chainLightningCooldown == null) {
                    p.chainLightningCooldown = 0;
                } else if (p.chainLightningCooldown < 0) {
                    p.chainLightningCooldown = 0;
                }

                if (!Number.isFinite(p.chainLightningDamage) || p.chainLightningDamage <= 0) {
                    p.chainLightningDamage = 1.0;
                }

                if (p.stormstrikerLevel == null || p.stormstrikerLevel < initialLevel) {
                    p.stormstrikerLevel = initialLevel;
                }

                p.lightningAlternate = false;
                p.lightningCycleIndex = 0;

                return (unlock && !wasUnlocked) || (!hadLightning);
            }

            function ensurePlayerStormbringerLoadout(p) {
                if (!p) return false;
                const wasUnlocked = !!p.hasStormbringer;
                grantPlayerChainLightning(p, { unlock: true, initialLevel: 1 });
                return !wasUnlocked;
            }

            function applySkillBonus(skill) {
                const p = store.player;

                switch (skill) {



                    // Tier 2 Enhanced Skills
                    case 'marauder_enhanced':
                        p.beefMaxCharges = 3;
                        p.beefCharges = Math.max(p.beefCharges, 3);
                        p.beefChainMode = true; // Enable chain jumping for enhanced marauder
                        announce('TRIPLE CHAIN ACTIVATED!');
                        break;
                    case 'juggernaut_enhanced':
                        p.beefBigExplosion = true;
                        announce('BIG BANG EXPLOSION ACTIVATED!');
                        break;



                    // Rocketman Tier 2 Enhanced Skills
                    case 'railgunner_enhanced':
                        // Enhanced railgunner should preserve existing abilities
                        if (!p.missilePierce) p.missilePierce = 2; // Give basic piercing if they don't have it
                        p.missilePierce = Math.max(p.missilePierce, 4);
                        announce('SUPER PIERCE ACTIVATED - Maximum Penetration!');
                        break;
                    case 'demolitioner_enhanced':
                        // Enhanced demolitioner should preserve existing abilities
                        if (!p.missileCluster) p.missileCluster = true; // Give basic clusters if they don't have them
                        p.missileClusterEnhanced = true;
                        announce('MEGA CLUSTERS ACTIVATED - Devastating Explosions!');
                        break;

                    // Voidmancer skills  



                    case 'railgunner_barrier':
                        p.subclass = 'railgunner';
                        // Give flame barrier ability
                        p.flameBarrierActive = false;
                        p.flameBarrierCooldown = 0;
                        p.flameBarrierDuration = 8; // 8 seconds
                        p.flameBarrierRecharge = 15; // 15 second cooldown
                        announce('RAILGUNNER ACTIVATED - Flame Barrier Defense!');
                        break;
                    case 'demolitioner_barrier':
                        p.subclass = 'demolitioner';
                        // Give enhanced flame barrier ability
                        p.flameBarrierActive = false;
                        p.flameBarrierCooldown = 0;
                        p.flameBarrierDuration = 12; // Longer duration than railgunner
                        p.flameBarrierRecharge = 10; // Faster cooldown than railgunner
                        p.flameBarrierExplosive = true; // Explosive reactive damage
                        announce('DEMOLITIONER ACTIVATED - Explosive Flame Wall!');
                        break;

                    // Voidmancer Tier 2 Enhanced Skills
                    case 'phasestriker_enhanced':
                        p.phasestRikerLevel = 2; // Level 2: Global range + ramping damage/size
                        announce('PHASESTRIKER LV2 - Ramping Laser Power!');
                        break;
                    case 'stormbringer_enhanced':
                        p.chainLightningEnhanced = true;
                        p.stormstrikerLevel = 2; // Level 2: Twin wing lightning
                        announce('STORMSTRIKER LV2 - Twin Wing Lightning!');
                        break;

                    // New Beef Skills
                    case 'beef_shield':
                        // Base shield scales with level: 100 + (10 per level)
                        p.beefShieldMax = 100 + (p.level * 10);
                        p.beefShield = p.beefShieldMax;
                        p.beefShieldRegenRate = 5; // Shield per second
                        announce('BEEF SHIELD ACTIVATED - Defensive Armor Plating!');
                        break;
                    case 'beef_shield_enhanced':
                        // Enhanced shield scales with level: 200 + (15 per level)
                        const baseShield = p.beefShieldMax || (100 + (p.level * 10));
                        p.beefShieldMax = Math.max(baseShield, 200 + (p.level * 15));
                        p.beefShield = p.beefShieldMax;
                        p.beefShieldRegenRate = 15; // Faster regeneration
                        p.beefShieldReflect = true; // Reflect damage back to enemies
                        announce('FORTRESS MODE ACTIVATED - Enhanced Defense and Reflection!');
                        break;
                    case 'beef_charge':
                        p.beefChargeState = 'ready';
                        p.beefChargeCooldown = 0;
                        p.beefChargeSpeed = Math.max(p.beefChargeSpeed || 0, 1.35);
                        // Don't reset charges if already have more than 1 (preserve subclass bonuses)
                        if (!p.beefMaxCharges || p.beefMaxCharges < 1) {
                            p.beefCharges = 1;
                            p.beefMaxCharges = 1;
                        }
                        announce('BEEF CHARGE ACTIVATED - Devastating Rush Attack!');
                        break;
                    case 'beef_charge_enhanced':
                        p.beefChargeDamageMultiplier = 1.5; // 50% more charge damage (reduced from 2x)
                        p.beefChargeRange = 1.5; // Increased range
                        announce('RAMMING SPEED ACTIVATED - Enhanced Charge Power!');
                        break;

                    // New Rocketman Skills
                    case 'flame_barrier':
                        p.flameBarrierActive = false;
                        p.flameBarrierCooldown = 0;
                        p.flameBarrierDuration = 8; // 8 seconds
                        p.flameBarrierRecharge = 15; // 15 second cooldown
                        announce('FLAME BARRIER ACTIVATED - Burning Protective Field!');
                        break;
                    case 'flame_barrier_enhanced':
                        p.flameBarrierDuration = 12; // Longer duration
                        p.flameBarrierRecharge = 10; // Faster cooldown
                        p.flameBarrierExplosive = true; // Explosive reactive damage
                        announce('INFERNO WALL ACTIVATED - Explosive Reactive Defense!');
                        break;
                    case 'missile_volley':
                        p.missileVolley = Math.max(p.missileVolley || 2, 4);
                        announce('MISSILE VOLLEY ACTIVATED - Multi-Missile Salvos!');
                        break;
                    case 'missile_volley_enhanced':
                        p.missileVolley = Math.max(p.missileVolley || 4, 6);
                        p.missileReloadBonus = 0.5; // 50% faster reload
                        announce('BARRAGE MODE ACTIVATED - Maximum Firepower!');
                        break;

                    // New Voidmancer Skills  
                    case 'blink_ability':
                        p.blinkDamage = true;
                        p.blinkCooldown = 0;
                        p.blinkRecharge = 3; // 3 second cooldown
                        p.hasBlink = true;
                        p.autoBlinkEnabled = true;
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 160);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.4);
                        p.autoBlinkLastTrigger = 0;
                        announce('BLINK ABILITY ACTIVATED - Damaging Teleportation!');
                        break;
                    case 'blink_ability_enhanced':
                        p.blinkDamageEnhanced = true;
                        p.blinkRecharge = 2; // Faster cooldown
                        p.blinkAreaDamage = true; // Area damage on teleport
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 200);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.5);
                        announce('VOID STEP ACTIVATED - Enhanced Teleportation Power!');
                        break;
                    case 'void_laser': {
                        const unlocked = ensurePhasestrikerLoadout(p);
                        p.voidLaserTarget = null;
                        p.voidLaserDamageTimer = 0;
                        p.voidLaserRetargetTimer = 0;
                        announce(unlocked ? 'VOID LASER CROSS-TRAINED - Focused Beam Online!' : 'VOID LASER ACTIVATED - Focused Beam Weapon!');
                        break;
                    }
                    case 'void_laser_enhanced':
                        ensurePhasestrikerLoadout(p);
                        p.voidLaserEnhanced = true;
                        p.voidLaserRampingDamage = 1.0; // Starts at 1x, builds up
                        p.voidLaserBeamWidth = 2.0; // Wider beam
                        announce('ANNIHILATION BEAM ACTIVATED - Ramping Laser Power!');
                        break;

                    // NEW 5-NODE SKILL TREE SKILLS
                    // Marauder Tree Skills
                    case 'marauder_multi_charge':
                        p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3);
                        p.beefCharges = Math.max(p.beefCharges, 3);
                        announce('MULTI CHARGE ACTIVATED - Additional Charge Attacks!');
                        break;
                    case 'marauder_chain_assault':
                        p.beefChainMode = true;
                        p.beefChainBonus = 1.5; // 50% bonus damage on chain
                        announce('CHAIN ASSAULT ACTIVATED - Chain Between Enemies!');
                        break;
                    case 'marauder_armor_boost':
                        p.hpMax += 25;
                        p.hp += 25;
                        p.damageReduction = (p.damageReduction || 0) + 0.15;
                        announce('BATTLE ARMOR ACTIVATED - Enhanced Durability!');
                        break;
                    case 'marauder_shield_mastery':
                        if (p.beefShieldMax) {
                            p.beefShieldRegenRate = (p.beefShieldRegenRate || 5) * 2;
                            p.beefShieldRegenDelay = Math.max((p.beefShieldRegenDelay || 3) - 1, 1);
                        }
                        announce('SHIELD MASTERY ACTIVATED - Enhanced Shield Regeneration!');
                        break;

                    // Juggernaut Tree Skills
                    case 'juggernaut_charge_power':
                        p.beefChargeDamage = (p.beefChargeDamage || 1.0) * 1.5; // 50% more damage (reduced from 100%)
                        p.beefChargeKnockback = (p.beefChargeKnockback || 1.0) * 2.0; // 100% more knockback
                        p.beefChargeRange = (p.beefChargeRange || 1.0) * 1.5; // 50% more range
                        announce('CHARGE POWER ACTIVATED - Enhanced Charge Strength!');
                        break;
                    case 'juggernaut_charge_mastery':
                        p.beefChargeShockwave = true; // Charge creates damaging shockwave
                        p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3); // +2 charges
                        p.beefCharges = Math.max(p.beefCharges || 0, 3);
                        announce('CHARGE MASTERY ACTIVATED - Shockwave & Extra Charges!');
                        break;
                    case 'juggernaut_speed_boost':
                        p.speedMult *= 1.4;
                        p.beefChargeSpeed = (p.beefChargeSpeed || 1.0) * 1.6;
                        announce('HEAVY MOMENTUM ACTIVATED - Enhanced Speed and Charge!');
                        break;
                    case 'juggernaut_dash_mastery':
                        p.beefKnockbackResistance = true;
                        p.beefChargeCooldown = Math.max((p.beefChargeCooldown || 3) - 1, 1);
                        announce('UNSTOPPABLE FORCE ACTIVATED - Enhanced Mobility!');
                        break;

                    // Railgunner Tree Skills
                    case 'railgunner_super_pierce':
                        p.missilePierce = Math.max(p.missilePierce || 1, 5); // Enhance to 5 enemies (from basic)
                        p.missilePierceDamage = (p.missilePierceDamage || 1.0) * 1.3;
                        announce('SUPER PIERCE ACTIVATED - Enhanced Missile Pierce!');
                        break;
                    case 'railgunner_perfect_aim':
                        p.missileCritChance = (p.missileCritChance || 0) + 0.25;
                        p.missileAccuracy = (p.missileAccuracy || 1.0) * 1.5;
                        announce('PERFECT AIM ACTIVATED - Enhanced Targeting!');
                        break;
                    case 'railgunner_flame_mastery':
                        p.flameBarrierDamage = (p.flameBarrierDamage || 1.0) * 1.8;
                        p.flameBarrierRadius = (p.flameBarrierRadius || 1.0) * 1.4;
                        announce('FLAME MASTERY ACTIVATED - Enhanced Fire Power!');
                        break;
                    case 'railgunner_wall_control':
                        p.flameBarrierCount = (p.flameBarrierCount || 1) + 1;
                        p.flameBarrierDuration *= 1.5;
                        announce('WALL CONTROL ACTIVATED - Advanced Flame Tactics!');
                        break;

                    // Demolitioner Tree Skills
                    case 'demolitioner_bigger_clusters':
                        // Make cluster bombs 2x larger with increased blast radius
                        p.missileClusterSize = (p.missileClusterSize || 1.0) * 2.0;
                        p.missileClusterRadius = (p.missileClusterRadius || 1.0) * 2.0;
                        announce('BIGGER CLUSTERS ACTIVATED - Massive Cluster Bombs!');
                        break;
                    case 'demolitioner_cluster_mastery':
                        // Clusters split into secondary explosions, +50% cluster count
                        p.missileClusterSecondary = true;
                        p.missileClusterCount = Math.max(p.missileClusterCount || 4, Math.floor((p.missileClusterCount || 4) * 1.5));
                        announce('CLUSTER MASTERY ACTIVATED - Secondary Explosions!');
                        break;
                    case 'demolitioner_fire_boost':
                        p.fireDamageBonus = (p.fireDamageBonus || 1.0) * 2.0;
                        p.burnDuration = (p.burnDuration || 3) * 1.5;
                        announce('INFERNO BOOST ACTIVATED - Enhanced Fire Damage!');
                        break;
                    case 'demolitioner_flame_master':
                        p.flameBarrierExplosive = true;
                        p.flameBarrierReactiveDamage = 150;
                        announce('FLAME MASTER ACTIVATED - Explosive Barriers!');
                        break;

                    // Phasestriker Tree Skills
                    case 'phasestriker_unlimited_range': {
                        const unlocked = ensurePhasestrikerLoadout(p);
                        // Remove range limitation from void laser
                        p.voidLaserRange = 999999; // Unlimited range - can hit any enemy
                        p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 1); // Ensure level reflects upgrade
                        announce(unlocked ? 'VOID LASER CROSS-TRAINED - Unlimited Range Achieved!' : 'UNLIMITED RANGE ACTIVATED - Global Laser Targeting!');
                        break;
                    }
                    case 'phasestriker_ramping_power':
                        ensurePhasestrikerLoadout(p);
                        // Enable ramping damage/size effect
                        p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 2); // Level 2: Ramping damage/size
                        announce('RAMPING POWER ACTIVATED - Growing Laser Strength!');
                        break;
                    case 'phasestriker_blink_boost':
                        ensurePhasestrikerLoadout(p);
                        const baseBlinkRange = p.blinkRange || 200;
                        p.blinkRange = baseBlinkRange * 1.8;
                        p.blinkCooldown = Math.max((p.blinkCooldown || 5) - 2, 1);
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, p.blinkRange * 0.7);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.55);
                        announce('BLINK BOOST ACTIVATED - Enhanced Teleportation!');
                        break;
                    case 'phasestriker_phase_mastery':
                        ensurePhasestrikerLoadout(p);
                        p.blinkDamage = (p.blinkDamage || 50) * 1.5; // 50% more damage (reduced from 2x)
                        p.blinkInvulnerable = true; // Brief invulnerability during blink
                        announce('PHASE MASTERY ACTIVATED - Dimensional Superiority!');
                        break;

                    // Stormbringer Tree Skills
                    case 'stormbringer_chain_boost': {
                        const unlocked = ensurePlayerStormbringerLoadout(p);
                        // Add twin lightning bolts from wing guns
                        p.stormstrikerLevel = Math.max(p.stormstrikerLevel, 2); // Twin wing lightning
                        announce(unlocked ? 'CHAIN LIGHTNING CROSS-TRAINED - Twin Lightning Ready!' : 'TWIN LIGHTNING ACTIVATED - Dual Chain Lightning!');
                        break;
                    }
                    case 'stormbringer_storm_mastery':
                        ensurePlayerStormbringerLoadout(p);
                        p.chainLightningDamage = (p.chainLightningDamage || 1.0) * 1.8; // 80% damage boost
                        p.chainLightningRange = (p.chainLightningRange || 150) * 1.5; // 50% jump range boost
                        announce('STORM MASTERY ACTIVATED - Enhanced Range & Power!');
                        break;
                    case 'stormbringer_warp_boost':
                        ensurePlayerStormbringerLoadout(p);
                        if (!p.blinkRange) p.blinkRange = 200;
                        p.blinkRange *= 1.6;
                        p.blinkRecharge = Math.max((p.blinkRecharge || 5) - 1.5, 1);
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, p.blinkRange * 0.65);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.5);
                        announce('WARP BOOST ACTIVATED - Enhanced Teleportation!');
                        break;
                    case 'stormbringer_void_control':
                        ensurePlayerStormbringerLoadout(p);
                        p.blinkTimeRipple = true;
                        p.blinkRippleDamage = 100;
                        announce('VOID CONTROL ACTIVATED - Time Ripple Effects!');
                        break;

                    // NEW TIER 3 & 4 SKILLS FOR SINGLE PATH PROGRESSION
                    // Marauder Advanced Skills
                    case 'marauder_combat_mastery':
                        p.beefChainDamageBonus = (p.beefChainDamageBonus || 1.0) * 2.0;
                        p.beefAttackSpeed = (p.beefAttackSpeed || 1.0) * 1.3;
                        announce('COMBAT MASTERY ACTIVATED - Advanced Assault Techniques!');
                        break;
                    case 'marauder_elite_warrior':
                        p.beefMaxCharges = Math.max(p.beefMaxCharges || 3, 5);
                        p.beefCharges = Math.max(p.beefCharges, 5);
                        p.beefEliteCombat = true;
                        p.marauderDoubleHitBonus = 2.0; // Elite double-hit gives 2x damage (reduced from 3x for balance)
                        announce('ELITE WARRIOR ACTIVATED - Peak Marauder Prowess!');
                        break;
                    case 'marauder_clone':
                        p.hasBeefClone = true;
                        p.juggernautCloneActive = false;
                        store.beefClone = createMirrorClone(p, store.beefClone);
                        announce('BATTLE CLONE ACTIVATED - Green ally summoned!');
                        break;

                    // Juggernaut Advanced Skills
                    case 'juggernaut_heavy_armor':
                        p.hpMax += 50;
                        p.hp += 50;
                        p.damageReduction = (p.damageReduction || 0) + 0.25;
                        p.knockbackImmunity = true;
                        announce('HEAVY ARMOR ACTIVATED - Superior Protection!');
                        break;
                    case 'juggernaut_unstoppable':
                        p.beefExplosionRadius = (p.beefExplosionRadius || 1.0) * 2.5;
                        p.beefExplosionDamage = (p.beefExplosionDamage || 1.0) * 3.0;
                        p.beefUnstoppableForce = true;
                        announce('UNSTOPPABLE FORCE ACTIVATED - Maximum Impact Power!');
                        break;
                    case 'juggernaut_clone':
                        p.hasBeefClone = true;
                        p.juggernautCloneActive = true;
                        activateJuggernautClone(p);
                        announce('WAR CLONE ACTIVATED - Bombing run engaged!');
                        break;

                    // Railgunner Advanced Skills
                    case 'railgunner_advanced_ballistics':
                        p.missilePierce = Math.max(p.missilePierce || 5, 8);
                        p.missileVelocity = (p.missileVelocity || 1.0) * 1.8;
                        p.missileHomingStrength = (p.missileHomingStrength || 0.5) * 1.5;
                        announce('ADVANCED BALLISTICS ACTIVATED - Superior Missile Technology!');
                        break;
                    case 'railgunner_precision_master':
                        p.missileCritChance = (p.missileCritChance || 0.25) + 0.5;
                        p.missileCritDamage = (p.missileCritDamage || 2.0) * 2.0;
                        p.railgunMastery = true;
                        announce('PRECISION MASTER ACTIVATED - Ultimate Accuracy!');
                        break;

                    // Demolitioner Advanced Skills
                    case 'demolitioner_explosive_mastery':
                        p.missileClusterCount = Math.max(p.missileClusterCount || 8, 12);
                        p.explosionChain = true;
                        p.explosionChainCount = 3;
                        announce('EXPLOSIVE MASTERY ACTIVATED - Chain Detonations!');
                        break;
                    case 'demolitioner_demolition_expert':
                        p.missileClusterRadius *= 2.0;
                        p.megaExplosionChance = 0.3; // 30% chance for mega explosions
                        p.demolitionExpert = true;
                        announce('DEMOLITION EXPERT ACTIVATED - Maximum Destructive Force!');
                        break;
                    case 'railgunner_stealth_rockets':
                        p.stealthRockets = true;
                        p.stealthRocketDamage = 1.25; // 25% damage boost
                        p.stealthRocketSpeed = 1.5; // 50% speed boost
                        announce('STEALTH ROCKETS ACTIVATED - Advanced Stealth Technology!');
                        break;
                    case 'demolitioner_stealth_rockets':
                        p.stealthRockets = true;
                        p.stealthRocketDamage = 1.25; // 25% damage boost
                        p.stealthRocketSpeed = 1.5; // 50% speed boost
                        announce('STEALTH ROCKETS ACTIVATED - Advanced Stealth Technology!');
                        break;
                    case 'phasestriker_wiper_lasers':
                        p.wiperLasers = true;
                        p.wiperLaserCount = 2; // Additional wiper lasers
                        playSound('epicHorn'); // Epic activation sound
                        announce('WIPER LASERS ACTIVATED - Sweeping Laser Array!');
                        break;
                    case 'stormbringer_wiper_lasers':
                        p.wiperLasers = true;
                        p.wiperLaserCount = 2; // Additional wiper lasers
                        playSound('epicHorn'); // Epic activation sound
                        announce('WIPER LASERS ACTIVATED - Sweeping Laser Array!');
                        break;

                    // Phasestriker Advanced Skills
                    case 'phasestriker_dimensional_control':
                        p.voidLaserPhase = true;
                        p.voidLaserPhaseDamage = 2.5;
                        p.dimensionalControl = true;
                        announce('DIMENSIONAL CONTROL ACTIVATED - Reality Manipulation!');
                        break;
                    case 'phasestriker_double_beam':
                        // Double Long Range Intensifying Beam - fires two parallel beams with intensifying damage
                        p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 4); // Level 4: Double beam
                        p.doubleBeam = true;
                        p.beamIntensifyRate = 0.1; // 10% damage increase per second of sustained fire
                        p.voidLaserMaxRamp *= 2.0; // Double the ramp potential
                        announce('DOUBLE LONG RANGE INTENSIFYING BEAM!');
                        break;

                    // Stormbringer Advanced Skills  
                    case 'stormbringer_thunder_lord':
                        p.stormstrikerLevel = 3; // 4-bolt lightning storm
                        p.lightningStorm = true;
                        p.thunderLordPower = true;
                        announce('THUNDER LORD ACTIVATED - 4 Simultaneous Bolts!');
                        break;
                    case 'stormbringer_storm_god':
                        p.chainLightningDamage *= 3.0;
                        p.stormGodPower = true;
                        p.omnipotentLightning = true;
                        announce('STORM GOD ACTIVATED - Divine Electrical Mastery!');
                        break;

                    // OMEGA MULTISHOT NODES (Tier 5 - requires all previous nodes)
                    case 'marauder_omega_burst':
                        p.hasOmegaMultishot = true;
                        p.omegaMultishotType = 'marauder_burst';
                        announce('â­ OMEGA BURST - Explosive Energy Orbs!');
                        break;
                    case 'juggernaut_omega_hammer':
                        p.hasOmegaMultishot = true;
                        p.omegaMultishotType = 'juggernaut_hammer';
                        announce('â­ OMEGA HAMMER - Shattering Projectiles!');
                        break;
                    case 'railgunner_omega_lance':
                        p.hasOmegaMultishot = true;
                        p.omegaMultishotType = 'railgunner_lance';
                        announce('â­ OMEGA LANCE - Piercing Energy!');
                        break;
                    case 'demolitioner_omega_nova':
                        p.hasOmegaMultishot = true;
                        p.omegaMultishotType = 'demolitioner_nova';
                        announce('â­ OMEGA NOVA - Unstable Chain Explosions!');
                        break;
                    case 'phasestriker_omega_void':
                        p.hasOmegaMultishot = true;
                        p.omegaMultishotType = 'phasestriker_void';
                        announce('â­ OMEGA VOID - Collapsing Singularities!');
                        break;
                    case 'stormbringer_omega_storm':
                        p.hasOmegaMultishot = true;
                        p.omegaMultishotType = 'stormbringer_storm';
                        announce('â­ OMEGA STORM - Plasma Lightning!');
                        break;

                    // CLASS ABILITY UNLOCKS (5th node rewards)
                    case 'beef_shield_unlock':
                        // Unlock shield with level scaling: 150 + (12 per level)
                        p.beefShieldMax = 150 + (p.level * 12);
                        p.beefShield = p.beefShieldMax;
                        p.beefShieldRegenRate = 8;
                        p.beefShieldRegenDelay = 3;
                        p.beefShieldDamageDealt = 0; // Track damage dealt for shield charging
                        p.beefShieldDamageTaken = 0; // Track damage taken for shield depletion
                        p.beefShieldCooldown = 0; // Cooldown after depletion before shield can absorb again
                        p.hasBeefShield = true;
                        playSound('powerup');
                        announce('ðŸ›¡ï¸ BEEF SHIELD UNLOCKED! - Class Ability Activated!');
                        break;
                    case 'blink_unlock':
                        p.hasBlink = true;
                        p.blinkRange = 250;
                        p.blinkCooldown = 4;
                        p.blinkDamage = 75;
                        p.autoBlinkEnabled = true;
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 190);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.45);
                        p.autoBlinkLastTrigger = 0;
                        p.isBlinkSlashing = false;
                        playSound('powerup');
                        announce('âœ¨ BLINK UNLOCKED! - Class Ability Activated!');
                        break;
                    case 'firewall_unlock':
                        p.hasFirewall = true;
                        p.firewallCooldown = 8; // Base cooldown for flame pulse
                        p.flamePulseCooldownMax = 8;
                        p.flamePulseCooldown = 0;
                        p.shipFlameColor = '#ff7b32';
                        p.shipHighlightColor = '#ffd166';
                        p.flamePulseCharge = 1; // Start ready
                        p.flamePulseInitialized = false;
                        playSound('powerup');
                        announce('ðŸ”¥ FLAME PULSE UNLOCKED! - Expanding fire ring ability!');
                        break;
                }
            }

            function applySubclassBonus(subclass) {
                const p = store.player;

                switch (subclass) {
                    case 'railgunner':
                        p.subclass = 'railgunner';
                        p.missilePierce = 2;
                        announce('RAILGUNNER ACTIVATED - Piercing Missiles!');
                        break;
                    case 'demolitioner':
                        p.subclass = 'demolitioner';
                        p.missileCluster = true;
                        announce('DEMOLITIONER ACTIVATED - Cluster Bombs!');
                        break;
                    case 'juggernaut':
                        p.subclass = 'juggernaut';
                        // Give 2 charges (beef shield must be purchased separately via skill tree)
                        p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                        p.beefCharges = Math.max(p.beefCharges, 2);
                        announce('JUGGERNAUT ACTIVATED - Enhanced Charges!');
                        break;
                    case 'marauder':
                        p.subclass = 'marauder';
                        // Give 2 charges and enable chain jumping (beef shield must be purchased separately via skill tree)
                        p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                        p.beefCharges = Math.max(p.beefCharges, 2);
                        p.beefChainMode = true; // Enable chain jumping for marauder
                        p.marauderHitTargets = new Set(); // Initialize double-hit tracking
                        announce('MARAUDER ACTIVATED - Chain Jumping!');
                        break;
                    case 'phasestriker':
                        p.subclass = 'phasestriker';
                        // Give basic SHORT RANGE void laser as first upgrade
                        p.hasVoidLaser = true;
                        p.voidLaserTarget = null;
                        p.voidLaserDamageTimer = 0;
                        p.voidLaserRetargetTimer = 0;
                        p.voidLaserRange = 250; // 25% longer base range
                        p.phasestRikerLevel = 0.5; // Base phasestriker level (between 0 and 1)
                        break;
                    case 'stormbringer':
                        p.subclass = 'stormbringer';
                        // Give basic chain lightning ability
                        grantPlayerChainLightning(p, { initialLevel: 1 });
                        break;
                    case 'voidmancer':
                        p.subclass = 'voidmancer';
                        // Base voidmancer bonus applied during genome selection
                        break;
                }
                store.world.enemyHealthBonus *= 1.10;
            }

            function showSpecSelect(isAdditive = false) {
                pauseGame();
                const panel = q('subclassPanel'); // Reuse the subclass panel
                const grid = q('subclassGrid');
                const p = store.player;
                const genome = p.pilotGenome;

                let choices = [];

                if (genome === 'rocketman') {
                    if (p.subclass === 'demolitioner') {
                        if (isAdditive && p.enhancedClusters) {
                            // If they already have enhanced clusters, double current power
                            choices = [{ id: 'double_clusters', name: 'MEGA CLUSTERS', desc: 'Cluster explosions are twice as large and deal massive damage.', icon: 'demo.png' }];
                        } else if (isAdditive && p.missilePierce > 0) {
                            // If they have railgunner abilities, give them enhanced clusters
                            choices = [{ id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' }];
                        } else {
                            // First spec or missing railgunner - offer both
                            const opts = [
                                { id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' },
                                { id: 'railgunner_pierce', name: 'PIERCING MISSILES', desc: 'Missiles pierce through 3 enemies with devastating force.', icon: 'rail.png' },
                                { id: 'compact_clusters_pierce', name: 'COMPACT PIERCING', desc: 'Smaller clusters but missiles pierce through 2 enemies.', icon: 'rail.png' }
                            ];
                            choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_clusters');
                        }
                    } else if (p.subclass === 'railgunner') {
                        if (isAdditive && p.enhancedPierce) {
                            choices = [{ id: 'mega_pierce', name: 'ULTRA PIERCE', desc: 'Missiles pierce through 6 enemies with increased damage.', icon: 'rail.png' }];
                        } else if (isAdditive && p.enhancedClusters) {
                            choices = [{ id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' }];
                        } else {
                            const opts = [
                                { id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' },
                                { id: 'cluster_missiles', name: 'CLUSTER MISSILES', desc: 'Missiles explode into smaller cluster bombs.', icon: 'demo.png' }
                            ];
                            choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_pierce');
                        }
                    }
                } else if (genome === 'voidmancer') {
                    // Voidmancer only gets the power they don't have
                    if (!p.hasStormbringer && !p.hasPhasestriker) {
                        // First spec - let them choose
                        choices = [
                            { id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' },
                            { id: 'stormbringer', name: 'STORMBRINGER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                        ];
                    } else if (!p.hasStormbringer) {
                        choices = [{ id: 'stormbringer', name: 'STORMBRINGER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }];
                    } else if (!p.hasPhasestriker) {
                        choices = [{ id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' }];
                    } else {
                        // They have both - offer three enhanced void caller options
                        choices = [
                            { id: 'double_storm', name: 'TWIN LIGHTNING', desc: 'Fires two chain lightning bolts instead of one.', icon: 'storm.png' },
                            { id: 'hybrid_void', name: 'VOID STORM', desc: 'Voidstep damages enemies + unlocks single lightning bolt.', icon: 'phase.png' },
                            { id: 'impact_phase', name: 'EARTHQUAKE', desc: 'Voidstep creates a massive impact shockwave at destination.', icon: 'void.png' }
                        ];
                    }
                } else if (genome === 'beef') {
                    // Handle beef subclasses similarly
                    if (p.subclass === 'juggernaut') {
                        choices = [{ id: 'enhanced_juggernaut', name: 'MEGA JUGGERNAUT', desc: 'Massive charge radius and knockback increase.', icon: 'jug2.png' }];
                    } else if (p.subclass === 'marauder') {
                        choices = [{ id: 'enhanced_marauder', name: 'SHIELD MASTER', desc: 'Charge restores even more shields and grants temporary invulnerability.', icon: 'marauder.png' }];
                    }
                }

                if (!choices.length) {
                    resumeGame();
                    return;
                }

                const title = isAdditive ? 'ENHANCED SPECIALIZATION' : 'CHOOSE SPECIALIZATION';
                document.querySelector('#subclassPanel h2').textContent = title;

                grid.innerHTML = choices.map(s => `<div class="skill-card" data-spec="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');

                grid.querySelectorAll('.skill-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const specId = card.dataset.spec;
                        applySpecBonus(specId);
                        panel.classList.add('hide');
                        resumeGame();
                        document.querySelector('#subclassPanel h2').textContent = 'CHOOSE SPECIALIZATION'; // Reset title
                    }, { once: true });
                });

                panel.classList.remove('hide');
            }

            // DISABLED: applySpecBonus function for stability  
            function applySpecBonus(specId) {
                const p = store.player;

                switch (specId) {
                    case 'enhanced_clusters':
                        p.enhancedClusters = true;
                        announce('ENHANCED CLUSTERS ACTIVATED!');
                        break;
                    case 'double_clusters':
                        // Implement double cluster damage
                        announce('MEGA CLUSTERS ACTIVATED!');
                        break;
                    case 'railgunner_pierce':
                        p.missilePierce = 3;
                        announce('PIERCING MISSILES ACTIVATED!');
                        break;
                    case 'compact_clusters_pierce':
                        p.missilePierce = 2;
                        // Keep clusters small but add pierce
                        announce('COMPACT PIERCING ACTIVATED!');
                        break;
                    case 'enhanced_pierce':
                        p.enhancedPierce = true;
                        p.missilePierce = Math.max(p.missilePierce, 4); // Ensure at least 4 pierce
                        announce('ENHANCED PIERCE ACTIVATED!');
                        break;
                    case 'mega_pierce':
                        p.missilePierce = 6;
                        announce('ULTRA PIERCE ACTIVATED!');
                        break;
                    case 'cluster_missiles':
                        p.missileCluster = true;
                        announce('CLUSTER MISSILES ACTIVATED!');
                        break;
                    case 'phasestriker':
                        p.hasPhasestriker = true;
                        announce('PHASESTRIKER ACTIVATED!');
                        break;
                    case 'stormbringer':
                        grantPlayerChainLightning(p, { unlock: true, initialLevel: 1 });
                        announce('CHAIN LIGHTNING ACTIVATED!');
                        playSound('thunder');
                        break;
                    case 'double_storm':
                        p.hasDoubleStorm = true;
                        announce('TWIN CHAIN LIGHTNING ACTIVATED!');
                        break;
                    case 'hybrid_void':
                        p.hasHybridVoid = true;
                        p.blinkDamage = true;  // Enable voidstep damage
                        announce('VOID STORM ACTIVATED!');
                        break;
                    case 'impact_phase':
                        p.hasImpactPhase = true;
                        p.blinkDamage = true;  // Ensure voidstep does damage
                        announce('EARTHQUAKE ACTIVATED!');
                        break;
                    case 'enhanced_storm':
                        announce('MEGA STORM ACTIVATED!');
                        break;
                    case 'enhanced_phase':
                        announce('VOID MASTERY ACTIVATED!');
                        break;
                    case 'enhanced_juggernaut':
                        announce('MEGA JUGGERNAUT ACTIVATED!');
                        break;
                    case 'enhanced_marauder':
                        announce('SHIELD MASTER ACTIVATED!');
                        break;
                }
            }


            function ensureName() {
                if (!store.name) {
                    pauseGame();
                    const panel = q("namePanel");

                    panel.classList.remove("hide");
                    q("nameInput").value = "";
                    setTimeout(() => q("nameInput").focus(), 50)
                } else {
                    resumeGame();
                    if (store.player.pilotGenome === null) {
                        initWave();
                    }
                }
            }

            q("restartBtn").addEventListener("click", resetGame);

            q("saveName").addEventListener("click", () => { const t = (q("nameInput").value || "").slice(0, 16).trim(); if (t) { store.name = t; q("namePanel").classList.add("hide"); if (store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); } } });

            const closeShopLogic = () => {
                const panel = q("shopPanel");
                panel.classList.add('hide');
                exitPanel('shopPanel');
                const highlighted = document.querySelector('.shop-item.highlight');
                if (highlighted) highlighted.classList.remove('highlight');
                const mechForgeBtn = q('shopBtn');
                if (mechForgeBtn) {
                    mechForgeBtn.classList.remove('mech-forge-pulse');
                    if (mechForgeBtn._forgePulseTimeout) {
                        clearTimeout(mechForgeBtn._forgePulseTimeout);
                        mechForgeBtn._forgePulseTimeout = null;
                    }
                }
                if (store.world.mechForgePulseTimeout) {
                    clearTimeout(store.world.mechForgePulseTimeout);
                    store.world.mechForgePulseTimeout = null;
                }
                resumeGame();
            };
            q("closeShopTopBtn").addEventListener("click", closeShopLogic);
            q("closeShop").addEventListener("click", closeShopLogic);

            const shopTutorialOpenBtn = q('shopTutorialOpen');
            if (shopTutorialOpenBtn) {
                shopTutorialOpenBtn.addEventListener('click', () => {
                    const disable = q('shopTutorialDontShow');
                    closeShopTutorial({ dismiss: !!(disable && disable.checked), openShop: true });
                });
            }
            const shopTutorialSkipBtn = q('shopTutorialSkip');
            if (shopTutorialSkipBtn) {
                shopTutorialSkipBtn.addEventListener('click', () => {
                    const disable = q('shopTutorialDontShow');
                    closeShopTutorial({ dismiss: !!(disable && disable.checked), openShop: false });
                });
            }

            q("shopBtn").addEventListener("click", () => {
                const shopPanel = q('shopPanel');
                if (shopPanel.classList.contains('hide')) {
                    showShop('upgrades');
                } else {
                    closeShopLogic();
                }
            });

            const closeScoresLogic = () => { q('scorePanel').classList.add('hide'); resumeGame(); };
            // q("closeScores").addEventListener("click", closeScoresLogic); // Button hidden via CSS

            // Upgrade Hangar menu event listeners
            q("closeMechForgeMenu").addEventListener("click", () => {
                const panel = q("mechForgeMenuPanel");
                panel.classList.add("hide");
                exitPanel('mechForgeMenuPanel');
                resumeGame();
            });
            q("closeMechForgeMenuBtn").addEventListener("click", () => {
                const panel = q("mechForgeMenuPanel");
                panel.classList.add("hide");
                exitPanel('mechForgeMenuPanel');
                resumeGame();
            });
            const openPrimordialLabBtn = q("openPrimordialLabFromMenu");
            if (openPrimordialLabBtn) {
                openPrimordialLabBtn.addEventListener("click", () => {
                    q("mechForgeMenuPanel").classList.add("hide");

                    setTimeout(() => {
                        const subclassPanel = q("subclassPanel");
                        const pilotPanel = q("pilotPanel");
                        const scorePanel = q("scorePanel");

                        if (subclassPanel && !subclassPanel.classList.contains("hide")) {
                            subclassPanel.classList.add("hide");
                            exitPanel('subclassPanel');
                        }
                        if (pilotPanel && !pilotPanel.classList.contains("hide")) {
                            pilotPanel.classList.add("hide");
                        }
                        if (scorePanel && !scorePanel.classList.contains("hide")) {
                            scorePanel.classList.add("hide");
                        }

                        showPrimordialSoldierLaboratory();
                    }, 50);
                });
            }
            q("openCharacterSheet").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); showCharacterSheet(); });
            q("openSkillTreeReadonly").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); showSkillTreeReadonly(); });
            q("openShopTutorial").addEventListener("click", () => {
                q("mechForgeMenuPanel").classList.add("hide");
                showShopTutorial(true, 'Upgrade Hangar alerts refreshed.');
            });

            // Character Sheet event listeners
            q("closeCharacterSheet").addEventListener("click", () => {
                const panel = q("characterSheetPanel");
                panel.classList.add("hide");
                exitPanel('characterSheetPanel');
                resumeGame();
            });
            q("closeCharacterSheetBtn").addEventListener("click", () => {
                const panel = q("characterSheetPanel");
                panel.classList.add("hide");
                exitPanel('characterSheetPanel');
                resumeGame();
            });

            // Primordial Soldier Laboratory event listeners
            q("openChampionDressingRoom").addEventListener("click", () => {
                q("shopPanel").classList.add("hide");
                showPrimordialSoldierLaboratory();
            });
            q("closeDressingRoom").addEventListener("click", () => {
                const panel = q("championDressingRoom");
                panel.classList.add("hide");
                exitPanel('championDressingRoom');
                resumeGame();
            });
            q("closeDressingRoomBtn").addEventListener("click", () => {
                const panel = q("championDressingRoom");
                panel.classList.add("hide");
                exitPanel('championDressingRoom');
                resumeGame();
            });
            q("openShopFromDressingRoom").addEventListener("click", () => {
                q("championDressingRoom").classList.add("hide");
                showShop();
            });

            // Track current preview animation type
            let currentPreviewAnimationType = 'idle';
            const attackModuleSelect = q('attackModuleSelect');
            if (attackModuleSelect) {
                attackModuleSelect.addEventListener('change', () => {
                    const state = getChampionUpgradeState();
                    state.attackModule = attackModuleSelect.value;
                    notifyChampionLoadoutChanged();
                    updateChampionPreview('idle');
                    updateChampionStats();
                    updateChampionBuilderDetails();
                });
            }

            const cadenceSelect = q('cadenceSelect');
            if (cadenceSelect) {
                cadenceSelect.addEventListener('change', () => {
                    const state = getChampionUpgradeState();
                    state.cadenceLevel = parseInt(cadenceSelect.value);
                    notifyChampionLoadoutChanged();
                    updateChampionPreview('attack');
                    updateChampionStats();
                    updateChampionBuilderDetails();
                });
            }

            const protocolSelect = q('protocolSelect');
            if (protocolSelect) {
                protocolSelect.addEventListener('change', () => {
                    const state = getChampionUpgradeState();
                    state.minionProtocols = parseInt(protocolSelect.value);
                    notifyChampionLoadoutChanged();
                    updateChampionPreview('special');
                    updateChampionStats();
                    updateChampionBuilderDetails();
                });
            }

            const skinSelect = q('skinSelect');
            if (skinSelect) {
                skinSelect.addEventListener('change', () => {
                    const state = getChampionUpgradeState();
                    state.skin = skinSelect.value;
                    notifyChampionLoadoutChanged();
                    updateChampionPreview();
                    updateChampionStats();
                    updateChampionBuilderDetails();
                });
            }

            const applyConfigurationBtn = q('applyConfigurationBtn');
            if (applyConfigurationBtn) {
                applyConfigurationBtn.addEventListener('click', () => {
                    // Configuration is already applied via change events, just refresh
                    updateChampionPreview();
                    updateChampionStats();
                    updateChampionBuilderDetails();
                    announce('Champion configuration applied!');
                });
            }

            const resetConfigurationBtn = q('resetConfigurationBtn');
            if (resetConfigurationBtn) {
                resetConfigurationBtn.addEventListener('click', () => {
                    populateChampionBuilder();
                    updateChampionPreview();
                    updateChampionStats();
                    updateChampionBuilderDetails();
                    announce('Configuration reset to current settings.');
                });
            }

            const generateChampionPresetBtn = q('generateChampionPresetBtn');
            if (generateChampionPresetBtn) {
                generateChampionPresetBtn.addEventListener('click', () => {
                    const preset = captureChampionPreset();
                    if (!preset) {
                        setChampionPresetStatus('Champion data unavailable.', 'error');
                        return;
                    }
                    const code = encodeChampionPresetCode(preset);
                    if (!code) {
                        setChampionPresetStatus('Failed to generate champion code.', 'error');
                        return;
                    }
                    store.lastChampionPresetCode = code;
                    const output = q('championPresetCodeOutput');
                    if (output) {
                        output.value = code;
                        try {
                            output.focus();
                            output.select();
                        } catch (err) { }
                    }
                    const canClipboard = typeof navigator !== 'undefined' && navigator.clipboard && typeof navigator.clipboard.writeText === 'function';
                    if (canClipboard) {
                        navigator.clipboard.writeText(code).then(() => {
                            setChampionPresetStatus('Champion code generated and copied to clipboard.', 'success');
                        }).catch(() => {
                            setChampionPresetStatus('Champion code generated. Copy it manually if needed.', 'success');
                        });
                    } else {
                        setChampionPresetStatus('Champion code generated. Copy it manually if needed.', 'success');
                    }
                });
            }

            const copyChampionPresetBtn = q('copyChampionPresetBtn');
            if (copyChampionPresetBtn) {
                copyChampionPresetBtn.addEventListener('click', () => {
                    const output = q('championPresetCodeOutput');
                    const code = (output && output.value ? output.value.trim() : '') || store.lastChampionPresetCode || '';
                    if (!code) {
                        setChampionPresetStatus('Generate a champion code first.', 'error');
                        return;
                    }
                    const canClipboard = typeof navigator !== 'undefined' && navigator.clipboard && typeof navigator.clipboard.writeText === 'function';
                    if (canClipboard) {
                        navigator.clipboard.writeText(code).then(() => {
                            setChampionPresetStatus('Champion code copied to clipboard.', 'success');
                        }).catch(() => {
                            try {
                                if (output) {
                                    output.focus();
                                    output.select();
                                }
                                if (typeof document !== 'undefined' && document.execCommand) {
                                    document.execCommand('copy');
                                    setChampionPresetStatus('Champion code copied to clipboard.', 'success');
                                } else {
                                    setChampionPresetStatus('Champion code readyâ€”copy manually if needed.', 'success');
                                }
                            } catch (err) {
                                setChampionPresetStatus('Unable to access clipboard. Select and copy the code manually.', 'error');
                            }
                        });
                    } else {
                        try {
                            if (output) {
                                output.focus();
                                output.select();
                            }
                        } catch (err) { }
                        setChampionPresetStatus('Clipboard unavailable. Select and copy the code manually.', 'error');
                    }
                });
            }

            const championPresetCodeInput = q('championPresetCodeInput');
            const applyChampionPresetBtn = q('applyChampionPresetBtn');
            if (applyChampionPresetBtn) {
                applyChampionPresetBtn.addEventListener('click', () => {
                    const code = championPresetCodeInput && championPresetCodeInput.value ? championPresetCodeInput.value.trim() : '';
                    if (!code) {
                        setChampionPresetStatus('Enter a champion code to load.', 'error');
                        return;
                    }
                    const result = loadChampionPresetCode(code, { player: store.player, applyChampion: true });
                    if (!result.success) {
                        setChampionPresetStatus(result.message || 'Failed to apply champion code.', 'error');
                        return;
                    }
                    setChampionPresetStatus('Champion configuration restored from code.', 'success');
                    refreshPrimordialSoldierLaboratory();
                });
            }

            if (championPresetCodeInput) {
                championPresetCodeInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        if (applyChampionPresetBtn) {
                            applyChampionPresetBtn.click();
                        }
                    }
                });
            }

            q("menuBtn").addEventListener("click", () => {
                if (q('scorePanel').classList.contains('hide')) {
                    pauseGame();

                    q('scorePanel').classList.remove('hide');
                } else {
                    closeScoresLogic();
                }
            });

            q("fsEnterBtn").addEventListener('click', () => { const r = document.documentElement; if (!document.fullscreenElement) { if (r.requestFullscreen) r.requestFullscreen(); else if (r.webkitRequestFullscreen) r.webkitRequestFullscreen(); else if (r.msRequestFullscreen) r.msRequestFullscreen() } else { if (document.exitFullscreen) document.exitFullscreen() } });

            q('pauseBtn').addEventListener('click', () => {
                if (store.isGameOver || isAnyPanelOpen()) return;
                store.isPaused = !store.isPaused;
                q('pauseBtn').textContent = store.isPaused ? 'RESUME' : 'PAUSE';
            });

            // EMP charges now auto-activate on proximity, no manual button

            /* Commented out for future implementation
            q('storyBtn').addEventListener('click', (e) => {
                e.stopPropagation();
                pauseGame();
                
                q('storyPanel').classList.remove('hide');
            });
            q('storyPanel').addEventListener('click', () => {
                q('storyPanel').classList.add('hide');
                if (!q('pilotPanel').classList.contains('hide')) {
                } else {
                    resumeGame();
                }
            });
            */

            q("nameInput").addEventListener("keydown", (e) => { if (e.key === "Enter") { const t = (q("nameInput").value || "").slice(0, 16).trim(); if (t) { store.name = t; q("namePanel").classList.add("hide"); if (store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); } } } });

            q("namePanel").addEventListener("click", (e) => {
                if (e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
                    q('nameInput').blur();
                }
            });

            let cheatCodeBuffer = "";
            let cheatTapCount = 0;
            let lastCheatTap = 0;

            function activateDamageOffCheat() {
                if (store.isDamageOff) return;
                store.isDamageOff = true;
                store.cheatsUsed = true;
                announce('CHEAT: DAMAGE & ABILITIES OFF');

                const p = store.player;
                const propsToDisable = [
                    'dmgMult', 'multishot', 'rearMultishot', 'piercing', 'explosive',
                    'flamethrowerLevel', 'missileVolley', 'critChance', 'critDamage',
                    'hasLauncher', 'hasHounds', 'hasLazarusBeam', 'hasVoidBeam',
                    'hasChainLightning', 'hasIceman', 'hasBeefClone', 'blinkDamage', 'missilePierce', 'missileCluster',
                    'hasDoubleStorm', 'hasHybridVoid', 'hasImpactPhase'
                ];

                store.savedPlayerState = {};
                propsToDisable.forEach(prop => {
                    store.savedPlayerState[prop] = p[prop];
                    if (typeof p[prop] === 'number') {
                        p[prop] = 0;
                    } else if (typeof p[prop] === 'boolean') {
                        p[prop] = false;
                    }
                });

                store.savedPlayerState.hounds = store.hounds;
                store.hounds = [];
                store.savedPlayerState.iceman = store.iceman;
                store.iceman = null;
                store.savedPlayerState.beefClone = store.beefClone;
                store.beefClone = null;
                store.savedPlayerState.escortDrones = store.escortDrones;
                store.escortDrones = [];
                store.savedPlayerState.playerChampion = store.playerChampion;
                if (store.playerChampion) {
                    store.playerChampion.currentTarget = null;
                    store.playerChampion._lastTargetSeen = 0;
                }
                store.savedPlayerState.championMinions = store.championMinions;
                if (Array.isArray(store.championMinions)) {
                    store.championMinions.forEach(minion => {
                        if (!minion) return;
                        minion.currentTarget = null;
                        minion._lastTargetSeen = 0;
                    });
                }
                store.playerChampion = null;
                store.championMinions = [];
            }

            function deactivateDamageOffCheat() {
                if (!store.isDamageOff || !store.savedPlayerState) return;
                store.isDamageOff = false;
                announce('CHEAT: DAMAGE & ABILITIES ON');

                const p = store.player;
                for (const prop in store.savedPlayerState) {
                    if (prop === 'hounds') {
                        store.hounds = store.savedPlayerState.hounds;
                    } else if (prop === 'iceman') {
                        store.iceman = store.savedPlayerState.iceman;
                    } else if (prop === 'beefClone') {
                        store.beefClone = store.savedPlayerState.beefClone;
                    } else if (prop === 'escortDrones') {
                        store.escortDrones = store.savedPlayerState.escortDrones;
                    } else if (prop === 'playerChampion') {
                        store.playerChampion = store.savedPlayerState.playerChampion || null;
                        if (store.playerChampion) {
                            store.playerChampion.state = null;
                            store.playerChampion.dashTimer = 0;
                            store.playerChampion.dashVX = 0;
                            store.playerChampion.dashVY = 0;
                            store.playerChampion.dashHits = null;
                            store.playerChampion.dashCooldownTimer = Math.max(0, store.playerChampion.dashCooldownTimer || 0);
                            store.playerChampion.currentTarget = null;
                            store.playerChampion._lastTargetSeen = 0;
                            store.playerChampion.fireTimer = Math.max(0, store.playerChampion.fireTimer || 0);
                        }
                    } else if (prop === 'championMinions') {
                        const savedMinions = store.savedPlayerState.championMinions;
                        store.championMinions = Array.isArray(savedMinions) ? savedMinions : [];
                        if (store.playerChampion && store.championMinions.length) {
                            store.championMinions.forEach(minion => {
                                if (!minion) return;
                                minion.dead = false;
                                minion.fireTimer = Math.max(0, minion.fireTimer || 0);
                                minion.currentTarget = null;
                                minion._lastTargetSeen = 0;
                            });
                        }
                    } else if (p.hasOwnProperty(prop)) {
                        p[prop] = store.savedPlayerState[prop];
                    }
                }

                store.savedPlayerState = null;
            }

            function activateSubclassCheat() {
                if (!store.player.pilotGenome) {
                    announce("CHEAT FAILED: Choose a Pilot first.");
                    return;
                }
                if (store.player.subclass) {
                    announce("CHEAT FAILED: Subclass already chosen.");
                    return;
                }

                store.cheatsUsed = true;
                announce('CHEAT: SKIPPING TO SUBCLASS SELECT');
                showSubclassSelect();
            }

            function activateClassCheat() {
                store.cheatsUsed = true;
                announce('CHEAT: SKIPPING TO CLASS SELECT');
                showPilotSelect();
            }

            const CHAMPION_CHEAT_ROTATIONS = Object.freeze([
                { attack: 'ember', skin: 'solstice', label: 'Solar Brand + Solstice' },
                { attack: 'tempest', skin: 'tempest', label: 'Tempest Lattice + Tempest' },
                { attack: 'void', skin: 'umbra', label: 'Umbral Resonance + Umbral' }
            ]);

            function activateChampionCheat() {
                if (!store || !store.player || !store.world) {
                    announce("CHEAT FAILED: Start a run first.");
                    cheatCodeBuffer = "";
                    return;
                }

                store.cheatsUsed = true;
                const player = store.player;
                const upgrades = ensureChampionUpgradeState(player);

                if (typeof store.championCheatIndex !== 'number') {
                    store.championCheatIndex = 0;
                }
                const rotation = CHAMPION_CHEAT_ROTATIONS[store.championCheatIndex % CHAMPION_CHEAT_ROTATIONS.length];
                store.championCheatIndex = (store.championCheatIndex + 1) % CHAMPION_CHEAT_ROTATIONS.length;

                upgrades.unlockedAttacks.ember = true;
                upgrades.unlockedAttacks.tempest = true;
                upgrades.unlockedAttacks.void = true;
                upgrades.attackModule = rotation.attack;
                upgrades.cadenceLevel = CHAMPION_CADENCE_LEVELS.length - 1;
                upgrades.minionProtocols = CHAMPION_MINION_PROTOCOL_LEVELS.length - 1;
                if (!upgrades.unlockedSkins || typeof upgrades.unlockedSkins !== 'object') {
                    upgrades.unlockedSkins = {};
                }
                CHAMPION_SKIN_OPTIONS.forEach(opt => upgrades.unlockedSkins[opt.id] = true);
                upgrades.skin = rotation.skin;

                player.championUnlocked = true;

                let champion = store.playerChampion;
                if (!champion || champion.dead) {
                    grantChampionCompanion();
                    champion = store.playerChampion;
                }

                if (!champion) {
                    announce("CHEAT FAILED: Champion unavailable.");
                    cheatCodeBuffer = "";
                    return;
                }

                champion.dead = false;
                champion.x = clamp(player.x, 60, W - 60);
                champion.y = clamp(player.y - 90, 80, H - 120);
                champion.roamAnchor = null;
                champion.state = null;
                champion.dashCooldownTimer = 0;

                const targetLevel = PLAYER_CHAMPION_CONFIG.maxLevel || 5;
                const levelDelta = Math.max(0, targetLevel - 1);
                champion.level = targetLevel;
                champion.damageScale = 1 + (targetLevel - 1) * 0.25;
                champion.fireCooldownBase = Math.max(0.6, PLAYER_CHAMPION_CONFIG.baseFireCooldown * Math.pow(0.9, levelDelta));
                champion.dashCooldownBase = Math.max(1.5, PLAYER_CHAMPION_CONFIG.baseDashCooldown * Math.pow(0.92, levelDelta));
                champion.momentumBase = Math.min(6.2, 4.1 + 0.25 * levelDelta);
                champion.momentum = champion.momentumBase;
                champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + targetLevel * 6;
                champion.guardRadius = champion.guardRadiusBase;
                champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (targetLevel - 1) * 0.08;
                champion.angularSpeed = champion.angularSpeedBase;
                champion.volleySize = Math.min(7, 4 + targetLevel);
                champion.volleySpread = Math.min(0.22, 0.16 + (targetLevel - 1) * 0.015);
                champion.specialAbilityCooldown = 0;
                champion.echoCooldown = 0;

                applyChampionUpgradeLoadout(champion, { refreshMinions: true });

                ensureChampionCollections();
                store.championMinions.length = 0;
                for (let i = 0; i < PLAYER_CHAMPION_CONFIG.maxMinions; i++) {
                    spawnChampionMinion(champion);
                }
                refreshChampionMinionsFromState(champion);

                champion.fireTimer = Math.max(0.05, (champion.fireCooldown || PLAYER_CHAMPION_CONFIG.baseFireCooldown) * 0.15);
                champion.dashCooldown = Math.max(0.6, champion.dashCooldownBase * (CHAMPION_CADENCE_LEVELS[upgrades.cadenceLevel]?.dashCooldownMult || 1));

                setWorldGold(Math.max(getWorldGold(), 600));

                announce(`CHEAT: Champion test loadout (${rotation.label}) online!`);
                playSound('epicHorn');

                cheatCodeBuffer = "";
            }

            function activatePowerCheat() {
                store.cheatsUsed = true;
                announce('CHEAT: POWER UP!');
                resetGame();
                setWorldGold(2000);
                store.player.multishot = 5;
                initWave();
                cheatCodeBuffer = "";
            }

            // ENABLED: Spec2 cheat functions  
            function activateSpec2Cheat() {
                if (!store.player.pilotGenome) {
                    announce("CHEAT FAILED: Choose a Pilot first.");
                    return;
                }
                if (!store.player.subclass) {
                    announce("CHEAT FAILED: Choose a Subclass first.");
                    return;
                }

                store.cheatsUsed = true;
                announce('CHEAT: JUMPING TO SUB2');
                showSpecSelect(true); // true = additive/second spec
            }

            function activateSpeedCheat() {
                // Initialize if not present
                if (!window.gameSpeedMultiplier || window.gameSpeedMultiplier < 1) {
                    window.gameSpeedMultiplier = 1;
                }

                // Cycle through speed multipliers: 1x -> 2x -> 3x -> 1x
                if (window.gameSpeedMultiplier === 1) {
                    window.gameSpeedMultiplier = 2;
                    announce('CHEAT: GAME SPEED 2X');
                } else if (window.gameSpeedMultiplier === 2) {
                    window.gameSpeedMultiplier = 3;
                    announce('CHEAT: GAME SPEED 3X');
                } else {
                    window.gameSpeedMultiplier = 1;
                    announce('CHEAT: GAME SPEED NORMAL');
                }

                store.cheatsUsed = true;
            }

            const SUBCLASS_CHEAT_CODES = {
                jug: { subclass: 'juggernaut', genome: 'beef', label: 'JUGGERNAUT' },
                mar: { subclass: 'marauder', genome: 'beef', label: 'MARAUDER' },
                dem: { subclass: 'demolitioner', genome: 'rocketman', label: 'DEMOLITIONER' },
                rai: { subclass: 'railgunner', genome: 'rocketman', label: 'RAILGUNNER' },
                pha: { subclass: 'phasestriker', genome: 'voidmancer', label: 'PHASESTRIKER' },
                sto: { subclass: 'stormbringer', genome: 'voidmancer', label: 'STORMBRINGER' }
            };

            function clearSubclassEffects() {
                const p = store.player;
                if (!p || !p.subclass) return;

                switch (p.subclass) {
                    case 'railgunner':
                        p.missilePierce = player_initial_state.missilePierce || 0;
                        break;
                    case 'demolitioner':
                        p.missileCluster = player_initial_state.missileCluster || false;
                        break;
                    case 'marauder':
                        p.beefChainMode = false;
                        if (p.marauderHitTargets && typeof p.marauderHitTargets.clear === 'function') {
                            p.marauderHitTargets.clear();
                        }
                        break;
                    case 'phasestriker':
                        if (!p.hasPhasestriker) {
                            p.hasVoidLaser = false;
                        }
                        p.voidLaserTarget = null;
                        p.voidLaserDamageTimer = 0;
                        p.voidLaserRetargetTimer = 0;
                        p.voidLaserRange = 0;
                        break;
                    case 'stormbringer':
                        resetPlayerLightningState(p, { preserveUnlock: true });
                        break;
                }

                p.subclass = null;
            }

            function activateSubclassOverrideCheat(targetSubclass, requiredGenome, label) {
                const p = store.player;
                if (!p || !p.pilotGenome) {
                    announce('CHEAT FAILED: Choose a Pilot first.');
                    cheatCodeBuffer = "";
                    return;
                }

                if (requiredGenome && p.pilotGenome !== requiredGenome) {
                    announce(`CHEAT FAILED: Requires ${requiredGenome.toUpperCase()} pilot.`);
                    cheatCodeBuffer = "";
                    return;
                }

                store.cheatsUsed = true;

                if (p.subclass === targetSubclass) {
                    updateAbilityButtonIcon();
                    announce(`CHEAT: ${targetSubclass.toUpperCase()} ALREADY ACTIVE`);
                    cheatCodeBuffer = "";
                    return;
                }

                clearSubclassEffects();

                const originalEnemyBonus = store.world ? store.world.enemyHealthBonus : null;
                if (label) {
                    announce(`CHEAT: ${label} READY`);
                }
                applySubclassBonus(targetSubclass);
                if (store.world && originalEnemyBonus !== null && originalEnemyBonus !== undefined) {
                    store.world.enemyHealthBonus = originalEnemyBonus;
                }

                if (targetSubclass === 'marauder' && (!p.marauderHitTargets || typeof p.marauderHitTargets.clear !== 'function')) {
                    p.marauderHitTargets = new Set();
                }

                updateAbilityButtonIcon();
                cheatCodeBuffer = "";
            }

            function activateSevenCheat() {
                store.cheatsUsed = true;
                initializeProgressionTracking();

                const pointsGranted = 7;
                for (let i = 0; i < pointsGranted; i++) {
                    checkProgressionLogic(true);
                }

                announce(`CHEAT: +${pointsGranted} PROGRESSION POINTS`);
                updateSkillTreeUI();
                cheatCodeBuffer = "";
            }

            q('diagBox').children[0].addEventListener('click', () => {
                const now = performance.now();
                if (now - lastCheatTap > 500) {
                    cheatTapCount = 0;
                }
                lastCheatTap = now;
                cheatTapCount++;
                if (cheatTapCount >= 3) {
                    activatePowerCheat();
                    cheatTapCount = 0;
                }
            });

            addEventListener("keydown", e => {
                const key = e.key.toLowerCase();
                if (document.activeElement.tagName === "INPUT") return;

                if (/[a-z]/.test(key)) {
                    cheatCodeBuffer += key;
                    if (cheatCodeBuffer.length > 10) {
                        cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
                    }

                    if (cheatCodeBuffer.endsWith('power')) {
                        activatePowerCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('off')) {
                        activateDamageOffCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('on')) {
                        deactivateDamageOffCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('fast')) {
                        activateSpeedCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('class')) {
                        activateClassCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('sub')) {
                        activateSubclassCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('spec2')) {
                        activateSpec2Cheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('sigil') || cheatCodeBuffer.endsWith('champ')) {
                        activateChampionCheat();
                        cheatCodeBuffer = "";
                    } else {
                        const subclassCode = Object.keys(SUBCLASS_CHEAT_CODES).find(code => cheatCodeBuffer.endsWith(code));
                        if (subclassCode) {
                            const { subclass, genome, label } = SUBCLASS_CHEAT_CODES[subclassCode];
                            activateSubclassOverrideCheat(subclass, genome, label);
                        } else if (cheatCodeBuffer.endsWith('seven')) {
                            activateSevenCheat();
                        }
                    }
                } else {
                    if (key !== ' ' && key !== 'b') {
                        cheatCodeBuffer = "";
                    }
                }

                // EMP charges auto-activate on proximity, spacebar no longer needed
                if (key === 'escape') {
                    e.preventDefault();
                    // Close skill tree if it's open
                    if (!q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                        closeSkillTree();
                    }
                }
            });

            let lastTapTime = 0;
            cvs.addEventListener('touchend', e => {
                e.preventDefault();
                if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
                    const now = performance.now();
                    const DOUBLE_TAP_DELAY = 300;
                    if (now - lastTapTime < DOUBLE_TAP_DELAY) {
                        const p = pointFromEvent(e);
                        tryVoidStep(store.player, p);
                        lastTapTime = 0;
                    } else {
                        lastTapTime = now;
                    }
                }
            }, { passive: false });

            cvs.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
                    const p = pointFromEvent(e);
                    tryVoidStep(store.player, p);
                }
            });


            // PERFORMANCE: Enhanced performance monitoring
            let perfFrameCount = 0;
            let perfLastFPSUpdate = 0;
            let perfFPS = 0;
            let perfWorstFrameTime = 0;

            function createPerformanceMetrics() {
                return {
                    stepWorldTime: 0,
                    renderTime: 0,
                    frameTime: 0,
                    // New detailed metrics
                    hudUpdateTime: 0,
                    bulletUpdateTime: 0,
                    enemyUpdateTime: 0,
                    collisionTime: 0,
                    drawCallTime: 0,
                    memoryUsage: 0,
                    slowFrameCount: 0,
                    lastSlowLog: 0,
                    activeEnemies: 0,
                    activeBullets: 0,
                    activeFlames: 0
                };
            }

            let performanceMetrics = createPerformanceMetrics();

            // Performance budget alerts
            const PERFORMANCE_BUDGETS = {
                frameTime: 16.67, // 60fps budget
                stepWorld: 8,     // Half frame budget for logic
                render: 4,        // Quarter frame budget for rendering
                hudUpdate: 1      // HUD should be very fast
            };

            function setTelemetryEnabled(enabled, forceReset = false) {
                const normalized = !!enabled;
                if (!forceReset && normalized === store.telemetryEnabled) {
                    return normalized;
                }

                store.telemetryEnabled = normalized;

                try {
                    if (window.localStorage) {
                        window.localStorage.setItem('voidTelemetry', normalized ? '1' : '0');
                    }
                } catch (err) {
                    // Ignore storage access issues
                }

                if (normalized) {
                    performanceMetrics = createPerformanceMetrics();
                    perfFrameCount = 0;
                    perfLastFPSUpdate = performance.now();
                    perfWorstFrameTime = 0;
                }

                console.info(`[PERF] Telemetry ${normalized ? 'enabled' : 'disabled'}`);
                return normalized;
            }

            window.enableTelemetry = () => setTelemetryEnabled(true);
            window.disableTelemetry = () => setTelemetryEnabled(false);
            window.toggleTelemetry = () => setTelemetryEnabled(!store.telemetryEnabled);

            setTelemetryEnabled(store.telemetryEnabled, true);

            function frame(now) {
                const telemetryActive = !!store.telemetryEnabled;
                const frameStart = telemetryActive ? performance.now() : 0;

                const rawDt = Math.min((now - store.last) / 1000, 0.07);
                const speedMultiplier = window.gameSpeedMultiplier || 1;

                // Cap the dt to prevent simulation instability even with speed multiplier
                const dt = Math.min(rawDt * speedMultiplier, 0.1);

                store.last = now;

                let stepStart;
                if (telemetryActive) {
                    stepStart = performance.now();
                }
                if (!store.isPaused && !store.isGameOver) {
                    stepWorld(dt);
                }
                if (telemetryActive && stepStart !== undefined) {
                    performanceMetrics.stepWorldTime = performance.now() - stepStart;
                }

                let renderStart;
                if (telemetryActive) {
                    renderStart = performance.now();
                }
                render(rawDt); // Use original dt for rendering to avoid visual issues
                if (telemetryActive && renderStart !== undefined) {
                    performanceMetrics.renderTime = performance.now() - renderStart;
                }

                if (telemetryActive) {
                    const currentFrameTime = performance.now() - frameStart;
                    if (currentFrameTime > PERFORMANCE_BUDGETS.frameTime) {
                        performanceMetrics.slowFrameCount++;
                    }

                    const frameTime = currentFrameTime;
                    performanceMetrics.frameTime = frameTime;
                    performanceMetrics.activeEnemies = store.enemies ? store.enemies.length : 0;
                    performanceMetrics.activeBullets = store.bullets ? store.bullets.length : 0;
                    performanceMetrics.activeFlames = store._activeFlamesCache ? store._activeFlamesCache.length : 0;

                    if (frameTime > perfWorstFrameTime) {
                        perfWorstFrameTime = frameTime;
                    }

                    if (frameTime > 33 && (!performanceMetrics.lastSlowLog || now - performanceMetrics.lastSlowLog > 1500)) {
                        console.warn(
                            `[PERF] Slow frame ${frameTime.toFixed(1)}ms (logic ${performanceMetrics.stepWorldTime.toFixed(1)}ms, ` +
                            `render ${performanceMetrics.renderTime.toFixed(1)}ms, enemies ${performanceMetrics.activeEnemies}, ` +
                            `bullets ${performanceMetrics.activeBullets}, flames ${performanceMetrics.activeFlames})`
                        );
                        performanceMetrics.lastSlowLog = now;
                    }

                    perfFrameCount++;
                    if (now - perfLastFPSUpdate > 3000) { // Log every 3 seconds
                        perfFPS = Math.round(perfFrameCount / 3);
                        perfFrameCount = 0;
                        perfLastFPSUpdate = now;

                        // Calculate memory usage if available
                        if (performance.memory) {
                            performanceMetrics.memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                        }
                    }
                }

                requestAnimationFrame(frame);

            }

            // Game initialization moved to DOMContentLoaded event


            // Optimized Asset Preloader System
            class AssetPreloader {
                constructor() {
                    // Prioritized asset groups for progressive loading
                    // ASSET GROUPS DISABLED FOR PERFORMANCE TESTING
                    this.assetGroups = {
                        critical: {
                            images: [], // ['cow.png', 'rockyboy.png', 'goggles.png'], // Pilot selection UI
                            audio: [] // ['Horn.wav', 'epichorntrimmed.m4a'] // Essential UI sounds
                        },
                        gameplay: {
                            images: [], // ['marauder.png', 'jug2.png', 'phase.png', 'storm.png'], // Subclass icons
                            audio: [] // ['Explosion.m4a', 'thunk.wav', 'cluster.mp3', 'thunder.mp3'] // Core game sounds
                        },
                        extended: {
                            images: [], // ['mar11.png', 'mar2.png', 'mar3.png', 'mar4.png', 'jug3.png'], // Skill trees
                            audio: [] // ['trap.m4a', 'dogs.m4a', 'charge.m4a', 'beefcharge.m4a', 'shao_kahn.m4a']
                        }
                    };

                    this.loadedAssets = new Map(); // Cache for loaded assets
                    this.loadingPromises = new Map(); // Prevent duplicate loading
                    this.lastUsed = new Map(); // Track usage for cleanup
                    this.memoryLimit = 150 * 1024 * 1024; // 150MB memory limit
                    this.currentMemoryUsage = 0;

                    this.loaded = 0;
                    this.total = this.getTotalAssetCount();
                    this.progress = 0;
                }

                getTotalAssetCount() {
                    return Object.values(this.assetGroups).reduce((total, group) => {
                        return total + group.images.length + group.audio.length;
                    }, 0);
                }

                updateProgress(assetName, category) {
                    this.loaded++;
                    this.progress = Math.floor((this.loaded / this.total) * 100);

                    const loadingBar = document.getElementById('loadingBar');
                    const loadingText = document.getElementById('loadingText');
                    const loadingDetails = document.getElementById('loadingDetails');

                    if (loadingBar) loadingBar.style.width = this.progress + '%';
                    if (loadingText) loadingText.textContent = `Loading Assets... ${this.progress}%`;
                    if (loadingDetails) {
                        const categoryName = category === 'image' ? 'Visual Assets' : 'Audio Systems';
                        loadingDetails.textContent = `${categoryName}: ${assetName}`;
                    }

                    if (this.loaded >= this.total) {
                        setTimeout(() => this.finishLoading(), 500);
                    }
                }

                estimateAssetSize(src, type) {
                    // Rough size estimates for memory management
                    if (type === 'image') {
                        // Estimate based on typical icon sizes: 64x64 = 16KB, 128x128 = 64KB
                        return src.includes('skill') || src.includes('tree') ? 16384 : 32768;
                    } else if (type === 'audio') {
                        // Audio files typically 50KB-500KB
                        return src.includes('.m4a') ? 200000 : 100000;
                    }
                    return 50000; // Default estimate
                }

                cleanupUnusedAssets() {
                    // Skip cleanup if we're under memory pressure threshold (75% of limit)
                    if (this.currentMemoryUsage < this.memoryLimit * 0.75) {
                        return;
                    }

                    const now = Date.now();
                    const cleanupThreshold = 300000; // 5 minutes
                    let cleanedMemory = 0;
                    const assetsToCleanup = [];

                    // Batch identify assets for cleanup to avoid iteration issues
                    for (const [key, timestamp] of this.lastUsed) {
                        if (now - timestamp > cleanupThreshold && this.loadedAssets.has(key)) {
                            assetsToCleanup.push(key);
                        }
                    }

                    // Prioritize cleanup of largest assets first
                    assetsToCleanup.sort((a, b) => {
                        const sizeA = this.estimateAssetSize(a, this.loadedAssets.get(a) instanceof Image ? 'image' : 'audio');
                        const sizeB = this.estimateAssetSize(b, this.loadedAssets.get(b) instanceof Image ? 'image' : 'audio');
                        return sizeB - sizeA;
                    });

                    // Clean up assets
                    assetsToCleanup.forEach(key => {
                        const asset = this.loadedAssets.get(key);
                        const estimatedSize = this.estimateAssetSize(key, asset instanceof Image ? 'image' : 'audio');

                        this.loadedAssets.delete(key);
                        this.lastUsed.delete(key);
                        this.loadingPromises.delete(key); // Also clean up loading promises
                        this.currentMemoryUsage -= estimatedSize;
                        cleanedMemory += estimatedSize;
                    });


                }

                loadAssetGroup(groupName) {
                    return new Promise((resolve) => {
                        const group = this.assetGroups[groupName];
                        if (!group) {
                            resolve();
                            return;
                        }

                        const allAssets = [...group.images.map(src => ({ src, type: 'image' })),
                        ...group.audio.map(src => ({ src, type: 'audio' }))];

                        if (allAssets.length === 0) {
                            resolve();
                            return;
                        }

                        let loadedCount = 0;
                        const timeout = setTimeout(() => {
                            console.warn(`${groupName} group loading timeout - continuing anyway`);
                            resolve();
                        }, 8000);

                        allAssets.forEach(({ src, type }) => {
                            this.loadSingleAsset(src, type).then(() => {
                                loadedCount++;
                                this.updateProgress(src, type);
                                if (loadedCount === allAssets.length) {
                                    clearTimeout(timeout);
                                    resolve();
                                }
                            }).catch(() => {
                                loadedCount++;
                                this.updateProgress(src, type);
                                if (loadedCount === allAssets.length) {
                                    clearTimeout(timeout);
                                    resolve();
                                }
                            });
                        });
                    });
                }

                loadSingleAsset(src, type) {
                    // Check if already loaded or loading
                    if (this.loadedAssets.has(src)) {
                        this.lastUsed.set(src, Date.now());
                        return Promise.resolve(this.loadedAssets.get(src));
                    }

                    if (this.loadingPromises.has(src)) {
                        return this.loadingPromises.get(src);
                    }

                    // Check memory limit before loading
                    const estimatedSize = this.estimateAssetSize(src, type);
                    if (this.currentMemoryUsage + estimatedSize > this.memoryLimit) {
                        this.cleanupUnusedAssets();
                    }

                    const promise = new Promise((resolve, reject) => {
                        if (type === 'image') {
                            const img = new Image();
                            img.onload = () => {
                                this.loadedAssets.set(src, img);
                                this.lastUsed.set(src, Date.now());
                                this.currentMemoryUsage += estimatedSize;
                                resolve(img);
                            };
                            img.onerror = () => {
                                console.warn(`Failed to load image: ${src}`);
                                reject(new Error(`Failed to load ${src}`));
                            };
                            img.src = src;
                        } else if (type === 'audio') {
                            const audio = new Audio();
                            audio.oncanplaythrough = () => {
                                this.loadedAssets.set(src, audio);
                                this.lastUsed.set(src, Date.now());
                                this.currentMemoryUsage += estimatedSize;
                                resolve(audio);
                            };
                            audio.onerror = () => {
                                console.warn(`Failed to load audio: ${src}`);
                                reject(new Error(`Failed to load ${src}`));
                            };
                            audio.volume = 0.1;
                            audio.src = src;
                        }
                    });

                    this.loadingPromises.set(src, promise);
                    return promise;
                }

                // Method to get a loaded asset (lazy load if needed)
                getAsset(src, type = 'image') {
                    if (this.loadedAssets.has(src)) {
                        this.lastUsed.set(src, Date.now()); // Update usage
                        return this.loadedAssets.get(src);
                    }

                    // Lazy load if not available
                    this.loadSingleAsset(src, type).catch(err =>
                        console.warn(`Failed to lazy load ${src}:`, err)
                    );

                    return null; // Return null for immediate use, will be available later
                }

                // Method to preload assets for a specific feature
                preloadForFeature(feature) {
                    const featureAssets = {
                        'pilot-selection': ['cow.png', 'rockyboy.png', 'goggles.png'],
                        'subclass-selection': ['marauder.png', 'jug2.png', 'phase.png', 'storm.png'],
                        'skill-tree': ['mar11.png', 'mar2.png', 'mar3.png', 'jug3.png', 'phase2.png'],
                        'combat-audio': ['Explosion.m4a', 'thunk.wav', 'cluster.mp3']
                    };

                    const assets = featureAssets[feature] || [];
                    return Promise.all(assets.map(src => {
                        const type = src.includes('.') && (src.endsWith('.mp3') || src.endsWith('.m4a') || src.endsWith('.wav')) ? 'audio' : 'image';
                        return this.loadSingleAsset(src, type);
                    }));
                }

                async startLoading() {
                    try {
                        const loadingDetails = document.getElementById('loadingDetails');
                        if (loadingDetails) loadingDetails.textContent = 'Initializing combat protocols...';

                        // Small delay for visual effect
                        await new Promise(resolve => setTimeout(resolve, 500));

                        // Progressive loading: Critical first, then gameplay, then extended
                        if (loadingDetails) loadingDetails.textContent = 'ðŸš€ Loading critical assets...';
                        await this.loadAssetGroup('critical');

                        if (loadingDetails) loadingDetails.textContent = 'âš”ï¸ Loading gameplay assets...';
                        await this.loadAssetGroup('gameplay');

                        // Load extended assets in background after main loading finishes
                        setTimeout(() => {
                            this.loadAssetGroup('extended').then(() => {
                                // Assets loaded silently
                            });
                        }, 2000);

                        // Start memory cleanup timer
                        setInterval(() => this.cleanupUnusedAssets(), 180000); // Every 3 minutes

                    } catch (error) {
                        console.error('Asset loading failed:', error);
                        this.finishLoading(); // Continue anyway
                    }
                }

                finishLoading() {
                    const loadingDetails = document.getElementById('loadingDetails');
                    const loadingText = document.getElementById('loadingText');

                    if (loadingDetails) loadingDetails.textContent = 'ðŸš€ Combat systems online! Engaging...';
                    if (loadingText) loadingText.textContent = 'Ready for Combat! 100%';

                    // Make asset manager globally available
                    window.assetManager = this;

                    // Fade out loading screen
                    setTimeout(() => {
                        const loadingScreen = document.getElementById('loadingScreen');
                        if (loadingScreen) {
                            loadingScreen.style.transition = 'opacity 1s ease-out';
                            loadingScreen.style.opacity = '0';
                            loadingScreen.style.pointerEvents = 'none';
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                                this.initializeGame();
                            }, 1000);
                        }
                    }, 800);
                }

                initializeGame() {
                    // Initialize mobile controls and start the game
                    setupMobileControls();

                    // Show a brief "systems online" message
                    setTimeout(() => {
                        if (typeof announce === 'function') {
                            announce('ðŸš€ VOID SKIES: Combat systems online!');
                        }
                    }, 500);
                }
            }

            // Game initialization runs immediately (like fghfgh.html working version)
            try {
                ensureName();
                refreshScoreList();
                requestAnimationFrame(frame);
            } catch (error) {
                console.error("Game initialization failed:", error);
                try {
                    updateLeaderboard(null);
                    ensureName();
                    requestAnimationFrame(frame);
                    console.log("Game started in offline mode")
                } catch (criticalError) {
                    console.error("Critical startup failure:", criticalError);
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                // SKIP ASSET LOADING FOR PERFORMANCE TESTING - Start game immediately

                // Hide loading screen immediately
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }

                // Set up upgrade popup OK button
                const upgradePopupOkBtn = document.getElementById('upgradePopupOkBtn');
                if (upgradePopupOkBtn) {
                    upgradePopupOkBtn.addEventListener('click', () => {
                        const panel = document.getElementById('upgradePopupPanel');
                        if (panel) {
                            panel.classList.add('hide');
                            resumeGame();
                        }
                    });
                }

                // Initialize mobile controls if the function exists (like fghfgh.html)
                if (typeof setupMobileControls === 'function') {
                    setupMobileControls();
                }
            });

        })();
    </script>
</body>

</html>