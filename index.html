<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 98vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        
        /* Hide VS Code browser controls */
        .monaco-workbench .part.titlebar, 
        .vs-dark .monaco-workbench .part.titlebar,
        .titlebar,
        .browser-close-button,
        .browser-action-buttons,
        .monaco-action-bar {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            opacity: 0 !important;
        }

        .close-btn {
            position: absolute;
            top: 8px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 20px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 4px;
        }
        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Hide only the specific problematic close buttons */
        #closeScores {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        /* More aggressive hiding of browser UI */
        body {
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden;
        }
        
        /* Hide any top-level browser chrome */
        :root {
            --browser-chrome-height: 0px;
        }
        
    #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:0;}
    .stage{width:100vw; height:100svh; position:relative;display:grid;place-items:center;background:#000;border-radius:0;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
    canvas{background:transparent;border-radius:16px;touch-action:none;cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }
    #diagBox{position:absolute;left:8px;top:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:left;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s; font-family: 'Orbitron', 'Audiowide', ui-sans-serif;}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        
        .panel{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:rgba(26,0,34,.95);
            border:1px solid var(--accent);
            border-radius:16px;
            padding:12px;
            width:min(600px, 90vw);
            backdrop-filter:blur(12px);
            color:#ffddff;
            box-shadow:0 0 40px rgba(178,102,255,.3);
            z-index:100;
        }
        

        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }
        #shopPanel h2, #levelPanel h2, #scorePanel h2, #namePanel h2, #pilotPanel h2, #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }
        #shopPanel p, #levelPanel p, #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }
        #shopGrid, #scorePanel div {
            max-height: 60vh; 
            overflow-y: auto;
            padding-right: 8px;
        }
        .grid{
            display:grid;
            gap:8px;
            grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
        }
        .hide{display:none!important}
        #belowBoard{width:min(98vw,var(--maxw));margin:50px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        
        .skill-card {
            background: radial-gradient(circle, rgba(51,0,68,1) 0%, rgba(51,0,68,0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        
        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }
        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }
        .skill-title{
            font-weight:700;
            color:#c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }
        .skill-desc{
            font-size:11px;
            color:#ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }

        .skill-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        .skill-card-node-pair {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            width: 100%;
        }

        #subclassPanel.skill-tree-active {
            width: min(900px, 95vw);
            max-height: 80vh;
            overflow-y: auto;
            padding: 20px 24px 28px;
        }

        #skillTree {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* SKILL TREE - Portrait-oriented Icon Button System */
        .skill-track {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .track-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        .skill-icon-button {
            position: relative;
            width: 120px;
            height: 140px;
            cursor: pointer;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .skill-icon-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: all 0.4s ease;
        }
        .skill-icon-image.enhanced {
            filter: brightness(1.3) saturate(1.2) drop-shadow(0 0 12px rgba(255,215,0,0.8));
        }
        .skill-info-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.8) 30%, rgba(0,0,0,0.95) 100%);
            padding: 15px 12px 12px;
            transform: translateY(70%);
            transition: all 0.4s ease;
        }
        .skill-overlay-title {
            font-size: 14px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 6px;
            text-align: center;
        }
        .skill-overlay-desc {
            font-size: 10px;
            color: #cccccc;
            line-height: 1.3;
            text-align: center;
        }
        
        /* SKILL ICON BUTTON STATES */
        .skill-icon-button.available {
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        .skill-icon-button.available:hover {
            border-color: #66BB6A;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            transform: translateY(-5px) scale(1.05);
        }
        .skill-icon-button.available:hover .skill-info-overlay {
            transform: translateY(0%);
        }
        .skill-icon-button.available:hover .skill-icon-image {
            filter: brightness(1.2) saturate(1.1);
        }
        
        .skill-icon-button.active {
            border-color: #FFD700;
            background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, rgba(255,215,0,0.2) 100%);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1);
            animation: activeIconGlow 3s ease-in-out infinite;
        }
        .skill-icon-button.active .skill-icon-image {
            filter: brightness(1.4) saturate(1.3) drop-shadow(0 0 15px rgba(255,215,0,0.9));
        }
        .skill-icon-button.active .skill-info-overlay {
            transform: translateY(0%);
            background: linear-gradient(180deg, transparent 0%, rgba(255,215,0,0.1) 30%, rgba(0,0,0,0.9) 100%);
        }
        
        .skill-icon-button.locked {
            border-color: #333;
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.7);
        }
        .skill-icon-button.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        /* CLASS ABILITY TRACK STYLING */
        .class-ability-track {
            position: relative;
            margin-left: 40px;
            padding: 20px;
            border-left: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 0 12px 12px 0;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(135, 206, 235, 0.05));
        }
        .class-ability-track .track-title {
            color: #FFD700;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        .class-ability-solo {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6) !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.2)) !important;
        }
        .class-ability-solo:hover {
            border-color: #FFF700 !important;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8) !important;
            transform: translateY(-8px) scale(1.08) !important;
        }
        
        /* BEAUTIFUL GLOW ANIMATIONS */
        @keyframes activeIconGlow {
            0% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 215, 0, 1.0), inset 0 0 25px rgba(255,255,255,0.2), 0 0 50px rgba(135,206,235,0.3); }
            100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
        }
        
        /* Old skill node classes for compatibility */
        
        /* Beautiful Marble/Lightning Animations */
        @keyframes marbleSwirl {
            0% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
            25% { background: linear-gradient(225deg, #e6e6fa 0%, #f5f5dc 30%, #f8f8ff 60%, #dcdcdc 100%); }
            50% { background: linear-gradient(315deg, #dcdcdc 0%, #f8f8ff 30%, #f5f5dc 60%, #e6e6fa 100%); }
            75% { background: linear-gradient(45deg, #f5f5dc 0%, #dcdcdc 30%, #e6e6fa 60%, #f8f8ff 100%); }
            100% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
        }
        
        @keyframes lightningPulse {
            0% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
            50% { box-shadow: 0 0 15px rgba(255,215,0,0.8), inset 0 0 12px rgba(255,255,255,0.6), 0 0 25px rgba(135,206,235,0.4); }
            100% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
        }
        .skill-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .skill-node.active, .skill-combo-node.active {
            border-color: #FFD700;
            background: #2a2a4e;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        .skill-node.locked, .skill-combo-node.locked {
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skill-combo-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .skill-description {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            min-height: 40px;
            color: #ffddff;
            font-size: 12px;
        }
        .ability-hint {
            font-size: 10px;
            color: #87CEEB;
            text-align: center;
            margin-top: 6px;
            font-style: italic;
            text-shadow: 0 0 4px rgba(135, 206, 235, 0.5);
        }
        .ability-icon {
            font-size: 12px;
            margin: 0 2px;
            display: inline-block;
            animation: pulse-glow 2s infinite;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }
        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }
        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }
        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn{
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.4;
            transition: opacity 0.3s ease-in-out;
        }
        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }
        
        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }
        #bottom-right-controls > .fixed-btn {
            position: static;
        }

        #menuBtn, #fsEnterBtn, #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }
        #pauseBtn {
            top: 50%;
            right: 15px; 
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif; box-sizing: border-box;}
        
        #abilityBar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 6; pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }
        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }
        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }
        
        .shop-item-attack { border-color: #00bfff; }
        .shop-item-health { border-color: #00ff00; }
        .shop-item-utility { border-color: #ffd700; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
            50% { box-shadow: 0 0 35px rgba(102, 255, 178, 1); }
            100% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
        }
        @keyframes pulse-glow-ability {
            0% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
            50% { box-shadow: 0 0 20px rgba(178, 102, 255, .8); }
            100% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
        }
        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(500px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
        
        /* Purple gradient classes for different brightness levels */
        .bright {
            color: #e6ccff;
            text-shadow: 0 0 5px #cc99ff, 0 0 10px #cc99ff;
        }

        .medium {
            color: #b366ff;
            text-shadow: 0 0 3px #9933ff;
        }

        .dim {
            color: #6600cc;
            text-shadow: 0 0 2px #6600cc;
        }

        .faded {
            color: #330066;
            opacity: 0.7;
        }

        .very-faded {
            color: #1a0033;
            opacity: 0.4;
        }

        /* Teleport Tutorial Popup */
        #teleportTutorialPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(102,0,204,0.2) 100%);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(204,153,255,0.4);
        }

        #teleportTutorialPanel h2 {
            color: var(--accent);
            font-family: 'Orbitron';
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--accent);
        }

        .teleport-instruction {
            font-size: 18px;
            color: #ffddff;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .teleport-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 5px var(--accent));
        }

        /* --- MOBILE JOYSTICK & BUTTON CONTROLS --- */
        .mobile-control {
            position: fixed;
            z-index: 20;
            opacity: 0.6;
            display: none; /* Hidden by default */
        }

        body.mobile-controls-active .mobile-control {
            display: block; /* Shown when body class is active */
        }

        #joystick-container {
            bottom: 90px;
            left: 45px;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(50, 0, 70, 0.5);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
        }

        #joystick-stick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ffddff, var(--accent));
            border-radius: 50%;
            pointer-events: none; /* Pass touches through to the base */
        }

        #ability-button-container {
            bottom: 100px;
            right: 70px;
        }

        #ability-button {
            width: 90px;
            height: 90px;
            background: rgba(150, 80, 255, 0.3);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(178, 102, 255, .5);
        }

        #ability-icon {
            width: 70px;
            height: 70px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            filter: drop-shadow(0 0 5px white);
        }

        /* --- TOGGLE SWITCH IN MECH FORGE --- */
        .mobile-toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #330044;
            border: 1px solid var(--accent);
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent2);
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }


        
    </style>
</head>
<body>
    <!-- Asset Loading Screen DISABLED FOR PERFORMANCE TESTING -->
    <div id="loadingScreen" style="
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2a 50%, #0a0a1a 100%); 
        display: none; 
        flex-direction: column; 
        align-items: center; 
        justify-content: center; 
        z-index: 9999;
        font-family: 'Orbitron', monospace;
        color: #b266ff;
    ">
        <div style="text-align: center; margin-bottom: 40px;">
            <h1 style="font-size: 3em; margin: 0; text-shadow: 0 0 20px #b266ff; animation: pulse 2s ease-in-out infinite;">
                ‚ö° VOID SKIES ‚ö°
            </h1>
            <p style="font-size: 1.2em; margin: 10px 0; color: #cc99ff;">
                Initializing Combat Systems...
            </p>
        </div>
        
        <div style="width: 400px; max-width: 80vw; margin-bottom: 20px;">
            <div style="background: rgba(0,0,0,0.5); border: 2px solid #b266ff; border-radius: 10px; padding: 4px;">
                <div id="loadingBar" style="
                    height: 20px; 
                    background: linear-gradient(90deg, #b266ff, #7a49cc); 
                    border-radius: 6px; 
                    width: 0%; 
                    transition: width 0.3s ease;
                    box-shadow: 0 0 10px #b266ff;
                "></div>
            </div>
            <div id="loadingText" style="text-align: center; margin-top: 10px; font-size: 0.9em; color: #cc99ff;">
                Loading Assets... 0%
            </div>
        </div>
        
        <div id="loadingDetails" style="
            font-size: 0.8em; 
            color: #8866bb; 
            text-align: center; 
            min-height: 20px;
        ">
            Scanning combat protocols...
        </div>
        
        <style>
            @keyframes pulse {
                0%, 100% { text-shadow: 0 0 20px #b266ff; }
                50% { text-shadow: 0 0 30px #b266ff, 0 0 40px #b266ff; }
            }
        </style>
    </div>
    
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide">
                        <div class="hud-title">‚ó¢ SYSTEMS ONLINE ‚ó£</div>
                        <div id="powerupList"></div>
                    </div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card">
                            <div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div>
                            <div style="text-align:center">
                                SECTOR <b id="waveNum">1</b> ‚Ä¢ KILLS <b id="killsNum">0</b> ‚Ä¢ LVL <b id="levelNum">1</b>
                            </div>
                        </div>
                        <div id="hudPilotContent" class="hud-card">
                            <div class="hud-title" id="pilotTitle">‚ó¢ UNIDENTIFIED ‚ó£</div>
                            <div style="text-align:center">
                                SCORE <b id="scoreNum">0</b> ‚Ä¢ Gold üí∞ <b id="goldNum" style="color:#FFD700;font-size:1.2em">0</b>
                            </div>
                            <div class="bar" id="hpBar"><span id="hpBarFill" style="width:100%"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="hpText">HP: 100 / 100</div>
                            <div class="bar" id="beefShieldBar" style="margin-top:2px;display:none"><span id="beefShieldBarFill" style="background:linear-gradient(90deg,#ff8c00,#ff4500)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="beefShieldText"></div>
                            <div class="bar" id="shieldBar" style="margin-top:2px;display:none"><span id="shieldBarFill" style="background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="shieldText"></div>
                        </div>
                        <div id="hudBossContent" class="hud-card hide">
                            <div class="hud-title" id="bossTitle">‚ö° BOSS ‚ö°</div>
                            <div class="bar"><span id="bossBarFill" style="width:100%"></span></div>
                        </div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide">
                        <div class="hud-title">‚ó¢ EQUIPMENT ‚ó£</div>
                        <div id="equipmentList"></div>
                    </div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <table style="font-size:10px; color:var(--fg); background:rgba(0,0,0,0.7); padding:8px; border-radius:8px; border-spacing:8px 2px;">
                        <tr><td>v3.8.0</td><td>FPS:</td><td><span id="fps">‚Äî</span></td></tr>

                    </table>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üöÄ PILOT LOST üöÄ</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <!-- <button id="storyBtn" type="button">i</button> -->
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">Cybernetic heavy assault unit with adaptive bio-armor that responds to hostile engagement. Neural implants trigger reflexive counterstrike protocols when threatened.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN"></div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">Former corporate military contractor with black-market ordnance mods. Tactical AI systems provide precision strike capabilities and explosive payload optimization.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="voidmancer">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER"></div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">Quantum-phase enhanced operative with experimental void-fold technology. Neural interfaces allow instantaneous spatial displacement through dimensional rifts.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                     <div id="subclassPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                        </div>

                    </div>
                    <div id="storyPanel" class="panel hide">
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                        Mammalian life developed specialized spacecraft to venture within and colonize the resources of the primitive creatures.<br><br>
                        The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üíÄ CALLSIGN üíÄ</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">üèÜ Aces of the Void üèÜ</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <button type="button" class="close-btn" id="closeShopTopBtn">√ó</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° MECH FORGE ‚ö°</h2>
                        <p style="color:#ffddff">Gold üí∞ <span id="shopgold" style="color:#FFD700;font-size:1.2em">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="teleportTutorialPanel" class="panel hide">
                        <h2>‚ö° VOID-FOLD PROTOCOL ‚ö°</h2>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">üñ±Ô∏è</span>
                            <span>Right-click to teleport</span>
                        </div>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">üëÜüëÜ</span>
                            <span>Double-tap to teleport (mobile)</span>
                        </div>
                        <div style="margin-top: 30px;">
                            <p style="color: #ccaaff; font-size: 14px; margin-bottom: 20px;">
                                Quantum displacement damages enemies at origin point.<br>
                                Use strategically to escape danger and deal damage.
                            </p>
                            <button id="closeTeleportTutorial" class="btn" type="button">GOT IT</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>‚ö° Aces of the Void ‚ö°</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>
    <audio id="audioCharge" src="charge.m4a" preload="auto"></audio>
    <audio id="audioBeefCharge" src="beefcharge.m4a" preload="auto"></audio>
    <audio id="audioEpicHorn" src="epichorntrimmed.m4a" preload="auto"></audio>
    <audio id="audioCluster" src="cluster.mp3" preload="auto"></audio>
    <audio id="audioThunder" src="thunder.mp3" preload="auto"></audio>
    <audio id="audioShaoKahn" src="shao_kahn.m4a" preload="auto"></audio>
    <audio id="audioStarGun" src="stargun.m4a" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">‚ö° MECH FORGE üí∞</button>
        <button id="menuBtn" class="fixed-btn" type="button">üèÜ TOP PILOTS</button>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

    <div id="joystick-container" class="mobile-control">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
    <div id="ability-button-container" class="mobile-control">
        <div id="ability-button">
            <div id="ability-icon"></div>
        </div>
    </div>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://endangered-ver-senate-require.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => {
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height),
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    
    // Simple resize handling without bounds caching
    window.addEventListener('resize', () => {
        // Mark joystick bounds for update too
        if (typeof joystickState !== 'undefined') {
            joystickState.boundsNeedUpdate = true;
        }
    }, { passive: true });
    
    const pointFromEvent = (e) => {
        const r = cvs.getBoundingClientRect();
        let touch = e;
        if (e.changedTouches && e.changedTouches.length > 0) {
            touch = e.changedTouches[0];
        } else if (e.touches && e.touches.length > 0) {
            touch = e.touches[0];
        }
        const cx = touch.clientX;
        const cy = touch.clientY;
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
    };

    // --- MOBILE JOYSTICK & ABILITY BUTTON SETUP ---
    const joystick = {
        base: q('joystick-base'),
        stick: q('joystick-stick'),
        container: q('joystick-container'),
        abilityButton: q('ability-button'),
        abilityIcon: q('ability-icon')
    };

    const joystickState = {
        active: false,
        touchId: null,
        baseRect: null,
        input: { x: 0, y: 0 }, // Normalized vector for player movement
        cachedBaseRect: null,
        boundsNeedUpdate: true
    };

    // Mobile device detection
    function isMobileDevice() {
        return window.innerWidth <= 768 || 
               'ontouchstart' in window || 
               navigator.maxTouchPoints > 0 || 
               /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    function setupMobileControls() {
        // Only set up joystick if elements exist
        if (joystick.base) {
            joystick.base.addEventListener('touchstart', handleJoystickStart, { passive: false });
            document.addEventListener('touchmove', handleJoystickMove, { passive: false });
            document.addEventListener('touchend', handleJoystickEnd, { passive: false });
            document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
        }

        // Only set up ability button if it exists
        if (joystick.abilityButton) {
            joystick.abilityButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (typeof handleAbilityPress === 'function') {
                    handleAbilityPress();
                }
            }, { passive: false });
        }

        // Load saved mobile controls preference
        try {
            if (localStorage.getItem('mobileControlsEnabled') === 'true') {
                document.body.classList.add('mobile-controls-active');
            }
        } catch(e) {
            // Ignore localStorage errors
        }
    }

    function handleJoystickStart(e) {
        e.preventDefault();
        if (joystickState.active) return;
        const touch = e.changedTouches[0];
        joystickState.active = true;
        joystickState.touchId = touch.identifier;
        
        // Cache joystick bounds to avoid layout calculations
        if (joystickState.boundsNeedUpdate || !joystickState.cachedBaseRect) {
            joystickState.cachedBaseRect = joystick.base.getBoundingClientRect();
            joystickState.boundsNeedUpdate = false;
        }
        joystickState.baseRect = joystickState.cachedBaseRect;
        
        handleJoystickMove(e); // Process initial position
    }

    function handleJoystickMove(e) {
        if (!joystickState.active) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
        if (!touch) return;

        const baseCenterX = joystickState.baseRect.left + joystickState.baseRect.width / 2;
        const baseCenterY = joystickState.baseRect.top + joystickState.baseRect.height / 2;
        
        let dx = touch.clientX - baseCenterX;
        let dy = touch.clientY - baseCenterY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const maxDist = joystickState.baseRect.width / 4; // Stick can move 1/4 of the base width from center

        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }

        joystick.stick.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickState.input.x = dx / maxDist;
        joystickState.input.y = dy / maxDist;
    }

    function handleJoystickEnd(e) {
        const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
        if (!touch) return;

        joystickState.active = false;
        joystickState.touchId = null;
        joystick.stick.style.transform = `translate(0, 0)`;
        joystickState.input = { x: 0, y: 0 };
    }

    function handleAbilityPress() {
        if (store.isPaused || store.isGameOver) return;
        const p = store.player;

        switch(p.pilotGenome) {
            case 'voidmancer':
                // Blink in the direction of joystick input, or straight ahead if idle
                const targetAngle = Math.atan2(joystickState.input.y, joystickState.input.x);
                const targetDist = 200; // Blink distance
                const target = {
                    x: p.x + (joystickState.input.x !== 0 ? Math.cos(targetAngle) * targetDist : 0),
                    y: p.y + (joystickState.input.y !== 0 ? Math.sin(targetAngle) * targetDist : p.y - targetDist)
                };
                tryVoidStep(p, target);
                break;
            case 'beef':
                // Manually trigger the charge ability
                p.isRequestingCharge = true; // A flag for the stepPlayer function
                break;
            default:
                // Default to grenade for other classes
                useGrenade();
                break;
        }
    }

    function updateAbilityButtonIcon() {
        const p = store.player;
        let iconUrl = '';

        // Determine icon based on class and subclass
        switch(p.pilotGenome) {
            case 'beef':
                iconUrl = p.subclass === 'marauder' ? 'marauder.png' : 'jug2.png';
                break;
            case 'voidmancer':
                iconUrl = p.subclass === 'phasestriker' ? 'phase.png' : 'storm.png';
                break;
            default:
                iconUrl = 'https://i.imgur.com/example.png'; // Placeholder for Grenade Icon
                break;
        }
        joystick.abilityIcon.style.backgroundImage = `url('${iconUrl}')`;
    }


    // --- NEW FLAME PARTICLE CLASS ---
class FlameParticle {
    constructor(x, y, attachedEnemy = null) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 40; // Less horizontal spread
        this.vy = -20 - Math.random() * 30; // Slower upward drift
        this.life = 8.4 + Math.random() * 5.6; // 40% longer: 8.4-14 seconds (was 6-10)
        this.maxLife = this.life;
        this.visualLife = this.life * 1.5; // Visual effect lasts 50% longer than mechanics
        this.maxVisualLife = this.visualLife;
        this.size = 8 + Math.random() * 8; // Smaller, more varied sizes
        this.attachedEnemy = attachedEnemy;
        this.damage = 0.45;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.5 + Math.random() * 1;
        this.heat = 0.8 + Math.random() * 0.2; // Start hot
        this.flickerOffset = Math.random() * 1000;
        this.baseSize = this.size;
        this.gravity = 15; // Slight downward pull for realistic behavior
        this.isDying = false;
    }

    update(dt) {
        this.life -= dt;
        this.visualLife -= dt;
        if (this.visualLife <= 0) return false; // Remove particle when visual effect ends

        // Physics - only apply when mechanically active
        if (this.life > 0) {
            this.vy += this.gravity * dt;
            this.vy -= 25 * dt;
            this.x += this.vx * dt;
            this.y += this.vy * dt;

            // Air resistance
            this.vx *= 0.98;
            this.vy *= 0.98;

            // Wobble
            this.wobble += this.wobbleSpeed * dt;
            this.x += Math.sin(this.wobble) * 8 * dt;
        }

        // Heat and void effect - based on VISUAL life for slower fade
        const visualLifeRatio = this.visualLife / this.maxVisualLife;
        this.heat = Math.max(0.2, visualLifeRatio * 0.8); // Minimum heat to avoid pure transparency

        // Size changes - based on visual life for slower shrinking
        if (visualLifeRatio > 0.7) {
            this.size = this.baseSize * (1 + (1 - visualLifeRatio) * 2); // Grow when young
        } else {
            this.size = Math.max(this.baseSize * 0.5, this.baseSize * visualLifeRatio); // Don't shrink below 50% of base
        }

        this.isDying = visualLifeRatio < 0.3;
        return true;
    }

    draw() {
        if (this.visualLife <= 0 || this.size <= 0) return;
        if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;

        const alpha = this.heat;
        
        // Simple flame with just 3 circles - no crackling, no sparkles
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Outer glow - simple and clean
    ctx.fillStyle = `rgba(255, 140, 20, ${alpha * 0.18})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 1.2, 0, 6.283185);
        ctx.fill();
        
        // Middle flame
    ctx.fillStyle = `rgba(255, 100, 30, ${alpha * 0.38})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.7, 0, 6.283185);
        ctx.fill();
        
        // Core flame
    ctx.fillStyle = `rgba(255, 215, 120, ${alpha * 0.55})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.3, 0, 6.283185);
        ctx.fill();
        
        ctx.restore(); // Reset blending mode
    }
}


    cvs.addEventListener('mousemove', (e) => { 
        try { 
            const p = pointFromEvent(e); 
            mouse.x = p.x; 
            mouse.y = p.y; 
        } catch(err) { 
            console.error('Mouse move error:', err); 
        }
    }, { passive: true });
    cvs.addEventListener('touchstart', (e) => { 
        try { 
            const p = pointFromEvent(e); 
            mouse.x = p.x; 
            mouse.y = p.y; 
            e.preventDefault(); 
        } catch(err) { 
            console.error('Touch start error:', err); 
        }
    }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { 
        try { 
            const p = pointFromEvent(e); 
            mouse.x = p.x; 
            mouse.y = p.y; 
            e.preventDefault(); 
        } catch(err) { 
            console.error('Touch move error:', err); 
        }
    }, { passive: false });
    
    // --- AUDIO ---
    const bgm = q('bgmAudio');
    const sounds = {
        explosion: q('audioExplosion'),
        horn: q('audioHorn'),
        hit: q('audioHit'),
        trap: q('audioTrap'),
        dogs: q('audioDogs'),
        charge: q('audioCharge'),
        beefCharge: q('audioBeefCharge'),
        epicHorn: q('audioEpicHorn'),
        cluster: q('audioCluster'),
        thunder: q('audioThunder'),
        shao_kahn: q('audioShaoKahn'),
        stargun: q('audioStarGun')
    };
    let lastExplosionSoundTime = 0;
    let lastBossHitSoundTime = 0;
    let lastClusterSoundTime = 0;
    
    function playSound(name) {
        const audio = sounds[name];
        if (!audio) return;
        const now = performance.now();
        if (name === 'explosion') {
            if (now - lastExplosionSoundTime < 50) return;
            lastExplosionSoundTime = now;
        }
        if (name === 'cluster') {
            if (now - lastClusterSoundTime < 150) return; // Increased from 60ms to 150ms
            lastClusterSoundTime = now;
        }
        if (name === 'hit') {
            if (now - lastBossHitSoundTime < 100) return;
            lastBossHitSoundTime = now;
        }
        audio.currentTime = 0;
        audio.play().catch(e => {});
    }


    // --- GAME STATE & DATA ---
    const player_initial_state = {
        x: W / 2, y: H * 0.8, r: 14, hp: 50, hpMax: 50, fireT: 0, speed: 380, dmgMult: 1.2, fireRate: 0.16,
        vampirism: 0, shield: 50, shieldMax: 50, multishot: 2, isInvincible: false, piercing: 0, explosive: false,
        hasShieldBubble: false, powerupTimers: {},
    upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0, launcher: 0, lazarus_beam: 0, gravity_well: 0, star_cannon: 0 },
        grenades: 0, hasVoidBeam: false, voidBeamCooldown: 0,
        hasLazarusBeam: false, lazarusBeamCooldown: 0,
        hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 0, vampirismLevel: 0, flamethrowerLevel: 0,
        flamethrowerT: 0, // Separate timer for lava chunks, unaffected by overclock
    starCannonLevel: 0, starCannonTimer: 0, starCannonIcemanSupport: false,
        luckBoost: 0, magnetRadius: 0, hasIceman: false, critChance: 0.02, critDamage: 1.85,
        pilotGenome: null, missileVolley: 2,
        hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
        rearMultishot: 0, addFrontNext: true,
        flameWallCooldown: 0,
        flameWallActiveT: 0,
        beefChargeState: 'ready', beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 1, beefMaxCharges: 1,
        beefDoubleCharge: false, beefBigExplosion: false, // New skill tree abilities
        beefChainTargets: [], beefChainIndex: 0, beefChainMode: false, // Chain jumping system for marauder
        hasChainLightning: false, chainLightningCooldown: 0, stormstrikerLevel: 0, lightningAlternate: false, lightningCycleIndex: 0, chainLightningDamage: 1.0,
        phasestRikerLevel: 0, voidLaserRampTime: 0, voidLaserLastTarget: null,
        subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false,
        enhancedClusters: false, enhancedPierce: false, hasStormcaller: false, hasPhasestriker: false,
        // Void caller enhanced options
        hasDoubleStorm: false, hasHybridVoid: false, hasImpactPhase: false,
        // Skill tree progress
        skillPoints: 0, skillPointsSpent: 0, skillTree: { juggernaut: false, marauder: false, double_charge: false, big_explosion: false, triple_charge: false },
        clusterSoundCounter: 0,
        // EMP nova effects
        empDisabled: false, empDisabledTimer: 0
    };
    
    class Pool {
        constructor(createFn, resetFn) {
            this.createFn = createFn;
            this.resetFn = resetFn;
            this.available = [];
        }

        prefill(count) {
            for (let i = 0; i < count; i++) {
                this.available.push(this.createFn());
            }
        }

        get() {
            const item = this.available.pop() || this.createFn();
            if (this.resetFn) this.resetFn(item);
            return item;
        }

        release(item) {
            if (this.resetFn) this.resetFn(item);
            this.available.push(item);
        }
    }

    function resetBulletState(bullet) {
        bullet.x = 0;
        bullet.y = 0;
        bullet.vx = 0;
        bullet.vy = 0;
        bullet.r = 3;
        bullet.col = "#b266ff";
        bullet.dmg = 0;
        bullet.pierce = 0;
        bullet.explosive = false;
        bullet.dead = false;
        bullet.life = undefined;
        bullet.fadeInTime = undefined;
        bullet.spawnTime = undefined;
        bullet.isSwirl = false;
        bullet.isFlame = false;
        bullet.isIceman = false;
        bullet.isDrone = false;
        bullet.isLavaChunk = false;
        bullet.isLevelUpPulse = false;
        bullet.gravity = undefined;
        bullet.target = undefined;
        bullet.particles = null;
        bullet.particleSpawnT = 0;
    }

    function createBullet() {
        const bullet = {};
        resetBulletState(bullet);
        return bullet;
    }

    const bulletPool = new Pool(createBullet, resetBulletState);
    bulletPool.prefill(100);

    const STAR_CANNON_COOLDOWN = 7;
    const STAR_CANNON_SPEED = 420;
    const STAR_CANNON_DAMAGE = 220;
    const STAR_CANNON_SIZE = 20;
    const STAR_CANNON_HITBOX_SCALE = 1.0;
    const STAR_CANNON_CLONE_DELAY = 0.35;
    const STAR_CANNON_ICEMAN_DAMAGE_SCALE = 0.3;

    const initialTelemetryEnabled = (() => {
        try {
            return !!(window.localStorage && window.localStorage.getItem('voidTelemetry') === '1');
        } catch (err) {
            return false;
        }
    })();

    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        isDamageOff: false,
        savedPlayerState: null,
        world: { 
            wave: 1, 
            score: 0, 
            gold: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0,
            waveTransitionTimer: null, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0,
            collarTargetStacks: 0,
            collarTargetStacks: 0,
            lateGameDamageScaling: 1,
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            isLowHealth: false,
            lastThreatScale: 1,
            lastSpawnOverflow: 0,
            lastPlannedSpawnCount: 0,
            lastSpawnCount: 0,
            lastSpawnFallback: false,
            lastSpawnQueueLength: 0,
            lastSpawnTempo: 0,
            firstBossOrbsGifted: false
        },
        player: { ...player_initial_state },
    boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], missiles: [], lasers: [], mines: [], activeEffects: [], starProjectiles: [], pendingStarClones: [],
        flameParticles: [],
        lightningBolts: [],
        empNovas: [],
        mechPuddles: [], // Hazardous puddles left by mech tank attacks
        poisonPuddles: [],
        goldenOrbs: [],
        _enemySpatial: {
            cellSize: 160,
            buckets: new Map(),
            usedKeys: []
        },
            iceman: null,
        waveSpawnQueue: [],
            pendingSpawnCount: 0,
        vulnerabilityEvents: [],
    // Object pools for performance optimization
    bulletPool: null,
        eBulletPool: [],
        effectPool: [],
        tempFlamePool: [], // For simple flame particles
        _startTs: performance.now(),
        cheatInvincibilityCooldown: 0,
        cheatDogHealCooldown: 0,
        heartbeatT: 0,
        cheatsUsed: false,
        telemetryEnabled: initialTelemetryEnabled
    };

    // --- OBJECT POOLING SYSTEM ---
    store.bulletPool = bulletPool;

    function spawnBullet(props = {}) {
        const bullet = bulletPool.get();
        Object.assign(bullet, props);
        bullet.dead = false;
        if (bullet.isFlame && !Array.isArray(bullet.particles)) {
            bullet.particles = [];
        }
        store.bullets.push(bullet);
        return bullet;
    }

    function getEBulletFromPool(props = {}) {
        let bullet;
        if (store.eBulletPool.length > 0) {
            bullet = store.eBulletPool.pop();
            // Reset all properties to default
            Object.assign(bullet, {
                x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                dmg: 0, dead: false, life: undefined,
                fadeInTime: undefined, spawnTime: undefined,
                bounceCount: 0, maxBounces: 0, type: undefined
            });
        } else {
            bullet = {
                x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                dmg: 0, dead: false
            };
        }
        
        // Apply custom properties
        Object.assign(bullet, props);
        return bullet;
    }
    
    function returnEBulletToPool(bullet) {
        if (store.eBulletPool.length < 1000) { // Cap pool size
            store.eBulletPool.push(bullet);
        }
    }

    // PERFORMANCE: Effect pooling for createEffect() calls
    function getEffectFromPool(type, x, y, extra) {
        let effect;
        if (store.effectPool.length > 0) {
            effect = store.effectPool.pop();
            effect.type = type;
            effect.x = x;
            effect.y = y;
            effect.extra = extra;
            effect.isActive = true;
            effect.dead = false;
            effect.birth = performance.now();
        } else {
            effect = createEffect(type, x, y, extra);
        }
        return effect;
    }

    function returnEffectToPool(effect) {
        if (store.effectPool.length < 50) { // Limit pool size
            effect.isActive = false;
            effect.dead = true;
            store.effectPool.push(effect);
        }
    }

    // PERFORMANCE: Simple flame particle pooling
    function getTempFlameFromPool() {
        if (store.tempFlamePool.length > 0) {
            return store.tempFlamePool.pop();
        }
        return {
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, dead: false
        };
    }

    function returnTempFlameToPool(flame) {
        if (store.tempFlamePool.length < 100) {
            flame.dead = true;
            store.tempFlamePool.push(flame);
        }
    }

    const ENEMY_SPATIAL_KEY_MASK = 0xffff;

    function computeEnemySpatialKey(cellX, cellY) {
        return ((cellX & ENEMY_SPATIAL_KEY_MASK) << 16) | (cellY & ENEMY_SPATIAL_KEY_MASK);
    }

    function rebuildEnemySpatialIndex() {
        const spatial = store._enemySpatial;
        if (!spatial) return;

        const { buckets, usedKeys, cellSize } = spatial;

        for (let i = 0; i < usedKeys.length; i++) {
            const key = usedKeys[i];
            const bucket = buckets.get(key);
            if (bucket) {
                bucket.length = 0;
            }
        }
        usedKeys.length = 0;

        const enemies = store.enemies;
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            if (!enemy || enemy.dead) continue;
            const cellX = Math.floor(enemy.x / cellSize);
            const cellY = Math.floor(enemy.y / cellSize);
            const key = computeEnemySpatialKey(cellX, cellY);
            let bucket = buckets.get(key);
            if (!bucket) {
                bucket = [];
                buckets.set(key, bucket);
            }
            bucket.push(enemy);
            if (bucket.length === 1) {
                usedKeys.push(key);
            }
        }
    }

    function forEachEnemyNearby(x, y, radius, iterator) {
        const spatial = store._enemySpatial;
        if (!spatial) return;

        const { buckets, cellSize } = spatial;
        const minCellX = Math.floor((x - radius) / cellSize);
        const maxCellX = Math.floor((x + radius) / cellSize);
        const minCellY = Math.floor((y - radius) / cellSize);
        const maxCellY = Math.floor((y + radius) / cellSize);

        for (let cellX = minCellX; cellX <= maxCellX; cellX++) {
            for (let cellY = minCellY; cellY <= maxCellY; cellY++) {
                const key = computeEnemySpatialKey(cellX, cellY);
                const bucket = buckets.get(key);
                if (!bucket || bucket.length === 0) continue;
                for (let i = 0; i < bucket.length; i++) {
                    const enemy = bucket[i];
                    if (!enemy || enemy.dead) continue;
                    if (iterator(enemy) === true) {
                        return;
                    }
                }
            }
        }
    }

    function getBulletSearchRadius(bullet) {
        if (bullet.collisionSearchRadius != null) {
            return bullet.collisionSearchRadius;
        }

        let radius = 140;
        if (bullet.r) radius += bullet.r;
        if (bullet.explosive) radius = Math.max(radius, 230);
        if (bullet.isLevelUpPulse) radius = Math.max(radius, 260);
        if (bullet.isFlame) radius = Math.max(radius, 220);
        if (bullet.isDrone) radius = Math.max(radius, 200);

        return Math.max(120, Math.min(radius, 320));
    }

    function handleBulletImpact(b, e) {
        if (b.isFlame) e.slowTimer = 1.0;

        if (e.isHeatDeath) {
            b.dead = true;
            return;
        }

        if (e === store.boss && e.isInvincible) {
            b.dead = true;
            return;
        }

        let dmg = b.dmg || 15;
        let didCrit = false;
        if (e === store.boss && b.isDrone) dmg *= 0.4;

        if (Math.random() < store.player.critChance) {
            dmg *= store.player.critDamage;
            didCrit = true;
            store.activeEffects.push(createEffect('critText', e.x, e.y));
            if (Math.random() < 0.05) spawnPowerup(e.x, e.y);
        }

        if (e === store.boss) playSound('hit');
        const subclass = store.player.subclass;
        let bulletTags;
        switch (subclass) {
            case 'juggernaut':
                bulletTags = ['fire', 'explosive'];
                break;
            case 'marauder':
                bulletTags = ['kinetic', 'concussive'];
                break;
            case 'railgunner':
                bulletTags = ['kinetic', 'explosive'];
                break;
            case 'demolitionist':
                bulletTags = ['fire', 'explosive'];
                break;
            case 'phasestriker':
                bulletTags = ['void', 'magic'];
                break;
            case 'stormcaller':
                bulletTags = ['lightning', 'magic'];
                break;
            default:
                bulletTags = b.explosive ? ['fire', 'explosive'] : ['kinetic'];
        }
        const vulnBullet = applySubclassVulnerability(e, dmg, {
            subclass,
            player: store.player,
            damageTags: bulletTags,
            source: b.explosive ? 'explosiveBullet' : 'bullet',
            projectile: b,
            baseDamage: dmg
        });
        dmg = vulnBullet.damage;
        e.hp -= dmg;

        const impactAngle = Math.atan2(e.y - b.y, e.x - b.x);
        registerEnemyHit(e, {
            angle: impactAngle,
            knockbackStrength: 0,
            shakeIntensity: b.explosive ? 6 : 3.5,
            shakeDuration: b.explosive ? 0.22 : 0.14,
            slowFactor: b.explosive ? 0.8 : 0.9,
            slowDuration: b.explosive ? 0.22 : 0.12,
            crit: didCrit,
            effect: false
        });

        if (store.player.pilotGenome === 'beef') {
            store.player.beefShieldDamageDealt += dmg;
        }

        if (store.player.vampirism > 0) {
            let healAmount = dmg * store.player.vampirism;
            healAmount = Math.max(healAmount, 1);
            healAmount = Math.min(healAmount, 5);
            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
        }

        if (e.hp <= 0) {
            e.dead = true;
            if (e.type === 'void_champion') {
                store.enemies.forEach(minion => {
                    if (minion.orbitTargetId === e.id && !minion.dead) {
                        spawnGibs(minion.x, minion.y, minion.color);
                        minion.dead = true;
                    }
                });
                spawnVoidCoreDrop(e.x, e.y - 10);
            }

            if (e === store.boss) {
                handleBossDefeat();
            } else {
                spawnGibs(e.x, e.y, e.color);
                const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                store.world.score += Math.floor(e.score * collarBonus);
                store.world.gold += Math.floor(e.gold * collarBonus);
                store.world.xp += Math.floor(e.xp * collarBonus);
                store.world.kills++;

                spawnPowerup(e.x, e.y);
                explode(e.x, e.y);
            }
        }

        if (b.explosive) explode(b.x, b.y, false, true);
        if (!b.pierce) b.dead = true;
    }

    const CLASS_DAMAGE_TAGS = {
        juggernaut: ['fire', 'explosive'],
        marauder: ['kinetic', 'concussive'],
        railgunner: ['kinetic', 'explosive'],
        demolitionist: ['fire', 'explosive'],
        phasestriker: ['void', 'magic'],
        stormcaller: ['lightning', 'magic']
    };

    const MARAUDER_VULNERABILITY_ALLOWED_SOURCES = new Set([
        'beefCharge',
        'beefChargeCombo',
        'missileImpact',
        'pierceMissile',
        'clusterMissile',
        'clusterDetonation',
        'voidLaser',
        'chainLightning'
    ]);

    function triggerJuggernautVulnerability(enemy, context) {
        enemy.jugFearTimer = Math.max(enemy.jugFearTimer || 0, 2.6);
        enemy.jugBurnTimer = Math.max(enemy.jugBurnTimer || 0, 3.5);
        enemy.jugBurnTick = 0;
        enemy.jugPulseTimer = Math.max(enemy.jugPulseTimer || 0, 3.0);
        enemy.jugPulsePhase = enemy.jugPulsePhase || 0;
        enemy.vulnerabilityPulseColor = '#ff3b3b';
        enemy.vulnerabilityPulseStrength = 1;
        store.activeEffects.push(createEffect('jugFearIgnite', enemy.x, enemy.y, enemy.r * 1.1));
    }

    function triggerMarauderVulnerability(enemy, context) {
        const angle = context.knockbackAngle ?? Math.atan2(enemy.y - store.player.y, enemy.x - store.player.x);
        const smashSpeed = 1100;
        const smashDuration = 0.55;
        enemy.knockback = {
            vx: Math.cos(angle) * smashSpeed,
            vy: Math.sin(angle) * smashSpeed,
            duration: smashDuration,
            type: 'maraLaunch'
        };
        enemy.maraLaunchTimer = smashDuration;
        enemy.maraImpactTriggered = false;
        enemy.vulnerabilityPulseColor = '#aad1ff';
        enemy.vulnerabilityPulseStrength = 0.8;
    store.activeEffects.push(createEffect('marauderLaunchTrail', enemy.x, enemy.y, { duration: smashDuration, enemy }));
    }

    function triggerRailgunnerVulnerability(enemy) {
        enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 4.0);
        enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 1, 3);
        enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.35);
        enemy.vulnerabilityPulseColor = '#d7f0ff';
        enemy.vulnerabilityPulseStrength = 0.6;
        store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, enemy.railgunCrackLevel));
    }

    function triggerDemolitionistVulnerability(enemy, context) {
        const fallbackPos = { x: enemy.x, y: enemy.y };
        const sourcePlayer = context.player || store.player;
        scheduleVulnerabilityEvent(0.7, () => {
            const ref = enemy.dead ? fallbackPos : { x: enemy.x, y: enemy.y };
            spawnFlamePulse(ref.x, ref.y, 95, context.baseDamage * 0.8, { player: sourcePlayer });
        });
        enemy.demolitionPulseWarmup = Math.max(enemy.demolitionPulseWarmup || 0, 0.7);
        enemy.vulnerabilityPulseColor = '#ffae5b';
        enemy.vulnerabilityPulseStrength = 0.7;
        store.activeEffects.push(createEffect('demolitionPulseCharge', enemy.x, enemy.y, enemy.r * 1.4));
    }

    function triggerPhaseStrikerVulnerability(enemy) {
        enemy.phaseLockTimer = Math.max(enemy.phaseLockTimer || 0, 2.4);
        enemy.phaseLockSlowFactor = 0.35;
        enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.5);
        enemy.vulnerabilityPulseColor = '#8f6bff';
        enemy.vulnerabilityPulseStrength = 0.9;
        store.activeEffects.push(createEffect('voidLockChains', enemy.x, enemy.y, enemy.r * 1.2));
    }

    function triggerStormcallerVulnerability(enemy, context) {
        enemy.stormShockTimer = Math.max(enemy.stormShockTimer || 0, 2.2);
        enemy.stormShockIntensity = 1;
        enemy.vulnerabilityPulseColor = '#6fd2ff';
        enemy.vulnerabilityPulseStrength = 1;
        store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, enemy.r * 1.5));
        const targets = store.enemies.filter(en => !en.dead && en !== enemy);
        const arcTargets = targets.sort((a, b) => ((a.x - enemy.x) ** 2 + (a.y - enemy.y) ** 2) - ((b.x - enemy.x) ** 2 + (b.y - enemy.y) ** 2)).slice(0, 3);
        arcTargets.forEach(target => {
            store.activeEffects.push(createEffect('stormArc', enemy.x, enemy.y, { x: target.x, y: target.y }));
            target.stunTimer = Math.max(target.stunTimer || 0, 0.3);
        });
    }

    const ENEMY_VULNERABILITIES = {
        mech: {
            juggernaut: {
                multiplier: 1.6,
                damageTags: ['fire', 'explosive'],
                cooldownMs: 500,
                onTrigger: triggerJuggernautVulnerability
            }
        },
        manta: {
            marauder: {
                multiplier: 1.45,
                damageTags: ['kinetic', 'concussive'],
                cooldownMs: 400,
                onTrigger: triggerMarauderVulnerability
            }
        },
        phantom: {
            railgunner: {
                multiplier: 1.4,
                damageTags: ['kinetic', 'explosive'],
                cooldownMs: 350,
                onTrigger: triggerRailgunnerVulnerability
            }
        },
        void_champion_orb: {
            demolitionist: {
                multiplier: 1.35,
                damageTags: ['fire', 'explosive'],
                cooldownMs: 650,
                onTrigger: triggerDemolitionistVulnerability
            }
        },
        void_champion: {
            phasestriker: {
                multiplier: 1.5,
                damageTags: ['void', 'magic'],
                cooldownMs: 500,
                onTrigger: triggerPhaseStrikerVulnerability
            }
        },
        angler: {
            stormcaller: {
                multiplier: 1.4,
                damageTags: ['lightning', 'magic'],
                cooldownMs: 450,
                onTrigger: triggerStormcallerVulnerability
            }
        }
    };

    function scheduleVulnerabilityEvent(delay, action) {
        store.vulnerabilityEvents.push({ timer: delay, action });
    }

    function processVulnerabilityEvents(dt) {
        for (let i = store.vulnerabilityEvents.length - 1; i >= 0; i--) {
            const evt = store.vulnerabilityEvents[i];
            evt.timer -= dt;
            if (evt.timer <= 0) {
                try {
                    evt.action?.();
                } catch (err) {
                    console.warn('Vulnerability event error', err);
                }
                store.vulnerabilityEvents.splice(i, 1);
            }
        }
    }

    function spawnFlamePulse(x, y, radius = 90, damage = 40, context = {}) {
        store.activeEffects.push(createEffect('delayedFlamePulse', x, y, radius));
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(enemy => {
            if (!enemy || enemy.dead) return;
            const distSq = (enemy.x - x) * (enemy.x - x) + (enemy.y - y) * (enemy.y - y);
            if (distSq <= radius * radius) {
                let dmg = damage;
                if (enemy === store.boss) dmg *= 0.35;
                const result = applySubclassVulnerability(enemy, dmg, {
                    subclass: 'demolitionist',
                    damageTags: ['fire', 'explosive'],
                    player: context.player,
                    source: 'demolitionPulse',
                    disableVulnerability: true
                });
                enemy.hp -= result.damage;
                for (let i = 0; i < 4; i++) {
                    store.flameParticles.push(new FlameParticle(
                        x + (Math.random() - 0.5) * radius * 0.6,
                        y + (Math.random() - 0.5) * radius * 0.6
                    ));
                }
            }
        });
    }

    function applySubclassVulnerability(enemy, baseDamage, context = {}) {
        if (context.disableVulnerability) {
            return { damage: baseDamage, triggered: false };
        }

        const player = context.player || store.player;
        if (!player) {
            return { damage: baseDamage, triggered: false };
        }

        const subclass = context.subclass || player.subclass;
        if (!subclass) {
            return { damage: baseDamage, triggered: false };
        }

        const config = ENEMY_VULNERABILITIES[enemy.type];
        const subclassConfig = config && config[subclass];
        if (!subclassConfig) {
            return { damage: baseDamage, triggered: false };
        }

        const appliedTags = context.damageTags || CLASS_DAMAGE_TAGS[subclass] || [];
        const matchesTag = appliedTags.some(tag => subclassConfig.damageTags.includes(tag));
        if (!matchesTag) {
            return { damage: baseDamage, triggered: false };
        }

        const allowTriggerOverride = context.allowVulnerabilityTrigger;
        let allowTrigger = allowTriggerOverride !== undefined ? !!allowTriggerOverride : true;
        if (allowTrigger && subclass === 'marauder') {
            const source = context.source;
            if (!MARAUDER_VULNERABILITY_ALLOWED_SOURCES.has(source) && !context.forceVulnerabilityTrigger) {
                allowTrigger = false;
            }
        }

        enemy._lastVulnerabilityTrigger = enemy._lastVulnerabilityTrigger || {};
        const now = performance.now();
        const cooldown = subclassConfig.cooldownMs ?? 350;
        const lastTrigger = enemy._lastVulnerabilityTrigger[subclass] || 0;
        let triggered = false;
        if (allowTrigger && now - lastTrigger >= cooldown) {
            enemy._lastVulnerabilityTrigger[subclass] = now;
            triggered = true;
            if (subclassConfig.onTrigger) {
                subclassConfig.onTrigger(enemy, { ...context, baseDamage, player });
            }
        }

        const damage = baseDamage * (subclassConfig.multiplier || 1);
        return { damage, triggered };
    }

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', icon: 'üí•', desc: '+6% damage', apply: () => { store.player.dmgMult *= 1.06; } },
        { id: 'fire', name: 'OVERCLOCK', icon: 'üî•', desc: '+6% fire rate', apply: () => { store.player.fireRate *= 0.60; } },
        { id: 'multi', name: 'SCATTER PROTOCOL', icon: '‚òÑÔ∏è', desc: '+1 projectile', apply: () => {
            const p = store.player;
            if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
        }},
        { id: 'shield', name: 'VOID SHIELD', icon: 'üõ°Ô∏è', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'flamethrower', name: 'LAVA CHUNKS', icon: 'üåã', desc: 'Spews chunks of molten rock in a cone.', apply: () => { store.player.flamethrowerLevel++; } }
    ];
    
    const SHOP_UPGRADES = {
        'repair': { name: "NANO REPAIR", icon: 'üîß', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'vampirism': {
            name: "VAMPIRIC ROUNDS", icon: 'ü©∏', isPremium: true, max: 4, category: 'utility',
            apply: () => {
                const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                if (store.world.gold >= cost && p.vampirismLevel < 4) { store.world.gold -= cost; p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
            },
            desc: () => {
                const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
            }
        },
        'hp': { 
            name: "MAX HP", 
            icon: '‚ù§Ô∏è', 
            baseCost: 40, 
            scale: 1.4, 
            maxLevel: 20, 
            category: 'health', 
            effect: (level) => { 
                const p = store.player;
                // Scale HP upgrades with current wave for late game viability
                let hpIncrease = 10;
                if (store.world.wave > 20) {
                    // After wave 20, HP upgrades scale with wave
                    hpIncrease = 10 + (store.world.wave - 20) * 2;
                }
                p.hpMax += hpIncrease; 
                p.hp += hpIncrease;
                // console.log(`HP upgrade: +${hpIncrease} HP (wave ${store.world.wave})`);
            }, 
            desc: level => {
                let hpIncrease = 10;
                if (store.world.wave > 20) {
                    hpIncrease = 10 + (store.world.wave - 20) * 2;
                }
                return `+${hpIncrease} Max HP (Lvl ${level + 1})`;
            }
        },
        'nano_save': { name: "NANO SAVE", icon: 'üíæ', cost: 25, isPremium: true, max: 3, category: 'utility', apply: () => { if (store.player.nanoSaves < 3) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Auto-heals on low HP. Charges: ${store.player.nanoSaves}/3` },
        'luck_boost': { name: "LUCK BOOST", icon: 'üçÄ', baseCost: 50, scale: 2, maxLevel: 5, category: 'utility', effect: (level) => { store.player.luckBoost = (store.player.luckBoost || 0) + (0.15 / Math.pow(2, level)); }, desc: level => `+${(0.15 / Math.pow(2, level) * 100).toFixed(1)}% drop chance (Lvl ${level + 1})` },
        'dmg': { name: "DAMAGE", icon: 'üí™', baseCost: 50, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.06, desc: level => `+6% Damage (Lvl ${level + 1})` },
        'crit_chance': { name: "SHINOBI REFLEXES", icon: 'ü•∑', baseCost: 40, increment: 24, maxLevel: 10, category: 'attack', effect: () => { store.player.critChance *= 1.5; store.player.critDamage *= 1.5; }, desc: level => `+50% Crit Chance & Dmg (Lvl ${level + 1})` },
        'speed': { name: "SPEED", icon: 'üöÄ', baseCost: 60, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
        'grenade': { name: "NOVA GRENADE", icon: 'üí•üí£üí•', cost: 70, isPremium: true, max: 3, category: 'attack', apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'max_shield': { 
            name: "MAX SHIELD", 
            icon: 'üõ°Ô∏è', 
            baseCost: 80, 
            scale: 1.8, 
            maxLevel: 20, // Increased max level
            category: 'health', 
            effect: (level) => { 
                const p = store.player;
                if (level < 5) {
                    // First 5 levels: +25 flat shield
                    p.shieldMax += 25; 
                    p.shield += 25;
                } else {
                    // Levels 6+: +25% of current max shield
                    const increase = Math.floor(p.shieldMax * 0.25);
                    p.shieldMax += increase;
                    p.shield += increase;
                }
            }, 
            desc: level => {
                if (level < 5) {
                    return `+25 Max Shield (Lvl ${level + 1})`;
                } else {
                    return `+25% Max Shield (Lvl ${level + 1})`;
                }
            }
        },
        'rear_guard': { name: 'AFT FLANKSHIELD', icon: 'üõ°Ô∏è‚ú®', baseCost: 130, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
        'launcher': {
                name: 'FRAG LAUNCHER',
                icon: 'üí•',
                baseCost: 100,
                scale: 2,
                maxLevel: 3,
                category: 'attack',
                effect: () => {
                    store.player.hasLauncher = true;
                },
                desc: level => {
                    if (level === 0) return `Unlocks launcher (2 projectiles).`;
                    if (level === 1) return `Add 2 projectiles (4 total).`;
                    if (level === 2) return `Add 2 more projectiles (6 total).`;
                    return "Max projectiles reached.";
                }
            },
        'star_cannon': {
            name: 'STAR CANNON',
            icon: 'üå†',
            baseCost: 180,
            scale: 2.2,
            maxLevel: 3,
            category: 'attack',
            effect: level => {
                const p = store.player;
                if (level === 0) {
                    p.starCannonLevel = 1;
                    p.starCannonTimer = 0;
                    announce('STAR CANNON ONLINE!');
                } else if (level === 1) {
                    p.starCannonLevel = 2;
                    p.starCannonTimer = Math.min(p.starCannonTimer, 0);
                    announce('STAR CANNON MKII - DUAL ARTILLERY!');
                } else if (level === 2) {
                    p.starCannonLevel = Math.max(p.starCannonLevel, 2);
                    p.starCannonIcemanSupport = true;
                    announce('STAR CANNON MKIII - BLIZZARD SYNC!');
                }
            },
            desc: level => {
                if (level === 0) return 'Left-side artillery star cannon (7s reload).';
                if (level === 1) return 'Add right-side cannon for twin strikes.';
                if (level === 2) return 'Iceman mirrors your salvo with frosty stars.';
                return 'Max Level';
            }
        },
        'iceman': { name: "THE ICEMAN", icon: '‚ùÑÔ∏è', cost: 118, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.hasIceman) { store.player.hasIceman = true; store.iceman = { x: store.player.x, y: store.player.y + 50, t: 0 }; return true; } return false; }, desc: () => `A clone mirrors your attacks.` },
        'lazarus_beam': { name: "LORD LAZARUS", icon: '‚ò¢Ô∏è‚òÑÔ∏è‚ò¢Ô∏è', baseCost: 200, scale: 3, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Lazarus smites foes twice as often.'; if (level === 1) return 'Lazarus fires two beams at once.'; return 'Max Level'; }},
        'magnet_pull': { name: "GRAV-PULSE", icon: 'üß≤', cost: 90, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
        'gravity_well': { name: "GRAVITY WELL", icon: 'üï≥Ô∏è', baseCost: 300, scale: 2, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; }}, desc: level => { if (level === 0) return 'Unleash a singularity that traps and crushes foes.'; if (level === 1) return 'Summon a second, smaller singularity.'; return 'Max Level'; }},
        'ghost_hounds': { name: "GHOST HOUNDS", icon: 'üëªüê∫', baseCost: 150, scale: 2, maxLevel: 2, category: 'attack', effect: () => { if (!store.player.hasHounds) { store.player.hasHounds = true; store.hounds = [createHound(-1), createHound(1)]; } else { store.hounds.push(createHound(-2)); store.hounds.push(createHound(2)); } playSound('dogs'); }, desc: level => { if (level === 0) return `Unlocks 2 spectral hounds.`; if (level === 1) return `Add 2 more hounds.`; return "Max hounds reached."; } }
    };
    
    const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: '‚¨ÜÔ∏è', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'üöÅ', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'üõ°Ô∏è', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: '‚ù§Ô∏è', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'üöÄ', duration: 20, type: 'timed' },
        'void_core': { name: 'VOID CORE', icon: 'üåÄ', duration: 25, type: 'timed' }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) {
        if (store.world.powerupCooldown > 0) return;
        const p = store.player;
        const baseChance = 0.075;
        const wave = store.world.wave;
        const waveReductionFactor = 0.0025;
        let finalChance = Math.max(0.025, baseChance - (wave - 1) * waveReductionFactor);
    let types = Object.keys(POWERUP_TYPES).filter(key => key !== 'void_core');
        let bonusType = null;
        if (p.pilotGenome === 'beef') {
            // Enhanced drop rates for beef - additional powerups, not replacing existing ones
            if (Math.random() < 0.4) bonusType = 'shield'; // Increased from 0.25 to 0.4
            else if (Math.random() < 0.3) bonusType = 'repair'; // Increased from 0.15 to 0.3
            // Also boost the base chance for beef pilots
            finalChance *= 1.3; // 30% higher overall powerup drop rate
        }
        if (p.pilotGenome === 'rocketman') {
            // Significantly boost missile powerup rates for rocketman
            if (Math.random() < 0.5) bonusType = 'missile'; // 50% chance for missile powerups
            finalChance *= 2.0; // Double overall powerup drop rate
            // Extra chance if rocketman doesn't currently have missiles active
            if (!p.powerupTimers.missile || p.powerupTimers.missile.remaining <= 3) {
                if (Math.random() < 0.3) bonusType = 'missile'; // Extra 30% chance when missiles are low/inactive
            }
        }
        const roll = Math.random();
        if (roll > finalChance && !bonusType) return;
        let typeKey;
        if (bonusType && (roll <= finalChance || Math.random() < 0.5)) {
            typeKey = bonusType;
        } else {
            typeKey = types[Math.floor(Math.random() * types.length)];
        }
        store.powerups.push({ x, y, r: 12, type: typeKey });
        store.world.powerupCooldown = 5;
    }

    function spawnVoidCoreDrop(x, y) {
        if (!store.powerups) store.powerups = [];
        store.powerups.push({ x, y, r: 14, type: 'void_core' });
    }
    
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
        if (typeKey === 'missile') {
            if (p.pilotGenome === 'rocketman') { p.missileVolley = Math.min(5, p.missileVolley + 2); } else { p.missileVolley = 2; }
        }
        if (typeKey === 'void_core') {
            const timer = p.powerupTimers[typeKey];
            const prevStacks = timer ? (timer.stacks || 0) : 0;
            const newStacks = Math.min(3, prevStacks + 1);
            const prevDmgMult = p.voidCoreDmgMult || 1;
            const prevFireRateMult = p.voidCoreFireRateMult || 1;
            const newDmgMult = 1 + newStacks * 0.3;
            const newFireRateMult = 1 + newStacks * 0.2;

            p.dmgMult = (p.dmgMult / prevDmgMult) * newDmgMult;
            p.fireRate = (p.fireRate * prevFireRateMult) / newFireRateMult;
            p.fireRate = Math.max(p.fireRate, 0.05);

            p.voidCoreStacks = newStacks;
            p.voidCoreDmgMult = newDmgMult;
            p.voidCoreFireRateMult = newFireRateMult;

            if (timer) {
                timer.remaining = powerup.duration;
                timer.max = powerup.duration;
                timer.stacks = newStacks;
            } else {
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration, stacks: newStacks };
            }

            announce(`VOID CORE RESONANCE x${newStacks}`);
            announce(powerup.name);
            return;
        }
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
            else {
                if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') {
                const p = store.player;
                if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                announce('SCATTER SHOT!');
            }
        }
        announce(powerup.name);
    }

    function sanitizeCollarStacks() {
        if (!Number.isFinite(store.world.collarStacks)) {
            console.warn('Invalid collar stack value detected, resetting.', store.world.collarStacks);
            store.world.collarStacks = 0;
        }
        if (!Number.isFinite(store.world.collarTargetStacks)) {
            store.world.collarTargetStacks = store.world.collarStacks;
        }
        return store.world.collarStacks;
    }

    function calculateCollarBonus(stacks) {
        const safeStacks = Math.max(0, Number.isFinite(stacks) ? stacks : 0);
        const tierOne = Math.min(safeStacks, 5); // First 5 stacks at 6% each
        const tierTwo = Math.min(Math.max(safeStacks - 5, 0), 5); // Next 5 stacks at 4% each
        const tierThree = Math.max(Math.min(safeStacks, 25) - 10, 0); // Remaining stacks (capped at 25) at 2% each
        const bonus = tierOne * 0.06 + tierTwo * 0.04 + tierThree * 0.02;
        return 1 + bonus;
    }

    const MAX_COLLAR_STACKS = 25;

    function setCollarStacks(value) {
        const clamped = Math.max(0, Math.min(MAX_COLLAR_STACKS, ensureFiniteNumber(value, 0)));
        store.world.collarStacks = clamped;
        store.world.collarTargetStacks = clamped;
        return clamped;
    }

    function approachCollarTarget() {
        const currentStacks = sanitizeCollarStacks();
        if (!Number.isFinite(store.world.collarTargetStacks)) {
            store.world.collarTargetStacks = currentStacks;
        }
        const targetStacks = Math.min(MAX_COLLAR_STACKS, store.world.collarTargetStacks);
        const stackGap = targetStacks - currentStacks;
        if (stackGap > 0) {
            const maxIncrease = 1 + Math.min(2, currentStacks * 0.05);
            const appliedIncrease = Math.min(stackGap, maxIncrease);
            store.world.collarStacks = Math.min(MAX_COLLAR_STACKS, currentStacks + appliedIncrease);
        } else if (stackGap < 0) {
            setCollarStacks(targetStacks);
        }
    }

    function scheduleCollarIncrease(amount) {
        const delta = ensureFiniteNumber(amount, 0);
        if (delta <= 0) {
            approachCollarTarget();
            return;
        }

        const currentStacks = sanitizeCollarStacks();
        if (!Number.isFinite(store.world.collarTargetStacks)) {
            store.world.collarTargetStacks = currentStacks;
        }
        store.world.collarTargetStacks = Math.min(MAX_COLLAR_STACKS, store.world.collarTargetStacks + delta);
        approachCollarTarget();
    }

    function ensureFiniteNumber(value, fallback = 0) {
        return Number.isFinite(value) ? value : fallback;
    }

    function initWave() {
        if (store.goldenOrbs) {
            store.goldenOrbs.length = 0;
        }
        const isBossWave = store.world.wave % 5 === 0;
        
        // Clear poison puddles at start of each wave for clean slate
        if (store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        
        if (isBossWave) {
            store.enemies = [];
            
            // FIXED: Balanced boss scaling instead of aggressive exponential growth
            // Old: 1 + (wave/5 - 1) * 1.5 caused 4x HP by wave 15
            // New: Gentler scaling with reasonable progression
            let bossHpScale;
            if (store.world.wave <= 5) {
                bossHpScale = 1; // No scaling for early bosses
            } else if (store.world.wave <= 15) {
                bossHpScale = 1 + (store.world.wave - 5) * 0.2; // +20% per wave 6-15
            } else {
                bossHpScale = 1 + 10 * 0.2 + (store.world.wave - 15) * 0.1; // +10% per wave after 15
            }
            
            store.boss = createBoss(bossHpScale);
            store.world.bossSpawnTime = performance.now();
            store.world.lastPlannedSpawnCount = 0;
            store.world.lastSpawnCount = 0;
            store.world.lastSpawnOverflow = 0;
            store.world.lastThreatScale = 1;
            store.world.lastSpawnFallback = false;
            if (store.boss.name === 'VOID SENTINEL') playSound('trap');
            else if (store.boss.name === 'NEURAL CORE') playSound('horn');
            announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
            if (!store.world.firstBossOrbsGifted && store.world.bosses === 0 && store.boss.name === 'VOID SENTINEL') {
                spawnGoldenSentinelOrbs(3);
                store.world.firstBossOrbsGifted = true;
                setTimeout(() => announce('Collect GOLDEN ORBS to shatter the guardian!'), 750);
            }
        } else {
            store.enemies = [];
            store.waveSpawnQueue = [];
            store.pendingSpawnCount = 0;
            
            // NEW SCALING SYSTEM: After wave 35, stop increasing spawn count and increase enemy stats instead
            let baseSpawnCount, spawnCount, lateGameScaling = 1;
            
            if (store.world.wave <= 35) {
                // Normal scaling: increase spawn count with waves
                baseSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                spawnCount = baseSpawnCount;
            } else {
                // Wave 35+: Cap spawn count, scale enemy stats instead
                baseSpawnCount = Math.floor((7 + Math.floor(35 * 1.8)) * store.world.enemyDensityBonus);
                spawnCount = Math.max(1, Math.floor(baseSpawnCount * 0.8)); // Slightly fewer enemies for performance
                
                // Calculate what the spawn count WOULD have been, use that as scaling factor
                const theoreticalSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                lateGameScaling = theoreticalSpawnCount / baseSpawnCount; // This becomes our health/damage multiplier
            }
            
            // Store late-game scaling factor globally for damage calculations
            store.world.lateGameDamageScaling = lateGameScaling;
            
            // Apply collar bonus to spawn count with defensive guards
            const collarStacks = sanitizeCollarStacks();
            const collarBonus = calculateCollarBonus(collarStacks);
            const plannedSpawnCountRaw = spawnCount * collarBonus;
            const plannedSpawnCount = Math.max(0, ensureFiniteNumber(Math.floor(plannedSpawnCountRaw), 0));

            const rawEnemyCap = ensureFiniteNumber(store.world.enemyCap, 36);
            const enemyCap = rawEnemyCap > 0 ? rawEnemyCap : 36;

            let cappedSpawnCount = Math.min(enemyCap, plannedSpawnCount);
            if (!Number.isFinite(cappedSpawnCount) || cappedSpawnCount <= 0) {
                cappedSpawnCount = 1;
                store.world.lastSpawnFallback = true;
            } else {
                store.world.lastSpawnFallback = false;
            }

            const spawnIterations = Math.max(1, Math.floor(cappedSpawnCount));
            const threatScaleRaw = spawnIterations > 0 && plannedSpawnCount > 0 ? plannedSpawnCount / spawnIterations : 1;
            const threatScale = ensureFiniteNumber(threatScaleRaw, 1);

            store.world.lastThreatScale = threatScale;
            store.world.lastSpawnOverflow = Math.max(0, plannedSpawnCount - spawnIterations);
            store.world.lastPlannedSpawnCount = plannedSpawnCount;
            store.world.lastSpawnCount = 0;

            spawnCount = spawnIterations;

            const teleportAuraByType = {
                drone: '#7fd5ff',
                hunter: '#ff6e84',
                phantom: '#d9a7ff',
                mech: '#4ef0ff',
                angler: '#8cf8f8',
                manta: '#7acbff',
                void_champion: '#a864ff'
            };
            const spawnDurationByType = {
                phantom: 0.7,
                mech: 0.8,
                angler: 0.7,
                manta: 0.85,
                void_champion: 1.05
            };
            const dropDistanceByType = {
                mech: 200,
                angler: 170,
                manta: 180,
                void_champion: 220
            };

            // Check if we should spawn a champion this wave (only one per wave)
            let championSpawned = false;
            if (store.world.wave > 12) {
                const championChance = Math.min(0.3, 0.06 + (store.world.wave - 12) * 0.015);
                if (Math.random() < championChance) {
                    const champion = spawnEnemy('void_champion', { hpScale: threatScale, damageMult: threatScale });
                    if (champion) {
                        applySpawnSpecToEnemy(champion, { lateGameScaling });
                        const entryDrop = dropDistanceByType.void_champion || 220;
                        const entryTargetY = 110 + Math.random() * 50;
                        champion.spawnTargetY = entryTargetY;
                        champion.y = entryTargetY - entryDrop;
                        champion.x = Math.max(120, Math.min(W - 120, champion.x));
                        activateSpawnIntro(champion, {
                            duration: spawnDurationByType.void_champion,
                            dropDistance: entryDrop,
                            targetY: entryTargetY,
                            clusterIndex: -1,
                            effectColor: teleportAuraByType.void_champion,
                            topClampBuffer: 1.2,
                            fireDelayBuffer: 0.6
                        });
                        store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.spawnTargetY ?? champion.y, champion.r || 28, {
                            duration: (champion.spawnDuration || 1) + 0.35,
                            color: teleportAuraByType.void_champion,
                            clusterIndex: -1,
                            isChampion: true
                        }));
                        store.enemies.push(champion);
                        championSpawned = true;
                        spawnCount = Math.max(1, spawnCount - 1); // Reduce normal enemy count by 1
                    }
                }
            }

            const spawnSpecs = [];

            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter'];
                if (store.world.wave > 3) types.push('phantom');
                if (store.world.wave > 5) types.push('mech');
                if (store.world.wave > 7) types.push('angler');
                if (store.world.wave > 9) types.push('manta');

                const selectedType = types[Math.floor(Math.random() * types.length)];
                spawnSpecs.push({
                    type: selectedType,
                    props: { hpScale: threatScale, damageMult: threatScale },
                    lateGameScaling,
                    spawnDuration: spawnDurationByType[selectedType],
                    spawnDropDistance: dropDistanceByType[selectedType],
                    effectColor: teleportAuraByType[selectedType]
                });
            }

            if (spawnSpecs.length === 0) {
                console.warn('Enemy spawn pipeline produced zero entities; applying fallback spawn.', {
                    wave: store.world.wave,
                    plannedSpawnCount,
                    enemyCap,
                    collarStacks,
                    threatScale
                });
                spawnSpecs.push({
                    type: 'drone',
                    props: { hpScale: threatScale, damageMult: threatScale },
                    lateGameScaling,
                    spawnDuration: 0.6,
                    spawnDropDistance: 120,
                    effectColor: teleportAuraByType.drone
                });
                store.world.lastSpawnFallback = true;
            }

            const plannedClusters = Math.max(1, Math.ceil(spawnSpecs.length / 4));
            const clusterCount = Math.min(6, plannedClusters);
            const spawnTempo = Math.max(0.2, 0.55 - Math.min(store.world.wave, 25) * 0.015);

            store.pendingSpawnCount = spawnSpecs.length;
            store.world.lastSpawnQueueLength = spawnSpecs.length;
            store.world.lastSpawnTempo = spawnTempo;
            store.world.lastSpawnCount = store.enemies.length;

            scheduleWaveSpawnClusters(spawnSpecs, {
                clusterCount,
                baseDelay: spawnTempo,
                jitter: spawnTempo * 0.6
            });

            store.world.waveStartTime = performance.now();
            announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
        }
    }
    
    function createBoss(scale) {
        const bossCycle = Math.floor((store.world.wave - 5) / 5) % 5;
        const types = [
            { name: 'VOID SENTINEL', baseHp: 4000, r: 55, behavior: 'sentinel', color: '#8B4A9C' },
            { name: 'NEXUS PHANTOM', baseHp: 2200, r: 50, behavior: 'hex', color: '#66aaff'},
            { name: 'NEURAL CORE', baseHp: 3200, r: 60, behavior: 'malignus', color: '#2E8B57' },
            { name: 'HIVE SOVEREIGN', baseHp: 8500, r: 85, behavior: 'broodlord', color: '#2d5016' },
            { name: 'DEATH ENGINE', baseHp: 9000, r: 90, behavior: 'construct', color: '#e54d24', phase: 1, isLaughing: false, laughStartTime: 0, visible: true }
        ];
        const type = types[bossCycle];
        let hp = type.baseHp * scale * store.world.bossHealthBonus;
    const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
        hp *= collarBonus;
        
    const boss = { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, isEnraged: false, attackPhase: 0, phaseTimer: 0, dashTimer: 0, dashTrailCooldown: 0, rainEvent: null };
        
        // console.log(`üèÜ Boss Created: ${boss.name} | Wave: ${store.world.wave} | HP: ${hp} | Scale: ${scale} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x`);
        
        // Create Boss class instance for DEATH ENGINE
        if (boss.name === 'DEATH ENGINE') {
            boss.skullRenderer = new Boss(ctx, boss.x, boss.y, boss.color);
            // Store collar stacks before Death Engine fight to restore them after
            store.world.deathEngineCollarStacks = store.world.collarStacks;
            store.world.deathEngineCollarTargetStacks = store.world.collarTargetStacks;
        }
        
        return boss;
    }

    function spawnEnemy(type = 'drone', props = {}) {
        const cfgs = {
            drone: { r: 10, v: 80, vx: 0, hp: 22, color: '#C0C0C0', xp: 5, score: 50, gold: 2, fireRateChance: 0.004, contactDamage: 6 },
            hunter: { r: 20, v: 100, vx: 0, hp: 18, color: '#DC143C', xp: 8, score: 80, gold: 2, fireRateChance: 0.005, contactDamage: 8 },
            trap_king_add: { r: 6, v: 90, vx: 0, hp: 9, color: '#ffc83d', damage: 5, xp: 2, score: 10, gold: 1, contactDamage: 5 },
            phantom: { r: 14, v: 90, vx: 0, hp: 35, color: '#FFFFFF', xp: 10, score: 100, gold: 3, fireRateChance: 0.006, fireCooldown: 1.5, contactDamage: 8 },
            mech: { r: 18, v: 40, vx: 0, hp: 73, color: '#FF8500', xp: 15, score: 150, gold: 5, fireRateChance: 0.007, attackPhase: 0, contactDamage: 10 },
            construct_gold: { r: 10, v: 120, vx: 0, hp: 17, color: '#e03434', xp: 3, score: 30, gold: 1, contactDamage: 7 },
            avian_hatchling: { r: 8, v: 150, vx: 0, hp: 22, color: '#9370DB', xp: 4, score: 40, gold: 1, contactDamage: 6 },
            angler: { r: 22, v: 30, vx: 0, hp: 150, color: '#00008b', xp: 18, score: 180, gold: 4, fireRateChance: 0.008, contactDamage: 10 },
            manta: { r: 26, v: 50, vx: 0, hp: 175, color: '#53B6FF', xp: 22, score: 220, gold: 5, fireRateChance: 0.009, contactDamage: 10 },
            void_champion: { r: 16, v: 48, vx: 0, hp: 190, color: '#5A28D8', xp: 32, score: 325, gold: 9, fireRateChance: 0.75, fireCooldown: 1.65, contactDamage: 10 },
            void_champion_orb: { r: 6, v: 0, vx: 0, hp: 22, color: '#FF7DEB', xp: 2, score: 24, gold: 0, fireRateChance: 0.55, fireCooldown: 1.25, contactDamage: 4 }
        };
        const baseCfg = cfgs[type];
        if (!baseCfg) {
            console.warn('Unknown enemy type', type);
            return null;
        }
        let c = { ...baseCfg }; const wave = store.world.wave;
        
        // FIXED: Much gentler health scaling to prevent unkillable enemies
        // Old: Math.pow(1.075, wave) - exponential growth was too aggressive
        // New: Linear growth with soft cap
        let waveMultiplier;
        if (wave <= 10) {
            waveMultiplier = 1 + (wave - 1) * 0.15; // +15% per wave early game
        } else {
            waveMultiplier = 1 + 9 * 0.15 + (wave - 10) * 0.05; // +5% per wave after wave 10
        }
        
        c.hp *= waveMultiplier * store.world.enemyHealthBonus;
    const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
        c.hp *= collarBonus;
        
        // console.log(`üîç Enemy Health Debug | Type: ${type} | Base: ${cfgs[type].hp} | Wave: ${wave} | WaveMult: ${waveMultiplier.toFixed(2)} | EnemyBonus: ${store.world.enemyHealthBonus.toFixed(2)} | CollarBonus: ${collarBonus.toFixed(2)} | Final HP: ${c.hp.toFixed(1)}`);
        const spawnX = props.x !== undefined ? props.x : 20 + Math.random() * (W - 40);
        const spawnY = props.y !== undefined ? props.y : -50 - Math.random() * 250;
        const e = {
            ...c,
            type,
            id: Date.now() + Math.random(),
            x: spawnX,
            y: spawnY,
            hpMax: c.hp,
            phase: type === 'phantom',
            t: 0,
            fireT: props.fireT !== undefined ? props.fireT : (c.fireCooldown || 0),
            isBursting: false,
            burstTimer: 0,
            stunTimer: 0,
            knockback: null,
            hitPulseTimer: 0,
            hitPulseDuration: props.hitPulseDuration || 0.22
        };

        if (props.hpScale && props.hpScale !== 1) {
            e.hp *= props.hpScale;
            e.hpMax *= props.hpScale;
        }

        e.damageMult = props.damageMult !== undefined ? props.damageMult : 1;
        e.baseContactDamage = props.baseContactDamage || c.contactDamage || 8;
        e.contactDamage = e.baseContactDamage * e.damageMult;

        if (!props.damageMult && props.hpScale && props.hpScale !== 1) {
            e.damageMult = props.hpScale;
            e.contactDamage = e.baseContactDamage * e.damageMult;
        }

        if (e.type === 'manta') {
            e.startX = e.x;
            e.amplitude = 150 + Math.random() * 100;
            e.frequency = 0.5 + Math.random() * 0.5;
            e.dodgeCooldown = 0;
            e.isDodging = false;
        }
        if (e.type === 'void_champion') {
            e.fireCooldown = c.fireCooldown || 1.8;
            e.fireT = e.fireCooldown * (0.4 + Math.random() * 0.6);
            e.vx = (Math.random() < 0.5 ? -1 : 1) * (40 + Math.random() * 30);
            e.dashTimer = 2 + Math.random() * 2;
            e.dashCooldown = 4 + Math.random() * 3;
            e.minionIds = [];
            e.nextPattern = 'beam';
            if (store && store.player) {
                const pStats = store.player;
                const dmgFactor = Math.min(3, Math.max(1, pStats.dmgMult || 1));
                const multishotFactor = 1 + Math.max(0, (pStats.multishot || 1) - 1) * 0.2 + (pStats.rearMultishot || 0) * 0.1;
                const fireRateBaseline = 0.45;
                const fireRateFactor = Math.min(2.5, Math.max(1, fireRateBaseline / Math.max(pStats.fireRate || 0.45, 0.18)));
                const shieldFactor = Math.pow(Math.max(1, (pStats.shieldMax || 0) / 60), 0.2);
                const healthFactor = Math.pow(Math.max(1, (pStats.hpMax || 100) / 120), 0.2);
                const playerScaling = Math.min(3.5, Math.max(1, dmgFactor * multishotFactor * fireRateFactor * Math.max(shieldFactor, healthFactor)));
                e.hp *= playerScaling;
                e.hpMax *= playerScaling;
                e.damageMult *= playerScaling;
                e.contactDamage = e.baseContactDamage * e.damageMult;
                e.playerScaling = playerScaling;
            }
            if (store && store.world && !store.world.seenVoidChampion) {
                store.world.seenVoidChampion = true;
                announce('‚öôÔ∏è VOID CHAMPION ONLINE // SINGULARITY KNIGHT ‚öôÔ∏è');
            }
            if (store && store.enemies) {
                const minionCount = 3;
                for (let i = 0; i < minionCount; i++) {
                    const angle = (i / minionCount) * Math.PI * 2;
                    const ringRadius = 42;
                    const minion = spawnEnemy('void_champion_orb', {
                        x: e.x + Math.cos(angle) * ringRadius,
                        y: e.y + Math.sin(angle) * ringRadius,
                        orbitTargetId: e.id,
                        orbitAngle: angle,
                        orbitRadius: ringRadius,
                        orbitSpeed: 1.3 + i * 0.12,
                        parentColor: e.color,
                        fireT: Math.random() * 0.6,
                        damageMult: Math.max(1, (e.damageMult || 1) * 0.65),
                        hpScale: Math.max(1, (e.damageMult || 1) * 0.7)
                    });
                    if (minion) {
                        const minionDrop = 140;
                        const minionTargetY = (e.spawnTargetY ?? e.y + minionDrop) + Math.sin(angle) * 26;
                        minion.spawnTargetY = minionTargetY;
                        activateSpawnIntro(minion, {
                            duration: 0.55 + Math.random() * 0.1,
                            dropDistance: minionDrop,
                            targetY: minionTargetY,
                            clusterIndex: -1,
                            effectColor: '#ff7deb',
                            topClampBuffer: 0.6,
                            fireDelayBuffer: 0.4
                        });
                        e.minionIds.push(minion.id);
                        store.enemies.push(minion);
                    }
                }
            }
        }
        if (e.type === 'void_champion_orb') {
            e.isOrbiter = true;
            e.orbitRadius = props.orbitRadius || 42;
            e.orbitSpeed = props.orbitSpeed || 1.45;
            e.orbitAngle = props.orbitAngle ?? Math.random() * Math.PI * 2;
            e.orbitTargetId = props.orbitTargetId || null;
            const centerX = props.orbitCenterX !== undefined ? props.orbitCenterX : e.x;
            const centerY = props.orbitCenterY !== undefined ? props.orbitCenterY : e.y;
            e.orbitCenter = { x: centerX, y: centerY };
            if (props.parentColor) {
                e.color = props.parentColor;
            }
            e.fireCooldown = c.fireCooldown || 1.15;
            e.fireT = props.fireT !== undefined ? props.fireT : e.fireCooldown;
            e.v = 0;
        }
        return e;
    }

    function scheduleWaveSpawnClusters(spawnSpecs, options = {}) {
        const clustersRequested = options.clusterCount ?? 3;
        const clusterCount = Math.max(1, Math.min(clustersRequested, spawnSpecs.length || 1));
        const clusters = Array.from({ length: clusterCount }, () => []);

        spawnSpecs.forEach((spec, index) => {
            clusters[index % clusterCount].push(spec);
        });

        const baseDelay = options.baseDelay ?? 0.35; // seconds between clusters
        const jitterAmplitude = options.jitter ?? baseDelay * 0.35;
        const queue = store.waveSpawnQueue;

        clusters.forEach((cluster, idx) => {
            if (!cluster.length) return;
            const stagger = idx === 0 ? 0 : (Math.random() - 0.5) * jitterAmplitude;
            const timer = Math.max(0, idx * baseDelay + stagger);
            queue.push({
                timer,
                enemies: cluster,
                clusterIndex: idx,
                clusterSize: cluster.length,
                totalClusters: clusterCount,
                baseDelay
            });
        });
    }

    function processWaveSpawnQueue(dt) {
        if (!store.waveSpawnQueue.length) return;
        for (let i = store.waveSpawnQueue.length - 1; i >= 0; i--) {
            const evt = store.waveSpawnQueue[i];
            evt.timer -= dt;
            if (evt.timer <= 0) {
                spawnClusterEnemies(evt);
                store.waveSpawnQueue.splice(i, 1);
            }
        }
    }

    function spawnClusterEnemies(event) {
        const clusterSize = event.enemies.length;
        const centerX = Math.max(80, Math.min(W - 80, 80 + Math.random() * (W - 160)));
        const spacing = Math.max(40, 140 - clusterSize * 10);
        let spawnedThisCluster = 0;

        event.enemies.forEach((spec, idx) => {
            const lateralOffset = (idx - (clusterSize - 1) / 2) * spacing + (Math.random() - 0.5) * 35;
            const spawnX = Math.max(40, Math.min(W - 40, centerX + lateralOffset));
            const spawnY = -160 - Math.random() * 120;
            const props = { ...(spec.props || {}), x: spawnX, y: spawnY };
            const enemy = spawnEnemy(spec.type, props);
            store.pendingSpawnCount = Math.max(0, (store.pendingSpawnCount || 0) - 1);
            if (!enemy) {
                store.world.lastSpawnFallback = true;
                return;
            }

            applySpawnSpecToEnemy(enemy, spec);
            activateSpawnIntro(enemy, {
                duration: spec.spawnDuration,
                dropDistance: spec.spawnDropDistance,
                clusterIndex: event.clusterIndex,
                effectColor: spec.effectColor,
                topClampBuffer: 0.75,
                clusterSize
            });

            store.enemies.push(enemy);
            store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
            spawnedThisCluster++;

            store.activeEffects.push(createEffect('spawnTeleport', enemy.x, enemy.spawnTargetY ?? enemy.y, enemy.r || 18, {
                duration: (enemy.spawnDuration || 0.6) + 0.25,
                color: spec.effectColor,
                clusterIndex: event.clusterIndex,
                clusterSize
            }));
        });

        if (spawnedThisCluster === 0) {
            const fallback = spawnEnemy('drone', { x: centerX, y: -140 });
            if (fallback) {
                applySpawnSpecToEnemy(fallback, { lateGameScaling: 1 });
                activateSpawnIntro(fallback, {
                    duration: 0.6,
                    dropDistance: 110,
                    clusterIndex: event.clusterIndex,
                    effectColor: '#7fd5ff',
                    topClampBuffer: 0.75,
                    clusterSize
                });
                store.enemies.push(fallback);
                store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
                store.world.lastSpawnFallback = true;
                store.activeEffects.push(createEffect('spawnTeleport', fallback.x, fallback.spawnTargetY ?? fallback.y, fallback.r || 14, {
                    duration: (fallback.spawnDuration || 0.6) + 0.25,
                    color: '#7fd5ff',
                    clusterIndex: event.clusterIndex,
                    clusterSize,
                    fallback: true
                }));
            }
        }
    }

    function applySpawnSpecToEnemy(enemy, spec) {
        if (spec.lateGameScaling && spec.lateGameScaling > 1) {
            enemy.hp *= spec.lateGameScaling;
            enemy.hpMax *= spec.lateGameScaling;
            enemy.damageMult = (enemy.damageMult || 1) * spec.lateGameScaling;
        }
        if (spec.props && spec.props.damageMult !== undefined) {
            enemy.damageMult = spec.props.damageMult;
        }
        enemy.baseContactDamage = spec.baseContactDamage ?? enemy.baseContactDamage ?? enemy.contactDamage ?? 8;
        enemy.contactDamage = enemy.baseContactDamage * (enemy.damageMult || 1);
        if (typeof spec.onSpawn === 'function') {
            try {
                spec.onSpawn(enemy);
            } catch (err) {
                console.warn('Spawn spec hook failed', err);
            }
        }
    }

    function activateSpawnIntro(enemy, opts = {}) {
        const duration = opts.duration ?? enemy.spawnDuration ?? (0.6 + Math.random() * 0.2);
        const dropDistance = opts.dropDistance ?? enemy.spawnDropDistance ?? (80 + Math.random() * 70);
        const existingTarget = enemy.spawnTargetY !== undefined ? enemy.spawnTargetY : enemy.y;
        const targetY = opts.targetY ?? (enemy.spawnTargetY !== undefined ? existingTarget : existingTarget + dropDistance);
        const startY = targetY - dropDistance;

        enemy.spawnPhase = 'teleport';
        enemy.spawnDuration = duration;
        enemy.spawnTimer = duration;
        enemy.spawnTargetY = targetY;
        enemy.spawnStartY = startY;
        enemy.spawnOpacity = 0;
        enemy.spawnEffectColor = opts.effectColor ?? enemy.spawnEffectColor;
        enemy.spawnClusterIndex = opts.clusterIndex ?? enemy.spawnClusterIndex ?? 0;
        enemy.spawnClusterSize = opts.clusterSize ?? enemy.spawnClusterSize ?? 1;
        enemy.spawnIntroGlow = opts.glowStrength ?? enemy.spawnIntroGlow ?? 1;
        enemy.topClampDelay = Math.max(enemy.topClampDelay || 0, duration + (opts.topClampBuffer ?? 0.5));
        enemy.fireT = Math.max(enemy.fireT || 0, duration + (opts.fireDelayBuffer ?? 0.25));
        enemy.y = startY;
    }

    function registerEnemyHit(enemy, impact = {}) {
        if (!enemy || enemy.dead) return;

        const duration = impact.duration ?? enemy.hitPulseDuration ?? 0.22;
        enemy.hitPulseDuration = duration;
        enemy.hitPulseTimer = duration;

        const shakeIntensity = impact.shakeIntensity ?? 0;
        if (shakeIntensity > 0) {
            const shakeDuration = Math.max(impact.shakeDuration ?? 0.16, 0);
            enemy.hitShakeDuration = Math.max(enemy.hitShakeDuration || 0, shakeDuration);
            enemy.hitShakeTimer = Math.max(enemy.hitShakeTimer || 0, shakeDuration);
            enemy.hitShakeIntensity = Math.max(enemy.hitShakeIntensity || 0, shakeIntensity);
        }

        if (impact.slowFactor !== undefined && impact.slowFactor < 1) {
            const slowDuration = Math.max(impact.slowDuration ?? 0.12, 0);
            if (slowDuration > 0) {
                enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, impact.slowFactor);
                enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
            }
        }

        const strength = impact.knockbackStrength ?? 140;
        if (strength > 0) {
            const angle = impact.angle ?? 0;
            const vx = Math.cos(angle) * strength;
            const vy = Math.sin(angle) * strength;
            const knockDuration = impact.knockbackDuration ?? 0.1;

            if (!enemy.knockback || enemy.knockback.type === 'hitReaction') {
                enemy.knockback = {
                    vx,
                    vy,
                    duration: knockDuration,
                    type: 'hitReaction'
                };
            } else if (enemy.knockback && enemy.knockback.vx !== undefined && enemy.knockback.type !== 'maraLaunch' && enemy.knockback.type !== 'jugCharge') {
                enemy.knockback.vx += vx * 0.35;
                enemy.knockback.vy += vy * 0.35;
                enemy.knockback.duration = Math.max(enemy.knockback.duration || 0, knockDuration * 0.8);
            }
        } else if (strength === 0 && enemy.knockback && enemy.knockback.type === 'hitReaction') {
            enemy.knockback = null;
        }

        if (impact.effect !== false) {
            store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, enemy.r || 16, {
                angle: impact.angle ?? 0,
                strength,
                crit: impact.crit || false
            }));
        }
    }

    function stepPlayer(dt) {
        const p = store.player;
        if (p.pilotGenome === 'beef' && p.beefChargeState !== 'ready' && p.beefMaxCharges > 0) {
            p.beefChargeT += dt;
            const chargeDuration = 0.25; const returnDuration = 0.35;
            if (p.beefChargeState === 'charging') {
                const progress = Math.min(p.beefChargeT / chargeDuration, 1);
                p.x = p.beefChargeOrigin.x + (p.beefChargeTarget.x - p.beefChargeOrigin.x) * progress;
                p.y = p.beefChargeOrigin.y + (p.beefChargeTarget.y - p.beefChargeOrigin.y) * progress;
                if (progress >= 1) { 
                    // Check if we're in chain mode and have more targets
                    if (p.beefChainMode && p.beefChainIndex < p.beefChainTargets.length - 1) {
                        // Move to next chain target
                        p.beefChainIndex++;
                        p.beefChargeOrigin = { x: p.x, y: p.y }; // Current position becomes new origin
                        p.beefChargeTarget = { x: p.beefChainTargets[p.beefChainIndex].x, y: p.beefChainTargets[p.beefChainIndex].y };
                        p.beefChargeT = 0; // Reset timing for next jump
                        // console.log(`Chaining to target ${p.beefChainIndex + 1} of ${p.beefChainTargets.length}`);
                    } else {
                        // Chain complete - stay at final position for chain mode, or return for single charge
                        if (p.beefChainMode) {
                            // Chain complete - stay here and reset
                            p.beefChargeState = 'ready'; 
                            p.isInvincible = false;
                            p.beefChainTargets = [];
                            p.beefChainIndex = 0;
                            // console.log('Chain jumping complete!');
                        } else {
                            // Single charge - return to origin
                            p.beefChargeState = 'returning'; 
                            p.beefChargeT = 0; 
                        }
                    }
                }
            } else if (p.beefChargeState === 'returning') {
                // Only used for single charge mode (non-marauder)
                const progress = Math.min(p.beefChargeT / returnDuration, 1);
                p.x = p.beefChargeTarget.x + (p.beefChargeOrigin.x - p.beefChargeTarget.x) * progress;
                p.y = p.beefChargeTarget.y + (p.beefChargeOrigin.y - p.beefChargeTarget.y) * progress;
                if (progress >= 1) { 
                    p.x = p.beefChargeOrigin.x; 
                    p.y = p.beefChargeOrigin.y; 
                    p.beefChargeState = 'ready'; 
                    p.isInvincible = false; 
                }
            }
        } else {
            // MOVEMENT LOGIC
            if (document.body.classList.contains('mobile-controls-active')) {
                // Joystick Movement
                const moveSpeed = p.speed;
                p.x += joystickState.input.x * moveSpeed * dt;
                p.y += joystickState.input.y * moveSpeed * dt;
                p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
            } else {
                // Mouse Movement (Original Logic)
                const vx = mouse.x - p.x, vy = mouse.y - p.y;
                const dist = Math.sqrt(vx * vx + vy * vy);
                if (dist < 15) {
                    p.x = mouse.x;
                    p.y = mouse.y;
                } else {
                    const accelFactor = 0.0125;
                    p.x += vx * p.speed * dt * accelFactor;
                    p.y += vy * p.speed * dt * accelFactor;
                }
                p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
            }
        }
        if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0) {
            if (p.beefCharges < p.beefMaxCharges) {
                if (p.beefChargeCooldown > 0) {
                    p.beefChargeCooldown -= dt;
                }
                if (p.beefChargeCooldown <= 0) {
                    p.beefCharges++;
                    if (p.beefCharges < p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                }
            }
            // The charge is triggered either by the button OR automatically by proximity
            const shouldCharge = p.isRequestingCharge || !document.body.classList.contains('mobile-controls-active');

            if (p.beefChargeState === 'ready' && p.beefCharges > 0 && shouldCharge) {
                p.isRequestingCharge = false; // Reset the flag
                const chargeRadius = 120; let closestEnemy = null; let closestDistSq = chargeRadius * chargeRadius;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.stunTimer > 0) return;
                    const dx = e.x - p.x; const dy = e.y - p.y; const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) { closestDistSq = distSq; closestEnemy = e; }
                });
                if (closestEnemy) {
                    if (p.beefCharges === p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                    p.beefCharges--; 
                    
                    // Set up chain jumping system for marauder
                    if (p.beefChainMode && p.beefMaxCharges > 1) {
                        // Find chain targets
                        p.beefChainTargets = [{ x: p.x, y: p.y }]; // Start with player position
                        let currentPos = { x: p.x, y: p.y };
                        
                        // Add targets based on max charges (marauder=2, enhanced=3)
                        for (let i = 0; i < p.beefMaxCharges; i++) {
                            let nextTarget = null;
                            let nextClosestDistSq = 150 * 150; // Chain range
                            
                            potentialTargets.forEach(e => {
                                if (e.dead || e.stunTimer > 0) return;
                                // Don't target the same enemy twice in a row
                                if (p.beefChainTargets.length > 1 && 
                                    Math.abs(e.x - p.beefChainTargets[p.beefChainTargets.length-1].x) < 10 &&
                                    Math.abs(e.y - p.beefChainTargets[p.beefChainTargets.length-1].y) < 10) return;
                                    
                                const dx = e.x - currentPos.x;
                                const dy = e.y - currentPos.y; 
                                const distSq = dx * dx + dy * dy;
                                if (distSq < nextClosestDistSq) { 
                                    nextClosestDistSq = distSq; 
                                    nextTarget = e; 
                                }
                            });
                            
                            if (nextTarget) {
                                p.beefChainTargets.push({ x: nextTarget.x, y: nextTarget.y });
                                currentPos = { x: nextTarget.x, y: nextTarget.y };
                            } else {
                                // No more targets found, end chain
                                break;
                            }
                        }
                        
                        // Start chaining (skip player position)
                        p.beefChainIndex = 0;
                        if (p.beefChainTargets.length > 1) {
                            p.beefChargeOrigin = { x: p.x, y: p.y };
                            p.beefChargeTarget = { x: p.beefChainTargets[1].x, y: p.beefChainTargets[1].y };
                            p.beefChainIndex = 1;
                        } else {
                            // Fall back to single target
                            p.beefChargeOrigin = { x: p.x, y: p.y };
                            p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y };
                        }
                        
                        // console.log(`Chain setup: ${p.beefChainTargets.length} targets for ${p.beefMaxCharges} charges`);
                    } else {
                        // Original single charge system
                        p.beefChargeOrigin = { x: p.x, y: p.y }; 
                        p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y };
                    }
                    
                    p.beefChargeState = 'charging'; 
                    p.beefChargeT = 0; 
                    p.isInvincible = true;
                    store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                    
                    // Calculate impact radius based on skills
                    let impactRadius = 80; // Base radius
                    if (p.skillTree && p.skillTree.juggernaut) impactRadius = 120;
                    if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) impactRadius = 160; // Big explosion
                    
                    // Apply Juggernaut Unstoppable Force radius multiplier
                    if (p.beefExplosionRadius) {
                        impactRadius *= p.beefExplosionRadius;
                    }
                    
                    // Skill tree compatibility - check subclass for existing players
                    if (p.subclass === 'juggernaut') impactRadius = Math.max(impactRadius, 120);
                    
                    if (p.skillTree && p.skillTree.juggernaut || p.subclass === 'juggernaut') {
                        playSound('charge');
                        explode(closestEnemy.x, closestEnemy.y, false, true);
                    } else {
                        playSound('beefCharge');
                    }
                    
                    // Apply impact damage
                    let baseDamage = 80;
                    if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) baseDamage = 150; // Big explosion damage
                    
                    // Apply Juggernaut skill multipliers
                    if (p.beefChargeDamage) {
                        baseDamage *= p.beefChargeDamage; // Charge Power skill
                    }
                    if (p.beefExplosionDamage) {
                        baseDamage *= p.beefExplosionDamage; // Unstoppable Force skill
                    }
                    
                    // Track enemies hit for marauder double-hit bonus
                    if (!p.marauderHitTargets) p.marauderHitTargets = new Set();
                    
                    potentialTargets.forEach(e => {
                        if (e.dead) return;
                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                        if (distSq < impactRadius * impactRadius) {
                            let chargeDmg = baseDamage * p.dmgMult;
                            
                            // Marauder double-hit bonus system
                            const enemyId = e.id || `${e.x}_${e.y}_${e.type}`;
                            let isDoubleHit = false;
                            if (p.subclass === 'marauder' && p.marauderHitTargets.has(enemyId)) {
                                const doubleHitMultiplier = p.marauderDoubleHitBonus || 2.0;
                                isDoubleHit = true;
                                
                                // Special effects based on enemy type
                                if (e === store.boss || e.type === 'void_champion') {
                                    // Boss/Champion: Major damage + long stun, but no flatten
                                    chargeDmg *= doubleHitMultiplier * 1.5; // Extra multiplier for tough enemies
                                    e.stunTimer = 8.0; // Extended stun
                                    e.marauderMarked = true; // Mark for visual effect
                                    announce('CHAMPION DEVASTATION!');
                                } else {
                                    // Regular enemy: Flatten effect - disable but leave for cleanup
                                    e.isFlattened = true;
                                    e.flattenedTime = performance.now();
                                    e.v = 0; // Stop movement
                                    e.vx = 0;
                                    e.vy = 0;
                                    e.hp = 1; // Leave at 1 HP for cleanup
                                    e.stunTimer = 999; // Effectively permanent stun
                                    e.fireRateChance = 0; // Can't fire anymore
                                    
                                    // Add special flattened visual scaling
                                    e.flattenScale = { x: 2.0, y: 0.1 }; // Wide and very flat
                                    
                                    const bonusText = doubleHitMultiplier >= 3.0 ? 'ELITE FLATTEN!' : 'MARAUDER FLATTEN!';
                                    announce(bonusText);
                                }
                                
                                // Reset the tracking for this enemy after the bonus
                                setTimeout(() => p.marauderHitTargets.delete(enemyId), 100);
                            } else if (p.subclass === 'marauder') {
                                // First hit - track this enemy for potential double hit
                                p.marauderHitTargets.add(enemyId);
                                // Clear tracking after 3 seconds if not hit again
                                setTimeout(() => p.marauderHitTargets.delete(enemyId), 3000);
                            }
                            
                            const knockbackAngle = Math.atan2(e.y - p.y, e.x - p.x);
                            const damageTags = p.subclass === 'juggernaut' ? ['fire', 'explosive'] : ['kinetic', 'concussive'];
                            const vulnResult = applySubclassVulnerability(e, chargeDmg, {
                                player: p,
                                subclass: p.subclass,
                                damageTags,
                                source: 'beefCharge',
                                knockbackAngle,
                                baseDamage: chargeDmg
                            });
                            chargeDmg = vulnResult.damage;

                            e.hp -= chargeDmg; 
                            if (!isDoubleHit) e.stunTimer = 2.5; // Normal stun if not double hit
                            
                            // Apply vampirism healing for charge damage
                            if (store.player.vampirism > 0) {
                                let healAmount = chargeDmg * store.player.vampirism;
                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                healAmount = Math.min(healAmount, 8); // Cap at 8 HP for charge
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                            
                            let knockbackForce = 250; 
                            if (p.beefChargeKnockback) {
                                knockbackForce *= p.beefChargeKnockback; // Apply Charge Power knockback multiplier
                            }
                            if (!e.knockback || e.knockback.type !== 'maraLaunch') {
                                e.knockback = { vx: Math.cos(knockbackAngle) * knockbackForce, vy: Math.sin(knockbackAngle) * knockbackForce, duration: 0.3 };
                            }
                        }
                    });
                    
                    // Handle double charge (combo skill)
                    if (p.beefDoubleCharge || (p.skillTree && p.skillTree.combo_charge) && p.beefCharges > 0) {
                        setTimeout(() => {
                            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                                // Trigger second charge at same target
                                p.beefCharges--;
                                p.beefChargeState = 'charging'; 
                                p.beefChargeOrigin = { x: p.x, y: p.y }; 
                                p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y }; 
                                p.beefChargeT = 0; p.isInvincible = true;
                                store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                                
                                setTimeout(() => {
                                    // Second impact (smaller for combo)
                                    if (p.skillTree && p.skillTree.juggernaut || p.subclass === 'juggernaut') {
                                        explode(closestEnemy.x, closestEnemy.y, false, true);
                                    }
                                    potentialTargets.forEach(e => {
                                        if (e.dead) return;
                                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                                        // Use smaller radius for combo double charge
                                        const comboRadius = 60; 
                                        if (distSq < comboRadius * comboRadius) {
                                            let secondChargeDmg = baseDamage * p.dmgMult * 0.7; // Reduced damage for second hit
                                            const comboAngle = Math.atan2(e.y - p.y, e.x - p.x);
                                            const comboTags = p.subclass === 'juggernaut' ? ['fire', 'explosive'] : ['kinetic', 'concussive'];
                                            const comboVuln = applySubclassVulnerability(e, secondChargeDmg, {
                                                player: p,
                                                subclass: p.subclass,
                                                damageTags: comboTags,
                                                source: 'beefChargeCombo',
                                                knockbackAngle: comboAngle,
                                                baseDamage: secondChargeDmg
                                            });
                                            secondChargeDmg = comboVuln.damage;
                                            e.hp -= secondChargeDmg;
                                            e.stunTimer = Math.max(e.stunTimer, 1.5);
                                            
                                            // Apply vampirism healing for second charge damage
                                            if (store.player.vampirism > 0) {
                                                let healAmount = secondChargeDmg * store.player.vampirism;
                                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                                healAmount = Math.min(healAmount, 6); // Cap at 6 HP for second charge
                                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                            }
                                        }
                                    });
                                }, 400); // Second impact timing
                            }
                        }, 400); // Delay before second charge
                    }
                }
            }
        } else if (p.pilotGenome === 'rocketman' && p.hasFirewall) {
            if (p.flameWallCooldown > 0) p.flameWallCooldown -= dt;
            if (p.flameWallActiveT > 0) p.flameWallActiveT -= dt;
            if (p.flameWallCooldown <= 0) { p.flameWallActiveT = 0.5; p.flameWallCooldown = 10; }
            if (p.flameWallActiveT > 0) {
                for (let i = 0; i < 2; i++) {
                    let attachedEnemy = null;
                    let closestDistSq = Infinity;
                    store.enemies.forEach(enemy => {
                        const distSq = (enemy.x - p.x) * (enemy.x - p.x) + (enemy.y - (p.y + 10)) * (enemy.y - (p.y + 10));
                        if (distSq < 100 * 100 && distSq < closestDistSq) {
                            closestDistSq = distSq;
                            attachedEnemy = enemy;
                        }
                    });
                    store.flameParticles.push(new FlameParticle(p.x, p.y + 10, attachedEnemy));
                }
            }
        } else if (p.pilotGenome === 'voidmancer') {
            if (p.hasChainLightning || p.hasHybridVoid) {
                p.chainLightningCooldown -= dt;
                if (p.chainLightningCooldown <= 0) { 
                    fireChainLightning(); 
                    // Set cooldown based on stormstriker level - more bolts = faster alternation
                    if (p.stormstrikerLevel >= 3) {
                        p.chainLightningCooldown = 0.375; // 4-bolt rotation: quadruple fire rate
                    } else if (p.stormstrikerLevel >= 2) {
                        p.chainLightningCooldown = 0.75; // Alternating bolts: double fire rate
                    } else {
                        p.chainLightningCooldown = 1.5; // Single bolt: normal rate
                    }
                }
            }
            
            // Voidmancer base laser beam system
            if (p.hasVoidLaser) {
                stepVoidLaser(dt);
            }
        }
        if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
        p.fireT -= dt;
        if (p.fireT <= 0 && !p.empDisabled) { firePlayer(); p.fireT = p.fireRate; }
        
        // Separate flamethrower system (unaffected by overclock)
        if (p.flamethrowerLevel > 0 && !p.empDisabled) {
            p.flamethrowerT -= dt;
            if (p.flamethrowerT <= 0) {
                fireFlamethrower();
                p.flamethrowerT = 0.18; // Fixed fire rate for lava chunks
            }
        }

        if (p.starCannonLevel > 0 && !p.empDisabled) {
            p.starCannonTimer -= dt;
            if (p.starCannonTimer <= 0) {
                fireStarCannon();
                p.starCannonTimer = STAR_CANNON_COOLDOWN;
            }
        }
        
        // Homing Missile system (from powerup)
        if (p.powerupTimers['missile'] && !p.empDisabled) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });
                if (closest) {
                    const isRocketman = p.pilotGenome === 'rocketman';
                    const missileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                    const volleySize = p.missileVolley || 2;
                    
                    for (let i = 0; i < volleySize; i++) {
                        const spreadAngle = (i - (volleySize - 1) / 2) * 0.2;
                        const dx = closest.x - p.x;
                        const dy = closest.y - p.y;
                        const baseAngle = Math.atan2(dy, dx);
                        const finalAngle = baseAngle + spreadAngle;
                        
                        const missile = {
                            x: p.x, y: p.y - 10,
                            vx: Math.cos(finalAngle) * 200,
                            vy: Math.sin(finalAngle) * 200,
                            speed: 200, turnRate: 4.5,
                            target: closest, life: 0,
                            dmg: missileDmg,
                            cluster: isRocketman && p.missileCluster,
                            pierce: isRocketman ? (p.missilePierce || 0) : 0,
                            isIceman: false
                        };
                        store.missiles.push(missile);
                    }
                    playSound('shoot');
                }
            }
        }
        
        if (p.shieldMax > 0 && p.shield < p.shieldMax) p.shield = Math.min(p.shieldMax, p.shield + 0.5 * dt);
        for (const key in p.powerupTimers) {
            const timer = p.powerupTimers[key];
            timer.remaining -= dt;
            if (timer.remaining <= 0) {
                if (key === 'drones') {
                    store.drones = [];
                } else if (key === 'void_core') {
                    const prevDmgMult = p.voidCoreDmgMult || 1;
                    const prevFireRateMult = p.voidCoreFireRateMult || 1;
                    p.dmgMult = p.dmgMult / prevDmgMult;
                    p.fireRate = p.fireRate * prevFireRateMult;
                    p.voidCoreStacks = 0;
                    p.voidCoreDmgMult = 1;
                    p.voidCoreFireRateMult = 1;
                }
                delete p.powerupTimers[key];
            }
        }
        if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
        if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { activateGravityWell(); p.voidBeamCooldown = 30; } }
        if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { activateLazarus(); p.lazarusBeamCooldown = 30 / (p.upgradeLevels.lazarus_beam > 0 ? 2 : 1) ; } }
        if (store.cheatInvincibilityCooldown > 0) store.cheatInvincibilityCooldown -= dt;
        if (store.cheatDogHealCooldown > 0) store.cheatDogHealCooldown -= dt;
        if (p.x < 50 && p.y < 50 && store.cheatInvincibilityCooldown <= 0) {
            store.cheatsUsed = true; p.isInvincible = true; p.cheatMultishotBonus = 2; announce('TEST: INVINCIBILITY ACTIVE');
            setTimeout(() => { p.isInvincible = false; p.cheatMultishotBonus = 0; announce('TEST: INVINCIBILITY ENDS'); store.cheatInvincibilityCooldown = 10; }, 15000);
            store.cheatInvincibilityCooldown = 15 + 10;
        }
        if (p.x > W - 50 && p.y < 50 && store.cheatDogHealCooldown <= 0) {
            store.cheatsUsed = true; p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.20);
            if (!p.hasHounds) { p.hasHounds = true; }
            let houndsToAdd = Math.min(2, 4 - store.hounds.length);
            if (houndsToAdd > 0) {
                const existingSides = new Set(store.hounds.map(h => h.side)); const potentialSides = [-1, 1, -2, 2];
                for (const side of potentialSides) { if (houndsToAdd > 0 && !existingSides.has(side)) { store.hounds.push(createHound(side)); houndsToAdd--; } }
            }
            store.cheatDogHealCooldown = 10; announce('TEST: HEAL & HOUNDS');
        }
        
        // Handle poison effects
        if (p.isPoisoned && performance.now() > p.poisonEndTime) {
            p.isPoisoned = false;
            p.moveSpeed = 100; // Reset to base speed
        }
        
        // Check poison puddle collisions
        if (store.poisonPuddles) {
            store.poisonPuddles.forEach(puddle => {
                const dx = p.x - puddle.x;
                const dy = p.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < puddle.r + p.r) {
                    // Player is in poison puddle - apply damage and effects
                    if (!p.lastPuddleDamageTime || performance.now() - p.lastPuddleDamageTime > 500) {
                        takeDamage(puddle.damage);
                        p.lastPuddleDamageTime = performance.now();
                        
                        // Apply poison debuff
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 3000; // 3 second poison from puddle
                        p.moveSpeed = Math.max(p.moveSpeed * 0.8, 60); // Slow player more
                    }
                }
            });
        }

        // Check mech oil/fuel puddle collisions
        if (store.mechPuddles && store.mechPuddles.length > 0) {
            store.mechPuddles.forEach(puddle => {
                // Calculate current radius with shrinking effect
                const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
                const currentRadius = puddle.r * Math.max(0.3, lifePercent);
                
                const dx = p.x - puddle.x;
                const dy = p.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < currentRadius + p.r) {
                    // Player is in hazardous puddle - apply damage and burning effect
                    if (!p.lastMechPuddleDamageTime || performance.now() - p.lastMechPuddleDamageTime > 400) {
                        // console.log('Player in mech puddle! Taking', puddle.damage, 'damage');
                        takeDamage(puddle.damage);
                        p.lastMechPuddleDamageTime = performance.now();
                        
                        // Apply burning/slowing effect
                        p.isBurning = true;
                        p.burnEndTime = performance.now() + 2500; // 2.5 second burn effect
                        
                        // Create burning particle effect
                        for (let i = 0; i < 3; i++) {
                            store.flameParticles.push({
                                x: p.x + (Math.random() - 0.5) * 30,
                                y: p.y + (Math.random() - 0.5) * 30,
                                vx: (Math.random() - 0.5) * 100,
                                vy: -Math.random() * 150,
                                life: 1 + Math.random() * 0.5,
                                maxLife: 1 + Math.random() * 0.5,
                                r: 3 + Math.random() * 4
                            });
                        }
                    }
                }
            });
        }
    }
    function stepPowerups(dt) {
        const p = store.player;
        store.powerups.forEach(powerup => {
            // Handle powerup movement (for Trap King falling powerups)
            if (powerup.vx !== undefined || powerup.vy !== undefined) {
                powerup.x += (powerup.vx || 0) * dt;
                powerup.y += (powerup.vy || 0) * dt;
                
                // Handle powerup lifetime
                if (powerup.life !== undefined) {
                    powerup.life -= dt;
                    if (powerup.life <= 0) {
                        powerup.dead = true;
                        return;
                    }
                }
                
                // Remove powerups that go off screen
                if (powerup.x < -20 || powerup.x > W + 20 || powerup.y < -20 || powerup.y > H + 20) {
                    powerup.dead = true;
                    return;
                }
            }
            
            if (p.magnetRadius > 0) {
                const dx = p.x - powerup.x;
                const dy = p.y - powerup.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);
                
                // Auto-collect if very close to prevent vibration
                if (dist < p.r + powerup.r + 5) {
                    powerup.dead = true;
                    applyPowerup(powerup.type);
                    return;
                }
                
                if (distSq < p.magnetRadius * p.magnetRadius) {
                    const pullSpeed = 350;
                    powerup.x += (dx / dist) * pullSpeed * dt;
                    powerup.y += (dy / dist) * pullSpeed * dt;
                }
            }

            if (collide(p, powerup)) {
                powerup.dead = true;
                applyPowerup(powerup.type);
            }
        });
    }

    function detonateClusterRocket(m) {
        if (m.dead) return;
        m.dead = true;
        
        // Play cluster sound if this missile is marked for sound
        if (m.playSound) {
            playSound('cluster');
        }
        
        const baseRadius = 70; // Halved from 80
        const explosionRadius = store.player.enhancedClusters ? 120 : baseRadius;
        const chainRadius = 90;
        const microExplosionCount = 5;
        let aoeDmg = m.dmg * .8;
        if (store.player.subclass === 'demolitionist') {
            aoeDmg *= 1.5;  // OPTIONAL: Boost damage for demolitionist
        }
        for (let i = 0; i < microExplosionCount; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.random() * explosionRadius * 0.7;
            const ex = m.x + Math.cos(angle) * dist;
            const ey = m.y + Math.sin(angle) * dist;
            store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
        }
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(e => {
            if (!e.dead) {
                const distSq = (e.x - m.x)**2 + (e.y - m.y)**2;
                if (distSq < explosionRadius**2) {
                    let pulseDmg = aoeDmg;
                    const explosionTags = store.player.subclass === 'demolitionist' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                    const vulnExplosion = applySubclassVulnerability(e, pulseDmg, {
                        subclass: store.player.subclass,
                        player: store.player,
                        damageTags: explosionTags,
                        source: 'clusterDetonation',
                        projectile: m,
                        baseDamage: pulseDmg
                    });
                    pulseDmg = vulnExplosion.damage;
                    e.hp -= pulseDmg;
                    e.hp = Math.max(1, e.hp);
                    
                    // Apply vampirism healing for cluster damage
                    if (store.player.vampirism > 0) {
                        let healAmount = aoeDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for AoE
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for AoE
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            }
        });
        // Remove chain detonation to prevent rockets from exploding each other
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            if (m.chainDetonate && !m.dead) {
                detonateClusterRocket(m);
                return;
            }
            m.life += dt; if (m.life > 6) { m.dead = true; return; }
            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }
            
            // Track movement distance before updating position
            const prevX = m.x, prevY = m.y;
            m.x += m.vx * dt; m.y += m.vy * dt;
            
            // Update travel distance if we have start position
            if (m.startX !== undefined && m.startY !== undefined) {
                m.travelDistance = Math.sqrt((m.x - m.startX)**2 + (m.y - m.startY)**2);
            }
            
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            
            // For cluster rockets, check proximity detonation only when they should explode
            if (m.cluster && !m.pierce) {
                // Original cluster behavior - explode near enemies
                const proxRadiusSq = 15 * 15;
                for (const e of targets) {
                    if (!e.dead && ((m.x - e.x)**2 + (m.y - e.y)**2 < proxRadiusSq)) {
                        detonateClusterRocket(m);
                        return;
                    }
                }
            }
            
            // Handle collision with enemies
            for (const e of targets) {
                if (!e.dead && collide(m, e)) {
                    m.hits = (m.hits || 0) + 1;
                    
                    if (m.cluster && m.pierce > 0) {
                        // Hybrid cluster + piercing: Deal damage, pierce, then set up for delayed explosion
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        const missileTags = store.player.subclass === 'demolitionist' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                        const vulResPierce = applySubclassVulnerability(e, dmg, {
                            subclass: store.player.subclass,
                            player: store.player,
                            damageTags: missileTags,
                            source: 'pierceMissile',
                            projectile: m,
                            baseDamage: dmg
                        });
                        dmg = vulResPierce.damage;
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 6); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        m.pierce--;
                        
                        if (m.pierce <= 0) {
                            // No more pierces left - mark for delayed explosion
                            m.shouldExplodeAfterTravel = true;
                            m.minTravelTimeForExplosion = 0.5; // 0.5 seconds minimum travel time
                            m.travelTimeAfterLastHit = 0;
                        } else {
                            // Find next target for piercing
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else {
                                // No more targets - explode immediately
                                detonateClusterRocket(m);
                            }
                        }
                    } else if (m.cluster) {
                        // Pure cluster rocket - explode immediately
                        detonateClusterRocket(m);
                    } else {
                        // Regular missile logic (non-cluster)
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        const missileDamageTags = store.player.subclass === 'demolitionist' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                        const vulRes = applySubclassVulnerability(e, dmg, {
                            subclass: store.player.subclass,
                            player: store.player,
                            damageTags: missileDamageTags,
                            source: m.cluster ? 'clusterMissile' : 'missileImpact',
                            projectile: m,
                            baseDamage: dmg
                        });
                        dmg = vulRes.damage;
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        if ((store.player.subclass === 'railgunner' || store.player.missilePierce > 0) && m.pierce > 0) {
                            m.pierce--;
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else { m.dead = true; }
                        } else if (m.pierce > 0) {
                            m.pierce--;
                        } else {
                            m.dead = true;
                        }
                    }
                    if (m.dead) break;
                }
            }
            
            // Handle delayed explosion for cluster + pierce missiles
            if (m.shouldExplodeAfterTravel) {
                m.travelTimeAfterLastHit += dt;
                if (m.travelTimeAfterLastHit >= m.minTravelTimeForExplosion) {
                    // Check if we're near any enemies to explode
                    const explosionProximity = 60;
                    let shouldExplode = false;
                    for (const e of targets) {
                        if (!e.dead) {
                            const distSq = (m.x - e.x)**2 + (m.y - e.y)**2;
                            if (distSq < explosionProximity * explosionProximity) {
                                shouldExplode = true;
                                break;
                            }
                        }
                    }
                    if (shouldExplode) {
                        detonateClusterRocket(m);
                    }
                }
            }
        });
    }

    function stepLightning(dt) {
        store.lightningBolts.forEach(bolt => {
            bolt.life -= dt;
            if (bolt.life <= 0) { bolt.dead = true; }
        });
    }

    function stepEmpNovas(dt) {
        store.empNovas.forEach(nova => {
            // Expand the nova
            nova.radius += nova.speed * dt;
            if (nova.radius > nova.maxRadius) {
                nova.radius = nova.maxRadius;
            }
            
            // Countdown life
            nova.life -= dt;
            if (nova.life <= 0) {
                nova.dead = true;
                return;
            }
            
            // Check if player is within EMP range
            const dx = store.player.x - nova.x;
            const dy = store.player.y - nova.y;
            const distSq = dx * dx + dy * dy;
            const radiusSq = nova.radius * nova.radius;
            
            if (distSq <= radiusSq) {
                // Player is within EMP range - disable weapons
                store.player.empDisabled = true;
                store.player.empDisabledTimer = 0.5; // Sizzle effect duration
            }
        });
        
        // Update player EMP disabled state
        if (store.player.empDisabledTimer > 0) {
            store.player.empDisabledTimer -= dt;
            if (store.player.empDisabledTimer <= 0) {
                store.player.empDisabled = false;
            }
        }
    }

    function stepLasers(dt) {
        store.lasers.forEach(laser => {
            laser.life -= dt;
            if (laser.life <= 0) { laser.dead = true; return; }
            laser.prevX = laser.x; laser.prevY = laser.y;
            laser.x += laser.vx * dt; laser.y += laser.vy * dt;
            if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                const speed = Math.sqrt(laser.vx**2 + laser.vy**2);
                let newAngle;
                if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                else { newAngle = Math.PI + Math.random() * Math.PI; }
                laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                laser.hitEnemies.clear();
            }
            store.enemies.forEach(e => {
                if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) { 
                    const laserDmg = 1000 * store.player.dmgMult;
                    e.hp -= laserDmg; 
                    laser.hitEnemies.add(e); 

                    registerEnemyHit(e, {
                        angle: Math.atan2(e.y - laser.y, e.x - laser.x),
                        knockbackStrength: 90,
                        knockbackDuration: 0.08
                    });
                    
                    // Track damage dealt for beef shield system
                    if (store.player.pilotGenome === 'beef') {
                        store.player.beefShieldDamageDealt += laserDmg;
                    }
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = laserDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                        healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            });
            if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) { 
                const bossLaserDmg = 500 * store.player.dmgMult;
                store.boss.hp -= bossLaserDmg; 
                laser.hitEnemies.add(store.boss); 

                registerEnemyHit(store.boss, {
                    angle: Math.atan2(store.boss.y - laser.y, store.boss.x - laser.x),
                    knockbackStrength: 70,
                    knockbackDuration: 0.08
                });
                
                // Track damage dealt for beef shield system
                if (store.player.pilotGenome === 'beef') {
                    store.player.beefShieldDamageDealt += bossLaserDmg;
                }
                
                // Apply vampirism healing for laser damage on boss
                if (store.player.vampirism > 0) {
                    let healAmount = bossLaserDmg * store.player.vampirism;
                    healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                    healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                }
            }
        });
    }

    function stepMines(dt) {
        store.mines.forEach(mine => {
            if (mine.dead) return;
            mine.fuse -= dt;
            let detonate = mine.fuse <= 0;
            if (!detonate) {
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                for(const target of targets) { if(!target.dead && collide(mine, target)) { detonate = true; break; } }
            }
            if(detonate) { mine.dead = true; explodeMine(mine); }
        });
    }
    
    function stepFlameParticles(dt) {
        const activeCache = store._activeFlamesCache || (store._activeFlamesCache = []);
        activeCache.length = 0;

        for (let i = store.flameParticles.length - 1; i >= 0; i--) {
            const p = store.flameParticles[i];
            let alive = true;
            if (p.attachedEnemy) {
                if (p.attachedEnemy.dead) {
                    p.attachedEnemy = null;
                } else {
                    p.x = p.attachedEnemy.x;
                    p.y = p.attachedEnemy.y;
                    p.attachedEnemy.hp -= p.damage;
                    
                    // Apply vampirism healing for attached flame damage
                    if (store.player.vampirism > 0) {
                        let healAmount = p.damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.2); // Minimum 0.2 HP
                        healAmount = Math.min(healAmount, 1); // Cap at 1 HP
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    p.attachedEnemy.slowTimer = 2.0;
                }
            }
            if (p.update && !p.update(dt)) {
                store.flameParticles.splice(i, 1);
                alive = false;
            } else if (!p.update) {
                // Handle legacy flame particles without update function
                p.life -= dt;
                if (p.life <= 0) {
                    store.flameParticles.splice(i, 1);
                    alive = false;
                }
            }

            if (alive) {
                activeCache.push(p);
            }
        }
    }




    const EMPTY_FLAME_CACHE = Object.freeze([]);

    function getHivePuddleLifetime(base, variance, options = {}) {
        const { min = 4, waveBonusPer = 0.35, maxWaveBonus = 5 } = options;
        const wave = (store && store.world && typeof store.world.wave === 'number') ? store.world.wave : 1;
        const waveBonus = Math.min(Math.max(wave - 1, 0) * waveBonusPer, maxWaveBonus);
        const randomized = variance > 0 ? Math.random() * variance : 0;
        return Math.max(min, base + randomized + waveBonus);
    }

    const GOLDEN_ORB_CONFIG = Object.freeze({
        radius: 22,
        pickupRadius: 30,
        floatAmplitude: 12,
        floatSpeed: 2.4,
        homingSpeed: 430,
        homingAcceleration: 6.5,
        maxTrail: 16,
        trailLife: 0.32
    });

    function spawnGoldenSentinelOrbs(count = 3) {
        if (!store || !store.player) return;
        if (!store.goldenOrbs) store.goldenOrbs = [];

        const spawnPositions = [
            {
                x: clamp(W * 0.23, 80, W - 80),
                y: clamp(H - 170, 120, H - 110)
            },
            {
                x: clamp(W * 0.5, 80, W - 80),
                y: clamp(H - 135, 120, H - 105)
            },
            {
                x: clamp(W * 0.77, 80, W - 80),
                y: clamp(H - 190, 120, H - 115)
            }
        ];

        for (let i = 0; i < Math.min(count, spawnPositions.length); i++) {
            const pos = spawnPositions[i];
            const orb = {
                x: pos.x,
                y: pos.y,
                baseY: pos.y,
                r: GOLDEN_ORB_CONFIG.radius,
                pickupRadius: GOLDEN_ORB_CONFIG.pickupRadius,
                state: 'idle',
                floatPhase: Math.random() * Math.PI * 2,
                floatSpeed: GOLDEN_ORB_CONFIG.floatSpeed * (0.85 + Math.random() * 0.3),
                floatAmplitude: GOLDEN_ORB_CONFIG.floatAmplitude * (0.85 + Math.random() * 0.25),
                pulseOffset: Math.random() * Math.PI * 2,
                created: performance.now(),
                trail: [],
                speed: GOLDEN_ORB_CONFIG.homingSpeed
            };
            store.goldenOrbs.push(orb);
            store.activeEffects.push(createEffect('goldenOrbSpawn', orb.x, orb.y, orb.r * 2.2));
        }
    }

    function stepGoldenOrbs(dt) {
        const orbs = store.goldenOrbs;
        if (!orbs || orbs.length === 0) {
            return;
        }

        if (!store.boss) {
            orbs.length = 0;
            return;
        }

        const player = store.player;
        for (let i = orbs.length - 1; i >= 0; i--) {
            const orb = orbs[i];
            orb.floatPhase += orb.floatSpeed * dt;

            if (orb.state === 'idle') {
                orb.y = orb.baseY + Math.sin(orb.floatPhase) * orb.floatAmplitude;
                const dx = player.x - orb.x;
                const dy = player.y - orb.y;
                if ((dx * dx + dy * dy) <= orb.pickupRadius * orb.pickupRadius) {
                    orb.state = 'homing';
                    orb.vx = 0;
                    orb.vy = 0;
                    orb.trail.length = 0;
                    orb.heading = -Math.PI / 2;
                    playSound('stargun');
                }
            } else if (orb.state === 'homing') {
                const boss = store.boss;
                if (!boss) {
                    orbs.splice(i, 1);
                    continue;
                }

                const dx = boss.x - orb.x;
                const dy = boss.y - orb.y;
                const dist = Math.max(0.001, Math.hypot(dx, dy));
                const desiredVx = (dx / dist) * orb.speed;
                const desiredVy = (dy / dist) * orb.speed;
                const accel = GOLDEN_ORB_CONFIG.homingAcceleration;
                orb.vx = (orb.vx || 0) + (desiredVx - (orb.vx || 0)) * Math.min(1, accel * dt);
                orb.vy = (orb.vy || 0) + (desiredVy - (orb.vy || 0)) * Math.min(1, accel * dt);
                orb.x += orb.vx * dt;
                orb.y += orb.vy * dt;
                orb.heading = Math.atan2(orb.vy, orb.vx);

                if (!orb.trail) orb.trail = [];
                orb.trail.unshift({ x: orb.x, y: orb.y, life: GOLDEN_ORB_CONFIG.trailLife });
                if (orb.trail.length > GOLDEN_ORB_CONFIG.maxTrail) {
                    orb.trail.pop();
                }
                for (let t = orb.trail.length - 1; t >= 0; t--) {
                    orb.trail[t].life -= dt;
                    if (orb.trail[t].life <= 0) {
                        orb.trail.splice(t, 1);
                    }
                }

                if (dist <= (boss.r || 70) + 12) {
                    const damage = boss.hpMax * 0.2;
                    boss.hp = Math.max(0, boss.hp - damage);
                    store.world.totalDamage += damage;
                    store.activeEffects.push(createEffect('goldenOrbDetonation', orb.x, orb.y, 140));
                    playSound('explosion');
                    orbs.splice(i, 1);
                    if (boss.hp <= 0) {
                        handleBossDefeat();
                        return;
                    }
                }
            }
        }
    }

    function stepWorld(dt) {
        stepPlayer(dt);
        if (store.boss) {
            stepBoss(dt);
        }

        stepPowerups(dt);
        stepHounds(dt);
        updateGibs(dt);
        
        stepMissiles(dt);
        stepLasers(dt);
        stepMines(dt);
        stepFlameParticles(dt);
        stepLightning(dt);
        stepEmpNovas(dt);
        processWaveSpawnQueue(dt);
        processVulnerabilityEvents(dt);
        
        // Update beef shield system
        updateBeefShield();
        
        // Update mech oil/fuel puddles
        for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
            const puddle = store.mechPuddles[i];
            puddle.life -= dt;
            if (puddle.life <= 0) {
                store.mechPuddles.splice(i, 1);
            }
        }
        
        updateVoidStepSystems(store.enemies);
        updateImpactSystem();
    stepGoldenOrbs(dt);

        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        if (store.world.powerupCooldown > 0) {
            store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2));
        }

        let base = store.world.wave < 200 ? 1.065 : 1.04;
        // BETTER BALANCE: Even more gentle scaling
        let dmgScale;
        if (store.world.wave <= 10) {
            // Very gentle exponential growth for early game
            dmgScale = Math.pow(1.03, store.world.wave - 1); // Reduced from 1.05 to 1.03
        } else {
            // Minimal linear scaling after wave 10
            const wave10Scale = Math.pow(1.03, 9); // ~1.3x at wave 10
            const veryGentleGrowth = (store.world.wave - 10) * 0.02; // Only +2% per wave after 10
            dmgScale = wave10Scale * (1 + veryGentleGrowth);
        }
        // Apply collar bonus and late-game scaling to enemy damage
    const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
        const lateGameBonus = store.world.lateGameDamageScaling || 1;
        dmgScale *= collarBonus * lateGameBonus;
        // console.log(`Wave ${store.world.wave}: Damage scale = ${dmgScale.toFixed(2)} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x | LateGameBonus: ${lateGameBonus.toFixed(2)}x`);
        store.eBullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.gravity) { b.vy += b.gravity * dt; }
            if (b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
            
            // Check if poison blob hits ground
            if (b.type === 'poisonBlob' && b.y > H - 30) {
                // Create poison puddle on ground impact
                if (!store.poisonPuddles) store.poisonPuddles = [];
                store.poisonPuddles.push({
                    x: b.x,
                    y: H - 20,
                    r: 20 + Math.random() * 10,
                    life: getHivePuddleLifetime(5.5, 4.5, { min: 4.5, maxWaveBonus: 5.5 }),
                    damage: (b.dmg || 15) * 0.5,
                    created: performance.now()
                });
                b.dead = true;
            }
            
            // Check if mech volley hits ground or reaches target area - create puddle
            if (b.isMechVolley && (b.y >= b.targetY - 10 || b.y > H - 30)) {
                // Use intended target location for puddle placement
                const puddleX = b.targetX;
                const puddleY = b.targetY;
                
                // console.log('Mech volley landed! Creating puddle at target:', puddleX, puddleY);
                store.mechPuddles.push({
                    x: puddleX,
                    y: puddleY,
                    r: 10, // Much smaller puddles (half of 20)
                    maxR: 10, // Store original size for shrinking effect
                    life: 1.5, // Reduced to 1.5 seconds
                    maxLife: 1.5, // Store original life for shrinking calculation
                    damage: (b.dmg || 18) * 0.4, // 40% of original damage per tick
                    sourceId: b.sourceId, // Track which mech created this puddle
                    created: performance.now(),
                    pulseOffset: Math.random() * Math.PI * 2, // For animation
                    hp: 15, // Make puddles killable with small HP
                    hpMax: 15 // Store max HP
                });
                b.dead = true;
            }
            
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            if (collide(b, store.player)) {
                const p = store.player;
                if (p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                    p.rearGuardReady = false;
                    p.rearGuardCooldown = 8;
                    b.dead = true;
                    store.activeEffects.push(createEffect("rearGuardBlock"));
                } else {
                    // Check if this is a poison blob for special effects
                    if (b.type === 'poisonBlob') {
                        // Apply poison debuff to player
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 5000; // 5 second poison
                        p.moveSpeed = Math.max(p.moveSpeed * 0.7, 50); // Slow player
                        
                        // Create poison puddle at impact location
                        if (!store.poisonPuddles) store.poisonPuddles = [];
                        store.poisonPuddles.push({
                            x: b.x,
                            y: b.y,
                            r: 25,
                            life: getHivePuddleLifetime(5, 3, { min: 4.5, maxWaveBonus: 4 }),
                            damage: (b.dmg || 15) * 0.3,
                            created: performance.now()
                        });
                    }
                    
                    // Calculate fade-in damage multiplier for Death Engine bullet rain
                    let damageMultiplier = 1.0;
                    if (b.fadeInTime && b.spawnTime) {
                        const timeAlive = (performance.now() - b.spawnTime) / 1000;
                        damageMultiplier = Math.min(1.0, timeAlive / b.fadeInTime);
                    }
                    
                    takeDamage((b.dmg || 10) * damageMultiplier);
                    b.dead = true;
                }
            }
        });

        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) {
                    store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                    mine.dead = true;
                }
                if (collide(mine, store.player)) {
                    takeDamage(50 * dmgScale);
                    mine.dead = true;
                }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }


    const activeFlames = store._activeFlamesCache && store._activeFlamesCache.length ? store._activeFlamesCache : EMPTY_FLAME_CACHE;
    const flameCount = activeFlames.length;
        
        // CONSOLIDATED enemy processing - flame collision + movement in single loop for performance
        store.enemies.forEach(e => {
            if (e.dead) return;

            if (e.hitPulseTimer && e.hitPulseTimer > 0) {
                e.hitPulseTimer = Math.max(0, e.hitPulseTimer - dt);
            }

            if (e.hitShakeTimer && e.hitShakeTimer > 0) {
                e.hitShakeTimer = Math.max(0, e.hitShakeTimer - dt);
                if (e.hitShakeTimer <= 0) {
                    e.hitShakeIntensity = 0;
                }
            }

            if (e.topClampDelay !== undefined && e.topClampDelay > 0) {
                e.topClampDelay = Math.max(0, e.topClampDelay - dt);
            }

            if (e.spawnPhase === 'teleport') {
                const duration = Math.max(0.001, e.spawnDuration || 0.6);
                e.spawnTimer = (e.spawnTimer ?? duration) - dt;
                const timeRemaining = Math.max(0, e.spawnTimer);
                const progress = Math.min(1, 1 - timeRemaining / duration);
                const eased = 1 - Math.pow(1 - progress, 3);
                const startY = e.spawnStartY ?? (e.spawnTargetY ?? e.y);
                const targetY = e.spawnTargetY ?? e.y;
                e.y = startY + (targetY - startY) * eased;
                e.spawnOpacity = Math.min(1, Math.max(e.spawnOpacity ?? 0, eased * 1.1));
                e.vulnLastKnownPos = { x: e.x, y: e.y };
                if (e.spawnTimer <= 0) {
                    e.spawnPhase = null;
                    e.spawnOpacity = 1;
                    e.y = targetY;
                } else {
                    return;
                }
            } else {
                e.vulnLastKnownPos = { x: e.x, y: e.y };
                if (e.spawnOpacity !== undefined && e.spawnOpacity < 1) {
                    e.spawnOpacity = Math.min(1, e.spawnOpacity + dt * 2.2);
                }
            }

            if (e.jugPulseTimer) e.jugPulseTimer = Math.max(0, e.jugPulseTimer - dt);
            if (e.jugFearTimer) e.jugFearTimer = Math.max(0, e.jugFearTimer - dt);
            if (e.jugBurnTimer) {
                e.jugBurnTimer = Math.max(0, e.jugBurnTimer - dt);
                e.jugBurnTick = (e.jugBurnTick || 0) - dt;
                if (e.jugBurnTimer > 0 && e.jugBurnTick <= 0) {
                    const burnDamage = 10 * (store.player?.dmgMult || 1);
                    const appliedBurn = Math.min(burnDamage, Math.max(0, e.hp - 1));
                    e.hp -= appliedBurn;
                    e.jugBurnTick = 0.45;
                    store.activeEffects.push(createEffect('jugFearEmber', e.x, e.y, e.r || 20));
                }
            }
            if (e.railgunArmorTimer) e.railgunArmorTimer = Math.max(0, e.railgunArmorTimer - dt);
            if (e.phaseLockTimer) e.phaseLockTimer = Math.max(0, e.phaseLockTimer - dt);
            if (e.stormShockTimer) e.stormShockTimer = Math.max(0, e.stormShockTimer - dt);
            if (e.demolitionPulseWarmup) e.demolitionPulseWarmup = Math.max(0, e.demolitionPulseWarmup - dt);
            if (e.maraLaunchTimer) e.maraLaunchTimer = Math.max(0, e.maraLaunchTimer - dt);
            if (e.vulnerabilityPulseStrength) {
                e.vulnerabilityPulseStrength = Math.max(0, e.vulnerabilityPulseStrength - dt * 0.7);
            }
            
            // OPTIMIZED FLAME PARTICLE COLLISION - batch processing with early exit
            if (flameCount > 0) {
                for (let f = 0; f < flameCount; f++) {
                    const flame = activeFlames[f];
                    
                    const dx = flame.x - e.x;
                    const dy = flame.y - e.y;
                    
                    // Early distance culling - skip expensive collision if too far (increased threshold)
                    if (Math.abs(dx) > 120 || Math.abs(dy) > 120) continue;
                    
                    const distSq = dx * dx + dy * dy; // Skip sqrt - use squared distance
                    const collisionRadius = Math.max(5, flame.size + e.r - 50);
                    const collisionRadiusSq = collisionRadius * collisionRadius;
                    
                    if (distSq < collisionRadiusSq) {
                        e.stunTimer = Math.max(e.stunTimer || 0, 0.5);
                        e.hp -= flame.damage;
                        
                        // Apply vampirism healing for flamethrower damage
                        if (store.player.vampirism > 0) {
                            let healAmount = flame.damage * store.player.vampirism;
                            healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                            healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        e.isBurning = true;
                        setTimeout(() => { if (e) e.isBurning = false; }, 100);
                        break; // Exit early on first collision for performance
                    }
                }
            }
            
            // MOVEMENT AND AI UPDATES
            if (e.knockback) {
                // Handle different knockback formats
                if (e.knockback.vx !== undefined && e.knockback.vy !== undefined) {
                    // Beef charge knockback format
                    e.x += e.knockback.vx * dt;
                    e.y += e.knockback.vy * dt;
                    e.knockback.duration -= dt;
                    if (e.knockback.duration <= 0) e.knockback = null;
                } else if (e.knockback.x !== undefined && e.knockback.y !== undefined) {
                    // Blink ability knockback format
                    e.x += e.knockback.x * dt;
                    e.y += e.knockback.y * dt;
                    e.knockback.duration -= dt;
                    if (e.knockback.duration <= 0) e.knockback = null;
                }
                
                // Clamp enemies to screen boundaries so they don't get pushed off-screen
                const margin = e.r || 15; // Use enemy radius for margin, default to 15
                e.x = Math.max(margin, Math.min(W - margin, e.x));
                e.y = Math.max(margin, Math.min(H - margin, e.y));
                if (e.knockback && e.knockback.type === 'maraLaunch' && !e.maraImpactTriggered) {
                    if (e.x <= margin + 1 || e.x >= W - margin - 1 || e.y <= margin + 1 || e.y >= H - margin - 1) {
                        e.maraImpactTriggered = true;
                        store.activeEffects.push(createEffect('maraImpactShockwave', e.x, e.y, (e.r || 20) * 1.8));
                    }
                }
            } else if (e.stunTimer && e.stunTimer > 0) {
                e.stunTimer -= dt;
            } else {
                let speedMultiplier = (e.slowTimer > 0) ? 0.3 : 1.0;
                if (e.hitSlowTimer && e.hitSlowTimer > 0) {
                    const slowFactor = e.hitSlowFactor !== undefined ? e.hitSlowFactor : 0.85;
                    speedMultiplier *= Math.max(0.3, Math.min(1, slowFactor));
                    e.hitSlowTimer = Math.max(0, e.hitSlowTimer - dt);
                    if (e.hitSlowTimer <= 0) {
                        e.hitSlowFactor = 1;
                    }
                } else if (e.hitSlowFactor && e.hitSlowFactor !== 1 && (!e.hitSlowTimer || e.hitSlowTimer <= 0)) {
                    e.hitSlowFactor = 1;
                }
                if (e.slowTimer > 0) e.slowTimer -= dt;
                if (e.phaseLockTimer > 0) {
                    speedMultiplier *= e.phaseLockSlowFactor || 0.4;
                }
                if (e.stormShockTimer > 0) {
                    speedMultiplier *= 0.6;
                }

                if (e.type === 'construct_gold' || e.type === 'avian_hatchling') {
                    const dx = store.player.x - e.x, dy = store.player.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        e.x += (dx / dist) * e.v * speedMultiplier * dt;
                        e.y += (dy / dist) * e.v * speedMultiplier * dt;
                    }
                } else if (e.type === 'angler') {
                    const dx = store.player.x - e.x;
                    if (Math.abs(dx) > 10) e.x += Math.sign(dx) * 30 * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'manta') {
                    e.t += dt;
                    
                    // DISABLED DODGE SYSTEM - was causing enemies to jump off-screen and become unkillable
                    // Simple sinusoidal snake movement only
                    e.x = e.startX + e.amplitude * Math.sin(e.t * e.frequency);
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'void_champion') {
                    e.baseV = e.baseV || e.v;
                    e.t += dt;
                    if (e.ramming) {
                        e.x += e.dashVX * speedMultiplier * dt;
                        e.y += e.dashVY * speedMultiplier * dt;
                        e.dashDuration -= dt;
                        if (e.dashDuration <= 0) {
                            e.ramming = false;
                            e.v = e.baseV;
                            e.vx = (Math.random() < 0.5 ? -1 : 1) * (30 + Math.random() * 40);
                        }
                    } else {
                        e.v = e.baseV;
                        e.vx += Math.sin(e.t * 2.5) * 20 * dt;
                        e.x += (e.vx || 0) * speedMultiplier * dt;
                        e.y += e.v * speedMultiplier * dt;
                    }

                    if (!e.ramming) {
                        e.dashTimer -= dt;
                        if (e.dashTimer <= 0) {
                            const dx = store.player.x - e.x;
                            const dy = store.player.y - e.y;
                            const dist = Math.max(60, Math.sqrt(dx * dx + dy * dy));
                            e.dashVX = (dx / dist) * 260;
                            e.dashVY = (dy / dist) * 260;
                            e.dashDuration = 0.35;
                            e.ramming = true;
                            e.dashTimer = e.dashCooldown;
                        }
                    }

                    if (e.x < e.r) {
                        e.x = e.r;
                        e.vx = Math.abs(e.vx || 60);
                    } else if (e.x > W - e.r) {
                        e.x = W - e.r;
                        e.vx = -Math.abs(e.vx || 60);
                    }
                } else if (!e.isOrbiter) {
                    e.x += (e.vx || 0) * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else {
                    let orbitTarget = null;
                    if (e.orbitTargetId) {
                        orbitTarget = store.enemies.find(en => en.id === e.orbitTargetId && !en.dead);
                    }
                    if (!orbitTarget && store.boss && !store.boss.dead) {
                        orbitTarget = store.boss;
                    }

                    if (orbitTarget) {
                        if (!e.orbitCenter) e.orbitCenter = { x: orbitTarget.x, y: orbitTarget.y };
                        e.orbitCenter.x = orbitTarget.x;
                        e.orbitCenter.y = orbitTarget.y;
                        e.orbitAngle += e.orbitSpeed * speedMultiplier * dt;
                        e.x = e.orbitCenter.x + e.orbitRadius * Math.cos(e.orbitAngle);
                        e.y = e.orbitCenter.y + e.orbitRadius * Math.sin(e.orbitAngle);
                    } else {
                        e.dead = true;
                    }
                }
                if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
            }

            if (e.jugFearTimer > 0) {
                const dxFear = e.x - store.player.x;
                const dyFear = e.y - store.player.y;
                const distFear = Math.sqrt(dxFear * dxFear + dyFear * dyFear) || 1;
                const fleeSpeed = Math.max(90, (e.v || 60) * 1.9);
                e.x += (dxFear / distFear) * fleeSpeed * dt;
                e.y += (dyFear / distFear) * fleeSpeed * dt * 0.6;
            }

            if (e.stormShockTimer > 0) {
                e.x += (Math.random() - 0.5) * 35 * dt;
                e.y += (Math.random() - 0.5) * 35 * dt;
            }

            const boundaryMargin = e.r || 15;
            e.x = Math.max(boundaryMargin, Math.min(W - boundaryMargin, e.x));
            if (!e.topClampDelay || e.topClampDelay <= 0) {
                if (e.y < boundaryMargin) {
                    e.y = boundaryMargin;
                }
            }

            if (e.fireT > 0) e.fireT -= dt;
            if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                const damageMult = e.damageMult || 1;
                switch (e.type) {
                    case 'hunter': { 
                        const a=Math.atan2(store.player.y-e.y,store.player.x-e.x); 
                        const bullet = getEBulletFromPool({x:e.x,y:e.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:3,col:e.color,dmg:6*dmgScale*damageMult});
                        store.eBullets.push(bullet); 
                        e.fireT=1; break; 
                    }
                    case 'phantom': { 
                        const bullet = getEBulletFromPool({x:e.x,y:e.y,vx:0,vy:180,r:3,col:e.color,dmg:5*dmgScale*damageMult});
                        store.eBullets.push(bullet); 
                        e.fireT=e.fireCooldown; break; 
                    }
                    case 'mech': {
                        e.attackPhase = (e.attackPhase || 0) + 1;
                        // Changed from 50/50 to 85% lob attacks, 15% shoulder cannons for more frequent lobs
                        if (e.attackPhase % 7 === 1) {
                            // Shoulder cannon attack (less frequent now)
                            const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                            const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                            store.eBullets.push({ x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult });
                            const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                            store.eBullets.push({ x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult });
                        } else {
                            // Lob attack with randomized target location (more frequent now)
                            // Limit target area to stay on screen with reasonable arc
                            const randomOffsetX = (Math.random() - 0.5) * 300; // Reduced spread to 300 pixels
                            const targetX = Math.max(80, Math.min(W - 80, store.player.x + randomOffsetX)); // Keep well within bounds
                            
                            // Limit Y coordinate to prevent extreme arcs
                            const minY = Math.max(H * 0.5, e.y + 100); // Don't go too high above the mech
                            const maxY = H - 80;   // Stop well above bottom
                            const targetY = minY + Math.random() * (maxY - minY);
                            
                            const dx = targetX - e.x;
                            const dy = targetY - e.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Much slower projectile for visibility and reasonable arc
                            const timeToTarget = Math.max(1.5, dist / 120); // Slower speed = 120 instead of 180
                            const gravity = 250; // Reduced gravity for gentler arc
                            const vx = dx / timeToTarget;
                            const vy = (dy - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;
                            
                            store.eBullets.push({ 
                                x: e.x, y: e.y, vx: vx, vy: vy, r: 6, 
                                col: '#40e0d0', dmg: 18 * dmgScale * damageMult, // Turquoise projectile color to match mech
                                gravity: gravity, isMechVolley: true, sourceId: e.id,
                                targetX: targetX, targetY: targetY // Store intended target location
                            });
                        }
                        e.fireT = 0.8; break; // Much more frequent attacks - reduced from 1.2 to 0.8
                    }
                    case 'angler': { const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,r:4,col:e.color,dmg:15*dmgScale*damageMult, life: 5}); e.fireT = 2.5; break; }
                    case 'manta': { for(let i=-1; i<=1; i++) { const angle = (90 + i * 30) * Math.PI/180; store.eBullets.push({x:e.x, y:e.y, vx:Math.cos(angle)*150, vy:Math.sin(angle)*150, r:3, col:e.color, dmg:12*dmgScale*damageMult}); } e.fireT = 2.8; break; }
                    case 'void_champion': {
                        if (e.nextPattern === 'beam') {
                            const baseAngle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                            const spreads = [-0.25, 0, 0.25];
                            spreads.forEach((offset, idx) => {
                                const finalAngle = baseAngle + offset;
                                const speed = 210 + idx * 25;
                                store.eBullets.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: Math.cos(finalAngle) * speed,
                                    vy: Math.sin(finalAngle) * speed,
                                    r: 6,
                                    col: '#ffb3ff',
                                    dmg: 18 * dmgScale * damageMult,
                                    life: 5
                                });
                            });
                            e.nextPattern = 'burst';
                        } else {
                            const bolts = 8;
                            for (let i = 0; i < bolts; i++) {
                                const angle = (i / bolts) * Math.PI * 2;
                                store.eBullets.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: Math.cos(angle) * 150,
                                    vy: Math.sin(angle) * 150,
                                    r: 5,
                                    col: '#de6cff',
                                    dmg: 12 * dmgScale * damageMult,
                                    life: 4
                                });
                            }
                            e.nextPattern = 'beam';
                            // Trigger orbiting shards to fire immediately
                            store.enemies.forEach(minion => {
                                if (minion.orbitTargetId === e.id && !minion.dead) {
                                    minion.fireT = Math.min(minion.fireT || 0, 0.1);
                                }
                            });
                        }
                        e.fireT = e.fireCooldown || 1.8;
                        break;
                    }
                    case 'void_champion_orb': {
                        const angle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                        const speed = 220;
                        store.eBullets.push({
                            x: e.x,
                            y: e.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 4,
                            col: '#ff6ad5',
                            dmg: 6 * dmgScale * damageMult,
                            life: 4
                        });
                        e.fireT = e.fireCooldown || 1.1;
                        break;
                    }
                    default: { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:150,r:3,col:e.color,dmg:5*dmgScale*damageMult}); e.fireT=.5; }
                }
            }

            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) {
                const contactDmg = (e.contactDamage || 8) * dmgScale;
                takeDamage(contactDmg); // Reduced baseline from 15 to 8 for better balance
                store.world.gold += e.gold;
                e.dead = true;
            }
        });

        // BOSS flame collision (reuse pre-filtered active flames)
        if (store.boss && !store.boss.dead && flameCount > 0) {
            for (let f = 0; f < flameCount; f++) {
                const flame = activeFlames[f];
                
                const dx = flame.x - store.boss.x;
                const dy = flame.y - store.boss.y;
                
                // Early culling for boss collision
                if (Math.abs(dx) > 150 || Math.abs(dy) > 150) continue;
                
                const distSq = dx * dx + dy * dy;
                const collisionRadius = Math.max(10, flame.size + store.boss.r - 50);
                const collisionRadiusSq = collisionRadius * collisionRadius;
                
                if (distSq < collisionRadiusSq) {
                    store.boss.stunTimer = Math.max(store.boss.stunTimer || 0, 0.3);
                    const bossFlameDmg = flame.damage * 0.5;
                    store.boss.hp -= bossFlameDmg;
                    
                    // Apply vampirism healing for flamethrower damage on boss
                    if (store.player.vampirism > 0) {
                        let healAmount = bossFlameDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    store.boss.isBurning = true;
                    setTimeout(() => { if (store.boss) store.boss.isBurning = false; }, 100);
                    break; // Exit early after first collision
                }
            }
        }

        rebuildEnemySpatialIndex();
        const bossTarget = store.boss && !store.boss.dead ? store.boss : null;

        for (let bi = 0; bi < store.bullets.length; bi++) {
            const b = store.bullets[bi];
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.isSwirl) {
                b.life = (b.life || 0) + dt;
                b.x += Math.sin(b.life * 15) * 150 * dt;
            }
            if (b.isFlame) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
                b.particleSpawnT -= dt;
                if (b.particleSpawnT <= 0) {
                    b.particleSpawnT = b.isLavaChunk ? 0.1 : 0.05;
                    const life = 0.3 + Math.random() * 0.3, angle = Math.random() * 2 * Math.PI, speed = b.isLavaChunk ? 10 + Math.random() * 15 : 20 + Math.random() * 20;
                    b.particles.push({ x: 0, y: 0, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: life, maxLife: life, r: 1 + Math.random() * (b.isLavaChunk ? 1.5 : 2) });
                }
                b.particles = b.particles.filter(p => {
                    p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt;
                    return p.life > 0;
                });
            } else if (b.isLevelUpPulse) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
            }

            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            if (!b.dead && bossTarget && !bossTarget.dead && collide(b, bossTarget)) {
                handleBulletImpact(b, bossTarget);
            }

            if (!b.dead && store.enemies.length) {
                const searchRadius = getBulletSearchRadius(b);
                forEachEnemyNearby(b.x, b.y, searchRadius, enemy => {
                    if (enemy === bossTarget) return false;
                    if (!collide(b, enemy)) return false;
                    handleBulletImpact(b, enemy);
                    return b.dead && !b.pierce;
                });
            }
            
            // Check bullet collision with mech puddles (make puddles killable)
            if (!b.dead && store.mechPuddles) {
                for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
                    const puddle = store.mechPuddles[i];
                    const dx = b.x - puddle.x;
                    const dy = b.y - puddle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < puddle.r + (b.r || 2)) {
                        // Puddle hit by bullet - take damage
                        puddle.hp -= (b.dmg || 15);
                        
                        if (puddle.hp <= 0) {
                            // Puddle destroyed - award rewards
                            store.world.gold += 1;
                            store.world.xp += 1;
                            
                            // Small explosion effect
                            for (let j = 0; j < 5; j++) {
                                store.flameParticles.push({
                                    x: puddle.x + (Math.random() - 0.5) * 20,
                                    y: puddle.y + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 100,
                                    vy: -Math.random() * 100,
                                    life: 0.3 + Math.random() * 0.3,
                                    maxLife: 0.3 + Math.random() * 0.3,
                                    r: 2 + Math.random() * 3,
                                    update: function(dt) {
                                        this.life -= dt;
                                        this.x += this.vx * dt;
                                        this.y += this.vy * dt;
                                        this.vy += 200 * dt; // gravity
                                        return this.life > 0;
                                    },
                                    draw: function() {
                                        if (!ctx) return;
                                        const alpha = this.life / this.maxLife;
                                        ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                                        ctx.beginPath();
                                        ctx.arc(this.x, this.y, this.r * alpha, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                });
                            }
                            
                            // console.log('Puddle destroyed by bullet! +1 gold, +1 xp');
                            store.mechPuddles.splice(i, 1);
                        }
                        
                        if (!b.pierce) b.dead = true;
                        break;
                    }
                }
            }
        }

        updateStarProjectiles(dt);

        const p = store.player;
        const healthRatio = p.hp / p.hpMax;
        const lowHealthThreshold = 0.35;

        if (healthRatio < lowHealthThreshold) {
            if (!store.world.isLowHealth) {
                store.world.isLowHealth = true;
                store.heartbeatT = 5.0;
                // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                store.activeEffects.push(createEffect("heartbeatPulse"));
            } else {
                if (store.heartbeatT > 0) {
                    store.heartbeatT -= dt;
                } else {
                    store.heartbeatT = 5.0;
                    // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                    store.activeEffects.push(createEffect("heartbeatPulse"));
                }
            }
        } else if (store.world.isLowHealth) {
            store.world.isLowHealth = false;
        }

        // Optimized cleanup with object pooling
        removeDeadObjects(store.bullets, bullet => bulletPool.release(bullet));
        removeDeadObjects(store.eBullets, bullet => returnEBulletToPool(bullet));
        
        // Efficient removal for other arrays
        removeDeadObjects(store.enemies);
        removeDeadObjects(store.powerups);
        removeDeadObjects(store.mines);
        removeDeadObjects(store.missiles);
        removeDeadObjects(store.lasers);
        removeDeadObjects(store.flameParticles);
        removeDeadObjects(store.lightningBolts);
        removeDeadObjects(store.empNovas);
        
        // Handle active effects separately (different property name)
        compactInactiveEffects(store.activeEffects);

        if (!store.boss && store.enemies.length === 0) {
            // Add some delay before starting next wave to prevent rapid cycling
            if (!store.world.waveTransitionTimer) {
                store.world.waveTransitionTimer = performance.now();
                return;
            }
            
            // Wait at least 0.5 seconds before progressing to next wave
            if (performance.now() - store.world.waveTransitionTimer < 500) {
                return;
            }
            
            // console.log(`Wave ${store.world.wave} completed, transitioning to wave ${store.world.wave + 1}`);
            
            if (store.world.waveStartTime > 0 && store.world.wave > 1) {
                const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;
                
                // Guaranteed minimum collar stacks for any reasonable clear
                let collarStacksToAdd = 0;
                sanitizeCollarStacks();
                
                if (waveClearTime < 2) {
                    // Ultra-instant clear: +9 collar stacks (addresses missing 9 stack issue)
                    collarStacksToAdd = 9;
                    store.world.enemyDensityBonus *= 1.15;
                    store.world.xpMultiplier *= 1.1;
                    announce("üí• ULTRA-INSTANT CLEAR! COLLAR CRUSHES +9 üí•");
                } else if (waveClearTime < 4) {
                    // Instant clear: +6 collar stacks
                    collarStacksToAdd = 6;
                    store.world.enemyDensityBonus *= 1.1;
                    store.world.xpMultiplier *= 1.07;
                    announce("‚ö° INSTANT WAVE CLEAR! COLLAR TIGHTENS +6 ‚ö°");
                } else if (waveClearTime < 8) {
                    // Fast clear: +3 collar stacks
                    collarStacksToAdd = 3;
                    store.world.enemyDensityBonus *= 1.05;
                    store.world.xpMultiplier *= 1.03;
                    announce("‚ö° FAST WAVE CLEAR! COLLAR TIGHTENS +3 ‚ö°");
                } else if (waveClearTime < 12) {
                    // Normal clear: +1 collar stack
                    collarStacksToAdd = 1;
                    announce("‚ö° COLLAR TIGHTENS +1 ‚ö°");
                } else if (waveClearTime > 20) {
                    // Very slow clear: reset collar stacks (except during Death Engine fight)
                    const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
                    if (!isDeathEngineFight) {
                        const loosenedStacks = Math.max(0, sanitizeCollarStacks() - 2);
                        setCollarStacks(loosenedStacks);
                        announce("üêå SLOW CLEAR - COLLAR LOOSENS");
                    } else {
                        announce("THE DEATH ENGINE'S CURSE MAINTAINS THE COLLAR!");
                    }
                }
                
                // Add collar stacks only after 2nd boss is defeated - let first two bosses play normally
                collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
                if (store.world.bosses >= 2) {
                    if (collarStacksToAdd > 0) {
                        scheduleCollarIncrease(collarStacksToAdd);
                    } else {
                        approachCollarTarget();
                    }
                }
            }
            
            store.world.wave++;
            store.world.waveTransitionTimer = null; // Reset timer
            
            const hpBonus = 1;
            store.player.hpMax += hpBonus;
            store.player.hp += hpBonus;
            initWave();
        } else {
            // Reset wave transition timer if there are still enemies or boss
            store.world.waveTransitionTimer = null;
        }

        let xpNeeded = Math.floor(store.world.level * 100 * store.world.xpMultiplier * (store.world.level >= 8 ? 1.3 : store.world.level >= 4 ? 1.1 : 1) * (store.world.wave > 10 ? 1.3 : 1));
        if (store.world.xp >= xpNeeded) {
            store.world.xp -= xpNeeded;
            store.world.level++;
            levelUp();
        }

        // Collar decay system - prevent infinite stacking
        if (!store.world.collarDecayTimer) {
            store.world.collarDecayTimer = 0;
        }
        store.world.collarDecayTimer += dt;
        
        // Apply gradual collar decay every 10 seconds if stacks are high (only after 2nd boss, except during Death Engine fight)
        if (store.world.collarDecayTimer >= 10 && store.world.bosses >= 2) {
            store.world.collarDecayTimer = 0;
            
            // Don't decay collar stacks during Death Engine fight due to its intermission phases
            const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
            
            if (!isDeathEngineFight) {
                const currentStacks = sanitizeCollarStacks();
                if (currentStacks > 20) {
                    // Decay faster when collar stacks are very high
                    const decay = Math.max(0.5, currentStacks * 0.02);
                    const newStacks = Math.max(0, currentStacks - decay);
                    setCollarStacks(newStacks);
                    // High collar stacks decay applied
                } else if (currentStacks > 5) {
                    // Gentle decay for moderate stacks
                    const newStacks = Math.max(0, currentStacks - 0.3);
                    setCollarStacks(newStacks);
                }
            }
        }

        if (store.player.hp <= 0) {
            handleGameOver();
        }
    }





    // PERFORMANCE: Efficient dead object removal (300-500% faster than filter)
    function removeDeadObjects(array, disposer) {
        let writeIndex = 0;
        for (let readIndex = 0; readIndex < array.length; readIndex++) {
            const item = array[readIndex];
            if (!item || item.dead) {
                if (item && disposer) {
                    disposer(item);
                }
                continue;
            }

            if (writeIndex !== readIndex) {
                array[writeIndex] = item;
            }
            writeIndex++;
        }

        if (writeIndex < array.length) {
            array.length = writeIndex;
        }
    }

    function compactInactiveEffects(effects) {
        let writeIndex = 0;
        for (let readIndex = 0; readIndex < effects.length; readIndex++) {
            const effect = effects[readIndex];
            if (effect && effect.isActive !== false) {
                if (writeIndex !== readIndex) {
                    effects[writeIndex] = effect;
                }
                writeIndex++;
            }
        }

        if (writeIndex < effects.length) {
            effects.length = writeIndex;
        }
    }

    // Helper function to ensure progression tracking is initialized
    function initializeProgressionTracking() {
        const p = store.player;
        if (!p.totalProgressionPoints) p.totalProgressionPoints = 0;
        if (!p.unspentProgressionPoints) p.unspentProgressionPoints = 0;
        if (!p.skillPointsSpent) p.skillPointsSpent = 0;
        if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
            p.signatureAbilities = {};
        }
        p.signatureAbility = Object.keys(p.signatureAbilities).length > 0;
        
        // Ensure player always has skill points available for purchases (controlled by progression logic)
        if (!p.skillPoints || p.skillPoints <= 0) {
            p.skillPoints = 10; // Generous skill point pool, but availability controlled by progression
        }
    }

    // Helper function to spend progression points when abilities are successfully added
    function spendProgressionPoint() {
        initializeProgressionTracking();
        if (store.player.unspentProgressionPoints > 0) {
            store.player.unspentProgressionPoints -= 1;
            return true;
        }
        return false;
    }

    // Helper function for progression logic (used by both boss defeat and mech forge button)
    function checkProgressionLogic(awardPoint = false) {
        // Initialize progression tracking
        initializeProgressionTracking();
        
        // Award progression point if this is from boss defeat
        if (awardPoint) {
            store.player.totalProgressionPoints += 1;
            store.player.unspentProgressionPoints += 1;
        }
        
        const playerTotalPts = store.player.totalProgressionPoints;
        const playerUnspentPts = store.player.unspentProgressionPoints;
        const currentSpec = store.player.pilotGenome;
        const currentSubclass = store.player.subclass;
        
        // Progression logic following Python pattern
        if (playerTotalPts === 1 && playerUnspentPts > 0) {
            // First boss - open class select
            if (awardPoint) store.player.pilotGenome = 'pending';
            setTimeout(showPilotSelect, awardPoint ? 1000 : 0);
            return true;
        } else if (playerTotalPts > 1 && currentSpec && currentSpec !== 'pending' && !currentSubclass && playerUnspentPts > 0) {
            // Second+ boss with class selected but no subclass - open subclass select
            setTimeout(showSubclassSelect, awardPoint ? 1500 : 0);
            return true;
        } else if (playerTotalPts > 2 && currentSpec && currentSpec !== 'pending' && currentSubclass && playerUnspentPts > 0) {
            // Third+ boss with class and subclass - open skill tree
            setTimeout(showSkillTreeModal, awardPoint ? 1500 : 0);
            return true;
        }
        
        return false; // No progression available
    }

    function handleBossDefeat() {
        const now = performance.now();
        const bossSpawnTime = ensureFiniteNumber(store.world.bossSpawnTime, now);
        const fightDuration = ensureFiniteNumber((now - bossSpawnTime) / 1000, 0);
        
        // Use progression logic with point award
        checkProgressionLogic(true);
        
        const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
        store.world.score += Math.floor(2000 * collarBonus); store.world.gold += Math.floor(25 * collarBonus); store.world.xp += Math.floor(100 * collarBonus); store.world.bosses++;
        const bossX = store.boss.x;
        const bossY = store.boss.y;
        const bossName = store.boss.name; // Store boss name before nulling
        if (store.goldenOrbs) {
            store.goldenOrbs.length = 0;
        }
        
        // Clear any poison puddles and poison blobs from HIVE SOVEREIGN when boss is defeated
        if (store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        // Also clear poison blobs still in flight to prevent persistent puddles
        store.bullets = store.bullets.filter(b => {
            if (b.type === 'poisonBlob') {
                bulletPool.release(b);
                return false;
            }
            return true;
        });
        
        store.boss = null;
        announce('‚ö° GUARDIAN DEFEATED ‚ö°');
        explode(bossX, bossY, true);

        let healthBonusMultiplier = 1.0, announcedAdaptation = false;
        // Calculate collar stacks to add based on boss kill speed (more generous)
        let collarStacksToAdd = 0;
        sanitizeCollarStacks();
        
        if (fightDuration <= 2) {
            // Ultra-fast boss kill: massive collar bonus
            collarStacksToAdd = 12;
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            announce(`üí• COLLAR CRUSHES +${collarStacksToAdd} üí•`);
        } else if (fightDuration <= 5) {
            // Fast boss kill
            collarStacksToAdd = Math.max(8, Math.floor(12 - (fightDuration * 1.5)));
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            announce(`‚ö° COLLAR TIGHTENS +${collarStacksToAdd} ‚ö°`);
        } else if (fightDuration < 8) {
            // Decent boss kill
            collarStacksToAdd = Math.max(3, Math.floor(10 - fightDuration));
            announcedAdaptation = true; 
            healthBonusMultiplier = 1.15;
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            announce(`‚ö° COLLAR TIGHTENS +${collarStacksToAdd} ‚ö°`);
        } else if (fightDuration < 12) {
            // Slow boss kill: minimal collar bonus
            collarStacksToAdd = 1;
            announcedAdaptation = true; 
            healthBonusMultiplier = 1.05;
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            announce(`‚ö° COLLAR TIGHTENS +${collarStacksToAdd} ‚ö°`);
        } else {
            // Very slow kill: reduce collar stacks (except for DEATH ENGINE)
            if (bossName !== 'DEATH ENGINE') {
                const loosened = Math.max(0, sanitizeCollarStacks() - 3);
                setCollarStacks(loosened);
                announce("‚öñÔ∏è COLLAR LOOSENS - ADAPTATION WEAKENS");
            } else {
                announce("THE DEATH ENGINE'S CURSE PERSISTS!");
            }
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            healthBonusMultiplier = 1.0;
        }
        
        // Special handling for Death Engine - restore preserved collar stacks
        if (bossName === 'DEATH ENGINE' && store.world.deathEngineCollarStacks !== undefined) {
            const originalStacks = ensureFiniteNumber(store.world.deathEngineCollarStacks, sanitizeCollarStacks());
            const originalTarget = ensureFiniteNumber(store.world.deathEngineCollarTargetStacks, originalStacks);
            setCollarStacks(Math.max(0, originalStacks));
            store.world.collarTargetStacks = Math.min(MAX_COLLAR_STACKS, Math.max(store.world.collarStacks, originalTarget));
            const addAfterRestore = ensureFiniteNumber(collarStacksToAdd, 0);
            if (addAfterRestore > 0) {
                scheduleCollarIncrease(addAfterRestore);
            } else {
                approachCollarTarget();
            }
            delete store.world.deathEngineCollarStacks; // Clean up
            delete store.world.deathEngineCollarTargetStacks;
        } else {
            // Add collar stacks only after 2nd boss is defeated - collar system starts with 3rd boss
            collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
            if (store.world.bosses >= 2) {
                if (collarStacksToAdd > 0) {
                    scheduleCollarIncrease(collarStacksToAdd);
                } else {
                    approachCollarTarget();
                }
            }
        }
        // FIXED: Don't permanently modify health bonuses - collar handles this dynamically
        // Instead, only apply temporary density and XP bonuses based on performance
        if (announcedAdaptation) {
            // Only apply density bonuses, not permanent health increases
            if (healthBonusMultiplier > 1.3) {
                store.world.enemyDensityBonus *= 1.15;
            } else if (healthBonusMultiplier > 1.1) {
                store.world.enemyDensityBonus *= 1.10;
            } else if (healthBonusMultiplier > 1.0) {
                store.world.enemyDensityBonus *= 1.05;
            }
            setTimeout(() => announce("GUARDIAN DEFEATED!"), 1000);
        }
    }

    function explode(x, y, isBoss = false, isSmall = false) {
        playSound('explosion');
        if (isBoss) for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
        if (isSmall) {
            const radius = 60;
            const dmg = 25 * store.player.dmgMult;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            targets.forEach(e => {
                if (!e.dead) {
                    const distSq = (e.x - x)**2 + (e.y - y)**2;
                    if (distSq < radius**2) {
                        e.hp -= dmg;
                        store.world.totalDamage += dmg;
                        
                        // Track damage dealt for beef shield system
                        if (store.player.pilotGenome === 'beef') {
                            store.player.beefShieldDamageDealt += dmg;
                        }
                        
                        // Apply vampirism healing for explosion damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP
                            healAmount = Math.min(healAmount, 2); // Cap at 2 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                    }
                }
            });
            store.activeEffects.push(createEffect("grenadeExplosion", x, y, radius));
        }
    }
    
    function levelUp() {
        announce(`LEVEL UP! ‚ö° CHOOSE YOUR AUGMENTATION!`);
        pauseGame();
        
        // Natural health growth: 10% per level
        const healthGrowth = store.player.hpMax * 0.1;
        store.player.hpMax += healthGrowth;
        store.player.hp += healthGrowth;
        
        store.player.isInvincible = true;
        const speedBoost = store.player.speed * 0.75;
        const fireRateBoost = store.player.fireRate * 0.5;
        store.player.speed += speedBoost;
        store.player.fireRate -= fireRateBoost;

        const levelUpPulse = () => {
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 300;
                spawnBullet({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 4,
                    col: '#ffddff',
                    dmg: 30 * p.dmgMult,
                    pierce: true,
                    life: 1.5,
                    isLevelUpPulse: true
                });
            }
        };

        levelUpPulse();
        setTimeout(levelUpPulse, 250);

        // Store timeout ID to prevent multiple level-ups causing permanent bonuses
        if (store.levelUpTimeoutId) {
            clearTimeout(store.levelUpTimeoutId);
        }
        
        store.levelUpTimeoutId = setTimeout(() => {
            store.player.isInvincible = false;
            store.player.speed -= speedBoost;
            store.player.fireRate += fireRateBoost;
            store.levelUpTimeoutId = null;
        }, 3000);

        const panel = q('levelPanel'), grid = q('skillsGrid');
        const availableUpgrades = LEVEL_UPGRADES.filter(u => {
            if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
            // Check if upgrade has availability function
            if (u.available && typeof u.available === 'function') return u.available();
            return true;
        });

        for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; }
        const choices = availableUpgrades.slice(0, 3);
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        const cards = grid.querySelectorAll('.skill-card');
        const clickHandler = (e) => {
            const card = e.currentTarget;
            const id = card.dataset.id; 
            const upgrade = LEVEL_UPGRADES.find(s => s.id === id);
            if (upgrade) upgrade.apply(); 
            panel.classList.add('hide');
            resumeGame();
            // Clean up event listeners to prevent UI freeze
            cards.forEach(c => c.removeEventListener('click', clickHandler));
        };
        
        cards.forEach(card => {
            card.addEventListener('click', clickHandler);
        });

        panel.classList.remove('hide');
    }
    
    function handleGameOver() {
        if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score);
        announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide');
    }
    
    function resetGame() {
        store.player = JSON.parse(JSON.stringify(player_initial_state));
        
        // Ensure dmgMult is initialized
        if (!store.player.dmgMult) store.player.dmgMult = 1;
    
        store.world = { 
            wave: 1, 
            score: 0, 
            gold: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            lateGameDamageScaling: 1,
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            totalDamage: 0,
            damageStartTime: performance.now(),
            lastThreatScale: 1,
            lastSpawnOverflow: 0,
            lastPlannedSpawnCount: 0,
            lastSpawnCount: 0,
            lastSpawnFallback: false,
            lastSpawnQueueLength: 0,
            lastSpawnTempo: 0,
            firstBossOrbsGifted: false
        };
        
        if (store.bullets && store.bullets.length) {
            store.bullets.forEach(bullet => bulletPool.release(bullet));
        }
        if (store.eBullets && store.eBullets.length) {
            store.eBullets.forEach(returnEBulletToPool);
        }
    store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = []; store.powerups = []; store.starProjectiles = []; store.pendingStarClones = [];
        store.drones = []; store.hounds = []; store.missiles = []; store.lasers = []; store.mines = []; store.activeEffects = []; store.flameParticles = [];
        store.lightningBolts = []; store.empNovas = []; store.poisonPuddles = []; store.goldenOrbs = [];
        store.iceman = null;
        store.waveSpawnQueue = [];
        store.pendingSpawnCount = 0;
        store._startTs = performance.now(); store.isGameOver = false;
        store.cheatsUsed = false;
        store.cheatInvincibilityCooldown = 0;
        store.cheatDogHealCooldown = 0;
        shopItemOrder = [];
        q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide'); 
        q('subclassPanel').classList.add('hide');
        ensureName();
    }

    // --- RENDER & DRAW FUNCTIONS ---
    const starCountA = 100, starCountB = 80;
    const starsA = Array.from({ length: starCountA }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.5, pulse: Math.random() * 10 }));
    const starsB = Array.from({ length: starCountB }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 2, pulse: Math.random() * 10 }));

    // Optimized background star rendering
    function renderBackgroundStars(dt) {
        // Batch star operations to reduce context state changes
        ctx.globalAlpha = 0.8;
        
        // Render starsA in a single pass
        for (let i = 0; i < starsA.length; i++) {
            const s = starsA[i];
            s.y += 30 * dt; 
            if (s.y > H) s.y -= H;
            
            const alpha = 0.5 + 0.5 * Math.sin(frameTime * 2 + s.pulse);
            ctx.fillStyle = `rgba(255,0,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, 6.283185307179586); // Use constant instead of Math.PI * 2
            ctx.fill();
        }
        
        ctx.globalAlpha = 0.6;
        
        // Render starsB in a single pass
        for (let i = 0; i < starsB.length; i++) {
            const s = starsB[i];
            s.y += 60 * dt; 
            if (s.y > H) s.y -= H;
            
            const pulse = Math.sin(frameTime * 1.5 + s.pulse);
            const alpha = 0.4 + 0.6 * pulse;
            const radius = Math.max(0.1, s.r * (0.4 + 0.6 * pulse));
            
            ctx.fillStyle = `rgba(204,0,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, radius, 0, 6.283185307179586);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
    }

// Cache for gradient objects to avoid recreation
let poisonGradientCache = new Map();
let mechGradientCache = new Map();
let frameTime = 0;
let frameCount = 0;

// Clear caches periodically to prevent memory buildup
function clearGradientCaches() {
    if (frameCount % 1000 === 0) { // Clear every ~17 seconds at 60fps
        poisonGradientCache.clear();
        mechGradientCache.clear();
    }
}

function render(dt) {
    frameCount++;
    clearGradientCaches();
    
    // Performance optimization: Use faster fill method and cache time calculation
    ctx.fillStyle = '#050008'; 
    ctx.fillRect(0, 0, W, H);
    frameTime = performance.now() / 1000;
    
    // Render background stars with optimized drawing
    renderBackgroundStars(dt);
    


    const closeBullets = [];
    const farBullets = [];
    const proximityThreshold = 110;
    const playerPos = store.player;

    store.eBullets.forEach(b => {
        const distSq = (b.x - playerPos.x)**2 + (b.y - playerPos.y)**2; 
        if (distSq < proximityThreshold**2) {
            closeBullets.push({ bullet: b, dist: Math.sqrt(distSq) });
        } else {
            farBullets.push(b);
        }
    });
    
    store.powerups.forEach(p => drawPowerup(p));
    drawGoldenOrbs();
    store.missiles.forEach(m => drawMissile(m));
    store.lightningBolts.forEach(l => drawLightningBolt(l));
    store.empNovas.forEach(n => drawEmpNova(n));
    drawStarProjectiles();


    // Optimized far bullets rendering with batched operations
    for (let i = 0; i < farBullets.length; i++) {
        const b = farBullets[i];
        
        // Apply visual fade-in for Death Engine bullet rain
        let alpha = 1.0;
        if (b.fadeInTime && b.spawnTime) {
            const timeAlive = (performance.now() - b.spawnTime) / 1000;
            alpha = Math.min(1.0, timeAlive / b.fadeInTime);
        }
        
        if (alpha < 1.0) {
            ctx.save();
            ctx.globalAlpha = alpha;
        }
        
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, 6.283185307179586); // Use constant
        ctx.fill();
        
        if (alpha < 1.0) {
            ctx.restore();
        }
    }
    
    store.bullets.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.fillStyle = b.col;
        ctx.beginPath();
        
        const r = b.r * 1.5;

        if (b.isLavaChunk) {
            ctx.beginPath();
            ctx.moveTo(0, -r); ctx.lineTo(r, r * 0.2); ctx.lineTo(r * 0.5, r); ctx.lineTo(-r * 0.5, r); ctx.lineTo(-r, r * 0.2);
            ctx.closePath();
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const particleR = p.r * t;
                ctx.fillStyle = `rgba(255, ${60 + Math.random() * 60}, 0, ${0.7 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isFlame) {
            ctx.fillStyle = `rgba(255, 150, 50, ${0.3 * (b.life / 50)})`;
            ctx.beginPath();
            ctx.arc(0, 0, b.r * 0.5, 0, 2 * Math.PI);
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const r_particle = p.r * t;
                const g = Math.floor(255 * (0.4 + t * 0.6));
                const b_val = Math.floor(100 * t);
                ctx.fillStyle = `rgba(${g}, ${b_val}, 0, ${0.8 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r_particle, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isSwirl || b.explosive) {
            ctx.arc(0, 0, b.r, 0, 2 * Math.PI);
        } else if (b.isIceman) {
            ctx.moveTo(0, r); ctx.lineTo(r * 0.8, -r * 0.8); ctx.lineTo(-r * 0.8, -r * 0.8);
        } else {
            ctx.moveTo(0, -r); ctx.lineTo(r * 0.8, r * 0.8); ctx.lineTo(-r * 0.8, r * 0.8);
        }

        ctx.closePath();
        ctx.fill();
        ctx.restore();
    });

    store.lasers.forEach(l => drawLaser(l));
    store.mines.forEach(m => drawMine(m));
    if (store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(frameTime * 5)})`; ctx.fill(); ctx.restore(); });
    
    // Draw poison puddles - optimized
    if (store.poisonPuddles) {
        store.poisonPuddles.forEach(puddle => {
            const age = (frameTime * 1000 - puddle.created) / 1000;
            const maxAge = puddle.life + (15 - puddle.life); // Total possible age
            
            ctx.save();
            ctx.translate(puddle.x, puddle.y);
            
            // Animate puddle bubbling - cache sin calculation
            const bubbleOffset = Math.sin(frameTime * 3 + puddle.x * 0.01) * 2;
            
            // Create toxic glow effect - cache gradient by radius
            const glowRadius = puddle.r * 1.5;
            const radiusKey = Math.round(glowRadius);
            let gradient = poisonGradientCache.get(radiusKey);
            if (!gradient) {
                gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                gradient.addColorStop(0, 'rgba(124, 252, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(173, 255, 47, 0.5)');
                gradient.addColorStop(1, 'rgba(124, 252, 0, 0)');
                poisonGradientCache.set(radiusKey, gradient);
            }
            
            const glowAlpha = 0.3 * (puddle.life / 15) + 0.2 * Math.sin(frameTime * 4);
            ctx.globalAlpha = glowAlpha;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // Draw the puddle itself
            const puddleAlpha = Math.max(0.4, puddle.life / 15);
            ctx.fillStyle = `rgba(45, 80, 22, ${puddleAlpha})`;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, puddle.r, 0, Math.PI * 2);
            ctx.fill();
            
            // Add surface texture/ripples
            ctx.strokeStyle = `rgba(124, 252, 0, ${puddleAlpha * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const rippleRadius = puddle.r * (0.3 + i * 0.3) + Math.sin(frameTime * 2 + i) * 3;
                const rippleAlpha = puddleAlpha * (0.8 - i * 0.2);
                ctx.globalAlpha = rippleAlpha;
                ctx.arc(0, bubbleOffset, rippleRadius, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Add occasional toxic bubbles - use time-based approach to reduce randomness
            if (Math.sin(frameTime * 8 + puddle.x * 0.1) > 0.8) {
                const bubbleX = Math.sin(frameTime * 3 + puddle.x) * puddle.r * 0.3;
                const bubbleY = Math.cos(frameTime * 2.5 + puddle.y) * puddle.r * 0.3 + bubbleOffset;
                const bubbleSize = 2 + Math.abs(Math.sin(frameTime * 4 + puddle.x)) * 3;
                
                const bubbleAlpha = 0.6 + Math.abs(Math.cos(frameTime * 5 + puddle.y)) * 0.4;
                ctx.fillStyle = `rgba(124, 252, 0, ${bubbleAlpha})`;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    // Draw mech oil/fuel puddles with aqua color scheme - optimized
    if (store.mechPuddles) {
        store.mechPuddles.forEach(puddle => {
            ctx.save();
            ctx.translate(puddle.x, puddle.y);
            
            // Create flickering aqua energy effect - use cached time
            const flicker = 0.8 + Math.sin(frameTime * 6) * 0.2;
            const pulseOffset = Math.sin(frameTime * 4 + puddle.x * 0.02) * 1.5;
            
            // Calculate shrinking effect as puddle disappears
            const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
            const currentRadius = puddle.r * Math.max(0.3, lifePercent); // Shrink to 30% min size
            
            // Create aqua hazardous glow effect - cache gradient by radius
            const glowRadius = currentRadius * 1.4;
            const radiusKey = Math.round(glowRadius);
            let gradient = mechGradientCache.get(radiusKey);
            if (!gradient) {
                gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 1)'); // Bright cyan
                gradient.addColorStop(0.6, 'rgba(32, 178, 170, 0.7)'); // Light sea green
                gradient.addColorStop(1, 'rgba(0, 139, 139, 0)'); // Dark cyan fade
                mechGradientCache.set(radiusKey, gradient);
            }
            
            const glowAlpha = 0.4 * lifePercent * flicker;
            ctx.globalAlpha = glowAlpha;
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, pulseOffset, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw the puddle base (dark aqua/teal liquid) with shrinking
            const puddleAlpha = Math.max(0.6, lifePercent);
            ctx.fillStyle = `rgba(14, 75, 92, ${puddleAlpha})`; // Dark aqua blue base
            ctx.beginPath();
            ctx.arc(0, pulseOffset, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Add aqua energy surface effects with shrinking
            ctx.strokeStyle = `rgba(64, 224, 208, ${puddleAlpha * 0.9})`; // Turquoise ripples
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < 2; i++) {
                const energyRadius = Math.max(0.1, currentRadius * (0.4 + i * 0.3) + Math.sin(frameTime * 3 + i * 2) * 2);
                const energyAlpha = puddleAlpha * (0.7 - i * 0.3) * flicker;
                ctx.globalAlpha = energyAlpha;
                ctx.arc(0, pulseOffset, energyRadius, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Add occasional aqua energy bubbles (only if puddle is large enough)
            if (currentRadius > 5 && Math.random() < 0.15) {
                const bubbleX = (Math.random() - 0.5) * currentRadius * 0.8;
                const bubbleY = (Math.random() - 0.5) * currentRadius * 0.8 + pulseOffset;
                const bubbleSize = 1 + Math.random() * 2;
                
                ctx.fillStyle = `rgba(0, 255, 255, ${0.8 + Math.random() * 0.2})`; // Bright cyan bubbles
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    store.enemies.forEach(e => drawEnemy(e));
    drawGibs(ctx); // <-- ADD THIS LINE TO DRAW THE GIBS
    if (store.boss && store.boss.visible !== false) drawBoss(store.boss);
    store.flameParticles.forEach(p => { if (p.draw) p.draw(); });
    store.drones.forEach(d => drawDrone(d));
    store.hounds.forEach(h => drawHound(h));
    if (store.iceman) drawIceman(store.iceman);
    drawShip(store.player.x, store.player.y, store.player);
    
    // Draw EMP disabled effect on player
    if (store.player.empDisabled) {
        const sizzleIntensity = 0.5 + 0.5 * Math.sin(frameTime * 15);
        
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        
        // Electric sparks around player
        ctx.strokeStyle = `rgba(255, 140, 0, ${sizzleIntensity})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 8;
        
        for (let i = 0; i < 8; i++) {
            if (Math.random() < 0.7) {
                const angle = (i / 8) * Math.PI * 2 + frameTime * 5;
                const radius = store.player.r + 5;
                const x1 = Math.cos(angle) * radius;
                const y1 = Math.sin(angle) * radius;
                const x2 = x1 + (Math.random() - 0.5) * 15;
                const y2 = y1 + (Math.random() - 0.5) * 15;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        // Purple inner glow
        ctx.fillStyle = `rgba(138, 43, 226, ${sizzleIntensity * 0.3})`;
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(0, 0, store.player.r * 1.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Draw poison effect on player
    if (store.player.isPoisoned) {
        const poisonAlpha = 0.3 + 0.2 * Math.sin(frameTime * 8);
        
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = `rgba(0, 255, 0, ${poisonAlpha})`;
        ctx.beginPath();
        ctx.arc(store.player.x, store.player.y, store.player.r + 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Add poison particle effect around player
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        for (let i = 0; i < 6; i++) {
            const angle = frameTime * 2 + i * Math.PI / 3;
            const x = Math.cos(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
            const y = Math.sin(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
            
            ctx.fillStyle = `rgba(124, 252, 0, ${0.4 + 0.3 * Math.sin(frameTime * 6 + i)})`;
            ctx.beginPath();
            ctx.arc(x, y, 2 + Math.sin(frameTime * 5 + i), 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
// ...existing code...
    // Draw voidmancer laser beam
    if (store.player.hasVoidLaser && store.player.voidLaserTarget && !store.player.voidLaserTarget.dead) {
        const p = store.player;
        const target = p.voidLaserTarget;
        
        // Determine laser color based on player ship color
        let laserColor = '#b266ff'; // Default purple
        switch (p.subclass) {
            case 'juggernaut':
                laserColor = '#ff3333';
                break;
            case 'marauder':
                laserColor = '#33cc33';
                break;
            case 'railgunner':
                laserColor = '#ff6600';
                break;
            case 'demolitionist':
                laserColor = '#ff4500';
                break;
            case 'phasestriker':
                laserColor = '#9900ff';
                break;
            case 'stormcaller':
                laserColor = '#00ccff';
                break;
        }
        
        const time = performance.now() / 1000;
        const pulseAlpha = 0.6 + 0.4 * Math.sin(time * 12);
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Calculate ramping size for level 2 phasestriker
        let baseLineWidth = 3;
        let glowLineWidth = 6;
        
        if (p.phasestRikerLevel >= 2) {
            const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // Same ramp as damage
            const sizeMultiplier = Math.min(rampMultiplier, 3.0); // Cap at 3x size
            baseLineWidth *= sizeMultiplier;
            glowLineWidth *= sizeMultiplier;
        }
        
        // Draw laser beam(s) - double beam for level 4 phasestriker
        const beamCount = (p.phasestRikerLevel >= 4 && p.doubleBeam) ? 2 : 1;
        const beamOffsets = beamCount === 2 ? [-8, 8] : [0]; // Parallel beams offset left and right
        
        for (let i = 0; i < beamCount; i++) {
            const offsetX = beamOffsets[i];
            
            // Draw main laser beam
            ctx.strokeStyle = laserColor;
            ctx.globalAlpha = pulseAlpha;
            ctx.lineWidth = baseLineWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + offsetX, p.y - 12);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
            
            // Draw laser glow effect - create gradient here
            const gradient = ctx.createLinearGradient(p.x + offsetX, p.y - 12, target.x, target.y);
            gradient.addColorStop(0, laserColor + '40');
            gradient.addColorStop(1, laserColor + '80');
            
            ctx.strokeStyle = gradient;
            ctx.globalAlpha = pulseAlpha * 0.5;
            ctx.lineWidth = glowLineWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + offsetX, p.y - 12);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
        }
        
        // Add impact effect at target
        ctx.fillStyle = laserColor;
        ctx.globalAlpha = pulseAlpha;
        ctx.beginPath();
        ctx.arc(target.x, target.y, 4 + Math.sin(time * 8) * 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
// ...existing code...
    
    
    closeBullets.forEach(item => {
        const b = item.bullet;
        const dist = item.dist;
        
        // Apply fade-in for Death Engine bullet rain
        let fadeAlpha = 1.0;
        if (b.fadeInTime && b.spawnTime) {
            const timeAlive = (performance.now() - b.spawnTime) / 1000;
            fadeAlpha = Math.min(1.0, timeAlive / b.fadeInTime);
        }
        
        const proxFactor = 1.0 - (dist / proximityThreshold);

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = proxFactor * fadeAlpha; 
        const glowRadius = b.r * 2;
        const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
        gradient.addColorStop(0.3, b.col);
        gradient.addColorStop(1, b.col + '00');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = fadeAlpha;
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255, 255, 255, ${proxFactor * 0.8 * fadeAlpha})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
    
    store.activeEffects.forEach(e => e.draw && e.draw());
    renderVoidStepSystems(ctx);
    renderImpactSystem(ctx);
    
    // Throttle HUD updates to avoid layout thrashing on every frame
    if (!window.lastHudUpdate || Date.now() - window.lastHudUpdate > 16) { // ~60fps
        updateHUD();
        window.lastHudUpdate = Date.now();
    }
}
    
    function takeDamage(dmg) {
        if (store.player.isInvincible || playerIsInvulnerable()) return;
        // Removed boss invincibility check here - that was preventing ALL damage incorrectly

        if (store.player.hasShieldBubble) {
            store.player.hasShieldBubble = false;
            store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
            return;
        }
        const p = store.player;
        
        // Beef shield takes damage first if pilot is beef
        if (p.pilotGenome === 'beef' && p.beefShield > 0 && p.beefShieldCooldown <= 0) {
            const beefAbsorbed = Math.min(p.beefShield, dmg);
            p.beefShield -= beefAbsorbed;
            dmg -= beefAbsorbed;
            p.beefShieldDamageTaken += beefAbsorbed;
            
            // If beef shield was depleted, start cooldown
            if (p.beefShield <= 0) {
                p.beefShieldCooldown = 2.0; // 2 second cooldown before shield can absorb again
            }
            
            if (dmg <= 0) return; // All damage absorbed by beef shield
        }
        
        const a = Math.min(p.shield, dmg);
        if (a < dmg) playSound('hit');
        p.shield -= a;
        dmg -= a;
        
        // Check for nano save BEFORE applying damage
        const hpAfterDamage = p.hp - dmg;
        if (hpAfterDamage <= 0 && p.nanoSaves > 0) {
            p.nanoSaves--;
            const revivedHp = Math.max(p.hpMax * 0.3, hpAfterDamage + p.hpMax * 0.35);
            p.hp = Math.max(1, Math.min(p.hpMax, revivedHp));
            store.activeEffects.push(createEffect("nanoHeal"));
            announce('NANO SAVE ACTIVATED!');
            return; // Don't apply the lethal damage
        }
        
        p.hp = Math.max(0, hpAfterDamage);

        if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
            store.world.lowHealthTutorialShown = true;
            showShopWithHighlight();
        }
    }
    
    function updateBeefShield() {
        if (store.player.pilotGenome !== 'beef') return;
        
        const p = store.player;
        const damageDealt = p.beefShieldDamageDealt;
        const damageTaken = p.beefShieldDamageTaken;
        
        // Skip if no damage events
        if (damageDealt === 0 && damageTaken === 0) return;
        
        // Update cooldown
        if (p.beefShieldCooldown > 0) {
            p.beefShieldCooldown -= 0.016; // Decrease by ~1/60 (assuming 60 FPS)
            if (p.beefShieldCooldown < 0) p.beefShieldCooldown = 0;
        }
        
        // Growth rate: 1 shield per 50 damage dealt, shrinkage rate: 1 shield per 30 damage taken
        // Made more responsive for better gameplay feel
        const shieldChange = (damageDealt * 0.02) - (damageTaken * 0.033);
        
        if (shieldChange > 0) {
            // Shield grows
            p.beefShield = Math.min(p.beefShieldMax, p.beefShield + shieldChange);
        } else if (shieldChange < 0) {
            // Shield shrinks (but not below 0)
            p.beefShield = Math.max(0, p.beefShield + shieldChange);
        }
        
        // Reset damage tracking counters
        p.beefShieldDamageDealt = 0;
        p.beefShieldDamageTaken = 0;
        

    }
    
    function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function announce(text) { const el = q('announce'); el.textContent = text; el.classList.remove('hide'); clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); }
// ...existing code...
    function updateHUD() { 
        const t = store.player;
        const hpPercent = Math.round(t.hp / t.hpMax * 100);
        const shieldPercent = t.shieldMax > 0 ? Math.round(t.shield / t.shieldMax * 100) : 0;
        const beefShieldPercent = t.pilotGenome === 'beef' && t.beefShieldMax > 0 ? Math.round(t.beefShield / t.beefShieldMax * 100) : 0;
        
        // Update pilot info with textContent (no DOM parsing)
        q("pilotTitle").textContent = store.name ? `‚ó¢ ${store.name} ‚ó£` : "‚ó¢ UNIDENTIFIED ‚ó£";
        q("scoreNum").textContent = store.world.score;
        q("goldNum").textContent = store.world.gold;
        
        // Update health bar and text
        q("hpBarFill").style.width = hpPercent + "%";
        q("hpText").textContent = `HP: ${Math.round(t.hp)} / ${t.hpMax}`;
        
        // Handle beef shield
        const beefShieldBar = q("beefShieldBar");
        const beefShieldText = q("beefShieldText");
        if (t.pilotGenome === 'beef' && t.beefShieldMax > 0) {
            beefShieldBar.style.display = "block";
            q("beefShieldBarFill").style.width = beefShieldPercent + "%";
            beefShieldText.textContent = `BEEF SHIELD: ${Math.round(t.beefShield)} / ${t.beefShieldMax}`;
        } else {
            beefShieldBar.style.display = "none";
            beefShieldText.textContent = "";
        }
        
        // Handle regular shield
        const shieldBar = q("shieldBar");
        const shieldTextEl = q("shieldText");
        if (t.shieldMax > 0) {
            shieldBar.style.display = "block";
            q("shieldBarFill").style.width = shieldPercent + "%";
            shieldTextEl.textContent = `SHIELD: ${Math.round(t.shield)} / ${t.shieldMax}`;
        } else {
            shieldBar.style.display = "none";
            shieldTextEl.textContent = "";
        }
        
        // Update wave info
        q("waveNum").textContent = store.world.wave;
        q("killsNum").textContent = store.world.kills;
        q("levelNum").textContent = store.world.level;
        
        // Update boss info
        const bossContent = q("hudBossContent");
        if (store.boss) {
            bossContent.classList.remove("hide");
            q("bossTitle").textContent = `‚ö° ${store.boss.name} ‚ö°`;
            q("bossBarFill").style.width = Math.round(store.boss.hp / store.boss.hpMax * 100) + "%";
        } else {
            bossContent.classList.add("hide");
        }
        
        // Update powerups (still needs some innerHTML for dynamic content)
        const powerupEl = q("hudPowerup");
        const timedPowerups = Object.keys(store.player.powerupTimers);
        if (timedPowerups.length > 0) {
            let timedContent = '';
            timedPowerups.forEach(key => {
                const timer = store.player.powerupTimers[key];
                const percent = Math.round((timer.remaining / timer.max) * 100);
                timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`;
            });
            q("powerupList").innerHTML = timedContent;
            powerupEl.classList.remove('hide');
        } else {
            powerupEl.classList.add('hide');
        }
        
        // Update equipment (still needs some innerHTML for dynamic content)
        const equipEl = q("hudEquipment");
        let hasEquipment = store.player.hasLauncher || store.player.hasHounds || store.player.nanoSaves > 0;
        if (hasEquipment) {
            let content = '';
            if (store.player.nanoSaves > 0) content += `<div>NANO SAVE [${store.player.nanoSaves}]</div>`;
            if (store.player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`;
            if (store.player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`;
            q("equipmentList").innerHTML = content;
            equipEl.classList.remove('hide');
        } else {
            equipEl.classList.add('hide');
        }
        
        // Update grenade button
        const grenadeBtn = q('grenadeBtnUI');
        if (store.player.grenades > 0) {
            grenadeBtn.classList.remove('hide');
            grenadeBtn.textContent = `GRENADE [${store.player.grenades}]`;
            grenadeBtn.disabled = false;
        } else {
            grenadeBtn.classList.add('hide');
        } 
        
        // Update FPS counter
        if (!store.fpsLastTime) {
            store.fpsLastTime = performance.now();
            store.fpsFrameCount = 0;
        }
        store.fpsFrameCount++;
        const now = performance.now();
        if (now - store.fpsLastTime >= 1000) {
            const fps = Math.round((store.fpsFrameCount * 1000) / (now - store.fpsLastTime));
            q('fps').textContent = fps;
            
            // COMMENTED OUT: Enhanced collar display with better feedback
            /*
            const collarStacks = sanitizeCollarStacks();
            const collarBonus = calculateCollarBonus(collarStacks);
            const collarPercent = (collarBonus - 1) * 100;
            const collarStatus = collarStacks === 0 ? 'LOOSE' : 
                                collarStacks < 25 ? 'CRUSHING' : 'MAXIMUM';
            q('collar').textContent = `${collarStacks.toFixed(1)} (${collarPercent.toFixed(0)}%) ${collarStatus}`;
            */
            
            // COMMENTED OUT: Calculate damage per bullet and average enemy HP
            /*
            const baseDamage = 15; // Updated from 20 to 15 (75% of original)
            const actualDamage = baseDamage * store.player.dmgMult;
            q('damagePerBullet').textContent = `${actualDamage.toFixed(1)}`;
            
            // Calculate average enemy HP across all enemy types
            const enemyTypes = [
            ];
            const avgBaseHp = enemyTypes.reduce((sum, type) => sum + type.hp, 0) / enemyTypes.length;
            const waveMultiplier = Math.pow(1.03, store.world.wave - 1);
            const avgCurrentHp = avgBaseHp * waveMultiplier * collarBonus;
            q('avgEnemyHp').textContent = `${avgCurrentHp.toFixed(0)}`;
            */
            
            const spawnDebugEl = q('spawnDebug');
            if (spawnDebugEl) {
                // Spawn debug info can stay if needed for development
            }
            
            store.fpsFrameCount = 0;
            store.fpsLastTime = now;
            
            // COMMENTED OUT: Update health table
            /*
            if (store.enemies.length > 0) {
                const enemy = store.enemies[0]; // Get first enemy for reference
                q('enemyCurrentHp').textContent = Math.round(enemy.hp);
            } else {
                q('enemyCurrentHp').textContent = '0';
            }
            if (store.boss) {
                q('bossCurrentHp').textContent = Math.round(store.boss.hp);
                q('bossBaseHp').textContent = Math.round(store.boss.hpMax);
            } else {
                q('bossCurrentHp').textContent = '0';
                q('bossBaseHp').textContent = '0';
            }
            */
        }
    }
// ...existing code...
    function normalizeLeaderboardEntries(source) {
        if (!source) return null;

        if (Array.isArray(source)) {
            return source;
        }

        if (Array.isArray(source.entries)) {
            return source.entries;
        }

        if (Array.isArray(source.top50)) {
            return source.top50;
        }

        if (Array.isArray(source.top10)) {
            return source.top10;
        }

        if (source.top50 && Array.isArray(source.top50.entries)) {
            return source.top50.entries;
        }

        if (source.top10 && Array.isArray(source.top10.entries)) {
            return source.top10.entries;
        }

        if (Array.isArray(source.data)) {
            return source.data;
        }

        if (source.data && Array.isArray(source.data.entries)) {
            return source.data.entries;
        }

        return null;
    }

    function updateLeaderboard(leaderboardData) { 
        const fallbackData = [
            { name: "ACE PILOT", score: 50000, waves: 10 },
            { name: "VOID RUNNER", score: 35000, waves: 8 },
            { name: "STAR HUNTER", score: 25000, waves: 6 },
            { name: "NOVA STRIKER", score: 18000, waves: 5 },
            { name: "COSMIC GUARD", score: 12000, waves: 4 }
        ]; 
        
        const entries = normalizeLeaderboardEntries(leaderboardData) ?? fallbackData;

        if (entries === fallbackData && leaderboardData) {
            console.warn("Leaderboard payload had unexpected shape, using fallback:", leaderboardData);
        }
        
        const safeEntries = entries.filter(entry => entry && typeof entry === "object");
        
        const listHtml = safeEntries.map(s => `<li>${escapeHtml(s.name ?? "UNKNOWN PILOT")} ‚Äî ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");
        const popupHtml = safeEntries.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name ?? "UNKNOWN PILOT")} ‚Äî ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");
        
        const hsList = q("hsList");
        const hsListPopup = q("hsListPopup");
        if (hsList) hsList.innerHTML = listHtml;
        if (hsListPopup) hsListPopup.innerHTML = popupHtml;
    }
    
    async function refreshScoreList() { 
        try { 
            const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 }); 
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`); 
            const data = await res.json(); 
            // data.entries contains up to 50 players
            updateLeaderboard(data); 
        } catch (err) { 
            console.warn("Failed to fetch leaderboard, using offline data:", err.message); 
            updateLeaderboard(null); 
        } 
    }
    async function addScore(score) {
        if (store.cheatsUsed) {
            announce("Score not submitted: Cheats used");
            return;
        }
        const name = (store.name || "ROGUE").slice(0, 16); 
        try { 
            const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 }); 
            if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`); 
            const { nonce } = await nonceRes.json(); 
            const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce }; 
            const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 }); 
            if (!res.ok) throw new Error(`Submit failed: ${res.status}`); 
            const data = await res.json(); 
            if (data.ok) { 
                updateLeaderboard(data); 
            } else { 
                console.warn("Score rejected:", data.err); 
                announce(`Score rejected: ${data.err}`); 
                refreshScoreList(); 
            } 
        } catch (err) { 
            console.warn("Score submission failed, game continues offline:", err.message); 
        } 
    }
    function fireBullet(x, y, vx, vy, props = {}) { 
        const p = store.player; 
        spawnBullet({
            x, y, vx, vy,
            r: p.explosive ? 5 : 3,
            col: p.explosive ? "#ED2F32" : "#b266ff",
            dmg: 15 * p.dmgMult,
            pierce: p.piercing,
            explosive: p.explosive,
            ...props
        });
    }
    function firePlayer() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        const baseBulletSpeed = 420;
        const bulletSpeed = baseBulletSpeed;
        const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0);
        const angleSpread = 10;
        for (let i = 0; i < totalMultishot; i++) { 
            const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; 
            spawnBullet({
                x: p.x + 10 * Math.sin(angle),
                y: p.y - 12,
                vx: Math.sin(angle) * bulletSpeed,
                vy: -Math.cos(angle) * bulletSpeed,
                r: p.explosive ? 5 : 3,
                col: p.explosive ? "#cc99ff" : "#b266ff",
                dmg: 15 * p.dmgMult,
                pierce: p.piercing,
                explosive: p.explosive
            });
        }
        if (p.hasIceman && store.iceman) {
            for (let i = 0; i < totalMultishot; i++) {
                const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                spawnBullet({
                    x: store.iceman.x + 10 * Math.sin(angle),
                    y: store.iceman.y - 12,
                    vx: Math.sin(angle) * bulletSpeed,
                    vy: -Math.cos(angle) * bulletSpeed,
                    r: p.explosive ? 5 : 3,
                    col: "#66aaff",
                    dmg: 15 * p.dmgMult * 0.35,
                    pierce: p.piercing,
                    explosive: p.explosive,
                    isIceman: true
                });
            }
        }
        if (p.rearMultishot > 0) {
            const rearAngleSpread = 15;
            for (let i = 0; i < p.rearMultishot; i++) {
                const angle = (i - (p.rearMultishot - 1) / 2) * rearAngleSpread;
                const radAngle = angle * Math.PI / 180;
                spawnBullet({
                    x: p.x + 10 * Math.sin(radAngle),
                    y: p.y + 12,
                    vx: Math.sin(radAngle) * bulletSpeed,
                    vy: Math.cos(radAngle) * bulletSpeed,
                    r: 3,
                    col: "#ffddff",
                    dmg: 11.25 * p.dmgMult,
                    pierce: p.piercing > 0 ? p.piercing - 1 : 0
                });
            }
        }
        store.drones.forEach(drone => spawnBullet({
            x: p.x + drone.offset,
            y: p.y + 20,
            vx: 0,
            vy: -bulletSpeed,
            r: 3,
            col: "#66aaff",
            dmg: 15 * p.dmgMult * 0.4,
            isDrone: true
        }));
        if (p.hasLauncher) {
            const speed = 350;
            const numPairs = store.player.upgradeLevels.launcher || 1;
            for (let i = 0; i < numPairs; i++) {
                const spread = 15 + i * 10;
                const vx_offset = 50 + i * 20;
                spawnBullet({ x: p.x - spread, y: p.y, vx: -vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                spawnBullet({ x: p.x + spread, y: p.y, vx: vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                if (p.hasIceman && store.iceman) {
                    spawnBullet({ x: store.iceman.x - spread, y: store.iceman.y, vx: -vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                    spawnBullet({ x: store.iceman.x + spread, y: store.iceman.y, vx: vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                }
            }
        }
    }
    
    function fireFlamethrower() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        
        let numFlames, angleRange, speed, life;
        switch (p.flamethrowerLevel) {
            case 1: numFlames = 4; angleRange = 40; speed = 250; life = 0.35; break;    // Halved from 8
            case 2: numFlames = 6; angleRange = 70; speed = 280; life = 0.4; break;     // Halved from 12
            default: numFlames = 8; angleRange = 90; speed = 320; life = 0.5; break;    // Halved from 16
        }
        
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
            const currentSpeed = speed + Math.random() * 40;
            const sideOffset = (i % 2 === 0) ? -15 : 15;
            const spawnX = p.x + sideOffset;
            const spawnY = p.y + 5;
            spawnBullet({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 3, col: `rgba(255, ${60 + Math.random() * 60}, 0, 0.9)`, dmg: 2 * p.dmgMult, life: life * 1.5, isFlame: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
        }
        
        if (p.hasIceman && store.iceman) {
            for (let i = 0; i < numFlames; i++) {
                const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                const currentSpeed = speed + Math.random() * 40;
                const sideOffset = (i % 2 === 0) ? -15 : 15;
                const spawnX = store.iceman.x + sideOffset;
                const spawnY = store.iceman.y + 5;
                spawnBullet({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 2, col: `rgba(100, 150, 255, 0.7)`, dmg: 2 * p.dmgMult * 0.35, life: life, isFlame: true, isIceman: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
            }
        }
    }

    function launchStarProjectile(originX, originY, angle, options = {}) {
        const speedMultiplier = options.speedMultiplier ?? 1;
        const projectile = {
            x: originX,
            y: originY,
            vx: Math.sin(angle) * STAR_CANNON_SPEED * speedMultiplier,
            vy: -Math.cos(angle) * STAR_CANNON_SPEED * speedMultiplier,
            size: STAR_CANNON_SIZE,
            rotation: 0,
            trail: [],
            maxTrailLength: 28,
            hitIds: new Set(),
            damageScale: options.damageScale ?? 1,
            isIceman: options.isIceman || false,
            hitboxScale: options.hitboxScale ?? STAR_CANNON_HITBOX_SCALE,
            trailColor: options.trailColor || null,
            primaryColor: options.primaryColor || null,
            coreColor: options.coreColor || null,
            shadowColor: options.shadowColor || null
        };
        store.starProjectiles.push(projectile);
    }

    function fireStarCannon() {
        const p = store.player;
        playSound('stargun');
        const originY = p.y - 12;
        const lateralOffset = 26;
        const shots = [];
        if (p.starCannonLevel >= 1) {
            shots.push({ originX: p.x - lateralOffset, angle: -Math.PI / 6, offset: -lateralOffset });
        }
        if (p.starCannonLevel >= 2) {
            shots.push({ originX: p.x + lateralOffset, angle: Math.PI / 6, offset: lateralOffset });
        }

        for (const shot of shots) {
            launchStarProjectile(shot.originX, originY, shot.angle, {
                hitboxScale: STAR_CANNON_HITBOX_SCALE
            });
        }

        if (p.starCannonIcemanSupport && p.hasIceman && store.iceman) {
            const icemanOriginY = store.iceman.y - 12;
            for (let i = 0; i < shots.length; i++) {
                const shot = shots[i];
                store.pendingStarClones.push({
                    delay: STAR_CANNON_CLONE_DELAY,
                    originX: store.iceman.x + shot.offset,
                    originY: icemanOriginY,
                    angle: shot.angle,
                    damageScale: STAR_CANNON_ICEMAN_DAMAGE_SCALE,
                    playSound: true
                });
            }
        }
    }

    function updateStarProjectiles(dt) {
        if (store.pendingStarClones.length) {
            for (let i = store.pendingStarClones.length - 1; i >= 0; i--) {
                const pending = store.pendingStarClones[i];
                pending.delay -= dt;
                if (pending.delay <= 0) {
                    launchStarProjectile(pending.originX, pending.originY, pending.angle, {
                        damageScale: pending.damageScale,
                        isIceman: true,
                        hitboxScale: STAR_CANNON_HITBOX_SCALE
                    });
                    if (pending.playSound) {
                        playSound('stargun');
                    }
                    store.pendingStarClones.splice(i, 1);
                }
            }
        }

        if (!store.starProjectiles.length) return;
        const p = store.player;
        const baseDamage = STAR_CANNON_DAMAGE * p.dmgMult;
        const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;

        for (let i = store.starProjectiles.length - 1; i >= 0; i--) {
            const star = store.starProjectiles[i];
            star.x += star.vx * dt;
            star.y += star.vy * dt;
            star.rotation += dt * 2.4;

            star.trail.push({ x: star.x, y: star.y, life: 1, size: star.size * 0.55 });
            if (star.trail.length > star.maxTrailLength) star.trail.shift();
            for (let t = star.trail.length - 1; t >= 0; t--) {
                const particle = star.trail[t];
                particle.life -= dt * 2.6;
                particle.size *= 1 - dt * 1.6;
                if (particle.life <= 0 || particle.size <= 0.2) star.trail.splice(t, 1);
            }

            const hitRadius = star.size * (star.hitboxScale || STAR_CANNON_HITBOX_SCALE);
            for (const target of targets) {
                if (!target || target.dead || target.hp <= 0) continue;
                if (target === store.boss && target.isInvincible) continue;
                if (target.isHeatDeath) continue;

                const targetRadius = target.r || target.radius || 18;
                const dx = star.x - target.x;
                const dy = star.y - target.y;
                const combined = hitRadius + targetRadius;
                if (dx * dx + dy * dy <= combined * combined) {
                    const id = target.id || target.__starId || target;
                    if (!star.hitIds.has(id)) {
                        const starDamage = baseDamage * (star.damageScale ?? 1);
                        applyStarDamage(target, starDamage);
                        star.hitIds.add(id);
                    }
                }
            }

            if (star.x < -80 || star.x > W + 80 || star.y < -120 || star.y > H + 120) {
                store.starProjectiles.splice(i, 1);
            }
        }
    }

    function applyStarDamage(target, dmg) {
        const p = store.player;
        let damage = dmg;

        if (Math.random() < p.critChance) {
            damage *= p.critDamage;
            store.activeEffects.push(createEffect('critText', target.x, target.y));
            if (Math.random() < 0.05) spawnPowerup(target.x, target.y);
        }

        if (target === store.boss) playSound('hit');
        target.hp -= damage;
        store.world.totalDamage = (store.world.totalDamage || 0) + damage;

        if (p.pilotGenome === 'beef') {
            p.beefShieldDamageDealt = (p.beefShieldDamageDealt || 0) + damage;
        }

        if (p.vampirism > 0) {
            let healAmount = damage * p.vampirism;
            healAmount = Math.max(healAmount, 1);
            healAmount = Math.min(healAmount, 5);
            p.hp = Math.min(p.hpMax, p.hp + healAmount);
        }

        if (target.hp <= 0) {
            target.dead = true;
            if (target.type === 'void_champion') {
                store.enemies.forEach(minion => {
                    if (minion.orbitTargetId === target.id && !minion.dead) {
                        spawnGibs(minion.x, minion.y, minion.color);
                        minion.dead = true;
                    }
                });
                spawnVoidCoreDrop(target.x, target.y - 10);
            }

            if (target === store.boss) {
                handleBossDefeat();
            } else {
                spawnGibs(target.x, target.y, target.color);
                store.world.score += target.score;
                store.world.gold += target.gold;
                store.world.xp += target.xp;
                store.world.kills++;

                spawnPowerup(target.x, target.y);
                explode(target.x, target.y);
            }
        }
    }

    function drawStarProjectiles() {
        if (!store.starProjectiles.length) return;
        for (const star of store.starProjectiles) {
            const trailFillBase = star.isIceman ? 'rgba(190, 225, 255, ' : 'rgba(255, 255, 200, ';
            const trailShadowBase = star.isIceman ? 'rgba(140, 200, 255, ' : 'rgba(255, 240, 150, ';
            for (const particle of star.trail) {
                const trailAlpha = Math.max(0, Math.min(1, particle.life * 0.6));
                const shadowAlpha = Math.max(0, Math.min(1, particle.life));
                ctx.fillStyle = `${trailFillBase}${trailAlpha})`;
                ctx.shadowColor = `${trailShadowBase}${shadowAlpha})`;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.save();
            ctx.translate(star.x, star.y);
            ctx.rotate(star.rotation);

            ctx.fillStyle = star.isIceman ? 'rgba(180, 215, 255, 0.85)' : 'rgba(255, 255, 140, 0.85)';
            ctx.shadowColor = star.isIceman ? 'rgba(140, 200, 255, 0.9)' : 'rgba(255, 220, 120, 0.9)';
            ctx.shadowBlur = 24;
            drawStarShape(ctx, 0, 0, 5, star.size, star.size * 0.45);
            ctx.fill();

            ctx.fillStyle = star.isIceman ? '#eef7ff' : '#fffbe6';
            ctx.shadowBlur = 12;
            drawStarShape(ctx, 0, 0, 5, star.size * 0.65, star.size * 0.28);
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;
        }
    }

    function drawStarShape(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
    }

    function drawGoldenOrbs() {
        if (!store.goldenOrbs || store.goldenOrbs.length === 0) {
            return;
        }
        const time = performance.now() / 1000;

        for (const orb of store.goldenOrbs) {
            if (orb.trail && orb.trail.length) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const node of orb.trail) {
                    const lifeRatio = Math.max(0, node.life / GOLDEN_ORB_CONFIG.trailLife);
                    if (lifeRatio <= 0) continue;
                    ctx.globalAlpha = lifeRatio * 0.45;
                    ctx.fillStyle = `rgba(255, 210, 120, ${lifeRatio * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 9 * lifeRatio, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            ctx.save();
            ctx.translate(orb.x, orb.y);
            if (orb.state === 'homing') {
                ctx.rotate(orb.heading || 0);
            }
            ctx.globalCompositeOperation = 'lighter';

            const pulse = 0.85 + Math.sin(time * 6 + (orb.pulseOffset || 0)) * 0.15;
            const outerGlowRadius = orb.r * (1.4 + pulse * 0.25);
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerGlowRadius);
            glowGradient.addColorStop(0, 'rgba(255, 255, 220, 0.18)');
            glowGradient.addColorStop(0.5, 'rgba(255, 210, 100, 0.4)');
            glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(0, 0, outerGlowRadius, 0, Math.PI * 2);
            ctx.fill();

            const ringOuter = orb.r * (0.95 + pulse * 0.12);
            const ringInner = ringOuter * 0.55;
            const ringGradient = ctx.createRadialGradient(0, 0, ringInner * 0.75, 0, 0, ringOuter);
            ringGradient.addColorStop(0, 'rgba(255, 250, 210, 0.85)');
            ringGradient.addColorStop(0.45, 'rgba(255, 210, 90, 0.75)');
            ringGradient.addColorStop(0.9, 'rgba(255, 130, 20, 0.35)');
            ringGradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
            ctx.fillStyle = ringGradient;
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 225, 140, 0.95)';
            ctx.lineWidth = Math.max(3, orb.r * 0.18);
            ctx.beginPath();
            ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255, 255, 220, 0.5)';
            ctx.lineWidth = Math.max(2, orb.r * 0.12);
            ctx.beginPath();
            ctx.arc(0, 0, ringInner, 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalAlpha = 0.6 + 0.3 * Math.sin(time * 8 + (orb.pulseOffset || 0));
            ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            ctx.beginPath();
            ctx.arc(0, 0, ringInner * 0.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
        ctx.globalAlpha = 1;
    }
    
    function stepBossOmegaSentinel(dt, b, dmgScale) {
        // Movement behavior
        if (b.y >= 100) {
            b.moveT += dt;
            b.x += Math.sin(b.moveT * 2) * 200 * dt;
            b.x = clamp(b.x, 100, W - 100);
        }
        
        // Initialize EMP nova timer if not set
        if (b.empNovaTimer === undefined) {
            b.empNovaTimer = 8; // EMP nova every 8 seconds
        }
        
        // EMP Nova attack countdown
        b.empNovaTimer -= dt;
        if (b.empNovaTimer <= 0) {
            // Create EMP nova
            store.empNovas.push({
                x: b.x,
                y: b.y,
                radius: 0,
                maxRadius: H / 3, // 1/3 of screen height
                speed: 80, // Slow expansion speed
                life: 15, // Lives for 15 seconds
                dead: false
            });
            b.empNovaTimer = 8; // Reset timer
        }
        
        // Regular attack patterns
        b.fireT -= dt;
        if (b.fireT <= 0) {
            if (b.patternPhase % 4 === 0) {
                // Radial burst
                b.fireT = 1.5;
                const n = 12;
                for (let i = 0; i < n; i++) {
                    const a = (i * Math.PI / 6) + b.t;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: 150 * Math.cos(a),
                        vy: 150 * Math.sin(a),
                        r: 4,
                        col: '#4169e1',
                        dmg: 12 * dmgScale
                    });
                }
            } else {
                // Aimed shot
                b.fireT = 0.2;
                const a = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                store.eBullets.push({
                    x: b.x,
                    y: b.y,
                    vx: 250 * Math.cos(a),
                    vy: 250 * Math.sin(a),
                    r: 5,
                    col: '#add8e6',
                    dmg: 18 * dmgScale
                });
            }
            b.patternPhase++;
        }
    }
    function stepBossCoreMalignus(dt, b, dmgScale) { if (b.hp / b.hpMax <= 0.07 && !b.isEnraged) { b.isEnraged = true; playSound('horn'); } if (b.y >= 100) { b.moveT += dt; b.x = W / 2 + (W / 2 - 100) * Math.sin(b.moveT * 0.5); } b.fireT -= dt; if (b.fireT <= 0) { b.fireT = b.isEnraged ? 0.6 : 0.8; const n = 12, g = 3, s = Math.floor(Math.random() * (n - g)); for (let i = 0; i < n; i++) { if (i >= s && i < s + g) continue; const p = (W / (n + 1)) * (i + 1); store.eBullets.push({ x: p, y: b.y, vx: 0, vy: 180, r: 6, col: b.color, dmg: 20 * dmgScale }); } } }
    function stepBossTheHex(dt, b, dmgScale) { 
        if (b.y >= 100) {
            b.moveT += dt;
            if (b.dashTimer && b.dashTimer > 0) {
                b.dashTimer -= dt;
                b.x += b.vx * dt;
                b.x = clamp(b.x, b.r, W - b.r);
                if (b.dashTimer <= 0) {
                    b.dashTimer = 0;
                    b.vx = 0;
                    b.dashTrailCooldown = 0;
                }
            } else {
                const desiredX = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4));
                const followSpeed = 6;
                b.x += (desiredX - b.x) * Math.min(1, followSpeed * dt);
            }
        }

        b.fireT -= dt; 
        if (b.hp / b.hpMax < 0.5 && !b.isEnraged) { 
            b.isEnraged = true; 
            playSound('trap'); 
        } 
        const fireRate = b.isEnraged ? 0.8 : 1.5; 
        if (b.fireT <= 0) { 
            b.fireT = fireRate; 
            b.attackPhase = (b.attackPhase + 1) % 3; 
            switch(b.attackPhase) { 
                case 0: 
                    // Gold rain with interspersed powerups for strategic gambling
                    b.rainEvent = {
                        remaining: 20,
                        interval: 0.05,
                        timer: 0
                    };
                    break; 
                case 1: 
                    for (let i = 0; i < 4; i++) { 
                        const isHorizontal = i < 2; 
                        const y = isHorizontal ? 100 + i * 150 : 0; 
                        const x = isHorizontal ? 0 : 200 + (i-2) * 250; 
                        const vx = isHorizontal ? 300 : 0; 
                        const vy = isHorizontal ? 0 : 300; 
                        store.eBullets.push({ 
                            x: x, 
                            y: y, 
                            vx: vx, 
                            vy: vy, 
                            r: 4, 
                            col: '#80ffff', 
                            dmg: 20 * dmgScale, 
                            isLaser: true, 
                            life: 2.5 
                        }); 
                    } 
                    break; 
                case 2: 
                    const targetX = store.player.x; 
                    const dx = targetX - b.x; 
                    const dashSpeed = 800;
                    const direction = dx === 0 ? (Math.random() < 0.5 ? -1 : 1) : Math.sign(dx);
                    b.vx = direction * dashSpeed;
                    b.dashTimer = 0.5;
                    b.dashTrailCooldown = 0;
                    break; 
            } 
        } 
        if (b.rainEvent && b.rainEvent.remaining > 0) {
            b.rainEvent.timer -= dt;
            while (b.rainEvent.timer <= 0 && b.rainEvent.remaining > 0) {
                b.rainEvent.timer += b.rainEvent.interval;
                b.rainEvent.remaining--;
                if (Math.random() < 0.2) {
                    const powerupTypes = ['double', 'missile', 'drones', 'shield'];
                    const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];

                    store.powerups.push({
                        x: Math.random() * W,
                        y: 0,
                        vx: 0,
                        vy: 250,
                        r: 6,
                        type: randomType,
                        life: H / 250 + 2
                    });
                } else {
                    store.eBullets.push({
                        x: Math.random() * W,
                        y: 0,
                        vx: 0,
                        vy: 250,
                        r: 5,
                        col: '#ffc83d',
                        dmg: 15 * dmgScale
                    });
                }
            }
            if (b.rainEvent.remaining <= 0) {
                b.rainEvent = null;
            }
        }
        if (b.dashTimer && b.dashTimer > 0) {
            b.dashTrailCooldown -= dt;
            if (b.dashTrailCooldown <= 0) {
                b.dashTrailCooldown += 0.12;
                store.eBullets.push({
                    x: b.x,
                    y: b.y,
                    vx: 0,
                    vy: 0,
                    r: 8,
                    col: '#ff8080',
                    dmg: 25 * dmgScale,
                    life: 1
                });
            }
        } 
    }
    function stepBossGeometron(dt, b, dmgScale) { 
        // Handle DEATH ENGINE specific behavior
        if (b.name === 'DEATH ENGINE') {
            // Initialize skull ship specific properties
            if (!b.skullPhaseInitialized) {
                b.skullPhaseInitialized = true;
                b.phase = 1;
                b.disappearPhase = false;
                b.disappearStartTime = 0;
                b.safeZoneY = H * 0.5; // Start safe zone in middle
                b.safeZoneChanges = 0;
                b.maxSafeZoneChanges = 3;
                b.hasDoneSecondDisappear = false;
            }

            // Phase 1: Normal attacks until 50% HP
            if (b.phase === 1 && b.hp / b.hpMax > 0.5) {
                // Movement
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * 0.3); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Normal attack pattern
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                            // Trigger Death Engine laugh
                            b.isLaughing = true;
                            b.laughStartTime = performance.now();
                            if (b.skullRenderer) {
                                b.skullRenderer.triggerAttack(true);
                            }
                            const n = 12; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 160 * Math.cos(a), vy: 160 * Math.sin(a), r: 4, col: '#8B0000', dmg: 18 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Aimed shots at player
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < 5; i++) { 
                                const angle = angleToPlayer + (i - 2) * 0.15; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 280 * Math.cos(angle), vy: 280 * Math.sin(angle), r: 5, col: '#FF4500', dmg: 22 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // Spawn construct gold
                            const numgold = 2 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 120; 
                                gold.y = b.y + 60; 
                                gold.color = '#8B0000';
                                store.enemies.push(gold); 
                            } 
                            break;
                        case 3:
                            // New attack phase: Bouncing skull projectiles
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * Math.PI / 3) + (Math.random() - 0.5) * 0.3;
                                const speed = 150 + Math.random() * 50;
                                store.eBullets.push({ 
                                    x: b.x, 
                                    y: b.y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    r: 6, 
                                    col: '#DC143C', 
                                    dmg: 20 * dmgScale,
                                    bounces: 2, // Special bouncing bullets
                                    life: 4.0
                                }); 
                            }
                            break; 
                    }
                }
            }
            // Phase transition: Disappear and start train bullet pattern
            else if (b.phase === 1 && b.hp / b.hpMax <= 0.5) {
                b.phase = 2;
                b.disappearPhase = true;
                b.disappearStartTime = performance.now();
                b.isInvincible = true;
                b.visible = false; // Hide the boss
                
                // Move boss offscreen below player so it can't be shot
                b.x = W / 2;
                b.y = H + 200; // Move well below the screen
                
                // Update skull renderer position to be offscreen too
                if (b.skullRenderer) {
                    b.skullRenderer.x = b.x;
                    b.skullRenderer.y = b.y;
                }
                
                playSound('shao_kahn'); // Skull laugh when disappearing
                announce('THE DEATH ENGINE VANISHES INTO THE VOID!');
                
                // Reset safe zone position and changes
                b.safeZoneY = H * 0.5;
                b.safeZoneChanges = 0;
            }
            // Phase 2: Disappear phase with train bullets
            else if (b.disappearPhase) {
                const disappearTime = (performance.now() - b.disappearStartTime) / 1000;
                
                // Spawn train bullets continuously - 2 chunks moving opposite directions with safe zone in middle
                if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                b.trainBulletTimer -= dt;
                
                if (b.trainBulletTimer <= 0) {
                    b.trainBulletTimer = 0.08; // Very frequent spawning
                    
                    const safeZoneHeight = 120; // Safe zone in middle
                    const safeZoneY = H * 0.5; // Center of screen
                    const bulletSpeed = 280;
                    const bulletSpacing = 25;
                    
                    // Top chunk: bullets moving right to left (from top)
                    const topBoundary = safeZoneY - safeZoneHeight/2;
                    if (topBoundary > 30) {
                        for (let y = 0; y < topBoundary; y += bulletSpacing) {
                            store.eBullets.push({
                                x: -10, y: y,
                                vx: bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                    
                    // Bottom chunk: bullets moving left to right (from bottom)
                    const bottomBoundary = safeZoneY + safeZoneHeight/2;
                    if (bottomBoundary < H - 30) {
                        for (let y = bottomBoundary; y < H; y += bulletSpacing) {
                            store.eBullets.push({
                                x: W + 10, y: y,
                                vx: -bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                }
                
                // Return after 4 seconds (single phase)
                if (disappearTime > 4) {
                    b.disappearPhase = false;
                    b.visible = true;
                    b.isInvincible = false;
                    b.fireT = 1.0;
                    
                    // Reposition boss
                    b.x = W / 2;
                    b.y = 100;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Another laugh as he returns
                    announce('THE DEATH ENGINE RETURNS!');
                }
            }
            // Second disappear phase (enraged) - 2 fields of bullets with contact safe zone
            else if (b.disappearPhase && b.hasDoneSecondDisappear) {
                const disappearTime = (performance.now() - b.disappearStartTime) / 1000;
                
                // Spawn train bullets continuously - 2 fields going opposite directions with contact safe zone
                if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                b.trainBulletTimer -= dt;
                
                if (b.trainBulletTimer <= 0) {
                    b.trainBulletTimer = 0.06; // Even more frequent spawning for enraged phase
                    
                    const safeZoneWidth = 60; // Narrower safe zone - contact without buffer
                    const safeZoneX = W * 0.5; // Center of screen
                    const bulletSpeed = 320; // Faster bullets
                    const bulletSpacing = 20;
                    
                    // Left field: bullets moving right (from left side)
                    const leftBoundary = safeZoneX - safeZoneWidth/2;
                    if (leftBoundary > 30) {
                        for (let x = 0; x < leftBoundary; x += bulletSpacing) {
                            for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                store.eBullets.push({
                                    x: x, y: y,
                                    vx: bulletSpeed, vy: 0,
                                    r: 5, col: '#FF0000',
                                    dmg: 30 * dmgScale, // Higher damage
                                    life: (W + 20) / bulletSpeed + 1,
                                    fadeInTime: 2.0, // 2 second fade-in
                                    spawnTime: performance.now()
                                });
                            }
                        }
                    }
                    
                    // Right field: bullets moving left (from right side)
                    const rightBoundary = safeZoneX + safeZoneWidth/2;
                    if (rightBoundary < W - 30) {
                        for (let x = rightBoundary; x < W; x += bulletSpacing) {
                            for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                store.eBullets.push({
                                    x: x, y: y,
                                    vx: -bulletSpeed, vy: 0,
                                    r: 5, col: '#FF0000',
                                    dmg: 30 * dmgScale, // Higher damage
                                    life: (W + 20) / bulletSpeed + 1,
                                    fadeInTime: 2.0, // 2 second fade-in
                                    spawnTime: performance.now()
                                });
                            }
                        }
                    }
                }
                
                // Return after 5 seconds (longer enraged phase)
                if (disappearTime > 5) {
                    b.disappearPhase = false;
                    b.visible = true;
                    b.isInvincible = false;
                    b.fireT = 0.5; // Very aggressive after returning
                    
                    // Reposition boss
                    b.x = W / 2;
                    b.y = 100;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Final laugh as he returns
                    announce('THE DEATH ENGINE RETURNS FOR THE FINAL ASSAULT!');
                }
            }
            // Phase 2: Normal combat after returning
            else if (b.phase === 2 && !b.disappearPhase) {
                // Calculate health percentage for final phase mechanics
                const healthPercent = b.hp / b.hpMax;
                const isFinalPhase = healthPercent <= 0.25; // Final phase at 25% health
                
                // Second disappear phase when enraged (red)
                if (isFinalPhase && !b.hasDoneSecondDisappear) {
                    b.hasDoneSecondDisappear = true;
                    b.disappearPhase = true;
                    b.disappearStartTime = performance.now();
                    b.isInvincible = true;
                    b.visible = false;
                    
                    // Move boss offscreen
                    b.x = W / 2;
                    b.y = H + 200;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Skull laugh when disappearing again
                    announce('THE DEATH ENGINE VANISHES INTO THE VOID AGAIN!');
                    
                    // Reset bullet timer
                    b.trainBulletTimer = 0;
                }
                
                // Red coloration and faster movement in final phase
                const moveSpeed = isFinalPhase ? 0.9 : 0.6; // Faster movement when low on health
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Override skull ship color to red when in final phase
                if (isFinalPhase && b.color !== '#FF0000') {
                    b.color = '#FF0000'; // Turn red in final phase
                }
                
                // ENRAGE PHASE: Spawn 1/4 density of intermission bullets passing through play field
                if (isFinalPhase) {
                    if (!b.enrageBulletTimer) b.enrageBulletTimer = 0;
                    b.enrageBulletTimer -= dt;
                    
                    if (b.enrageBulletTimer <= 0) {
                        b.enrageBulletTimer = 0.32; // 1/4 density of normal intermission (0.08 * 4)
                        
                        const bulletSpeed = 280;
                        const bulletSpacing = 25;
                        
                        // Spawn bullets from left side moving right (top half)
                        for (let y = 0; y < H * 0.5; y += bulletSpacing * 4) { // Every 4th bullet spacing
                            store.eBullets.push({
                                x: -10, y: y,
                                vx: bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                        
                        // Spawn bullets from right side moving left (bottom half)
                        for (let y = H * 0.5; y < H; y += bulletSpacing * 4) { // Every 4th bullet spacing
                            store.eBullets.push({
                                x: W + 10, y: y,
                                vx: -bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                }
                
                // More aggressive attacks, even faster in final phase
                const fireRate = isFinalPhase ? 1.2 : 1.8; // Faster attacks in final phase
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = fireRate;
                    switch(b.attackPhase) { 
                        case 0: 
                            // Trigger Death Engine laugh
                            b.isLaughing = true;
                            b.laughStartTime = performance.now();
                            if (b.skullRenderer) {
                                b.skullRenderer.triggerAttack(true);
                            }
                            // Dense spiral (more bullets in final phase)
                            const n = isFinalPhase ? 20 : 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 1.2; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 200 * Math.cos(a), vy: 200 * Math.sin(a), r: 5, col: bulletColor, dmg: 20 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Triple aimed shots (more spread in final phase)
                            const shotCount = isFinalPhase ? 9 : 7;
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < shotCount; i++) { 
                                const angle = angleToPlayer + (i - Math.floor(shotCount/2)) * 0.12; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#FF4500';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 320 * Math.cos(angle), vy: 320 * Math.sin(angle), r: 5, col: bulletColor, dmg: 25 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // More gold (significantly more in final phase)
                            const basegold = 3 + Math.floor(store.world.wave / 8);
                            const finalPhaseBonus = isFinalPhase ? Math.floor(basegold * 0.75) : 0; // 75% more adds in final phase
                            const numgold = basegold + finalPhaseBonus;
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 150; 
                                gold.y = b.y + 60; 
                                gold.color = isFinalPhase ? '#FF0000' : '#FF0000';
                                gold.hp *= isFinalPhase ? 1.5 : 1.3; // Tougher adds in final phase
                                store.enemies.push(gold); 
                            } 
                            break; 
                        case 3: 
                            // Cross pattern (more layers in final phase)
                            const layers = isFinalPhase ? 4 : 3;
                            for (let i = 0; i < 4; i++) {
                                const angle = i * Math.PI / 2;
                                for (let j = 1; j <= layers; j++) {
                                    const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                    store.eBullets.push({ 
                                        x: b.x, y: b.y, 
                                        vx: 180 * j * 0.7 * Math.cos(angle), 
                                        vy: 180 * j * 0.7 * Math.sin(angle), 
                                        r: 4, col: bulletColor, dmg: 18 * dmgScale 
                                    }); 
                                }
                            }
                            break;
                    }
                }
            }
        } else {
            // Original GEOMETRON logic (unchanged)
            if (b.hp / b.hpMax < 0.5 && b.phase === 1) { 
                b.phase = 2; 
                b.isInvincible = true; 
                playSound('horn'); 
                store.activeEffects.push(createEffect("bossPhaseChange", b.x, b.y)); 
                b.attackPhase = 0; 
                b.fireT = 2.0; 
                setTimeout(() => { b.isInvincible = false; }, 2000); 
                announce('GEOMETRON ENRAGED!'); 
            }
            
            // Movement logic
            if (b.y >= 100) { 
                b.moveT += dt; 
                const moveSpeed = (b.phase === 1) ? 0.3 : 0.7; 
                b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
            } 
            
            // Attack logic
            b.fireT -= dt; 
            if (b.fireT <= 0) { 
                if (b.phase === 1) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const n = 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numgold = 3 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 100; 
                                gold.y = b.y + 50; 
                                store.enemies.push(gold); 
                            } 
                            break; 
                    } 
                } else { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.0; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const spread = 8; 
                            const numShots = 8; 
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < numShots; i++) { 
                                const angle = angleToPlayer + (i - (numShots - 1) / 2) * (spread * Math.PI / 180) * 0.1; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 350 * Math.cos(angle), vy: 350 * Math.sin(angle), r: 4, col: '#ff4500', dmg: 22 * dmgScale, life: 2.0 }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numgold = 2; 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (i === 0 ? -50 : 50); 
                                gold.y = b.y + 50; 
                                gold.hp *= 1.5; 
                                gold.v *= 1.3; 
                                gold.color = '#ff4500'; 
                                store.enemies.push(gold); 
                            } 
                            break; 
                    } 
                } 
            }
        }
    }
    function stepBossVoidRaven(dt, b, dmgScale) { b.moveT += dt; if (!b.isDiving) { b.y = 100 + Math.sin(b.moveT * 2) * 20; b.x = W/2 + Math.cos(b.moveT * 0.5) * (W/2 - 100); } b.fireT -= dt; if (b.fireT <=0) { b.attackPhase = (b.attackPhase + 1) % 5; switch(b.attackPhase) { case 0: case 2: b.fireT = 1.2; for(let i = 0; i < 7; i++) { const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: '#4169e1', dmg: 18 * dmgScale }); } break; case 1: case 3: b.fireT = 2.0; const numHatchlings = 2 + Math.floor(store.world.wave / 15); for(let i = 0; i < numHatchlings; i++) { const hatchling = spawnEnemy('avian_hatchling'); hatchling.x = b.x + (Math.random() - 0.5) * 80; hatchling.y = b.y + 40; store.enemies.push(hatchling); } break; case 4: b.fireT = 4.0; b.isDiving = true; b.diveTarget = { x: store.player.x, y: store.player.y }; const dx = b.diveTarget.x - b.x; const dy = b.diveTarget.y - b.y; const dist = Math.sqrt(dx*dx + dy*dy); b.vx = (dx / dist) * 400; b.vy = (dy / dist) * 400; setTimeout(() => { b.isDiving = false; b.vx = 0; b.vy = 30; }, 1500); break; } } if (b.isDiving) { b.x += b.vx * dt; b.y += b.vy * dt; } }
    
    function stepBossBroodlord(dt, b, dmgScale) {
        // Initialize poison puddles array if not exists
        if (!store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        
        // Broodlord skittering movement
        b.moveT += dt;
        if (!b.spiderInit) {
            b.spiderInit = true;
            b.spiderVX = (Math.random() < 0.5 ? -1 : 1) * (120 + Math.random() * 40);
            b.spiderVY = 90 + Math.random() * 50;
            b.webRetargetT = 1.4;
            b.poisonTrailT = 1.2;
        }

        const speedScale = 1 + Math.min(0.75, Math.max(0, store.world.wave - 10) * 0.02);
        b.x += b.spiderVX * speedScale * dt;
        b.y += b.spiderVY * speedScale * dt;

        const minX = 90;
        const maxX = W - 90;
        const minY = 90;
        const maxY = Math.min(H - 170, H * 0.78);

        if (b.x <= minX && b.spiderVX < 0) {
            b.x = minX;
            b.spiderVX = Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
            b.spiderVY += (Math.random() - 0.5) * 140;
        } else if (b.x >= maxX && b.spiderVX > 0) {
            b.x = maxX;
            b.spiderVX = -Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
            b.spiderVY += (Math.random() - 0.5) * 140;
        }

        if (b.y <= minY && b.spiderVY < 0) {
            b.y = minY;
            b.spiderVY = Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
            b.spiderVX += (Math.random() - 0.5) * 110;
        } else if (b.y >= maxY && b.spiderVY > 0) {
            b.y = maxY;
            b.spiderVY = -Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
            b.spiderVX += (Math.random() - 0.5) * 110;
        }

        b.spiderVX = clamp(b.spiderVX, -260, 260);
        b.spiderVY = clamp(b.spiderVY, -240, 240);

        b.webRetargetT -= dt;
        if (b.webRetargetT <= 0) {
            const player = store.player;
            const dx = player.x - b.x;
            const dy = (player.y - 40) - b.y;
            const dist = Math.max(120, Math.hypot(dx, dy));
            const chaseStrengthX = 180 + Math.random() * 60;
            const chaseStrengthY = 170 + Math.random() * 60;
            b.spiderVX = clamp(b.spiderVX * 0.5 + (dx / dist) * chaseStrengthX, -260, 260);
            b.spiderVY = clamp(b.spiderVY * 0.5 + (dy / dist) * chaseStrengthY, -240, 240);
            b.webRetargetT = 1.3 + Math.random() * 0.9;
        }

        b.poisonTrailT -= dt;
        if (b.poisonTrailT <= 0) {
            const puddleX = clamp(b.x + (Math.random() - 0.5) * 120, 40, W - 40);
            const puddleY = clamp(b.y + Math.random() * 120, 80, H - 80);
            store.poisonPuddles.push({
                x: puddleX,
                y: puddleY,
                r: 18 + Math.random() * 12,
                life: getHivePuddleLifetime(4.8, 3.2, { min: 4.2, maxWaveBonus: 4.5 }),
                damage: 10 * dmgScale,
                created: performance.now()
            });
            const trailReset = 2.4 - Math.min(1.4, store.world.wave * 0.035);
            b.poisonTrailT = Math.max(0.9, trailReset);
        }
        
        // Attack phases
        b.fireT -= dt;
        if (b.fireT <= 0) {
            b.attackPhase = (b.attackPhase + 1) % 4;
            
            switch(b.attackPhase) {
                case 0:
                case 2:
                    // Poison blob barrage
                    b.fireT = 1.8;
                    const numBlobs = 5 + Math.floor(store.world.wave / 10);
                    for (let i = 0; i < numBlobs; i++) {
                        const spread = Math.PI * 0.6;
                        const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                        const angle = baseAngle + (Math.random() - 0.5) * spread;
                        const speed = 180 + Math.random() * 80;
                        
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 8,
                            col: '#7cfc00',
                            dmg: 22 * dmgScale,
                            life: 4,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 1:
                    // Acid spit pattern
                    b.fireT = 2.2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI / 4) + b.t * 0.5;
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * 160,
                            vy: Math.sin(angle) * 160,
                            r: 6,
                            col: '#adff2f',
                            dmg: 20 * dmgScale,
                            life: 3,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 3:
                    // Toxic ground slam - saturate arena with dangerous puddles
                    b.fireT = 2.6;
                    const playerPos = store.player;
                    const webSpots = [
                        { x: clamp(playerPos.x, 80, W - 80), y: clamp(playerPos.y + 40, 120, H - 90) },
                        { x: clamp(playerPos.x + 180, 80, W - 80), y: clamp(playerPos.y - 20, 120, H - 90) },
                        { x: clamp(playerPos.x - 180, 80, W - 80), y: clamp(playerPos.y + 80, 120, H - 90) },
                        { x: W * 0.25 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                        { x: W * 0.75 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                        { x: W * 0.5 + (Math.random() - 0.5) * 220, y: H * 0.55 + (Math.random() - 0.5) * 140 }
                    ];
                    for (let i = 0; i < 6; i++) {
                        const node = webSpots[i % webSpots.length];
                        const puddleX = clamp(node.x + (Math.random() - 0.5) * 70, 40, W - 40);
                        const puddleY = clamp(node.y + (Math.random() - 0.5) * 70, 80, H - 70);
                        store.poisonPuddles.push({
                            x: puddleX,
                            y: puddleY,
                            r: 28 + Math.random() * 18,
                            life: getHivePuddleLifetime(7.5, 4.5, { min: 6.5, waveBonusPer: 0.4, maxWaveBonus: 6.5 }),
                            damage: 15 * dmgScale,
                            created: performance.now()
                        });
                    }
                    break;
            }
        }
        
        const now = performance.now();
        const bossRadius = b.r || 80;
        const puddleDamageInterval = 600; // ms between damage ticks while boss is in the acid

        for (let i = store.poisonPuddles.length - 1; i >= 0; i--) {
            const puddle = store.poisonPuddles[i];
            puddle.life -= dt;
            if (puddle.life <= 0) {
                store.poisonPuddles.splice(i, 1);
                continue;
            }

            const dx = b.x - puddle.x;
            const dy = b.y - puddle.y;
            const dist = Math.hypot(dx, dy);
            const effectiveRadius = puddle.r + bossRadius * 0.55;

            if (dist < effectiveRadius) {
                // Standing in the acid slows and harms the Hive Sovereign
                b.slowTimer = Math.max(b.slowTimer || 0, 0.45);

                if (!b.lastPuddleDamageTime || now - b.lastPuddleDamageTime >= puddleDamageInterval) {
                    const puddleDamage = Math.max(8, puddle.damage * 0.9);
                    b.hp -= puddleDamage;
                    store.world.totalDamage += puddleDamage;
                    b.lastPuddleDamageTime = now;

                    if (b.hp <= 0) {
                        handleBossDefeat();
                        return;
                    }
                }
            }
        }
    }
    
    function stepBoss(dt) {
        const b = store.boss;
        b.t += dt;
        if (b.y < 100) { b.y += b.vy * dt; }
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        
        if (b.slowTimer > 0) { b.slowTimer -= dt; dt *= 0.3; }

        switch (b.behavior) {
            case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break;
            case 'malignus': stepBossCoreMalignus(dt, b, dmgScale); break;
            case 'hex':      stepBossTheHex(dt, b, dmgScale); break;
            case 'construct': stepBossGeometron(dt, b, dmgScale); break;
            case 'avian':    stepBossVoidRaven(dt, b, dmgScale); break;
            case 'broodlord': stepBossBroodlord(dt, b, dmgScale); break;
        }
    }
    function drawMissile(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2);

        ctx.fillStyle = m.isIceman ? "#a0e9ff" : "#ffddff";
        ctx.shadowColor = m.isIceman ? '#3c9aed' : '#ff8080';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(4, 5); 
        ctx.lineTo(-4, 5);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;

        const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
        ctx.fillStyle = m.isIceman ? `rgba(60, 154, 237, ${0.6 + 0.4 * Math.random()})` : `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;

        ctx.beginPath();
        ctx.moveTo(-3, 5);
        ctx.lineTo(3, 5); 
        ctx.lineTo(0, 5 + flameSize);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }
    function drawPowerup(p) { const cfg = POWERUP_TYPES[p.type]; ctx.save(); ctx.translate(p.x, p.y); const pulse = 0.8 + 0.2 * Math.sin(performance.now() / 150); ctx.scale(pulse, pulse); ctx.beginPath(); ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2); const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3); grad.addColorStop(0, '#FFD70099'); grad.addColorStop(1, '#FFD70000'); ctx.fillStyle = grad; ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, p.r, 0, Math.PI * 2); ctx.fillStyle = '#FFD70044'; ctx.fill(); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 16px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(cfg.icon, 0, 1); ctx.restore(); }
    function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }
    
    function drawLaser(laser) {
        ctx.save();
        const trailLength = 200;
        const angle = Math.atan2(laser.vy, laser.vx);
        const startX = laser.x - Math.cos(angle) * trailLength;
        const startY = laser.y - Math.sin(angle) * trailLength;

        const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
        grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
        grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = laser.r * 1.5;
        ctx.lineCap = 'round';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 25;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(laser.x, laser.y);
        ctx.stroke();
        
        // Inner bright core
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = `rgba(200, 220, 255, 0.8)`;
        ctx.shadowBlur = 10;
        ctx.stroke();

        ctx.restore();
    }
// Helper: safely add alpha to a hex color (falls back if not hex)
    function addAlpha(color, alpha) {
        const a = Math.max(0, Math.min(1, alpha));
        if (typeof color === 'string' && color.startsWith('#')) {
            let hex = color.slice(1);
            if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
            if (hex.length >= 6) {
            const r = parseInt(hex.slice(0, 2), 16);
            const g = parseInt(hex.slice(2, 4), 16);
            const b = parseInt(hex.slice(4, 6), 16);
            return `rgba(${r},${g},${b},${a})`;
            }
        }
        // If it's not hex, return as-is (the caller can tweak globalAlpha if needed)
        return color;
        }

    // Skull Ship Drawing Functions

    /**
     * @class Boss
     * Represents the main antagonist character.
     * This class encapsulates all logic for rendering, animating, and managing the state of the boss.
     */
    class Boss {
        /**
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context for the canvas.
         * @param {number} x The initial X position of the boss.
         * @param {number} y The initial Y position of the boss.
         * @param {string} skullColor The color for the skull (supports red final phase).
         */
        constructor(ctx, x, y, skullColor = '#e54d24') {
            this.ctx = ctx;
            this.x = x;
            this.y = y;
            this.skullColor = skullColor;

            this.width = 180;
            this.height = 280;

            // Animation state
            this.isAttacking = false;
            this.attackStartTime = 0;
            this.bloodDrips = [];
        }

        /**
         * Triggers the boss's attack animation (laugh and scythe swipe).
         * This should be called from the main game logic (e.g., on a timer or player action).
         * @param {boolean} playAudio - Whether to play the laugh sound effect.
         */
        triggerAttack(playAudio = true) {
            if (!this.isAttacking) {
                this.isAttacking = true;
                this.attackStartTime = Date.now();

                // Play death engine laugh sound using game's sound system
                if (playAudio && typeof playSound !== 'undefined') {
                    playSound('shao_kahn');
                }

                // Reset the attack state after the animation duration
                setTimeout(() => {
                    this.isAttacking = false;
                }, 3000);
            }
        }

        /**
         * Updates the boss's state. This should be called every frame in the game loop.
         * It handles internal animations like the blood drips.
         */
        update() {
            this._updateBloodDrips();
        }

        /**
         * Renders the boss on the canvas. This should be called every frame in the game loop after `update`.
         */
        draw() {
            this.ctx.save();
            this.ctx.translate(this.x, this.y);
            this._drawHorns();
            this._drawHead();
            this._drawFacialFeatures();
            this._addWeathering(); // Scars
            this._drawBloodDrips();
            this.ctx.restore();
        }

        // --- Private Helper Methods ---

        _drawHorns() {
            const { ctx, width: skullWidth, height: skullHeight } = this;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            let swipeAngle = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                const duration = 1000;
                if (elapsedTime < duration) {
                    const progress = elapsedTime / duration;
                    swipeAngle = Math.sin(progress * Math.PI) * -0.3;
                }
            }

            const drawHornScythe = (isFlipped) => {
                const side = isFlipped ? -1 : 1;
                ctx.save();
                
                const handleGradient = ctx.createLinearGradient(0, -200, 0, 100);
                handleGradient.addColorStop(0, '#111111');
                handleGradient.addColorStop(0.5, '#333333');
                handleGradient.addColorStop(1, '#222222');
                ctx.fillStyle = handleGradient;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 18;

                ctx.beginPath();
                ctx.moveTo(side * skullWidth * 0.35, -skullHeight * 0.4);
                const handleEndX = side * 400;
                const handleEndY = -skullHeight * 0.20;
                ctx.bezierCurveTo(side * 220, -skullHeight * 0.9, side * 350, -skullHeight * 0.1, handleEndX, handleEndY);
                ctx.bezierCurveTo(side * 360, 0, side * 230, -skullHeight * 0.55, side * skullWidth * 0.25, -skullHeight * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 10, handleEndY, 14, 20, side * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 35, handleEndY - 5, 12, 18, side * 0.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.translate(handleEndX, handleEndY);
                const baseRotation = Math.PI / 4;
                ctx.rotate(side * baseRotation + side * swipeAngle);

                const bladeGradient = ctx.createLinearGradient(side * 50, 0, side * 150, 300);
                bladeGradient.addColorStop(0, '#ffffff');
                bladeGradient.addColorStop(0.5, '#e3dac9');
                bladeGradient.addColorStop(1, '#c1b8a8');
                ctx.fillStyle = bladeGradient;
                ctx.strokeStyle = '#8c8273';
                ctx.lineWidth = 4;

                ctx.beginPath();
                const tipX = side * 150;
                const tipY = 220;
                ctx.moveTo(0, -15);
                ctx.bezierCurveTo(side * 180, 80, side * 200, 200, tipX, tipY);
                ctx.bezierCurveTo(side * 130, 160, side * 40, 70, 0, 15);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.clip();
                ctx.strokeStyle = 'rgba(80, 70, 60, 0.2)';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    const startX = side * (Math.random() * 250);
                    const startY = -15 + Math.random() * 300;
                    const length = 20 + Math.random() * 30;
                    const angle = Math.random() * Math.PI * 2;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
                    ctx.stroke();
                }
                ctx.restore();
                
                if (this.isAttacking && Math.random() < 0.3) {
                    const dripSpawnPoint = { x: tipX / 2, y: tipY / 1.5 };
                    const rotatedPoint = {
                        x: dripSpawnPoint.x * Math.cos(side * baseRotation) - dripSpawnPoint.y * Math.sin(side * baseRotation),
                        y: dripSpawnPoint.x * Math.sin(side * baseRotation) + dripSpawnPoint.y * Math.cos(side * baseRotation)
                    };
                    this._addBloodDrip(handleEndX + rotatedPoint.x, handleEndY + rotatedPoint.y);
                }

                ctx.restore();
            };

            drawHornScythe(false);
            drawHornScythe(true);
        }

        _drawHead() {
            const { ctx, width: skullWidth, height: skullHeight, skullColor } = this;
            const gradient = ctx.createRadialGradient(0, -50, skullWidth * 0.1, 0, 0, skullWidth * 1.2);
            
            if (skullColor === '#FF0000') {
                // Red final phase colors
                gradient.addColorStop(0, '#ff6666');
                gradient.addColorStop(0.5, '#ff0000');
                gradient.addColorStop(1, '#660000');
            } else {
                // Original orange colors
                gradient.addColorStop(0, '#ff8c66');
                gradient.addColorStop(0.5, '#e54d24');
                gradient.addColorStop(1, '#661a00');
            }

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#1a0a05';
            ctx.lineWidth = 8;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 20;

            ctx.beginPath();
            ctx.moveTo(0, -skullHeight * 0.55);
            ctx.bezierCurveTo(-skullWidth * 0.6, -skullHeight * 0.6, -skullWidth * 0.6, -skullHeight * 0.1, -skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(-skullWidth * 0.6, skullHeight * 0.3, -skullWidth * 0.2, skullHeight * 0.55, 0, skullHeight * 0.52);
            ctx.bezierCurveTo(skullWidth * 0.2, skullHeight * 0.55, skullWidth * 0.6, skullHeight * 0.3, skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(skullWidth * 0.6, -skullHeight * 0.1, skullWidth * 0.6, -skullHeight * 0.6, 0, -skullHeight * 0.55);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.shadowColor = 'transparent';
        }

        _drawFacialFeatures() {
            const { ctx, height: skullHeight } = this;

            const drawMirrorEye = (offsetX, isFlipped) => {
                ctx.save();
                ctx.translate(offsetX, -10);
                if (isFlipped) ctx.scale(-1, 1);
                const eyePath = new Path2D();
                eyePath.moveTo(-30, -20); eyePath.lineTo(30, -30); eyePath.lineTo(25, 28); eyePath.lineTo(-25, 25); eyePath.closePath();
                for (let i = 0; i < 6; i++) {
                    ctx.fillStyle = (i % 2 === 0 || i === 5) ? '#1a0a05' : '#ff3300';
                    ctx.fill(eyePath);
                    ctx.scale(0.8, 0.75);
                }
                ctx.restore();
            };
            drawMirrorEye(-35, true);
            drawMirrorEye(35, false);

            let mouthOpenness = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 15;
            }

            ctx.strokeStyle = 'rgba(26, 10, 5, 0.8)';
            ctx.lineWidth = 2;

            for (let i = -6; i <= 6; i++) {
                if (i === 0) continue;
                let toothWidth = 10;
                let toothHeight = 25 - Math.abs(i) * 1.2;
                const isCanine = Math.abs(i) === 5 || Math.abs(i) === 6;
                if (isCanine) {
                    toothHeight += 18;
                    toothWidth -= 2;
                }
                const xPos = i * 9;
                let yPos = skullHeight * 0.53;
                yPos -= Math.pow(i, 2) * 1.8;
                yPos += mouthOpenness;
                ctx.save();
                ctx.translate(xPos, yPos);
                ctx.beginPath();
                ctx.moveTo(-toothWidth / 2, 0);
                ctx.lineTo(toothWidth / 2, 0);
                ctx.lineTo(0, toothHeight);
                ctx.closePath();
                ctx.fillStyle = '#e8d9a9';
                ctx.fill();
                ctx.stroke();
                const tipY = toothHeight;
                ctx.fillStyle = '#8c1803';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 3, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        _addWeathering() {
            const { ctx } = this;
            ctx.strokeStyle = 'rgba(26, 10, 5, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, -30);
            ctx.lineTo(70, 10);
            ctx.lineTo(65, 15);
            ctx.stroke();
        }

        _addBloodDrip(x, y) {
            if (this.bloodDrips.length > 100) return;
            this.bloodDrips.push({
                x: x,
                y: y,
                speed: 2 + Math.random() * 3,
                size: 2 + Math.random() * 3
            });
        }

        _updateBloodDrips() {
            for (let i = this.bloodDrips.length - 1; i >= 0; i--) {
                const drip = this.bloodDrips[i];
                drip.y += drip.speed;
                if (drip.y > this.ctx.canvas.height) {
                    this.bloodDrips.splice(i, 1);
                }
            }
        }

        _drawBloodDrips() {
            const { ctx } = this;
            ctx.fillStyle = '#8c1803';
            for (const drip of this.bloodDrips) {
                ctx.beginPath();
                ctx.arc(drip.x, drip.y, drip.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawBoss(t) {
        // Special rendering for Heat Death of the Universe
        if (t.isHeatDeath) {
            // Darken the top half of screen with haze effect
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, W, H/2);
            
            // Add dark gray haze
            ctx.fillStyle = 'rgba(32, 32, 32, 0.6)';
            ctx.fillRect(0, 0, W, H/2);
            
            // No health bar or physical form - just the void
            ctx.restore();
            return;
        }
        
        ctx.save(); ctx.translate(t.x, t.y); if (t.isEnraged) {ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50);} const hpRatio = Math.max(0, Math.min(1, ((t.hp || 0) / (t.hpMax || 1)))); ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(-60, -t.r - 20, 120, 8); const healthBarColor = t.name === 'EVIL BABYMOON' ? '#ffd700' : (t.color || '#ff4444'); ctx.fillStyle = healthBarColor; ctx.fillRect(-60, -t.r - 20, 120 * hpRatio, 8); ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.strokeRect(-60, -t.r - 20, 120, 8); if (t.behavior === "malignus") {const time = performance.now() / 1000; ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.4, 0, Math.PI * 2); ctx.fill(); const numgold = 5; for (let i = 0; i < numgold; i++) {ctx.save(); const angle = time * (0.5 + 0.1 * i) + i * (2 * Math.PI / numgold); const dist = 0.8 * t.r; ctx.rotate(angle); ctx.translate(dist, 0); ctx.rotate(2 * time); ctx.fillStyle = addAlpha(t.color, 0.67); ctx.strokeStyle = "#FFFFFF"; ctx.lineWidth = 2; const goldize = 0.3 * t.r; ctx.beginPath(); ctx.moveTo(0, -goldize); ctx.lineTo(goldize / 2, goldize); ctx.lineTo(-goldize / 2, goldize); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();}} else if (t.behavior === "hex") {ctx.translate(0, 30); const bodyW_top = t.r * 1.5; const bodyW_bottom = t.r * 2.5; const bodyH = t.r * 1.5; ctx.fillStyle = "#66aaff"; ctx.strokeStyle = "#5599e5"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_bottom / 2, bodyH / 2); ctx.lineTo(-bodyW_bottom / 2, bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#e03434"; ctx.strokeStyle = "#c02d2d"; const crownH = t.r * 0.8, crownW = bodyW_top * 0.9; ctx.beginPath(); ctx.moveTo(-crownW / 2, -bodyH / 2); ctx.lineTo(-crownW / 2 + crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(0, -bodyH / 2 - crownH / 2); ctx.lineTo(crownW / 2 - crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(crownW / 2, -bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#000"; ctx.fillRect(-t.r * 0.6, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(t.r * 0.2, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(-t.r * 0.4, 0, t.r * 0.8, t.r * 0.1); ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 8; ctx.beginPath(); ctx.arc(0, 0, t.r * 1.1, 0.5, Math.PI - 0.5); ctx.stroke(); ctx.fillStyle = "#ffd700"; ctx.strokeStyle = "#daa520"; ctx.lineWidth = 3; const medR = t.r * 0.5; ctx.beginPath(); ctx.moveTo(0, t.r * 1.1 + medR); for (let i = 1; i <= 8; i++) {const angle = i * (2 * Math.PI / 8); ctx.lineTo(medR * Math.sin(angle), t.r * 1.1 + medR * Math.cos(angle));} ctx.closePath(); ctx.fill(); ctx.stroke();} else if (t.behavior === "construct") {
        // Check if this is the DEATH ENGINE boss
        if (t.name === 'DEATH ENGINE') {
            // Update skull renderer position and color for red final phase
            if (t.skullRenderer) {
                t.skullRenderer.x = 0; // Relative position since we're already translated
                t.skullRenderer.y = 0; // Relative position since we're already translated  
                t.skullRenderer.skullColor = t.color || '#e54d24';
                
                // Handle attack animation
                if (t.isLaughing && !t.skullRenderer.isAttacking) {
                    // Trigger attack animation with sound effect
                    t.skullRenderer.triggerAttack(true);
                }
                
                // Update and draw using Boss class
                t.skullRenderer.update();
                t.skullRenderer.draw();
            } else {
                // Fallback to original drawing if skullRenderer is missing (shouldn't happen)
                const skullWidth = t.r * 2; 
                const skullHeight = t.r * 2.8; 
                
                // Calculate mouth openness for animation
                let mouthOpenness = 0;
                if (t.isLaughing) {
                    const elapsedTime = performance.now() - t.laughStartTime;
                    mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 7;
                }

                // Draw all parts of the skull ship (pass boss color for red final phase)
                const skullColor = t.color || '#e54d24';
                drawSkullHorns(ctx, skullWidth, skullHeight, skullColor);
                drawSkullMain(ctx, skullWidth, skullHeight, skullColor);
                drawSkullFace(ctx, skullWidth, skullHeight, mouthOpenness, skullColor);
                drawSkullWeathering(ctx, skullWidth, skullHeight, skullColor);
            }
        } else {
            // Original GEOMETRON drawing code
            const phaseColor = t.phase === 1 ? (t.color || "#ff4500") : "#ff4500"; ctx.fillStyle = addAlpha(phaseColor, 0.67); ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; if (t.phase === 2) {ctx.shadowColor = phaseColor; ctx.shadowBlur = 25;} const bodyW = t.r * 1.2, bodyH = t.r * 1.5, headH = t.r * 0.7; ctx.beginPath(); ctx.moveTo(-bodyW * 0.5, bodyH * 0.5); ctx.lineTo(-bodyW * 0.6, bodyH * 0.2); ctx.lineTo(-bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(0, -bodyH * 0.5); ctx.lineTo(bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(bodyW * 0.6, bodyH * 0.2); ctx.lineTo(bodyW * 0.5, bodyH * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); const shoulderY = -bodyH * 0.3, shoulderX = bodyW * 0.4; const armW = 0.4 * t.r, armH = 0.9 * t.r; ctx.beginPath(); ctx.moveTo(-shoulderX, shoulderY); ctx.lineTo(-shoulderX - armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(-shoulderX, shoulderY + armH); ctx.lineTo(-shoulderX + armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(shoulderX + armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(shoulderX, shoulderY + armH); ctx.lineTo(shoulderX - armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); const eyeR = Math.max(1, t.r * 0.2 + 2 * Math.sin(performance.now() / 200)); ctx.fillStyle = "#ffffff"; ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -headH * 0.1, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        }
    } else if (t.behavior === "avian") {ctx.save(); ctx.rotate(-Math.PI / 2); const wingY = -t.r * 0.4; ctx.strokeStyle = "#FFFFFF"; ctx.fillStyle = t.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-t.r * 0.4, wingY); ctx.quadraticCurveTo(-t.r * 0.8, wingY - t.r * 0.6, -t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(-t.r * 0.9, wingY - t.r * 0.1, -t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(t.r * 0.4, wingY); ctx.quadraticCurveTo(t.r * 0.8, wingY - t.r * 0.6, t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(t.r * 0.9, wingY - t.r * 0.1, t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0, 0, t.r * 0.6, t.r * 0.8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); const eyeSize = t.r * 0.15; ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = "#FF6600"; ctx.beginPath(); ctx.moveTo(0, t.r * 0.1); ctx.lineTo(-t.r * 0.15, t.r * 0.3); ctx.lineTo(t.r * 0.15, t.r * 0.3); ctx.closePath(); ctx.fill(); ctx.restore();} else if (t.behavior === "sentinel") {
        // Cyberpunk VOID SENTINEL with purple-orange sunset gradient
        const time = performance.now() / 1000;
        
        // Create radial gradient for cyberpunk sunset effect
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
        gradient.addColorStop(0, '#FF6B35'); // Orange center
        gradient.addColorStop(0.4, '#FF8E53'); // Orange-purple transition
        gradient.addColorStop(0.7, '#8B4A9C'); // Purple
        gradient.addColorStop(1, '#2D1B69'); // Deep purple edge
        
        // Main body - hexagonal cyberpunk shape
        ctx.fillStyle = gradient;
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const sides = 6;
        for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const x = Math.cos(angle) * t.r;
            const y = Math.sin(angle) * t.r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Inner core with pulsing effect
        const pulseSize = 0.6 + 0.2 * Math.sin(time * 3);
        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 0.5);
        coreGradient.addColorStop(0, '#FFFFFF');
        coreGradient.addColorStop(0.3, '#FF6B35');
        coreGradient.addColorStop(1, '#8B4A9C');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, t.r * 0.4 * pulseSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Cyberpunk energy rings
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            const ringTime = time * (2 + i * 0.5);
            const opacity = 0.3 + 0.4 * Math.sin(ringTime);
            ctx.globalAlpha = opacity;
            
            ctx.beginPath();
            ctx.arc(0, 0, t.r * (0.7 + i * 0.15), 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        
        // Rotating cyberpunk elements
        ctx.strokeStyle = '#8B4A9C';
        ctx.fillStyle = '#FF6B35';
        ctx.lineWidth = 2;
        
        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate(i * Math.PI / 4 + time * 0.5);
            ctx.translate(t.r * 0.8, 0);
            
            // Small diamond-shaped elements
            ctx.beginPath();
            ctx.moveTo(0, -t.r * 0.08);
            ctx.lineTo(t.r * 0.06, 0);
            ctx.lineTo(0, t.r * 0.08);
            ctx.lineTo(-t.r * 0.06, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
        // Glowing eyes with cyberpunk effect
        ctx.shadowColor = '#FF6B35';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#FFFFFF';
        
        const eyeOffset = t.r * 0.25;
        ctx.beginPath();
        ctx.arc(-eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
    } else if (t.behavior === "broodlord") {
        // Draw cyberpunk HIVE SOVEREIGN - sleek and menacing
        const time = performance.now() / 1000;
        const pulseFactor = 1 + 0.08 * Math.sin(time * 3);
        
        // Create sunset gradient for main body
        const mainGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
        mainGradient.addColorStop(0, '#FF6B35'); // Orange center
        mainGradient.addColorStop(0.4, '#FF8E53'); // Orange-purple blend
        mainGradient.addColorStop(0.7, '#8B4A9C'); // Purple
        mainGradient.addColorStop(1, '#2D1B69'); // Deep void purple
        
        // Main carapace body with cyberpunk glow
        ctx.fillStyle = mainGradient;
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#8B4A9C';
        ctx.shadowBlur = 20 * pulseFactor;
        
        ctx.beginPath();
        ctx.ellipse(0, 0, t.r * 1.2 * pulseFactor, t.r * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Segmented armor plating with energy lines
        ctx.strokeStyle = "#FF8E53";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        
        for (let i = -2; i <= 2; i++) {
            const segmentPulse = 0.9 + 0.1 * Math.sin(time * 4 + i * 0.5);
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.ellipse(0, i * t.r * 0.25, t.r * 1.1 * pulseFactor * segmentPulse, t.r * 0.15, 0, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        
        // Cyberpunk energy claws/appendages
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.translate(side * t.r * 0.8, (i - 1) * t.r * 0.4);
                ctx.rotate(side * (Math.PI/6 + i * Math.PI/12) + Math.sin(time * 2 + i) * 0.15);
                
                // Energy claw with gradient
                const clawGradient = ctx.createLinearGradient(0, 0, t.r * 0.8, 0);
                clawGradient.addColorStop(0, '#8B4A9C');
                clawGradient.addColorStop(0.7, '#FF6B35');
                clawGradient.addColorStop(1, '#FFFFFF');
                
                ctx.fillStyle = clawGradient;
                ctx.strokeStyle = '#FF8E53';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FF6B35';
                ctx.shadowBlur = 8;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.lineTo(t.r * 0.7, -t.r * 0.1);
                ctx.lineTo(t.r * 0.8, 0);
                ctx.lineTo(t.r * 0.7, t.r * 0.1);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            }
        }
        ctx.shadowBlur = 0;
        
        // Cyberpunk energy eyes
        const eyeGlow = 0.6 + 0.4 * Math.sin(time * 5);
        
        for (let side = -1; side <= 1; side += 2) {
            // Outer eye glow
            ctx.shadowColor = '#FF6B35';
            ctx.shadowBlur = 20 * eyeGlow;
            ctx.fillStyle = '#FF6B35';
            
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.18 * eyeGlow, 0, Math.PI * 2);
            ctx.fill();
            
            // Main eye
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.12, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy core pupil
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#8B4A9C';
            ctx.fillStyle = '#2D1B69';
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.06, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Cyberpunk mandibles with energy effect
        ctx.shadowBlur = 0;
        const mandibleOffset = Math.sin(time * 3) * 0.12;
        
        for (let side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(side * t.r * 0.2, t.r * 0.2);
            ctx.rotate(side * (Math.PI/8 + mandibleOffset));
            
            // Mandible gradient
            const mandibleGradient = ctx.createLinearGradient(0, 0, t.r * 0.4, 0);
            mandibleGradient.addColorStop(0, '#2D1B69');
            mandibleGradient.addColorStop(0.6, '#8B4A9C');
            mandibleGradient.addColorStop(1, '#FF6B35');
            
            ctx.fillStyle = mandibleGradient;
            ctx.strokeStyle = '#FF8E53';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#8B4A9C';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(t.r * 0.3, -t.r * 0.1);
            ctx.lineTo(t.r * 0.4, 0);
            ctx.lineTo(t.r * 0.3, t.r * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        ctx.shadowBlur = 0;
        
    } else {const time = performance.now() / 1000; ctx.fillStyle = '#2c2c54'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, t.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#706fd3'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f0932b'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.3, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 6; i++) {ctx.save(); ctx.rotate(i * Math.PI / 3 + time * 0.3); ctx.translate(t.r * 0.6, 0); ctx.fillStyle = '#ff6348'; ctx.strokeStyle = '#2f3542'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore();} const eyeSize = t.r * 0.12; ctx.fillStyle = '#ff3838'; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 4; i++) {ctx.save(); ctx.rotate(i * Math.PI / 2 + time * -0.5); ctx.translate(t.r * 0.9, 0); ctx.fillStyle = '#3c6382'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 2; ctx.fillRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.strokeRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.restore();}} ctx.restore();}

    function drawShip(t, e, player) {
        let mainColor = '#b266ff', accentColor1 = '#7a49cc', accentColor2 = '#4d2a80',
            wingStrokeColor = '#c49cff', engineColor = '#cc99ff';

        switch (player.subclass) {
            case 'juggernaut':
                mainColor = '#ff3333'; accentColor1 = '#cc0000'; accentColor2 = '#990000';
                wingStrokeColor = '#ff6666'; engineColor = '#ffaaaa';
                break;
            case 'marauder':
                mainColor = '#33cc33'; accentColor1 = '#009900'; accentColor2 = '#006600';
                wingStrokeColor = '#66ff66'; engineColor = '#aaffaa';
                break;
            case 'demolitionist':
                mainColor = '#ffcc00'; accentColor1 = '#ffaa00'; accentColor2 = '#cc8800';
                wingStrokeColor = '#ffeeaa'; engineColor = '#ffffcc';
                break;
            case 'railgunner':
                mainColor = '#9933ff'; accentColor1 = '#6600cc'; accentColor2 = '#440088';
                wingStrokeColor = '#cc99ff'; engineColor = '#e6ccff';
                break;
            case 'phasestriker':
                mainColor = '#ff69b4'; accentColor1 = '#ff1493'; accentColor2 = '#c71585';
                wingStrokeColor = '#ffb6c1'; engineColor = '#ffc0cb';
                break;
            case 'stormcaller':
                mainColor = '#00bfff'; accentColor1 = '#1e90ff'; accentColor2 = '#0000cd';
                wingStrokeColor = '#87cefa'; engineColor = '#add8e6';
                break;
        }

        ctx.save();
        ctx.translate(t,e);
        if(player.isInvincible || player.hasShieldBubble){
            ctx.beginPath();ctx.arc(0,0,24,0,2*Math.PI);
            const g=ctx.createRadialGradient(0,0,18,0,0,24);
            g.addColorStop(0,"#9a66ff11");g.addColorStop(1,"#9a66ff");
            ctx.fillStyle=g;ctx.fill()
        }
        ctx.beginPath();
        ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);
        ctx.closePath();
        const o=ctx.createLinearGradient(0,-20,0,14);
        o.addColorStop(0, mainColor);o.addColorStop(.5, accentColor1);o.addColorStop(1, accentColor2);
        ctx.fillStyle=o;ctx.fill();
        ctx.lineWidth=2;ctx.strokeStyle=wingStrokeColor;ctx.stroke();
        ctx.strokeStyle=mainColor;ctx.lineWidth=2;
        ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();
        const r=performance.now()/1e3;
    ctx.globalAlpha=.8+.2*Math.sin(10*r);
    ctx.fillStyle=engineColor;
    ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,2*Math.PI);ctx.ellipse(5,16,3,6,0,0,2*Math.PI);ctx.fill();
    ctx.globalAlpha=1;
    ctx.fillStyle="#ffffff";ctx.beginPath();ctx.arc(0,-8,3,0,2*Math.PI);ctx.fill();

    const time = performance.now() / 1000;
        
        // Draw beef shield bubble if pilot is beef and shield is active
        if (player.pilotGenome === 'beef' && player.beefShield > 0) {
            const shieldPercent = player.beefShield / player.beefShieldMax;
            const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 2.5);
            
            // Base radius scales with shield level (8px minimum, up to 30px at full shield)
            const baseRadius = 8 + (22 * shieldPercent); // 8px at 0%, 30px at 100%
            // Add wobbling effect on top of the scaled base
            const wobbleAmount = 4 * shieldPercent; // Wobble gets stronger as shield grows
            const shieldRadius = baseRadius + wobbleAmount * Math.sin(time * 3);
            
            // Create void power shield gradient (dark purple/black energy)
            const shieldGradient = ctx.createRadialGradient(0, 0, shieldRadius * 0.2, 0, 0, shieldRadius);
            shieldGradient.addColorStop(0, `rgba(75, 0, 130, ${0.8 * shieldPercent})`); // Dark purple core (increased opacity)
            shieldGradient.addColorStop(0.4, `rgba(25, 25, 112, ${0.6 * shieldPercent * pulseIntensity})`); // Midnight blue (increased)
            shieldGradient.addColorStop(0.7, `rgba(72, 61, 139, ${0.7 * shieldPercent})`); // Dark slate blue (increased)
            shieldGradient.addColorStop(1, `rgba(138, 43, 226, ${0.5 * shieldPercent})`); // Purple edge (was black, now purple)
            
            ctx.beginPath();
            ctx.arc(0, 0, shieldRadius, 0, 2 * Math.PI);
            ctx.fillStyle = shieldGradient;
            ctx.fill();
            
            // Add void energy sparkles
            ctx.strokeStyle = `rgba(138, 43, 226, ${0.9 * shieldPercent * pulseIntensity})`; // Blue violet sparkles (increased opacity)
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
            
            // Add inner void energy core
            if (shieldPercent > 0.2) {
                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shieldRadius * 0.3);
                coreGradient.addColorStop(0, `rgba(147, 0, 211, ${0.6 * shieldPercent})`); // Dark violet (increased)
                coreGradient.addColorStop(1, `rgba(75, 0, 130, ${0.3 * shieldPercent})`); // (increased)
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, 0, shieldRadius * 0.3 * Math.abs(Math.sin(time * 4)), 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // Draw floating beef shield meter above ship
        if (player.pilotGenome === 'beef' && player.beefShieldMax > 0) {
            const shieldPercent = player.beefShield / player.beefShieldMax;
            const meterY = -35; // Position above ship
            const meterWidth = 40;
            const meterHeight = 4;
            
            // Background bar
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-meterWidth/2, meterY, meterWidth, meterHeight);
            
            // Shield fill bar
            if (shieldPercent > 0) {
                const fillGradient = ctx.createLinearGradient(-meterWidth/2, meterY, meterWidth/2, meterY);
                fillGradient.addColorStop(0, 'rgba(75, 0, 130, 0.9)'); // Dark purple
                fillGradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.9)'); // Blue violet
                fillGradient.addColorStop(1, 'rgba(147, 0, 211, 0.9)'); // Dark violet
                
                ctx.fillStyle = fillGradient;
                ctx.fillRect(-meterWidth/2, meterY, meterWidth * shieldPercent, meterHeight);
            }
            
            // Border
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
            ctx.lineWidth = 1;
            ctx.strokeRect(-meterWidth/2, meterY, meterWidth, meterHeight);
            
            // Shield text
            ctx.fillStyle = 'rgba(138, 43, 226, 0.9)';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            const shieldText = `${Math.round(player.beefShield)}/${Math.round(player.beefShieldMax)}`;
            ctx.fillText(shieldText, 0, meterY - 2);
        }

        if (player.hasRearGuard && player.rearGuardReady) {
            const pulse = 0.4 + 0.3 * Math.sin(performance.now() / 200);
            ctx.fillStyle = `rgba(100, 255, 255, ${pulse})`;
            ctx.beginPath();
            ctx.arc(0, 15, 8, 0, 2 * Math.PI);
            ctx.fill();
        }

        ctx.restore();
    }

    function drawMine(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        const time = performance.now();
        const pulse = 0.8 + 0.2 * Math.sin(time / 150);
        const fuseRatio = m.fuse / 5;
        const color = `rgb(255, ${100 * fuseRatio}, ${80 * fuseRatio})`;

        ctx.beginPath();
        ctx.arc(0, 0, m.r * 1.5 * pulse, 0, 2 * Math.PI);
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, m.r * 1.5 * pulse);
        grad.addColorStop(0, color + '99');
        grad.addColorStop(1, color + '00');
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(0, 0, m.r, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, m.r * 0.4 * pulse, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawEnemy(e) {
        const { x: t, y: o, r: a, type: r, color: n, hp: l, hpMax: s, t: c } = e;
        ctx.save();
        let drawX = t;
        let drawY = o;
        if (e.hitShakeTimer && e.hitShakeTimer > 0 && e.hitShakeIntensity) {
            const baseDuration = e.hitShakeDuration || 0.16;
            const ratio = baseDuration > 0 ? Math.max(0, Math.min(1, e.hitShakeTimer / baseDuration)) : 0;
            const intensity = e.hitShakeIntensity * Math.pow(ratio, 0.6);
            const phaseSeed = (e.id || 0) * 13.37;
            const time = performance.now() * 0.006 + phaseSeed;
            drawX += Math.sin(time) * intensity;
            drawY += Math.cos(time * 1.6) * intensity * 0.7;
        }
        ctx.translate(drawX, drawY);
        const spawnAlpha = e.spawnOpacity !== undefined ? Math.max(0.2, Math.min(1, e.spawnOpacity)) : 1;
        ctx.globalAlpha *= spawnAlpha;
        if (e.spawnPhase === 'teleport') {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const time = performance.now() / 200;
            const ringRadius = (a + 8) * (0.9 + 0.05 * Math.sin(time + (e.spawnClusterIndex || 0)));
            const ringAlpha = 0.35 + 0.25 * spawnAlpha;
            ctx.globalAlpha = ringAlpha;
            ctx.strokeStyle = e.spawnEffectColor || '#9ad7ff';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = ringAlpha * 0.7;
            ctx.beginPath();
            ctx.arc(0, 0, ringRadius * 0.65, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        // Apply flattening effect if enemy has flattenScale property
        if (e.flattenScale !== undefined) {
            if (typeof e.flattenScale === 'number') {
                ctx.scale(1, e.flattenScale);
            } else {
                ctx.scale(e.flattenScale.x || 1, e.flattenScale.y || 1);
            }
        }
        l<s&&l>0&&(ctx.fillStyle='rgba(0,0,0,0.5)',ctx.fillRect(-a,-a-8,2*a,3),ctx.fillStyle="#b266ff",ctx.fillRect(-a,-a-8,2*a*(l/s),3));ctx.lineWidth=2;ctx.beginPath();switch(r){case"avian_hatchling":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a*1.2);ctx.lineTo(a,-a*0.5);ctx.lineTo(a,a*0.5);ctx.lineTo(0,a*1.2);ctx.lineTo(-a,a*0.5);ctx.lineTo(-a,-a*0.5);ctx.closePath();ctx.fill();ctx.stroke();break;case"construct_gold":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a);ctx.lineTo(a,0);ctx.lineTo(0,a);ctx.lineTo(-a,0);ctx.closePath();ctx.fill();ctx.stroke();break;case"trap_king_add":case"drone":const e=ctx.createLinearGradient(-a,-a,a,a);e.addColorStop(0,"#E0E0E0");e.addColorStop(1,"#A0A0A0");ctx.fillStyle=e;ctx.strokeStyle="#808080";ctx.beginPath();ctx.moveTo(-1.2*a,0);ctx.quadraticCurveTo(0,-a,1.2*a,0);ctx.quadraticCurveTo(0,.6*a,-1.2*a,0);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#aaddff";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-.2*a,.6*a,Math.PI,0);ctx.fill();ctx.stroke();ctx.fillStyle=r==="trap_king_add"?"#ffc83d":"#32CD32";ctx.beginPath();ctx.ellipse(0,-.2*a,.3*a,.4*a,0,0,2*Math.PI);ctx.fill();ctx.fillStyle="#000000";ctx.beginPath();ctx.ellipse(-.1*a,-.25*a,.08*a,.15*a,-.5,0,2*Math.PI);ctx.ellipse(.1*a,-.25*a,.08*a,.15*a,.5,0,2*Math.PI);ctx.fill();break;
        case "hunter": {
            const time = performance.now() / 1000;
            const segments = 8;
            const length = a * 2;
            const amplitude = a * 0.5;

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            ctx.setLineDash([]);

            const top = [];
            const bottom = [];

            for (let i = 0; i <= segments; i++) {
                const progress = i / segments;
                const width = a * Math.sin(progress * Math.PI) * 0.4;
                const x = Math.sin(progress * 2 * Math.PI + c * 4) * amplitude;
                const y = (progress - 0.5) * length;
                top.push({ x: x + width, y });
                bottom.push({ x: x - width, y });
            }

            ctx.fillStyle = '#cc3344';
            ctx.strokeStyle = '#7a1b24';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(top[0].x, top[0].y);
            for (let i = 1; i < top.length; i++) ctx.lineTo(top[i].x, top[i].y);
            for (let i = bottom.length - 1; i >= 0; i--) ctx.lineTo(bottom[i].x, bottom[i].y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            const headX = Math.sin(c * 4) * amplitude;
            const headY = -0.5 * length;

            ctx.fillStyle = '#e47777';
            ctx.strokeStyle = '#7a1b24';
            ctx.beginPath();
            ctx.arc(headX, headY, a * 0.35, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#250b0b';
            const eyeOffsetX = a * 0.12;
            const eyeOffsetY = a * 0.05;
            const eyeRadius = a * 0.08;
            ctx.beginPath();
            ctx.arc(headX - eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.arc(headX + eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#7a1b24';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(headX, headY + a * 0.1);
            ctx.lineTo(headX, headY + a * 0.4);
            ctx.stroke();

            break;
        }
        case "phantom":
            ctx.globalAlpha=.6+.4*Math.sin(5*c);ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-.8*a);ctx.quadraticCurveTo(a,-.5*a,.8*a,.8*a);ctx.quadraticCurveTo(0,.5*a,-.8*a,.8*a);ctx.quadraticCurveTo(-a,-.5*a,0,-.8*a);ctx.closePath();ctx.fill();ctx.stroke();for(let e=-1;e<=1;e++)ctx.beginPath(),ctx.moveTo(e*.4*a,.6*a),ctx.quadraticCurveTo(e*.5*a,a,e*.3*a+2*Math.sin(4*c+e),1.2*a),ctx.stroke();break;
    case "mech": 
            // Enhanced mechanical tank enemy with Aquaman aqua blue theme
            const time = performance.now() / 1000;
            const pulseFactor = 1 + 0.05 * Math.sin(time * 4);
            
            // Aquaman color scheme: aqua blues and ocean greens
            const mainColor = '#0e4b5c'; // Deep aqua blue
            const accentColor = '#20b2aa'; // Light sea green
            const metalColor = '#2e8b8b'; // Dark cyan/teal
            const glowColor = '#00ffff'; // Bright cyan glow
            const highlightColor = '#40e0d0'; // Turquoise highlights
            
            ctx.lineWidth = 2;
            
            // Main chassis with aqua gradient shading
            const chassisGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.2);
            chassisGradient.addColorStop(0, highlightColor);
            chassisGradient.addColorStop(0.6, mainColor);
            chassisGradient.addColorStop(1, '#051e28'); // Deep ocean blue
            
            ctx.fillStyle = chassisGradient;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.moveTo(-a * 1.2, -a * 1.0);
            ctx.lineTo(a * 1.2, -a * 1.0); 
            ctx.lineTo(a * 0.7, a * 0.6);  
            ctx.lineTo(-a * 0.7, a * 0.6); 
            ctx.closePath(); 
            ctx.fill(); 
            ctx.stroke();
            
            // Armor plating with rivets
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 1;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(i * a * 0.2, -a * 0.8);
                ctx.lineTo(i * a * 0.15, a * 0.4);
                ctx.stroke();
            }
            
            // Rivets with aqua metallic finish
            ctx.fillStyle = '#5f9ea0'; // Cadet blue rivets
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    ctx.beginPath();
                    ctx.arc(i * a * 0.3, j * a * 0.3, a * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Weapon turrets with menacing design
            ctx.lineWidth = 3;
            // Left turret
            ctx.fillStyle = mainColor;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.rect(-a * 1.6, -a * 0.9, a * 0.7, a * 1.8);
            ctx.fill(); ctx.stroke();
            
            // Left cannon barrel
            ctx.fillStyle = metalColor;
            ctx.beginPath();
            ctx.rect(-a * 1.3 - a * 0.5, -a * 0.1, a * 0.8, a * 0.2);
            ctx.fill(); ctx.stroke();
            
            // Right turret
            ctx.fillStyle = mainColor;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.rect(a * 0.9, -a * 0.9, a * 0.7, a * 1.8);
            ctx.fill(); ctx.stroke();
            
            // Right cannon barrel
            ctx.fillStyle = metalColor;
            ctx.beginPath();
            ctx.rect(a * 1.3, -a * 0.1, a * 0.8, a * 0.2);
            ctx.fill(); ctx.stroke();
            
            // Aqua blue eyes/sensors with oceanic glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 8 * pulseFactor;
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(-a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Tank treads with aqua metallic detail
            ctx.fillStyle = '#1c4e4e'; // Dark teal treads
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 2;
            
            // Left tread
            ctx.beginPath();
            ctx.arc(-a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            
            // Tread segments
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time * 2;
                const x = -a * 1.3 + Math.cos(angle) * a * 0.4;
                const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                ctx.fillStyle = '#4682b4'; // Steel blue segments
                ctx.beginPath();
                ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                ctx.fill();
            }
            
            // Right tread
            ctx.fillStyle = '#1c4e4e'; // Dark teal treads
            ctx.beginPath();
            ctx.arc(a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            
            // Right tread segments
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time * 2;
                const x = a * 1.3 + Math.cos(angle) * a * 0.4;
                const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                ctx.fillStyle = '#4682b4'; // Steel blue segments
                ctx.beginPath();
                ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                ctx.fill();
            }
            
            // Command center/cockpit with aqua gradient
            const cockpitGradient = ctx.createLinearGradient(0, -a * 1.4, 0, -a * 1.0);
            cockpitGradient.addColorStop(0, accentColor);
            cockpitGradient.addColorStop(0.5, mainColor);
            cockpitGradient.addColorStop(1, '#0a2533'); // Deep ocean blue
            
            ctx.fillStyle = cockpitGradient;
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(-a * 0.4, -a * 1.4, a * 0.8, a * 0.5);
            ctx.fill(); ctx.stroke();
            
            // Antenna/communication array
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -a * 1.4);
            ctx.lineTo(-a * 0.2, -a * 1.8);
            ctx.moveTo(0, -a * 1.4);
            ctx.lineTo(a * 0.2, -a * 1.8);
            ctx.stroke();
            
            // Aqua warning lights
            ctx.fillStyle = time % 1 < 0.5 ? glowColor : '#004d4d';
            ctx.beginPath();
            ctx.arc(-a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
            ctx.fill();
            
            // Aqua energy exhaust vents
            ctx.fillStyle = '#00bfff'; // Deep sky blue exhaust
            ctx.shadowColor = '#00bfff';
            ctx.shadowBlur = 4;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.rect(-a * 0.1 + i * a * 0.1, a * 0.4, a * 0.05, a * 0.2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            break;
// Color schemes dictionary for void_champion variants
const VOID_CHAMPION_COLOR_SCHEMES = {
    purple: {
        name: 'Void Wraith',
        shadowColor: '#b56bff',
        auraColor: '#7a34ff',
        hullGradient: ['#5f18c4', '#1b0635', '#320a63'],
        strokeColor: '#c6a4ff',
        finColor: [155, 69, 255], // RGB for rgba usage
        visorGradient: ['#f5d9ff', '#7d2cff'],
        eyeColor: '#ff508f',
        coreGlow: '#e499ff',
        coreColor: '#ffe6ff',
        thrusterColor: '#732bff'
    },
    crimson: {
        name: 'Crimson Reaper',
        shadowColor: '#ff4444',
        auraColor: '#cc1100',
        hullGradient: ['#8b0000', '#330000', '#4a0000'],
        strokeColor: '#ff6666',
        finColor: [200, 50, 50],
        visorGradient: ['#ffcccc', '#990000'],
        eyeColor: '#ffff00',
        coreGlow: '#ff8888',
        coreColor: '#ffffff',
        thrusterColor: '#cc0000'
    },
    azure: {
        name: 'Azure Phantom',
        shadowColor: '#4488ff',
        auraColor: '#0044cc',
        hullGradient: ['#1144aa', '#001122', '#002244'],
        strokeColor: '#66aaff',
        finColor: [100, 150, 255],
        visorGradient: ['#ccddff', '#0066cc'],
        eyeColor: '#00ffff',
        coreGlow: '#88bbff',
        coreColor: '#ffffff',
        thrusterColor: '#0088ff'
    },
    emerald: {
        name: 'Emerald Specter',
        shadowColor: '#44ff44',
        auraColor: '#00cc44',
        hullGradient: ['#006600', '#001100', '#003300'],
        strokeColor: '#66ff66',
        finColor: [50, 200, 50],
        visorGradient: ['#ccffcc', '#009900'],
        eyeColor: '#ffff00',
        coreGlow: '#88ff88',
        coreColor: '#ffffff',
        thrusterColor: '#00cc00'
    },
    golden: {
        name: 'Golden Harbinger',
        shadowColor: '#ffcc44',
        auraColor: '#cc8800',
        hullGradient: ['#b8860b', '#4a3c00', '#6b5b00'],
        strokeColor: '#ffd700',
        finColor: [255, 200, 50],
        visorGradient: ['#fffacd', '#daa520'],
        eyeColor: '#ff4500',
        coreGlow: '#ffd700',
        coreColor: '#ffffff',
        thrusterColor: '#b8860b'
    }
};

// Function to get color scheme for void_champion
function getVoidChampionColorScheme(enemy) {
    // Use enemy's unique ID or position to determine color scheme consistently
    if (!enemy.colorScheme) {
        const schemes = Object.keys(VOID_CHAMPION_COLOR_SCHEMES);
        const seed = enemy.id || (enemy.x + enemy.y * 1000); // Use ID or position as seed
        const schemeIndex = Math.abs(Math.floor(seed)) % schemes.length;
        enemy.colorScheme = schemes[schemeIndex];
        enemy.displayName = VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme].name;
    }
    return VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme];
}

        case "void_champion": {
            const time = performance.now() / 1000;
            const shimmer = 0.55 + 0.45 * Math.sin(time * 6 + c * 3);
            const wingPulse = 0.8 + 0.2 * Math.sin(time * 5 + c * 2);
            
            // Get color scheme for this specific enemy
            const colors = getVoidChampionColorScheme(e);

            ctx.save();
            ctx.shadowColor = colors.shadowColor;
            ctx.shadowBlur = 8 * shimmer;

            // Outer aura to hint at teleport energy
            ctx.globalAlpha = 0.28 * shimmer;
            ctx.fillStyle = colors.auraColor;
            ctx.beginPath();
            ctx.arc(0, 0, a * 1.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Player-like hull with evil tint
            const hullGradient = ctx.createLinearGradient(0, -a * 1.3, 0, a * 1.1);
            hullGradient.addColorStop(0, colors.hullGradient[0]);
            hullGradient.addColorStop(0.45, colors.hullGradient[1]);
            hullGradient.addColorStop(1, colors.hullGradient[2]);
            ctx.fillStyle = hullGradient;
            ctx.strokeStyle = colors.strokeColor;
            ctx.lineWidth = 1.8;
            ctx.beginPath();
            ctx.moveTo(0, -a * 1.15);
            ctx.lineTo(a * 0.78, a * 0.35);
            ctx.lineTo(0, a * 1.1);
            ctx.lineTo(-a * 0.78, a * 0.35);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Mirrored shoulder fins
            ctx.fillStyle = `rgba(${colors.finColor[0]}, ${colors.finColor[1]}, ${colors.finColor[2]}, ${0.4 + 0.4 * shimmer})`;
            ctx.beginPath();
            ctx.moveTo(-a * 1.05, -a * 0.05);
            ctx.quadraticCurveTo(-a * 1.4, a * 0.35 * wingPulse, -a * 0.55, a * 0.55);
            ctx.lineTo(-a * 0.3, a * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(a * 1.05, -a * 0.05);
            ctx.quadraticCurveTo(a * 1.4, a * 0.35 * wingPulse, a * 0.55, a * 0.55);
            ctx.lineTo(a * 0.3, a * 0.1);
            ctx.closePath();
            ctx.fill();

            // Face visor resembling the player silhouette
            const visorGradient = ctx.createLinearGradient(0, -a * 0.8, 0, -a * 0.2);
            visorGradient.addColorStop(0, colors.visorGradient[0]);
            visorGradient.addColorStop(1, colors.visorGradient[1]);
            ctx.fillStyle = visorGradient;
            ctx.beginPath();
            ctx.moveTo(-a * 0.4, -a * 0.5);
            ctx.quadraticCurveTo(0, -a * 0.9, a * 0.4, -a * 0.5);
            ctx.quadraticCurveTo(0, -a * 0.25, -a * 0.4, -a * 0.5);
            ctx.fill();

            // Eyes for villain vibe
            ctx.fillStyle = colors.eyeColor;
            ctx.beginPath();
            ctx.ellipse(-a * 0.18, -a * 0.55, a * 0.11, a * 0.08, -0.3, 0, Math.PI * 2);
            ctx.ellipse(a * 0.18, -a * 0.55, a * 0.11, a * 0.08, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Chest core
            ctx.shadowBlur = 12 * shimmer;
            ctx.shadowColor = colors.coreGlow;
            ctx.fillStyle = colors.coreColor;
            ctx.beginPath();
            ctx.arc(0, a * 0.15, a * (0.32 + 0.08 * shimmer), 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Trail thruster
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = colors.thrusterColor;
            ctx.beginPath();
            ctx.moveTo(-a * 0.28, a * 1.05);
            ctx.lineTo(0, a * (1.45 + 0.2 * shimmer));
            ctx.lineTo(a * 0.28, a * 1.05);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.restore();
            break;
        }
        case "void_champion_orb": {
            const time = performance.now() / 1000;
            const flicker = 0.6 + 0.4 * Math.sin(time * 10 + c * 8);
            const radius = a * (0.85 + 0.15 * flicker);

            ctx.fillStyle = `rgba(255, 122, 229, ${0.35 + 0.4 * flicker})`;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff7deb';
            ctx.strokeStyle = '#ffe0f8';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(-radius * 0.6, -radius * 0.2);
            ctx.lineTo(radius * 0.9, 0);
            ctx.lineTo(-radius * 0.6, radius * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(radius * 0.25, 0, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff4fb5';
            ctx.beginPath();
            ctx.arc(radius * 0.25, 0, radius * 0.18, 0, Math.PI * 2);
            ctx.fill();

            // trailing spark
            ctx.strokeStyle = `rgba(255, 125, 235, ${0.4 + 0.3 * flicker})`;
            ctx.lineWidth = 1.8;
            ctx.beginPath();
            ctx.moveTo(-radius * 1.2, 0);
            ctx.lineTo(-radius * 2, 0);
            ctx.stroke();
            break;
        }
        case "angler": {
            const scale = a / 20;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle = n + "99"; ctx.strokeStyle = n; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-20,0);
            ctx.quadraticCurveTo(0,-18,24,0);
            ctx.quadraticCurveTo(0,16,-20,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-6,5);
            ctx.quadraticCurveTo(2,10,10,4);
            ctx.stroke();
            ctx.beginPath(); ctx.moveTo(8,-6);
            ctx.quadraticCurveTo(20,-24,32,-28); ctx.stroke();
            ctx.shadowColor="#00FFD5"; ctx.shadowBlur=12;
            ctx.beginPath(); ctx.arc(32,-28,4,0,Math.PI*2); ctx.fillStyle="#00FFD5"; ctx.fill();
            ctx.restore();
            break;
        }
        case "manta": {
            const scale = a / 36;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle= n + "cc"; ctx.strokeStyle=n; ctx.lineWidth=2;

            ctx.beginPath();
            ctx.moveTo(-36,0);
            ctx.quadraticCurveTo(-8,-18,0,-8);
            ctx.quadraticCurveTo(8,-18,36,0);
            ctx.quadraticCurveTo(8,14,0,8);
            ctx.quadraticCurveTo(-8,14,-36,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0,8);
            ctx.quadraticCurveTo(4,22,0,30);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
            ctx.restore();
            break;
        }
    }
    if (e.stunTimer && e.stunTimer > 0) {
        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + 0.3 * Math.sin(performance.now() / 100)})`;
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('STUN', 0, -a - 12);
    }
    if (e.vulnerabilityPulseStrength && e.vulnerabilityPulseColor) {
        const pulse = (Math.sin(performance.now() / 120) + 1) * 0.5;
        ctx.save();
        ctx.globalAlpha = Math.min(0.9, e.vulnerabilityPulseStrength);
        ctx.strokeStyle = e.vulnerabilityPulseColor;
        ctx.lineWidth = 2.5 + pulse * 2;
        ctx.beginPath();
        ctx.arc(0, 0, a * (1.05 + 0.2 * pulse), 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
    if (e.railgunArmorTimer > 0) {
        ctx.save();
        ctx.strokeStyle = `rgba(215,240,255,${Math.min(0.8, e.railgunArmorTimer / 2)})`;
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(-a * 0.6, -a * 0.3);
        ctx.lineTo(0, 0);
        ctx.lineTo(a * 0.5, -a * 0.2);
        ctx.moveTo(0, 0);
        ctx.lineTo(-a * 0.2, a * 0.5);
        ctx.stroke();
        ctx.restore();
    }
    if (e.phaseLockTimer > 0) {
        ctx.save();
        ctx.globalAlpha = 0.4 + 0.2 * Math.sin(performance.now() / 60);
        ctx.strokeStyle = '#9e7cff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, a * 1.2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-a * 1.2, 0);
        ctx.lineTo(a * 1.2, 0);
        ctx.moveTo(0, -a * 1.2);
        ctx.lineTo(0, a * 1.2);
        ctx.stroke();
        ctx.restore();
    }
    if (e.stormShockTimer > 0) {
        ctx.save();
        ctx.globalAlpha = Math.min(0.8, 0.4 + e.stormShockTimer * 0.3);
        ctx.strokeStyle = '#66d6ff';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2 + performance.now() / 250;
            ctx.beginPath();
            ctx.moveTo(Math.cos(angle) * a * 0.4, Math.sin(angle) * a * 0.4);
            ctx.lineTo(Math.cos(angle) * a * 1.3, Math.sin(angle) * a * 1.3);
            ctx.stroke();
        }
        ctx.restore();
    }
    if (e.demolitionPulseWarmup > 0) {
        ctx.save();
        ctx.globalAlpha = Math.min(0.6, e.demolitionPulseWarmup * 1.2);
        const grad = ctx.createRadialGradient(0, 0, a * 0.2, 0, 0, a * 1.4);
        grad.addColorStop(0, 'rgba(255, 170, 90, 0.7)');
        grad.addColorStop(1, 'rgba(255, 90, 0, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, a * (1 + (1 - e.demolitionPulseWarmup) * 0.4), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    ctx.restore()
    }
    function createEffect(type,x,y, radius, options = {}){
        const opts = options || {};
        let effect={isActive:!0,life:1,maxLife:1,x,y,radius,opts};
        switch(type){
            case "heartbeatPulse":
                effect.maxLife = 0.6;
                effect.life = effect.maxLife;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const alpha = Math.sin((this.life / this.maxLife) * Math.PI) * 0.4;
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "beefCharge":
                effect.maxLife = 0.4;
                effect.origin = x;
                effect.target = y;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const progress = 1 - this.life;
                    const currentX = this.origin.x + (this.target.x - this.origin.x) * progress;
                    const currentY = this.origin.y + (this.target.y - this.origin.y) * progress;
        
                    ctx.save();
                    if(progress > 0.5) {
                        const shockwaveProgress = (progress - 0.5) / 0.5;
                        ctx.strokeStyle = `rgba(255, 100, 100, ${1 - shockwaveProgress})`;
                        ctx.lineWidth = 5 * (1 - shockwaveProgress);
                        ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, 80 * shockwaveProgress, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = `rgba(255, 150, 150, ${this.life})`;
                    ctx.lineWidth = 15 * this.life;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.origin.x, this.origin.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "spawnTeleport":
                effect.maxLife = opts.duration ?? 0.85;
                effect.life = effect.maxLife;
                effect.radius = radius || 18;
                effect.color = opts.color || '#9ad7ff';
                effect.clusterIndex = opts.clusterIndex ?? 0;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const t = 1 - (this.life / this.maxLife);
                    const eased = 1 - Math.pow(1 - t, 2.4);
                    const alpha = Math.max(0, 0.75 * (1 - eased));
                    const ringPulse = 0.8 + Math.sin(performance.now() / 140 + this.clusterIndex) * 0.15;
                    const baseRadius = this.radius * (0.85 + eased * 0.55);
                    ctx.save();
                    ctx.translate(this.x, this.y + (opts.fallback ? 6 : 0));
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = alpha;
                    const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, baseRadius * 1.15);
                    gradient.addColorStop(0, `${this.color}aa`);
                    gradient.addColorStop(1, `${this.color}00`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * 1.15, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * ringPulse, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.lineWidth = 1.2;
                    ctx.globalAlpha *= 0.8;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * (0.55 + Math.sin(performance.now() / 180 + this.clusterIndex) * 0.1), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "goldenOrbSpawn":
                effect.maxLife = 0.65;
                effect.life = effect.maxLife;
                effect.radius = radius || 70;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const progress = 1 - (this.life / this.maxLife);
                    const currentRadius = this.radius * (0.55 + progress * 0.7);
                    const time = performance.now() / 1000;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalCompositeOperation = 'lighter';
                    const glow = ctx.createRadialGradient(0, 0, currentRadius * 0.25, 0, 0, currentRadius);
                    glow.addColorStop(0, 'rgba(255, 245, 200, 0.75)');
                    glow.addColorStop(0.6, 'rgba(255, 210, 90, 0.55)');
                    glow.addColorStop(1, 'rgba(255, 110, 20, 0)');
                    ctx.globalAlpha = 0.85 - progress * 0.5;
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 220, 120, ${0.9 - progress})`;
                    ctx.lineWidth = 3 + 4 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(0, 0, currentRadius * (0.7 + Math.sin(time * 12) * 0.08), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "goldenOrbDetonation":
                effect.maxLife = 0.6;
                effect.life = effect.maxLife;
                effect.radius = radius || 150;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const t = 1 - (this.life / this.maxLife);
                    const ringRadius = this.radius * t;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalCompositeOperation = 'lighter';
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, ringRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 0.75)');
                    gradient.addColorStop(0.35, 'rgba(255, 210, 90, 0.55)');
                    gradient.addColorStop(0.8, 'rgba(255, 120, 0, 0.15)');
                    gradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 200, 80, ${1 - t})`;
                    ctx.lineWidth = 6 * (1 - t);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius * 0.72, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "hitSpark":
                effect.maxLife = 0.22;
                effect.life = effect.maxLife;
                effect.radius = radius || 14;
                effect.sparks = Array.from({ length: opts.crit ? 8 : 5 }, (_, i) => {
                    const spread = (Math.random() - 0.5) * 0.9;
                    const angle = (opts.angle ?? 0) + spread;
                    const power = (opts.strength ?? 120) * (0.45 + Math.random() * 0.35);
                    return {
                        angle,
                        speed: power * 0.015,
                        length: effect.radius * (opts.crit ? 1.6 : 1.2) * (0.9 + Math.random() * 0.3),
                        offset: (i / Math.max(1, (opts.crit ? 8 : 5))) * 0.35
                    };
                });
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const t = 1 - (this.life / this.maxLife);
                    const fade = 1 - t;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.75 * fade;
                    ctx.strokeStyle = opts.crit ? '#ffd6ff' : '#ff9adb';
                    ctx.lineWidth = opts.crit ? 2.6 * fade : 1.8 * fade;
                    this.sparks.forEach(spark => {
                        const dist = spark.length * fade;
                        const dx = Math.cos(spark.angle) * dist;
                        const dy = Math.sin(spark.angle) * dist;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(spark.angle) * spark.offset * this.radius, Math.sin(spark.angle) * spark.offset * this.radius);
                        ctx.lineTo(dx, dy);
                        ctx.stroke();
                    });
                    ctx.restore();
                };
                break;
            case "rearGuardBlock":
                effect.maxLife = 0.5;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${this.life})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 5, 20 * (1.2 - this.life), Math.PI * 0.2, Math.PI * 0.8);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "gravityWell":
                effect.maxLife = 7;
                effect.life = 7;
                effect.radius = 0;
                effect.maxRadius = 150;
                effect.damagePulseT = 1;
                effect.totalDamageDealtToBoss = 0;
                effect.stars = [];
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * effect.maxRadius;
                    effect.stars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        r: Math.random() * 1.5,
                        initialDist: dist
                    });
                }
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) {
                        this.isActive = false;
                        screenFlash(1, 400, 'rgba(255, 255, 255, 0.5)');
                        return;
                    }
                    if (this.radius < this.maxRadius) {
                        this.radius += 200 * dt;
                    }

                    this.damagePulseT -= dt;
                    const damageThisFrame = this.damagePulseT <= 0;
                    if (damageThisFrame) {
                        this.damagePulseT = 1;
                    }
                    
                    const pullStrength = 300;
                    const damageRadiusSq = (this.maxRadius * 0.7)**2;

                    store.enemies.forEach(e => {
                        if (e.dead) {
                            return; 
                        }
                        const dx = this.x - e.x;
                        const dy = this.y - e.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < this.radius**2) {
                            const dist = Math.sqrt(distSq);
                            if (dist > 10) {
                                const resistance = (e.type === 'mech' || e.type === 'hunter') ? 0.7 : 1.0;
                                e.x += (dx / dist) * pullStrength * resistance * dt;
                                e.y += (dy / dist) * pullStrength * resistance * dt;
                            }
                            
                            if (damageThisFrame && distSq < damageRadiusSq) {
                                const damage = e.hpMax * (0.25 * store.player.dmgMult);
                                e.hp -= damage;
                                store.world.totalDamage += damage;
                                
                                // Apply vampirism healing for blink damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = damage * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }
                            }
                        }
                    });
                     if (store.boss) {
                         const b = store.boss;
                          const dx = this.x - b.x;
                          const dy = this.y - b.y;
                          const distSq = dx*dx + dy*dy;
                          if(distSq < this.radius**2) {
                               const dist = Math.sqrt(distSq);
                               if (dist > 50) {
                                   b.x += (dx/dist) * pullStrength * 0.5 * dt;
                                   b.y += (dy/dist) * pullStrength * 0.5 * dt;
                               }
                               if (damageThisFrame && distSq < damageRadiusSq) {
                                    const damageToDeal = b.hpMax * (0.10 * store.player.dmgMult);
                                    const cap = b.hpMax * 0.5;
                                    let actualDamage = damageToDeal;
                                    if (this.totalDamageDealtToBoss + actualDamage > cap) {
                                        actualDamage = cap - this.totalDamageDealtToBoss;
                                    }
                                    if (actualDamage > 0) {
                                        b.hp -= actualDamage;
                                        this.totalDamageDealtToBoss += actualDamage;
                                        store.world.totalDamage += actualDamage;
                                        
                                        // Apply vampirism healing for blink damage on boss
                                        if (store.player.vampirism > 0) {
                                            let healAmount = actualDamage * store.player.vampirism;
                                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                        }
                                    }
                               }
                           }
                      }
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const time = performance.now();
                    const lifeRatio = this.life / this.maxLife;

                    ctx.fillStyle = 'white';
                    this.stars.forEach(star => {
                        const pullFactor = 1 - lifeRatio;
                        const currentDist = star.initialDist * (1 - pullFactor * 0.95);
                        const angle = Math.atan2(star.y, star.x) + pullFactor * 3;
                        const sx = Math.cos(angle) * currentDist;
                        const sy = Math.sin(angle) * currentDist;
                        
                        if (currentDist < this.radius) {
                            ctx.globalAlpha = lifeRatio * (currentDist / this.radius);
                            ctx.beginPath();
                            ctx.arc(sx, sy, star.r, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                    ctx.globalAlpha = 1;

                    for (let i = 0; i < 5; i++) {
                        const rotation = (time / (2000 + i * 200)) % (2 * Math.PI);
                        ctx.strokeStyle = `rgba(0, 0, 5, ${0.4 * lifeRatio})`;
                        ctx.lineWidth = (2 + i) * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, (this.radius / 5) * (i + 1), rotation, rotation + Math.PI * 1.5);
                        ctx.stroke();
                    }
                    
                    const corePulse = 3 + Math.sin(time / 100) * 2;
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse * 2);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    coreGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.7)');
                    coreGrad.addColorStop(1, 'rgba(150, 150, 255, 0)');
                    ctx.fillStyle = coreGrad;
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, corePulse * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case"grenadeExplosion":
                effect.maxLife=.5;
                effect.radius=radius || 60;
                effect.step=function(dt){this.life-=2*dt;this.life<=0&&(this.isActive=!1)};
                effect.draw=function(){
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.radius*(1-this.life),0,2*Math.PI);
                    ctx.fillStyle=`rgba(255, 153, 51, ${.8*this.life})`;
                    ctx.fill()
                };
                break;
            case"shieldBreak":effect.maxLife=.6;effect.step=function(dt){this.life-=1.5*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.strokeStyle=`rgba(154, 102, 255, ${this.life})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(this.x,this.y,24*(1.5-this.life),0,2*Math.PI);ctx.stroke()};break;
            case "nanoHeal":
                effect.maxLife = 0.7;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const p = 1 - this.life;
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                    ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "jugFearIgnite":
                effect.maxLife = 0.6;
                effect.radius = radius || 40;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const progress = 1 - this.life;
                    ctx.globalAlpha = 0.5 + 0.4 * Math.sin(performance.now() / 60);
                    ctx.fillStyle = 'rgba(255,80,40,0.6)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (0.7 + progress * 0.6), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = 'rgba(255,200,120,0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (0.4 + progress * 0.3), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "jugFearEmber":
                effect.maxLife = 0.4;
                effect.radius = radius || 20;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 40 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = 'rgba(255,150,80,0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (0.4 + 0.6 * this.life), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "marauderLaunchTrail":
                const trailCfg = radius || {};
                effect.maxLife = trailCfg.duration || 0.5;
                effect.life = effect.maxLife;
                effect.followEnemy = trailCfg.enemy || null;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.followEnemy) {
                        this.x = this.followEnemy.x;
                        this.y = this.followEnemy.y;
                    }
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                    ctx.strokeStyle = 'rgba(170, 209, 255, 0.7)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30 * (1 + (1 - this.life / this.maxLife)), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "maraImpactShockwave":
                effect.maxLife = 0.4;
                effect.radius = radius || 45;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(150, 210, 255, 0.9)';
                    ctx.lineWidth = 6 - (5 * (1 - this.life));
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "armorCrackFlash":
                effect.maxLife = 0.5;
                effect.level = radius || 1;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(210, 240, 255, 0.8)';
                    ctx.lineWidth = 1.2;
                    for (let i = 0; i < 3 + this.level; i++) {
                        const angle = (i / (3 + this.level)) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                        ctx.stroke();
                    }
                    ctx.restore();
                };
                break;
            case "demolitionPulseCharge":
                effect.maxLife = 0.7;
                effect.radius = radius || 40;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(255, 170, 90, 0.8)';
                    ctx.lineWidth = 2 + (1 - this.life) * 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "voidLockChains":
                effect.maxLife = 0.6;
                effect.radius = radius || 45;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const rotation = performance.now() / 200;
                    ctx.globalAlpha = 0.5 + 0.3 * this.life;
                    ctx.strokeStyle = 'rgba(140, 120, 255, 0.9)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotation + (i / 4) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                        ctx.lineTo(Math.cos(angle + Math.PI) * this.radius * 0.4, Math.sin(angle + Math.PI) * this.radius * 0.4);
                        ctx.stroke();
                    }
                    ctx.restore();
                };
                break;
            case "stormDischarge":
                effect.maxLife = 0.35;
                effect.radius = radius || 60;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life * 0.8;
                    ctx.strokeStyle = 'rgba(110, 210, 255, 1)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1.1 - this.life * 0.4), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "stormArc":
                const arcTarget = radius || { x, y };
                effect.maxLife = 0.2;
                effect.target = arcTarget;
                effect.x = x;
                effect.y = y;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(120, 220, 255, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    const controlX = (this.x + this.target.x) / 2 + (Math.random() - 0.5) * 30;
                    const controlY = (this.y + this.target.y) / 2 + (Math.random() - 0.5) * 30;
                    ctx.quadraticCurveTo(controlX, controlY, this.target.x, this.target.y);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "delayedFlamePulse":
                effect.maxLife = 0.5;
                effect.radius = radius || 90;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(255, 150, 60, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1 + (1 - this.life) * 0.3), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "critText":
                effect.maxLife = 0.6;
                effect.text = "CRITICAL!";
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 30 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                };
                break;
            case "bossPhaseChange":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; this.radius += 600 * dt; };
                effect.draw = function() {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                    ctx.lineWidth = 1 + 4 * this.life;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                };
                break;
             case "screenFlash":
                effect.maxLife = y / 1000;
                effect.life = effect.maxLife;
                effect.color = radius;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.globalAlpha = this.life / this.maxLife;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "timeRippleExplosion":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.maxRadius = 80;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.radius = this.maxRadius * (1 - this.life);
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Create time ripple effect with concentric circles
                    for (let i = 0; i < 3; i++) {
                        const rippleRadius = this.radius * (0.3 + i * 0.3);
                        const alpha = this.life * (1 - i * 0.2);
                        
                        // Outer ripple ring
                        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                        ctx.lineWidth = 3 - i;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Inner glow
                        ctx.fillStyle = `rgba(150, 220, 255, ${alpha * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius * 0.8, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    // Central time distortion effect
                    const centerAlpha = this.life * 0.6;
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                    grad.addColorStop(0, `rgba(200, 240, 255, ${centerAlpha})`);
                    grad.addColorStop(0.7, `rgba(100, 200, 255, ${centerAlpha * 0.5})`);
                    grad.addColorStop(1, `rgba(50, 150, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case "lightningFlash":
                effect.maxLife = 0.15; // Very short flash duration
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Calculate flash intensity based on remaining life
                    const intensity = Math.sin(this.life * Math.PI); // Sine wave for smooth fade
                    const alpha = intensity * 0.8;
                    
                    // Outer blue glow
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                    grad.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 150, 255, ${alpha * 0.6})`);
                    grad.addColorStop(1, `rgba(30, 100, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Inner bright white core
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Electric sparks around the edge
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI + this.life * 10; // Rotate sparks
                        const sparkX = Math.cos(angle) * (20 + Math.random() * 10);
                        const sparkY = Math.sin(angle) * (20 + Math.random() * 10);
                        
                        ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.7})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(sparkX * 0.7, sparkY * 0.7);
                        ctx.lineTo(sparkX, sparkY);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                };
                break;
        }
        return effect
    }
    

    function explodeMine(mine) {
        playSound('explosion');
        const p = store.player;
        
        const numBullets = 18;
        for (let i = 0; i < numBullets; i++) {
            const angle = (i / numBullets) * 2 * Math.PI;
            const bulletSpeed = 300;
            spawnBullet({
                x: mine.x,
                y: mine.y,
                vx: Math.cos(angle) * bulletSpeed,
                vy: Math.sin(angle) * bulletSpeed,
                r: 3,
                col: '#ff9966',
                dmg: 20 * p.dmgMult,
                pierce: false,
                life: 0.28
            });
        }

        const numFlames = 15;
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * 120 * Math.PI / 180;
            const speed = 250 + Math.random() * 50;
            spawnBullet({
                x: mine.x,
                y: mine.y,
                vx: Math.sin(angle) * speed,
                vy: -Math.cos(angle) * speed,
                r: 3 + Math.random() * 2,
                col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`,
                dmg: 2 * p.dmgMult,
                life: 0.3,
                isFlame: true
            });
        }

        store.activeEffects.push(createEffect("grenadeExplosion", mine.x, mine.y, 55));
    }


    let shopItemOrder = [];
    function showShop() {
        pauseGame();
        const panel = q("shopPanel"),
            grid = q("shopGrid"),
            goldEl = q("shopgold");
        goldEl.textContent = store.world.gold;

        // Add the mobile controls toggle if it doesn't exist
        if (!q('mobileControlsToggle')) {
            const toggleHTML = `
                <div class="mobile-toggle-container">
                    <span>Mobile Controls</span>
                    <label class="switch">
                        <input type="checkbox" id="mobileControlsToggle">
                        <span class="slider"></span>
                    </label>
                </div>`;
            panel.insertAdjacentHTML('afterbegin', toggleHTML);
            
            const toggle = q('mobileControlsToggle');
            toggle.checked = document.body.classList.contains('mobile-controls-active');

            toggle.addEventListener('change', () => {
                if (toggle.checked) {
                    document.body.classList.add('mobile-controls-active');
                    localStorage.setItem('mobileControlsEnabled', 'true');
                } else {
                    document.body.classList.remove('mobile-controls-active');
                    localStorage.setItem('mobileControlsEnabled', 'false');
                }
            });
        }



        const currentItems = Object.keys(SHOP_UPGRADES).map(key => {
            const u = SHOP_UPGRADES[key];
            let currentLevel = store.player.upgradeLevels[key] || 0,
                cost = 0;
            if (key === 'vampirism') {
                cost = 12 + (store.player.vampirismLevel * 5);
                if (store.player.vampirismLevel >= u.max) cost = Infinity
            } else if (u.isPremium) {
                cost = u.cost
            } else {
                if (currentLevel >= u.maxLevel) {
                    cost = Infinity
                } else {
                    if (u.increment) {
                        cost = u.baseCost + (currentLevel * u.increment);
                    } else {
                        cost = Math.floor(u.baseCost * Math.pow(u.scale, currentLevel))
                    }
                }
            }
            return {
                key, ...u,
                cost
            }
        });
        const temporarilyDisabled = [];

        if (shopItemOrder.length === 0) {
            const itemsToSort = [...currentItems];
            itemsToSort.sort((a, b) => {
                const aIsDisabled = temporarilyDisabled.includes(a.key);
                const bIsDisabled = temporarilyDisabled.includes(b.key);
                if (aIsDisabled && !bIsDisabled) return 1;
                if (!aIsDisabled && bIsDisabled) return -1;
                return a.cost - b.cost;
            });
            shopItemOrder = itemsToSort.map(item => item.key);
        }

        const shopItems = shopItemOrder.map(key => currentItems.find(item => item.key === key));
        
        let content = "";
        for (const u of shopItems) {
            const key = u.key;
            let currentLevel = store.player.upgradeLevels[key] || 0,
                isDisabled = false,
                cost = u.cost,
                desc = typeof u.desc === 'function' ? u.desc(currentLevel) : u.desc,
                name = u.name;
            if (u.isPremium) {
                if (key === 'vampirism') {
                    if (store.player.vampirismLevel >= u.max) isDisabled = true
                } else if (key === 'repair') {
                    if (store.player.hp >= store.player.hpMax) {
                        isDisabled = true;
                        desc = "Health is already full."
                    }
                } else if (key === 'nano_save') {
                    if (store.player.nanoSaves >= u.max) {
                        isDisabled = true;
                        desc = "Max charges reached."
                    }
                } else if (u.isUnlock) {
                    if ( (key === 'gravity_well' && store.player.hasVoidBeam) ||
                         (key === 'lazarus_beam' && store.player.hasLazarusBeam) ||
                         (key === 'launcher' && store.player.hasLauncher) ||
                         (key === 'luck_boost' && store.player.luckBoost > 0) ||
                         (key === 'magnet_pull' && store.player.magnetRadius > 0) ||
                         (key === 'rear_guard' && store.player.hasRearGuard) ||
                         (key === 'iceman' && store.player.hasIceman)) {
                        isDisabled = true;
                        desc = "Already Unlocked"
                    }
                } else {
                    if (store.player.grenades >= u.max) {
                        isDisabled = true;
                        desc = "At maximum capacity"
                    }
                }
            } else {
                if (currentLevel >= u.maxLevel) {
                    isDisabled = true;
                    desc = "Max Level Reached"
                }
            }
            if (store.world.gold < cost) isDisabled = true;
            if (temporarilyDisabled.includes(key)) {
                isDisabled = true;
                desc = "Under maintenance.";
            }
            const costText = isFinite(cost) ? cost : '---';
            content += `<div class="skill-card shop-item ${isDisabled?'disabled':''} shop-item-${u.category}" data-key="${key}"><div class="skill-icon">${u.icon}</div><div><div class="skill-title">${name}</div><div class="skill-desc">${desc}</div></div><div style="color:var(--accent);margin-top:4px;font-size:11px;">Cost: ${costText}</div></div>`
        }
        grid.innerHTML = content;
        grid.querySelectorAll(".shop-item").forEach(item => {
            item.addEventListener("click", () => {
                if (item.classList.contains('disabled')) return;
                const key = item.dataset.key;
                const upgrade = SHOP_UPGRADES[key];
                let purchaseSuccessful = false;
                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const cost = 12 + (store.player.vampirismLevel * 5);
                        if (store.world.gold >= cost) {
                            purchaseSuccessful = upgrade.apply()
                        }
                    } else {
                        const cost = upgrade.cost;
                        if (store.world.gold >= cost) {
                            store.world.gold -= cost;
                            purchaseSuccessful = upgrade.apply()
                        }
                    }
                } else {
                    const currentLevel = store.player.upgradeLevels[key] || 0;
                    let cost;
                    if (upgrade.increment) {
                        cost = upgrade.baseCost + (currentLevel * upgrade.increment);
                    } else {
                        cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                    }

                    if (store.world.gold >= cost) {
                        store.world.gold -= cost;
                        upgrade.effect(currentLevel);
                        store.player.upgradeLevels[key] = (store.player.upgradeLevels[key] || 0) + 1;
                        purchaseSuccessful = true;
                    }
                }
                if (purchaseSuccessful) {
                    // Defer shop update to next frame to avoid blocking interaction response
                    requestAnimationFrame(() => showShop());
                }
            })
        });



        panel.classList.remove("hide")
    }

    function showShopWithHighlight() { showShop(); announce('Low health! Use the Mech Forge to repair!'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }
    function createHound(side) {
        const isTuxedo = side === -1 || side === -2;
        let color = isTuxedo ? { main: '#222222', accent: '#FFFFFF' } : { main: '#F0E68C', accent: '#BDB76B' };
        
        let isUpgraded = false;
        let eyeType = 'normal';
        let expression = 'normal';

        if (Math.abs(side) > 1) { 
            isUpgraded = true;
            if (side === -2) { 
                color = { main: '#c4b5a0', accent: '#333' }; 
                eyeType = 'swirly';
                expression = 'silly';
            } else { 
                color = { main: '#ffb366', accent: '#000' }; 
                eyeType = 'dilated';
                expression = 'mischievous';
            }
        }

        return {
            x: store.player.x + 50 * side,
            y: store.player.y + 20,
            side,
            target: null,
            attackT: 0,
            r: 12,
            killCount: 0,
            color,
            isUpgraded,
            eyeType,
            expression
        };
    }
    function stepHounds(dt) { if (!store.player.hasHounds) return; store.hounds.forEach(h => { if (!h.target || h.target.dead || h.target.hp <= 0) { let closest = null, closestDist = Infinity; const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies; potentialTargets.forEach(e => { if (e.dead || e.hp <= 0) return; const dist = (h.x - e.x)**2 + (h.y - e.y)**2; if (dist < closestDist) { closestDist = dist; closest = e; } }); h.target = closest; } if (h.target) { const tx = h.target.x, ty = h.target.y; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); const speed = 350; if (dist > 30) { h.x += (dx / dist) * speed * dt; h.y += (dy / dist) * speed * dt; } else { h.attackT -= dt; if (h.attackT <= 0) { h.attackT = 0.25; let dmg = 8 * store.player.dmgMult; if (h.target === store.boss) dmg *= 0.3; if (!h.target.dead && h.target.hp > 0) { h.target.hp -= dmg; if (store.player.vampirism > 0) { let healAmount = dmg * store.player.vampirism; healAmount = Math.max(healAmount, 0.5); healAmount = Math.min(healAmount, 2); store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount); } if (h.target.hp <= 0) { h.killCount++; if (h.killCount > 0 && h.killCount % 12 === 0) { playSound('dogs'); } } } } } } else { const tx = store.player.x + h.side * 50, ty = store.player.y + 20; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 5) { h.x += dx * 5 * dt; h.y += dy * 5 * dt; } } }); }
    function drawHound(h) {
        ctx.save();
        ctx.translate(h.x, h.y);
        const time = performance.now();
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time / 1000 + h.side);
        const r = h.r;

        if (!h.isUpgraded) {
            const { main, accent } = h.color;
            const isTuxedo = accent === '#FFFFFF';

            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.5);
            ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
            ctx.quadraticCurveTo(r * 1.2, 0, r, r);
            ctx.lineTo(-r, r);
            ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.4);
            ctx.lineTo(-r * 0.5, -r * 1.2);
            ctx.lineTo(-r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r, -r * 0.4);
            ctx.lineTo(r * 0.5, -r * 1.2);
            ctx.lineTo(r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();

            if (isTuxedo) {
                ctx.fillStyle = accent;
                ctx.beginPath();
                ctx.moveTo(-r * 0.6, r * 0.2);
                ctx.quadraticCurveTo(0, r, r * 0.6, r * 0.2);
                ctx.lineTo(0, r * 0.5);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.3, r * 0.5, r * 0.4, 0, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, r * 0.5);
            ctx.lineTo(-r * 0.1, r * 0.5);
            ctx.lineTo(-r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.3, r * 0.5);
            ctx.lineTo(r * 0.1, r * 0.5);
            ctx.lineTo(r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
        } else {
            const color = h.color.main;
            const opacity = ctx.globalAlpha;
            const eyeType = h.eyeType;
            const expression = h.expression;
            const radius = r * 1.5;

            if (h.side === 2) {
                ctx.save();
                ctx.globalAlpha = 0.7 * opacity;
                ctx.fillStyle = '#9966ff';
                ctx.beginPath();
                ctx.moveTo(0, -radius * 1.8);
                ctx.lineTo(-radius * 0.8, -radius * 0.9);
                ctx.lineTo(radius * 0.8, -radius * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius * 0.6, -radius * 0.7);
            ctx.lineTo(-radius * 0.4, -radius * 1.2);
            ctx.lineTo(-radius * 0.2, -radius * 0.8);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.6, -radius * 0.7);
            ctx.lineTo(radius * 0.4, -radius * 1.2);
            ctx.lineTo(radius * 0.2, -radius * 0.8);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius, 0);
            for(let i = 0; i <= 6; i++) {
                let waveX = -radius + (radius * 2 / 6) * i;
                let waveY = radius + Math.sin(i * 0.8 + time * 0.005) * radius * 0.2;
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(radius, 0);
            ctx.fill();

            ctx.fillStyle = 'white';
            
            if (eyeType === 'dilated') {
                ctx.beginPath();
                ctx.ellipse(-radius * 0.35, -radius * 0.1, radius * 0.28, radius * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(radius * 0.35, -radius * 0.15, radius * 0.25, radius * 0.32, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-radius * 0.3 + Math.sin(time * 0.001) * radius * 0.05,
                      -radius * 0.05, radius * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.4,
                      -radius * 0.2 + Math.cos(time * 0.001) * radius * 0.05,
                      radius * 0.06, 0, Math.PI * 2);
                ctx.fill();
            } else { // 'swirly'
                ctx.beginPath();
                ctx.arc(-radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'black';
                ctx.lineWidth = radius * 0.04;
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = -radius * 0.35 + Math.cos(t + time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t + time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = radius * 0.35 + Math.cos(t - time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t - time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            
            ctx.fillStyle = 'white';
            
            ctx.beginPath();
            ctx.moveTo(-radius * 0.25, radius * 0.2);
            ctx.lineTo(-radius * 0.2, radius * 0.5);
            ctx.lineTo(-radius * 0.15, radius * 0.2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.25, radius * 0.2);
            ctx.lineTo(radius * 0.2, radius * 0.5);
            ctx.lineTo(radius * 0.15, radius * 0.2);
            ctx.fill();
            
            for(let i = -1; i <= 1; i++) {
                if(i === 0) continue;
                ctx.beginPath();
                ctx.moveTo(i * radius * 0.08, radius * 0.2);
                ctx.lineTo(i * radius * 0.08 + radius * 0.02, radius * 0.35);
                ctx.lineTo(i * radius * 0.08 - radius * 0.02, radius * 0.35);
                ctx.fill();
            }
            
            ctx.strokeStyle = expression === 'silly' ? '#000' : '#333';
            ctx.lineWidth = radius * 0.03;
            ctx.beginPath();
            
            if (expression === 'silly') {
                ctx.moveTo(-radius * 0.3, radius * 0.15);
                ctx.quadraticCurveTo(-radius * 0.1, radius * 0.05, 0, radius * 0.15);
                ctx.quadraticCurveTo(radius * 0.1, radius * 0.25, radius * 0.3, radius * 0.15);
            } else {
                ctx.arc(0, 0, radius * 0.35, Math.PI * 0.2, Math.PI * 0.8);
            }
            ctx.stroke();
        }
        ctx.restore();
    }
    function drawIceman(iceman) {
        const { x, y } = iceman;
        ctx.save();
        ctx.translate(x, y);
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12, 8);
        ctx.lineTo(8, 14);
        ctx.lineTo(0, 10);
        ctx.lineTo(-8, 14);
        ctx.lineTo(-12, 8);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
        bodyGrad.addColorStop(0, "#a0e9ff");
        bodyGrad.addColorStop(1, "#3c9aed");
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d0f8ff";
        ctx.stroke();

        ctx.strokeStyle = "#a0e9ff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 5);
        ctx.lineTo(-20, -2);
        ctx.lineTo(-18, 8);
        ctx.moveTo(12, 5);
        ctx.lineTo(20, -2);
        ctx.lineTo(18, 8);
        ctx.stroke();

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(0, -8, 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawLightningBolt(bolt) {
        const { points, life, maxLife } = bolt;
        const t = life / maxLife;
        if (t <= 0) return;

        ctx.save();
        ctx.lineWidth = 4 * t;
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * t})`;
        ctx.shadowColor = '#9a66ff';
        ctx.shadowBlur = 20 * t;
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        
        ctx.lineWidth = 1.5 * t;
        ctx.strokeStyle = `rgba(200, 220, 255, ${t})`;
        ctx.shadowBlur = 10 * t;
        ctx.stroke();

        ctx.restore();
    }

    function drawEmpNova(nova) {
        ctx.save();
        
        // Create pulsing effect
        const time = performance.now() / 1000;
        const pulse = 0.8 + 0.2 * Math.sin(time * 8);
        const opacity = Math.min(1, nova.life / 2) * 0.3; // Fade in over 2 seconds
        
        // Draw expanding EMP ring
        ctx.strokeStyle = `rgba(255, 140, 0, ${opacity * pulse})`; // Orange cyberpunk color
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]); // Dashed line for tech effect
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner energy ring
        ctx.strokeStyle = `rgba(138, 43, 226, ${opacity * pulse * 0.7})`; // Purple
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 10;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        
        // Add some sparking effects around the perimeter
        ctx.setLineDash([]);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * pulse})`;
        ctx.lineWidth = 1;
        
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2 + time * 2;
            const x1 = nova.x + Math.cos(angle) * (nova.radius - 5);
            const y1 = nova.y + Math.sin(angle) * (nova.radius - 5);
            const x2 = nova.x + Math.cos(angle) * (nova.radius + 5);
            const y2 = nova.y + Math.sin(angle) * (nova.radius + 5);
            
            if (Math.random() < 0.3) { // Random sparking
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        ctx.restore();
    }

    function activateGravityWell() {
        if (!store.isPaused) {
            const spawnX = W * 0.2 + Math.random() * W * 0.6;
            const spawnY = H * 0.2 + Math.random() * H * 0.6;
            store.activeEffects.push(createEffect("gravityWell", spawnX, spawnY));
            announce('GRAVITY WELL ACTIVATED');
            screenFlash(2, 250, 'rgba(255, 255, 255, 0.7)');
        }
    }
    function activateLazarus() {
        if (store.player.hasLazarusBeam && !store.isPaused) {
            const angle = Math.random() * 2 * Math.PI,
                speed = 800,
                p = store.player;
            store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 6, r: 12, hitEnemies: new Set });
            
            if (p.upgradeLevels.lazarus_beam > 1) {
                const oppositeAngle = angle + Math.PI;
                store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(oppositeAngle) * speed, vy: Math.sin(oppositeAngle) * speed, life: 6, r: 12, hitEnemies: new Set });
            }
        }
    }
    function useGrenade() {
        if (store.player.grenades > 0 && !store.isPaused) {
            playSound('explosion');
            store.player.grenades--;
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 400;
                spawnBullet({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 5,
                    col: '#ff8080',
                    dmg: 40 * p.dmgMult,
                    pierce: true,
                    life: 0.8
                });
            }
            store.activeEffects.push(createEffect("shieldBreak", p.x, p.y));
        }
    }
    
    function stepVoidLaser(dt) {
        const p = store.player;
        
        // Determine range based on phasestriker level
        let maxRange;
        if (p.phasestRikerLevel >= 1) {
            // Level 1+: Global range - can hit anything on screen (unlimited range upgrade)
            maxRange = Math.max(W, H) * 2; // Unlimited range using game dimensions
        } else if (p.phasestRikerLevel >= 0.5) {
            // Base phasestriker: Use voidLaserRange (medium range)
            maxRange = p.voidLaserRange || 250;
        } else {
            // No phasestriker: Default short range
            maxRange = p.r * 12;
        }
        
        // Timer for retargeting - check for new targets every 0.1 seconds
        p.voidLaserRetargetTimer -= dt;
        if (p.voidLaserRetargetTimer <= 0) {
            p.voidLaserRetargetTimer = 0.1;
            
            // Find closest enemy within range
            const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
            let closestTarget = null;
            let closestDistSq = maxRange * maxRange;
            
            allEnemies.forEach(e => {
                const distSq = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                if (distSq < closestDistSq) {
                    closestDistSq = distSq;
                    closestTarget = e;
                }
            });
            
            // Reset ramp time if target changed
            if (closestTarget !== p.voidLaserLastTarget) {
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = closestTarget;
            }
            
            p.voidLaserTarget = closestTarget;
        }
        
        // Apply continuous damage if we have a target
        if (p.voidLaserTarget && !p.voidLaserTarget.dead) {
            // Check if target is still in range
            const distSq = (p.x - p.voidLaserTarget.x) ** 2 + (p.y - p.voidLaserTarget.y) ** 2;
            if (distSq <= maxRange * maxRange) {
                // Increase ramp time for level 2 phasestriker
                if (p.phasestRikerLevel >= 2) {
                    p.voidLaserRampTime += dt;
                }
                
                // Damage timer - apply damage every 0.1 seconds for smooth continuous damage
                p.voidLaserDamageTimer -= dt;
                if (p.voidLaserDamageTimer <= 0) {
                    p.voidLaserDamageTimer = 0.1;
                    
                    // Base damage
                    let damage = 8.5 * p.dmgMult;
                    
                    // Level 2 phasestriker: Ramping damage based on time on target
                    if (p.phasestRikerLevel >= 2) {
                        const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // +80% damage per second
                        damage *= Math.min(rampMultiplier, 4.0); // Cap at 4x damage
                    }
                    
                    // Level 4 phasestriker: Double Long Range Intensifying Beam - double damage with intensification
                    if (p.phasestRikerLevel >= 4 && p.doubleBeam) {
                        damage *= 2; // Double beam doubles the damage
                        // Additional intensification over time
                        if (p.beamIntensifyRate && p.voidLaserRampTime > 0) {
                            const intensifyMultiplier = 1 + (p.voidLaserRampTime * p.beamIntensifyRate);
                            damage *= Math.min(intensifyMultiplier, 2.0); // Cap at 2x additional intensification
                        }
                    }
                    
                    if (p.voidLaserTarget === store.boss) damage *= 0.3; // Reduced damage to boss
                    
                    const voidLaserVuln = applySubclassVulnerability(p.voidLaserTarget, damage, {
                        subclass: p.subclass,
                        player: p,
                        damageTags: ['void', 'magic'],
                        source: 'voidLaser',
                        baseDamage: damage
                    });
                    damage = voidLaserVuln.damage;

                    p.voidLaserTarget.hp -= damage;
                    store.world.totalDamage += damage;
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.1); // Minimum heal
                        healAmount = Math.min(healAmount, 0.6); // Increased heal cap slightly
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            } else {
                // Target out of range
                p.voidLaserTarget = null;
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = null;
            }
        } else {
            // No target or target dead - reset ramp
            p.voidLaserTarget = null;
            p.voidLaserRampTime = 0;
            p.voidLaserLastTarget = null;
        }
    }
    
    function fireChainLightning() {
        const p = store.player;
        
        if (p.stormstrikerLevel >= 3) {
            // Level 3: Fire four simultaneous chain lightning bolts from all positions (Thunder Lord)
            const positions = [
                { x: p.x - 25, y: p.y - 15 }, // Far left
                { x: p.x - 8, y: p.y - 8 },  // Left wing
                { x: p.x + 8, y: p.y - 8 },  // Right wing  
                { x: p.x + 25, y: p.y - 15 } // Far right
            ];
            
            // Fire all four bolts simultaneously
            positions.forEach(pos => {
                fireChainLightningBolt(1.0, pos);
            });
        } else if (p.stormstrikerLevel >= 2) {
            // Level 2: Fire simultaneous twin lightning from both wing guns
            const leftWing = { x: p.x - 18, y: p.y - 8 };
            const rightWing = { x: p.x + 18, y: p.y - 8 };
            fireChainLightningBolt(1.0, leftWing);
            fireChainLightningBolt(1.0, rightWing);
        } else if (p.hasHybridVoid) {
            // Fire single lightning bolt (reduced power for hybrid)
            fireChainLightningBolt(0.7); // 70% damage for hybrid mode
        } else {
            // Standard single chain lightning from ship center (default stormcaller)
            fireChainLightningBolt();
        }
    }
    
    function fireChainLightningBolt(damageMultiplier = 1.0, startPos = null) {
        const p = store.player;
        const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
        if (allEnemies.length === 0) return;

        // Use custom start position or default to center above player
        const startPoint = startPos || { x: p.x, y: p.y - 20 };

        let closestDistSq = Infinity;
        let currentTarget = null;
        allEnemies.forEach(e => {
            const distSq = (startPoint.x - e.x)**2 + (startPoint.y - e.y)**2;
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                currentTarget = e;
            }
        });

        if (!currentTarget) return;

        const maxJumps = 100; // High limit for unlimited potential with probabilistic limiting
        const chainChance = 0.65; // 65% chance to chain each jump
        let currentDamage = 95 * p.dmgMult * damageMultiplier * (p.chainLightningDamage || 1.0);
        const targetsHit = new Set();
        const chainPoints = [startPoint];

        for (let i = 0; i < maxJumps && currentTarget; i++) {
            targetsHit.add(currentTarget);
            chainPoints.push({ x: currentTarget.x, y: currentTarget.y });

            // Create blue lightning flash at hit point
            store.activeEffects.push(createEffect('lightningFlash', currentTarget.x, currentTarget.y));

            let dmg = currentDamage;
            if (currentTarget === store.boss) dmg *= 0.3;
            const lightningResult = applySubclassVulnerability(currentTarget, dmg, {
                subclass: store.player.subclass,
                player: store.player,
                damageTags: ['lightning', 'magic'],
                source: 'chainLightning',
                baseDamage: dmg
            });
            dmg = lightningResult.damage;
            currentTarget.hp -= dmg;
            store.world.totalDamage += dmg;
            
            // Apply vampirism healing for chain lightning damage
            if (store.player.vampirism > 0) {
                let healAmount = dmg * store.player.vampirism;
                healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for lightning
                healAmount = Math.min(healAmount, 3); // Cap at 3 HP for lightning
                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
            }

            // Check if the lightning should chain (50% chance each jump)
            if (Math.random() >= chainChance) {
                // Chain failed - stop here
                break;
            }

            // Find next target for chaining
            let nextTarget = null;
            let nextDistSq = Infinity;
            allEnemies.forEach(e => {
                if (e.dead || targetsHit.has(e)) return;
                const distSq = (currentTarget.x - e.x)**2 + (currentTarget.y - e.y)**2;
                if (distSq < nextDistSq) {
                    nextDistSq = distSq;
                    nextTarget = e;
                }
            });

            // If no valid target found, stop chaining
            if (!nextTarget) break;

            currentTarget = nextTarget;
            currentDamage *= 0.85; // Slightly less decay since we have probabilistic limiting
        }

        if (chainPoints.length > 1) {
            store.lightningBolts.push({
                points: chainPoints,
                life: 0.4,
                maxLife: 0.4,
                dead: false
            });
        }
    }
    
    const VOIDSTEP = {
        cooldownMs: 2500,
        iframeMs: 220,
        riftMs: 600,
        edgePadding: 6
    };
    let lastVoidStep = -9999;
    let invulUntil = 0;
    const rifts = [];
    const blinkFlashes = [];

        // Ensure the result is never NaN
    
    function spawnBlinkFlash(x, y, life=200){ blinkFlashes.push({x, y, life, birth: performance.now(), dead:false}); }
    function spawnRift(x1,y1,x2,y2, life=VOIDSTEP.riftMs){
        rifts.push({ x1,y1,x2,y2, birth: performance.now(), life, dead:false });
    }

function clampToField(nx, ny){
    const pad = VOIDSTEP.edgePadding;
    nx = Math.max(pad, Math.min(W - pad, nx));
    ny = Math.max(pad, Math.min(H - pad, ny));
    return { nx, ny };
}

function tryVoidStep(player, target, now = performance.now()){
    const cd = VOIDSTEP.cooldownMs;
    if (now - lastVoidStep < cd) return false;

    const start = { x: player.x, y: player.y };
    let { nx, ny } = clampToField(target.x, target.y);

    if (player.blinkDamage) {
        const dx = nx - start.x;
        const dy = ny - start.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let damage = 150 * player.dmgMult;
        
        // Enhanced damage for phasestriker mastery
        if (player.blinkDamageEnhanced) {
            damage = 200 * player.dmgMult;
        }
        
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dot = (((e.x - start.x) * dx) + ((e.y - start.y) * dy)) / (dist * dist);
            const closestX = start.x + dot * dx;
            const closestY = start.y + dot * dy;
            
            const onSegment = dot > 0 && dot < 1;
            if (onSegment) {
                 const distToLine = Math.sqrt((e.x - closestX)**2 + (e.y - closestY)**2);
                 if (distToLine < e.r + 10) {
                     e.hp -= damage;
                     store.world.totalDamage += damage;
                     
                     // Apply vampirism healing for void step damage
                     if (store.player.vampirism > 0) {
                         let healAmount = damage * store.player.vampirism;
                         healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                         healAmount = Math.min(healAmount, 6); // Cap at 6 HP
                         store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                     }
                 }
            }
        });
    }

    spawnRift(start.x, start.y, nx, ny, VOIDSTEP.riftMs);

    player.x = nx; player.y = ny;
    invulUntil = now + VOIDSTEP.iframeMs;
    lastVoidStep = now;

    // Phasestriker mastery: Time ripple explosion at destination
    if (player.blinkDamageEnhanced) {
        // Create time ripple explosion effect
        store.activeEffects.push(createEffect("timeRippleExplosion", nx, ny));
        
        // Damage enemies in explosion radius
        const explosionRadius = 80;
        const explosionDamage = 120 * player.dmgMult;
        const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
        targets.forEach(e => {
            if (e.dead) return;
            const distSq = (e.x - nx)**2 + (e.y - ny)**2;
            if (distSq < explosionRadius**2) {
                e.hp -= explosionDamage;
                store.world.totalDamage += explosionDamage;
            }
        });
    }

    // Impact shockwave for earthquake enhancement
    if (player.hasImpactPhase) {
        createImpactShockwave(nx, ny, player.dmgMult);
    }

    spawnBlinkFlash(nx, ny);
    return true;
}
    
    // Impact shockwave system for earthquake enhancement
    const impactRipples = [];
    
    function createImpactShockwave(x, y, dmgMult) {
        const shockDamage = 200 * dmgMult;  // High impact damage
        const maxRadius = 120;  // Large earthquake radius
        
        // Create expanding ripple effect
        impactRipples.push({
            x: x, y: y,
            radius: 0,
            maxRadius: maxRadius,
            life: 0.8,
            maxLife: 0.8,
            birth: performance.now(),
            dead: false
        });
        
        // Damage all enemies in impact radius
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3; // 30% falloff at edge
                const actualDamage = shockDamage * damageFalloff;
                e.hp -= actualDamage;
                store.world.totalDamage += actualDamage;
                
                // Knockback effect
                if (dist > 0) {
                    const knockbackForce = 200;
                    const knockbackX = (e.x - x) / dist * knockbackForce;
                    const knockbackY = (e.y - y) / dist * knockbackForce;
                    e.knockback = { x: knockbackX, y: knockbackY, duration: 0.3, timer: 0.3 };
                }
            }
        });
        
        // Damage boss if in range
        if (store.boss && !store.boss.dead) {
            const dist = Math.sqrt((store.boss.x - x)**2 + (store.boss.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3;
                const bossDamage = shockDamage * damageFalloff * 0.4;
                store.boss.hp -= bossDamage; // Reduced boss damage
                store.world.totalDamage += bossDamage;
            }
        }
        
        playSound('thunder'); // Play earthquake sound
    }
    
    function updateImpactSystem() {
        const now = performance.now();
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const age = (now - ripple.birth) / 1000; // Convert to seconds
            ripple.radius = (age / ripple.maxLife) * ripple.maxRadius;
            
            if (age >= ripple.maxLife) {
                ripple.dead = true;
            }
        }
        
        // Remove dead ripples
        for (let i = impactRipples.length - 1; i >= 0; i--) {
            if (impactRipples[i].dead) {
                impactRipples.splice(i, 1);
            }
        }
    }
    
    function renderImpactSystem(ctx) {
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const now = performance.now();
            const age = (now - ripple.birth) / 1000;
            const progress = age / ripple.maxLife;
            const alpha = 1.0 - progress; // Fade out over time
            
            ctx.save();
            ctx.globalAlpha = alpha * 0.6;
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;  // Yellow earthquake ripples
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner ripple for more impact
            if (progress < 0.7) {
                ctx.globalAlpha = alpha * 0.4;
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius * 0.6, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    
    function updateVoidStepSystems(enemies){
        for (const r of rifts) if (!r.dead) {
        if(performance.now() - r.birth >= r.life) r.dead = true;
        }
        for (const f of blinkFlashes) if (!f.dead) {
        if(performance.now() - f.birth >= f.life) f.dead = true;
        }
        for (let i=rifts.length-1; i>=0; i--) if (rifts[i].dead) rifts.splice(i,1);
        for (let i=blinkFlashes.length-1; i>=0; i--) if (blinkFlashes[i].dead) blinkFlashes.splice(i,1);
    }

    function renderVoidStepSystems(ctx){
        rifts.forEach(r => {
            const t = (performance.now() - r.birth)/r.life;
            if (t>=1) { r.dead = true; return; }
            const a = (1 - t) * 0.8 + 0.2;
            ctx.save();
            ctx.globalAlpha = a;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 10 * (1-t);
            ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 25 * (1-t);
            ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
            ctx.restore();
        });
        blinkFlashes.forEach(f => {
            const t = (performance.now() - f.birth)/f.life;
            if (t>=1) { f.dead = true; return; }
            ctx.save();
            ctx.globalAlpha = 1 - t;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 4 * (1 - t);
            ctx.shadowColor="#b266ff"; ctx.shadowBlur=20;
            ctx.beginPath();
            ctx.arc(f.x, f.y, 20 + 30 * t, 0, Math.PI*2);
            ctx.stroke();

            ctx.globalAlpha = 1 - t*t;
            ctx.beginPath(); ctx.arc(f.x, f.y, 20 * (1-t), 0, Math.PI*2);
            ctx.fillStyle="#ffddff"; ctx.fill();
            ctx.restore();
        });
    }
    
    function playerIsInvulnerable(){ return performance.now() < invulUntil; }
    
    function screenFlash(count, duration, color) {
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                store.activeEffects.push(createEffect("screenFlash", 0, duration, color));
            }, i * (duration / 2));
        }
    }

    // --- PAUSE & MENU LOGIC ---
    const PANELS = ['namePanel', 'pilotPanel', 'scorePanel', 'levelPanel', 'shopPanel', 'storyPanel', 'subclassPanel', 'teleportTutorialPanel'];
    function isAnyPanelOpen() {
        return PANELS.some(id => !q(id).classList.contains('hide'));
    }
    
    function pauseGame() {
        if (!store.isPaused) {
            store.isPaused = true;
            q('pauseBtn').classList.add('hide');
        }
    }

    function resumeGame() {
        if (!isAnyPanelOpen()) {
            store.isPaused = false;
            q('pauseBtn').classList.remove('hide');
            q('pauseBtn').textContent = 'PAUSE';
        }
    }
    
    // --- EVENT LISTENERS & INITIALIZATION ---
    function showPilotSelect() {
        playSound('epicHorn');
        pauseGame();
        const panel = q('pilotPanel');
        
        panel.classList.remove('hide');
        const cards = panel.querySelectorAll('.skill-card');
        
        const clickHandler = (e) => {
            const card = e.currentTarget;
            const genome = card.dataset.genome;
            store.player.pilotGenome = genome;
            panel.classList.add('hide');
            applyGenomeBonus(genome);
            
            // Spend progression point for successful class selection
            spendProgressionPoint();
            
            // Update mobile controls ability button icon
            updateAbilityButtonIcon();
            
            // Resume game for all genomes (removed teleport tutorial popup)
            resumeGame();
            cards.forEach(c => c.removeEventListener('click', clickHandler));
        };
        
        cards.forEach(card => {
            card.addEventListener('click', clickHandler);
        });
    }

    function showTeleportTutorial() {
        const panel = q('teleportTutorialPanel');
        panel.classList.remove('hide');
        
        // Set up close button handler
        const closeBtn = q('closeTeleportTutorial');
        const closeHandler = () => {
            panel.classList.add('hide');
            closeBtn.removeEventListener('click', closeHandler);
            resumeGame();
        };
        
        closeBtn.addEventListener('click', closeHandler);
    }

    // --- GIBBING EFFECT ---

    // Initialize the gibs array in your game's store
    store.gibs = [];

    /**
     * Spawns a cluster of gib particles at a specific location.
     * Call this function when an enemy dies.
     * @param {number} x - The x-coordinate of the enemy.
     * @param {number} y - The y-coordinate of the enemy.
     * @param {string} color - The base color of the enemy.
     * @param {number} [amount=15] - The number of gibs to create.
     */
    function spawnGibs(x, y, color, amount = 12) {
        for (let i = 0; i < amount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 50 + Math.random() * 150;
            const size = 2 + Math.random() * 4;
            const life = 0.5 + Math.random() * 0.5;

            store.gibs.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                r: size,
                life,
                maxLife: life,
                color,
                gravity: 300, // Pulls gibs downward
            });
        }
    }

    /**
     * Updates the position and lifetime of all active gibs.
     * This should be called once per frame from your main game loop.
     * @param {number} dt - Delta time, the time since the last frame.
     */
    function updateGibs(dt) {
        for (let i = store.gibs.length - 1; i >= 0; i--) {
            const gib = store.gibs[i];
            
            // Apply physics
            gib.vy += gib.gravity * dt;
            gib.x += gib.vx * dt;
            gib.y += gib.vy * dt;
            gib.life -= dt;

            // Remove gibs that have expired
            if (gib.life <= 0) {
                store.gibs.splice(i, 1);
            }
        }
    }

    /**
     * Draws all active gibs to the canvas.
     * This is called from the main render() function.
     * @param {object} ctx - The 2D rendering context of the canvas.
     */
    function drawGibs(ctx) {
        store.gibs.forEach(gib => {
            const alpha = gib.life / gib.maxLife; // Fade out effect
            
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha);
            ctx.fillStyle = gib.color;
            ctx.beginPath();
            ctx.fillRect(gib.x - gib.r / 2, gib.y - gib.r / 2, gib.r, gib.r);
            ctx.restore();
        });
    }

    function applyGenomeBonus(genome) {
        if (!genome) return;

        // Reset all potential subclass stats to their defaults
        const p = store.player;
        p.subclass = null;
        p.beefMaxCharges = 1;
        p.missilePierce = 0;
        p.missileCluster = false;
        p.blinkDamage = false;
        p.hasChainLightning = false;
        p.stormstrikerLevel = 0;
        p.lightningAlternate = false;
        p.lightningCycleIndex = 0;
        p.chainLightningDamage = 1.0;
        p.phasestRikerLevel = 0;
        p.voidLaserRampTime = 0;
        p.voidLaserLastTarget = null;
        p.hasVoidLaser = false;
        p.voidLaserTarget = null;
        p.voidLaserDamageTimer = 0;
        p.voidLaserRetargetTimer = 0;

        store.world.bossesAtPilotSelection = store.world.bosses;
        
        switch(genome) {
            case 'beef':
                // Base beef no longer gets abilities by default - subclasses must unlock them via skill trees
                break;
            case 'voidmancer':
                // Give +2 multishot base and mild speed boost for base voidmancer
                p.multishot = (p.multishot || 2) + 2; // Base 2 + 2 = 4 bullets total
                p.speed = (p.speed || 2.5) * 1.05; // 5% speed boost
                break;
            case 'rocketman':
                // Rocketman no longer auto-gains the frag launcher; keep any previously unlocked state
                p.hasLauncher = !!p.hasLauncher;
                break;
        }
    }
    
    // 4-Node Skill Tree Data Structure + Separate Class Ability - Single focused path per subclass
    const SKILL_TREE_DATA = {
        // Each subclass gets a focused 4-node skill tree + separate class ability (available immediately)
        marauder: {
            title: 'MARAUDER MASTERY TREE',
            path: {
                name: 'MARAUDER PATH',
                nodes: [
                    { id: 'marauder_multi_charge', name: 'Multi Charge', desc: 'Gain 3 charge attacks with enhanced chain capability', icon: 'mar11.png', tier: 1 },
                    { id: 'marauder_chain_assault', name: 'Chain Assault', desc: '+50% chain damage bonus and improved chain targeting', icon: 'mar2.png', tier: 2 },
                    { id: 'marauder_combat_mastery', name: 'Combat Mastery', desc: '+25 HP, 15% damage reduction, enhanced armor', icon: 'mar3.png', tier: 3 },
                    { id: 'marauder_elite_warrior', name: 'Elite Warrior', desc: '5 total charges with elite combat techniques', icon: 'mar4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' }
        },
        juggernaut: {
            title: 'JUGGERNAUT MASTERY TREE',
            path: {
                name: 'CHARGE PATH',
                nodes: [
                    { id: 'juggernaut_charge_power', name: 'Charge Power', desc: '+100% charge damage and knockback, +50% charge range', icon: 'jug1.png', tier: 1 },
                    { id: 'juggernaut_charge_mastery', name: 'Charge Mastery', desc: 'Charge creates damaging shockwave, +2 charge capacity', icon: 'jug22.png', tier: 2 },
                    { id: 'juggernaut_heavy_armor', name: 'Heavy Armor', desc: '+50 HP, 25% damage reduction, knockback immunity', icon: 'jug33.png', tier: 3 },
                    { id: 'juggernaut_unstoppable', name: 'Unstoppable Force', desc: '2.5x explosion radius, 3x damage - devastating impact', icon: 'jug4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' }
        },
        railgunner: {
            title: 'RAILGUNNER MASTERY TREE',
            path: {
                name: 'RAILGUN PATH',
                nodes: [
                    { id: 'railgunner_super_pierce', name: 'Super Pierce', desc: 'Missiles pierce 5 enemies with +30% pierce damage', icon: 'one.png', tier: 1 },
                    { id: 'railgunner_perfect_aim', name: 'Perfect Aim', desc: '+25% critical hit chance with +50% accuracy', icon: 'two.png', tier: 2 },
                    { id: 'railgunner_advanced_ballistics', name: 'Advanced Ballistics', desc: 'Pierce 8 enemies with +80% velocity and homing', icon: 'three.png', tier: 3 },
                    { id: 'railgunner_precision_master', name: 'Precision Master', desc: 'Pierce 12 enemies with +100% critical damage', icon: 'four.png', tier: 4 }
                ]
            },
            classAbility: { id: 'firewall_unlock', name: 'FIREWALL', desc: 'UNLOCK: Deployable burning barrier for area control', icon: 'firewall.png', tier: 'class' }
        },
        demolitionist: {
            title: 'DEMOLITIONIST MASTERY TREE',
            path: {
                name: 'CLUSTER PATH',
                nodes: [
                    { id: 'demolitionist_bigger_clusters', name: 'Bigger Clusters', desc: 'Cluster bombs are 2x larger with increased blast radius', icon: 'demo1.png', tier: 1 },
                    { id: 'demolitionist_cluster_mastery', name: 'Cluster Mastery', desc: 'Clusters split into secondary explosions, +50% cluster count', icon: 'demo2.png', tier: 2 },
                    { id: 'demolitionist_explosive_mastery', name: 'Explosive Mastery', desc: 'Advanced explosive techniques and enhanced detonation power', icon: 'demo3.png', tier: 3 },
                    { id: 'demolitionist_demolition_expert', name: 'Demolition Expert', desc: 'Peak explosive specialist with maximum destructive force', icon: 'demo4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'firewall_unlock', name: 'FIREWALL', desc: 'UNLOCK: Deployable burning barrier for area control', icon: 'firewall.png', tier: 'class' }
        },
        phasestriker: {
            title: 'PHASESTRIKER MASTERY TREE',
            path: {
                name: 'LASER PATH',
                nodes: [
                    { id: 'phasestriker_unlimited_range', name: 'Unlimited Range', desc: 'Void laser can target enemies anywhere on screen - no range limitations', icon: 'phase1.png', tier: 1 },
                    { id: 'phasestriker_ramping_power', name: 'Ramping Power', desc: 'Laser increases in size and damage each millisecond on the same target', icon: 'phase2.png', tier: 2 },
                    { id: 'phasestriker_dimensional_control', name: 'Dimensional Control', desc: 'Void laser phases through reality with 2.5x damage', icon: 'phase3.png', tier: 3 },
                    { id: 'phasestriker_double_beam', name: 'Double Long Range Intensifying Beam', desc: 'Fires two parallel beams that intensify over time, dealing massive damage', icon: 'phase4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' }
        },
        stormcaller: {
            title: 'STORMCALLER MASTERY TREE',
            path: {
                name: 'LIGHTNING PATH',
                nodes: [
                    { id: 'stormcaller_chain_boost', name: 'Twin Lightning', desc: 'Alternating left/right wing lightning at double fire rate', icon: 'storm1.png', tier: 1 },
                    { id: 'stormcaller_storm_mastery', name: 'Storm Mastery', desc: '+50% jump range and +80% chain lightning damage', icon: 'storm2.png', tier: 2 },
                    { id: 'stormcaller_thunder_lord', name: 'Thunder Lord', desc: '4 simultaneous lightning bolts from all positions - devastating coverage', icon: 'storm3.png', tier: 3 },
                    { id: 'stormcaller_storm_god', name: 'Storm God', desc: '3x lightning damage multiplier - omnipotent electrical dominance', icon: 'storm4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' }
        }
    };

    const SUBCLASSES = {
        rocketman: [
            { id: 'railgunner', name: 'Railgunner', desc: 'Missiles pierce through multiple enemies with devastating precision.', icon: 'rail.png' },
            { id: 'demolitionist', name: 'Demolitionist', desc: 'Missiles explode into deadly cluster bombs on impact.', icon: 'demo.png' }
        ],
        beef: [
            { id: 'juggernaut', name: 'juggernaut', desc: 'Charge ability creates a damaging explosion on impact.', icon: 'jug2.png' },
            { id: 'marauder', name: 'Marauder', desc: 'Gain a second charge for your special ability.', icon: 'marauder.png' }
        ],
        voidmancer: [
            { id: 'phasestriker', name: 'Phase Striker', desc: 'Basic short-range void laser that can be upgraded for unlimited range and power.', icon: 'phase.png' },
            { id: 'stormcaller', name: 'Stormcaller', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
        ]
    };

    function showSubclassSelect() {
        pauseGame();
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const skillTree = q('skillTree');
        const genome = store.player.pilotGenome;

        if (!panel || !grid) {
            console.warn('Subclass UI unavailable; skipping selection.');
            resumeGame();
            return;
        }

        // Show traditional card selection for all pilots (including beef)
        const choices = SUBCLASSES[genome];
        if (!choices) {
            resumeGame();
            return;
        }
        if (skillTree) {
            skillTree.classList.add('hide');
        }
        grid.classList.remove('hide');
        panel.classList.remove('skill-tree-active'); // Ensure normal panel size for subclass selection
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-subclass="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const subclassId = card.dataset.subclass;
                store.player.subclass = subclassId;
                applySubclassBonus(subclassId);
                
                // Spend progression point for successful subclass selection
                spendProgressionPoint();
                
                // Update mobile controls ability button icon
                updateAbilityButtonIcon();
                
                panel.classList.add('hide');
                resumeGame();
            }, { once: true });
        });

        const heading = panel.querySelector('h2');
        if (heading) {
            heading.style.display = 'block'; // Show h2 for subclass selection
        }
        panel.classList.remove('hide');
    }

    function showProgressiveSkillTree() {
        showSkillTreeModal();
    }

    function showSkillTreeModal(openedFromForge = false) {
        if (!store.player.pilotGenome || store.player.pilotGenome === 'pending') {
            return;
        }

        const panel = q('subclassPanel');
        if (!panel) {
            console.warn('Skill tree panel unavailable; skipping modal open.');
            resumeGame();
            return;
        }

        const grid = q('subclassGrid');
        let skillTree = q('skillTree');

        window.skillTreeOpenedFromForge = openedFromForge;

        if (!openedFromForge) {
            playSound('epicHorn');
        }

        pauseGame();

        if (grid) {
            grid.classList.add('hide');
        }

        if (!skillTree) {
            skillTree = document.createElement('div');
            skillTree.id = 'skillTree';
            panel.appendChild(skillTree);
        } else if (!panel.contains(skillTree)) {
            panel.appendChild(skillTree);
        }

        skillTree.classList.remove('hide');

        panel.classList.remove('hide');
        panel.classList.add('skill-tree-active');
        panel.scrollTop = 0;

        const heading = panel.querySelector('h2');
        if (heading) {
            if (!panel.dataset.originalHeading) {
                panel.dataset.originalHeading = heading.textContent || '';
            }
            heading.textContent = 'SPECIALIZATION MASTERY';
            heading.style.display = 'block';
        }

        generateDynamicSkillTree();

        const closeBtn = q('skillTreeCloseBtn');
        if (closeBtn) closeBtn.onclick = () => closeSkillTree();
        const closeBottomBtn = q('skillTreeCloseBottomBtn');
        if (closeBottomBtn) closeBottomBtn.onclick = () => closeSkillTree();
    }

    function viewCurrentSkillTree() {
        showSkillTreeModal(true);
    }



    function generateDynamicSkillTree() {
        const skillTreeElement = q('skillTree');
        const genome = store.player.pilotGenome;
        
        // Map pilot genome to default subclass for skill tree display
        let subclass = store.player.subclass;
        if (!subclass) {
            // Default subclass based on genome if none selected
            switch (genome) {
                case 'rocketman': subclass = 'railgunner'; break;
                case 'beef': subclass = 'marauder'; break;
                case 'voidmancer': subclass = 'phasestriker'; break;
                default: 
                    console.error('Unknown pilot genome:', genome);
                    return;
            }
        }
        
        // Get the skill tree data for the current subclass
        const treeData = SKILL_TREE_DATA[subclass];
        if (!treeData) {
            console.error('No skill tree data found for subclass:', subclass);
            return;
        }
        
        // Generate the 5-node single path skill tree HTML
        const path = treeData.path;
        const classAbility = treeData.classAbility;
        
        skillTreeElement.innerHTML = `
            <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
            <div class="skill-tree-title">${treeData.title}</div>
            <div class="skill-grid">
                <div class="skill-row">
                    <!-- Main progression path with 4 nodes -->
                    <div class="skill-track">
                        <div class="track-title">${path.name}</div>
                        <!-- Tier 1 -->
                        <div class="skill-icon-button locked" data-skill="${path.nodes[0].id}" data-tier="1">
                            <img src="${path.nodes[0].icon}" alt="${path.nodes[0].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[0].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[0].desc}</div>
                            </div>
                        </div>
                        <!-- Tier 2 -->
                        <div class="skill-icon-button locked" data-skill="${path.nodes[1].id}" data-tier="2" data-parent="${path.nodes[0].id}">
                            <img src="${path.nodes[1].icon}" alt="${path.nodes[1].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[1].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[1].desc}</div>
                            </div>
                        </div>
                        <!-- Tier 3 -->
                        <div class="skill-icon-button locked" data-skill="${path.nodes[2].id}" data-tier="3" data-parent="${path.nodes[1].id}">
                            <img src="${path.nodes[2].icon}" alt="${path.nodes[2].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[2].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[2].desc}</div>
                            </div>
                        </div>
                        <!-- Tier 4 -->
                        <div class="skill-icon-button locked" data-skill="${path.nodes[3].id}" data-tier="4" data-parent="${path.nodes[2].id}">
                            <img src="${path.nodes[3].icon}" alt="${path.nodes[3].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[3].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[3].desc}</div>
                            </div>
                        </div>
                    </div>
                    <!-- Separate class ability track (always available) -->
                    <div class="skill-track class-ability-track">
                        <div class="track-title" style="color: #FFD700;">SIGNATURE ABILITY</div>
                        <div class="skill-icon-button locked class-ability-solo" data-skill="${classAbility.id}" data-tier="class">
                            <img src="${classAbility.icon}" alt="${classAbility.name}" class="skill-icon-image class-ability">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${classAbility.name}</div>
                                <div class="skill-overlay-desc">${classAbility.desc}</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="skill-description" id="skillDescription">
                Master your ${subclass} specialization through focused training. Spend progression points to unlock path upgrades and your signature ability.
            </div>
            <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        
        // Initialize skill tree progression
        initializeSkillTree();
    }
    
    // Old skill tree code - now commented out as we use dynamic trees
    /*
    function generateOldSkillTree() {
        // Old static skill trees removed - now using SKILL_TREE_DATA structure
    }
            // Create voidmancer skill tree
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">VOIDMANCER SPECIALIZATION TREE</div>
                <div class="skill-grid">
                    <div class="skill-row">
                        <div class="skill-track">
                            <div class="track-title">PHASE STRIKER</div>
                            <div class="skill-icon-button available" data-skill="phasestriker" data-tier="1">
                                <img src="phase.png" alt="Phase Striker" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">PHASE STRIKER</div>
                                    <div class="skill-overlay-desc">Void manipulation specialist with damaging blink teleportation</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="phasestriker_enhanced" data-tier="2" data-parent="phasestriker">
                                <img src="phase.png" alt="Ramping Laser" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">RAMPING LASER</div>
                                    <div class="skill-overlay-desc">MASTERY: Laser grows in size and damage while fixated on the same target</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">STORMCALLER</div>
                            <div class="skill-icon-button available" data-skill="stormcaller" data-tier="1">
                                <img src="storm.png" alt="Stormcaller" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">STORMCALLER</div>
                                    <div class="skill-overlay-desc">Lightning manipulation specialist with chain lightning weaponry</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="stormcaller_enhanced" data-tier="2" data-parent="stormcaller">
                                <img src="storm.png" alt="Chain Storm" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">CHAIN STORM</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced stormcaller with maximum chain lightning power</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">BLINK ABILITY</div>
                            <div class="skill-icon-button available" data-skill="blink_ability" data-tier="1">
                                <img src="blink.png" alt="Blink Ability" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">BLINK ABILITY</div>
                                    <div class="skill-overlay-desc">Mobility specialist with instant teleportation and damage</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="blink_ability_enhanced" data-tier="2" data-parent="blink_ability">
                                <img src="blink.png" alt="Void Step" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">VOID STEP</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced blink with area damage and faster cooldown</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">VOID LASER</div>
                            <div class="skill-icon-button available" data-skill="void_laser" data-tier="1">
                                <img src="voidlaser.png" alt="Void Laser" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">VOID LASER</div>
                                    <div class="skill-overlay-desc">Energy weapons specialist with focused beam attacks</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="void_laser_enhanced" data-tier="2" data-parent="void_laser">
                                <img src="voidlaser.png" alt="Annihilation Beam" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">ANNIHILATION BEAM</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced void laser with ramping damage and wider beam</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="skill-description" id="skillDescription">
                    Choose your specialization path: Phase Striker for void teleportation, Stormcaller for chain lightning, Blink Ability for mobility, Void Laser for focused damage. Mix and match for powerful combos!
                </div>
                <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        } else {
            // Fallback for unknown pilot types
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">UNKNOWN PILOT TYPE</div>
                <div class="skill-description" id="skillDescription">
                    Skill tree not available for this pilot type.
                </div>
                <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        }
    }
    
    */
    
    function initializeSkillTree() {
        const p = store.player;
        let subclass = p.subclass;
        
        // Default subclass based on genome if none selected
        if (!subclass) {
            switch (p.pilotGenome) {
                case 'rocketman': subclass = 'railgunner'; break;
                case 'beef': subclass = 'marauder'; break;
                case 'voidmancer': subclass = 'phasestriker'; break;
                default: 
                    console.error('Unknown pilot genome:', p.pilotGenome);
                    return;
            }
        }
        
        const treeData = SKILL_TREE_DATA[subclass];
        if (!treeData) {
            console.error('Missing skill tree data for subclass:', subclass);
            return;
        }

        // Initialize skill tree properties if needed
        if (!p.skillTree) {
            p.skillTree = {};
        }

        // Ensure current subclass nodes exist on the player's skill tree map
        treeData.path.nodes.forEach(node => {
            if (p.skillTree[node.id] === undefined) {
                p.skillTree[node.id] = false;
            }
        });

        if (p.skillTree[treeData.classAbility.id] === undefined) {
            p.skillTree[treeData.classAbility.id] = false;
        }
        
        if (!p.skillTreeProgress) p.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
        if (!p.skillPoints) p.skillPoints = 0;
        if (!p.skillPointsSpent) p.skillPointsSpent = 0;
        
        // Don't award skill points here - they're awarded in handleBossDefeat
        // Just update the UI with whatever points we have
        updateSkillTreeUI();
        setupSkillTreeHandlers();
    }
    
    function updateSkillTreeUI() {
        const p = store.player;
        const panel = q('subclassPanel');
        
        // Early return if skill tree panel is not visible - major performance optimization
        if (!panel || panel.classList.contains('hide') || !panel.classList.contains('skill-tree-active')) {
            return;
        }
        
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        
        // Update button states first, regardless of whether tree will close
        iconButtons.forEach(button => {
            const skill = button.dataset.skill;
            const tierRaw = button.dataset.tier;
            const tier = tierRaw === 'class' ? 'class' : parseInt(tierRaw, 10);
            const parent = button.dataset.parent;
            
            // Remove all state classes
            button.classList.remove('available', 'active', 'locked');
            
            if (p.skillTree && p.skillTree[skill]) {
                // Skill is learned - show active glow effect
                button.classList.add('active');
            } else if (canLearnSkill(skill, tier, parent)) {
                // Skill can be learned - show available state
                button.classList.add('available');
            } else {
                // Skill is locked - show dim state
                button.classList.add('locked');
            }
        });
        
        // Update skill description based on progression state
    const skillDescription = document.getElementById('skillDescription');
    const unspentProgPts = p.unspentProgressionPoints || 0;
    const skillPointsSpent = p.skillPointsSpent || 0;
    const signatureAbilities = p.signatureAbilities || {};
    const signatureCount = Object.keys(signatureAbilities).length;
    const hasSignature = signatureCount > 0;
    const canProgress = unspentProgPts > 0 || (skillPointsSpent >= 2 && skillPointsSpent < 5);
        
        if (skillDescription) {
            if (unspentProgPts === 0) {
                skillDescription.innerHTML = `
                    <div style="color: #ffaa00; margin-bottom: 10px;">üìñ READ-ONLY MODE</div>
                    <div style="color: #cccccc;">No progression points available. Defeat more bosses to unlock abilities!</div>
                    <div style="font-size: 12px; color: #888; margin-top: 8px;">
                        Points Spent: ${skillPointsSpent} ‚Ä¢ Signature Abilities: ${signatureCount}
                    </div>
                `;
            } else {
                skillDescription.innerHTML = `
                    <div style="color: #66ff66;">üéØ PROGRESSION AVAILABLE</div>
                    <div style="color: #cccccc;">You have ${unspentProgPts} progression point${unspentProgPts !== 1 ? 's' : ''} to spend!</div>
                    <div style="font-size: 12px; color: #888; margin-top: 8px;">Signature Abilities Unlocked: ${signatureCount}</div>
                `;
            }
        }
        
        // Safety check: if no progression available and skill tree is open (from boss defeat), close it
        // But don't auto-close if opened from Mech Forge for read-only viewing
        const openedFromMechForge = window.skillTreeOpenedFromForge;
        if (!canProgress && !openedFromMechForge) {
            const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
            setTimeout(() => {
                closeSkillTree();
            }, delay);
            return;
        }
        
        // If tree is fully capped, also close it
        if (isSkillTreeFullyCapped()) {
            const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
            setTimeout(() => {
                closeSkillTree();
            }, delay);
            return;
        }
        
        // If 4 skill points have been spent, don't auto-close (allow viewing)
        // const skillPointsSpent = p.skillPointsSpent || 0;
        // if (skillPointsSpent >= 4 && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
        //     setTimeout(() => {
        //         console.log(`Auto-closing skill tree from updateSkillTreeUI - 4 skill points spent (${skillPointsSpent}/4)`);
        //         closeSkillTree();
        //     }, 100);
        //     return;
        // }
    }
    
    function canLearnSkill(skill, tier, parent) {
        const p = store.player;
        
        // Can't learn a skill that's already learned
        if (p.skillTree && p.skillTree[skill]) return false;
        
        // Initialize progression tracking
        initializeProgressionTracking();
        
        const totalUnspentPts = p.unspentProgressionPoints || 0;
        const totalSpentPts = p.skillPointsSpent || 0;
        const signatureAbilities = p.signatureAbilities || {};
        
        // NEW PROGRESSION SYSTEM:
        if (tier === 'class') {
            // Signature abilities: Available if a progression point is free and this specific signature isn't already unlocked
            return totalUnspentPts > 0 && !signatureAbilities[skill];
        }

        if (tier === 1) {
            // Tier 1 skills: First unlock once a progression point is available
            return totalUnspentPts > 0;
        }

        if (tier === 2) {
            // Tier 2 skills: Need one prior spend and the tier 1 parent
            return totalUnspentPts > 0 && totalSpentPts >= 1 && p.skillTree && p.skillTree[parent];
        }

        if (tier === 3) {
            // Tier 3 skills: Need two prior spends and the tier 2 parent
            return totalUnspentPts > 0 && totalSpentPts >= 2 && p.skillTree && p.skillTree[parent];
        }

        if (tier === 4) {
            // Tier 4 skills: Need three prior spends and the tier 3 parent
            return totalUnspentPts > 0 && totalSpentPts >= 3 && p.skillTree && p.skillTree[parent];
        }
        
        return false;
    }
    
    function setupSkillTreeHandlers() {
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        const description = q('skillDescription');
        
        // Remove any existing handlers first to prevent duplicates
        iconButtons.forEach(button => {
            button.replaceWith(button.cloneNode(true));
        });
        
        // Re-query after cloning to get fresh elements
        const freshButtons = document.querySelectorAll('.skill-icon-button');
        
        // Updated skill descriptions for icon button system
        const skillDescriptions = {
            // Beef skills
            juggernaut: "Heavy assault specialist with explosive charge impacts and superior defensive capabilities.",
            marauder: "Rapid assault specialist with multiple charge capacity for sustained offensive operations.",
            juggernaut_enhanced: "MASTERY: Enhanced juggernaut with devastating explosion radius and catastrophic damage output.", 
            marauder_enhanced: "MASTERY: Elite marauder with triple charge capacity for relentless battlefield dominance.",
            
            // Rocketman skills
            railgunner: "Precision missile specialist with devastating piercing capabilities that cut through multiple enemies.",
            demolitionist: "Explosive missile specialist with cluster bombs that devastate large areas on impact.",
            railgunner_enhanced: "MASTERY: Enhanced railgunner with maximum piercing power and superior accuracy.",
            demolitionist_enhanced: "MASTERY: Elite demolitionist with massive cluster explosions and enhanced area damage.",
            
            // Wizard skills
            phasestriker: "Long-range laser specialist with unlimited targeting range across the entire battlefield.",
            stormcaller: "Lightning manipulation specialist with chain lightning weaponry that arcs between targets.",
            phasestriker_enhanced: "MASTERY: Ramping laser that grows in size and damage the longer it focuses on the same target.",
            stormcaller_enhanced: "MASTERY: Elite stormcaller with maximum chain lightning power and enhanced conductivity."
        };
        
        // Add hover effects to icon buttons
        freshButtons.forEach(button => {
            const skill = button.dataset.skill;
            
            button.addEventListener('mouseenter', () => {
                description.textContent = skillDescriptions[skill] || "Specialization path available";
            });
            
            button.addEventListener('mouseleave', () => {
                const pilotType = store.player.pilotGenome;
                if (pilotType === 'beef') {
                    description.textContent = "Choose your specialization path: Marauder for sustained assault, Juggernaut for devastating impact. Select both for the ultimate combo!";
                } else if (pilotType === 'rocketman') {
                    description.textContent = "Choose your specialization path: Railgunner for piercing precision, Demolitionist for explosive devastation. Select both for the ultimate combo!";
                } else if (pilotType === 'voidmancer') {
                    description.textContent = "Choose your specialization path: Phase Striker for void teleportation, Stormcaller for chain lightning. Select both for the ultimate combo!";
                }
            });
        });
        
        // Click handlers - icon buttons are directly clickable
        freshButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Skill button clicked
                if (button.classList.contains('available')) {
                    const skill = button.dataset.skill;
                    // About to learn skill
                    learnSkill(skill);
                }
            });
        });
    }
    
    let isLearningSkill = false;
    
    function learnSkill(skill) {
        if (isLearningSkill) {
            // Already learning a skill, ignoring duplicate call
            return;
        }
        
        isLearningSkill = true;
        
        try {
            const p = store.player;
            const skillButton = document.querySelector(`[data-skill="${skill}"]`);
            if (!skillButton) {
                console.warn(`Skill button for ${skill} not found.`);
                isLearningSkill = false;
                return;
            }

            const tierRaw = skillButton.dataset.tier;
            const tier = tierRaw === 'class' ? 'class' : parseInt(tierRaw, 10);
            const parentId = skillButton.dataset.parent;

            if (!canLearnSkill(skill, tier, parentId)) {
                isLearningSkill = false;
                return;
            }
            
            const spentPoint = spendProgressionPoint();
            if (!spentPoint) {
                isLearningSkill = false;
                return;
            }

            if (!p.skillTree) p.skillTree = {};
            p.skillTree[skill] = true;
            if (p.skillPoints > 0) {
                p.skillPoints--;
            }
            p.skillPointsSpent = (p.skillPointsSpent || 0) + 1; // Track total spent
            
            // Handle signature ability flag for class tier skills
            if (tier === 'class') {
                if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
                    p.signatureAbilities = {};
                }
                p.signatureAbilities[skill] = true;
                p.signatureAbility = true;
            }
            
            // Apply the skill effects
            applySkillBonus(skill);
            
            // Check for combo when both base skills are learned
            // Check for combo when both base skills are learned
            const pilotType = p.pilotGenome;
            if (tier === 1) {
                if (pilotType === 'beef' && p.skillTree.marauder && p.skillTree.juggernaut) {
                    p.beefDoubleCharge = true;
                    announce('DOUBLE CHARGE COMBO ACTIVATED!');
                } else if (pilotType === 'rocketman' && p.skillTree.railgunner && p.skillTree.demolitionist) {
                    p.rocketmanHybrid = true;
                    announce('HYBRID MISSILES COMBO ACTIVATED!');
                } else if (pilotType === 'voidmancer' && p.skillTree.phasestriker && p.skillTree.stormcaller) {
                    p.voidmancerHybrid = true;
                    announce('VOID STORM COMBO ACTIVATED!');
                }
            }
            
            updateSkillTreeUI();
            
            // Update remaining skill points display
            
            // Check if tree is now fully capped
            if (isSkillTreeFullyCapped()) {
                const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                setTimeout(() => {
                    closeSkillTree();
                }, delay);
            } else {
                // Check if no progression is available
                const unspentProgPts = p.unspentProgressionPoints || 0;
                const skillPointsSpent = p.skillPointsSpent || 0;
                const hasSignature = p.signatureAbility;
                const canProgress = unspentProgPts > 0 || (!hasSignature && unspentProgPts > 0) || (skillPointsSpent >= 2 && skillPointsSpent < 5);
                
                if (!canProgress) {
                    const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                    setTimeout(() => {
                        closeSkillTree();
                    }, delay);
                }
            }
            // Note: No longer auto-closing when 4 skill points are spent - allow viewing
        } catch (error) {
            console.error('Error in learnSkill:', error);
        } finally {
            isLearningSkill = false;
        }
    }
    
    function closeSkillTree() {
        // Clear the flag for Mech Forge opened skill tree
        window.skillTreeOpenedFromForge = false;

        const panel = q('subclassPanel');
        if (!panel) {
            resumeGame();
            return;
        }

        const skillTree = q('skillTree');
        if (skillTree) {
            skillTree.classList.add('hide');
        }

        if (panel.dataset && panel.dataset.originalHeading) {
            const heading = panel.querySelector('h2');
            if (heading) {
                heading.textContent = panel.dataset.originalHeading;
            }
        }

        panel.classList.add('hide');
        panel.classList.remove('skill-tree-active');
        resumeGame();
    }
    
    function isSkillTreeFullyCapped() {
        const p = store.player;
        const subclass = p.subclass;
        
        if (!p.skillTree || !subclass) return false;
        
        // Check if the current subclass main progression path is fully capped (all 4 path nodes learned)
        // Class ability is separate and doesn't count toward "fully capped" since it's always available
        const treeData = SKILL_TREE_DATA[subclass];
        if (!treeData) return false;
        
        // Check if all 4 path nodes are learned (class ability is separate)
        const pathNodes = treeData.path.nodes.map(node => node.id);
        
        return pathNodes.every(skill => p.skillTree[skill] === true);
    }
    
    function applySkillBonus(skill) {
        const p = store.player;
        
        switch(skill) {


                
            // Tier 2 Enhanced Skills
            case 'marauder_enhanced':
                p.beefMaxCharges = 3;
                p.beefCharges = Math.max(p.beefCharges, 3);
                p.beefChainMode = true; // Enable chain jumping for enhanced marauder
                announce('TRIPLE CHAIN ACTIVATED!');
                break;
            case 'juggernaut_enhanced':
                p.beefBigExplosion = true;
                announce('BIG BANG EXPLOSION ACTIVATED!');
                break;
                

                
            // Rocketman Tier 2 Enhanced Skills
            case 'railgunner_enhanced':
                // Enhanced railgunner should preserve existing abilities
                if (!p.missilePierce) p.missilePierce = 2; // Give basic piercing if they don't have it
                p.missilePierce = Math.max(p.missilePierce, 4);
                announce('SUPER PIERCE ACTIVATED - Maximum Penetration!');
                break;
            case 'demolitionist_enhanced':
                // Enhanced demolitionist should preserve existing abilities
                if (!p.missileCluster) p.missileCluster = true; // Give basic clusters if they don't have them
                p.missileClusterEnhanced = true;
                announce('MEGA CLUSTERS ACTIVATED - Devastating Explosions!');
                break;
                
            // Voidmancer skills  



            case 'railgunner_barrier':
                p.subclass = 'railgunner';
                // Give flame barrier ability
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 8; // 8 seconds
                p.flameBarrierRecharge = 15; // 15 second cooldown
                announce('RAILGUNNER ACTIVATED - Flame Barrier Defense!');
                break;
            case 'demolitionist_barrier':
                p.subclass = 'demolitionist';
                // Give enhanced flame barrier ability
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 12; // Longer duration than railgunner
                p.flameBarrierRecharge = 10; // Faster cooldown than railgunner
                p.flameBarrierExplosive = true; // Explosive reactive damage
                announce('DEMOLITIONIST ACTIVATED - Explosive Flame Wall!');
                break;
                
            // Voidmancer Tier 2 Enhanced Skills
            case 'phasestriker_enhanced':
                p.phasestRikerLevel = 2; // Level 2: Global range + ramping damage/size
                announce('PHASESTRIKER LV2 - Ramping Laser Power!');
                break;
            case 'stormcaller_enhanced':
                p.chainLightningEnhanced = true;
                p.stormstrikerLevel = 2; // Level 2: Twin wing lightning
                announce('STORMSTRIKER LV2 - Twin Wing Lightning!');
                break;
                
            // New Beef Skills
            case 'beef_shield':
                p.beefShieldMax = 100;
                p.beefShield = 100;
                p.beefShieldRegenRate = 5; // Shield per second
                announce('BEEF SHIELD ACTIVATED - Defensive Armor Plating!');
                break;
            case 'beef_shield_enhanced':
                p.beefShieldMax = Math.max(p.beefShieldMax || 100, 200);
                p.beefShield = p.beefShieldMax;
                p.beefShieldRegenRate = 15; // Faster regeneration
                p.beefShieldReflect = true; // Reflect damage back to enemies
                announce('FORTRESS MODE ACTIVATED - Enhanced Defense and Reflection!');
                break;
            case 'beef_charge':
                p.beefChargeState = 'ready';
                p.beefChargeCooldown = 0;
                p.beefCharges = 1;
                p.beefMaxCharges = 1;
                announce('BEEF CHARGE ACTIVATED - Devastating Rush Attack!');
                break;
            case 'beef_charge_enhanced':
                p.beefChargeDamageMultiplier = 2.0; // Double charge damage
                p.beefChargeRange = 1.5; // Increased range
                announce('RAMMING SPEED ACTIVATED - Enhanced Charge Power!');
                break;
                
            // New Rocketman Skills
            case 'flame_barrier':
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 8; // 8 seconds
                p.flameBarrierRecharge = 15; // 15 second cooldown
                announce('FLAME BARRIER ACTIVATED - Burning Protective Field!');
                break;
            case 'flame_barrier_enhanced':
                p.flameBarrierDuration = 12; // Longer duration
                p.flameBarrierRecharge = 10; // Faster cooldown
                p.flameBarrierExplosive = true; // Explosive reactive damage
                announce('INFERNO WALL ACTIVATED - Explosive Reactive Defense!');
                break;
            case 'missile_volley':
                p.missileVolley = Math.max(p.missileVolley || 2, 4);
                announce('MISSILE VOLLEY ACTIVATED - Multi-Missile Salvos!');
                break;
            case 'missile_volley_enhanced':
                p.missileVolley = Math.max(p.missileVolley || 4, 6);
                p.missileReloadBonus = 0.5; // 50% faster reload
                announce('BARRAGE MODE ACTIVATED - Maximum Firepower!');
                break;
                
            // New Voidmancer Skills  
            case 'blink_ability':
                p.blinkDamage = true;
                p.blinkCooldown = 0;
                p.blinkRecharge = 3; // 3 second cooldown
                announce('BLINK ABILITY ACTIVATED - Damaging Teleportation!');
                break;
            case 'blink_ability_enhanced':
                p.blinkDamageEnhanced = true;
                p.blinkRecharge = 2; // Faster cooldown
                p.blinkAreaDamage = true; // Area damage on teleport
                announce('VOID STEP ACTIVATED - Enhanced Teleportation Power!');
                break;
            case 'void_laser':
                p.hasVoidLaser = true;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                announce('VOID LASER ACTIVATED - Focused Beam Weapon!');
                break;
            case 'void_laser_enhanced':
                p.voidLaserEnhanced = true;
                p.voidLaserRampingDamage = 1.0; // Starts at 1x, builds up
                p.voidLaserBeamWidth = 2.0; // Wider beam
                announce('ANNIHILATION BEAM ACTIVATED - Ramping Laser Power!');
                break;
                
            // NEW 5-NODE SKILL TREE SKILLS
            // Marauder Tree Skills
            case 'marauder_multi_charge':
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3);
                p.beefCharges = Math.max(p.beefCharges, 3);
                announce('MULTI CHARGE ACTIVATED - Additional Charge Attacks!');
                break;
            case 'marauder_chain_assault':
                p.beefChainMode = true;
                p.beefChainBonus = 1.5; // 50% bonus damage on chain
                announce('CHAIN ASSAULT ACTIVATED - Chain Between Enemies!');
                break;
            case 'marauder_armor_boost':
                p.hpMax += 25;
                p.hp += 25;
                p.damageReduction = (p.damageReduction || 0) + 0.15;
                announce('BATTLE ARMOR ACTIVATED - Enhanced Durability!');
                break;
            case 'marauder_shield_mastery':
                if (p.beefShieldMax) {
                    p.beefShieldRegenRate = (p.beefShieldRegenRate || 5) * 2;
                    p.beefShieldRegenDelay = Math.max((p.beefShieldRegenDelay || 3) - 1, 1);
                }
                announce('SHIELD MASTERY ACTIVATED - Enhanced Shield Regeneration!');
                break;
                
            // Juggernaut Tree Skills
            case 'juggernaut_charge_power':
                p.beefChargeDamage = (p.beefChargeDamage || 1.0) * 2.0; // 100% more damage
                p.beefChargeKnockback = (p.beefChargeKnockback || 1.0) * 2.0; // 100% more knockback
                p.beefChargeRange = (p.beefChargeRange || 1.0) * 1.5; // 50% more range
                announce('CHARGE POWER ACTIVATED - Enhanced Charge Strength!');
                break;
            case 'juggernaut_charge_mastery':
                p.beefChargeShockwave = true; // Charge creates damaging shockwave
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3); // +2 charges
                p.beefCharges = Math.max(p.beefCharges || 0, 3);
                announce('CHARGE MASTERY ACTIVATED - Shockwave & Extra Charges!');
                break;
            case 'juggernaut_speed_boost':
                p.speedMult *= 1.4;
                p.beefChargeSpeed = (p.beefChargeSpeed || 1.0) * 1.6;
                announce('HEAVY MOMENTUM ACTIVATED - Enhanced Speed and Charge!');
                break;
            case 'juggernaut_dash_mastery':
                p.beefKnockbackResistance = true;
                p.beefChargeCooldown = Math.max((p.beefChargeCooldown || 3) - 1, 1);
                announce('UNSTOPPABLE FORCE ACTIVATED - Enhanced Mobility!');
                break;
                
            // Railgunner Tree Skills
            case 'railgunner_super_pierce':
                p.missilePierce = Math.max(p.missilePierce || 1, 5); // Enhance to 5 enemies (from basic)
                p.missilePierceDamage = (p.missilePierceDamage || 1.0) * 1.3;
                announce('SUPER PIERCE ACTIVATED - Enhanced Missile Pierce!');
                break;
            case 'railgunner_perfect_aim':
                p.missileCritChance = (p.missileCritChance || 0) + 0.25;
                p.missileAccuracy = (p.missileAccuracy || 1.0) * 1.5;
                announce('PERFECT AIM ACTIVATED - Enhanced Targeting!');
                break;
            case 'railgunner_flame_mastery':
                p.flameBarrierDamage = (p.flameBarrierDamage || 1.0) * 1.8;
                p.flameBarrierRadius = (p.flameBarrierRadius || 1.0) * 1.4;
                announce('FLAME MASTERY ACTIVATED - Enhanced Fire Power!');
                break;
            case 'railgunner_wall_control':
                p.flameBarrierCount = (p.flameBarrierCount || 1) + 1;
                p.flameBarrierDuration *= 1.5;
                announce('WALL CONTROL ACTIVATED - Advanced Flame Tactics!');
                break;
                
            // Demolitionist Tree Skills
            case 'demolitionist_bigger_clusters':
                // Make cluster bombs 2x larger with increased blast radius
                p.missileClusterSize = (p.missileClusterSize || 1.0) * 2.0;
                p.missileClusterRadius = (p.missileClusterRadius || 1.0) * 2.0;
                announce('BIGGER CLUSTERS ACTIVATED - Massive Cluster Bombs!');
                break;
            case 'demolitionist_cluster_mastery':
                // Clusters split into secondary explosions, +50% cluster count
                p.missileClusterSecondary = true;
                p.missileClusterCount = Math.max(p.missileClusterCount || 4, Math.floor((p.missileClusterCount || 4) * 1.5));
                announce('CLUSTER MASTERY ACTIVATED - Secondary Explosions!');
                break;
            case 'demolitionist_fire_boost':
                p.fireDamageBonus = (p.fireDamageBonus || 1.0) * 2.0;
                p.burnDuration = (p.burnDuration || 3) * 1.5;
                announce('INFERNO BOOST ACTIVATED - Enhanced Fire Damage!');
                break;
            case 'demolitionist_flame_master':
                p.flameBarrierExplosive = true;
                p.flameBarrierReactiveDamage = 150;
                announce('FLAME MASTER ACTIVATED - Explosive Barriers!');
                break;
                
            // Phasestriker Tree Skills
            case 'phasestriker_unlimited_range':
                // Remove range limitation from void laser
                p.voidLaserRange = 999999; // Unlimited range - can hit any enemy
                p.phasestRikerLevel = 1; // Upgrade to level 1 for unlimited range
                announce('UNLIMITED RANGE ACTIVATED - Global Laser Targeting!');
                break;
            case 'phasestriker_ramping_power':
                // Enable ramping damage/size effect
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 2); // Level 2: Ramping damage/size
                announce('RAMPING POWER ACTIVATED - Growing Laser Strength!');
                break;
            case 'phasestriker_blink_boost':
                p.blinkRange = (p.blinkRange || 200) * 1.8;
                p.blinkCooldown = Math.max((p.blinkCooldown || 5) - 2, 1);
                announce('BLINK BOOST ACTIVATED - Enhanced Teleportation!');
                break;
            case 'phasestriker_phase_mastery':
                p.blinkDamage = (p.blinkDamage || 50) * 2;
                p.blinkInvulnerable = true; // Brief invulnerability during blink
                announce('PHASE MASTERY ACTIVATED - Dimensional Superiority!');
                break;
                
            // Stormcaller Tree Skills
            case 'stormcaller_chain_boost':
                // Add twin lightning bolts from wing guns
                p.stormstrikerLevel = 2; // Twin wing lightning
                announce('TWIN LIGHTNING ACTIVATED - Dual Chain Lightning!');
                break;
            case 'stormcaller_storm_mastery':
                p.chainLightningDamage = (p.chainLightningDamage || 1.0) * 1.8; // 80% damage boost
                p.chainLightningRange = (p.chainLightningRange || 150) * 1.5; // 50% jump range boost
                announce('STORM MASTERY ACTIVATED - Enhanced Range & Power!');
                break;
            case 'stormcaller_warp_boost':
                if (!p.blinkRange) p.blinkRange = 200;
                p.blinkRange *= 1.6;
                p.blinkRecharge = Math.max((p.blinkRecharge || 5) - 1.5, 1);
                announce('WARP BOOST ACTIVATED - Enhanced Teleportation!');
                break;
            case 'stormcaller_void_control':
                p.blinkTimeRipple = true;
                p.blinkRippleDamage = 100;
                announce('VOID CONTROL ACTIVATED - Time Ripple Effects!');
                break;
                
            // NEW TIER 3 & 4 SKILLS FOR SINGLE PATH PROGRESSION
            // Marauder Advanced Skills
            case 'marauder_combat_mastery':
                p.beefChainDamageBonus = (p.beefChainDamageBonus || 1.0) * 2.0;
                p.beefAttackSpeed = (p.beefAttackSpeed || 1.0) * 1.3;
                announce('COMBAT MASTERY ACTIVATED - Advanced Assault Techniques!');
                break;
            case 'marauder_elite_warrior':
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 3, 5);
                p.beefCharges = Math.max(p.beefCharges, 5);
                p.beefEliteCombat = true;
                p.marauderDoubleHitBonus = 3.0; // Elite double-hit gives 3x damage instead of 2x
                announce('ELITE WARRIOR ACTIVATED - Peak Marauder Prowess!');
                break;
                
            // Juggernaut Advanced Skills
            case 'juggernaut_heavy_armor':
                p.hpMax += 50;
                p.hp += 50;
                p.damageReduction = (p.damageReduction || 0) + 0.25;
                p.knockbackImmunity = true;
                announce('HEAVY ARMOR ACTIVATED - Superior Protection!');
                break;
            case 'juggernaut_unstoppable':
                p.beefExplosionRadius = (p.beefExplosionRadius || 1.0) * 2.5;
                p.beefExplosionDamage = (p.beefExplosionDamage || 1.0) * 3.0;
                p.beefUnstoppableForce = true;
                announce('UNSTOPPABLE FORCE ACTIVATED - Maximum Impact Power!');
                break;
                
            // Railgunner Advanced Skills
            case 'railgunner_advanced_ballistics':
                p.missilePierce = Math.max(p.missilePierce || 5, 8);
                p.missileVelocity = (p.missileVelocity || 1.0) * 1.8;
                p.missileHomingStrength = (p.missileHomingStrength || 0.5) * 1.5;
                announce('ADVANCED BALLISTICS ACTIVATED - Superior Missile Technology!');
                break;
            case 'railgunner_precision_master':
                p.missileCritChance = (p.missileCritChance || 0.25) + 0.5;
                p.missileCritDamage = (p.missileCritDamage || 2.0) * 2.0;
                p.railgunMastery = true;
                announce('PRECISION MASTER ACTIVATED - Ultimate Accuracy!');
                break;
                
            // Demolitionist Advanced Skills
            case 'demolitionist_explosive_mastery':
                p.missileClusterCount = Math.max(p.missileClusterCount || 8, 12);
                p.explosionChain = true;
                p.explosionChainCount = 3;
                announce('EXPLOSIVE MASTERY ACTIVATED - Chain Detonations!');
                break;
            case 'demolitionist_demolition_expert':
                p.missileClusterRadius *= 2.0;
                p.megaExplosionChance = 0.3; // 30% chance for mega explosions
                p.demolitionExpert = true;
                announce('DEMOLITION EXPERT ACTIVATED - Maximum Destructive Force!');
                break;
                
            // Phasestriker Advanced Skills
            case 'phasestriker_dimensional_control':
                p.voidLaserPhase = true;
                p.voidLaserPhaseDamage = 2.5;
                p.dimensionalControl = true;
                announce('DIMENSIONAL CONTROL ACTIVATED - Reality Manipulation!');
                break;
            case 'phasestriker_double_beam':
                // Double Long Range Intensifying Beam - fires two parallel beams with intensifying damage
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 4); // Level 4: Double beam
                p.doubleBeam = true;
                p.beamIntensifyRate = 0.1; // 10% damage increase per second of sustained fire
                p.voidLaserMaxRamp *= 2.0; // Double the ramp potential
                announce('DOUBLE LONG RANGE INTENSIFYING BEAM!');
                break;
                
            // Stormcaller Advanced Skills  
            case 'stormcaller_thunder_lord':
                p.stormstrikerLevel = 3; // 4-bolt lightning storm
                p.lightningStorm = true;
                p.thunderLordPower = true;
                announce('THUNDER LORD ACTIVATED - 4 Simultaneous Bolts!');
                break;
            case 'stormcaller_storm_god':
                p.chainLightningDamage *= 3.0;
                p.stormGodPower = true;
                p.omnipotentLightning = true;
                announce('STORM GOD ACTIVATED - Divine Electrical Mastery!');
                break;
                
            // CLASS ABILITY UNLOCKS (5th node rewards)
            case 'beef_shield_unlock':
                p.beefShieldMax = 150;
                p.beefShield = 150;
                p.beefShieldRegenRate = 8;
                p.beefShieldRegenDelay = 3;
                p.beefShieldDamageDealt = 0; // Track damage dealt for shield charging
                p.beefShieldDamageTaken = 0; // Track damage taken for shield depletion
                p.beefShieldCooldown = 0; // Cooldown after depletion before shield can absorb again
                p.hasBeefShield = true;
                playSound('powerup');
                announce('üõ°Ô∏è BEEF SHIELD UNLOCKED! - Class Ability Activated!');
                break;
            case 'blink_unlock':
                p.hasBlink = true;
                p.blinkRange = 250;
                p.blinkCooldown = 4;
                p.blinkDamage = 75;
                playSound('powerup');
                announce('‚ú® BLINK UNLOCKED! - Class Ability Activated!');
                break;
            case 'firewall_unlock':
                p.hasFirewall = true;
                p.firewallDuration = 10;
                p.firewallCooldown = 15;
                p.firewallDamage = 50;
                playSound('powerup');
                announce('üî• FIREWALL UNLOCKED! - Class Ability Activated!');
                break;
        }
    }

    function applySubclassBonus(subclass) {
        const p = store.player;

        switch(subclass) {
            case 'railgunner': 
                p.subclass = 'railgunner';
                p.missilePierce = 2;
                announce('RAILGUNNER ACTIVATED - Piercing Missiles!');
                break;
            case 'demolitionist': 
                p.subclass = 'demolitionist';
                p.missileCluster = true;
                announce('DEMOLITIONIST ACTIVATED - Cluster Bombs!');
                break;
            case 'juggernaut': 
                p.subclass = 'juggernaut';
                // Give 2 charges (beef shield must be purchased separately via skill tree)
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                p.beefCharges = Math.max(p.beefCharges, 2);
                announce('JUGGERNAUT ACTIVATED - Enhanced Charges!');
                break;
            case 'marauder': 
                p.subclass = 'marauder';
                // Give 2 charges and enable chain jumping (beef shield must be purchased separately via skill tree)
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);  
                p.beefCharges = Math.max(p.beefCharges, 2);
                p.beefChainMode = true; // Enable chain jumping for marauder
                p.marauderHitTargets = new Set(); // Initialize double-hit tracking
                announce('MARAUDER ACTIVATED - Chain Jumping!');
                break;
            case 'phasestriker': 
                p.subclass = 'phasestriker';
                // Give basic SHORT RANGE void laser as first upgrade
                p.hasVoidLaser = true;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                p.voidLaserRange = 250; // 25% longer base range
                p.phasestRikerLevel = 0.5; // Base phasestriker level (between 0 and 1)
                break;
            case 'stormcaller':
                p.subclass = 'stormcaller';
                // Give basic chain lightning ability
                p.hasChainLightning = true;
                p.chainLightningCooldown = 0;
                break;
            case 'voidmancer':
                p.subclass = 'voidmancer';
                // Base voidmancer bonus applied during genome selection
                break;
        }
        store.world.enemyHealthBonus *= 1.10;
}

    function showSpecSelect(isAdditive = false) {
        pauseGame();
        const panel = q('subclassPanel'); // Reuse the subclass panel
        const grid = q('subclassGrid');
        const p = store.player;
        const genome = p.pilotGenome;
        
        let choices = [];
        
        if (genome === 'rocketman') {
            if (p.subclass === 'demolitionist') {
                if (isAdditive && p.enhancedClusters) {
                    // If they already have enhanced clusters, double current power
                    choices = [{ id: 'double_clusters', name: 'MEGA CLUSTERS', desc: 'Cluster explosions are twice as large and deal massive damage.', icon: 'demo.png' }];
                } else if (isAdditive && p.missilePierce > 0) {
                    // If they have railgunner abilities, give them enhanced clusters
                    choices = [{ id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' }];
                } else {
                    // First spec or missing railgunner - offer both
                    const opts = [
                        { id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' },
                        { id: 'railgunner_pierce', name: 'PIERCING MISSILES', desc: 'Missiles pierce through 3 enemies with devastating force.', icon: 'rail.png' },
                        { id: 'compact_clusters_pierce', name: 'COMPACT PIERCING', desc: 'Smaller clusters but missiles pierce through 2 enemies.', icon: 'rail.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_clusters');
                }
            } else if (p.subclass === 'railgunner') {
                if (isAdditive && p.enhancedPierce) {
                    choices = [{ id: 'mega_pierce', name: 'ULTRA PIERCE', desc: 'Missiles pierce through 6 enemies with increased damage.', icon: 'rail.png' }];
                } else if (isAdditive && p.enhancedClusters) {
                    choices = [{ id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' }];
                } else {
                    const opts = [
                        { id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' },
                        { id: 'cluster_missiles', name: 'CLUSTER MISSILES', desc: 'Missiles explode into smaller cluster bombs.', icon: 'demo.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_pierce');
                }
            }
        } else if (genome === 'voidmancer') {
            // Voidmancer only gets the power they don't have
            if (!p.hasStormcaller && !p.hasPhasestriker) {
                // First spec - let them choose
                choices = [
                    { id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' },
                    { id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                ];
            } else if (!p.hasStormcaller) {
                choices = [{ id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }];
            } else if (!p.hasPhasestriker) {
                choices = [{ id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' }];
            } else {
                // They have both - offer three enhanced void caller options
                choices = [
                    { id: 'double_storm', name: 'TWIN LIGHTNING', desc: 'Fires two chain lightning bolts instead of one.', icon: 'storm.png' },
                    { id: 'hybrid_void', name: 'VOID STORM', desc: 'Voidstep damages enemies + unlocks single lightning bolt.', icon: 'phase.png' },
                    { id: 'impact_phase', name: 'EARTHQUAKE', desc: 'Voidstep creates a massive impact shockwave at destination.', icon: 'void.png' }
                ];
            }
        } else if (genome === 'beef') {
            // Handle beef subclasses similarly
            if (p.subclass === 'juggernaut') {
                choices = [{ id: 'enhanced_juggernaut', name: 'MEGA JUGGERNAUT', desc: 'Massive charge radius and knockback increase.', icon: 'jug2.png' }];
            } else if (p.subclass === 'marauder') {
                choices = [{ id: 'enhanced_marauder', name: 'SHIELD MASTER', desc: 'Charge restores even more shields and grants temporary invulnerability.', icon: 'marauder.png' }];
            }
        }
        
        if (!choices.length) {
            resumeGame();
            return;
        }
        
        const title = isAdditive ? 'ENHANCED SPECIALIZATION' : 'CHOOSE SPECIALIZATION';
        document.querySelector('#subclassPanel h2').textContent = title;
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-spec="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const specId = card.dataset.spec;
                applySpecBonus(specId);
                panel.classList.add('hide');
                resumeGame();
                document.querySelector('#subclassPanel h2').textContent = 'CHOOSE SPECIALIZATION'; // Reset title
            }, { once: true });
        });

        panel.classList.remove('hide');
    }

    // DISABLED: applySpecBonus function for stability  
    function applySpecBonus(specId) {
        const p = store.player;
        
        switch(specId) {
            case 'enhanced_clusters':
                p.enhancedClusters = true;
                announce('ENHANCED CLUSTERS ACTIVATED!');
                break;
            case 'double_clusters':
                // Implement double cluster damage
                announce('MEGA CLUSTERS ACTIVATED!');
                break;
            case 'railgunner_pierce':
                p.missilePierce = 3;
                announce('PIERCING MISSILES ACTIVATED!');
                break;
            case 'compact_clusters_pierce':
                p.missilePierce = 2;
                // Keep clusters small but add pierce
                announce('COMPACT PIERCING ACTIVATED!');
                break;
            case 'enhanced_pierce':
                p.enhancedPierce = true;
                p.missilePierce = Math.max(p.missilePierce, 4); // Ensure at least 4 pierce
                announce('ENHANCED PIERCE ACTIVATED!');
                break;
            case 'mega_pierce':
                p.missilePierce = 6;
                announce('ULTRA PIERCE ACTIVATED!');
                break;
            case 'cluster_missiles':
                p.missileCluster = true;
                announce('CLUSTER MISSILES ACTIVATED!');
                break;
            case 'phasestriker':
                p.hasPhasestriker = true;
                announce('PHASESTRIKER ACTIVATED!');
                break;
            case 'stormcaller':
                p.hasStormcaller = true;
                p.hasChainLightning = true;
                announce('CHAIN LIGHTNING ACTIVATED!');
                playSound('thunder');
                break;
            case 'double_storm':
                p.hasDoubleStorm = true;
                announce('TWIN CHAIN LIGHTNING ACTIVATED!');
                break;
            case 'hybrid_void':
                p.hasHybridVoid = true; 
                p.blinkDamage = true;  // Enable voidstep damage
                announce('VOID STORM ACTIVATED!');
                break;
            case 'impact_phase':
                p.hasImpactPhase = true;
                p.blinkDamage = true;  // Ensure voidstep does damage
                announce('EARTHQUAKE ACTIVATED!');
                break;
            case 'enhanced_storm':
                announce('MEGA STORM ACTIVATED!');
                break;
            case 'enhanced_phase':
                announce('VOID MASTERY ACTIVATED!');
                break;
            case 'enhanced_juggernaut':
                announce('MEGA JUGGERNAUT ACTIVATED!');
                break;
            case 'enhanced_marauder':
                announce('SHIELD MASTER ACTIVATED!');
                break;
        }
    }


    function ensureName(){
        if(!store.name){
            pauseGame();
            const panel = q("namePanel");
            
            panel.classList.remove("hide");
            q("nameInput").value="";
            setTimeout(()=>q("nameInput").focus(),50)
        } else {
            resumeGame();
            if (store.player.pilotGenome === null) {
                initWave();
            }
        }
    }
    
    q("restartBtn").addEventListener("click", resetGame);
    
    q("saveName").addEventListener("click",()=>{const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}});
    
    const closeShopLogic = () => { q("shopPanel").classList.add('hide'); resumeGame(); const highlighted = document.querySelector('.shop-item.highlight'); if (highlighted) highlighted.classList.remove('highlight'); };
    q("closeShopTopBtn").addEventListener("click", closeShopLogic);
    q("closeShop").addEventListener("click", closeShopLogic);

    q("shopBtn").addEventListener("click", () => {
        if (q('shopPanel').classList.contains('hide')) {
            showShop();
        } else {
            closeShopLogic();
        }
    });

    const closeScoresLogic = () => { q('scorePanel').classList.add('hide'); resumeGame(); };
    // q("closeScores").addEventListener("click", closeScoresLogic); // Button hidden via CSS
    
    q("menuBtn").addEventListener("click",()=>{
        if (q('scorePanel').classList.contains('hide')) {
            pauseGame();
            
            q('scorePanel').classList.remove('hide');
        } else {
            closeScoresLogic();
        }
    });

    q("fsEnterBtn").addEventListener('click',()=>{const r=document.documentElement;if(!document.fullscreenElement){if(r.requestFullscreen)r.requestFullscreen();else if(r.webkitRequestFullscreen)r.webkitRequestFullscreen();else if(r.msRequestFullscreen)r.msRequestFullscreen()}else{if(document.exitFullscreen)document.exitFullscreen()}});
    
    q('pauseBtn').addEventListener('click',()=>{
        if(store.isGameOver || isAnyPanelOpen()) return;
        store.isPaused = !store.isPaused;
        q('pauseBtn').textContent = store.isPaused ? 'RESUME' : 'PAUSE';
    });
    
    q('grenadeBtnUI').addEventListener('click',useGrenade);

    /* Commented out for future implementation
    q('storyBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        pauseGame();
        
        q('storyPanel').classList.remove('hide');
    });
    q('storyPanel').addEventListener('click', () => {
        q('storyPanel').classList.add('hide');
        if (!q('pilotPanel').classList.contains('hide')) {
        } else {
            resumeGame();
        }
    });
    */
    
    q("nameInput").addEventListener("keydown",(e)=>{if(e.key==="Enter"){const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}}});

    q("namePanel").addEventListener("click", (e) => {
        if(e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
            q('nameInput').blur();
        }
    });
    
    let cheatCodeBuffer = "";
    let cheatTapCount = 0;
    let lastCheatTap = 0;

    function activateDamageOffCheat() {
    if (store.isDamageOff) return;
    store.isDamageOff = true;
    store.cheatsUsed = true;
    announce('CHEAT: DAMAGE & ABILITIES OFF');

    const p = store.player;
    const propsToDisable = [
        'dmgMult', 'multishot', 'rearMultishot', 'piercing', 'explosive', 
        'flamethrowerLevel', 'missileVolley', 'critChance', 'critDamage', 
        'hasLauncher', 'hasHounds', 'hasLazarusBeam', 'hasVoidBeam', 
        'hasChainLightning', 'hasIceman', 'blinkDamage', 'missilePierce', 'missileCluster',
        'hasDoubleStorm', 'hasHybridVoid', 'hasImpactPhase'
    ];
    
    store.savedPlayerState = {};
    propsToDisable.forEach(prop => {
        store.savedPlayerState[prop] = p[prop];
        if (typeof p[prop] === 'number') {
            p[prop] = 0;
        } else if (typeof p[prop] === 'boolean') {
            p[prop] = false;
        }
    });

    store.savedPlayerState.hounds = store.hounds;
    store.hounds = [];
    store.savedPlayerState.iceman = store.iceman;
    store.iceman = null;
}

    function deactivateDamageOffCheat() {
        if (!store.isDamageOff || !store.savedPlayerState) return;
        store.isDamageOff = false;
        announce('CHEAT: DAMAGE & ABILITIES ON');

        const p = store.player;
        for (const prop in store.savedPlayerState) {
            if (prop === 'hounds') {
                store.hounds = store.savedPlayerState.hounds;
            } else if (prop === 'iceman') {
                store.iceman = store.savedPlayerState.iceman;
            } else if (p.hasOwnProperty(prop)) {
                p[prop] = store.savedPlayerState[prop];
            }
        }
        
        store.savedPlayerState = null;
}

    function activateSubclassCheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (store.player.subclass) {
            announce("CHEAT FAILED: Subclass already chosen.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO SUBCLASS SELECT');
        showSubclassSelect();
    }
    
    function activateClassCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO CLASS SELECT');
        showPilotSelect();
    }
    
    function activatePowerCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: POWER UP!');
        resetGame();
        store.world.gold = 2000;
        store.player.multishot = 5;
        initWave();
        cheatCodeBuffer = "";
    }

    // ENABLED: Spec2 cheat functions  
    function activateSpec2Cheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (!store.player.subclass) {
            announce("CHEAT FAILED: Choose a Subclass first.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: JUMPING TO SUB2');
        showSpecSelect(true); // true = additive/second spec
    }

    function activateSpeedCheat() {
        // Initialize if not present
        if (!window.gameSpeedMultiplier || window.gameSpeedMultiplier < 1) {
            window.gameSpeedMultiplier = 1;
        }
        
        // Cycle through speed multipliers: 1x -> 2x -> 3x -> 1x
        if (window.gameSpeedMultiplier === 1) {
            window.gameSpeedMultiplier = 2;
            announce('CHEAT: GAME SPEED 2X');
        } else if (window.gameSpeedMultiplier === 2) {
            window.gameSpeedMultiplier = 3;
            announce('CHEAT: GAME SPEED 3X');
        } else {
            window.gameSpeedMultiplier = 1;
            announce('CHEAT: GAME SPEED NORMAL');
        }
        
        store.cheatsUsed = true;
    }

    const SUBCLASS_CHEAT_CODES = {
        jug: { subclass: 'juggernaut', genome: 'beef', label: 'JUGGERNAUT' },
        mar: { subclass: 'marauder', genome: 'beef', label: 'MARAUDER' },
        dem: { subclass: 'demolitionist', genome: 'rocketman', label: 'DEMOLITIONIST' },
        rai: { subclass: 'railgunner', genome: 'rocketman', label: 'RAILGUNNER' },
        pha: { subclass: 'phasestriker', genome: 'voidmancer', label: 'PHASESTRIKER' },
        sto: { subclass: 'stormcaller', genome: 'voidmancer', label: 'STORMCALLER' }
    };

    function clearSubclassEffects() {
        const p = store.player;
        if (!p || !p.subclass) return;

        switch (p.subclass) {
            case 'railgunner':
                p.missilePierce = player_initial_state.missilePierce || 0;
                break;
            case 'demolitionist':
                p.missileCluster = player_initial_state.missileCluster || false;
                break;
            case 'marauder':
                p.beefChainMode = false;
                if (p.marauderHitTargets && typeof p.marauderHitTargets.clear === 'function') {
                    p.marauderHitTargets.clear();
                }
                break;
            case 'phasestriker':
                if (!p.hasPhasestriker) {
                    p.hasVoidLaser = false;
                }
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                p.voidLaserRange = 0;
                break;
            case 'stormcaller':
                if (!p.hasStormcaller) {
                    p.hasChainLightning = false;
                }
                p.chainLightningCooldown = 0;
                break;
        }

        p.subclass = null;
    }

    function activateSubclassOverrideCheat(targetSubclass, requiredGenome, label) {
        const p = store.player;
        if (!p || !p.pilotGenome) {
            announce('CHEAT FAILED: Choose a Pilot first.');
            cheatCodeBuffer = "";
            return;
        }

        if (requiredGenome && p.pilotGenome !== requiredGenome) {
            announce(`CHEAT FAILED: Requires ${requiredGenome.toUpperCase()} pilot.`);
            cheatCodeBuffer = "";
            return;
        }

        store.cheatsUsed = true;

        if (p.subclass === targetSubclass) {
            updateAbilityButtonIcon();
            announce(`CHEAT: ${targetSubclass.toUpperCase()} ALREADY ACTIVE`);
            cheatCodeBuffer = "";
            return;
        }

        clearSubclassEffects();

        const originalEnemyBonus = store.world ? store.world.enemyHealthBonus : null;
        if (label) {
            announce(`CHEAT: ${label} READY`);
        }
        applySubclassBonus(targetSubclass);
        if (store.world && originalEnemyBonus !== null && originalEnemyBonus !== undefined) {
            store.world.enemyHealthBonus = originalEnemyBonus;
        }

        if (targetSubclass === 'marauder' && (!p.marauderHitTargets || typeof p.marauderHitTargets.clear !== 'function')) {
            p.marauderHitTargets = new Set();
        }

        updateAbilityButtonIcon();
        cheatCodeBuffer = "";
    }

    function activateSevenCheat() {
        store.cheatsUsed = true;
        initializeProgressionTracking();

        const pointsGranted = 7;
        for (let i = 0; i < pointsGranted; i++) {
            checkProgressionLogic(true);
        }

        announce(`CHEAT: +${pointsGranted} PROGRESSION POINTS`);
        updateSkillTreeUI();
        cheatCodeBuffer = "";
    }

    q('diagBox').children[0].addEventListener('click', () => {
        const now = performance.now();
        if (now - lastCheatTap > 500) {
            cheatTapCount = 0;
        }
        lastCheatTap = now;
        cheatTapCount++;
        if (cheatTapCount >= 3) {
            activatePowerCheat();
            cheatTapCount = 0;
        }
    });

    addEventListener("keydown", e => {
        const key = e.key.toLowerCase();
        if (document.activeElement.tagName === "INPUT") return;

        if (/[a-z]/.test(key)) {
            cheatCodeBuffer += key;
            if (cheatCodeBuffer.length > 10) {
                cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
            }

            if (cheatCodeBuffer.endsWith('power')) {
                activatePowerCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('off')) {
                activateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('on')) {
                deactivateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('fast')) {
                activateSpeedCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('class')) {
                activateClassCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('sub')) {
                activateSubclassCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('spec2')) {
                activateSpec2Cheat();
                cheatCodeBuffer = "";
            } else {
                const subclassCode = Object.keys(SUBCLASS_CHEAT_CODES).find(code => cheatCodeBuffer.endsWith(code));
                if (subclassCode) {
                    const { subclass, genome, label } = SUBCLASS_CHEAT_CODES[subclassCode];
                    activateSubclassOverrideCheat(subclass, genome, label);
                } else if (cheatCodeBuffer.endsWith('seven')) {
                    activateSevenCheat();
                }
            }
        } else {
            if (key !== ' ' && key !== 'b') {
                cheatCodeBuffer = "";
            }
        }

        if (key === ' ') { e.preventDefault(); useGrenade() }
        if (key === 'escape') { 
            e.preventDefault(); 
            // Close skill tree if it's open
            if (!q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                closeSkillTree();
            }
        }
    });

    let lastTapTime = 0;
    cvs.addEventListener('touchend', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
            const now = performance.now();
            const DOUBLE_TAP_DELAY = 300;
            if (now - lastTapTime < DOUBLE_TAP_DELAY) {
                const p = pointFromEvent(e);
                tryVoidStep(store.player, p);
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: false });

    cvs.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
            const p = pointFromEvent(e);
            tryVoidStep(store.player, p);
        }
    });


    // PERFORMANCE: Enhanced performance monitoring
    let perfFrameCount = 0;
    let perfLastFPSUpdate = 0;
    let perfFPS = 0;
    let perfWorstFrameTime = 0;

    function createPerformanceMetrics() {
        return {
            stepWorldTime: 0,
            renderTime: 0,
            frameTime: 0,
            // New detailed metrics
            hudUpdateTime: 0,
            bulletUpdateTime: 0,
            enemyUpdateTime: 0,
            collisionTime: 0,
            drawCallTime: 0,
            memoryUsage: 0,
            slowFrameCount: 0,
            lastSlowLog: 0,
            activeEnemies: 0,
            activeBullets: 0,
            activeFlames: 0
        };
    }

    let performanceMetrics = createPerformanceMetrics();
    
    // Performance budget alerts
    const PERFORMANCE_BUDGETS = {
        frameTime: 16.67, // 60fps budget
        stepWorld: 8,     // Half frame budget for logic
        render: 4,        // Quarter frame budget for rendering
        hudUpdate: 1      // HUD should be very fast
    };
    
    function setTelemetryEnabled(enabled, forceReset = false) {
        const normalized = !!enabled;
        if (!forceReset && normalized === store.telemetryEnabled) {
            return normalized;
        }

        store.telemetryEnabled = normalized;

        try {
            if (window.localStorage) {
                window.localStorage.setItem('voidTelemetry', normalized ? '1' : '0');
            }
        } catch (err) {
            // Ignore storage access issues
        }

        if (normalized) {
            performanceMetrics = createPerformanceMetrics();
            perfFrameCount = 0;
            perfLastFPSUpdate = performance.now();
            perfWorstFrameTime = 0;
        }

        console.info(`[PERF] Telemetry ${normalized ? 'enabled' : 'disabled'}`);
        return normalized;
    }

    window.enableTelemetry = () => setTelemetryEnabled(true);
    window.disableTelemetry = () => setTelemetryEnabled(false);
    window.toggleTelemetry = () => setTelemetryEnabled(!store.telemetryEnabled);

    setTelemetryEnabled(store.telemetryEnabled, true);

    function frame(now) {
        const telemetryActive = !!store.telemetryEnabled;
        const frameStart = telemetryActive ? performance.now() : 0;
        
        const rawDt = Math.min((now - store.last) / 1000, 0.07);
        const speedMultiplier = window.gameSpeedMultiplier || 1;
        // Cap the dt to prevent simulation instability even with speed multiplier
        const dt = Math.min(rawDt * speedMultiplier, 0.1); 
        
        store.last = now;
        
        let stepStart;
        if (telemetryActive) {
            stepStart = performance.now();
        }
        if (!store.isPaused && !store.isGameOver) {
            stepWorld(dt);
        }
        if (telemetryActive && stepStart !== undefined) {
            performanceMetrics.stepWorldTime = performance.now() - stepStart;
        }
        
        let renderStart;
        if (telemetryActive) {
            renderStart = performance.now();
        }
        render(rawDt); // Use original dt for rendering to avoid visual issues
        if (telemetryActive && renderStart !== undefined) {
            performanceMetrics.renderTime = performance.now() - renderStart;
        }

        if (telemetryActive) {
            const currentFrameTime = performance.now() - frameStart;
            if (currentFrameTime > PERFORMANCE_BUDGETS.frameTime) {
                performanceMetrics.slowFrameCount++;
            }

            const frameTime = currentFrameTime;
            performanceMetrics.frameTime = frameTime;
            performanceMetrics.activeEnemies = store.enemies ? store.enemies.length : 0;
            performanceMetrics.activeBullets = store.bullets ? store.bullets.length : 0;
            performanceMetrics.activeFlames = store._activeFlamesCache ? store._activeFlamesCache.length : 0;

            if (frameTime > perfWorstFrameTime) {
                perfWorstFrameTime = frameTime;
            }

            if (frameTime > 33 && (!performanceMetrics.lastSlowLog || now - performanceMetrics.lastSlowLog > 1500)) {
                console.warn(
                    `[PERF] Slow frame ${frameTime.toFixed(1)}ms (logic ${performanceMetrics.stepWorldTime.toFixed(1)}ms, ` +
                    `render ${performanceMetrics.renderTime.toFixed(1)}ms, enemies ${performanceMetrics.activeEnemies}, ` +
                    `bullets ${performanceMetrics.activeBullets}, flames ${performanceMetrics.activeFlames})`
                );
                performanceMetrics.lastSlowLog = now;
            }

            perfFrameCount++;
            if (now - perfLastFPSUpdate > 3000) { // Log every 3 seconds
                perfFPS = Math.round(perfFrameCount / 3);
                perfFrameCount = 0;
                perfLastFPSUpdate = now;

                // Calculate memory usage if available
                if (performance.memory) {
                    performanceMetrics.memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                }
            }
        }
        
        requestAnimationFrame(frame);
        
    }
    
    // Game initialization moved to DOMContentLoaded event
    

    // Optimized Asset Preloader System
    class AssetPreloader {
        constructor() {
            // Prioritized asset groups for progressive loading
            // ASSET GROUPS DISABLED FOR PERFORMANCE TESTING
            this.assetGroups = {
                critical: {
                    images: [], // ['cow.png', 'rockyboy.png', 'goggles.png'], // Pilot selection UI
                    audio: [] // ['Horn.wav', 'epichorntrimmed.m4a'] // Essential UI sounds
                },
                gameplay: {
                    images: [], // ['marauder.png', 'jug2.png', 'phase.png', 'storm.png'], // Subclass icons
                    audio: [] // ['Explosion.m4a', 'thunk.wav', 'cluster.mp3', 'thunder.mp3'] // Core game sounds
                },
                extended: {
                    images: [], // ['mar11.png', 'mar2.png', 'mar3.png', 'mar4.png', 'jug3.png'], // Skill trees
                    audio: [] // ['trap.m4a', 'dogs.m4a', 'charge.m4a', 'beefcharge.m4a', 'shao_kahn.m4a']
                }
            };
            
            this.loadedAssets = new Map(); // Cache for loaded assets
            this.loadingPromises = new Map(); // Prevent duplicate loading
            this.lastUsed = new Map(); // Track usage for cleanup
            this.memoryLimit = 150 * 1024 * 1024; // 150MB memory limit
            this.currentMemoryUsage = 0;
            
            this.loaded = 0;
            this.total = this.getTotalAssetCount();
            this.progress = 0;
        }

        getTotalAssetCount() {
            return Object.values(this.assetGroups).reduce((total, group) => {
                return total + group.images.length + group.audio.length;
            }, 0);
        }

        updateProgress(assetName, category) {
            this.loaded++;
            this.progress = Math.floor((this.loaded / this.total) * 100);
            
            const loadingBar = document.getElementById('loadingBar');
            const loadingText = document.getElementById('loadingText');
            const loadingDetails = document.getElementById('loadingDetails');
            
            if (loadingBar) loadingBar.style.width = this.progress + '%';
            if (loadingText) loadingText.textContent = `Loading Assets... ${this.progress}%`;
            if (loadingDetails) {
                const categoryName = category === 'image' ? 'Visual Assets' : 'Audio Systems';
                loadingDetails.textContent = `${categoryName}: ${assetName}`;
            }

            if (this.loaded >= this.total) {
                setTimeout(() => this.finishLoading(), 500);
            }
        }

        estimateAssetSize(src, type) {
            // Rough size estimates for memory management
            if (type === 'image') {
                // Estimate based on typical icon sizes: 64x64 = 16KB, 128x128 = 64KB
                return src.includes('skill') || src.includes('tree') ? 16384 : 32768;
            } else if (type === 'audio') {
                // Audio files typically 50KB-500KB
                return src.includes('.m4a') ? 200000 : 100000;
            }
            return 50000; // Default estimate
        }

        cleanupUnusedAssets() {
            // Skip cleanup if we're under memory pressure threshold (75% of limit)
            if (this.currentMemoryUsage < this.memoryLimit * 0.75) {
                return;
            }

            const now = Date.now();
            const cleanupThreshold = 300000; // 5 minutes
            let cleanedMemory = 0;
            const assetsToCleanup = [];

            // Batch identify assets for cleanup to avoid iteration issues
            for (const [key, timestamp] of this.lastUsed) {
                if (now - timestamp > cleanupThreshold && this.loadedAssets.has(key)) {
                    assetsToCleanup.push(key);
                }
            }

            // Prioritize cleanup of largest assets first
            assetsToCleanup.sort((a, b) => {
                const sizeA = this.estimateAssetSize(a, this.loadedAssets.get(a) instanceof Image ? 'image' : 'audio');
                const sizeB = this.estimateAssetSize(b, this.loadedAssets.get(b) instanceof Image ? 'image' : 'audio');
                return sizeB - sizeA;
            });

            // Clean up assets
            assetsToCleanup.forEach(key => {
                const asset = this.loadedAssets.get(key);
                const estimatedSize = this.estimateAssetSize(key, asset instanceof Image ? 'image' : 'audio');
                
                this.loadedAssets.delete(key);
                this.lastUsed.delete(key);
                this.loadingPromises.delete(key); // Also clean up loading promises
                this.currentMemoryUsage -= estimatedSize;
                cleanedMemory += estimatedSize;
            });


        }

        loadAssetGroup(groupName) {
            return new Promise((resolve) => {
                const group = this.assetGroups[groupName];
                if (!group) {
                    resolve();
                    return;
                }

                const allAssets = [...group.images.map(src => ({src, type: 'image'})), 
                                ...group.audio.map(src => ({src, type: 'audio'}))];
                
                if (allAssets.length === 0) {
                    resolve();
                    return;
                }

                let loadedCount = 0;
                const timeout = setTimeout(() => {
                    console.warn(`${groupName} group loading timeout - continuing anyway`);
                    resolve();
                }, 8000);

                allAssets.forEach(({src, type}) => {
                    this.loadSingleAsset(src, type).then(() => {
                        loadedCount++;
                        this.updateProgress(src, type);
                        if (loadedCount === allAssets.length) {
                            clearTimeout(timeout);
                            resolve();
                        }
                    }).catch(() => {
                        loadedCount++;
                        this.updateProgress(src, type);
                        if (loadedCount === allAssets.length) {
                            clearTimeout(timeout);
                            resolve();
                        }
                    });
                });
            });
        }

        loadSingleAsset(src, type) {
            // Check if already loaded or loading
            if (this.loadedAssets.has(src)) {
                this.lastUsed.set(src, Date.now());
                return Promise.resolve(this.loadedAssets.get(src));
            }
            
            if (this.loadingPromises.has(src)) {
                return this.loadingPromises.get(src);
            }

            // Check memory limit before loading
            const estimatedSize = this.estimateAssetSize(src, type);
            if (this.currentMemoryUsage + estimatedSize > this.memoryLimit) {
                this.cleanupUnusedAssets();
            }

            const promise = new Promise((resolve, reject) => {
                if (type === 'image') {
                    const img = new Image();
                    img.onload = () => {
                        this.loadedAssets.set(src, img);
                        this.lastUsed.set(src, Date.now());
                        this.currentMemoryUsage += estimatedSize;
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${src}`);
                        reject(new Error(`Failed to load ${src}`));
                    };
                    img.src = src;
                } else if (type === 'audio') {
                    const audio = new Audio();
                    audio.oncanplaythrough = () => {
                        this.loadedAssets.set(src, audio);
                        this.lastUsed.set(src, Date.now());
                        this.currentMemoryUsage += estimatedSize;
                        resolve(audio);
                    };
                    audio.onerror = () => {
                        console.warn(`Failed to load audio: ${src}`);
                        reject(new Error(`Failed to load ${src}`));
                    };
                    audio.volume = 0.1;
                    audio.src = src;
                }
            });

            this.loadingPromises.set(src, promise);
            return promise;
        }

        // Method to get a loaded asset (lazy load if needed)
        getAsset(src, type = 'image') {
            if (this.loadedAssets.has(src)) {
                this.lastUsed.set(src, Date.now()); // Update usage
                return this.loadedAssets.get(src);
            }
            
            // Lazy load if not available
            this.loadSingleAsset(src, type).catch(err => 
                console.warn(`Failed to lazy load ${src}:`, err)
            );
            
            return null; // Return null for immediate use, will be available later
        }

        // Method to preload assets for a specific feature
        preloadForFeature(feature) {
            const featureAssets = {
                'pilot-selection': ['cow.png', 'rockyboy.png', 'goggles.png'],
                'subclass-selection': ['marauder.png', 'jug2.png', 'phase.png', 'storm.png'],
                'skill-tree': ['mar11.png', 'mar2.png', 'mar3.png', 'jug3.png', 'phase2.png'],
                'combat-audio': ['Explosion.m4a', 'thunk.wav', 'cluster.mp3']
            };

            const assets = featureAssets[feature] || [];
            return Promise.all(assets.map(src => {
                const type = src.includes('.') && (src.endsWith('.mp3') || src.endsWith('.m4a') || src.endsWith('.wav')) ? 'audio' : 'image';
                return this.loadSingleAsset(src, type);
            }));
        }

        async startLoading() {
            try {
                const loadingDetails = document.getElementById('loadingDetails');
                if (loadingDetails) loadingDetails.textContent = 'Initializing combat protocols...';
                
                // Small delay for visual effect
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Progressive loading: Critical first, then gameplay, then extended
                if (loadingDetails) loadingDetails.textContent = 'üöÄ Loading critical assets...';
                await this.loadAssetGroup('critical');
                
                if (loadingDetails) loadingDetails.textContent = '‚öîÔ∏è Loading gameplay assets...';
                await this.loadAssetGroup('gameplay');
                
                // Load extended assets in background after main loading finishes
                setTimeout(() => {
                    this.loadAssetGroup('extended').then(() => {
                        // Assets loaded silently
                    });
                }, 2000);
                
                // Start memory cleanup timer
                setInterval(() => this.cleanupUnusedAssets(), 180000); // Every 3 minutes
                
            } catch (error) {
                console.error('Asset loading failed:', error);
                this.finishLoading(); // Continue anyway
            }
        }

        finishLoading() {
            const loadingDetails = document.getElementById('loadingDetails');
            const loadingText = document.getElementById('loadingText');
            
            if (loadingDetails) loadingDetails.textContent = 'üöÄ Combat systems online! Engaging...';
            if (loadingText) loadingText.textContent = 'Ready for Combat! 100%';
            
            // Make asset manager globally available
            window.assetManager = this;
            
            // Fade out loading screen
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.transition = 'opacity 1s ease-out';
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.pointerEvents = 'none';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        this.initializeGame();
                    }, 1000);
                }
            }, 800);
        }

        initializeGame() {
            // Initialize mobile controls and start the game
            setupMobileControls();
            
            // Show a brief "systems online" message
            setTimeout(() => {
                if (typeof announce === 'function') {
                    announce('üöÄ VOID SKIES: Combat systems online!');
                }
            }, 500);
        }
    }

    // Game initialization runs immediately (like fghfgh.html working version)
    try{
        ensureName();
        refreshScoreList();
        requestAnimationFrame(frame);
    }catch(error){
        console.error("Game initialization failed:",error);
        try{
            updateLeaderboard(null);
            ensureName();
            requestAnimationFrame(frame);
            console.log("Game started in offline mode")
        }catch(criticalError){
            console.error("Critical startup failure:",criticalError);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        // SKIP ASSET LOADING FOR PERFORMANCE TESTING - Start game immediately
        
        // Hide loading screen immediately
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }
        
        // Initialize mobile controls if the function exists (like fghfgh.html)
        if (typeof setupMobileControls === 'function') {
            setupMobileControls();
        }
    });

})();
</script>
</body>
</html>
