<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Void Skies v1.1.2 ‚Ä¢ 1P (Responsive)</title>
  <style>
    :root { --bg:#05070b; --fg:#e6f0ff; --accent:#5eead4; --p1:#60a5fa; --p2:#f472b6; --danger:#f87171; --panel:#0f1524; --edge:rgba(255,255,255,.12); }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%, #0d1220, var(--bg));color:var(--fg);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";}
    /* Responsive shell + stage (fixed 16:9 with letterbox + safe areas) */
    #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:
      calc(16px + env(safe-area-inset-top))
      calc(16px + env(safe-area-inset-right))
      calc(16px + env(safe-area-inset-bottom))
      calc(16px + env(safe-area-inset-left));}
    .stage{width:min(100%, 1200px);aspect-ratio:16/9;position:relative;display:grid;place-items:center;background:#000;border-radius:16px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,.5);}
    canvas{background:transparent;box-shadow:0 10px 40px rgba(0,0,0,.5);border-radius:16px;touch-action:none;}

    /* UI Panels */
    #ui{position:fixed;inset:0;pointer-events:none}
    .panel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:color-mix(in oklab, var(--panel) 92%, black 8%);border:1px solid var(--edge);border-radius:16px;padding:20px;width:min(900px,92vw);pointer-events:auto;backdrop-filter:blur(12px)}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .chip{padding:6px 10px;border-radius:10px;background:rgba(255,255,255,.06);border:1px solid var(--edge)}
    .btn{background:#0b1220;color:var(--fg);border:1px solid var(--edge);border-radius:12px;padding:10px 14px;cursor:pointer}
    .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
    .skill{padding:12px;border:1px solid var(--edge);border-radius:12px;background:rgba(255,255,255,.03);cursor:pointer}
    .skill .req{opacity:.7;font-size:.85rem}
    .hide{display:none!important}

    /* HUD (modernized) */
    #hud{position:absolute;inset:0;padding:12px 14px;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;pointer-events:none;font-size:14px;gap:8px}
    .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));backdrop-filter:blur(8px);padding:8px 10px;border-radius:12px;min-width:250px}
    .hud-title{opacity:.85;font-weight:600;margin-bottom:4px}
    .bar{height:8px;width:100%;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:4px}
    .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#38bdf8)}
    #hudCenter{display:flex;gap:8px}

    /* Menu button */
    #menuBtn{position:fixed;top:12px;right:12px;z-index:5;border-radius:12px;padding:10px 12px;background:rgba(255,255,255,.08);border:1px solid var(--edge);backdrop-filter:blur(8px);cursor:pointer;pointer-events:auto}

    /* Mobile controls (prettier + toggleable) */
    #controls{position:fixed;inset:0;pointer-events:none;display:none} /* Default hidden so a JS parse error doesn't leave UI overlay blocking the game */
    #joy{position:absolute;left:18px;bottom:18px;width:170px;height:170px;border-radius:50%;background:radial-gradient(120px 120px at 50% 50%, rgba(94,234,212,.18), rgba(255,255,255,.04));border:1px solid var(--edge);pointer-events:auto;box-shadow:0 8px 20px rgba(0,0,0,.35)}
    #joyKnob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:76px;height:76px;border-radius:50%;background:linear-gradient(180deg, rgba(255,255,255,.28), rgba(255,255,255,.12));border:1px solid rgba(255,255,255,.25)}
    .roundBtn{position:absolute;right:18px;border-radius:16px;width:92px;height:92px;background:radial-gradient(80px 80px at 50% 35%, rgba(255,255,255,.22), rgba(255,255,255,.06));border:1px solid var(--edge);pointer-events:auto;display:grid;place-items:center;box-shadow:0 8px 20px rgba(0,0,0,.35)}
    #fireBtn{bottom:22px}
    #specBtn{bottom:130px}

    @media (max-width: 820px){ canvas{width:100vw;height:auto;max-height:68vh;border-radius:12px} .panel{width:min(700px,94vw)} .hud-card{min-width:auto} }
  </style>
</head>
<body>
  <div id="wrap"><div class="stage" id="stage"><canvas id="game" width="960" height="540"></canvas></div></div>

  <button id="menuBtn">‚öôÔ∏è</button>

  <div id="ui">
    <div id="settingsPanel" class="panel hide">
      <h2>Settings</h2>
      <div class="row">
        <label class="chip"><input type="radio" name="players" value="1" id="opt1p"> 1 Player</label>
        <label class="chip"><input type="radio" name="players" value="2" id="opt2p"> 2 Players</label>
        <button id="applyPlayers" class="btn">Apply & Restart</button>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="chip"><input type="checkbox" id="toggleControls"> Show Mobile Controls</label>
        <button id="resetProgress" class="btn">Reset Progress</button>
      </div>
      <div class="row" style="justify-content:flex-end;margin-top:10px"><button id="closeSettings" class="btn">Close</button></div>
    </div>

    <div id="levelPanel" class="panel hide">
      <h2>Level Up</h2>
      <p id="levelWho">Player leveled up! Choose a skill.</p>
      <div id="skillsGrid" class="grid"></div>
      <div class="row" style="justify-content:flex-end"><button id="closeLevel" class="btn">Continue</button></div>
    </div>

    <div id="pausePanel" class="panel hide"><h2>‚è∏Ô∏è Paused</h2><p>Press <b>P</b> to resume.</p></div>

    <div id="gameOverPanel" class="panel hide">
      <h2>üí• Game Over</h2>
      <p>Your ship was destroyed. Press <b>R</b> to restart.</p>
      <div class="row" style="justify-content:flex-end"><button id="restartBtn" class="btn">Restart</button></div>
    </div>

    <div id="shopPanel" class="panel hide">
      <h2>üõ†Ô∏è Hangar Shop</h2>
      <p id="shopInfo">Spend Parts to upgrade between waves.</p>
      <div id="shopGrid" class="grid"></div>
      <div class="row" style="justify-content:flex-end"><button id="closeShop" class="btn">Launch</button></div>
    </div>

    <div id="hud">
      <div id="hudP1" class="hud-card"></div>
      <div id="hudCenter" class="hud-card"></div>
      <div id="hudP2" class="hud-card"></div>
    </div>
  </div>

  <div id="controls" aria-hidden="true">
    <div id="joy"><div id="joyKnob"></div></div>
    <div id="fireBtn" class="roundBtn">üî•</div>
    <div id="specBtn" class="roundBtn">‚ú®</div>
  </div>

<script>
(() => {
  /* DEV NOTE: If you ever see static mobile controls & empty HUD, open DevTools ‚Üí Console.
     A syntax/parse error earlier in this file prevents JS from running (controls stay visible by default).
     Fix the error (often a duplicated block or stray brace) and hard refresh. */
  // ===== Core Setup =====
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  const W = 960, H = 540; // logical size (16:9)
  const stage = document.getElementById('stage');
  function resizeCanvas(){
    const rect = stage.getBoundingClientRect();
    const cssW = Math.floor(rect.width);
    const cssH = Math.floor(rect.height);
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cvs.style.width = cssW + 'px';
    cvs.style.height = cssH + 'px';
    cvs.width = Math.floor(cssW * dpr);
    cvs.height = Math.floor(cssH * dpr);
    ctx.setTransform(cvs.width / cssW, 0, 0, cvs.height / cssH, 0, 0);
  }
  const ro = new ResizeObserver(resizeCanvas); ro.observe(stage); resizeCanvas();

  // Time
  let last=performance.now(), acc=0, dtFixed=1/60;

  // Input
  const keys=new Set(); const mouse={x:W*0.5,y:H*0.8,down:false};
  addEventListener('keydown',e=>{ keys.add(e.key); if([' ','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); });
  addEventListener('keyup',e=>keys.delete(e.key));
  cvs.addEventListener('mousemove',e=>{ const r=cvs.getBoundingClientRect(); const sx=r.width/W, sy=r.height/H; mouse.x=(e.clientX-r.left)/sx; mouse.y=(e.clientY-r.top)/sy;});
  addEventListener('mousedown',()=>mouse.down=true); addEventListener('mouseup',()=>mouse.down=false);

  // Mobile controls (prettier + toggleable)
  const joy=$('#joy'), knob=$('#joyKnob'), fireBtn=$('#fireBtn'), specBtn=$('#specBtn');
  let joyActive=false; let joyVec={x:0,y:0};
  function joyPos(e){ const t=e.touches?e.touches[0]:e; const r=joy.getBoundingClientRect(); return {x:t.clientX-r.left, y:t.clientY-r.top}; }
  function joySet(e){ const p=joyPos(e); const cx=85, cy=85; let dx=p.x-cx, dy=p.y-cy; const d=Math.hypot(dx,dy); const max=62; if(d>max){ dx=dx/d*max; dy=dy/d*max; } knob.style.transform=`translate(${dx}px,${dy}px)`; joyVec={x:dx/max, y:dy/max}; }
  joy.addEventListener('pointerdown',e=>{ joyActive=true; joy.setPointerCapture(e.pointerId); joySet(e); });
  joy.addEventListener('pointermove',e=>{ if(joyActive) joySet(e); });
  joy.addEventListener('pointerup',()=>{ joyActive=false; knob.style.transform='translate(-50%,-50%)'; joyVec={x:0,y:0}; });
  fireBtn.addEventListener('pointerdown',()=>mouse.down=true); fireBtn.addEventListener('pointerup',()=>mouse.down=false); fireBtn.addEventListener('pointerleave',()=>mouse.down=false);
  specBtn.addEventListener('pointerdown',()=>keys.add('Shift')); specBtn.addEventListener('pointerup',()=>keys.delete('Shift'));

  // UI helpers
  function $(q){return document.querySelector(q)}
  function show(el){el.classList.remove('hide')} function hide(el){el.classList.add('hide')}

  // Settings panel logic
  const menuBtn=$('#menuBtn'), settingsPanel=$('#settingsPanel');
  const gameOverPanel=$('#gameOverPanel');
  const restartBtn=$('#restartBtn');
  const opt1p=$('#opt1p'), opt2p=$('#opt2p'), applyPlayers=$('#applyPlayers');
  const toggleControls=$('#toggleControls');
  const resetProgress=$('#resetProgress');
  const levelPanel=$('#levelPanel'), skillsGrid=$('#skillsGrid'), pausePanel=$('#pausePanel');
  const shopPanel=$('#shopPanel'), shopGrid=$('#shopGrid');
  const hudP1=$('#hudP1'), hudP2=$('#hudP2'), hudCenter=$('#hudCenter');
  $('#closeLevel').onclick=()=>hide(levelPanel);
  $('#closeShop').onclick=()=>{ hide(shopPanel); gameState='playing'; };
  $('#closeSettings').onclick=()=>hide(settingsPanel);
  menuBtn.onclick=()=>{ fillSettingsFromState(); show(settingsPanel); };
  applyPlayers.onclick=()=>{ startGame({twoPlayers: opt2p.checked}); hide(settingsPanel); };
  toggleControls.onchange=()=>{ setControlsVisible(toggleControls.checked); localStorage.setItem('vs_controls', toggleControls.checked? '1':'0'); };
  resetProgress.onclick=()=>{ localStorage.removeItem('voidskies_save'); startGame({twoPlayers: world.twoPlayers}); };

  // Debug
  let DEBUG=true; addEventListener('keydown',e=>{ if(e.key==='`') DEBUG=!DEBUG; });

  // RNG
  let seed=(Date.now()>>>0) ^ 0x9e3779b9; function rand(){ seed^=seed<<13; seed^=seed>>>17; seed^=seed<<5; return (seed>>>0)/4294967296; }
  const rnd=(a,b)=>a+rand()*(b-a), rndi=(a,b)=>Math.floor(rnd(a,b+1)); const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // Camera + shake
  let shakeT=0, shakeMag=0; function shake(mag=6,time=0.2){ shakeMag=Math.max(shakeMag,mag); shakeT=Math.max(shakeT,time);} 

  // Parallax background
  const layers=[{n:90,s:10,col:'rgba(255,255,255,.4)'},{n:120,s:30,col:'rgba(255,255,255,.7)'},{n:160,s:60,col:'rgba(255,255,255,.9)'}]
    .map(l=>({...l,stars:Array.from({length:l.n},()=>({x:rnd(0,W),y:rnd(0,H)}))}));
  function drawBG(dt){
    ctx.fillStyle='#05070b';
    ctx.fillRect(0,0,W,H);
    // soft nebula glow
    const g = ctx.createRadialGradient(W*0.72,H*0.28,60, W*0.72,H*0.28, 420);
    g.addColorStop(0,'rgba(94,234,212,0.08)');
    g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);
    // parallax star layers
    for(const L of layers){
      for(const s of L.stars){
        s.y+=L.s*dt;
        if(s.y>H){ s.y=0; s.x=rnd(0,W); }
        ctx.fillStyle=L.col;
        ctx.fillRect(s.x,s.y,1,1);
      }
    }
  }
  // ===== Content =====
  const EnemyDefs={
    grunt:{hp:22,speed:62,score:10, shootP:0.003, draw(c){ tri(c,'#eab308'); } , ai:(e,t)=>{ e.t=(e.t||0)+t; e.y+=e.speed*t; e.x+=Math.sin(e.t*2)*40*t; }},
    bruiser:{hp:38,speed:46,score:18, shootP:0.0045, draw(c){ tri(c,'#f97316'); }, ai:(e,t)=>{ e.t=(e.t||0)+t; e.y+=e.speed*t; e.x+=Math.sin(e.t*3)*70*t; }},
    chaser:{hp:28,speed:60,score:16, shootP:0.0,  draw(c){ tri(c,'#22d3ee'); }, ai:(e,t,w)=>{ e.t=(e.t||0)+t; e.y+=e.speed*t; const p=nearestPlayer(w,e); if(p){ const a=Math.atan2(p.y-e.y,p.x-e.x); e.x+=Math.cos(a)*80*t; }}},
    viper:{hp:20,speed:110,score:14, shootP:0.0016, draw(c){ tri(c,'#60a5fa'); }, ai:(e,t)=>{ e.t=(e.t||0)+t; e.y+=e.speed*t; e.x+=Math.sin(e.t*5)*90*t; }},
    sniper:{hp:28,speed:40,score:20, shootP:0.0, draw(c){ tri(c,'#fde047'); }, ai:(e,t,w)=>{ e.t=(e.t||0)+t; e.y+=e.speed*t; if((e.t||0)%1.2<0.02){ const p=nearestPlayer(w,e); if(p){ const a=Math.atan2(p.y-e.y,p.x-e.x); w.bullets.push(new Bullet(e.x,e.y+8, Math.cos(a)*240, Math.sin(a)*240, null,'#fca5a5')); } } }},
    mine:{hp:22,speed:32,score:18, shootP:0, draw(c){ c.fillStyle='#94a3b8'; c.beginPath(); c.arc(0,0,10,0,Math.PI*2); c.fill(); }, ai:(e,t,w)=>{ e.t=(e.t||0)+t; e.y+=e.speed*t; if(!e.arm) e.arm = 1.5 + rnd(0.4,1.4); if(e.t>e.arm || e.y>H*0.72){ // explode
        for(let i=0;i<10;i++){ const a=i*(Math.PI*2/10)+rand()*0.2; w.bullets.push(new Bullet(e.x,e.y, Math.cos(a)*160, Math.sin(a)*160, null, '#fca5a5')); }
        e.alive=false; }
      }},
    turret:{hp:56,speed:18,score:26, shootP:0, draw(c){ c.fillStyle='#a78bfa'; c.fillRect(-10,-10,20,20); }, ai:(e,t,w)=>{ e.t=(e.t||0)+t; e.y = Math.min(e.y + e.speed*t, 120); if(e.t>0.5){ e.t=0; for(let i=0;i<6;i++){ const a=i*(Math.PI*2/6)+rand()*0.2; w.bullets.push(new Bullet(e.x,e.y, Math.cos(a)*200, Math.sin(a)*200, null,'#c4b5fd')); } } }},
    splitter:{hp:30,speed:55,score:22, shootP:0.003, draw(c){ tri(c,'#34d399'); }, ai:(e,t)=>{ e.t=(e.t||0)+t; e.y+=e.speed*t; e.x+=Math.sin(e.t*2.5)*50*t; }, onDeath:(e,w)=>{ for(let i=0;i<2;i++){ w.enemies.push(new Enemy(EnemyDefs.grunt, e.x+(i?-12:12), e.y-10)); } }},
  };

  const BossDefs={
    behemoth:{hp:600, score:120, draw(c){ c.fillStyle='#94a3b8'; c.beginPath(); c.arc(0,0,40,0,Math.PI*2); c.fill(); },
      ai:(b,t,w)=>{ b.t=(b.t||0)+t; b.y+=30*t; b.x+=Math.sin(b.t*1.2)*100*t; if(rand()<0.02){
        for(let i=0;i<12;i++){ const a=i*(Math.PI*2/12); w.bullets.push(new Bullet(b.x, b.y, Math.cos(a)*160, Math.sin(a)*160, null, '#fca5a5')); }
      } if(rand()<0.015){ const p=nearestPlayer(w,b); if(p){ const a=Math.atan2(p.y-b.y,p.x-b.x); w.bullets.push(new Bullet(b.x,b.y,Math.cos(a)*220,Math.sin(a)*220,null,'#fca5a5')); } }
      }
    },
    sentinel:{hp:520, score:160, draw(c){ c.save(); c.rotate((Date.now()%4000)/4000*Math.PI*2); c.strokeStyle='#f472b6'; c.beginPath(); c.arc(0,0,44,0,Math.PI*2); c.stroke(); c.fillStyle='rgba(244,114,182,.2)'; c.beginPath(); c.arc(0,0,26,0,Math.PI*2); c.fill(); c.restore(); },
      ai:(b,t,w)=>{ b.t=(b.t||0)+t; b.y = Math.min(b.y + 25*t, 140); b.x+=Math.sin(b.t*1.1)*120*t; const base=b.t*2.4; for(let i=0;i<2;i++){ const a=base+i*Math.PI; if(rand()<0.12){ w.bullets.push(new Bullet(b.x,b.y, Math.cos(a)*260, Math.sin(a)*260, null,'#fb7185')); } } if(rand()<0.02){ for(let i=0;i<10;i++){ const a=i*(Math.PI*2/10)+b.t*0.6; w.bullets.push(new Bullet(b.x,b.y, Math.cos(a)*180, Math.sin(a)*180, null,'#fb7185')); } } }
    },
    carrier:{hp:680, score:180, draw(c){ c.fillStyle='#38bdf8'; c.beginPath(); c.moveTo(-46,-12); c.lineTo(46,-12); c.lineTo(24,14); c.lineTo(-24,14); c.closePath(); c.fill(); },
      ai:(b,t,w)=>{ b.t=(b.t||0)+t; b.y = Math.min(b.y + 18*t, 120); b.x+=Math.sin(b.t*0.9)*80*t; if(rand()<0.03){ w.enemies.push(new Enemy(EnemyDefs.viper, b.x+rnd(-40,40), b.y+30)); } if(rand()<0.01){ for(let i=0;i<6;i++){ const a=i*(Math.PI*2/6); w.bullets.push(new Bullet(b.x, b.y, Math.cos(a)*150, Math.sin(a)*150, null, '#38bdf8')); } } }
    }
  };

  const SkillDefs={
    gunnery1:{name:'Gunnery I',desc:'+20% bullet dmg',req:[],apply:p=>p.stats.bulletDamage*=1.2},
    gunnery2:{name:'Gunnery II',desc:'+25% bullet dmg',req:['gunnery1'],apply:p=>p.stats.bulletDamage*=1.25},
    gunnery3:{name:'Gunnery III',desc:'+30% bullet dmg',req:['gunnery2'],apply:p=>p.stats.bulletDamage*=1.3},
    focus:{name:'Targeting Focus',desc:'-20% fire CD',req:['gunnery1'],apply:p=>p.stats.fireCd*=0.8},
    overclock:{name:'Overclock',desc:'-15% fire CD',req:['focus'],apply:p=>p.stats.fireCd*=0.85},
    shields1:{name:'Shield Plating I',desc:'+25% max HP',req:[],apply:p=>{p.stats.maxHp=Math.round(p.stats.maxHp*1.25); p.hp=p.stats.maxHp;}},
    shields2:{name:'Shield Plating II',desc:'+35% max HP',req:['shields1'],apply:p=>{p.stats.maxHp=Math.round(p.stats.maxHp*1.35); p.hp=p.stats.maxHp;}},
    engine1:{name:'Engine Tuning',desc:'+15% speed',req:[],apply:p=>p.stats.speed*=1.15},
    reactor:{name:'Reactor Overdrive',desc:'Special lasts 2√ó',req:['engine1'],apply:p=>p.stats.specialDur*=2},
    drone:{name:'Auto‚ÄëDrone',desc:'Adds a helper drone',req:['focus'],apply:p=>p.deployDrone()},
    salvage:{name:'Salvage Ops',desc:'+25% parts gain',req:[],apply:p=>p.stats.partsBonus=1.25},
    autoRepair:{name:'Auto‚ÄëRepair',desc:'Regenerate 1 HP/s',req:['shields1'],apply:p=>p.mods.regen=(p.mods.regen||0)+1},
    magnet:{name:'Tractor Beam',desc:'Pickup range ‚Üë',req:[],apply:p=>p.mods.magnet=(p.mods.magnet||0)+1},
  };

  const ShopDefs=[
    {key:'heal', name:'Repair Kit', cost:20, desc:'Restore 50 HP', apply:p=>p.hp=Math.min(p.stats.maxHp,p.hp+50)},
    {key:'rate', name:'Refined Actuator', cost:35, desc:'‚àí18% fire cooldown', apply:p=>p.stats.fireCd*=0.82},
    {key:'dmg',  name:'High‚ÄëEnergy Rounds', cost:40, desc:'+25% bullet damage', apply:p=>p.stats.bulletDamage*=1.25},
    {key:'move', name:'Engine Baffles', cost:30, desc:'+12% move speed', apply:p=>p.stats.speed*=1.12},
    {key:'spread', name:'Twin Spread', cost:45, desc:'Adds spread shot', apply:p=>p.mods.spread=Math.min(3,(p.mods.spread||1)+1)},
    {key:'pierce', name:'Piercing Rounds', cost:60, desc:'Bullets pierce 1 target', apply:p=>p.mods.pierce=1},
    {key:'shield', name:'Reactive Shielding', cost:50, desc:'+1s special duration', apply:p=>p.stats.specialDur*=1.25},
    {key:'drone2', name:'Drone Overhaul', cost:55, desc:'Drone fires more often', apply:p=>p.mods.droneBoost=(p.mods.droneBoost||1)+0.5},
  ];

  // ===== Entities =====
  const PowerTypes={
    heal:{label:'‚ù§Ô∏è +40', col:'#86efac', apply:p=>p.hp=Math.min(p.stats.maxHp,p.hp+40)},
    rapid:{label:'‚ö° fire', col:'#a5b4fc', apply:p=>p.tempRapid=6},
    damage:{label:'üí• dmg', col:'#fca5a5', apply:p=>p.tempDamage=6},
    shield:{label:'üõ°Ô∏è shield', col:'#fde68a', apply:p=>p.tempShield=8},
  };
  class Powerup{ constructor(x,y,type){ this.x=x; this.y=y; this.r=10; this.type=type; this.alive=true; this.t=0; }
    step(t){ this.t+=t; this.y+=40*t; if(this.y>H+20) this.alive=false; }
    draw(){ ctx.save(); ctx.translate(this.x,this.y); ctx.fillStyle=PowerTypes[this.type].col; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#071018'; ctx.font='10px system-ui'; ctx.textAlign='center'; ctx.fillText(PowerTypes[this.type].label,0,3); ctx.restore(); }
  }
  class Bullet{ constructor(x,y,vx,vy,owner,col){ this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.r=3;this.owner=owner;this.col=col||'#fff';this.alive=true; this.pierce=owner?.mods?.pierce||0; this.dmg=(owner?.stats?.bulletDamage||8) * (owner?.tempDamage?1.6:1); }
    step(t){ this.x+=this.vx*t; this.y+=this.vy*t; if(this.y<-10||this.y>H+10||this.x<-10||this.x>W+10) this.alive=false; }
    draw(){ dot(this.x,this.y,this.r,this.col); }
  }
  class Enemy{ constructor(def,x,y){ this.kind='enemy'; this.def=def; Object.assign(this, {x,y,r:14,hp:def.hp,t:0,alive:true}); }
    step(t,world){ this.def.ai(this,t,world); if(rand()<this.def.shootP) world.bullets.push(new Bullet(this.x,this.y+8,0,200,null,'#fca5a5')); if(this.y>H+40) this.alive=false; }
    draw(){ ctx.save(); ctx.translate(this.x,this.y); this.def.draw(ctx); ctx.restore(); }
  }
  class Boss{ constructor(def,x,y){ this.kind='boss'; this.def=def; Object.assign(this,{x,y,r:40,hp:def.hp,maxHp:def.hp,t:0,alive:true,leashT:0}); }
    step(t,world){ this.def.ai(this,t,world);
      this.x = clamp(this.x, 60, W-60);
      this.y = clamp(this.y, 60, H*0.65);
      const nearEdge = (this.y>=H*0.64)||(this.x<=62)||(this.x>=W-62)||(this.y<=58);
      this.leashT = nearEdge ? Math.min(this.leashT+t, 2) : Math.max(0,this.leashT-t*2);
      if(this.leashT>1.2){ const ax=(W/2-this.x)*0.6, ay=(H*0.35-this.y)*0.6; this.x+=ax*t; this.y+=ay*t; }
  }
    draw(){ ctx.save(); ctx.translate(this.x,this.y); this.def.draw(ctx); ctx.strokeStyle='#f87171'; ctx.beginPath(); ctx.arc(0,0,this.r+6,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  }
  class Particle{ constructor(x,y,vx,vy,c,life=.6){ Object.assign(this,{x,y,vx,vy,c,life,alive:true}); }
    step(t){ this.life-=t; if(this.life<=0) this.alive=false; this.x+=this.vx*t; this.y+=this.vy*t; this.vy+=60*t; }
    draw(){ ctx.globalAlpha=Math.max(0,this.life/0.6); ctx.fillStyle=this.c; ctx.fillRect(this.x,this.y,3,3); ctx.globalAlpha=1; }
  }
  class Player{ constructor(id,x,y,col,control){ Object.assign(this,{id,x,y,r:14,col,control}); this.stats={maxHp:100,speed:180,fireCd:.22,bulletDamage:10,specialCd:10,specialDur:3,partsBonus:1}; this.mods={spread:1,pierce:0}; this.hp=this.stats.maxHp; this.fireT=0; this.specialT=0; this.specialA=0; this.level=1; this.xp=0; this.xpNext=60; this.sp=0; this.skills=new Set(); this.drone=null; this.tempRapid=0; this.tempDamage=0; this.tempShield=0; }
    step(t){ this.tempRapid=Math.max(0,this.tempRapid-t); this.tempDamage=Math.max(0,this.tempDamage-t); this.tempShield=Math.max(0,this.tempShield-t);
      let dx=joyVec.x, dy=joyVec.y; if(Math.hypot(dx,dy)<0.05){ dx=0; dy=0; }
      if(this.control.type==='mouse' && dx===0 && dy===0){ const vx=mouse.x-this.x, vy=mouse.y-this.y; const d=Math.hypot(vx,vy); if(d>1){ dx=vx/d; dy=vy/d; } }
      else if(this.control.type==='keys'){ const K=this.control.keys; if(keys.has(K.up)) dy-=1; if(keys.has(K.down)) dy+=1; if(keys.has(K.left)) dx-=1; if(keys.has(K.right)) dx+=1; if(dx||dy){ const l=Math.hypot(dx,dy); dx/=l; dy/=l; } }
      this.x=clamp(this.x+dx*this.stats.speed*t,20,W-20); this.y=clamp(this.y+dy*this.stats.speed*t,20,H-20);
      this.fireT-=t; const wantsFire=(this.control.type==='mouse'? mouse.down : keys.has(this.control.keys.fire)); if(wantsFire && this.fireT<=0){ this.shoot(); const cd=this.stats.fireCd*(this.specialA?0.5:1)*(this.tempRapid?0.6:1); this.fireT=cd; } 
      this.specialT-=t; const wantsSpec=(this.control.type==='mouse'? (keys.has('Shift')||keys.has('ShiftLeft')||keys.has('ShiftRight')) : keys.has(this.control.keys.special)); if(wantsSpec && this.specialT<=0){ this.specialA=this.stats.specialDur; this.specialT=this.stats.specialCd; }
      if(this.specialA>0) this.specialA=Math.max(0,this.specialA-t);
      if(this.drone) this.droneStep(t);
    }
    draw(){ ctx.save(); ctx.translate(this.x,this.y); tri(ctx,this.col); if(this.specialA>0||this.tempShield>0){ ctx.globalAlpha=.9; ctx.strokeStyle=this.tempShield>0?'#fde68a':this.col; ctx.lineWidth=1.5; ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
      if(rand()<0.35){ world.particles.push(new Particle(this.x+rand()*6-3, this.y+16, 0, rnd(20,40), 'rgba(148,163,184,.7)', .3)); }
      ctx.restore(); if(this.drone) this.droneDraw(); }
    shoot(){ const spread=this.mods.spread||1; const base= -360*(this.specialA?1.2:1); for(let i=0;i<spread;i++){ const off=(i-(spread-1)/2)*50; world.bullets.push(new Bullet(this.x-6+off*0.02,this.y-12, off*2, base, this, this.col)); world.bullets.push(new Bullet(this.x+6+off*0.02,this.y-12, off*2, base, this, this.col)); } }
    hit(d){ if(this.tempShield>0){ this.tempShield=Math.max(0,this.tempShield-0.6); return; } this.hp-=d; shake(8,.15); if(this.hp<=0){ this.hp=0; killPlayer(this); }}
    earn(xp,parts){ this.xp+=xp; world.currency+=Math.round(parts*(this.stats.partsBonus||1)); if(this.xp>=this.xpNext){ this.level++; this.sp++; this.xp-=this.xpNext; this.xpNext=Math.round(this.xpNext*1.35); queueLevelUp(this);} }
    deployDrone(){ this.drone={t:0}; }
    droneStep(t){ this.drone.t+=t; const rate = 25/(this.mods.droneBoost||1); if(rndi(0,rate)===0){ world.bullets.push(new Bullet(this.x+Math.cos(this.drone.t*2)*24, this.y-24+Math.sin(this.drone.t*2)*6, 0, -340, {stats:{bulletDamage:6}}, '#a7f3d0')); } }
    droneDraw(){ const px=this.x+Math.cos(this.drone.t*2)*24, py=this.y-24+Math.sin(this.drone.t*2)*6; dot(px,py,4,'#a7f3d0'); }
  }

  // ===== World =====
  let world={ players:[], enemies:[], bullets:[], particles:[], powerups:[], wave:1, currency:0, score:0, gameOver:false, twoPlayers:false, boss:null };
  const SAVE_KEY='voidskies_save';
  function save(){ const p=world.players[0]; if(!p) return; const data={parts:world.currency, wave:world.wave, p1:{hp:p.hp, stats:p.stats, mods:p.mods}}; localStorage.setItem(SAVE_KEY, JSON.stringify(data)); }
  function load(){ try{ const d=JSON.parse(localStorage.getItem(SAVE_KEY)||'null'); if(!d) return; persist=d; }catch{} }
  let persist=null; load();

  function nearestPlayer(w,e){ let best=null,bd=1e9; for(const p of w.players){ const d=(p.x-e.x)**2+(p.y-e.y)**2; if(d<bd){bd=d;best=p;} } return best; }

  // ===== Waves / Spawner =====
  const Spawner={ timer:0, interval:0.7, left:0, watchdog:0, startedAt:0 };
  function beginWave(){
    Spawner.startedAt=performance.now();
    Spawner.watchdog=0;
    if(world.wave%5===0){
      const bossKeys = Object.keys(BossDefs);
      const pick = bossKeys[rndi(0,bossKeys.length-1)];
      world.boss=new Boss(BossDefs[pick], W/2, -60);
      Spawner.left=0;
    } else {
      Spawner.left=8+world.wave*2;
      Spawner.interval=Math.max(0.22, 0.9 - world.wave*0.045);
      Spawner.timer=0;
    }
  }
  function spawnOne(){
    const w=world.wave;
    const weights={ grunt:6, bruiser:Math.max(1,Math.floor(w/3)), chaser:Math.max(1,Math.floor(w/4)), viper:w>2?2:0, sniper:w>3?2:0, mine:w>4?2:0, turret:w>6?1:0, splitter:w>5?1:0 };
    const pool=[]; for(const [k,val] of Object.entries(weights)){ for(let i=0;i<val;i++) pool.push(k); }
    const pick = pool[rndi(0,pool.length-1)] || 'grunt';
    world.enemies.push(new Enemy(EnemyDefs[pick], rnd(40,W-40), -30));
    Spawner.left--;
  }
  function spawnerStep(t){
    if(Spawner.left>0){
      Spawner.timer-=t;
      if(Spawner.timer<=0){ spawnOne(); Spawner.timer=Spawner.interval; }
    }
    Spawner.watchdog += t;
    const noAction = world.enemies.length===0 && !world.boss && Spawner.left===0;
    if(Spawner.watchdog>2.0 && noAction){ beginWave(); }
  }

  // ===== Level Up UI =====
  function queueLevelUp(player){ show(levelPanel); $('#levelWho').textContent=`Player ${player.id} leveled up! Choose a skill.`; renderSkillChoices(player); gameState='paused'; }
  function availableSkillsOf(p){ const out=[]; for(const [k,d] of Object.entries(SkillDefs)){ if(p.skills.has(k)) continue; if(d.req.every(r=>p.skills.has(r))) out.push({k,d}); } return out; }
  function renderSkillChoices(p){ skillsGrid.innerHTML=''; let avail=availableSkillsOf(p).slice(0,6); for(const {k,d} of avail){ const card=document.createElement('div'); card.className='skill'; card.innerHTML=`<b>${d.name}</b><div>${d.desc}</div>${d.req.length?`<div class="req">Requires: ${d.req.map(r=>SkillDefs[r].name).join(', ')}</div>`:''}`; card.onclick=()=>{ if(p.sp<=0) return; p.sp--; p.skills.add(k); d.apply(p); hide(levelPanel); gameState='playing'; }; skillsGrid.appendChild(card);} }

  // ===== Shop =====
  function openShop(){ shopGrid.innerHTML=''; const p=world.players[0]; ShopDefs.forEach(item=>{ const el=document.createElement('div'); el.className='skill'; el.innerHTML=`<b>${item.name}</b><div>${item.desc}</div><div class="chip">${item.cost} Parts</div>`; el.onclick=()=>{ if(world.currency>=item.cost){ world.currency-=item.cost; item.apply(p); renderHUD(); save(); } }; shopGrid.appendChild(el); }); show(shopPanel); gameState='paused'; }

  // ===== Scenes & Settings =====
  let gameState='playing';
  function setControlsVisible(v){ $('#controls').style.display = v? 'block':'none'; }
  function fillSettingsFromState(){ opt1p.checked=!world.twoPlayers; opt2p.checked=world.twoPlayers; toggleControls.checked=$('#controls').style.display!=='none'; }

  function startGame({twoPlayers}){
    world={players:[], enemies:[], bullets:[], particles:[], powerups:[], wave: persist?.wave||1, currency: persist?.parts||0, score:0, gameOver:false, twoPlayers: !!twoPlayers, boss:null};
    const p1=new Player(1, W*0.3, H-60, getComputedStyle(document.documentElement).getPropertyValue('--p1').trim()||'#60a5fa', {type:'mouse'});
    if(persist?.p1){ Object.assign(p1.stats,persist.p1.stats||{}); Object.assign(p1.mods,persist.p1.mods||{}); p1.hp=persist.p1.hp||p1.stats.maxHp; }
    world.players.push(p1);
    if(twoPlayers){ world.players.push(new Player(2, W*0.7, H-60, getComputedStyle(document.documentElement).getPropertyValue('--p2').trim()||'#f472b6', {type:'keys',keys:{up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight',fire:'/',special:'ShiftRight'}})); }
    beginWave(); // start first wave immediately
    hide(levelPanel); hide(pausePanel); hide(shopPanel); renderHUD();
  }

  // Initial visibility for mobile controls (persisted)
  const persistedCtrl = localStorage.getItem('vs_controls');
  // Default: controls hidden unless user opts in (prevents overlay blocking)
  setControlsVisible(persistedCtrl===null ? false : persistedCtrl==='1');

  // Auto-start instantly (no splash) in 1P by default; user can switch in settings
  startGame({twoPlayers:false});

  // ===== Update =====
  function stepSim(t){
    spawnerStep(t);

    for(const p of world.players) p.step(t);
    for(const b of world.bullets) b.step(t);
    if(world.boss){ world.boss.step(t,world); }
    for(const e of world.enemies) e.step(t,world);
    for(const pu of world.powerups) pu.step(t);

    // Collisions: player bullets ‚Üí enemies/boss
    for(const b of world.bullets){ if(!b.alive) continue; if(!world.players.includes(b.owner)) continue; 
      if(world.boss && b.alive && collide(b,world.boss)){ world.boss.hp-=b.dmg; if(b.pierce>0) b.pierce--; else b.alive=false; hit(b.x,b.y,'#fde047'); if(world.boss.hp<=0){ world.boss=null; world.players.forEach(p=>p.earn(80/world.players.length, 60/world.players.length)); world.score += 500; pop(W/2,120,'#c7d2fe',24); } }
      for(const e of world.enemies){ if(!e.alive) continue; if(collide(b,e)){ e.hp-=b.dmg; if(b.pierce>0) b.pierce--; else b.alive=false; if(e.hp<=0){ e.alive=false; if(e.def.onDeath) e.def.onDeath(e,world); shake(5,.12); pop(e.x,e.y,'#fde047',12); if(rand()<0.30){ const kinds=['heal','rapid','damage','shield']; const k=kinds[rndi(0,kinds.length-1)]; world.powerups.push(new Powerup(e.x,e.y,k)); } const xp=e.def.score, parts=Math.round(e.def.score/2); world.players.forEach(p=>p.earn(xp/world.players.length, parts/world.players.length)); world.score += e.def.score*10; } }
      }
    }

    // Enemy bullets ‚Üí players
    for(const b of world.bullets){ if(!b.alive) continue; if(world.players.includes(b.owner)) continue; for(const p of world.players){ if(collide(b,p)){ p.hit(8); b.alive=false; hit(p.x,p.y,p.col); } } }
    // Enemies/Boss ‚Üí players
    if(world.boss){ for(const p of world.players){ if(collide(world.boss,p)){ p.hit(18); } } }
    for(const e of world.enemies){ if(!e.alive) continue; for(const p of world.players){ if(collide(e,p)){ p.hit(12); e.alive=false; pop(e.x,e.y,'#fde047',10); } } }

    // Powerups ‚Üí players
    for(const pu of world.powerups){ for(const p of world.players){ if(collide({x:pu.x,y:pu.y,r:pu.r},{x:p.x,y:p.y,r:p.r})){ PowerTypes[pu.type].apply(p); pu.alive=false; pop(pu.x,pu.y,PowerTypes[pu.type].col,8); } } }

    // Cleanup
    world.bullets=world.bullets.filter(b=>b.alive);
    world.enemies=world.enemies.filter(e=>e.alive);
    world.powerups=world.powerups.filter(pu=>pu.alive);
    for(const prt of world.particles) prt.step(t); world.particles=world.particles.filter(p=>p.alive);

    // Wave clear -> shop or next wave
    const cleared = !world.boss && world.enemies.length===0 && Spawner.left<=0 && !world.gameOver;
    if(cleared && gameState==='playing'){ world.wave++; save(); openShop(); beginWave(); }
  }

  // ===== Render =====
  let fpsSm=60; function render(dt){
    drawBG(dt);
    let ox=0,oy=0; if(shakeT>0){ shakeT=Math.max(0,shakeT-dt); const m=shakeMag*(shakeT/0.2); ox=(rand()-.5)*m; oy=(rand()-.5)*m; }
    ctx.save(); ctx.translate(ox,oy);
    for(const p of world.players) p.draw();
    if(world.boss) world.boss.draw();
    for(const e of world.enemies) e.draw();
    for(const b of world.bullets) b.draw();
    for(const pu of world.powerups) pu.draw();
    for(const prt of world.particles) prt.draw();
    ctx.restore();
    renderHUD();
    if(DEBUG){ fpsSm = fpsSm*0.9 + (1/dt)*0.1; debugBadge(`Void Skies v1.1.2 ‚Ä¢ 1P  |  state: ${gameState}  |  FPS: ${fpsSm.toFixed(0)}`); }
  }

  function debugBadge(text){ ctx.fillStyle='rgba(0,0,0,.45)'; const w=12+ctx.measureText(text).width+12; ctx.fillRect(8,8, w, 28); ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.fillText(text, 20, 27); }

  function renderHUD(){
    function hudFor(p,label,color){
      const xpPct=Math.max(0,Math.min(1,p.xp/p.xpNext));
      return `
      <div class="hud-title">${label}</div>
      <div class="row" style="gap:6px;pointer-events:none">
        <div class="chip">HP <b style="color:${color}">${Math.max(0,Math.round(p.hp))}</b>/<span>${p.stats.maxHp}</span></div>
        <div class="chip">Lvl <b>${p.level}</b> ‚Ä¢ SP <b>${p.sp}</b></div>
      </div>
      <div class="bar"><span style="width:${(xpPct*100).toFixed(0)}%"></span></div>`;
    }
    hudP1.innerHTML = world.players[0]? hudFor(world.players[0], 'Player 1', 'var(--p1)') : '';
    hudP2.innerHTML = world.players[1]? hudFor(world.players[1], 'Player 2', 'var(--p2)') : '';
    let center = `<div class="hud-title">Wave ${world.wave}</div><div class="row" style="gap:6px"><div class="chip">Parts <b>${world.currency}</b></div><div class="chip">Score <b>${world.score}</b></div></div>`;
    if(world.boss){
      const pct=Math.max(0,Math.min(1, world.boss.hp/world.boss.maxHp));
      center += `<div class=\"bar\" style=\"margin-top:6px\"><span style=\"width:${(pct*100).toFixed(0)}%\"></span></div>`;
    }
    hudCenter.innerHTML = center;
  }
  // ===== Helpers =====
  function killPlayer(p){
    pop(p.x,p.y,p.col,24);
    world.players.length=0; // 1P: remove pilot
    world.gameOver=true;
    gameState='paused';
    if(gameOverPanel) show(gameOverPanel);
  }

  function pop(x,y,c='#fde047',n=10){ for(let i=0;i<n;i++) world.particles.push(new Particle(x,y,rnd(-140,140),rnd(-80,40),c)); }
  function hit(x,y,c='#fff'){ for(let i=0;i<8;i++) world.particles.push(new Particle(x,y,rnd(-120,120),rnd(-60,20),c)); if(world.players[0]?.mods?.regen){ world.players[0].hp=Math.min(world.players[0].stats.maxHp, world.players[0].hp + 0.2*world.players[0].mods.regen); } }
  function dot(x,y,r,c){ ctx.fillStyle=c; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
  function tri(c,fill){
    // prettier jet: body, wings, cockpit, engine glow
    c.save();
    // body
    c.fillStyle=fill; c.beginPath(); c.moveTo(0,-16); c.lineTo(12,10); c.lineTo(-12,10); c.closePath(); c.fill();
    // wings
    c.fillStyle='rgba(255,255,255,.08)'; c.beginPath(); c.moveTo(-12,6); c.lineTo(-24,12); c.lineTo(-12,10); c.closePath(); c.fill();
    c.beginPath(); c.moveTo(12,6); c.lineTo(24,12); c.lineTo(12,10); c.closePath(); c.fill();
    // cockpit
    c.fillStyle='rgba(255,255,255,.6)'; c.beginPath(); c.ellipse(0,-6,4,6,0,0,Math.PI*2); c.fill();
    // thruster glow
    const grad=c.createRadialGradient(0,12,0,0,14,10); grad.addColorStop(0,'rgba(255,255,255,.7)'); grad.addColorStop(1,'rgba(56,189,248,.0)'); c.fillStyle=grad; c.beginPath(); c.ellipse(0,14,6,10,0,0,Math.PI*2); c.fill();
    c.restore();
  }
  function collide(a,b){ const dx=a.x-b.x, dy=a.y-b.y; const rr=(a.r||0)+(b.r||0); return dx*dx+dy*dy < rr*rr; }

  // ===== Tiny Tests =====
  (function tests(){
    if (window.__voidSkiesTests) return; window.__voidSkiesTests=true;
    const A=(x,y,r)=>({x,y,r});
    console.assert(collide(A(0,0,1), A(3,0,1))===false, 'collide: far apart');
    console.assert(collide(A(0,0,2), A(3,0,2))===true,  'collide: overlap');
    console.assert(collide(A(0,0,2), A(4,0,2))===false, 'collide: edge-touch false');
    world.wave=1; beginWave(); console.assert(Spawner.left>0 && !world.boss, 'wave1 spawns enemies');
    // simulate watchdog safety by clearing left & boss
    Spawner.left=0; world.enemies.length=0; world.boss=null; Spawner.watchdog=2.1; spawnerStep(0); console.assert(Spawner.left>0 || world.boss, 'watchdog re-primes wave');
    world.wave=5; beginWave(); console.assert(Spawner.left===0 && world.boss, 'wave5 spawns boss');
  })();

  // ===== Main Loop =====
  // Restart controls
  if (restartBtn) restartBtn.addEventListener('click', ()=> startGame({twoPlayers:false}));
  addEventListener('keydown', e=>{ if((e.key==='r'||e.key==='R') && world.gameOver){ startGame({twoPlayers:false}); } });

  
  function loop(now){
    const dt=(now-last)/1000; last=now; acc+=dt;
    const stepMax=0.25; if(acc>stepMax) acc=stepMax;
    while(acc>=dtFixed){ if(gameState==='playing') stepSim(dtFixed); acc-=dtFixed; }
    render(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Touch helpers: tap to auto-fire briefly so mobile users can shoot without holding
  addEventListener('touchstart',()=>{ mouse.down=true; setTimeout(()=>mouse.down=false, 250); }, {passive:true});

  // Pause toggle
  addEventListener('keydown',e=>{ if(e.key==='p'||e.key==='P'){ if(gameState==='playing'){ gameState='paused'; show(pausePanel);} else if(gameState==='paused'){ gameState='playing'; hide(pausePanel);} }});
})();
</script>
</body>
</html>
