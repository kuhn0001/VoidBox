<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 98vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        
        /* Hide VS Code browser controls */
        .monaco-workbench .part.titlebar, 
        .vs-dark .monaco-workbench .part.titlebar,
        .titlebar,
        .browser-close-button,
        .browser-action-buttons,
        .monaco-action-bar {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            opacity: 0 !important;
        }

        .close-btn {
            position: absolute;
            top: 8px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 20px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 4px;
        }
        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Hide only the specific problematic close buttons */
        #closeScores {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        /* More aggressive hiding of browser UI */
        body {
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden;
        }
        
        /* Hide any top-level browser chrome */
        :root {
            --browser-chrome-height: 0px;
        }
        
    #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:0;}
    .stage{width:100vw; height:100svh; position:relative;display:grid;place-items:center;background:#000;border-radius:0;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
    canvas{background:transparent;border-radius:16px;touch-action:none;cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }
    #diagBox{position:absolute;left:8px;top:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:left;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s; font-family: 'Orbitron', 'Audiowide', ui-sans-serif;}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        
        .panel{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:rgba(26,0,34,.95);
            border:1px solid var(--accent);
            border-radius:16px;
            padding:12px;
            width:min(600px, 90vw);
            backdrop-filter:blur(12px);
            color:#ffddff;
            box-shadow:0 0 40px rgba(178,102,255,.3);
            z-index:100;
        }
        

        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }
        #shopPanel h2, #levelPanel h2, #scorePanel h2, #namePanel h2, #pilotPanel h2, #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }
        #shopPanel p, #levelPanel p, #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }
        #shopGrid, #scorePanel div {
            max-height: 60vh; 
            overflow-y: auto;
            padding-right: 8px;
        }
        .character-sheet-body {
            font-family: 'Orbitron', 'Audiowide', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.55;
            color: #f6ecff;
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 6px;
        }
        .character-sheet-body::-webkit-scrollbar {
            width: 6px;
        }
        .character-sheet-body::-webkit-scrollbar-thumb {
            background: rgba(189, 128, 255, 0.45);
            border-radius: 10px;
        }
        .intel-section {
            margin-bottom: 16px;
        }
        .intel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #f7d7ff;
            margin-bottom: 6px;
            opacity: 0.9;
        }
        .intel-summary {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(124, 62, 160, 0.22);
            border-left: 2px solid rgba(228, 189, 255, 0.55);
            padding: 8px 12px;
            border-radius: 6px;
        }
        .intel-summary-line {
            font-size: 11px;
            letter-spacing: 0.05em;
            color: #f3e3ff;
        }
        .intel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        .intel-cell {
            background: rgba(82, 34, 120, 0.32);
            border: 1px solid rgba(201, 146, 255, 0.35);
            border-radius: 10px;
            padding: 8px 10px 9px;
            box-shadow: inset 0 0 12px rgba(150, 70, 200, 0.25);
        }
        .intel-key {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: #dfc2ff;
            opacity: 0.82;
        }
        .intel-val {
            font-size: 14px;
            font-weight: 700;
            color: #f6ecff;
        }
        .intel-detail {
            font-size: 10px;
            color: #d5b9ff;
            opacity: 0.85;
            margin-top: 4px;
        }
        .intel-list {
            margin: 0;
            padding-left: 18px;
            font-size: 11px;
            color: #f3e3ff;
        }
        .intel-list li {
            margin-bottom: 4px;
        }
        .intel-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: rgba(66, 24, 110, 0.48);
            border: 1px solid rgba(205, 150, 255, 0.4);
            border-radius: 10px;
            overflow: hidden;
        }
        .intel-table thead {
            background: rgba(118, 58, 168, 0.55);
        }
        .intel-table th, .intel-table td {
            padding: 6px 8px;
            color: #f2e6ff;
            border-bottom: 1px solid rgba(205, 150, 255, 0.22);
            text-align: left;
        }
        .intel-table tr:last-child td {
            border-bottom: none;
        }
        .intel-table tr.active {
            background: rgba(151, 83, 214, 0.35);
        }
        .intel-table tr.inactive {
            opacity: 0.55;
        }
        .intel-subtitle {
            margin-top: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #f0d9ff;
        }
        .intel-note {
            font-size: 10px;
            color: #d4baff;
            opacity: 0.75;
            margin-top: 6px;
        }
        .forge-toolbar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            margin-bottom: 12px;
        }
        .forge-toolbar .mobile-toggle-container {
            flex: 1 1 auto;
        }
        .forge-toolbar-btn {
            background: linear-gradient(135deg, rgba(138, 70, 214, 0.85), rgba(84, 36, 140, 0.9));
            border: 1px solid rgba(214, 170, 255, 0.7);
            border-radius: 20px;
            padding: 6px 14px;
            font-size: 11px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #f8eaff;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }
        .forge-toolbar-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 14px rgba(210, 160, 255, 0.6);
        }
        .forge-toolbar-btn[aria-pressed="true"] {
            background: linear-gradient(135deg, rgba(167, 90, 240, 0.95), rgba(110, 48, 180, 0.95));
            box-shadow: 0 0 18px rgba(214, 170, 255, 0.7);
        }
        .grid{
            display:grid;
            gap:8px;
            grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
        }
        
        /* Character Sheet Panel */
        #characterSheetPanel {
            width: min(900px, 95vw);
            max-height: 85vh;
            overflow-y: auto;
        }
        
        /* Mech Forge Menu Panel */
        #mechForgeMenuPanel {
            width: min(600px, 90vw);
        }
        
        .forge-menu-section {
            margin-bottom: 24px;
        }
        
        .forge-menu-title {
            font-size: 16px;
            color: var(--accent);
            margin-bottom: 12px;
            text-align: center;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        
        .forge-menu-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: 1fr;
        }
        
        .forge-menu-btn {
            background: linear-gradient(135deg, rgba(150, 80, 255, 0.3), rgba(120, 60, 200, 0.4));
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 16px 20px;
            color: #ffddff;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .forge-menu-btn:hover {
            background: linear-gradient(135deg, rgba(180, 100, 255, 0.5), rgba(150, 80, 230, 0.6));
            box-shadow: 0 0 20px rgba(178, 102, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .forge-menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .forge-menu-desc {
            font-size: 11px;
            color: #ccaaff;
            margin-top: 4px;
            opacity: 0.8;
        }
        .hide{display:none!important}
        #belowBoard{width:min(98vw,var(--maxw));margin:50px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        
        .skill-card {
            background: radial-gradient(circle, rgba(51,0,68,1) 0%, rgba(51,0,68,0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        
        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }
        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }
        .skill-title{
            font-weight:700;
            color:#c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }
        .skill-desc{
            font-size:11px;
            color:#ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }

        .skill-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        .skill-card-node-pair {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            width: 100%;
        }

        #subclassPanel.skill-tree-active {
            width: min(900px, 95vw);
            max-height: 80vh;
            overflow-y: auto;
            padding: 20px 24px 28px;
        }

        #skillTree {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .skill-tree-title {
            font-size: 28px;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.24em;
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.8);
            text-align: center;
            margin: 0 auto 14px;
            max-width: 680px;
        }
        .skill-view-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 14px;
        }
        
        /* SKILL TREE - Portrait-oriented Icon Button System */
        .skill-track {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 26px;
            width: 100%;
        }
        .track-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        .skill-icon-button {
            position: relative;
            width: min(520px, 100%);
            min-height: 190px;
            cursor: pointer;
            border-radius: 16px;
            padding: 16px;
            display: flex;
            gap: 18px;
            align-items: stretch;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            border: 2px solid rgba(110, 70, 180, 0.6);
            background: radial-gradient(circle at 18% 22%, rgba(66, 18, 110, 0.95), rgba(24, 2, 40, 0.9));
            box-shadow: inset 0 0 18px rgba(122, 60, 190, 0.22);
        }
        .skill-icon-frame {
            flex: 0 0 clamp(160px, 48%, 220px);
            aspect-ratio: 3 / 4;
            border-radius: 14px;
            border: 1px solid rgba(202, 138, 255, 0.45);
            background: radial-gradient(circle at 40% 30%, rgba(120, 70, 200, 0.35), rgba(40, 10, 70, 0.4));
            box-shadow: inset 0 0 24px rgba(150, 80, 255, 0.35);
            display: grid;
            place-items: center;
            overflow: hidden;
        }
        .skill-icon-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease, filter 0.3s ease;
            border-radius: 12px;
        }
        .skill-icon-image.enhanced {
            filter: brightness(1.25) saturate(1.15) drop-shadow(0 0 12px rgba(255,215,0,0.8));
        }
        .skill-info-table {
            flex: 1 1 50%;
            display: grid;
            gap: 10px;
            background: rgba(82, 34, 120, 0.32);
            border: 1px solid rgba(201, 146, 255, 0.32);
            border-radius: 14px;
            padding: 14px 18px;
        }
        .skill-info-row {
            display: grid;
            grid-template-columns: minmax(86px, 30%) 1fr;
            gap: 12px;
            align-items: start;
        }
        .skill-info-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #e6ccff;
            opacity: 0.82;
        }
        .skill-info-value {
            font-size: 12px;
            color: #f5e8ff;
            line-height: 1.4;
        }
        .skill-info-note {
            font-size: 11px;
            color: #ffb3f7;
            opacity: 0.8;
            border-top: 1px solid rgba(201, 146, 255, 0.28);
            padding-top: 8px;
            margin-top: 6px;
        }
        .skill-track-connector {
            width: 3px;
            height: 38px;
            border-radius: 6px;
            background: linear-gradient(180deg, rgba(216, 176, 255, 0.7) 0%, rgba(125, 82, 200, 0.9) 100%);
            box-shadow: 0 0 12px rgba(180, 120, 255, 0.45);
        }
        .skill-view-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 4px;
            border-radius: 999px;
            background: rgba(46, 18, 78, 0.68);
            border: 1px solid rgba(190, 140, 255, 0.45);
            box-shadow: 0 0 16px rgba(150, 90, 220, 0.32);
            width: fit-content;
            min-width: 0;
        }
        .skill-view-toggle button {
            border: none;
            background: transparent;
            color: #cfc2ff;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            padding: 8px 14px;
            border-radius: 999px;
            cursor: pointer;
            transition: all 0.25s ease;
        }
        .skill-view-toggle button.active {
            background: linear-gradient(135deg, rgba(180, 120, 255, 0.8), rgba(110, 60, 200, 0.75));
            color: #1c0f31;
            box-shadow: 0 0 18px rgba(160, 110, 255, 0.55);
        }
        .skill-view-toggle button:focus-visible {
            outline: 2px solid rgba(255, 215, 0, 0.7);
            outline-offset: 2px;
        }
        .skill-grid[data-active-view="main"] .view-signature {
            display: none;
        }
        .skill-grid[data-active-view="main"] .view-main {
            display: flex;
        }
        .skill-grid[data-active-view="signature"] .view-main {
            display: none;
        }
        .skill-grid[data-active-view="signature"] .view-signature {
            display: flex;
        }
        .skill-status-heading {
            font-size: 16px;
            font-weight: 700;
            color: #f8d87f;
            letter-spacing: 0.08em;
        }
        .skill-status-heading.readonly {
            color: #ff9c6b;
        }
        .skill-status-body {
            font-size: 13px;
            color: #d8c9ff;
            margin-top: 6px;
            line-height: 1.4;
        }
        .skill-status-line {
            font-size: 12px;
            color: #b8a6ff;
            margin-top: 6px;
        }
        .skill-status-line strong {
            color: #f5e8ff;
        }
        .skill-hover-title {
            font-size: 15px;
            font-weight: 600;
            color: #ffe39f;
            letter-spacing: 0.06em;
        }
        .skill-hover-body {
            font-size: 13px;
            color: #ded2ff;
            margin-top: 6px;
            line-height: 1.5;
        }
        .skill-hover-note {
            font-size: 11px;
            color: #94ffd1;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
        }

        /* SKILL ICON BUTTON STATES */
        .skill-icon-button.available {
            border-color: rgba(102, 255, 178, 0.7);
            box-shadow: 0 0 24px rgba(102, 255, 178, 0.35);
        }
        .skill-icon-button.available .skill-info-table {
            border-color: rgba(120, 255, 210, 0.55);
            box-shadow: inset 0 0 18px rgba(120, 255, 210, 0.18);
        }
        .skill-icon-button.available:hover {
            border-color: rgba(140, 255, 210, 0.85);
            box-shadow: 0 0 32px rgba(120, 255, 200, 0.5);
            transform: translateY(-4px);
        }
        .skill-icon-button.available:hover .skill-icon-image {
            filter: brightness(1.2) saturate(1.1);
            transform: scale(1.02);
        }

        .skill-icon-button.active {
            border-color: rgba(255, 215, 0, 0.95);
            background: linear-gradient(135deg, rgba(255,215,0,0.16), rgba(140, 60, 200, 0.24));
            box-shadow: 0 0 26px rgba(255, 215, 0, 0.7), inset 0 0 22px rgba(255,255,255,0.12);
            animation: activeIconGlow 3s ease-in-out infinite;
        }
        .skill-icon-button.active .skill-icon-frame {
            border-color: rgba(255, 215, 0, 0.85);
            box-shadow: inset 0 0 26px rgba(255, 215, 0, 0.35);
        }
        .skill-icon-button.active .skill-icon-image {
            filter: brightness(1.35) saturate(1.2) drop-shadow(0 0 16px rgba(255,215,0,0.85));
        }
        .skill-icon-button.active .skill-info-table {
            border-color: rgba(255, 220, 120, 0.65);
            box-shadow: inset 0 0 24px rgba(255, 220, 120, 0.24);
        }

        .skill-icon-button.locked {
            border-color: rgba(70, 40, 120, 0.65);
            opacity: 0.65;
            cursor: not-allowed;
            filter: grayscale(0.4);
        }
        .skill-icon-button.locked .skill-info-table {
            background: rgba(38, 14, 68, 0.5);
            border-color: rgba(90, 50, 130, 0.35);
        }
        .skill-icon-button.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        /* CLASS ABILITY TRACK STYLING */
        .class-ability-track {
            position: relative;
            margin-left: 40px;
            padding: 20px;
            border-left: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 0 12px 12px 0;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(135, 206, 235, 0.05));
        }
        .class-ability-track .track-title {
            color: #FFD700;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        .class-ability-track .skill-icon-button + .skill-icon-button {
            margin-top: 18px;
        }
        .class-ability-solo {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6) !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.2)) !important;
        }
        .class-ability-solo.locked {
            opacity: 0.85;
            filter: none;
        }
        .class-ability-solo .skill-info-table {
            border-color: rgba(255, 223, 120, 0.8) !important;
            box-shadow: inset 0 0 26px rgba(255, 220, 130, 0.32) !important;
            background: rgba(80, 40, 0, 0.28);
        }
        .class-ability-solo:hover {
            border-color: #FFF700 !important;
            box-shadow: 0 0 36px rgba(255, 215, 0, 0.75) !important;
            transform: translateY(-5px) scale(1.04) !important;
        }
        .cross-ability {
            border-color: rgba(102, 255, 178, 0.6);
            box-shadow: 0 0 18px rgba(102, 255, 178, 0.3);
        }
        .cross-ability.available {
            border-color: rgba(125, 255, 200, 0.9);
            box-shadow: 0 0 28px rgba(125, 255, 200, 0.6);
        }
        .cross-ability .skill-info-table {
            border-color: rgba(120, 255, 210, 0.6);
        }
        @media (max-width: 640px) {
            .skill-row {
                gap: 24px;
            }
            .skill-icon-button {
                flex-direction: column;
                align-items: stretch;
                min-height: auto;
            }
            .skill-icon-frame {
                flex: 0 0 auto;
                width: 100%;
                max-width: 260px;
                margin: 0 auto 12px;
            }
            .skill-info-table {
                padding: 14px;
            }
            .skill-info-row {
                grid-template-columns: 1fr;
                gap: 6px;
            }
            .skill-info-label {
                font-size: 10px;
                letter-spacing: 0.12em;
            }
            .skill-track-connector {
                display: none;
            }
            .skill-view-toggle {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }
        }

        .skill-grid[data-active-view="signature"] .class-ability-track {
            margin-left: 0;
        }
        
        /* BEAUTIFUL GLOW ANIMATIONS */
        @keyframes activeIconGlow {
            0% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 215, 0, 1.0), inset 0 0 25px rgba(255,255,255,0.2), 0 0 50px rgba(135,206,235,0.3); }
            100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
        }
        
        /* Old skill node classes for compatibility */
        
        /* Beautiful Marble/Lightning Animations */
        @keyframes marbleSwirl {
            0% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
            25% { background: linear-gradient(225deg, #e6e6fa 0%, #f5f5dc 30%, #f8f8ff 60%, #dcdcdc 100%); }
            50% { background: linear-gradient(315deg, #dcdcdc 0%, #f8f8ff 30%, #f5f5dc 60%, #e6e6fa 100%); }
            75% { background: linear-gradient(45deg, #f5f5dc 0%, #dcdcdc 30%, #e6e6fa 60%, #f8f8ff 100%); }
            100% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
        }
        
        @keyframes lightningPulse {
            0% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
            50% { box-shadow: 0 0 15px rgba(255,215,0,0.8), inset 0 0 12px rgba(255,255,255,0.6), 0 0 25px rgba(135,206,235,0.4); }
            100% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
        }
        .skill-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .skill-node.active, .skill-combo-node.active {
            border-color: #FFD700;
            background: #2a2a4e;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        .skill-node.locked, .skill-combo-node.locked {
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skill-combo-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .skill-description {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 18px auto 0;
            text-align: center;
            min-height: 40px;
            color: #ffddff;
            font-size: 12px;
            max-width: 680px;
        }
        .ability-hint {
            font-size: 10px;
            color: #87CEEB;
            text-align: center;
            margin-top: 6px;
            font-style: italic;
            text-shadow: 0 0 4px rgba(135, 206, 235, 0.5);
        }
        .ability-icon {
            font-size: 12px;
            margin: 0 2px;
            display: inline-block;
            animation: pulse-glow 2s infinite;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }
        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }
        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }
        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn{
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.4;
            transition: opacity 0.3s ease-in-out;
        }
        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }
        
        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }
        #bottom-right-controls > .fixed-btn {
            position: static;
        }

        #menuBtn, #fsEnterBtn, #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }
        #shopBtn.mech-forge-pulse {
            animation: mechForgePulse 1.2s ease-in-out infinite;
            box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25);
        }
        #shopBtn.mech-forge-pulse::after {
            content: "";
            position: absolute;
            inset: -6px;
            border-radius: 18px;
            border: 2px solid rgba(255, 215, 0, 0.65);
            pointer-events: none;
            animation: mechForgeRing 1.2s ease-in-out infinite;
        }
        #pauseBtn {
            top: 50%;
            right: 15px; 
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif; box-sizing: border-box;}
        
        #abilityBar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 6; pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }
        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }
        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }
        
        .shop-item-attack { border-color: #00bfff; }
        .shop-item-health { border-color: #00ff00; }
        .shop-item-utility { border-color: #ffd700; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
            50% { box-shadow: 0 0 35px rgba(102, 255, 178, 1); }
            100% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
        }
        @keyframes mechForgePulse {
            0% { transform: scale(1); box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25); }
            50% { transform: scale(1.03); box-shadow: 0 0 28px rgba(255, 215, 0, 0.75), 0 0 45px rgba(255, 140, 0, 0.35); }
            100% { transform: scale(1); box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25); }
        }
        @keyframes mechForgeRing {
            0% { transform: scale(0.92); opacity: 0.9; }
            70% { transform: scale(1.1); opacity: 0.3; }
            100% { transform: scale(1.15); opacity: 0; }
        }
        @keyframes pulse-glow-ability {
            0% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
            50% { box-shadow: 0 0 20px rgba(178, 102, 255, .8); }
            100% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
        }
        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(500px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
        
        /* Purple gradient classes for different brightness levels */
        .bright {
            color: #e6ccff;
            text-shadow: 0 0 5px #cc99ff, 0 0 10px #cc99ff;
        }

        .medium {
            color: #b366ff;
            text-shadow: 0 0 3px #9933ff;
        }

        .dim {
            color: #6600cc;
            text-shadow: 0 0 2px #6600cc;
        }

        .faded {
            color: #330066;
            opacity: 0.7;
        }

        .very-faded {
            color: #1a0033;
            opacity: 0.4;
        }

        /* Teleport Tutorial Popup */
        #teleportTutorialPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(102,0,204,0.2) 100%);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(204,153,255,0.4);
        }

        #teleportTutorialPanel h2 {
            color: var(--accent);
            font-family: 'Orbitron';
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--accent);
        }

        .teleport-instruction {
            font-size: 18px;
            color: #ffddff;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .teleport-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 5px var(--accent));
        }

        /* --- MOBILE JOYSTICK & BUTTON CONTROLS --- */
        .mobile-control {
            position: fixed;
            z-index: 20;
            opacity: 0.6;
            display: none; /* Hidden by default */
        }

        body.mobile-controls-active .mobile-control {
            display: block; /* Shown when body class is active */
        }

        #joystick-container {
            bottom: 90px;
            left: 45px;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(50, 0, 70, 0.5);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
        }

        #joystick-stick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ffddff, var(--accent));
            border-radius: 50%;
            pointer-events: none; /* Pass touches through to the base */
        }

        #ability-button-container {
            bottom: 100px;
            right: 70px;
        }

        #ability-button {
            width: 90px;
            height: 90px;
            background: rgba(150, 80, 255, 0.3);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(178, 102, 255, .5);
        }

        #ability-icon {
            width: 70px;
            height: 70px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            filter: drop-shadow(0 0 5px white);
        }

        /* --- TOGGLE SWITCH IN MECH FORGE --- */
        .mobile-toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #330044;
            border: 1px solid var(--accent);
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent2);
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }


        
    </style>
</head>
<body>
    <!-- Asset Loading Screen DISABLED FOR PERFORMANCE TESTING -->
    <div id="loadingScreen" style="
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2a 50%, #0a0a1a 100%); 
        display: none; 
        flex-direction: column; 
        align-items: center; 
        justify-content: center; 
        z-index: 9999;
        font-family: 'Orbitron', monospace;
        color: #b266ff;
    ">
        <div style="text-align: center; margin-bottom: 40px;">
            <h1 style="font-size: 3em; margin: 0; text-shadow: 0 0 20px #b266ff; animation: pulse 2s ease-in-out infinite;">
                âš¡ VOID SKIES âš¡
            </h1>
            <p style="font-size: 1.2em; margin: 10px 0; color: #cc99ff;">
                Initializing Combat Systems...
            </p>
        </div>
        
        <div style="width: 400px; max-width: 80vw; margin-bottom: 20px;">
            <div style="background: rgba(0,0,0,0.5); border: 2px solid #b266ff; border-radius: 10px; padding: 4px;">
                <div id="loadingBar" style="
                    height: 20px; 
                    background: linear-gradient(90deg, #b266ff, #7a49cc); 
                    border-radius: 6px; 
                    width: 0%; 
                    transition: width 0.3s ease;
                    box-shadow: 0 0 10px #b266ff;
                "></div>
            </div>
            <div id="loadingText" style="text-align: center; margin-top: 10px; font-size: 0.9em; color: #cc99ff;">
                Loading Assets... 0%
            </div>
        </div>
        
        <div id="loadingDetails" style="
            font-size: 0.8em; 
            color: #8866bb; 
            text-align: center; 
            min-height: 20px;
        ">
            Scanning combat protocols...
        </div>
        
        <style>
            @keyframes pulse {
                0%, 100% { text-shadow: 0 0 20px #b266ff; }
                50% { text-shadow: 0 0 30px #b266ff, 0 0 40px #b266ff; }
            }
        </style>
    </div>
    
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide">
                        <div class="hud-title">â—¢ SYSTEMS ONLINE â—£</div>
                        <div id="powerupList"></div>
                    </div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card">
                            <div class="hud-title">â—¢ VOID SKIES â—£</div>
                            <div style="text-align:center">
                                    SCORE <b id="scoreNum">0</b> â€¢ Gold ðŸ’° <b id="goldNum" style="color:#FFD700;font-size:1.2em">0</b>
                            </div>
                        </div>
                        <div id="hudPilotContent" class="hud-card">
                            <div class="hud-title" id="pilotTitle">â—¢ UNIDENTIFIED â—£</div>
                            <div style="display:flex;justify-content:space-between;font-size:10px;margin:4px 0 6px 0;">
                                <div>WAVE <b id="waveNum">1</b></div>
                                <div>KILLS <b id="killsNum">0</b></div>
                                <div>LEVEL <b id="levelNum">1</b></div>
                            </div>
                            <div class="bar" id="hpBar"><span id="hpBarFill" style="width:100%"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="hpText">HP: 100 / 100</div>
                            <div class="bar" id="beefShieldBar" style="margin-top:2px;display:none"><span id="beefShieldBarFill" style="background:linear-gradient(90deg,#ff8c00,#ff4500)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="beefShieldText"></div>
                            <div class="bar" id="shieldBar" style="margin-top:2px;display:none"><span id="shieldBarFill" style="background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="shieldText"></div>
                        </div>
                        <div id="hudBossContent" class="hud-card hide">
                            <div class="hud-title" id="bossTitle">âš¡ BOSS âš¡</div>
                            <div class="bar"><span id="bossBarFill" style="width:100%"></span></div>
                        </div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide">
                        <div class="hud-title">â—¢ EQUIPMENT â—£</div>
                        <div id="equipmentList"></div>
                    </div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <table style="font-size:10px; color:var(--fg); background:rgba(0,0,0,0.7); padding:8px; border-radius:8px; border-spacing:8px 2px;">
                        <tr><td>v3.8.0</td><td>FPS:</td><td><span id="fps">â€”</span></td></tr>

                    </table>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">ðŸš€ PILOT LOST ðŸš€</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <!-- <button id="storyBtn" type="button">i</button> -->
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">Cybernetic heavy assault unit with adaptive bio-armor that responds to hostile engagement. Neural implants trigger reflexive counterstrike protocols when threatened.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN"></div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">Former corporate military contractor with black-market ordnance mods. Tactical AI systems provide precision strike capabilities and explosive payload optimization.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="voidmancer">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER"></div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">Quantum-phase enhanced operative with experimental void-fold technology. Neural interfaces allow instantaneous spatial displacement through dimensional rifts.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                     <div id="subclassPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                        </div>

                    </div>
                    <div id="storyPanel" class="panel hide">
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                        Mammalian life developed specialized spacecraft to venture within and colonize the resources of the primitive creatures.<br><br>
                        The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">ðŸ’€ CALLSIGN ðŸ’€</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">ðŸ† Aces of the Void ðŸ†</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);">âš¡ AUGMENTATION PROTOCOL âš¡</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <button type="button" class="close-btn" id="closeShopTopBtn">Ã—</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">âš¡ MECH FORGE âš¡</h2>
                        <p style="color:#ffddff">Gold ðŸ’° <span id="shopgold" style="color:#FFD700;font-size:1.2em">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="mechForgeMenuPanel" class="panel hide">
                        <button type="button" class="close-btn" id="closeMechForgeMenuBtn">Ã—</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">âš¡ MECH FORGE MENU âš¡</h2>
                        
                        <div class="forge-menu-section">
                            <div class="forge-menu-title">Controls</div>
                            <div class="mobile-toggle-container">
                                <span>Mobile Controls</span>
                                <label class="switch">
                                    <input type="checkbox" id="mobileControlsToggleMenu">
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="forge-menu-section">
                            <div class="forge-menu-title">Systems</div>
                            <div class="forge-menu-grid">
                                <button id="openShopFromMenu" class="forge-menu-btn" type="button">
                                    ðŸ’° MECH FORGE
                                    <div class="forge-menu-desc">Upgrade systems and equipment</div>
                                </button>
                                <button id="openCharacterSheet" class="forge-menu-btn" type="button">
                                    ðŸ“Š CHARACTER SHEET
                                    <div class="forge-menu-desc">View pilot stats and progression</div>
                                </button>
                                <button id="openSkillTreeReadonly" class="forge-menu-btn" type="button">
                                    ðŸŒŸ SKILL TREE
                                    <div class="forge-menu-desc">Review specialization progress</div>
                                </button>
                            </div>
                        </div>
                        
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="closeMechForgeMenu" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="characterSheetPanel" class="panel hide">
                        <button type="button" class="close-btn" id="closeCharacterSheetBtn">Ã—</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">ðŸ“Š CHARACTER SHEET</h2>
                        <div id="characterSheetBody" class="character-sheet-body" aria-live="polite"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeCharacterSheet" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="teleportTutorialPanel" class="panel hide">
                        <h2>âš¡ VOID-FOLD PROTOCOL âš¡</h2>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">ðŸ–±ï¸</span>
                            <span>Right-click to teleport</span>
                        </div>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">ðŸ‘†ðŸ‘†</span>
                            <span>Double-tap to teleport (mobile)</span>
                        </div>
                        <div style="margin-top: 30px;">
                            <p style="color: #ccaaff; font-size: 14px; margin-bottom: 20px;">
                                Quantum displacement damages enemies at origin point.<br>
                                Use strategically to escape danger and deal damage.
                            </p>
                            <button id="closeTeleportTutorial" class="btn" type="button">GOT IT</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>âš¡ Aces of the Void âš¡</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>
    <audio id="audioCharge" src="charge.m4a" preload="auto"></audio>
    <audio id="audioBeefCharge" src="beefcharge.m4a" preload="auto"></audio>
    <audio id="audioEpicHorn" src="epichorntrimmed.m4a" preload="auto"></audio>
    <audio id="audioCluster" src="cluster.mp3" preload="auto"></audio>
    <audio id="audioThunder" src="thunder.mp3" preload="auto"></audio>
    <audio id="audioShaoKahn" src="shao_kahn.m4a" preload="auto"></audio>
    <audio id="audioStarGun" src="stargun.m4a" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">âš¡ MECH FORGE ðŸ’°</button>
        <button id="menuBtn" class="fixed-btn" type="button">ðŸ† TOP PILOTS</button>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

    <div id="joystick-container" class="mobile-control">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
    <div id="ability-button-container" class="mobile-control">
        <div id="ability-button">
            <div id="ability-icon"></div>
        </div>
    </div>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://organisms-reserve-handled-tone.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => {
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height),
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    
    // Simple resize handling without bounds caching
    window.addEventListener('resize', () => {
        // Mark joystick bounds for update too
        if (typeof joystickState !== 'undefined') {
            joystickState.boundsNeedUpdate = true;
        }
    }, { passive: true });
    
    const pointFromEvent = (e) => {
        const r = cvs.getBoundingClientRect();
        let touch = e;
        if (e.changedTouches && e.changedTouches.length > 0) {
            touch = e.changedTouches[0];
        } else if (e.touches && e.touches.length > 0) {
            touch = e.touches[0];
        }
        const cx = touch.clientX;
        const cy = touch.clientY;
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
    };

    // --- MOBILE JOYSTICK & ABILITY BUTTON SETUP ---
    const joystick = {
        base: q('joystick-base'),
        stick: q('joystick-stick'),
        container: q('joystick-container'),
        abilityButton: q('ability-button'),
        abilityIcon: q('ability-icon')
    };

    const joystickState = {
        active: false,
        touchId: null,
        baseRect: null,
        input: { x: 0, y: 0 }, // Normalized vector for player movement
        cachedBaseRect: null,
        boundsNeedUpdate: true
    };

    // Mobile device detection
    function isMobileDevice() {
        return window.innerWidth <= 768 || 
               'ontouchstart' in window || 
               navigator.maxTouchPoints > 0 || 
               /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    function setupMobileControls() {
        // Only set up joystick if elements exist
        if (joystick.base) {
            joystick.base.addEventListener('touchstart', handleJoystickStart, { passive: false });
            document.addEventListener('touchmove', handleJoystickMove, { passive: false });
            document.addEventListener('touchend', handleJoystickEnd, { passive: false });
            document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
        }

        // Only set up ability button if it exists
        if (joystick.abilityButton) {
            joystick.abilityButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (typeof handleAbilityPress === 'function') {
                    handleAbilityPress();
                }
            }, { passive: false });
        }

        // Load saved mobile controls preference
        try {
            if (localStorage.getItem('mobileControlsEnabled') === 'true') {
                document.body.classList.add('mobile-controls-active');
            }
        } catch(e) {
            // Ignore localStorage errors
        }
    }

    function handleJoystickStart(e) {
        e.preventDefault();
        if (joystickState.active) return;
        const touch = e.changedTouches[0];
        joystickState.active = true;
        joystickState.touchId = touch.identifier;
        
        // Cache joystick bounds to avoid layout calculations
        if (joystickState.boundsNeedUpdate || !joystickState.cachedBaseRect) {
            joystickState.cachedBaseRect = joystick.base.getBoundingClientRect();
            joystickState.boundsNeedUpdate = false;
        }
        joystickState.baseRect = joystickState.cachedBaseRect;
        
        handleJoystickMove(e); // Process initial position
    }

    function handleJoystickMove(e) {
        if (!joystickState.active) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
        if (!touch) return;

        const baseCenterX = joystickState.baseRect.left + joystickState.baseRect.width / 2;
        const baseCenterY = joystickState.baseRect.top + joystickState.baseRect.height / 2;
        
        let dx = touch.clientX - baseCenterX;
        let dy = touch.clientY - baseCenterY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const maxDist = joystickState.baseRect.width / 4; // Stick can move 1/4 of the base width from center

        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }

        joystick.stick.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickState.input.x = dx / maxDist;
        joystickState.input.y = dy / maxDist;
    }

    function handleJoystickEnd(e) {
        const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
        if (!touch) return;

        joystickState.active = false;
        joystickState.touchId = null;
        joystick.stick.style.transform = `translate(0, 0)`;
        joystickState.input = { x: 0, y: 0 };
    }

    function handleAbilityPress() {
        if (store.isPaused || store.isGameOver) return;
        const p = store.player;

        switch(p.pilotGenome) {
            case 'voidmancer':
                // Blink in the direction of joystick input, or straight ahead if idle
                const targetAngle = Math.atan2(joystickState.input.y, joystickState.input.x);
                const targetDist = 200; // Blink distance
                const target = {
                    x: p.x + (joystickState.input.x !== 0 ? Math.cos(targetAngle) * targetDist : 0),
                    y: p.y + (joystickState.input.y !== 0 ? Math.sin(targetAngle) * targetDist : p.y - targetDist)
                };
                tryVoidStep(p, target);
                break;
            case 'beef':
                // Manually trigger the charge ability
                p.isRequestingCharge = true; // A flag for the stepPlayer function
                break;
            default:
                // Default to grenade for other classes
                useGrenade();
                break;
        }
    }

    function updateAbilityButtonIcon() {
        const p = store.player;
        let iconUrl = '';

        // Determine icon based on class and subclass
        switch(p.pilotGenome) {
            case 'beef':
                iconUrl = p.subclass === 'marauder' ? 'marauder.png' : 'jug2.png';
                break;
            case 'voidmancer':
                iconUrl = p.subclass === 'phasestriker' ? 'phase.png' : 'storm.png';
                break;
            default:
                iconUrl = 'https://i.imgur.com/example.png'; // Placeholder for Grenade Icon
                break;
        }
        joystick.abilityIcon.style.backgroundImage = `url('${iconUrl}')`;
    }


    // --- NEW FLAME PARTICLE CLASS ---
class FlameParticle {
    constructor(x, y, attachedEnemy = null) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 40; // Less horizontal spread
        this.vy = -20 - Math.random() * 30; // Slower upward drift
        this.life = 8.4 + Math.random() * 5.6; // 40% longer: 8.4-14 seconds (was 6-10)
        this.maxLife = this.life;
        this.visualLife = this.life * 1.5; // Visual effect lasts 50% longer than mechanics
        this.maxVisualLife = this.visualLife;
        this.size = 8 + Math.random() * 8; // Smaller, more varied sizes
        this.attachedEnemy = attachedEnemy;
        this.damage = 0.45;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.5 + Math.random() * 1;
        this.heat = 0.8 + Math.random() * 0.2; // Start hot
        this.flickerOffset = Math.random() * 1000;
        this.baseSize = this.size;
        this.gravity = 15; // Slight downward pull for realistic behavior
        this.isDying = false;
    }

    update(dt) {
        this.life -= dt;
        this.visualLife -= dt;
        if (this.visualLife <= 0) return false; // Remove particle when visual effect ends

        // Physics - only apply when mechanically active
        if (this.life > 0) {
            this.vy += this.gravity * dt;
            this.vy -= 25 * dt;
            this.x += this.vx * dt;
            this.y += this.vy * dt;

            // Air resistance
            this.vx *= 0.98;
            this.vy *= 0.98;

            // Wobble
            this.wobble += this.wobbleSpeed * dt;
            this.x += Math.sin(this.wobble) * 8 * dt;
        }

        // Heat and void effect - based on VISUAL life for slower fade
        const visualLifeRatio = this.visualLife / this.maxVisualLife;
        this.heat = Math.max(0.2, visualLifeRatio * 0.8); // Minimum heat to avoid pure transparency

        // Size changes - based on visual life for slower shrinking
        if (visualLifeRatio > 0.7) {
            this.size = this.baseSize * (1 + (1 - visualLifeRatio) * 2); // Grow when young
        } else {
            this.size = Math.max(this.baseSize * 0.5, this.baseSize * visualLifeRatio); // Don't shrink below 50% of base
        }

        this.isDying = visualLifeRatio < 0.3;
        return true;
    }

    draw() {
        if (this.visualLife <= 0 || this.size <= 0) return;
        if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;

        const alpha = this.heat;
        
        // Simple flame with just 3 circles - no crackling, no sparkles
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Outer glow - simple and clean
    ctx.fillStyle = `rgba(255, 140, 20, ${alpha * 0.18})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 1.2, 0, 6.283185);
        ctx.fill();
        
        // Middle flame
    ctx.fillStyle = `rgba(255, 100, 30, ${alpha * 0.38})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.7, 0, 6.283185);
        ctx.fill();
        
        // Core flame
    ctx.fillStyle = `rgba(255, 215, 120, ${alpha * 0.55})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.3, 0, 6.283185);
        ctx.fill();
        
        ctx.restore(); // Reset blending mode
    }
}

// Simple particle creation function
function createParticle(x, y, vx, vy, color, life) {
    return {
        x: x,
        y: y,
        vx: vx,
        vy: vy,
        life: life,
        maxLife: life,
        color: color,
        size: 1
    };
}


    cvs.addEventListener('mousemove', (e) => { 
        try { 
            const p = pointFromEvent(e); 
            mouse.x = p.x; 
            mouse.y = p.y; 
        } catch(err) { 
            console.error('Mouse move error:', err); 
        }
    }, { passive: true });
    cvs.addEventListener('touchstart', (e) => { 
        try { 
            const p = pointFromEvent(e); 
            mouse.x = p.x; 
            mouse.y = p.y; 
            e.preventDefault(); 
        } catch(err) { 
            console.error('Touch start error:', err); 
        }
    }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { 
        try { 
            const p = pointFromEvent(e); 
            mouse.x = p.x; 
            mouse.y = p.y; 
            e.preventDefault(); 
        } catch(err) { 
            console.error('Touch move error:', err); 
        }
    }, { passive: false });
    
    // --- AUDIO ---
    const bgm = q('bgmAudio');
    const sounds = {
        explosion: q('audioExplosion'),
        horn: q('audioHorn'),
        hit: q('audioHit'),
        trap: q('audioTrap'),
        dogs: q('audioDogs'),
        charge: q('audioCharge'),
        beefCharge: q('audioBeefCharge'),
        epicHorn: q('audioEpicHorn'),
        cluster: q('audioCluster'),
        thunder: q('audioThunder'),
        shao_kahn: q('audioShaoKahn'),
        stargun: q('audioStarGun')
    };
    let lastExplosionSoundTime = 0;
    let lastBossHitSoundTime = 0;
    let lastClusterSoundTime = 0;
    
    function playSound(name) {
        const audio = sounds[name];
        if (!audio) return;
        const now = performance.now();
        if (name === 'explosion') {
            if (now - lastExplosionSoundTime < 50) return;
            lastExplosionSoundTime = now;
        }
        if (name === 'cluster') {
            if (now - lastClusterSoundTime < 150) return; // Increased from 60ms to 150ms
            lastClusterSoundTime = now;
        }
        if (name === 'hit') {
            if (now - lastBossHitSoundTime < 100) return;
            lastBossHitSoundTime = now;
        }
        audio.currentTime = 0;
        audio.play().catch(e => {});
    }


    // --- GAME STATE & DATA ---
    const player_initial_state = {
        x: W / 2, y: H * 0.8, r: 14, hp: 50, hpMax: 50, fireT: 0, speed: 380, dmgMult: 1.2, fireRate: 0.16,
        vampirism: 0, shield: 0, shieldMax: 0, multishot: 2, isInvincible: false, piercing: 0, explosive: false,
    hasShieldBubble: false, powerupTimers: {},
    swirlShots: false, attackSpeedStacks: 0,
    upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0, launcher: 0, lazarus_beam: 0, gravity_well: 0, star_cannon: 0 },
        grenades: 0, hasVoidBeam: false, voidBeamCooldown: 0,
        hasLazarusBeam: false, lazarusBeamCooldown: 0,
        hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 0, vampirismLevel: 0, flamethrowerLevel: 0,
        flamethrowerT: 0, // Separate timer for lava chunks, unaffected by overclock
        // Shield recharge delay system
        shieldRecharging: false,
        shieldRechargeDelay: 0,
        shieldRechargeDelayMax: 2.0,
        // Rocketman afterburner system
        afterburnerActive: false,
        afterburnerTimer: 0,
        afterburnerMaxDuration: 2.0,
        afterburnerParticleTimer: 0,
    starCannonLevel: 0, starCannonTimer: 0, starCannonIcemanSupport: false,
        luckBoost: 0, magnetRadius: 0, hasIceman: false, hasBeefClone: false, critChance: 0.02, critDamage: 1.85,
        pilotGenome: null, missileVolley: 2,
        hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
        rearMultishot: 0, addFrontNext: true,
    flameWallCooldown: 0,
    flameWallCooldownMax: 10,
    flameWallCharge: 0,
    flameWallInitialized: false,
    flameWallActiveT: 0,
    beefChargeState: 'ready', beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 1, beefMaxCharges: 1,
    beefChargePlan: null, beefChargeSegmentIndex: 0, beefImpactDelay: 0, beefLastImpact: null, beefQueuedCharge: null,
    beefDoubleCharge: false, beefBigExplosion: false, // New skill tree abilities
    beefChainMode: false, // Chain jumping system for marauder
        hasChainLightning: false, chainLightningCooldown: 0, stormstrikerLevel: 0, lightningAlternate: false, lightningCycleIndex: 0, chainLightningDamage: 1.0,
        phasestRikerLevel: 0, voidLaserRampTime: 0, voidLaserLastTarget: null,
        wiperLasers: false, wiperLaser1Angle: 0, wiperLaser2Angle: Math.PI, wiperLaserSpeed: 1.5, wiperLaserDamageTimer: 0,
    subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false,
    hasBlink: false, autoBlinkEnabled: false, autoBlinkRange: 0, autoBlinkLookahead: 0.45, autoBlinkLastTrigger: 0,
    isBlinkSlashing: false,
        enhancedClusters: false, enhancedPierce: false, hasStormcaller: false, hasPhasestriker: false,
        // Void caller enhanced options
        hasDoubleStorm: false, hasHybridVoid: false, hasImpactPhase: false,
        // Skill tree progress
        skillPoints: 0, skillPointsSpent: 0, skillTree: { juggernaut: false, marauder: false, double_charge: false, big_explosion: false, triple_charge: false },
        clusterSoundCounter: 0,
        // EMP nova effects
        empDisabled: false, empDisabledTimer: 0
    };
    
    class Pool {
        constructor(createFn, resetFn) {
            this.createFn = createFn;
            this.resetFn = resetFn;
            this.available = [];
        }

        prefill(count) {
            for (let i = 0; i < count; i++) {
                this.available.push(this.createFn());
            }
        }

        get() {
            const item = this.available.pop() || this.createFn();
            if (this.resetFn) this.resetFn(item);
            return item;
        }

        release(item) {
            if (this.resetFn) this.resetFn(item);
            this.available.push(item);
        }
    }

    function resetBulletState(bullet) {
        bullet.x = 0;
        bullet.y = 0;
        bullet.vx = 0;
        bullet.vy = 0;
        bullet.r = 3;
        bullet.col = "#b266ff";
        bullet.dmg = 0;
        bullet.pierce = 0;
        bullet.explosive = false;
        bullet.dead = false;
        bullet.life = undefined;
        bullet.fadeInTime = undefined;
        bullet.spawnTime = undefined;
        bullet.isSwirl = false;
        bullet.isFlame = false;
        bullet.isIceman = false;
        bullet.isDrone = false;
        bullet.isLavaChunk = false;
        bullet.isLevelUpPulse = false;
        bullet.gravity = undefined;
        bullet.target = undefined;
        bullet.particles = null;
        bullet.particleSpawnT = 0;
    }

    function createBullet() {
        const bullet = {};
        resetBulletState(bullet);
        return bullet;
    }

    const bulletPool = new Pool(createBullet, resetBulletState);
    bulletPool.prefill(100);

    const STAR_CANNON_COOLDOWN = 7;
    const STAR_CANNON_SPEED = 420;
    const STAR_CANNON_DAMAGE = 220;
    const STAR_CANNON_SIZE = 20;
    const STAR_CANNON_HITBOX_SCALE = 1.0;
    const STAR_CANNON_CLONE_DELAY = 0.35;
    const STAR_CANNON_ICEMAN_DAMAGE_SCALE = 0.3;

    const initialTelemetryEnabled = (() => {
        try {
            return !!(window.localStorage && window.localStorage.getItem('voidTelemetry') === '1');
        } catch (err) {
            return false;
        }
    })();

    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        isDamageOff: false,
        savedPlayerState: null,
        world: { 
            wave: 1, 
            score: 0, 
            gold: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0,
            waveTransitionTimer: null, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0,
            collarTargetStacks: 0,
            collarTargetStacks: 0,
            lateGameDamageScaling: 1,
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            isLowHealth: false,
            lastThreatScale: 1,
            lastSpawnOverflow: 0,
            lastPlannedSpawnCount: 0,
            lastSpawnCount: 0,
            lastSpawnFallback: false,
            lastSpawnQueueLength: 0,
            lastSpawnTempo: 0,
            firstBossOrbsGifted: false,
            mechForgeGoldTriggered: false,
            mechForgePulseTimeout: null
        },
        player: { ...player_initial_state },
    boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], shadowHounds: [], missiles: [], lasers: [], mines: [], activeEffects: [], starProjectiles: [], pendingStarClones: [],
        lastBossSnapshot: null,
        lastBossDefeatId: null,
        flameParticles: [],
        lightningBolts: [],
        empNovas: [],
        mechPuddles: [], // Hazardous puddles left by mech tank attacks
        poisonPuddles: [],
        goldenOrbs: [],
        shadowEchoes: [],
        championMinions: [],
        playerChampion: null,
        shadowChampionId: null,
        shadowChampionDefeated: false,
        shadowChampionTokenDropped: false,
        shadowChampionLastPos: null,
        _enemySpatial: {
            cellSize: 160,
            buckets: new Map(),
            usedKeys: []
        },
            iceman: null,
        beefClone: null,
        waveSpawnQueue: [],
            pendingSpawnCount: 0,
        vulnerabilityEvents: [],
    // Object pools for performance optimization
    bulletPool: null,
        eBulletPool: [],
        effectPool: [],
        tempFlamePool: [], // For simple flame particles
        _startTs: performance.now(),
        cheatInvincibilityCooldown: 0,
        cheatDogHealCooldown: 0,
        heartbeatT: 0,
        cheatsUsed: false,
        telemetryEnabled: initialTelemetryEnabled
    };

    // --- OBJECT POOLING SYSTEM ---
    store.bulletPool = bulletPool;

    function spawnBullet(props = {}) {
        const bullet = bulletPool.get();
        Object.assign(bullet, props);
        bullet.dead = false;
        if (bullet.isFlame && !Array.isArray(bullet.particles)) {
            bullet.particles = [];
        }
        store.bullets.push(bullet);
        return bullet;
    }

    function getEBulletFromPool(props = {}) {
        let bullet;
        if (store.eBulletPool.length > 0) {
            bullet = store.eBulletPool.pop();
            // Reset all properties to default
            Object.assign(bullet, {
                x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                dmg: 0, dead: false, life: undefined,
                fadeInTime: undefined, spawnTime: undefined,
                bounceCount: 0, maxBounces: 0, type: undefined
            });
        } else {
            bullet = {
                x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                dmg: 0, dead: false
            };
        }
        
        // Apply custom properties
        Object.assign(bullet, props);
        return bullet;
    }
    
    function returnEBulletToPool(bullet) {
        if (store.eBulletPool.length < 1000) { // Cap pool size
            store.eBulletPool.push(bullet);
        }
    }

    // PERFORMANCE: Effect pooling for createEffect() calls
    function getEffectFromPool(type, x, y, extra) {
        let effect;
        if (store.effectPool.length > 0) {
            effect = store.effectPool.pop();
            effect.type = type;
            effect.x = x;
            effect.y = y;
            effect.extra = extra;
            effect.isActive = true;
            effect.dead = false;
            effect.birth = performance.now();
        } else {
            effect = createEffect(type, x, y, extra);
        }
        return effect;
    }

    function returnEffectToPool(effect) {
        if (store.effectPool.length < 50) { // Limit pool size
            effect.isActive = false;
            effect.dead = true;
            store.effectPool.push(effect);
        }
    }

    // PERFORMANCE: Simple flame particle pooling
    function getTempFlameFromPool() {
        if (store.tempFlamePool.length > 0) {
            return store.tempFlamePool.pop();
        }
        return {
            x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, dead: false
        };
    }

    function returnTempFlameToPool(flame) {
        if (store.tempFlamePool.length < 100) {
            flame.dead = true;
            store.tempFlamePool.push(flame);
        }
    }

    const ENEMY_SPATIAL_KEY_MASK = 0xffff;

    function computeEnemySpatialKey(cellX, cellY) {
        return ((cellX & ENEMY_SPATIAL_KEY_MASK) << 16) | (cellY & ENEMY_SPATIAL_KEY_MASK);
    }

    function rebuildEnemySpatialIndex() {
        const spatial = store._enemySpatial;
        if (!spatial) return;

        const { buckets, usedKeys, cellSize } = spatial;

        for (let i = 0; i < usedKeys.length; i++) {
            const key = usedKeys[i];
            const bucket = buckets.get(key);
            if (bucket) {
                bucket.length = 0;
            }
        }
        usedKeys.length = 0;

        const enemies = store.enemies;
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            if (!enemy || enemy.dead) continue;
            const cellX = Math.floor(enemy.x / cellSize);
            const cellY = Math.floor(enemy.y / cellSize);
            const key = computeEnemySpatialKey(cellX, cellY);
            let bucket = buckets.get(key);
            if (!bucket) {
                bucket = [];
                buckets.set(key, bucket);
            }
            bucket.push(enemy);
            if (bucket.length === 1) {
                usedKeys.push(key);
            }
        }
    }

    function forEachEnemyNearby(x, y, radius, iterator) {
        const spatial = store._enemySpatial;
        if (!spatial) return;

        const { buckets, cellSize } = spatial;
        const minCellX = Math.floor((x - radius) / cellSize);
        const maxCellX = Math.floor((x + radius) / cellSize);
        const minCellY = Math.floor((y - radius) / cellSize);
        const maxCellY = Math.floor((y + radius) / cellSize);

        for (let cellX = minCellX; cellX <= maxCellX; cellX++) {
            for (let cellY = minCellY; cellY <= maxCellY; cellY++) {
                const key = computeEnemySpatialKey(cellX, cellY);
                const bucket = buckets.get(key);
                if (!bucket || bucket.length === 0) continue;
                for (let i = 0; i < bucket.length; i++) {
                    const enemy = bucket[i];
                    if (!enemy || enemy.dead) continue;
                    if (iterator(enemy) === true) {
                        return;
                    }
                }
            }
        }
    }

    function getBulletSearchRadius(bullet) {
        if (bullet.collisionSearchRadius != null) {
            return bullet.collisionSearchRadius;
        }

        let radius = 140;
        if (bullet.r) radius += bullet.r;
        if (bullet.explosive) radius = Math.max(radius, 230);
        if (bullet.isLevelUpPulse) radius = Math.max(radius, 260);
        if (bullet.isFlame) radius = Math.max(radius, 220);
        if (bullet.isDrone) radius = Math.max(radius, 200);

        return Math.max(120, Math.min(radius, 320));
    }

    function handleBulletImpact(b, e) {
        if (b.isFlame) e.slowTimer = 1.0;

        if (e.isHeatDeath) {
            b.dead = true;
            return;
        }

        if (e === store.boss && e.isInvincible) {
            b.dead = true;
            return;
        }

        let dmg = b.dmg || 15;
        let didCrit = false;
        if (e === store.boss && b.isDrone) dmg *= 0.4;

        if (Math.random() < store.player.critChance) {
            dmg *= store.player.critDamage;
            didCrit = true;
            store.activeEffects.push(createEffect('critText', e.x, e.y));
            if (Math.random() < 0.05) spawnPowerup(e.x, e.y);
        }

        if (e === store.boss) playSound('hit');
        const subclass = store.player.subclass;
        let bulletTags;
        switch (subclass) {
            case 'juggernaut':
                bulletTags = ['fire', 'explosive'];
                break;
            case 'marauder':
                bulletTags = ['kinetic', 'concussive'];
                break;
            case 'railgunner':
                bulletTags = ['kinetic', 'explosive'];
                break;
            case 'demolitionist':
                bulletTags = ['fire', 'explosive'];
                break;
            case 'phasestriker':
                bulletTags = ['void', 'magic'];
                break;
            case 'stormcaller':
                bulletTags = ['lightning', 'magic'];
                break;
            default:
                bulletTags = b.explosive ? ['fire', 'explosive'] : ['kinetic'];
        }
        const vulnBullet = applySubclassVulnerability(e, dmg, {
            subclass,
            player: store.player,
            damageTags: bulletTags,
            source: b.explosive ? 'explosiveBullet' : 'bullet',
            projectile: b,
            baseDamage: dmg
        });
        dmg = vulnBullet.damage;
        e.hp -= dmg;

        const impactAngle = Math.atan2(e.y - b.y, e.x - b.x);
        registerEnemyHit(e, {
            angle: impactAngle,
            knockbackStrength: 0,
            shakeIntensity: b.explosive ? 6 : 3.5,
            shakeDuration: b.explosive ? 0.22 : 0.14,
            slowFactor: b.explosive ? 0.8 : 0.9,
            slowDuration: b.explosive ? 0.22 : 0.12,
            crit: didCrit,
            effect: false
        });

        if (store.player.pilotGenome === 'beef') {
            store.player.beefShieldDamageDealt += dmg;
        }

        if (store.player.vampirism > 0) {
            let healAmount = dmg * store.player.vampirism;
            healAmount = Math.max(healAmount, 1);
            healAmount = Math.min(healAmount, 5);
            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
        }

        if (e.hp <= 0) {
            e.dead = true;
            if (e.type === 'void_champion') {
                store.enemies.forEach(minion => {
                    if (minion.orbitTargetId === e.id && !minion.dead) {
                        spawnGibs(minion.x, minion.y, minion.color);
                        minion.dead = true;
                    }
                });
                handleVoidChampionReward(e);
            }

            if (e.type === 'shadow_champion') {
                store.shadowChampionDefeated = true;
                store.shadowChampionLastPos = { x: e.x, y: e.y };
                store.shadowChampionId = null;
                if (!store.shadowChampionTokenDropped) {
                    addShadowEcho(e.x, e.y);
                    announce('Champion sigil destabilized!');
                }
            }

            if (e === store.boss) {
                handleBossDefeat();
            } else {
                spawnGibs(e.x, e.y, e.color);
                const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                store.world.score += Math.floor(e.score * collarBonus);
                store.world.gold += Math.floor(e.gold * collarBonus);
                store.world.xp += Math.floor(e.xp * collarBonus);
                store.world.kills++;

                if (e.type !== 'shadow_champion') {
                    spawnPowerup(e.x, e.y);
                }
                explode(e.x, e.y);
            }
        }

        if (b.explosive) explode(b.x, b.y, false, true);
        if (!b.pierce) b.dead = true;
    }

    const CLASS_DAMAGE_TAGS = {
        juggernaut: ['fire', 'explosive'],
        marauder: ['kinetic', 'concussive'],
        railgunner: ['kinetic', 'explosive'],
        demolitionist: ['fire', 'explosive'],
        phasestriker: ['void', 'magic'],
        stormcaller: ['lightning', 'magic']
    };

    const MARAUDER_VULNERABILITY_ALLOWED_SOURCES = new Set([
        'beefCharge',
        'beefChargeCombo',
        'missileImpact',
        'pierceMissile',
        'clusterMissile',
        'clusterDetonation',
        'voidLaser',
        'chainLightning'
    ]);

    function triggerJuggernautVulnerability(enemy, context) {
        enemy.jugFearTimer = Math.max(enemy.jugFearTimer || 0, 2.6);
        enemy.jugBurnTimer = Math.max(enemy.jugBurnTimer || 0, 3.5);
        enemy.jugBurnTick = 0;
        enemy.jugPulseTimer = Math.max(enemy.jugPulseTimer || 0, 3.0);
        enemy.jugPulsePhase = enemy.jugPulsePhase || 0;
        enemy.vulnerabilityPulseColor = '#ff3b3b';
        enemy.vulnerabilityPulseStrength = 1;
        store.activeEffects.push(createEffect('jugFearIgnite', enemy.x, enemy.y, enemy.r * 1.1));
    }

    function triggerMarauderVulnerability(enemy, context) {
        const angle = context.knockbackAngle ?? Math.atan2(enemy.y - store.player.y, enemy.x - store.player.x);
        const smashSpeed = 1100;
        const smashDuration = 0.55;
        enemy.knockback = {
            vx: Math.cos(angle) * smashSpeed,
            vy: Math.sin(angle) * smashSpeed,
            duration: smashDuration,
            type: 'maraLaunch'
        };
        enemy.maraLaunchTimer = smashDuration;
        enemy.maraImpactTriggered = false;
        enemy.vulnerabilityPulseColor = '#aad1ff';
        enemy.vulnerabilityPulseStrength = 0.8;
    store.activeEffects.push(createEffect('marauderLaunchTrail', enemy.x, enemy.y, { duration: smashDuration, enemy }));
    }

    function triggerRailgunnerVulnerability(enemy) {
        enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 4.0);
        enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 1, 3);
        enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.35);
        enemy.vulnerabilityPulseColor = '#d7f0ff';
        enemy.vulnerabilityPulseStrength = 0.6;
        store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, enemy.railgunCrackLevel));
    }

    function triggerDemolitionistVulnerability(enemy, context) {
        const fallbackPos = { x: enemy.x, y: enemy.y };
        const sourcePlayer = context.player || store.player;
        scheduleVulnerabilityEvent(0.7, () => {
            const ref = enemy.dead ? fallbackPos : { x: enemy.x, y: enemy.y };
            spawnFlamePulse(ref.x, ref.y, 95, context.baseDamage * 0.8, { player: sourcePlayer });
        });
        enemy.demolitionPulseWarmup = Math.max(enemy.demolitionPulseWarmup || 0, 0.7);
        enemy.vulnerabilityPulseColor = '#ffae5b';
        enemy.vulnerabilityPulseStrength = 0.7;
        store.activeEffects.push(createEffect('demolitionPulseCharge', enemy.x, enemy.y, enemy.r * 1.4));
    }

    function triggerPhaseStrikerVulnerability(enemy) {
        enemy.phaseLockTimer = Math.max(enemy.phaseLockTimer || 0, 2.4);
        enemy.phaseLockSlowFactor = 0.35;
        enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.5);
        enemy.vulnerabilityPulseColor = '#8f6bff';
        enemy.vulnerabilityPulseStrength = 0.9;
        store.activeEffects.push(createEffect('voidLockChains', enemy.x, enemy.y, enemy.r * 1.2));
    }

    function triggerStormcallerVulnerability(enemy, context) {
        enemy.stormShockTimer = Math.max(enemy.stormShockTimer || 0, 2.2);
        enemy.stormShockIntensity = 1;
        enemy.vulnerabilityPulseColor = '#6fd2ff';
        enemy.vulnerabilityPulseStrength = 1;
        store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, enemy.r * 1.5));
        const targets = store.enemies.filter(en => !en.dead && en !== enemy);
        const arcTargets = targets.sort((a, b) => ((a.x - enemy.x) ** 2 + (a.y - enemy.y) ** 2) - ((b.x - enemy.x) ** 2 + (b.y - enemy.y) ** 2)).slice(0, 3);
        arcTargets.forEach(target => {
            store.activeEffects.push(createEffect('stormArc', enemy.x, enemy.y, { x: target.x, y: target.y }));
            target.stunTimer = Math.max(target.stunTimer || 0, 0.3);
        });
    }

    const ENEMY_VULNERABILITIES = {
        mech: {
            juggernaut: {
                multiplier: 1.6,
                damageTags: ['fire', 'explosive'],
                cooldownMs: 500,
                onTrigger: triggerJuggernautVulnerability
            }
        },
        manta: {
            marauder: {
                multiplier: 1.45,
                damageTags: ['kinetic', 'concussive'],
                cooldownMs: 400,
                onTrigger: triggerMarauderVulnerability
            }
        },
        phantom: {
            railgunner: {
                multiplier: 1.4,
                damageTags: ['kinetic', 'explosive'],
                cooldownMs: 350,
                onTrigger: triggerRailgunnerVulnerability
            }
        },
        void_champion_orb: {
            demolitionist: {
                multiplier: 1.35,
                damageTags: ['fire', 'explosive'],
                cooldownMs: 650,
                onTrigger: triggerDemolitionistVulnerability
            }
        },
        void_champion: {
            phasestriker: {
                multiplier: 1.5,
                damageTags: ['void', 'magic'],
                cooldownMs: 500,
                onTrigger: triggerPhaseStrikerVulnerability
            }
        },
        angler: {
            stormcaller: {
                multiplier: 1.4,
                damageTags: ['lightning', 'magic'],
                cooldownMs: 450,
                onTrigger: triggerStormcallerVulnerability
            }
        }
    };

    function scheduleVulnerabilityEvent(delay, action) {
        store.vulnerabilityEvents.push({ timer: delay, action });
    }

    function processVulnerabilityEvents(dt) {
        for (let i = store.vulnerabilityEvents.length - 1; i >= 0; i--) {
            const evt = store.vulnerabilityEvents[i];
            evt.timer -= dt;
            if (evt.timer <= 0) {
                try {
                    evt.action?.();
                } catch (err) {
                    console.warn('Vulnerability event error', err);
                }
                store.vulnerabilityEvents.splice(i, 1);
            }
        }
    }

    function spawnFlamePulse(x, y, radius = 90, damage = 40, context = {}) {
        store.activeEffects.push(createEffect('delayedFlamePulse', x, y, radius));
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(enemy => {
            if (!enemy || enemy.dead) return;
            const distSq = (enemy.x - x) * (enemy.x - x) + (enemy.y - y) * (enemy.y - y);
            if (distSq <= radius * radius) {
                let dmg = damage;
                if (enemy === store.boss) dmg *= 0.35;
                const result = applySubclassVulnerability(enemy, dmg, {
                    subclass: 'demolitionist',
                    damageTags: ['fire', 'explosive'],
                    player: context.player,
                    source: 'demolitionPulse',
                    disableVulnerability: true
                });
                enemy.hp -= result.damage;
                for (let i = 0; i < 4; i++) {
                    store.flameParticles.push(new FlameParticle(
                        x + (Math.random() - 0.5) * radius * 0.6,
                        y + (Math.random() - 0.5) * radius * 0.6
                    ));
                }
            }
        });
    }

    function applySubclassVulnerability(enemy, baseDamage, context = {}) {
        if (context.disableVulnerability) {
            return { damage: baseDamage, triggered: false };
        }

        const player = context.player || store.player;
        if (!player) {
            return { damage: baseDamage, triggered: false };
        }

        const subclass = context.subclass || player.subclass;
        if (!subclass) {
            return { damage: baseDamage, triggered: false };
        }

        const config = ENEMY_VULNERABILITIES[enemy.type];
        const subclassConfig = config && config[subclass];
        if (!subclassConfig) {
            return { damage: baseDamage, triggered: false };
        }

        const appliedTags = context.damageTags || CLASS_DAMAGE_TAGS[subclass] || [];
        const matchesTag = appliedTags.some(tag => subclassConfig.damageTags.includes(tag));
        if (!matchesTag) {
            return { damage: baseDamage, triggered: false };
        }

        const allowTriggerOverride = context.allowVulnerabilityTrigger;
        let allowTrigger = allowTriggerOverride !== undefined ? !!allowTriggerOverride : true;
        if (allowTrigger && subclass === 'marauder') {
            const source = context.source;
            if (!MARAUDER_VULNERABILITY_ALLOWED_SOURCES.has(source) && !context.forceVulnerabilityTrigger) {
                allowTrigger = false;
            }
        }

        enemy._lastVulnerabilityTrigger = enemy._lastVulnerabilityTrigger || {};
        const now = performance.now();
        const cooldown = subclassConfig.cooldownMs ?? 350;
        const lastTrigger = enemy._lastVulnerabilityTrigger[subclass] || 0;
        let triggered = false;
        if (allowTrigger && now - lastTrigger >= cooldown) {
            enemy._lastVulnerabilityTrigger[subclass] = now;
            triggered = true;
            if (subclassConfig.onTrigger) {
                subclassConfig.onTrigger(enemy, { ...context, baseDamage, player });
            }
        }

        const damage = baseDamage * (subclassConfig.multiplier || 1);
        return { damage, triggered };
    }

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', icon: 'ðŸ’¥', desc: '+6% damage', apply: () => { store.player.dmgMult *= 1.06; } },
        { id: 'fire', name: 'OVERCLOCK', icon: 'ðŸ”¥', desc: '+6% fire rate', apply: () => { store.player.fireRate *= 0.60; } },
        { id: 'multi', name: 'SCATTER PROTOCOL', icon: 'â˜„ï¸', desc: '+1 projectile', apply: () => {
            const p = store.player;
            if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
        }},
        { id: 'shield', name: 'VOID SHIELD', icon: 'ðŸ›¡ï¸', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'flamethrower', name: 'LAVA CHUNKS', icon: 'ðŸŒ‹', desc: 'Spews chunks of molten rock in a cone.', apply: () => { store.player.flamethrowerLevel++; } }
    ];
    
    const SHOP_UPGRADES = {
        'repair': { name: "NANO REPAIR", icon: 'ðŸ”§', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'vampirism': {
            name: "VAMPIRIC ROUNDS", icon: 'ðŸ©¸', isPremium: true, max: 4, category: 'utility',
            apply: () => {
                const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                if (store.world.gold >= cost && p.vampirismLevel < 4) { store.world.gold -= cost; p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
            },
            desc: () => {
                const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
            }
        },
        'hp': { 
            name: "MAX HP", 
            icon: 'â¤ï¸', 
            baseCost: 25, 
            scale: 1.1, 
            maxLevel: 20, 
            category: 'health', 
            effect: (level) => { 
                const p = store.player;
                // Scale HP upgrades with current wave for late game viability
                let hpIncrease = 10;
                if (store.world.wave > 20) {
                    // After wave 20, HP upgrades scale with wave
                    hpIncrease = 10 + (store.world.wave - 20) * 2;
                }
                p.hpMax += hpIncrease; 
                p.hp += hpIncrease;
                // console.log(`HP upgrade: +${hpIncrease} HP (wave ${store.world.wave})`);
            }, 
            desc: level => {
                let hpIncrease = 10;
                if (store.world.wave > 20) {
                    hpIncrease = 10 + (store.world.wave - 20) * 2;
                }
                return `+${hpIncrease} Max HP (Lvl ${level + 1})`;
            }
        },
        'nano_save': { name: "NANO SAVE", icon: 'ðŸ’¾', cost: 25, isPremium: true, max: 3, category: 'utility', apply: () => { if (store.player.nanoSaves < 3) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Auto-heals on low HP. Charges: ${store.player.nanoSaves}/3` },
        'luck_boost': { name: "LUCK BOOST", icon: 'ðŸ€', baseCost: 50, scale: 2, maxLevel: 5, category: 'utility', effect: (level) => { store.player.luckBoost = (store.player.luckBoost || 0) + (0.15 / Math.pow(2, level)); }, desc: level => `+${(0.15 / Math.pow(2, level) * 100).toFixed(1)}% drop chance (Lvl ${level + 1})` },
        'dmg': { name: "DAMAGE", icon: 'ðŸ’ª', baseCost: 50, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.06, desc: level => `+6% Damage (Lvl ${level + 1})` },
        'crit_chance': { name: "SHINOBI REFLEXES", icon: 'ðŸ¥·', baseCost: 40, increment: 24, maxLevel: 10, category: 'attack', effect: () => { store.player.critChance *= 1.5; store.player.critDamage *= 1.5; }, desc: level => `+50% Crit Chance & Dmg (Lvl ${level + 1})` },
        'speed': { name: "SPEED", icon: 'ðŸš€', baseCost: 40, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
        'grenade': { name: "NOVA GRENADE", icon: 'ðŸ’¥ðŸ’£ðŸ’¥', cost: 70, isPremium: true, max: 3, category: 'attack', apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'max_shield': { 
            name: "MAX SHIELD", 
            icon: 'ðŸ›¡ï¸', 
            baseCost: 30, 
            scale: 1.2, 
            maxLevel: 20, // Increased max level
            category: 'health', 
            effect: (level) => { 
                const p = store.player;
                if (level < 5) {
                    // First 5 levels: +25 flat shield
                    p.shieldMax += 25; 
                    p.shield += 25;
                } else {
                    // Levels 6+: +25% of current max shield
                    const increase = Math.floor(p.shieldMax * 0.25);
                    p.shieldMax += increase;
                    p.shield += increase;
                }
            }, 
            desc: level => {
                if (level < 5) {
                    return `+25 Max Shield (Lvl ${level + 1})`;
                } else {
                    return `+25% Max Shield (Lvl ${level + 1})`;
                }
            }
        },
        'rear_guard': { name: 'AFT FLANKSHIELD', icon: 'ðŸ›¡ï¸âœ¨', baseCost: 130, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
        'launcher': {
                name: 'FRAG LAUNCHER',
                icon: 'ðŸ’¥',
                baseCost: 100,
                scale: 2,
                maxLevel: 3,
                category: 'attack',
                effect: () => {
                    store.player.hasLauncher = true;
                },
                desc: level => {
                    if (level === 0) return `Unlocks launcher (2 projectiles).`;
                    if (level === 1) return `Add 2 projectiles (4 total).`;
                    if (level === 2) return `Add 2 more projectiles (6 total).`;
                    return "Max projectiles reached.";
                }
            },
        'star_cannon': {
            name: 'STAR CANNON',
            icon: 'ðŸŒ ',
            baseCost: 150,
            scale: 1.5,
            maxLevel: 3,
            category: 'attack',
            effect: level => {
                const p = store.player;
                if (level === 0) {
                    p.starCannonLevel = 1;
                    p.starCannonTimer = 0;
                    announce('STAR CANNON ONLINE!');
                } else if (level === 1) {
                    p.starCannonLevel = 2;
                    p.starCannonTimer = Math.min(p.starCannonTimer, 0);
                    announce('STAR CANNON MKII - DUAL ARTILLERY!');
                } else if (level === 2) {
                    p.starCannonLevel = Math.max(p.starCannonLevel, 2);
                    p.starCannonIcemanSupport = true;
                    announce('STAR CANNON MKIII - BLIZZARD SYNC!');
                }
            },
            desc: level => {
                if (level === 0) return 'Left-side artillery star cannon (7s reload).';
                if (level === 1) return 'Add right-side cannon for twin strikes.';
                if (level === 2) return 'Iceman mirrors your salvo with frosty stars.';
                return 'Max Level';
            }
        },
        'iceman': { name: "THE ICEMAN", icon: 'â„ï¸', cost: 118, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.hasIceman) { store.player.hasIceman = true; store.iceman = { x: store.player.x, y: store.player.y + 50, t: 0 }; return true; } return false; }, desc: () => `A clone mirrors your attacks.` },
        'lazarus_beam': { name: "LORD LAZARUS", icon: 'â˜¢ï¸â˜„ï¸â˜¢ï¸', baseCost: 200, scale: 3, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Lazarus smites foes twice as often.'; if (level === 1) return 'Lazarus fires two beams at once.'; return 'Max Level'; }},
        'magnet_pull': { name: "GRAV-PULSE", icon: 'ðŸ§²', cost: 90, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
        'gravity_well': { name: "GRAVITY WELL", icon: 'ðŸ•³ï¸', baseCost: 300, scale: 2, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; }}, desc: level => { if (level === 0) return 'Unleash a singularity that traps and crushes foes.'; if (level === 1) return 'Summon a second, smaller singularity.'; return 'Max Level'; }},
        'ghost_hounds': { name: "GHOST HOUNDS", icon: 'ðŸ‘»ðŸº', baseCost: 150, scale: 2, maxLevel: 2, category: 'attack', effect: () => { if (!store.player.hasHounds) { store.player.hasHounds = true; store.hounds = [createHound(-1), createHound(1)]; } else { store.hounds.push(createHound(-2)); store.hounds.push(createHound(2)); } playSound('dogs'); }, desc: level => { if (level === 0) return `Unlocks 2 spectral hounds.`; if (level === 1) return `Add 2 more hounds.`; return "Max hounds reached."; } }
    };
    
    const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: 'â¬†ï¸', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'ðŸš', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'ðŸ›¡ï¸', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: 'â¤ï¸', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'ðŸš€', duration: 20, type: 'timed' },
        'void_core': { name: 'VOID CORE', icon: 'ðŸŒ€', duration: 25, type: 'timed' },
        'cash': { name: 'CASH INFUSION', icon: 'ðŸ’°', duration: 0, type: 'instant', isSpecial: true },
        'attack_speed': { name: 'HYPER DRIVE', icon: 'âš¡', duration: 0, type: 'instant', isSpecial: true },
        'swirly_upgrade': { name: 'SWIRL CORE', icon: 'ðŸŒªï¸', duration: 0, type: 'instant', isSpecial: true },
        'star_upgrade': { name: 'STAR CORE', icon: 'ðŸŒ ', duration: 0, type: 'instant', isSpecial: true },
        'shadow_champion_token': { name: 'CHAMPION SIGIL', icon: 'âš”ï¸', duration: 0, type: 'instant', isSpecial: true }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) {
        if (store.world.powerupCooldown > 0) return;
        const p = store.player;
        const baseChance = 0.075;
        const wave = store.world.wave;
        const waveReductionFactor = 0.0025;
        let finalChance = Math.max(0.025, baseChance - (wave - 1) * waveReductionFactor);
    let types = Object.keys(POWERUP_TYPES).filter(key => key !== 'void_core' && !POWERUP_TYPES[key].isSpecial);
        let bonusType = null;
        if (p.pilotGenome === 'beef') {
            // Enhanced drop rates for beef - additional powerups, not replacing existing ones
            if (Math.random() < 0.4) bonusType = 'shield'; // Increased from 0.25 to 0.4
            else if (Math.random() < 0.3) bonusType = 'repair'; // Increased from 0.15 to 0.3
            // Also boost the base chance for beef pilots
            finalChance *= 1.3; // 30% higher overall powerup drop rate
        }
        if (p.pilotGenome === 'rocketman') {
            // Significantly boost missile powerup rates for rocketman
            if (Math.random() < 0.5) bonusType = 'missile'; // 50% chance for missile powerups
            finalChance *= 2.0; // Double overall powerup drop rate
            // Extra chance if rocketman doesn't currently have missiles active
            if (!p.powerupTimers.missile || p.powerupTimers.missile.remaining <= 3) {
                if (Math.random() < 0.3) bonusType = 'missile'; // Extra 30% chance when missiles are low/inactive
            }
        }
        const roll = Math.random();
        if (roll > finalChance && !bonusType) return;
        let typeKey;
        if (bonusType && (roll <= finalChance || Math.random() < 0.5)) {
            typeKey = bonusType;
        } else {
            typeKey = types[Math.floor(Math.random() * types.length)];
        }
        store.powerups.push({ x, y, r: 12, type: typeKey });
        store.world.powerupCooldown = 5;
    }

    function spawnVoidCoreDrop(x, y) {
        if (!store.powerups) store.powerups = [];
        store.powerups.push({ x, y, r: 14, type: 'void_core' });
    }

    const VOID_CHAMPION_REWARD_POOL = ['multishot_bundle', 'attack_speed', 'swirly_upgrade', 'star_upgrade'];
    const VOID_CHAMPION_REWARD_MAP = {
        purple: 'swirly_upgrade',
        crimson: 'attack_speed',
        azure: 'multishot_bundle',
        emerald: 'star_upgrade',
        golden: 'cash_bundle'
    };

    function spawnMultishotBundle(x, y) {
        if (!store.powerups) store.powerups = [];
        const offsets = [-36, 0, 36];
        offsets.forEach((offset, index) => {
            store.powerups.push({
                x: x + offset,
                y: y - index * 6,
                r: 12,
                type: 'double'
            });
        });
    }

    function spawnSpecialPowerup(type, x, y) {
        if (!store.powerups) store.powerups = [];
        store.powerups.push({ x, y, r: 14, type });
    }

    function spawnCashBundle(x, y) {
        if (!store.powerups) store.powerups = [];
        const offsets = [-30, 0, 30];
        offsets.forEach((offset, index) => {
            store.powerups.push({
                x: x + offset,
                y: y - index * 8,
                r: 14,
                type: 'cash'
            });
        });
    }

    function handleVoidChampionReward(enemy) {
        if (!enemy || enemy.voidChampionRewardGranted) return;
        const scheme = getVoidChampionColorScheme(enemy);
        const colorKey = enemy.colorScheme || 'purple';
        if (!enemy.voidChampionRewardKey) {
            let rewardKey = VOID_CHAMPION_REWARD_MAP[colorKey] || 'attack_speed';
            if (rewardKey === 'random_high_tier') {
                rewardKey = VOID_CHAMPION_REWARD_POOL[Math.floor(Math.random() * VOID_CHAMPION_REWARD_POOL.length)];
            }
            enemy.voidChampionRewardKey = rewardKey;
        }

        enemy.voidChampionRewardGranted = true;
        const rewardKey = enemy.voidChampionRewardKey;
        const dropX = enemy.x;
        const dropY = enemy.y - 12;

        switch (rewardKey) {
            case 'multishot_bundle':
                spawnMultishotBundle(dropX, dropY);
                announce(`${scheme.name} shattered! Triple scatter caches deployed!`);
                break;
            case 'attack_speed':
                spawnSpecialPowerup('attack_speed', dropX, dropY);
                announce(`${scheme.name} dismantled! Hyper drive matrix recovered!`);
                break;
            case 'swirly_upgrade':
                spawnSpecialPowerup('swirly_upgrade', dropX, dropY);
                announce(`${scheme.name} collapsed! Swirl core resonance secured!`);
                break;
            case 'star_upgrade':
                spawnSpecialPowerup('star_upgrade', dropX, dropY);
                announce(`${scheme.name} defeated! Star core schematics salvaged!`);
                break;
            case 'cash_bundle':
                spawnCashBundle(dropX, dropY);
                announce(`${scheme.name} destroyed! Triple cash infusion secured!`);
                break;
            default:
                spawnSpecialPowerup('attack_speed', dropX, dropY);
                announce(`${scheme.name} neutralized! Hyper drive cache secured!`);
                break;
        }
    }
    
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
        if (typeKey === 'shadow_champion_token') {
            grantChampionCompanion();
            return;
        }
        if (typeKey === 'missile') {
            if (p.pilotGenome === 'rocketman') { p.missileVolley = Math.min(5, p.missileVolley + 2); } else { p.missileVolley = 2; }
        }
        if (typeKey === 'cash') {
            const baseGoldValue = 80;
            const waveScaling = Math.max(1, store.world.wave * 1.5);
            const goldAmount = Math.floor(baseGoldValue * waveScaling);
            store.world.gold = (store.world.gold || 0) + goldAmount;
            announce(`ðŸ’° CASH INFUSION +${goldAmount} GOLD! ðŸ’°`);
            return;
        }
        if (typeKey === 'attack_speed') {
            const newStacks = (p.attackSpeedStacks || 0) + 1;
            p.attackSpeedStacks = newStacks;
            p.fireRate = Math.max(p.fireRate * 0.88, 0.045);
            announce(`HYPER DRIVE +12% (${newStacks} stack${newStacks === 1 ? '' : 's'})`);
            return;
        }
        if (typeKey === 'swirly_upgrade') {
            if (!p.swirlShots) {
                p.swirlShots = true;
                announce('SWIRL SHOTS ONLINE!');
            } else {
                announce('Swirl core overloaded! Diverting to hyper drive.');
                applyPowerup('attack_speed');
            }
            return;
        }
        if (typeKey === 'star_upgrade') {
            const upgrade = SHOP_UPGRADES && SHOP_UPGRADES.star_cannon;
            if (upgrade) {
                const currentLevel = p.upgradeLevels.star_cannon || 0;
                const maxLevel = upgrade.maxLevel ?? 3;
                if (currentLevel < maxLevel) {
                    upgrade.effect(currentLevel);
                    p.upgradeLevels.star_cannon = currentLevel + 1;
                    announce('STAR CANNON BLUEPRINT ACQUIRED (FREE)!');
                } else {
                    announce('Star core surplus! Converting to hyper drive.');
                    applyPowerup('attack_speed');
                }
            }
            return;
        }
        if (typeKey === 'void_core') {
            const timer = p.powerupTimers[typeKey];
            const prevStacks = timer ? (timer.stacks || 0) : 0;
            const newStacks = Math.min(3, prevStacks + 1);
            const prevDmgMult = p.voidCoreDmgMult || 1;
            const prevFireRateMult = p.voidCoreFireRateMult || 1;
            const newDmgMult = 1 + newStacks * 0.3;
            const newFireRateMult = 1 + newStacks * 0.2;

            p.dmgMult = (p.dmgMult / prevDmgMult) * newDmgMult;
            p.fireRate = (p.fireRate * prevFireRateMult) / newFireRateMult;
            p.fireRate = Math.max(p.fireRate, 0.05);

            p.voidCoreStacks = newStacks;
            p.voidCoreDmgMult = newDmgMult;
            p.voidCoreFireRateMult = newFireRateMult;

            if (timer) {
                timer.remaining = powerup.duration;
                timer.max = powerup.duration;
                timer.stacks = newStacks;
            } else {
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration, stacks: newStacks };
            }

            announce(`VOID CORE RESONANCE x${newStacks}`);
            announce(powerup.name);
            return;
        }
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
            else {
                if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') {
                const p = store.player;
                if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                announce('SCATTER SHOT!');
            }
        }
        announce(powerup.name);
    }

    function sanitizeCollarStacks() {
        if (!Number.isFinite(store.world.collarStacks)) {
            console.warn('Invalid collar stack value detected, resetting.', store.world.collarStacks);
            store.world.collarStacks = 0;
        }
        if (!Number.isFinite(store.world.collarTargetStacks)) {
            store.world.collarTargetStacks = store.world.collarStacks;
        }
        return store.world.collarStacks;
    }

    function calculateCollarBonus(stacks) {
        const safeStacks = Math.max(0, Number.isFinite(stacks) ? stacks : 0);
        const tierOne = Math.min(safeStacks, 5); // First 5 stacks at 6% each
        const tierTwo = Math.min(Math.max(safeStacks - 5, 0), 5); // Next 5 stacks at 4% each
        const tierThree = Math.max(Math.min(safeStacks, 25) - 10, 0); // Remaining stacks (capped at 25) at 2% each
        const bonus = tierOne * 0.06 + tierTwo * 0.04 + tierThree * 0.02;
        return 1 + bonus;
    }

    const MAX_COLLAR_STACKS = 25;

    function setCollarStacks(value) {
        const clamped = Math.max(0, Math.min(MAX_COLLAR_STACKS, ensureFiniteNumber(value, 0)));
        store.world.collarStacks = clamped;
        store.world.collarTargetStacks = clamped;
        return clamped;
    }

    function approachCollarTarget() {
        const currentStacks = sanitizeCollarStacks();
        if (!Number.isFinite(store.world.collarTargetStacks)) {
            store.world.collarTargetStacks = currentStacks;
        }
        const targetStacks = Math.min(MAX_COLLAR_STACKS, store.world.collarTargetStacks);
        const stackGap = targetStacks - currentStacks;
        if (stackGap > 0) {
            const maxIncrease = 1 + Math.min(2, currentStacks * 0.05);
            const appliedIncrease = Math.min(stackGap, maxIncrease);
            store.world.collarStacks = Math.min(MAX_COLLAR_STACKS, currentStacks + appliedIncrease);
        } else if (stackGap < 0) {
            setCollarStacks(targetStacks);
        }
    }

    function scheduleCollarIncrease(amount) {
        const delta = ensureFiniteNumber(amount, 0);
        if (delta <= 0) {
            approachCollarTarget();
            return;
        }

        const currentStacks = sanitizeCollarStacks();
        if (!Number.isFinite(store.world.collarTargetStacks)) {
            store.world.collarTargetStacks = currentStacks;
        }
        store.world.collarTargetStacks = Math.min(MAX_COLLAR_STACKS, store.world.collarTargetStacks + delta);
        approachCollarTarget();
    }

    function ensureFiniteNumber(value, fallback = 0) {
        return Number.isFinite(value) ? value : fallback;
    }

    function initWave() {
        if (store.goldenOrbs) {
            store.goldenOrbs.length = 0;
        }
        const isBossWave = store.world.wave % 5 === 0;

        const teleportAuraByType = {
            drone: '#7fd5ff',
            hunter: '#ff6e84',
            phantom: '#d9a7ff',
            mech: '#4ef0ff',
            angler: '#8cf8f8',
            manta: '#7acbff',
            void_champion: '#a864ff'
        };
        const spawnDurationByType = {
            phantom: 0.7,
            mech: 0.8,
            angler: 0.7,
            manta: 0.85,
            void_champion: 1.05
        };
        const dropDistanceByType = {
            mech: 200,
            angler: 170,
            manta: 180,
            void_champion: 220
        };
        const BOSS_CHAMPION_LOOP = 6;

        function spawnVoidChampion({
            hpScale = 1,
            damageMult = 1,
            lateGameScaling = 1,
            entryTargetYBase = 110,
            entryYOffset = 0
        } = {}) {
            const champion = spawnEnemy('void_champion', { hpScale, damageMult });
            if (!champion) return null;

            applySpawnSpecToEnemy(champion, { lateGameScaling });
            const entryDrop = dropDistanceByType.void_champion || 220;
            const entryTargetY = entryTargetYBase + entryYOffset + Math.random() * 50;
            champion.spawnTargetY = entryTargetY;
            champion.y = entryTargetY - entryDrop;
            champion.x = Math.max(120, Math.min(W - 120, champion.x));

            activateSpawnIntro(champion, {
                duration: spawnDurationByType.void_champion,
                dropDistance: entryDrop,
                targetY: entryTargetY,
                clusterIndex: -1,
                effectColor: teleportAuraByType.void_champion,
                topClampBuffer: 1.2,
                fireDelayBuffer: 0.6
            });

            store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.spawnTargetY ?? champion.y, champion.r || 28, {
                duration: (champion.spawnDuration || 1) + 0.35,
                color: teleportAuraByType.void_champion,
                clusterIndex: -1,
                isChampion: true
            }));
            store.enemies.push(champion);
            return champion;
        }

        function spawnBossLoopChampions(loopCount, bossHpScale) {
            if (loopCount < 1 || !Number.isFinite(loopCount)) return 0;
            const championsToSpawn = Math.min(2, Math.max(0, loopCount));
            let spawned = 0;
            for (let i = 0; i < championsToSpawn; i++) {
                const champion = spawnVoidChampion({
                    hpScale: bossHpScale,
                    damageMult: bossHpScale,
                    lateGameScaling: bossHpScale,
                    entryTargetYBase: 100,
                    entryYOffset: i * 40
                });
                if (champion) spawned += 1;
            }
            return spawned;
        }

        // Clear poison puddles at start of each wave for clean slate
        if (store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        
        if (isBossWave) {
            store.enemies = [];
            
            // FIXED: Balanced boss scaling instead of aggressive exponential growth
            // Old: 1 + (wave/5 - 1) * 1.5 caused 4x HP by wave 15
            // New: Gentler scaling with reasonable progression
            let bossHpScale;
            if (store.world.wave <= 5) {
                bossHpScale = 1; // No scaling for early bosses
            } else if (store.world.wave <= 15) {
                bossHpScale = 1 + (store.world.wave - 5) * 0.2; // +20% per wave 6-15
            } else {
                bossHpScale = 1 + 10 * 0.2 + (store.world.wave - 15) * 0.1; // +10% per wave after 15
            }
            
            store.boss = createBoss(bossHpScale);
            store.lastBossSnapshot = null;
            store.lastBossDefeatId = null;
            store.world.bossSpawnTime = performance.now();
            store.world.lastPlannedSpawnCount = 0;
            store.world.lastSpawnCount = 0;
            store.world.lastSpawnOverflow = 0;
            store.world.lastThreatScale = 1;
            store.world.lastSpawnFallback = false;
            if (store.boss.name === 'VOID SENTINEL') playSound('trap');
            else if (store.boss.name === 'NEURAL CORE') playSound('horn');
            announce(`âš¡ GUARDIAN: ${store.boss.name} âš¡`);
            if (!store.world.firstBossOrbsGifted && store.world.bosses === 0 && store.boss.name === 'VOID SENTINEL') {
                spawnGoldenSentinelOrbs(3);
                store.world.firstBossOrbsGifted = true;
                setTimeout(() => announce('Collect GOLDEN ORBS to shatter the guardian!'), 750);
            }

            const bossesDefeated = ensureFiniteNumber(store.world.bosses, 0);
            const bossLoopCount = Math.floor(bossesDefeated / BOSS_CHAMPION_LOOP);
            if (bossLoopCount > 0) {
                spawnBossLoopChampions(bossLoopCount, bossHpScale);
            }
        } else {
            store.enemies = [];
            store.waveSpawnQueue = [];
            store.pendingSpawnCount = 0;
            
            // NEW SCALING SYSTEM: After wave 35, stop increasing spawn count and increase enemy stats instead
            let baseSpawnCount, spawnCount, lateGameScaling = 1;
            
            if (store.world.wave <= 35) {
                // Normal scaling: increase spawn count with waves
                baseSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                spawnCount = baseSpawnCount;
            } else {
                // Wave 35+: Cap spawn count, scale enemy stats instead
                baseSpawnCount = Math.floor((7 + Math.floor(35 * 1.8)) * store.world.enemyDensityBonus);
                spawnCount = Math.max(1, Math.floor(baseSpawnCount * 0.8)); // Slightly fewer enemies for performance
                
                // Calculate what the spawn count WOULD have been, use that as scaling factor
                const theoreticalSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                lateGameScaling = theoreticalSpawnCount / baseSpawnCount; // This becomes our health/damage multiplier
            }
            
            // Store late-game scaling factor globally for damage calculations
            store.world.lateGameDamageScaling = lateGameScaling;
            
            // Apply collar bonus to spawn count with defensive guards
            const collarStacks = sanitizeCollarStacks();
            const collarBonus = calculateCollarBonus(collarStacks);
            const plannedSpawnCountRaw = spawnCount * collarBonus;
            const plannedSpawnCount = Math.max(0, ensureFiniteNumber(Math.floor(plannedSpawnCountRaw), 0));

            const rawEnemyCap = ensureFiniteNumber(store.world.enemyCap, 36);
            const enemyCap = rawEnemyCap > 0 ? rawEnemyCap : 36;

            let cappedSpawnCount = Math.min(enemyCap, plannedSpawnCount);
            if (!Number.isFinite(cappedSpawnCount) || cappedSpawnCount <= 0) {
                cappedSpawnCount = 1;
                store.world.lastSpawnFallback = true;
            } else {
                store.world.lastSpawnFallback = false;
            }

            const spawnIterations = Math.max(1, Math.floor(cappedSpawnCount));
            const threatScaleRaw = spawnIterations > 0 && plannedSpawnCount > 0 ? plannedSpawnCount / spawnIterations : 1;
            const threatScale = ensureFiniteNumber(threatScaleRaw, 1);

            store.world.lastThreatScale = threatScale;
            store.world.lastSpawnOverflow = Math.max(0, plannedSpawnCount - spawnIterations);
            store.world.lastPlannedSpawnCount = plannedSpawnCount;
            store.world.lastSpawnCount = 0;

            spawnCount = spawnIterations;

            if (store.world.wave > 8) {
                const championChance = Math.min(0.4, 0.12 + (store.world.wave - 8) * 0.025);
                if (Math.random() < championChance) {
                    // Cap champion scaling to prevent absurd HP values
                    const maxChampionScale = 3.0; // Max 3x scaling instead of unlimited
                    const cappedHpScale = Math.min(maxChampionScale, threatScale);
                    const cappedLateGameScaling = Math.min(maxChampionScale, lateGameScaling);
                    
                    const champion = spawnVoidChampion({
                        hpScale: cappedHpScale,
                        damageMult: Math.min(2.0, threatScale), // Cap damage scaling at 2x
                        lateGameScaling: cappedLateGameScaling
                    });
                    if (champion) {
                        spawnCount = Math.max(1, spawnCount - 1);
                    }
                }
            }
            const spawnSpecs = [];

            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter'];
                if (store.world.wave > 3) types.push('phantom');
                if (store.world.wave > 5) types.push('mech');
                if (store.world.wave > 7) types.push('angler');
                if (store.world.wave > 9) types.push('manta');

                const selectedType = types[Math.floor(Math.random() * types.length)];
                spawnSpecs.push({
                    type: selectedType,
                    props: { hpScale: threatScale, damageMult: threatScale },
                    lateGameScaling,
                    spawnDuration: spawnDurationByType[selectedType],
                    spawnDropDistance: dropDistanceByType[selectedType],
                    effectColor: teleportAuraByType[selectedType]
                });
            }

            if (spawnSpecs.length === 0) {
                console.warn('Enemy spawn pipeline produced zero entities; applying fallback spawn.', {
                    wave: store.world.wave,
                    plannedSpawnCount,
                    enemyCap,
                    collarStacks,
                    threatScale
                });
                spawnSpecs.push({
                    type: 'drone',
                    props: { hpScale: threatScale, damageMult: threatScale },
                    lateGameScaling,
                    spawnDuration: 0.6,
                    spawnDropDistance: 120,
                    effectColor: teleportAuraByType.drone
                });
                store.world.lastSpawnFallback = true;
            }

            const plannedClusters = Math.max(1, Math.ceil(spawnSpecs.length / 4));
            const clusterCount = Math.min(6, plannedClusters);
            const spawnTempo = Math.max(0.2, 0.55 - Math.min(store.world.wave, 25) * 0.015);

            store.pendingSpawnCount = spawnSpecs.length;
            store.world.lastSpawnQueueLength = spawnSpecs.length;
            store.world.lastSpawnTempo = spawnTempo;
            store.world.lastSpawnCount = store.enemies.length;

            scheduleWaveSpawnClusters(spawnSpecs, {
                clusterCount,
                baseDelay: spawnTempo,
                jitter: spawnTempo * 0.6
            });

            store.world.waveStartTime = performance.now();
            announce(`â—¢ SECTOR ${store.world.wave} â—£`);
        }
    }
    
    function createBoss(scale) {
        const types = [
            { name: 'VOID SENTINEL', baseHp: 4000, r: 55, behavior: 'sentinel', color: '#8B4A9C' },
            { name: 'NEXUS PHANTOM', baseHp: 2200, r: 50, behavior: 'hex', color: '#66aaff'},
            { name: 'NEURAL CORE', baseHp: 3200, r: 60, behavior: 'malignus', color: '#2E8B57' },
            { name: 'HIVE SOVEREIGN', baseHp: 8500, r: 85, behavior: 'broodlord', color: '#2d5016' },
            { name: 'SHADOW MIRROR', baseHp: 7200, r: 58, behavior: 'shadow_clone', color: '#cbd4ff' },
            { name: 'DEATH ENGINE', baseHp: 9000, r: 90, behavior: 'construct', color: '#e54d24', phase: 1, isLaughing: false, laughStartTime: 0, visible: true }
        ];
        const cycleRaw = Math.floor((store.world.wave - 5) / 5);
        const bossCycle = ((cycleRaw % types.length) + types.length) % types.length;
        const type = types[bossCycle];
        let hp = type.baseHp * scale * store.world.bossHealthBonus;
    const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
        hp *= collarBonus;
        
    const boss = { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, isEnraged: false, attackPhase: 0, phaseTimer: 0, dashTimer: 0, dashTrailCooldown: 0, rainEvent: null };
        
        // console.log(`ðŸ† Boss Created: ${boss.name} | Wave: ${store.world.wave} | HP: ${hp} | Scale: ${scale} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x`);
        
        // Create Boss class instance for DEATH ENGINE
        if (boss.name === 'DEATH ENGINE') {
            boss.skullRenderer = new Boss(ctx, boss.x, boss.y, boss.color);
            // Store collar stacks before Death Engine fight to restore them after
            store.world.deathEngineCollarStacks = store.world.collarStacks;
            store.world.deathEngineCollarTargetStacks = store.world.collarTargetStacks;
        }
        
        return boss;
    }

    function spawnEnemy(type = 'drone', props = {}) {
        const cfgs = {
            drone: { r: 10, v: 80, vx: 0, hp: 22, color: '#C0C0C0', xp: 5, score: 50, gold: 2, fireRateChance: 0.004, contactDamage: 6 },
            hunter: { r: 20, v: 100, vx: 0, hp: 18, color: '#DC143C', xp: 8, score: 80, gold: 2, fireRateChance: 0.005, contactDamage: 8 },
            trap_king_add: { r: 6, v: 90, vx: 0, hp: 9, color: '#ffc83d', damage: 5, xp: 2, score: 10, gold: 1, contactDamage: 5 },
            phantom: { r: 14, v: 90, vx: 0, hp: 35, color: '#FFFFFF', xp: 10, score: 100, gold: 3, fireRateChance: 0.006, fireCooldown: 1.5, contactDamage: 8 },
            mech: { r: 18, v: 40, vx: 0, hp: 73, color: '#FF8500', xp: 15, score: 150, gold: 5, fireRateChance: 0.007, attackPhase: 0, contactDamage: 10 },
            construct_gold: { r: 10, v: 120, vx: 0, hp: 17, color: '#e03434', xp: 3, score: 30, gold: 1, contactDamage: 7 },
            avian_hatchling: { r: 8, v: 150, vx: 0, hp: 22, color: '#9370DB', xp: 4, score: 40, gold: 1, contactDamage: 6 },
            angler: { r: 22, v: 30, vx: 0, hp: 150, color: '#00008b', xp: 18, score: 180, gold: 4, fireRateChance: 0.008, contactDamage: 10 },
            manta: { r: 26, v: 50, vx: 0, hp: 175, color: '#53B6FF', xp: 22, score: 220, gold: 5, fireRateChance: 0.009, contactDamage: 10 },
            shadow_champion: { r: 18, v: 70, vx: 0, hp: 620, color: '#cbd4ff', xp: 60, score: 480, gold: 12, fireRateChance: 1, fireCooldown: 1.45, contactDamage: 14 },
            void_champion: { r: 16, v: 48, vx: 0, hp: 190, color: '#5A28D8', xp: 32, score: 325, gold: 9, fireRateChance: 0.75, fireCooldown: 1.65, contactDamage: 10 },
            void_champion_orb: { r: 6, v: 0, vx: 0, hp: 22, color: '#FF7DEB', xp: 2, score: 24, gold: 0, fireRateChance: 0.55, fireCooldown: 1.25, contactDamage: 4 }
        };
        const baseCfg = cfgs[type];
        if (!baseCfg) {
            console.warn('Unknown enemy type', type);
            return null;
        }
        let c = { ...baseCfg }; const wave = store.world.wave;
        
        // FIXED: Much gentler health scaling to prevent unkillable enemies
        // Old: Math.pow(1.075, wave) - exponential growth was too aggressive
        // New: Linear growth with soft cap
        let waveMultiplier;
        if (wave <= 10) {
            waveMultiplier = 1 + (wave - 1) * 0.15; // +15% per wave early game
        } else {
            waveMultiplier = 1 + 9 * 0.15 + (wave - 10) * 0.05; // +5% per wave after wave 10
        }
        
        c.hp *= waveMultiplier * store.world.enemyHealthBonus;
    const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
        c.hp *= collarBonus;
        
        // console.log(`ðŸ” Enemy Health Debug | Type: ${type} | Base: ${cfgs[type].hp} | Wave: ${wave} | WaveMult: ${waveMultiplier.toFixed(2)} | EnemyBonus: ${store.world.enemyHealthBonus.toFixed(2)} | CollarBonus: ${collarBonus.toFixed(2)} | Final HP: ${c.hp.toFixed(1)}`);
        const spawnX = props.x !== undefined ? props.x : 20 + Math.random() * (W - 40);
        const spawnY = props.y !== undefined ? props.y : -50 - Math.random() * 250;
        const e = {
            ...c,
            type,
            id: Date.now() + Math.random(),
            x: spawnX,
            y: spawnY,
            hpMax: c.hp,
            phase: type === 'phantom',
            t: 0,
            fireT: props.fireT !== undefined ? props.fireT : (c.fireCooldown || 0),
            isBursting: false,
            burstTimer: 0,
            stunTimer: 0,
            knockback: null,
            hitPulseTimer: 0,
            hitPulseDuration: props.hitPulseDuration || 0.22
        };

        if (props.hpScale && props.hpScale !== 1) {
            e.hp *= props.hpScale;
            e.hpMax *= props.hpScale;
        }

        e.damageMult = props.damageMult !== undefined ? props.damageMult : 1;
        e.baseContactDamage = props.baseContactDamage || c.contactDamage || 8;
        e.contactDamage = e.baseContactDamage * e.damageMult;

        if (!props.damageMult && props.hpScale && props.hpScale !== 1) {
            e.damageMult = props.hpScale;
            e.contactDamage = e.baseContactDamage * e.damageMult;
        }

        if (e.type === 'manta') {
            e.startX = e.x;
            e.amplitude = 150 + Math.random() * 100;
            e.frequency = 0.5 + Math.random() * 0.5;
            e.dodgeCooldown = 0;
            e.isDodging = false;
        }
        if (e.type === 'void_champion') {
            e.fireCooldown = c.fireCooldown || 1.8;
            e.fireT = e.fireCooldown * (0.4 + Math.random() * 0.6);
            e.vx = (Math.random() < 0.5 ? -1 : 1) * (40 + Math.random() * 30);
            e.dashTimer = 2 + Math.random() * 2;
            e.dashCooldown = 4 + Math.random() * 3;
            e.minionIds = [];
            e.nextPattern = 'beam';
            if (store && store.player) {
                const pStats = store.player;
                const dmgFactor = Math.min(3, Math.max(1, pStats.dmgMult || 1));
                const multishotFactor = 1 + Math.max(0, (pStats.multishot || 1) - 1) * 0.2 + (pStats.rearMultishot || 0) * 0.1;
                const fireRateBaseline = 0.45;
                const fireRateFactor = Math.min(2.5, Math.max(1, fireRateBaseline / Math.max(pStats.fireRate || 0.45, 0.18)));
                const shieldFactor = Math.pow(Math.max(1, (pStats.shieldMax || 0) / 60), 0.2);
                const healthFactor = Math.pow(Math.max(1, (pStats.hpMax || 100) / 120), 0.2);
                const playerScaling = Math.min(3.5, Math.max(1, dmgFactor * multishotFactor * fireRateFactor * Math.max(shieldFactor, healthFactor)));
                e.hp *= playerScaling;
                e.hpMax *= playerScaling;
                e.damageMult *= playerScaling;
                e.contactDamage = e.baseContactDamage * e.damageMult;
                e.playerScaling = playerScaling;
            }
            if (store && store.world && !store.world.seenVoidChampion) {
                store.world.seenVoidChampion = true;
                announce('âš™ï¸ VOID CHAMPION ONLINE // SINGULARITY KNIGHT âš™ï¸');
            }
            if (store && store.enemies) {
                const minionCount = 3;
                for (let i = 0; i < minionCount; i++) {
                    const angle = (i / minionCount) * Math.PI * 2;
                    const ringRadius = 42;
                    const minion = spawnEnemy('void_champion_orb', {
                        x: e.x + Math.cos(angle) * ringRadius,
                        y: e.y + Math.sin(angle) * ringRadius,
                        orbitTargetId: e.id,
                        orbitAngle: angle,
                        orbitRadius: ringRadius,
                        orbitSpeed: 1.3 + i * 0.12,
                        parentColor: e.color,
                        fireT: Math.random() * 0.6,
                        damageMult: Math.max(1, (e.damageMult || 1) * 0.65),
                        hpScale: Math.max(1, (e.damageMult || 1) * 0.7)
                    });
                    if (minion) {
                        const minionDrop = 140;
                        const minionTargetY = (e.spawnTargetY ?? e.y + minionDrop) + Math.sin(angle) * 26;
                        minion.spawnTargetY = minionTargetY;
                        activateSpawnIntro(minion, {
                            duration: 0.55 + Math.random() * 0.1,
                            dropDistance: minionDrop,
                            targetY: minionTargetY,
                            clusterIndex: -1,
                            effectColor: '#ff7deb',
                            topClampBuffer: 0.6,
                            fireDelayBuffer: 0.4
                        });
                        e.minionIds.push(minion.id);
                        store.enemies.push(minion);
                    }
                }
            }
        }
        if (e.type === 'shadow_champion') {
            e.baseV = e.v;
            e.guardRadius = props.guardRadius || 120;
            e.guardAngle = props.guardAngle ?? Math.random() * Math.PI * 2;
            e.angularSpeed = props.angularSpeed || (0.75 + Math.random() * 0.25);
            e.anchorOffsetY = props.anchorOffsetY ?? 80;
            e.fireCooldown = props.fireCooldown || e.fireCooldown || 1.45;
            e.fireT = props.fireT !== undefined ? props.fireT : e.fireCooldown * (0.4 + Math.random() * 0.3);
            e.momentum = props.momentum || 3.4;
            e.enrageThreshold = props.enrageThreshold || 0.45;
            e.state = null;
            e.dashTimer = 0;
            e.dashVX = 0;
            e.dashVY = 0;
            e.bossLinkId = props.bossLinkId || null;
            e.guardAnchor = props.guardAnchor || null;
            e.isShadowChampion = true;
        }
        if (e.type === 'void_champion_orb') {
            e.isOrbiter = true;
            e.orbitRadius = props.orbitRadius || 42;
            e.orbitSpeed = props.orbitSpeed || 1.45;
            e.orbitAngle = props.orbitAngle ?? Math.random() * Math.PI * 2;
            e.orbitTargetId = props.orbitTargetId || null;
            const centerX = props.orbitCenterX !== undefined ? props.orbitCenterX : e.x;
            const centerY = props.orbitCenterY !== undefined ? props.orbitCenterY : e.y;
            e.orbitCenter = { x: centerX, y: centerY };
            if (props.parentColor) {
                e.color = props.parentColor;
            }
            e.fireCooldown = c.fireCooldown || 1.15;
            e.fireT = props.fireT !== undefined ? props.fireT : e.fireCooldown;
            e.v = 0;
        }
        return e;
    }

    function scheduleWaveSpawnClusters(spawnSpecs, options = {}) {
        const clustersRequested = options.clusterCount ?? 3;
        const clusterCount = Math.max(1, Math.min(clustersRequested, spawnSpecs.length || 1));
        const clusters = Array.from({ length: clusterCount }, () => []);

        spawnSpecs.forEach((spec, index) => {
            clusters[index % clusterCount].push(spec);
        });

        const baseDelay = options.baseDelay ?? 0.35; // seconds between clusters
        const jitterAmplitude = options.jitter ?? baseDelay * 0.35;
        const queue = store.waveSpawnQueue;

        clusters.forEach((cluster, idx) => {
            if (!cluster.length) return;
            const stagger = idx === 0 ? 0 : (Math.random() - 0.5) * jitterAmplitude;
            const timer = Math.max(0, idx * baseDelay + stagger);
            queue.push({
                timer,
                enemies: cluster,
                clusterIndex: idx,
                clusterSize: cluster.length,
                totalClusters: clusterCount,
                baseDelay
            });
        });
    }

    function processWaveSpawnQueue(dt) {
        if (!store.waveSpawnQueue.length) return;
        for (let i = store.waveSpawnQueue.length - 1; i >= 0; i--) {
            const evt = store.waveSpawnQueue[i];
            evt.timer -= dt;
            if (evt.timer <= 0) {
                spawnClusterEnemies(evt);
                store.waveSpawnQueue.splice(i, 1);
            }
        }
    }

    function spawnClusterEnemies(event) {
        const clusterSize = event.enemies.length;
        const centerX = Math.max(80, Math.min(W - 80, 80 + Math.random() * (W - 160)));
        const spacing = Math.max(40, 140 - clusterSize * 10);
        let spawnedThisCluster = 0;

        event.enemies.forEach((spec, idx) => {
            const lateralOffset = (idx - (clusterSize - 1) / 2) * spacing + (Math.random() - 0.5) * 35;
            const spawnX = Math.max(40, Math.min(W - 40, centerX + lateralOffset));
            const spawnY = -160 - Math.random() * 120;
            const props = { ...(spec.props || {}), x: spawnX, y: spawnY };
            const enemy = spawnEnemy(spec.type, props);
            store.pendingSpawnCount = Math.max(0, (store.pendingSpawnCount || 0) - 1);
            if (!enemy) {
                store.world.lastSpawnFallback = true;
                return;
            }

            applySpawnSpecToEnemy(enemy, spec);
            activateSpawnIntro(enemy, {
                duration: spec.spawnDuration,
                dropDistance: spec.spawnDropDistance,
                clusterIndex: event.clusterIndex,
                effectColor: spec.effectColor,
                topClampBuffer: 0.75,
                clusterSize
            });

            store.enemies.push(enemy);
            store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
            spawnedThisCluster++;

            store.activeEffects.push(createEffect('spawnTeleport', enemy.x, enemy.spawnTargetY ?? enemy.y, enemy.r || 18, {
                duration: (enemy.spawnDuration || 0.6) + 0.25,
                color: spec.effectColor,
                clusterIndex: event.clusterIndex,
                clusterSize
            }));
        });

        if (spawnedThisCluster === 0) {
            const fallback = spawnEnemy('drone', { x: centerX, y: -140 });
            if (fallback) {
                applySpawnSpecToEnemy(fallback, { lateGameScaling: 1 });
                activateSpawnIntro(fallback, {
                    duration: 0.6,
                    dropDistance: 110,
                    clusterIndex: event.clusterIndex,
                    effectColor: '#7fd5ff',
                    topClampBuffer: 0.75,
                    clusterSize
                });
                store.enemies.push(fallback);
                store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
                store.world.lastSpawnFallback = true;
                store.activeEffects.push(createEffect('spawnTeleport', fallback.x, fallback.spawnTargetY ?? fallback.y, fallback.r || 14, {
                    duration: (fallback.spawnDuration || 0.6) + 0.25,
                    color: '#7fd5ff',
                    clusterIndex: event.clusterIndex,
                    clusterSize,
                    fallback: true
                }));
            }
        }
    }

    function applySpawnSpecToEnemy(enemy, spec) {
        if (spec.lateGameScaling && spec.lateGameScaling > 1) {
            enemy.hp *= spec.lateGameScaling;
            enemy.hpMax *= spec.lateGameScaling;
            enemy.damageMult = (enemy.damageMult || 1) * spec.lateGameScaling;
        }
        if (spec.props && spec.props.damageMult !== undefined) {
            enemy.damageMult = spec.props.damageMult;
        }
        enemy.baseContactDamage = spec.baseContactDamage ?? enemy.baseContactDamage ?? enemy.contactDamage ?? 8;
        enemy.contactDamage = enemy.baseContactDamage * (enemy.damageMult || 1);
        if (typeof spec.onSpawn === 'function') {
            try {
                spec.onSpawn(enemy);
            } catch (err) {
                console.warn('Spawn spec hook failed', err);
            }
        }
    }

    function activateSpawnIntro(enemy, opts = {}) {
        const duration = opts.duration ?? enemy.spawnDuration ?? (0.6 + Math.random() * 0.2);
        const dropDistance = opts.dropDistance ?? enemy.spawnDropDistance ?? (80 + Math.random() * 70);
        const existingTarget = enemy.spawnTargetY !== undefined ? enemy.spawnTargetY : enemy.y;
        const targetY = opts.targetY ?? (enemy.spawnTargetY !== undefined ? existingTarget : existingTarget + dropDistance);
        const startY = targetY - dropDistance;

        enemy.spawnPhase = 'teleport';
        enemy.spawnDuration = duration;
        enemy.spawnTimer = duration;
        enemy.spawnTargetY = targetY;
        enemy.spawnStartY = startY;
        enemy.spawnOpacity = 0;
        enemy.spawnEffectColor = opts.effectColor ?? enemy.spawnEffectColor;
        enemy.spawnClusterIndex = opts.clusterIndex ?? enemy.spawnClusterIndex ?? 0;
        enemy.spawnClusterSize = opts.clusterSize ?? enemy.spawnClusterSize ?? 1;
        enemy.spawnIntroGlow = opts.glowStrength ?? enemy.spawnIntroGlow ?? 1;
        enemy.topClampDelay = Math.max(enemy.topClampDelay || 0, duration + (opts.topClampBuffer ?? 0.5));
        enemy.fireT = Math.max(enemy.fireT || 0, duration + (opts.fireDelayBuffer ?? 0.25));
        enemy.y = startY;
    }

    function registerEnemyHit(enemy, impact = {}) {
        if (!enemy || enemy.dead) return;

        const duration = impact.duration ?? enemy.hitPulseDuration ?? 0.22;
        enemy.hitPulseDuration = duration;
        enemy.hitPulseTimer = duration;

        const shakeIntensity = impact.shakeIntensity ?? 0;
        if (shakeIntensity > 0) {
            const shakeDuration = Math.max(impact.shakeDuration ?? 0.16, 0);
            enemy.hitShakeDuration = Math.max(enemy.hitShakeDuration || 0, shakeDuration);
            enemy.hitShakeTimer = Math.max(enemy.hitShakeTimer || 0, shakeDuration);
            enemy.hitShakeIntensity = Math.max(enemy.hitShakeIntensity || 0, shakeIntensity);
        }

        if (impact.slowFactor !== undefined && impact.slowFactor < 1) {
            const slowDuration = Math.max(impact.slowDuration ?? 0.12, 0);
            if (slowDuration > 0) {
                enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, impact.slowFactor);
                enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
            }
        }

        const strength = impact.knockbackStrength ?? 140;
        if (strength > 0) {
            const angle = impact.angle ?? 0;
            const vx = Math.cos(angle) * strength;
            const vy = Math.sin(angle) * strength;
            const knockDuration = impact.knockbackDuration ?? 0.1;

            if (!enemy.knockback || enemy.knockback.type === 'hitReaction') {
                enemy.knockback = {
                    vx,
                    vy,
                    duration: knockDuration,
                    type: 'hitReaction'
                };
            } else if (enemy.knockback && enemy.knockback.vx !== undefined && enemy.knockback.type !== 'maraLaunch' && enemy.knockback.type !== 'jugCharge') {
                enemy.knockback.vx += vx * 0.35;
                enemy.knockback.vy += vy * 0.35;
                enemy.knockback.duration = Math.max(enemy.knockback.duration || 0, knockDuration * 0.8);
            }
        } else if (strength === 0 && enemy.knockback && enemy.knockback.type === 'hitReaction') {
            enemy.knockback = null;
        }

        if (impact.effect !== false) {
            store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, enemy.r || 16, {
                angle: impact.angle ?? 0,
                strength,
                crit: impact.crit || false
            }));
        }
    }

    function computeBeefChargeContext(p) {
        let impactRadius = 80;
        if (p.skillTree && p.skillTree.juggernaut) impactRadius = 120;
        if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) impactRadius = 160;
        if (p.beefExplosionRadius) impactRadius *= p.beefExplosionRadius;
        if (p.subclass === 'juggernaut') impactRadius = Math.max(impactRadius, 120);

        let baseDamage = 80;
        if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) baseDamage = 150;
        if (p.beefChargeDamage) baseDamage *= p.beefChargeDamage;
        if (p.beefExplosionDamage) baseDamage *= p.beefExplosionDamage;

        const damageTags = p.subclass === 'juggernaut' ? ['fire', 'explosive'] : ['kinetic', 'concussive'];

        const hasJuggernautSkills = (p.skillTree && p.skillTree.juggernaut) || p.subclass === 'juggernaut' ||
            (p.skillTree && (p.skillTree.juggernaut_charge_power || p.skillTree.juggernaut_charge_mastery ||
             p.skillTree.juggernaut_heavy_armor || p.skillTree.juggernaut_unstoppable || p.skillTree.juggernaut_enhanced));

        const chainDamageBonus = p.beefChainDamageBonus || (p.beefChainMode ? 1.25 : 1);
        const chainRadiusScale = p.beefChainMode ? 0.85 : 1;

        return {
            impactRadius,
            baseDamage,
            damageTags,
            hasJuggernautSkills,
            explosionSound: hasJuggernautSkills ? 'charge' : 'beefCharge',
            knockbackBase: 250,
            doubleHitMultiplier: p.marauderDoubleHitBonus || 2.0,
            chainDamageBonus,
            chainRadiusScale
        };
    }

    function getBeefChargeTargetPosition(segment) {
        if (!segment) return { x: 0, y: 0 };
        const enemy = segment.enemy;
        if (enemy && !enemy.dead) {
            segment.fallbackX = enemy.x;
            segment.fallbackY = enemy.y;
            return { x: enemy.x, y: enemy.y };
        }
        return { x: segment.fallbackX, y: segment.fallbackY };
    }

    function findClosestEnemyInRange(origin, potentialTargets, rangeSq, excludeSet = new Set()) {
        let best = null;
        let bestDistSq = rangeSq;
        potentialTargets.forEach(enemy => {
            if (!enemy || enemy.dead || excludeSet.has(enemy) || enemy.stunTimer > 0) return;
            const dx = enemy.x - origin.x;
            const dy = enemy.y - origin.y;
            const distSq = dx * dx + dy * dy;
            if (distSq < bestDistSq) {
                bestDistSq = distSq;
                best = enemy;
            }
        });
        return best;
    }

    function buildBeefChargePlan(p, primaryEnemy, potentialTargets) {
        if (!primaryEnemy) return null;

        const context = computeBeefChargeContext(p);
        const origin = { x: p.x, y: p.y };
        const rangeSq = 150 * 150;
        const segments = [];
        const used = new Set();

        const pushEnemySegment = (enemy, label) => {
            if (!enemy) return;
            segments.push({
                enemy,
                fallbackX: enemy.x,
                fallbackY: enemy.y,
                doImpact: true,
                label
            });
            used.add(enemy);
        };

        pushEnemySegment(primaryEnemy, 'primary');

        if (p.beefChainMode && p.beefMaxCharges > 1) {
            let anchor = primaryEnemy;
            for (let i = 1; i < p.beefMaxCharges; i++) {
                const reference = (anchor && !anchor.dead)
                    ? { x: anchor.x, y: anchor.y }
                    : (segments.length ? { x: segments[segments.length - 1].fallbackX, y: segments[segments.length - 1].fallbackY } : origin);
                const next = findClosestEnemyInRange(reference, potentialTargets, rangeSq, used);
                if (!next) break;
                pushEnemySegment(next, 'chain');
                anchor = next;
            }
        }

        if (!segments.length) return null;

        const returnToOrigin = !p.beefChainMode && p.subclass !== 'marauder';
        if (returnToOrigin) {
            segments.push({
                enemy: null,
                fallbackX: origin.x,
                fallbackY: origin.y,
                doImpact: false,
                label: 'return'
            });
        }

        return {
            context,
            origin,
            segments,
            chainDelay: p.beefChainMode ? 0.08 : 0,
            recoveryDelay: returnToOrigin ? 0.1 : 0.12,
            segmentDuration: 0.24 / Math.max(p.beefChargeSpeed || 1.35, 0.6),
            returnToOrigin
        };
    }

    function spawnBeefChargeTrail(startX, startY, targetX, targetY, options = {}) {
        store.activeEffects.push(createEffect('beefCharge', { x: startX, y: startY }, { x: targetX, y: targetY }, undefined, options));
    }

    function resolveBeefChargeImpact(p, context, impactX, impactY, options = {}) {
        const segment = options.segment || null;
        const segmentLabel = segment ? segment.label : 'primary';
        const segmentIndex = options.index ?? 0;
        let impactRadius = context.impactRadius;
        if (segmentLabel === 'chain' && context.chainRadiusScale) {
            impactRadius *= context.chainRadiusScale;
        }

        if (context.hasJuggernautSkills) {
            playSound(context.explosionSound);
            explode(impactX, impactY, false, true);
        } else {
            playSound(context.explosionSound);
        }

        store.activeEffects.push(createEffect('marauderImpact', impactX, impactY, impactRadius, {
            subclass: p.subclass,
            segmentLabel,
            segmentIndex
        }));

        const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        if (!p.marauderHitTargets) p.marauderHitTargets = new Set();

        let lastEnemyHit = null;
    const radiusSq = impactRadius * impactRadius;

        potentialTargets.forEach(e => {
            if (!e || e.dead) return;
            const dx = e.x - impactX;
            const dy = e.y - impactY;
            const distSq = dx * dx + dy * dy;
            if (distSq > radiusSq) return;

            let damageMultiplier = 1;
            if (segmentLabel === 'chain') {
                if (context.chainDamageBonus) damageMultiplier *= context.chainDamageBonus;
                if (p.beefChainBonus) damageMultiplier *= p.beefChainBonus;
            }
            let chargeDmg = context.baseDamage * damageMultiplier * p.dmgMult;
            const enemyId = e.id || `${e.x}_${e.y}_${e.type}`;
            let isDoubleHit = false;

            if (p.subclass === 'marauder') {
                if (p.marauderHitTargets.has(enemyId)) {
                    isDoubleHit = true;
                    const multiplier = context.doubleHitMultiplier || 2.0;
                    if (e === store.boss || e.type === 'void_champion') {
                        chargeDmg *= multiplier * 1.5;
                        e.stunTimer = 8.0;
                        e.marauderMarked = true;
                        announce('CHAMPION DEVASTATION!');
                    } else {
                        e.isFlattened = true;
                        e.flattenedTime = performance.now();
                        e.v = 0;
                        e.vx = 0;
                        e.vy = 0;
                        e.hp = Math.min(e.hp, 1);
                        e.stunTimer = Math.max(e.stunTimer || 0, 999);
                        e.fireRateChance = 0;
                        e.flattenScale = { x: 2.0, y: 0.1 };
                        const bonusText = multiplier >= 3.0 ? 'ELITE FLATTEN!' : 'MARAUDER FLATTEN!';
                        announce(bonusText);
                    }
                    setTimeout(() => p.marauderHitTargets.delete(enemyId), 100);
                } else {
                    p.marauderHitTargets.add(enemyId);
                    setTimeout(() => p.marauderHitTargets.delete(enemyId), 3000);
                }
            }

            const knockbackAngle = Math.atan2(e.y - impactY, e.x - impactX);
            const vulnResult = applySubclassVulnerability(e, chargeDmg, {
                player: p,
                subclass: p.subclass,
                damageTags: context.damageTags,
                source: 'beefCharge',
                knockbackAngle,
                baseDamage: chargeDmg
            });
            chargeDmg = vulnResult.damage;

            e.hp -= chargeDmg;
            if (!isDoubleHit) {
                e.stunTimer = Math.max(e.stunTimer || 0, 2.5);
            }

            if (p.vampirism > 0) {
                let healAmount = chargeDmg * p.vampirism;
                healAmount = Math.max(healAmount, 1);
                healAmount = Math.min(healAmount, 8);
                p.hp = Math.min(p.hpMax, p.hp + healAmount);
            }

            let knockbackForce = context.knockbackBase * (segmentLabel === 'chain' ? Math.max(0.85, damageMultiplier) : 1);
            if (p.beefChargeKnockback) {
                knockbackForce *= p.beefChargeKnockback;
            }
            if (!e.knockback || e.knockback.type !== 'maraLaunch') {
                e.knockback = {
                    vx: Math.cos(knockbackAngle) * knockbackForce,
                    vy: Math.sin(knockbackAngle) * knockbackForce,
                    duration: 0.3,
                    type: 'maraLaunch'
                };
            }

            lastEnemyHit = e;
        });

        return {
            x: impactX,
            y: impactY,
            enemy: lastEnemyHit
        };
    }

    function stepPlayer(dt) {
        const p = store.player;
        if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0 && p.beefChargeState !== 'ready') {
            const plan = p.beefChargePlan;
            if (!plan || !plan.segments || plan.segments.length === 0) {
                p.beefChargeState = 'ready';
                p.beefChargePlan = null;
                p.beefChargeT = 0;
                p.beefImpactDelay = 0;
                p.isInvincible = false;
            } else if (p.beefChargeState === 'charging') {
                const segmentIndex = Math.min(p.beefChargeSegmentIndex, plan.segments.length - 1);
                const segment = plan.segments[segmentIndex];
                if (!segment) {
                    p.beefChargeState = 'ready';
                    p.beefChargePlan = null;
                    p.beefChargeT = 0;
                    p.isInvincible = false;
                } else {
                    if (segment.startX === undefined) {
                        segment.startX = p.x;
                        segment.startY = p.y;
                    }
                    const targetPos = getBeefChargeTargetPosition(segment);
                    const startX = segment.startX;
                    const startY = segment.startY;
                    const progress = Math.min((p.beefChargeT + dt) / plan.segmentDuration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    p.x = startX + (targetPos.x - startX) * eased;
                    p.y = startY + (targetPos.y - startY) * eased;
                    p.beefChargeT += dt;
                    p.isInvincible = true;
                    const distSq = (targetPos.x - p.x) * (targetPos.x - p.x) + (targetPos.y - p.y) * (targetPos.y - p.y);
                    if (progress >= 1 || distSq < 9) {
                        p.x = targetPos.x;
                        p.y = targetPos.y;
                        const impactResult = segment.doImpact
                            ? resolveBeefChargeImpact(p, plan.context, targetPos.x, targetPos.y, {
                                segment,
                                index: p.beefChargeSegmentIndex
                            })
                            : { x: targetPos.x, y: targetPos.y, enemy: null };
                        if (segment.doImpact || !p.beefLastImpact) {
                            p.beefLastImpact = impactResult;
                        }
                        p.beefChargeSegmentIndex++;
                        p.beefChargeT = 0;
                        if (p.beefChargeSegmentIndex < plan.segments.length) {
                            p.beefImpactDelay = plan.chainDelay;
                            if (plan.chainDelay > 0) {
                                p.beefChargeState = 'impactPause';
                            } else {
                                const nextSegment = plan.segments[p.beefChargeSegmentIndex];
                                nextSegment.startX = p.x;
                                nextSegment.startY = p.y;
                                const nextTarget = getBeefChargeTargetPosition(nextSegment);
                                p.beefChargeOrigin = { x: p.x, y: p.y };
                                p.beefChargeTarget = { x: nextTarget.x, y: nextTarget.y };
                                spawnBeefChargeTrail(p.x, p.y, nextTarget.x, nextTarget.y, {
                                    subclass: p.subclass,
                                    segmentIndex: p.beefChargeSegmentIndex,
                                    segmentLabel: nextSegment.label,
                                    rangeOverride: plan.context.impactRadius
                                });
                            }
                        } else {
                            p.beefImpactDelay = plan.recoveryDelay;
                            p.beefChargeState = 'recovering';
                            p.beefChargePlan = null;
                            p.isInvincible = false;
                        }
                    }
                }
            } else if (p.beefChargeState === 'impactPause') {
                p.beefImpactDelay -= dt;
                p.isInvincible = true;
                if (p.beefImpactDelay <= 0) {
                    if (plan && p.beefChargeSegmentIndex < plan.segments.length) {
                        const nextSegment = plan.segments[p.beefChargeSegmentIndex];
                        nextSegment.startX = p.x;
                        nextSegment.startY = p.y;
                        const nextTarget = getBeefChargeTargetPosition(nextSegment);
                        p.beefChargeOrigin = { x: p.x, y: p.y };
                        p.beefChargeTarget = { x: nextTarget.x, y: nextTarget.y };
                        spawnBeefChargeTrail(p.x, p.y, nextTarget.x, nextTarget.y, {
                            subclass: p.subclass,
                            segmentIndex: p.beefChargeSegmentIndex,
                            segmentLabel: nextSegment.label,
                            rangeOverride: plan.context.impactRadius
                        });
                        p.beefChargeState = 'charging';
                        p.beefChargeT = 0;
                    } else {
                        p.beefChargeState = 'recovering';
                        p.beefImpactDelay = plan ? plan.recoveryDelay : 0.12;
                        p.isInvincible = false;
                    }
                }
            } else if (p.beefChargeState === 'recovering') {
                p.beefImpactDelay -= dt;
                if (p.beefImpactDelay <= 0) {
                    p.beefChargeState = 'ready';
                    p.beefChargePlan = null;
                    p.beefChargeT = 0;
                    p.beefImpactDelay = 0;
                    p.isInvincible = false;
                }
            }
        } else {
            // MOVEMENT LOGIC
            if (document.body.classList.contains('mobile-controls-active')) {
                // Joystick Movement
                const moveSpeed = p.speed;
                p.x += joystickState.input.x * moveSpeed * dt;
                p.y += joystickState.input.y * moveSpeed * dt;
                p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
            } else {
                // Mouse Movement (Original Logic)
                const vx = mouse.x - p.x, vy = mouse.y - p.y;
                const dist = Math.sqrt(vx * vx + vy * vy);
                if (dist < 15) {
                    p.x = mouse.x;
                    p.y = mouse.y;
                } else {
                    const accelFactor = 0.0125;
                    p.x += vx * p.speed * dt * accelFactor;
                    p.y += vy * p.speed * dt * accelFactor;
                }
                p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
            }
        }
        if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0) {
            if (p.beefCharges < p.beefMaxCharges) {
                if (p.beefChargeCooldown > 0) {
                    p.beefChargeCooldown = Math.max(0, p.beefChargeCooldown - dt);
                }
                if (p.beefChargeCooldown <= 0) {
                    p.beefCharges++;
                    if (p.beefCharges < p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                }
            }

            const shouldCharge = p.isRequestingCharge || !document.body.classList.contains('mobile-controls-active');

            if (p.beefChargeState === 'ready' && p.beefCharges > 0 && shouldCharge) {
                p.isRequestingCharge = false;
                const chargeRadius = 120;
                let closestEnemy = null;
                let closestDistSq = chargeRadius * chargeRadius;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : [...store.enemies];
                potentialTargets.forEach(enemy => {
                    if (!enemy || enemy.dead || enemy.stunTimer > 0) return;
                    const dx = enemy.x - p.x;
                    const dy = enemy.y - p.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) {
                        closestDistSq = distSq;
                        closestEnemy = enemy;
                    }
                });

                if (closestEnemy) {
                    if (p.beefCharges === p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                    p.beefCharges = Math.max(0, p.beefCharges - 1);

                    const plan = buildBeefChargePlan(p, closestEnemy, potentialTargets);
                    if (plan) {
                        plan.primaryEnemy = closestEnemy;
                        p.beefChargePlan = plan;
                        p.beefChargeSegmentIndex = 0;
                        p.beefChargeState = 'charging';
                        p.beefChargeT = 0;
                        p.beefImpactDelay = 0;
                        p.isInvincible = true;
                        p.beefLastImpact = null;

                        const firstSegment = plan.segments[0];
                        firstSegment.startX = p.x;
                        firstSegment.startY = p.y;
                        const firstTarget = getBeefChargeTargetPosition(firstSegment);
                        p.beefChargeOrigin = { x: p.x, y: p.y };
                        p.beefChargeTarget = { x: firstTarget.x, y: firstTarget.y };
                        spawnBeefChargeTrail(p.x, p.y, firstTarget.x, firstTarget.y, {
                            subclass: p.subclass,
                            segmentIndex: p.beefChargeSegmentIndex,
                            segmentLabel: firstSegment.label,
                            rangeOverride: plan.context.impactRadius
                        });

                        if ((p.beefDoubleCharge || (p.skillTree && p.skillTree.combo_charge)) && p.beefCharges > 0) {
                            p.beefQueuedCharge = {
                                delay: 0.4,
                                fallback: { x: firstTarget.x, y: firstTarget.y },
                                targetEnemy: closestEnemy
                            };
                        } else {
                            p.beefQueuedCharge = null;
                        }
                    } else {
                        p.beefChargeState = 'ready';
                        p.isInvincible = false;
                    }
                }
            } else if (p.beefChargeState !== 'ready') {
                p.isRequestingCharge = false;
            }

            if (p.beefQueuedCharge) {
                p.beefQueuedCharge.delay -= dt;
                if (p.beefQueuedCharge.delay <= 0) {
                    if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                        const potentialTargets = store.boss ? [...store.enemies, store.boss] : [...store.enemies];
                        let comboEnemy = p.beefQueuedCharge.targetEnemy;
                        if (!comboEnemy || comboEnemy.dead) {
                            comboEnemy = findClosestEnemyInRange(p.beefQueuedCharge.fallback, potentialTargets, 180 * 180);
                        }
                        if (comboEnemy) {
                            if (p.beefCharges === p.beefMaxCharges) {
                                p.beefChargeCooldown = 8;
                            }
                            p.beefCharges = Math.max(0, p.beefCharges - 1);
                            const comboPlan = buildBeefChargePlan(p, comboEnemy, potentialTargets);
                            if (comboPlan) {
                                comboPlan.primaryEnemy = comboEnemy;
                                p.beefChargePlan = comboPlan;
                                p.beefChargeSegmentIndex = 0;
                                p.beefChargeState = 'charging';
                                p.beefChargeT = 0;
                                p.beefImpactDelay = 0;
                                p.isInvincible = true;
                                p.beefLastImpact = null;

                                const firstSegment = comboPlan.segments[0];
                                firstSegment.startX = p.x;
                                firstSegment.startY = p.y;
                                const firstTarget = getBeefChargeTargetPosition(firstSegment);
                                p.beefChargeOrigin = { x: p.x, y: p.y };
                                p.beefChargeTarget = { x: firstTarget.x, y: firstTarget.y };
                                spawnBeefChargeTrail(p.x, p.y, firstTarget.x, firstTarget.y, {
                                    subclass: p.subclass,
                                    segmentIndex: p.beefChargeSegmentIndex,
                                    segmentLabel: firstSegment.label,
                                    rangeOverride: comboPlan.context ? comboPlan.context.impactRadius : undefined
                                });
                                p.beefQueuedCharge = null;
                            }
                        }
                    }

                    if (p.beefQueuedCharge) {
                        p.beefQueuedCharge.delay = 0.08;
                    }
                }
            }
        } else if (p.pilotGenome === 'rocketman' && p.hasFirewall) {
            // Rocketman afterburner system
            if (!p.flameWallInitialized) {
                const baseCooldown = p.flameWallCooldownMax || p.firewallCooldown || 10;
                p.flameWallCooldownMax = baseCooldown;
                const immediateCast = Math.random() < 0.5;
                p.flameWallCooldown = immediateCast ? 0 : baseCooldown;
                p.flameWallCharge = immediateCast ? 1 : 0;
                p.flameWallInitialized = true;
            }

            const cooldownMax = p.flameWallCooldownMax || p.firewallCooldown || 10;

            if (p.flameWallCooldown > 0) {
                p.flameWallCooldown = Math.max(0, p.flameWallCooldown - dt);
            }

            const cooldownProgress = cooldownMax > 0 ? 1 - (p.flameWallCooldown / cooldownMax) : 1;
            p.flameWallCharge = cooldownProgress;

            // Start afterburner sequence when ready
            if (p.flameWallCooldown <= 0 && !p.afterburnerActive && p.flameWallActiveT <= 0) {
                p.afterburnerActive = true;
                p.afterburnerTimer = p.afterburnerMaxDuration;
                p.afterburnerParticleTimer = 0;
            }



            // Handle afterburner phase - small particles from rear boosters
            if (p.afterburnerActive) {
                p.afterburnerTimer -= dt;
                p.afterburnerParticleTimer -= dt;

                // Spawn small flame particles from rear boosters
                if (p.afterburnerParticleTimer <= 0) {
                    p.afterburnerParticleTimer = 0.08; // Fast particle spawn rate
                    
                    // Create small particles from left and right boosters at rear of ship
                    for (let side = -1; side <= 1; side += 2) {
                        const particle = new FlameParticle(
                            p.x + side * 12, // Left/right booster positions
                            p.y + 20,        // Behind the ship
                            null
                        );
                        // Make afterburner particles smaller and shorter-lived
                        particle.size *= 0.6;
                        particle.baseSize *= 0.6;
                        particle.life *= 0.4;
                        particle.maxLife *= 0.4;
                        particle.visualLife *= 0.4;
                        particle.maxVisualLife *= 0.4;
                        particle.damage *= 0.3; // Less damage than main flame wall
                        // Make particles move mostly backward with slight spread
                        particle.vx = (Math.random() - 0.5) * 20 + side * 15;
                        particle.vy = 30 + Math.random() * 20; // Moving backward from ship
                        store.flameParticles.push(particle);
                    }
                }

                // Transition to main flame wall after afterburner duration
                if (p.afterburnerTimer <= 0) {
                    p.afterburnerActive = false;
                    p.flameWallActiveT = 0.6;
                    p.flameWallCooldown = cooldownMax || 10;
                    p.flameWallCharge = 1;
                }
            }

            // Main flame wall from nose (original system)
            if (p.flameWallActiveT > 0) {
                p.flameWallActiveT -= dt;
                p.flameWallCharge = Math.max(0, p.flameWallCharge - dt * 3.2);
                
                for (let i = 0; i < 2; i++) {
                    let attachedEnemy = null;
                    let closestDistSq = Infinity;
                    store.enemies.forEach(enemy => {
                        const distSq = (enemy.x - p.x) * (enemy.x - p.x) + (enemy.y - (p.y + 10)) * (enemy.y - (p.y + 10));
                        if (distSq < 100 * 100 && distSq < closestDistSq) {
                            closestDistSq = distSq;
                            attachedEnemy = enemy;
                        }
                    });
                    store.flameParticles.push(new FlameParticle(p.x, p.y + 10, attachedEnemy));
                }
            }
        } else if (p.pilotGenome === 'voidmancer') {
            if (p.hasChainLightning || p.hasHybridVoid) {
                p.chainLightningCooldown -= dt;
                if (p.chainLightningCooldown <= 0) { 
                    fireChainLightning(); 
                    // Set cooldown based on stormstriker level - more bolts = faster alternation
                    if (p.stormstrikerLevel >= 3) {
                        p.chainLightningCooldown = 0.375; // 4-bolt rotation: quadruple fire rate
                    } else if (p.stormstrikerLevel >= 2) {
                        p.chainLightningCooldown = 0.75; // Alternating bolts: double fire rate
                    } else {
                        p.chainLightningCooldown = 1.5; // Single bolt: normal rate
                    }
                }
            }
            
            // Voidmancer base laser beam system
            if (p.hasVoidLaser) {
                stepVoidLaser(dt); // Regular seeking lasers for Phasestriker
            }
            
            // Wiper lasers work for both Phasestriker and Stormcaller
            if (p.wiperLasers) {
                stepWiperLasers(dt); // Ultimate ability for both subclasses
            }
        }
        if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
        if (p.hasBeefClone && store.beefClone) { store.beefClone.x = p.x + 50; store.beefClone.y = p.y + 40; }
        p.fireT -= dt;
        if (p.fireT <= 0 && !p.empDisabled) { firePlayer(); p.fireT = p.fireRate; }
        
        // Separate flamethrower system (unaffected by overclock)
        if (p.flamethrowerLevel > 0 && !p.empDisabled) {
            p.flamethrowerT -= dt;
            if (p.flamethrowerT <= 0) {
                fireFlamethrower();
                p.flamethrowerT = 0.18; // Fixed fire rate for lava chunks
            }
        }

        if (p.starCannonLevel > 0 && !p.empDisabled) {
            p.starCannonTimer -= dt;
            if (p.starCannonTimer <= 0) {
                fireStarCannon();
                p.starCannonTimer = STAR_CANNON_COOLDOWN;
            }
        }
        
        // Homing Missile system (from powerup)
        if (p.powerupTimers['missile'] && !p.empDisabled) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });
                if (closest) {
                    const isRocketman = p.pilotGenome === 'rocketman';
                    let baseMissileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                    let baseSpeed = 200;
                    
                    // Apply stealth rocket upgrades
                    if (p.stealthRockets) {
                        baseMissileDmg *= (p.stealthRocketDamage || 1.25);
                        baseSpeed *= (p.stealthRocketSpeed || 1.5);
                    }
                    
                    const volleySize = p.missileVolley || 2;
                    
                    for (let i = 0; i < volleySize; i++) {
                        const spreadAngle = (i - (volleySize - 1) / 2) * 0.2;
                        const dx = closest.x - p.x;
                        const dy = closest.y - p.y;
                        const baseAngle = Math.atan2(dy, dx);
                        const finalAngle = baseAngle + spreadAngle;
                        
                        const missile = {
                            x: p.x, y: p.y - 10,
                            vx: Math.cos(finalAngle) * baseSpeed,
                            vy: Math.sin(finalAngle) * baseSpeed,
                            speed: baseSpeed, turnRate: 4.5,
                            target: closest, life: 0,
                            dmg: baseMissileDmg,
                            cluster: isRocketman && p.missileCluster,
                            pierce: isRocketman ? (p.missilePierce || 0) : 0,
                            isIceman: false,
                            isStealth: p.stealthRockets || false
                        };
                        store.missiles.push(missile);
                    }
                    playSound('shoot');
                }
            }
        }
        
        // Shield recharge system with damage delay
        if (p.shieldMax > 0 && p.shield < p.shieldMax) {
            if (p.shieldRechargeDelay > 0) {
                // Still in delay period, count down
                p.shieldRechargeDelay -= dt;
                p.shieldRecharging = false;
            } else {
                // Delay period over, start/continue recharging
                p.shieldRecharging = true;
                p.shield = Math.min(p.shieldMax, p.shield + (p.shieldMax / 6) * dt);
            }
        } else {
            p.shieldRecharging = false;
        }
        
        for (const key in p.powerupTimers) {
            const timer = p.powerupTimers[key];
            timer.remaining -= dt;
            if (timer.remaining <= 0) {
                if (key === 'drones') {
                    store.drones = [];
                } else if (key === 'void_core') {
                    const prevDmgMult = p.voidCoreDmgMult || 1;
                    const prevFireRateMult = p.voidCoreFireRateMult || 1;
                    p.dmgMult = p.dmgMult / prevDmgMult;
                    p.fireRate = p.fireRate * prevFireRateMult;
                    p.voidCoreStacks = 0;
                    p.voidCoreDmgMult = 1;
                    p.voidCoreFireRateMult = 1;
                }
                delete p.powerupTimers[key];
            }
        }
        if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
        if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { activateGravityWell(); p.voidBeamCooldown = 30; } }
        if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { activateLazarus(); p.lazarusBeamCooldown = 30 / (p.upgradeLevels.lazarus_beam > 0 ? 2 : 1) ; } }
        if (store.cheatInvincibilityCooldown > 0) store.cheatInvincibilityCooldown -= dt;
        if (store.cheatDogHealCooldown > 0) store.cheatDogHealCooldown -= dt;

        if (p.x < 50 && p.y < 50 && store.cheatInvincibilityCooldown <= 0) {
            store.cheatsUsed = true; p.isInvincible = true; p.cheatMultishotBonus = 2; announce('TEST: INVINCIBILITY ACTIVE');
            setTimeout(() => { p.isInvincible = false; p.cheatMultishotBonus = 0; announce('TEST: INVINCIBILITY ENDS'); store.cheatInvincibilityCooldown = 10; }, 15000);
            store.cheatInvincibilityCooldown = 15 + 10;
        }
        if (p.x > W - 50 && p.y < 50 && store.cheatDogHealCooldown <= 0) {
            store.cheatsUsed = true; p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.20);
            if (!p.hasHounds) { p.hasHounds = true; }
            let houndsToAdd = Math.min(2, 4 - store.hounds.length);
            if (houndsToAdd > 0) {
                const existingSides = new Set(store.hounds.map(h => h.side)); const potentialSides = [-1, 1, -2, 2];
                for (const side of potentialSides) { if (houndsToAdd > 0 && !existingSides.has(side)) { store.hounds.push(createHound(side)); houndsToAdd--; } }
            }
            store.cheatDogHealCooldown = 10; announce('TEST: HEAL & HOUNDS');
        }
        
        // Handle poison effects
        if (p.isPoisoned && performance.now() > p.poisonEndTime) {
            p.isPoisoned = false;
            p.moveSpeed = 100; // Reset to base speed
        }
        
        // Check poison puddle collisions
        if (store.poisonPuddles) {
            store.poisonPuddles.forEach(puddle => {
                const dx = p.x - puddle.x;
                const dy = p.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < puddle.r + p.r) {
                    // Player is in poison puddle - apply damage and effects
                    if (!p.lastPuddleDamageTime || performance.now() - p.lastPuddleDamageTime > 500) {
                        takeDamage(puddle.damage);
                        p.lastPuddleDamageTime = performance.now();
                        
                        // Apply poison debuff
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 3000; // 3 second poison from puddle
                        p.moveSpeed = Math.max(p.moveSpeed * 0.8, 60); // Slow player more
                    }
                }
            });
        }

        // Check mech oil/fuel puddle collisions
        if (store.mechPuddles && store.mechPuddles.length > 0) {
            store.mechPuddles.forEach(puddle => {
                // Calculate current radius with shrinking effect
                const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
                const currentRadius = puddle.r * Math.max(0.3, lifePercent);
                
                const dx = p.x - puddle.x;
                const dy = p.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < currentRadius + p.r) {
                    // Player is in hazardous puddle - apply damage and burning effect
                    if (!p.lastMechPuddleDamageTime || performance.now() - p.lastMechPuddleDamageTime > 400) {
                        // console.log('Player in mech puddle! Taking', puddle.damage, 'damage');
                        takeDamage(puddle.damage);
                        p.lastMechPuddleDamageTime = performance.now();
                        
                        // Apply burning/slowing effect
                        p.isBurning = true;
                        p.burnEndTime = performance.now() + 2500; // 2.5 second burn effect
                        
                        // Create burning particle effect
                        for (let i = 0; i < 3; i++) {
                            store.flameParticles.push({
                                x: p.x + (Math.random() - 0.5) * 30,
                                y: p.y + (Math.random() - 0.5) * 30,
                                vx: (Math.random() - 0.5) * 100,
                                vy: -Math.random() * 150,
                                life: 1 + Math.random() * 0.5,
                                maxLife: 1 + Math.random() * 0.5,
                                r: 3 + Math.random() * 4
                            });
                        }
                    }
                }
            });
        }
    }
    function stepPowerups(dt) {
        const p = store.player;
        store.powerups.forEach(powerup => {
            // Handle powerup movement (for Trap King falling powerups)
            if (powerup.vx !== undefined || powerup.vy !== undefined) {
                powerup.x += (powerup.vx || 0) * dt;
                powerup.y += (powerup.vy || 0) * dt;
                
                // Handle powerup lifetime
                if (powerup.life !== undefined) {
                    powerup.life -= dt;
                    if (powerup.life <= 0) {
                        powerup.dead = true;
                        return;
                    }
                }
                
                // Remove powerups that go off screen
                if (powerup.x < -20 || powerup.x > W + 20 || powerup.y < -20 || powerup.y > H + 20) {
                    powerup.dead = true;
                    return;
                }
            }
            
            if (p.magnetRadius > 0) {
                const dx = p.x - powerup.x;
                const dy = p.y - powerup.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);
                
                // Auto-collect if very close to prevent vibration
                if (dist < p.r + powerup.r + 5) {
                    powerup.dead = true;
                    applyPowerup(powerup.type);
                    return;
                }
                
                if (distSq < p.magnetRadius * p.magnetRadius) {
                    const pullSpeed = 350;
                    powerup.x += (dx / dist) * pullSpeed * dt;
                    powerup.y += (dy / dist) * pullSpeed * dt;
                }
            }

            if (collide(p, powerup)) {
                powerup.dead = true;
                applyPowerup(powerup.type);
            }
        });
    }

    function detonateClusterRocket(m) {
        if (m.dead) return;
        m.dead = true;
        
        // Play cluster sound if this missile is marked for sound
        if (m.playSound) {
            playSound('cluster');
        }
        
        const baseRadius = 70; // Halved from 80
        const explosionRadius = store.player.enhancedClusters ? 120 : baseRadius;
        const chainRadius = 90;
        const microExplosionCount = 5;
        let aoeDmg = m.dmg * .8;
        if (store.player.subclass === 'demolitionist') {
            aoeDmg *= 1.5;  // OPTIONAL: Boost damage for demolitionist
        }
        for (let i = 0; i < microExplosionCount; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.random() * explosionRadius * 0.7;
            const ex = m.x + Math.cos(angle) * dist;
            const ey = m.y + Math.sin(angle) * dist;
            store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
        }
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(e => {
            if (!e.dead) {
                const distSq = (e.x - m.x)**2 + (e.y - m.y)**2;
                if (distSq < explosionRadius**2) {
                    let pulseDmg = aoeDmg;
                    const explosionTags = store.player.subclass === 'demolitionist' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                    const vulnExplosion = applySubclassVulnerability(e, pulseDmg, {
                        subclass: store.player.subclass,
                        player: store.player,
                        damageTags: explosionTags,
                        source: 'clusterDetonation',
                        projectile: m,
                        baseDamage: pulseDmg
                    });
                    pulseDmg = vulnExplosion.damage;
                    e.hp -= pulseDmg;
                    e.hp = Math.max(1, e.hp);
                    
                    // Apply vampirism healing for cluster damage
                    if (store.player.vampirism > 0) {
                        let healAmount = aoeDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for AoE
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for AoE
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            }
        });
        // Remove chain detonation to prevent rockets from exploding each other
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            if (m.chainDetonate && !m.dead) {
                detonateClusterRocket(m);
                return;
            }
            m.life += dt; if (m.life > 6) { m.dead = true; return; }
            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }
            
            // Track movement distance before updating position
            const prevX = m.x, prevY = m.y;
            m.x += m.vx * dt; m.y += m.vy * dt;
            
            // Update travel distance if we have start position
            if (m.startX !== undefined && m.startY !== undefined) {
                m.travelDistance = Math.sqrt((m.x - m.startX)**2 + (m.y - m.startY)**2);
            }
            
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            
            // For cluster rockets, check proximity detonation only when they should explode
            if (m.cluster && !m.pierce) {
                // Original cluster behavior - explode near enemies
                const proxRadiusSq = 15 * 15;
                for (const e of targets) {
                    if (!e.dead && ((m.x - e.x)**2 + (m.y - e.y)**2 < proxRadiusSq)) {
                        detonateClusterRocket(m);
                        return;
                    }
                }
            }
            
            // Handle collision with enemies
            for (const e of targets) {
                if (!e.dead && collide(m, e)) {
                    m.hits = (m.hits || 0) + 1;
                    
                    if (m.cluster && m.pierce > 0) {
                        // Hybrid cluster + piercing: Deal damage, pierce, then set up for delayed explosion
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        const missileTags = store.player.subclass === 'demolitionist' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                        const vulResPierce = applySubclassVulnerability(e, dmg, {
                            subclass: store.player.subclass,
                            player: store.player,
                            damageTags: missileTags,
                            source: 'pierceMissile',
                            projectile: m,
                            baseDamage: dmg
                        });
                        dmg = vulResPierce.damage;
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 6); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        m.pierce--;
                        
                        if (m.pierce <= 0) {
                            // No more pierces left - mark for delayed explosion
                            m.shouldExplodeAfterTravel = true;
                            m.minTravelTimeForExplosion = 0.5; // 0.5 seconds minimum travel time
                            m.travelTimeAfterLastHit = 0;
                        } else {
                            // Find next target for piercing
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else {
                                // No more targets - explode immediately
                                detonateClusterRocket(m);
                            }
                        }
                    } else if (m.cluster) {
                        // Pure cluster rocket - explode immediately
                        detonateClusterRocket(m);
                    } else {
                        // Regular missile logic (non-cluster)
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        const missileDamageTags = store.player.subclass === 'demolitionist' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                        const vulRes = applySubclassVulnerability(e, dmg, {
                            subclass: store.player.subclass,
                            player: store.player,
                            damageTags: missileDamageTags,
                            source: m.cluster ? 'clusterMissile' : 'missileImpact',
                            projectile: m,
                            baseDamage: dmg
                        });
                        dmg = vulRes.damage;
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        if ((store.player.subclass === 'railgunner' || store.player.missilePierce > 0) && m.pierce > 0) {
                            m.pierce--;
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else { m.dead = true; }
                        } else if (m.pierce > 0) {
                            m.pierce--;
                        } else {
                            m.dead = true;
                        }
                    }
                    if (m.dead) break;
                }
            }
            
            // Handle delayed explosion for cluster + pierce missiles
            if (m.shouldExplodeAfterTravel) {
                m.travelTimeAfterLastHit += dt;
                if (m.travelTimeAfterLastHit >= m.minTravelTimeForExplosion) {
                    // Check if we're near any enemies to explode
                    const explosionProximity = 60;
                    let shouldExplode = false;
                    for (const e of targets) {
                        if (!e.dead) {
                            const distSq = (m.x - e.x)**2 + (m.y - e.y)**2;
                            if (distSq < explosionProximity * explosionProximity) {
                                shouldExplode = true;
                                break;
                            }
                        }
                    }
                    if (shouldExplode) {
                        detonateClusterRocket(m);
                    }
                }
            }
        });
    }

    function stepLightning(dt) {
        store.lightningBolts.forEach(bolt => {
            bolt.life -= dt;
            if (bolt.life <= 0) { bolt.dead = true; }
        });
    }

    function stepEmpNovas(dt) {
        store.empNovas.forEach(nova => {
            // Expand the nova
            nova.radius += nova.speed * dt;
            if (nova.radius > nova.maxRadius) {
                nova.radius = nova.maxRadius;
            }
            
            // Countdown life
            nova.life -= dt;
            if (nova.life <= 0) {
                nova.dead = true;
                return;
            }
            
            // Check if player is within EMP range
            const dx = store.player.x - nova.x;
            const dy = store.player.y - nova.y;
            const distSq = dx * dx + dy * dy;
            const radiusSq = nova.radius * nova.radius;
            
            if (distSq <= radiusSq) {
                // Player is within EMP range - disable weapons
                store.player.empDisabled = true;
                store.player.empDisabledTimer = 0.5; // Sizzle effect duration
            }
        });
        
        // Update player EMP disabled state
        if (store.player.empDisabledTimer > 0) {
            store.player.empDisabledTimer -= dt;
            if (store.player.empDisabledTimer <= 0) {
                store.player.empDisabled = false;
            }
        }
    }

    function stepLasers(dt) {
        store.lasers.forEach(laser => {
            laser.life -= dt;
            if (laser.life <= 0) { laser.dead = true; return; }
            laser.prevX = laser.x; laser.prevY = laser.y;
            laser.x += laser.vx * dt; laser.y += laser.vy * dt;
            if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                const speed = Math.sqrt(laser.vx**2 + laser.vy**2);
                let newAngle;
                if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                else { newAngle = Math.PI + Math.random() * Math.PI; }
                laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                laser.hitEnemies.clear();
            }
            store.enemies.forEach(e => {
                if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) { 
                    const laserDmg = 1000 * store.player.dmgMult;
                    e.hp -= laserDmg; 
                    laser.hitEnemies.add(e); 

                    registerEnemyHit(e, {
                        angle: Math.atan2(e.y - laser.y, e.x - laser.x),
                        knockbackStrength: 90,
                        knockbackDuration: 0.08
                    });
                    
                    // Track damage dealt for beef shield system
                    if (store.player.pilotGenome === 'beef') {
                        store.player.beefShieldDamageDealt += laserDmg;
                    }
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = laserDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                        healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            });
            if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) { 
                const bossLaserDmg = 500 * store.player.dmgMult;
                store.boss.hp -= bossLaserDmg; 
                laser.hitEnemies.add(store.boss); 

                registerEnemyHit(store.boss, {
                    angle: Math.atan2(store.boss.y - laser.y, store.boss.x - laser.x),
                    knockbackStrength: 70,
                    knockbackDuration: 0.08
                });
                
                // Track damage dealt for beef shield system
                if (store.player.pilotGenome === 'beef') {
                    store.player.beefShieldDamageDealt += bossLaserDmg;
                }
                
                // Apply vampirism healing for laser damage on boss
                if (store.player.vampirism > 0) {
                    let healAmount = bossLaserDmg * store.player.vampirism;
                    healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                    healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                }
            }
        });
    }

    function stepMines(dt) {
        store.mines.forEach(mine => {
            if (mine.dead) return;
            mine.fuse -= dt;
            let detonate = mine.fuse <= 0;
            if (!detonate) {
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                for(const target of targets) { if(!target.dead && collide(mine, target)) { detonate = true; break; } }
            }
            if(detonate) { mine.dead = true; explodeMine(mine); }
        });
    }
    
    function stepFlameParticles(dt) {
        const activeCache = store._activeFlamesCache || (store._activeFlamesCache = []);
        activeCache.length = 0;

        for (let i = store.flameParticles.length - 1; i >= 0; i--) {
            const p = store.flameParticles[i];
            let alive = true;
            if (p.attachedEnemy) {
                if (p.attachedEnemy.dead) {
                    p.attachedEnemy = null;
                } else {
                    p.x = p.attachedEnemy.x;
                    p.y = p.attachedEnemy.y;
                    p.attachedEnemy.hp -= p.damage;
                    
                    // Apply vampirism healing for attached flame damage
                    if (store.player.vampirism > 0) {
                        let healAmount = p.damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.2); // Minimum 0.2 HP
                        healAmount = Math.min(healAmount, 1); // Cap at 1 HP
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    p.attachedEnemy.slowTimer = 2.0;
                }
            }
            if (p.update && !p.update(dt)) {
                store.flameParticles.splice(i, 1);
                alive = false;
            } else if (!p.update) {
                // Handle legacy flame particles without update function
                if (p.vx !== undefined) {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                }
                p.life -= dt;
                if (p.life <= 0) {
                    store.flameParticles.splice(i, 1);
                    alive = false;
                }
            }

            if (alive) {
                activeCache.push(p);
            }
        }
    }




    const EMPTY_FLAME_CACHE = Object.freeze([]);

    function getHivePuddleLifetime(base, variance, options = {}) {
        const { min = 4, waveBonusPer = 0.35, maxWaveBonus = 5 } = options;
        const wave = (store && store.world && typeof store.world.wave === 'number') ? store.world.wave : 1;
        const waveBonus = Math.min(Math.max(wave - 1, 0) * waveBonusPer, maxWaveBonus);
        const randomized = variance > 0 ? Math.random() * variance : 0;
        return Math.max(min, base + randomized + waveBonus);
    }

    const GOLDEN_ORB_CONFIG = Object.freeze({
        radius: 22,
        pickupRadius: 30,
        floatAmplitude: 12,
        floatSpeed: 2.4,
        homingSpeed: 430,
        homingAcceleration: 6.5,
        maxTrail: 16,
        trailLife: 0.32
    });

    function spawnGoldenSentinelOrbs(count = 3) {
        if (!store || !store.player) return;
        if (!store.goldenOrbs) store.goldenOrbs = [];

        const spawnPositions = [
            {
                x: clamp(W * 0.23, 80, W - 80),
                y: clamp(H - 170, 120, H - 110)
            },
            {
                x: clamp(W * 0.5, 80, W - 80),
                y: clamp(H - 135, 120, H - 105)
            },
            {
                x: clamp(W * 0.77, 80, W - 80),
                y: clamp(H - 190, 120, H - 115)
            }
        ];

        for (let i = 0; i < Math.min(count, spawnPositions.length); i++) {
            const pos = spawnPositions[i];
            const orb = {
                x: pos.x,
                y: pos.y,
                baseY: pos.y,
                r: GOLDEN_ORB_CONFIG.radius,
                pickupRadius: GOLDEN_ORB_CONFIG.pickupRadius,
                state: 'idle',
                floatPhase: Math.random() * Math.PI * 2,
                floatSpeed: GOLDEN_ORB_CONFIG.floatSpeed * (0.85 + Math.random() * 0.3),
                floatAmplitude: GOLDEN_ORB_CONFIG.floatAmplitude * (0.85 + Math.random() * 0.25),
                pulseOffset: Math.random() * Math.PI * 2,
                created: performance.now(),
                trail: [],
                speed: GOLDEN_ORB_CONFIG.homingSpeed
            };
            store.goldenOrbs.push(orb);
            store.activeEffects.push(createEffect('goldenOrbSpawn', orb.x, orb.y, orb.r * 2.2));
        }
    }

    function stepGoldenOrbs(dt) {
        const orbs = store.goldenOrbs;
        if (!orbs || orbs.length === 0) {
            return;
        }

        if (!store.boss) {
            orbs.length = 0;
            return;
        }

        const player = store.player;
        for (let i = orbs.length - 1; i >= 0; i--) {
            const orb = orbs[i];
            orb.floatPhase += orb.floatSpeed * dt;

            if (orb.state === 'idle') {
                orb.y = orb.baseY + Math.sin(orb.floatPhase) * orb.floatAmplitude;
                const dx = player.x - orb.x;
                const dy = player.y - orb.y;
                if ((dx * dx + dy * dy) <= orb.pickupRadius * orb.pickupRadius) {
                    orb.state = 'homing';
                    orb.vx = 0;
                    orb.vy = 0;
                    orb.trail.length = 0;
                    orb.heading = -Math.PI / 2;
                    playSound('stargun');
                }
            } else if (orb.state === 'homing') {
                const boss = store.boss;
                if (!boss) {
                    orbs.splice(i, 1);
                    continue;
                }

                const dx = boss.x - orb.x;
                const dy = boss.y - orb.y;
                const dist = Math.max(0.001, Math.hypot(dx, dy));
                const desiredVx = (dx / dist) * orb.speed;
                const desiredVy = (dy / dist) * orb.speed;
                const accel = GOLDEN_ORB_CONFIG.homingAcceleration;
                orb.vx = (orb.vx || 0) + (desiredVx - (orb.vx || 0)) * Math.min(1, accel * dt);
                orb.vy = (orb.vy || 0) + (desiredVy - (orb.vy || 0)) * Math.min(1, accel * dt);
                orb.x += orb.vx * dt;
                orb.y += orb.vy * dt;
                orb.heading = Math.atan2(orb.vy, orb.vx);

                if (!orb.trail) orb.trail = [];
                orb.trail.unshift({ x: orb.x, y: orb.y, life: GOLDEN_ORB_CONFIG.trailLife });
                if (orb.trail.length > GOLDEN_ORB_CONFIG.maxTrail) {
                    orb.trail.pop();
                }
                for (let t = orb.trail.length - 1; t >= 0; t--) {
                    orb.trail[t].life -= dt;
                    if (orb.trail[t].life <= 0) {
                        orb.trail.splice(t, 1);
                    }
                }

                if (dist <= (boss.r || 70) + 12) {
                    const damage = boss.hpMax * 0.2;
                    boss.hp = Math.max(0, boss.hp - damage);
                    store.world.totalDamage += damage;
                    store.activeEffects.push(createEffect('goldenOrbDetonation', orb.x, orb.y, 140));
                    playSound('explosion');
                    orbs.splice(i, 1);
                    if (boss.hp <= 0) {
                        handleBossDefeat();
                        return;
                    }
                }
            }
        }
    }

    function stepWorld(dt) {
        stepPlayer(dt);
        if (store.boss) {
            stepBoss(dt);
        }

    stepPowerups(dt);
    stepPlayerChampion(dt);
    stepChampionMinions(dt);
    stepHounds(dt);
    stepShadowHounds(dt);
        updateGibs(dt);
        
        stepMissiles(dt);
        stepLasers(dt);
        stepMines(dt);
        stepFlameParticles(dt);
    updateShadowEchoes(dt);
        stepLightning(dt);
        stepEmpNovas(dt);
        processWaveSpawnQueue(dt);
        processVulnerabilityEvents(dt);
        
        // Update beef shield system
        updateBeefShield();
        
        // Update mech oil/fuel puddles
        for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
            const puddle = store.mechPuddles[i];
            puddle.life -= dt;
            if (puddle.life <= 0) {
                store.mechPuddles.splice(i, 1);
            }
        }
        
        updateVoidStepSystems(store.enemies);
        updateImpactSystem();
    stepGoldenOrbs(dt);

        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        if (store.world.powerupCooldown > 0) {
            store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2));
        }

        let base = store.world.wave < 200 ? 1.065 : 1.04;
        // BETTER BALANCE: Even more gentle scaling
        let dmgScale;
        if (store.world.wave <= 10) {
            // Very gentle exponential growth for early game
            dmgScale = Math.pow(1.03, store.world.wave - 1); // Reduced from 1.05 to 1.03
        } else {
            // Minimal linear scaling after wave 10
            const wave10Scale = Math.pow(1.03, 9); // ~1.3x at wave 10
            const veryGentleGrowth = (store.world.wave - 10) * 0.02; // Only +2% per wave after 10
            dmgScale = wave10Scale * (1 + veryGentleGrowth);
        }
        // Apply collar bonus and late-game scaling to enemy damage
    const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
        const lateGameBonus = store.world.lateGameDamageScaling || 1;
        dmgScale *= collarBonus * lateGameBonus;
        // console.log(`Wave ${store.world.wave}: Damage scale = ${dmgScale.toFixed(2)} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x | LateGameBonus: ${lateGameBonus.toFixed(2)}x`);
        const player = store.player;
        let autoBlinkTriggeredThisFrame = false;

        store.eBullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.gravity) { b.vy += b.gravity * dt; }
            if (b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
            
            // Check if poison blob hits ground
            if (b.type === 'poisonBlob' && b.y > H - 30) {
                // Create poison puddle on ground impact
                if (!store.poisonPuddles) store.poisonPuddles = [];
                store.poisonPuddles.push({
                    x: b.x,
                    y: H - 20,
                    r: 20 + Math.random() * 10,
                    life: getHivePuddleLifetime(5.5, 4.5, { min: 4.5, maxWaveBonus: 5.5 }),
                    damage: (b.dmg || 15) * 0.5,
                    created: performance.now()
                });
                b.dead = true;
            }
            
            // Check if mech volley hits ground or reaches target area - create puddle
            if (b.isMechVolley && (b.y >= b.targetY - 10 || b.y > H - 30)) {
                // Use intended target location for puddle placement
                const puddleX = b.targetX;
                const puddleY = b.targetY;
                
                // console.log('Mech volley landed! Creating puddle at target:', puddleX, puddleY);
                store.mechPuddles.push({
                    x: puddleX,
                    y: puddleY,
                    r: 10, // Much smaller puddles (half of 20)
                    maxR: 10, // Store original size for shrinking effect
                    life: 1.5, // Reduced to 1.5 seconds
                    maxLife: 1.5, // Store original life for shrinking calculation
                    damage: (b.dmg || 18) * 0.4, // 40% of original damage per tick
                    sourceId: b.sourceId, // Track which mech created this puddle
                    created: performance.now(),
                    pulseOffset: Math.random() * Math.PI * 2, // For animation
                    hp: 15, // Make puddles killable with small HP
                    hpMax: 15 // Store max HP
                });
                b.dead = true;
            }
            
            if (!autoBlinkTriggeredThisFrame && !b.dead) {
                if (attemptAutoBlink(player, b)) {
                    autoBlinkTriggeredThisFrame = true;
                }
            }

            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            if (collide(b, store.player)) {
                const p = store.player;
                if (p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                    p.rearGuardReady = false;
                    p.rearGuardCooldown = 8;
                    b.dead = true;
                    store.activeEffects.push(createEffect("rearGuardBlock"));
                } else {
                    // Check if this is a poison blob for special effects
                    if (b.type === 'poisonBlob') {
                        // Apply poison debuff to player
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 5000; // 5 second poison
                        p.moveSpeed = Math.max(p.moveSpeed * 0.7, 50); // Slow player
                        
                        // Create poison puddle at impact location
                        if (!store.poisonPuddles) store.poisonPuddles = [];
                        store.poisonPuddles.push({
                            x: b.x,
                            y: b.y,
                            r: 25,
                            life: getHivePuddleLifetime(5, 3, { min: 4.5, maxWaveBonus: 4 }),
                            damage: (b.dmg || 15) * 0.3,
                            created: performance.now()
                        });
                    }
                    
                    // Calculate fade-in damage multiplier for Death Engine bullet rain
                    let damageMultiplier = 1.0;
                    if (b.fadeInTime && b.spawnTime) {
                        const timeAlive = (performance.now() - b.spawnTime) / 1000;
                        damageMultiplier = Math.min(1.0, timeAlive / b.fadeInTime);
                    }
                    
                    takeDamage((b.dmg || 10) * damageMultiplier);
                    b.dead = true;
                }
            }
        });

        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) {
                    store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                    mine.dead = true;
                }
                if (collide(mine, store.player)) {
                    takeDamage(50 * dmgScale);
                    mine.dead = true;
                }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }


    const activeFlames = store._activeFlamesCache && store._activeFlamesCache.length ? store._activeFlamesCache : EMPTY_FLAME_CACHE;
    const flameCount = activeFlames.length;
        
        // CONSOLIDATED enemy processing - flame collision + movement in single loop for performance
        store.enemies.forEach(e => {
            if (e.dead) return;

            if (e.hitPulseTimer && e.hitPulseTimer > 0) {
                e.hitPulseTimer = Math.max(0, e.hitPulseTimer - dt);
            }

            if (e.hitShakeTimer && e.hitShakeTimer > 0) {
                e.hitShakeTimer = Math.max(0, e.hitShakeTimer - dt);
                if (e.hitShakeTimer <= 0) {
                    e.hitShakeIntensity = 0;
                }
            }

            if (e.topClampDelay !== undefined && e.topClampDelay > 0) {
                e.topClampDelay = Math.max(0, e.topClampDelay - dt);
            }

            if (e.spawnPhase === 'teleport') {
                const duration = Math.max(0.001, e.spawnDuration || 0.6);
                e.spawnTimer = (e.spawnTimer ?? duration) - dt;
                const timeRemaining = Math.max(0, e.spawnTimer);
                const progress = Math.min(1, 1 - timeRemaining / duration);
                const eased = 1 - Math.pow(1 - progress, 3);
                const startY = e.spawnStartY ?? (e.spawnTargetY ?? e.y);
                const targetY = e.spawnTargetY ?? e.y;
                e.y = startY + (targetY - startY) * eased;
                e.spawnOpacity = Math.min(1, Math.max(e.spawnOpacity ?? 0, eased * 1.1));
                e.vulnLastKnownPos = { x: e.x, y: e.y };
                if (e.spawnTimer <= 0) {
                    e.spawnPhase = null;
                    e.spawnOpacity = 1;
                    e.y = targetY;
                } else {
                    return;
                }
            } else {
                e.vulnLastKnownPos = { x: e.x, y: e.y };
                if (e.spawnOpacity !== undefined && e.spawnOpacity < 1) {
                    e.spawnOpacity = Math.min(1, e.spawnOpacity + dt * 2.2);
                }
            }

            if (e.jugPulseTimer) e.jugPulseTimer = Math.max(0, e.jugPulseTimer - dt);
            if (e.jugFearTimer) e.jugFearTimer = Math.max(0, e.jugFearTimer - dt);
            if (e.jugBurnTimer) {
                e.jugBurnTimer = Math.max(0, e.jugBurnTimer - dt);
                e.jugBurnTick = (e.jugBurnTick || 0) - dt;
                if (e.jugBurnTimer > 0 && e.jugBurnTick <= 0) {
                    const burnDamage = 10 * (store.player?.dmgMult || 1);
                    const appliedBurn = Math.min(burnDamage, Math.max(0, e.hp - 1));
                    e.hp -= appliedBurn;
                    e.jugBurnTick = 0.45;
                    store.activeEffects.push(createEffect('jugFearEmber', e.x, e.y, e.r || 20));
                }
            }
            if (e.railgunArmorTimer) e.railgunArmorTimer = Math.max(0, e.railgunArmorTimer - dt);
            if (e.phaseLockTimer) e.phaseLockTimer = Math.max(0, e.phaseLockTimer - dt);
            if (e.stormShockTimer) e.stormShockTimer = Math.max(0, e.stormShockTimer - dt);
            if (e.demolitionPulseWarmup) e.demolitionPulseWarmup = Math.max(0, e.demolitionPulseWarmup - dt);
            if (e.maraLaunchTimer) e.maraLaunchTimer = Math.max(0, e.maraLaunchTimer - dt);
            if (e.vulnerabilityPulseStrength) {
                e.vulnerabilityPulseStrength = Math.max(0, e.vulnerabilityPulseStrength - dt * 0.7);
            }
            
            // OPTIMIZED FLAME PARTICLE COLLISION - batch processing with early exit
            if (flameCount > 0) {
                for (let f = 0; f < flameCount; f++) {
                    const flame = activeFlames[f];
                    
                    const dx = flame.x - e.x;
                    const dy = flame.y - e.y;
                    
                    // Early distance culling - skip expensive collision if too far (increased threshold)
                    if (Math.abs(dx) > 120 || Math.abs(dy) > 120) continue;
                    
                    const distSq = dx * dx + dy * dy; // Skip sqrt - use squared distance
                    const collisionRadius = Math.max(5, flame.size + e.r - 50);
                    const collisionRadiusSq = collisionRadius * collisionRadius;
                    
                    if (distSq < collisionRadiusSq) {
                        e.stunTimer = Math.max(e.stunTimer || 0, 0.5);
                        e.hp -= flame.damage;
                        
                        // Apply vampirism healing for flamethrower damage
                        if (store.player.vampirism > 0) {
                            let healAmount = flame.damage * store.player.vampirism;
                            healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                            healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        e.isBurning = true;
                        setTimeout(() => { if (e) e.isBurning = false; }, 100);
                        break; // Exit early on first collision for performance
                    }
                }
            }
            
            // MOVEMENT AND AI UPDATES
            if (e.knockback) {
                // Handle different knockback formats
                if (e.knockback.vx !== undefined && e.knockback.vy !== undefined) {
                    // Beef charge knockback format
                    e.x += e.knockback.vx * dt;
                    e.y += e.knockback.vy * dt;
                    e.knockback.duration -= dt;
                    if (e.knockback.duration <= 0) e.knockback = null;
                } else if (e.knockback.x !== undefined && e.knockback.y !== undefined) {
                    // Blink ability knockback format
                    e.x += e.knockback.x * dt;
                    e.y += e.knockback.y * dt;
                    e.knockback.duration -= dt;
                    if (e.knockback.duration <= 0) e.knockback = null;
                }
                
                // Clamp enemies to screen boundaries so they don't get pushed off-screen
                const margin = e.r || 15; // Use enemy radius for margin, default to 15
                e.x = Math.max(margin, Math.min(W - margin, e.x));
                e.y = Math.max(margin, Math.min(H - margin, e.y));
                if (e.knockback && e.knockback.type === 'maraLaunch' && !e.maraImpactTriggered) {
                    if (e.x <= margin + 1 || e.x >= W - margin - 1 || e.y <= margin + 1 || e.y >= H - margin - 1) {
                        e.maraImpactTriggered = true;
                        store.activeEffects.push(createEffect('maraImpactShockwave', e.x, e.y, (e.r || 20) * 1.8));
                    }
                }
            } else if (e.stunTimer && e.stunTimer > 0) {
                e.stunTimer -= dt;
            } else {
                let speedMultiplier = (e.slowTimer > 0) ? 0.3 : 1.0;
                if (e.hitSlowTimer && e.hitSlowTimer > 0) {
                    const slowFactor = e.hitSlowFactor !== undefined ? e.hitSlowFactor : 0.85;
                    speedMultiplier *= Math.max(0.3, Math.min(1, slowFactor));
                    e.hitSlowTimer = Math.max(0, e.hitSlowTimer - dt);
                    if (e.hitSlowTimer <= 0) {
                        e.hitSlowFactor = 1;
                    }
                } else if (e.hitSlowFactor && e.hitSlowFactor !== 1 && (!e.hitSlowTimer || e.hitSlowTimer <= 0)) {
                    e.hitSlowFactor = 1;
                }
                if (e.slowTimer > 0) e.slowTimer -= dt;
                if (e.phaseLockTimer > 0) {
                    speedMultiplier *= e.phaseLockSlowFactor || 0.4;
                }
                if (e.stormShockTimer > 0) {
                    speedMultiplier *= 0.6;
                }

                if (e.type === 'construct_gold' || e.type === 'avian_hatchling') {
                    const dx = store.player.x - e.x, dy = store.player.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        e.x += (dx / dist) * e.v * speedMultiplier * dt;
                        e.y += (dy / dist) * e.v * speedMultiplier * dt;
                    }
                } else if (e.type === 'angler') {
                    const dx = store.player.x - e.x;
                    if (Math.abs(dx) > 10) e.x += Math.sign(dx) * 30 * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'manta') {
                    e.t += dt;
                    
                    // DISABLED DODGE SYSTEM - was causing enemies to jump off-screen and become unkillable
                    // Simple sinusoidal snake movement only
                    e.x = e.startX + e.amplitude * Math.sin(e.t * e.frequency);
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'shadow_champion') {
                    const boss = store.boss && store.boss.behavior === 'shadow_clone' ? store.boss : null;
                    const enrageThreshold = e.enrageThreshold ?? 0.45;
                    const bossRatio = boss && boss.hpMax ? boss.hp / boss.hpMax : 1;
                    const isEnraged = boss ? (boss.isEnraged || bossRatio <= enrageThreshold) : true;
                    e.isEnraged = isEnraged;

                    if (e.state === 'dash') {
                        e.dashTimer -= dt;
                        e.x += (e.dashVX || 0) * speedMultiplier * dt;
                        e.y += (e.dashVY || 0) * speedMultiplier * dt;
                        addShadowEcho(e.x, e.y);
                        if (e.dashTimer <= 0) {
                            e.state = null;
                            e.dashVX = 0;
                            e.dashVY = 0;
                        }
                    } else {
                        const anchorX = boss ? boss.x : store.player.x;
                        const anchorY = boss ? boss.y + (e.anchorOffsetY ?? 80) : store.player.y - 60;
                        const radius = boss ? (e.guardRadius || 120) : Math.max(80, (e.guardRadius || 120) * 0.65);
                        e.guardAngle = (e.guardAngle ?? 0) + (e.angularSpeed || 0.9) * dt * (isEnraged ? 1.35 : 1);
                        const desiredX = anchorX + Math.cos(e.guardAngle) * radius;
                        const desiredY = anchorY + Math.sin(e.guardAngle) * Math.max(radius * 0.55, 60);
                        const followSpeed = (e.momentum || 3.4) * (isEnraged ? 1.15 : 1);
                        e.x += (desiredX - e.x) * Math.min(1, followSpeed * dt);
                        e.y += (desiredY - e.y) * Math.min(1, followSpeed * 0.9 * dt);
                    }

                    store.shadowChampionLastPos = { x: e.x, y: e.y };
                } else if (e.type === 'void_champion') {
                    e.baseV = e.baseV || e.v;
                    e.t += dt;
                    if (e.ramming) {
                        e.x += e.dashVX * speedMultiplier * dt;
                        e.y += e.dashVY * speedMultiplier * dt;
                        e.dashDuration -= dt;
                        if (e.dashDuration <= 0) {
                            e.ramming = false;
                            e.v = e.baseV;
                            e.vx = (Math.random() < 0.5 ? -1 : 1) * (30 + Math.random() * 40);
                        }
                    } else {
                        e.v = e.baseV;
                        e.vx += Math.sin(e.t * 2.5) * 20 * dt;
                        e.x += (e.vx || 0) * speedMultiplier * dt;
                        // Void champion is immune to gravity - no automatic downward movement
                    }

                    if (!e.ramming) {
                        e.dashTimer -= dt;
                        if (e.dashTimer <= 0) {
                            const dx = store.player.x - e.x;
                            const dy = store.player.y - e.y;
                            const dist = Math.max(60, Math.sqrt(dx * dx + dy * dy));
                            e.dashVX = (dx / dist) * 260;
                            e.dashVY = (dy / dist) * 260;
                            e.dashDuration = 0.35;
                            e.ramming = true;
                            e.dashTimer = e.dashCooldown;
                        }
                    }

                    // Clamp void champion to playfield bounds (both horizontal and vertical)
                    if (e.x < e.r) {
                        e.x = e.r;
                        e.vx = Math.abs(e.vx || 60);
                    } else if (e.x > W - e.r) {
                        e.x = W - e.r;
                        e.vx = -Math.abs(e.vx || 60);
                    }
                    
                    // NEW: Vertical clamping to keep void champion in playfield
                    if (e.y < e.r) {
                        e.y = e.r;
                        if (e.ramming && e.dashVY < 0) e.dashVY = Math.abs(e.dashVY);
                    } else if (e.y > H - e.r) {
                        e.y = H - e.r;
                        if (e.ramming && e.dashVY > 0) e.dashVY = -Math.abs(e.dashVY);
                    }
                } else if (!e.isOrbiter) {
                    e.x += (e.vx || 0) * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else {
                    let orbitTarget = null;
                    if (e.orbitTargetId) {
                        orbitTarget = store.enemies.find(en => en.id === e.orbitTargetId && !en.dead);
                    }
                    if (!orbitTarget && store.boss && !store.boss.dead) {
                        orbitTarget = store.boss;
                    }

                    if (orbitTarget) {
                        if (!e.orbitCenter) e.orbitCenter = { x: orbitTarget.x, y: orbitTarget.y };
                        e.orbitCenter.x = orbitTarget.x;
                        e.orbitCenter.y = orbitTarget.y;
                        e.orbitAngle += e.orbitSpeed * speedMultiplier * dt;
                        e.x = e.orbitCenter.x + e.orbitRadius * Math.cos(e.orbitAngle);
                        e.y = e.orbitCenter.y + e.orbitRadius * Math.sin(e.orbitAngle);
                    } else {
                        e.dead = true;
                    }
                }
                if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
            }

            if (e.jugFearTimer > 0) {
                const dxFear = e.x - store.player.x;
                const dyFear = e.y - store.player.y;
                const distFear = Math.sqrt(dxFear * dxFear + dyFear * dyFear) || 1;
                const fleeSpeed = Math.max(90, (e.v || 60) * 1.9);
                e.x += (dxFear / distFear) * fleeSpeed * dt;
                e.y += (dyFear / distFear) * fleeSpeed * dt * 0.6;
            }

            if (e.stormShockTimer > 0) {
                e.x += (Math.random() - 0.5) * 35 * dt;
                e.y += (Math.random() - 0.5) * 35 * dt;
            }

            const boundaryMargin = e.r || 15;
            e.x = Math.max(boundaryMargin, Math.min(W - boundaryMargin, e.x));
            if (!e.topClampDelay || e.topClampDelay <= 0) {
                if (e.y < boundaryMargin) {
                    e.y = boundaryMargin;
                }
            }

            if (e.fireT > 0) e.fireT -= dt;
            if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                const damageMult = e.damageMult || 1;
                switch (e.type) {
                    case 'hunter': { 
                        const a=Math.atan2(store.player.y-e.y,store.player.x-e.x); 
                        const bullet = getEBulletFromPool({x:e.x,y:e.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:3,col:e.color,dmg:6*dmgScale*damageMult});
                        store.eBullets.push(bullet); 
                        e.fireT=1; break; 
                    }
                    case 'phantom': { 
                        const bullet = getEBulletFromPool({x:e.x,y:e.y,vx:0,vy:180,r:3,col:e.color,dmg:5*dmgScale*damageMult});
                        store.eBullets.push(bullet); 
                        e.fireT=e.fireCooldown; break; 
                    }
                    case 'mech': {
                        e.attackPhase = (e.attackPhase || 0) + 1;
                        // Changed from 50/50 to 85% lob attacks, 15% shoulder cannons for more frequent lobs
                        if (e.attackPhase % 7 === 1) {
                            // Shoulder cannon attack (less frequent now)
                            const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                            const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                            store.eBullets.push({ x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult });
                            const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                            store.eBullets.push({ x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult });
                        } else {
                            // Lob attack with randomized target location (more frequent now)
                            // Limit target area to stay on screen with reasonable arc
                            const randomOffsetX = (Math.random() - 0.5) * 300; // Reduced spread to 300 pixels
                            const targetX = Math.max(80, Math.min(W - 80, store.player.x + randomOffsetX)); // Keep well within bounds
                            
                            // Limit Y coordinate to prevent extreme arcs
                            const minY = Math.max(H * 0.5, e.y + 100); // Don't go too high above the mech
                            const maxY = H - 80;   // Stop well above bottom
                            const targetY = minY + Math.random() * (maxY - minY);
                            
                            const dx = targetX - e.x;
                            const dy = targetY - e.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Much slower projectile for visibility and reasonable arc
                            const timeToTarget = Math.max(1.5, dist / 120); // Slower speed = 120 instead of 180
                            const gravity = 250; // Reduced gravity for gentler arc
                            const vx = dx / timeToTarget;
                            const vy = (dy - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;
                            
                            store.eBullets.push({ 
                                x: e.x, y: e.y, vx: vx, vy: vy, r: 6, 
                                col: '#40e0d0', dmg: 18 * dmgScale * damageMult, // Turquoise projectile color to match mech
                                gravity: gravity, isMechVolley: true, sourceId: e.id,
                                targetX: targetX, targetY: targetY // Store intended target location
                            });
                        }
                        e.fireT = 0.8; break; // Much more frequent attacks - reduced from 1.2 to 0.8
                    }
                    case 'angler': { const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,r:4,col:e.color,dmg:15*dmgScale*damageMult, life: 5}); e.fireT = 2.5; break; }
                    case 'manta': { for(let i=-1; i<=1; i++) { const angle = (90 + i * 30) * Math.PI/180; store.eBullets.push({x:e.x, y:e.y, vx:Math.cos(angle)*150, vy:Math.sin(angle)*150, r:3, col:e.color, dmg:12*dmgScale*damageMult}); } e.fireT = 2.8; break; }
                    case 'shadow_champion': {
                        const boss = store.boss && store.boss.behavior === 'shadow_clone' ? store.boss : null;
                        const enrageThreshold = e.enrageThreshold ?? 0.45;
                        const bossRatio = boss && boss.hpMax ? boss.hp / boss.hpMax : 1;
                        const isEnraged = boss ? (boss.isEnraged || bossRatio <= enrageThreshold) : true;
                        const attackMult = (e.damageMult || 1) * (isEnraged ? 1.2 : 1);
                        const angle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                        if (Math.random() < 0.45) {
                            const volley = isEnraged ? 6 : 4;
                            const spread = isEnraged ? 0.18 : 0.14;
                            for (let i = 0; i < volley; i++) {
                                const offset = (i - (volley - 1) / 2) * spread;
                                const speed = 320 + (isEnraged ? 90 : 60);
                                store.eBullets.push(getEBulletFromPool({
                                    x: e.x + Math.cos(angle) * (e.r * 0.3),
                                    y: e.y + Math.sin(angle) * (e.r * 0.3),
                                    vx: Math.cos(angle + offset) * speed,
                                    vy: Math.sin(angle + offset) * speed,
                                    r: isEnraged ? 6 : 5,
                                    col: isEnraged ? '#a89fff' : '#d6dbff',
                                    dmg: 16 * attackMult,
                                    life: 1.6
                                }));
                            }
                            e.fireT = isEnraged ? 1.05 : 1.35;
                        } else {
                            e.state = 'dash';
                            const dashSpeed = isEnraged ? 520 : 440;
                            e.dashVX = Math.cos(angle) * dashSpeed;
                            e.dashVY = Math.sin(angle) * dashSpeed;
                            e.dashTimer = 0.32;
                            addShadowEcho(e.x, e.y);
                            e.fireT = isEnraged ? 1.25 : 1.55;
                        }
                        break;
                    }
                    case 'void_champion': {
                        if (e.nextPattern === 'beam') {
                            const baseAngle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                            const spreads = [-0.25, 0, 0.25];
                            spreads.forEach((offset, idx) => {
                                const finalAngle = baseAngle + offset;
                                const speed = 210 + idx * 25;
                                store.eBullets.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: Math.cos(finalAngle) * speed,
                                    vy: Math.sin(finalAngle) * speed,
                                    r: 6,
                                    col: '#ffb3ff',
                                    dmg: 18 * dmgScale * damageMult,
                                    life: 5
                                });
                            });
                            e.nextPattern = 'burst';
                        } else {
                            const bolts = 8;
                            for (let i = 0; i < bolts; i++) {
                                const angle = (i / bolts) * Math.PI * 2;
                                store.eBullets.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: Math.cos(angle) * 150,
                                    vy: Math.sin(angle) * 150,
                                    r: 5,
                                    col: '#de6cff',
                                    dmg: 12 * dmgScale * damageMult,
                                    life: 4
                                });
                            }
                            e.nextPattern = 'beam';
                            // Trigger orbiting shards to fire immediately
                            store.enemies.forEach(minion => {
                                if (minion.orbitTargetId === e.id && !minion.dead) {
                                    minion.fireT = Math.min(minion.fireT || 0, 0.1);
                                }
                            });
                        }
                        e.fireT = e.fireCooldown || 1.8;
                        break;
                    }
                    case 'void_champion_orb': {
                        const angle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                        const speed = 220;
                        store.eBullets.push({
                            x: e.x,
                            y: e.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 4,
                            col: '#ff6ad5',
                            dmg: 6 * dmgScale * damageMult,
                            life: 4
                        });
                        e.fireT = e.fireCooldown || 1.1;
                        break;
                    }
                    default: { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:150,r:3,col:e.color,dmg:5*dmgScale*damageMult}); e.fireT=.5; }
                }
            }

            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) {
                const contactDmg = (e.contactDamage || 8) * dmgScale;
                takeDamage(contactDmg); // Reduced baseline from 15 to 8 for better balance
                if (e.type === 'shadow_champion') {
                    e.stunTimer = Math.max(e.stunTimer || 0, 0.35);
                    e.state = null;
                    e.dashTimer = 0;
                    e.dashVX = 0;
                    e.dashVY = 0;
                    e.fireT = Math.max(e.fireT, 0.8);
                } else {
                    store.world.gold += e.gold;
                    e.dead = true;
                }
            }
        });

        // BOSS flame collision (reuse pre-filtered active flames)
        if (store.boss && !store.boss.dead && flameCount > 0) {
            for (let f = 0; f < flameCount; f++) {
                const flame = activeFlames[f];
                
                const dx = flame.x - store.boss.x;
                const dy = flame.y - store.boss.y;
                
                // Early culling for boss collision
                if (Math.abs(dx) > 150 || Math.abs(dy) > 150) continue;
                
                const distSq = dx * dx + dy * dy;
                const collisionRadius = Math.max(10, flame.size + store.boss.r - 50);
                const collisionRadiusSq = collisionRadius * collisionRadius;
                
                if (distSq < collisionRadiusSq) {
                    store.boss.stunTimer = Math.max(store.boss.stunTimer || 0, 0.3);
                    const bossFlameDmg = flame.damage * 0.5;
                    store.boss.hp -= bossFlameDmg;
                    
                    // Apply vampirism healing for flamethrower damage on boss
                    if (store.player.vampirism > 0) {
                        let healAmount = bossFlameDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    store.boss.isBurning = true;
                    setTimeout(() => { if (store.boss) store.boss.isBurning = false; }, 100);
                    break; // Exit early after first collision
                }
            }
        }

        rebuildEnemySpatialIndex();
        const bossTarget = store.boss && !store.boss.dead ? store.boss : null;

        for (let bi = 0; bi < store.bullets.length; bi++) {
            const b = store.bullets[bi];
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.isSwirl) {
                b.life = (b.life || 0) + dt;
                b.x += Math.sin(b.life * 15) * 150 * dt;
            }
            if (b.isFlame) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
                b.particleSpawnT -= dt;
                if (b.particleSpawnT <= 0) {
                    b.particleSpawnT = b.isLavaChunk ? 0.1 : 0.05;
                    const life = 0.3 + Math.random() * 0.3, angle = Math.random() * 2 * Math.PI, speed = b.isLavaChunk ? 10 + Math.random() * 15 : 20 + Math.random() * 20;
                    b.particles.push({ x: 0, y: 0, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: life, maxLife: life, r: 1 + Math.random() * (b.isLavaChunk ? 1.5 : 2) });
                }
                b.particles = b.particles.filter(p => {
                    p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt;
                    return p.life > 0;
                });
            } else if (b.isLevelUpPulse) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
            }

            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            if (!b.dead && bossTarget && !bossTarget.dead && collide(b, bossTarget)) {
                handleBulletImpact(b, bossTarget);
            }

            if (!b.dead && store.enemies.length) {
                const searchRadius = getBulletSearchRadius(b);
                forEachEnemyNearby(b.x, b.y, searchRadius, enemy => {
                    if (enemy === bossTarget) return false;
                    if (!collide(b, enemy)) return false;
                    handleBulletImpact(b, enemy);
                    return b.dead && !b.pierce;
                });
            }
            
            // Check bullet collision with mech puddles (make puddles killable)
            if (!b.dead && store.mechPuddles) {
                for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
                    const puddle = store.mechPuddles[i];
                    const dx = b.x - puddle.x;
                    const dy = b.y - puddle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < puddle.r + (b.r || 2)) {
                        // Puddle hit by bullet - take damage
                        puddle.hp -= (b.dmg || 15);
                        
                        if (puddle.hp <= 0) {
                            // Puddle destroyed - award rewards
                            store.world.gold += 1;
                            store.world.xp += 1;
                            
                            // Small explosion effect
                            for (let j = 0; j < 5; j++) {
                                store.flameParticles.push({
                                    x: puddle.x + (Math.random() - 0.5) * 20,
                                    y: puddle.y + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 100,
                                    vy: -Math.random() * 100,
                                    life: 0.3 + Math.random() * 0.3,
                                    maxLife: 0.3 + Math.random() * 0.3,
                                    r: 2 + Math.random() * 3,
                                    update: function(dt) {
                                        this.life -= dt;
                                        this.x += this.vx * dt;
                                        this.y += this.vy * dt;
                                        this.vy += 200 * dt; // gravity
                                        return this.life > 0;
                                    },
                                    draw: function() {
                                        if (!ctx) return;
                                        const alpha = this.life / this.maxLife;
                                        ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                                        ctx.beginPath();
                                        ctx.arc(this.x, this.y, this.r * alpha, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                });
                            }
                            
                            // console.log('Puddle destroyed by bullet! +1 gold, +1 xp');
                            store.mechPuddles.splice(i, 1);
                        }
                        
                        if (!b.pierce) b.dead = true;
                        break;
                    }
                }
            }
        }

        updateStarProjectiles(dt);

        const p = store.player;
        const healthRatio = p.hp / p.hpMax;
        const lowHealthThreshold = 0.35;

        if (healthRatio < lowHealthThreshold) {
            if (!store.world.isLowHealth) {
                store.world.isLowHealth = true;
                store.heartbeatT = 5.0;
                // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                store.activeEffects.push(createEffect("heartbeatPulse"));
            } else {
                if (store.heartbeatT > 0) {
                    store.heartbeatT -= dt;
                } else {
                    store.heartbeatT = 5.0;
                    // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                    store.activeEffects.push(createEffect("heartbeatPulse"));
                }
            }
        } else if (store.world.isLowHealth) {
            store.world.isLowHealth = false;
        }

        // Optimized cleanup with object pooling
        removeDeadObjects(store.bullets, bullet => bulletPool.release(bullet));
        removeDeadObjects(store.eBullets, bullet => returnEBulletToPool(bullet));
        
        // Efficient removal for other arrays
    removeDeadObjects(store.enemies);
    removeDeadObjects(store.shadowHounds);
    if (store.championMinions && store.championMinions.length) {
        removeDeadObjects(store.championMinions);
    }
        removeDeadObjects(store.powerups);
        removeDeadObjects(store.mines);
        removeDeadObjects(store.missiles);
        removeDeadObjects(store.lasers);
        removeDeadObjects(store.flameParticles);
        removeDeadObjects(store.lightningBolts);
        removeDeadObjects(store.empNovas);
    removeDeadObjects(store.shadowEchoes);
    if (store.playerChampion && store.playerChampion.dead) {
        store.playerChampion = null;
    }
        
        // Handle active effects separately (different property name)
        compactInactiveEffects(store.activeEffects);

        if (!store.boss && store.enemies.length === 0) {
            // Add some delay before starting next wave to prevent rapid cycling
            if (!store.world.waveTransitionTimer) {
                store.world.waveTransitionTimer = performance.now();
                return;
            }
            
            // Wait at least 0.5 seconds before progressing to next wave
            if (performance.now() - store.world.waveTransitionTimer < 500) {
                return;
            }
            
            // console.log(`Wave ${store.world.wave} completed, transitioning to wave ${store.world.wave + 1}`);
            
            if (store.world.waveStartTime > 0 && store.world.wave > 1) {
                const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;
                
                // Guaranteed minimum collar stacks for any reasonable clear
                let collarStacksToAdd = 0;
                sanitizeCollarStacks();
                
                if (waveClearTime < 2) {
                    // Ultra-instant clear: +9 collar stacks (addresses missing 9 stack issue)
                    collarStacksToAdd = 9;
                    store.world.enemyDensityBonus *= 1.15;
                    store.world.xpMultiplier *= 1.1;
                    announce("ðŸ’¥ ULTRA-INSTANT CLEAR! COLLAR CRUSHES +9 ðŸ’¥");
                } else if (waveClearTime < 4) {
                    // Instant clear: +6 collar stacks
                    collarStacksToAdd = 6;
                    store.world.enemyDensityBonus *= 1.1;
                    store.world.xpMultiplier *= 1.07;
                    announce("âš¡ INSTANT WAVE CLEAR! COLLAR TIGHTENS +6 âš¡");
                } else if (waveClearTime < 8) {
                    // Fast clear: +3 collar stacks
                    collarStacksToAdd = 3;
                    store.world.enemyDensityBonus *= 1.05;
                    store.world.xpMultiplier *= 1.03;
                    announce("âš¡ FAST WAVE CLEAR! COLLAR TIGHTENS +3 âš¡");
                } else if (waveClearTime < 12) {
                    // Normal clear: +1 collar stack
                    collarStacksToAdd = 1;
                    announce("âš¡ COLLAR TIGHTENS +1 âš¡");
                } else if (waveClearTime > 20) {
                    // Very slow clear: reset collar stacks (except during Death Engine fight)
                    const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
                    if (!isDeathEngineFight) {
                        const loosenedStacks = Math.max(0, sanitizeCollarStacks() - 2);
                        setCollarStacks(loosenedStacks);
                        announce("ðŸŒ SLOW CLEAR - COLLAR LOOSENS");
                    } else {
                        announce("THE DEATH ENGINE'S CURSE MAINTAINS THE COLLAR!");
                    }
                }
                
                // Add collar stacks only after 2nd boss is defeated - let first two bosses play normally
                collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
                if (store.world.bosses >= 2) {
                    if (collarStacksToAdd > 0) {
                        scheduleCollarIncrease(collarStacksToAdd);
                    } else {
                        approachCollarTarget();
                    }
                }
            }
            
            store.world.wave++;
            store.world.waveTransitionTimer = null; // Reset timer
            
            const hpBonus = 1;
            store.player.hpMax += hpBonus;
            store.player.hp += hpBonus;
            initWave();
        } else {
            // Reset wave transition timer if there are still enemies or boss
            store.world.waveTransitionTimer = null;
        }

        let xpNeeded = Math.floor(store.world.level * 100 * store.world.xpMultiplier * (store.world.level >= 8 ? 1.3 : store.world.level >= 4 ? 1.1 : 1) * (store.world.wave > 10 ? 1.3 : 1));
        if (store.world.xp >= xpNeeded) {
            store.world.xp -= xpNeeded;
            store.world.level++;
            levelUp();
        }

        // Collar decay system - prevent infinite stacking
        if (!store.world.collarDecayTimer) {
            store.world.collarDecayTimer = 0;
        }
        store.world.collarDecayTimer += dt;
        
        // Apply gradual collar decay every 10 seconds if stacks are high (only after 2nd boss, except during Death Engine fight)
        if (store.world.collarDecayTimer >= 10 && store.world.bosses >= 2) {
            store.world.collarDecayTimer = 0;
            
            // Don't decay collar stacks during Death Engine fight due to its intermission phases
            const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
            
            if (!isDeathEngineFight) {
                const currentStacks = sanitizeCollarStacks();
                if (currentStacks > 20) {
                    // Decay faster when collar stacks are very high
                    const decay = Math.max(0.5, currentStacks * 0.02);
                    const newStacks = Math.max(0, currentStacks - decay);
                    setCollarStacks(newStacks);
                    // High collar stacks decay applied
                } else if (currentStacks > 5) {
                    // Gentle decay for moderate stacks
                    const newStacks = Math.max(0, currentStacks - 0.3);
                    setCollarStacks(newStacks);
                }
            }
        }

        if (store.player.hp <= 0) {
            handleGameOver();
        }
    }





    // PERFORMANCE: Efficient dead object removal (300-500% faster than filter)
    function removeDeadObjects(array, disposer) {
        let writeIndex = 0;
        for (let readIndex = 0; readIndex < array.length; readIndex++) {
            const item = array[readIndex];
            if (!item || item.dead) {
                if (item && disposer) {
                    disposer(item);
                }
                continue;
            }

            if (writeIndex !== readIndex) {
                array[writeIndex] = item;
            }
            writeIndex++;
        }

        if (writeIndex < array.length) {
            array.length = writeIndex;
        }
    }

    function compactInactiveEffects(effects) {
        let writeIndex = 0;
        for (let readIndex = 0; readIndex < effects.length; readIndex++) {
            const effect = effects[readIndex];
            if (effect && effect.isActive !== false) {
                if (writeIndex !== readIndex) {
                    effects[writeIndex] = effect;
                }
                writeIndex++;
            }
        }

        if (writeIndex < effects.length) {
            effects.length = writeIndex;
        }
    }

    function ensureSkillTrackingLists() {
        const p = store.player;
        if (!p) return;

        if (!Array.isArray(p.learnedSkills)) {
            if (p.learnedSkills && typeof p.learnedSkills === 'object') {
                const legacyKeys = Object.keys(p.learnedSkills).filter(key => p.learnedSkills[key]);
                p.learnedSkills = legacyKeys;
            } else {
                p.learnedSkills = [];
            }
        }
    }

    // Helper function to ensure progression tracking is initialized
    function initializeProgressionTracking() {
        const p = store.player;
        if (!p) return;

        if (typeof p.totalProgressionPoints !== 'number') p.totalProgressionPoints = 0;
        if (typeof p.unspentProgressionPoints !== 'number') p.unspentProgressionPoints = 0;
        if (typeof p.skillPointsSpent !== 'number') p.skillPointsSpent = 0;
        if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
            p.signatureAbilities = {};
        }
        p.signatureAbility = Object.keys(p.signatureAbilities).length > 0;

        ensureSkillTrackingLists();

        // Ensure player always has skill points available for purchases (controlled by progression logic)
        if (typeof p.skillPoints !== 'number' || p.skillPoints <= 0) {
            p.skillPoints = 10; // Generous skill point pool, but availability controlled by progression
        }
    }

    // Helper function to spend progression points when abilities are successfully added
    function spendProgressionPoint() {
        initializeProgressionTracking();
        if (store.player.unspentProgressionPoints > 0) {
            store.player.unspentProgressionPoints -= 1;
            return true;
        }
        return false;
    }

    // Helper function for progression logic (used by both boss defeat and mech forge button)
    function checkProgressionLogic(awardPoint = false) {
        // Initialize progression tracking
        initializeProgressionTracking();
        
        // Award progression point if this is from boss defeat
        if (awardPoint) {
            store.player.totalProgressionPoints += 1;
            store.player.unspentProgressionPoints += 1;
        }
        
        const playerTotalPts = store.player.totalProgressionPoints;
        const playerUnspentPts = store.player.unspentProgressionPoints;
        const currentSpec = store.player.pilotGenome;
        const currentSubclass = store.player.subclass;
        
        // Progression logic following Python pattern
        if (playerTotalPts === 1 && playerUnspentPts > 0) {
            // First boss - open class select
            if (awardPoint) store.player.pilotGenome = 'pending';
            setTimeout(showPilotSelect, awardPoint ? 1000 : 0);
            return true;
        } else if (playerTotalPts > 1 && currentSpec && currentSpec !== 'pending' && !currentSubclass && playerUnspentPts > 0) {
            // Second+ boss with class selected but no subclass - open subclass select
            setTimeout(showSubclassSelect, awardPoint ? 1500 : 0);
            return true;
        } else if (playerTotalPts > 2 && currentSpec && currentSpec !== 'pending' && currentSubclass && playerUnspentPts > 0) {
            // Third+ boss with class and subclass - open skill tree
            setTimeout(showSkillTreeModal, awardPoint ? 1500 : 0);
            return true;
        }
        
        return false; // No progression available
    }

    function handleBossDefeat() {
        const activeBoss = store.boss;
        const snapshot = activeBoss || store.lastBossSnapshot;
        if (!snapshot) {
            return;
        }

        const bossId = snapshot.id || snapshot._instanceId || snapshot.behavior || snapshot.name;
        if (bossId && store.lastBossDefeatId === bossId) {
            return;
        }

    const playerRef = store.player || {};
    const fallbackX = Number.isFinite(playerRef.x) ? playerRef.x : W / 2;
    const fallbackY = Number.isFinite(playerRef.y) ? playerRef.y : H / 2;
    const bossX = ensureFiniteNumber(snapshot.x, fallbackX);
    const bossY = ensureFiniteNumber(snapshot.y, fallbackY);
        const bossName = snapshot.name || 'UNKNOWN';

        store.lastBossSnapshot = { x: bossX, y: bossY, name: bossName, id: bossId };
        store.lastBossDefeatId = bossId;
        if (activeBoss) {
            activeBoss.dead = true;
        }

        const now = performance.now();
        const bossSpawnTime = ensureFiniteNumber(store.world.bossSpawnTime, now);
        const fightDuration = ensureFiniteNumber((now - bossSpawnTime) / 1000, 0);
        
        // Use progression logic with point award
        checkProgressionLogic(true);
        
        const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
        store.world.score += Math.floor(2000 * collarBonus); store.world.gold += Math.floor(25 * collarBonus); store.world.xp += Math.floor(100 * collarBonus); store.world.bosses++;
        if (store.goldenOrbs) {
            store.goldenOrbs.length = 0;
        }
        
        // Clear any poison puddles and poison blobs from HIVE SOVEREIGN when boss is defeated
        if (store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        // Also clear poison blobs still in flight to prevent persistent puddles
        store.bullets = store.bullets.filter(b => {
            if (b.type === 'poisonBlob') {
                bulletPool.release(b);
                return false;
            }
            return true;
        });
        
        store.boss = null;
        announce('âš¡ GUARDIAN DEFEATED âš¡');
        explode(bossX, bossY, true);

        if (bossName === 'SHADOW MIRROR') {
            finalizeShadowChampionAfterBoss(bossX, bossY);
        }

        let healthBonusMultiplier = 1.0, announcedAdaptation = false;
        // Calculate collar stacks to add based on boss kill speed (more generous)
        let collarStacksToAdd = 0;
        sanitizeCollarStacks();
        
        if (fightDuration <= 2) {
            // Ultra-fast boss kill: massive collar bonus
            collarStacksToAdd = 12;
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            announce(`ðŸ’¥ COLLAR CRUSHES +${collarStacksToAdd} ðŸ’¥`);
        } else if (fightDuration <= 5) {
            // Fast boss kill
            collarStacksToAdd = Math.max(8, Math.floor(12 - (fightDuration * 1.5)));
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
        } else if (fightDuration < 8) {
            // Decent boss kill
            collarStacksToAdd = Math.max(3, Math.floor(10 - fightDuration));
            announcedAdaptation = true; 
            healthBonusMultiplier = 1.15;
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
        } else if (fightDuration < 12) {
            // Slow boss kill: minimal collar bonus
            collarStacksToAdd = 1;
            announcedAdaptation = true; 
            healthBonusMultiplier = 1.05;
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
        } else {
            // Very slow kill: reduce collar stacks (except for DEATH ENGINE)
            if (bossName !== 'DEATH ENGINE') {
                const loosened = Math.max(0, sanitizeCollarStacks() - 3);
                setCollarStacks(loosened);
                announce("âš–ï¸ COLLAR LOOSENS - ADAPTATION WEAKENS");
            } else {
                announce("THE DEATH ENGINE'S CURSE PERSISTS!");
            }
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            healthBonusMultiplier = 1.0;
        }
        
        // Special handling for Death Engine - restore preserved collar stacks
        if (bossName === 'DEATH ENGINE' && store.world.deathEngineCollarStacks !== undefined) {
            const originalStacks = ensureFiniteNumber(store.world.deathEngineCollarStacks, sanitizeCollarStacks());
            const originalTarget = ensureFiniteNumber(store.world.deathEngineCollarTargetStacks, originalStacks);
            setCollarStacks(Math.max(0, originalStacks));
            store.world.collarTargetStacks = Math.min(MAX_COLLAR_STACKS, Math.max(store.world.collarStacks, originalTarget));
            const addAfterRestore = ensureFiniteNumber(collarStacksToAdd, 0);
            if (addAfterRestore > 0) {
                scheduleCollarIncrease(addAfterRestore);
            } else {
                approachCollarTarget();
            }
            delete store.world.deathEngineCollarStacks; // Clean up
            delete store.world.deathEngineCollarTargetStacks;
        } else {
            // Add collar stacks only after 2nd boss is defeated - collar system starts with 3rd boss
            collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
            if (store.world.bosses >= 2) {
                if (collarStacksToAdd > 0) {
                    scheduleCollarIncrease(collarStacksToAdd);
                } else {
                    approachCollarTarget();
                }
            }
        }
        // FIXED: Don't permanently modify health bonuses - collar handles this dynamically
        // Instead, only apply temporary density and XP bonuses based on performance
        if (announcedAdaptation) {
            // Only apply density bonuses, not permanent health increases
            if (healthBonusMultiplier > 1.3) {
                store.world.enemyDensityBonus *= 1.15;
            } else if (healthBonusMultiplier > 1.1) {
                store.world.enemyDensityBonus *= 1.10;
            } else if (healthBonusMultiplier > 1.0) {
                store.world.enemyDensityBonus *= 1.05;
            }
            setTimeout(() => announce("GUARDIAN DEFEATED!"), 1000);
        }
    }

    function explode(x, y, isBoss = false, isSmall = false) {
        playSound('explosion');
        if (isBoss) for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
        if (isSmall) {
            const radius = 60;
            const dmg = 25 * store.player.dmgMult;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            targets.forEach(e => {
                if (!e.dead) {
                    const distSq = (e.x - x)**2 + (e.y - y)**2;
                    if (distSq < radius**2) {
                        e.hp -= dmg;
                        store.world.totalDamage += dmg;
                        
                        // Track damage dealt for beef shield system
                        if (store.player.pilotGenome === 'beef') {
                            store.player.beefShieldDamageDealt += dmg;
                        }
                        
                        // Apply vampirism healing for explosion damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP
                            healAmount = Math.min(healAmount, 2); // Cap at 2 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                    }
                }
            });
            store.activeEffects.push(createEffect("grenadeExplosion", x, y, radius));
        }
    }
    
    function levelUp() {
        announce(`LEVEL UP! âš¡ CHOOSE YOUR AUGMENTATION!`);
        pauseGame();
        
        // Natural health growth: 10% per level
        const healthGrowth = store.player.hpMax * 0.1;
        store.player.hpMax += healthGrowth;
        store.player.hp += healthGrowth;
        
        store.player.isInvincible = true;
        const speedBoost = store.player.speed * 0.75;
        const fireRateBoost = store.player.fireRate * 0.5;
        store.player.speed += speedBoost;
        store.player.fireRate -= fireRateBoost;

        const levelUpPulse = () => {
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 300;
                spawnBullet({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 4,
                    col: '#ffddff',
                    dmg: 30 * p.dmgMult,
                    pierce: true,
                    life: 1.5,
                    isLevelUpPulse: true
                });
            }
        };

        levelUpPulse();
        setTimeout(levelUpPulse, 250);

        // Store timeout ID to prevent multiple level-ups causing permanent bonuses
        if (store.levelUpTimeoutId) {
            clearTimeout(store.levelUpTimeoutId);
        }
        
        store.levelUpTimeoutId = setTimeout(() => {
            store.player.isInvincible = false;
            store.player.speed -= speedBoost;
            store.player.fireRate += fireRateBoost;
            store.levelUpTimeoutId = null;
        }, 3000);

        const panel = q('levelPanel'), grid = q('skillsGrid');
        const availableUpgrades = LEVEL_UPGRADES.filter(u => {
            if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
            // Check if upgrade has availability function
            if (u.available && typeof u.available === 'function') return u.available();
            return true;
        });

        for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; }
        const choices = availableUpgrades.slice(0, 3);
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        const cards = grid.querySelectorAll('.skill-card');
        const clickHandler = (e) => {
            const card = e.currentTarget;
            const id = card.dataset.id; 
            const upgrade = LEVEL_UPGRADES.find(s => s.id === id);
            if (upgrade) upgrade.apply(); 
            panel.classList.add('hide');
            resumeGame();
            // Clean up event listeners to prevent UI freeze
            cards.forEach(c => c.removeEventListener('click', clickHandler));
        };
        
        cards.forEach(card => {
            card.addEventListener('click', clickHandler);
        });

        panel.classList.remove('hide');
    }
    
    function handleGameOver() {
        if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score);
        announce('â—¢ NEXUS BREACH - PILOT LOST â—£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide');
    }
    
    function resetGame() {
        store.player = JSON.parse(JSON.stringify(player_initial_state));
        
        // Ensure dmgMult is initialized
        if (!store.player.dmgMult) store.player.dmgMult = 1;
    
        store.world = { 
            wave: 1, 
            score: 0, 
            gold: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            mechForgeGoldTriggered: false,
            mechForgePulseTimeout: null,
            bossSpawnTime: 0, 
            waveStartTime: 0, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            lateGameDamageScaling: 1,
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            totalDamage: 0,
            damageStartTime: performance.now(),
            lastThreatScale: 1,
            lastSpawnOverflow: 0,
            lastPlannedSpawnCount: 0,
            lastSpawnCount: 0,
            lastSpawnFallback: false,
            lastSpawnQueueLength: 0,
            lastSpawnTempo: 0,
            firstBossOrbsGifted: false
        };
        
        if (store.bullets && store.bullets.length) {
            store.bullets.forEach(bullet => bulletPool.release(bullet));
        }
        if (store.eBullets && store.eBullets.length) {
            store.eBullets.forEach(returnEBulletToPool);
        }
    store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = []; store.powerups = []; store.starProjectiles = []; store.pendingStarClones = [];
        store.lastBossSnapshot = null;
        store.lastBossDefeatId = null;
        store.drones = []; store.hounds = []; store.shadowHounds = []; store.missiles = []; store.lasers = []; store.mines = []; store.activeEffects = []; store.flameParticles = [];
        store.lightningBolts = []; store.empNovas = []; store.poisonPuddles = []; store.goldenOrbs = []; store.shadowEchoes = [];
        store.championMinions = [];
        store.playerChampion = null;
        store.shadowChampionId = null;
        store.shadowChampionDefeated = false;
        store.shadowChampionTokenDropped = false;
    store.shadowChampionLastPos = null;
        store.iceman = null;
        store.beefClone = null;
        store.waveSpawnQueue = [];
        store.pendingSpawnCount = 0;
        store._startTs = performance.now(); store.isGameOver = false;
        store.cheatsUsed = false;
        store.cheatInvincibilityCooldown = 0;
        store.cheatDogHealCooldown = 0;
        shopItemOrder = [];
        q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide'); 
        q('subclassPanel').classList.add('hide');
        const mechForgeBtn = q('shopBtn');
        if (mechForgeBtn) {
            mechForgeBtn.classList.remove('forge-highlight');
            mechForgeBtn.classList.remove('mech-forge-pulse');
            if (mechForgeBtn._forgePulseTimeout) {
                clearTimeout(mechForgeBtn._forgePulseTimeout);
                mechForgeBtn._forgePulseTimeout = null;
            }
        }
        ensureName();
    }

    // --- RENDER & DRAW FUNCTIONS ---
    const starCountA = 100, starCountB = 80;
    const starsA = Array.from({ length: starCountA }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.5, pulse: Math.random() * 10 }));
    const starsB = Array.from({ length: starCountB }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 2, pulse: Math.random() * 10 }));

    // Optimized background star rendering
    function renderBackgroundStars(dt) {
        // Batch star operations to reduce context state changes
        ctx.globalAlpha = 0.8;
        
        // Render starsA in a single pass
        for (let i = 0; i < starsA.length; i++) {
            const s = starsA[i];
            s.y += 30 * dt; 
            if (s.y > H) s.y -= H;
            
            const alpha = 0.5 + 0.5 * Math.sin(frameTime * 2 + s.pulse);
            ctx.fillStyle = `rgba(255,0,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, 6.283185307179586); // Use constant instead of Math.PI * 2
            ctx.fill();
        }
        
        ctx.globalAlpha = 0.6;
        
        // Render starsB in a single pass
        for (let i = 0; i < starsB.length; i++) {
            const s = starsB[i];
            s.y += 60 * dt; 
            if (s.y > H) s.y -= H;
            
            const pulse = Math.sin(frameTime * 1.5 + s.pulse);
            const alpha = 0.4 + 0.6 * pulse;
            const radius = Math.max(0.1, s.r * (0.4 + 0.6 * pulse));
            
            ctx.fillStyle = `rgba(204,0,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, radius, 0, 6.283185307179586);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
    }

// Cache for gradient objects to avoid recreation
let poisonGradientCache = new Map();
let mechGradientCache = new Map();
let frameTime = 0;
let frameCount = 0;

// Clear caches periodically to prevent memory buildup
function clearGradientCaches() {
    if (frameCount % 1000 === 0) { // Clear every ~17 seconds at 60fps
        poisonGradientCache.clear();
        mechGradientCache.clear();
    }
}

function render(dt) {
    frameCount++;
    clearGradientCaches();
    
    // Performance optimization: Use faster fill method and cache time calculation
    ctx.fillStyle = '#050008'; 
    ctx.fillRect(0, 0, W, H);
    frameTime = performance.now() / 1000;
    
    // Render background stars with optimized drawing
    renderBackgroundStars(dt);
    


    const closeBullets = [];
    const farBullets = [];
    const proximityThreshold = 110;
    const playerPos = store.player;

    store.eBullets.forEach(b => {
        const distSq = (b.x - playerPos.x)**2 + (b.y - playerPos.y)**2; 
        if (distSq < proximityThreshold**2) {
            closeBullets.push({ bullet: b, dist: Math.sqrt(distSq) });
        } else {
            farBullets.push(b);
        }
    });
    
    store.powerups.forEach(p => drawPowerup(p));
    drawGoldenOrbs();
    store.missiles.forEach(m => drawMissile(m));
    store.lightningBolts.forEach(l => drawLightningBolt(l));
    store.empNovas.forEach(n => drawEmpNova(n));
    drawStarProjectiles();


    // Optimized far bullets rendering with batched operations
    for (let i = 0; i < farBullets.length; i++) {
        const b = farBullets[i];
        
        // Apply visual fade-in for Death Engine bullet rain
        let alpha = 1.0;
        if (b.fadeInTime && b.spawnTime) {
            const timeAlive = (performance.now() - b.spawnTime) / 1000;
            alpha = Math.min(1.0, timeAlive / b.fadeInTime);
        }
        
        if (alpha < 1.0) {
            ctx.save();
            ctx.globalAlpha = alpha;
        }
        
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, 6.283185307179586); // Use constant
        ctx.fill();
        
        if (alpha < 1.0) {
            ctx.restore();
        }
    }
    
    store.bullets.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.fillStyle = b.col;
        ctx.beginPath();
        
        const r = b.r * 1.5;

        if (b.isLavaChunk) {
            ctx.beginPath();
            ctx.moveTo(0, -r); ctx.lineTo(r, r * 0.2); ctx.lineTo(r * 0.5, r); ctx.lineTo(-r * 0.5, r); ctx.lineTo(-r, r * 0.2);
            ctx.closePath();
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const particleR = p.r * t;
                ctx.fillStyle = `rgba(255, ${60 + Math.random() * 60}, 0, ${0.7 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isFlame) {
            ctx.fillStyle = `rgba(255, 150, 50, ${0.3 * (b.life / 50)})`;
            ctx.beginPath();
            ctx.arc(0, 0, b.r * 0.5, 0, 2 * Math.PI);
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const r_particle = p.r * t;
                const g = Math.floor(255 * (0.4 + t * 0.6));
                const b_val = Math.floor(100 * t);
                ctx.fillStyle = `rgba(${g}, ${b_val}, 0, ${0.8 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r_particle, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isSwirl || b.explosive) {
            ctx.arc(0, 0, b.r, 0, 2 * Math.PI);
        } else if (b.isIceman) {
            ctx.moveTo(0, r); ctx.lineTo(r * 0.8, -r * 0.8); ctx.lineTo(-r * 0.8, -r * 0.8);
        } else {
            ctx.moveTo(0, -r); ctx.lineTo(r * 0.8, r * 0.8); ctx.lineTo(-r * 0.8, r * 0.8);
        }

        ctx.closePath();
        ctx.fill();
        ctx.restore();
    });

    store.lasers.forEach(l => drawLaser(l));
    store.mines.forEach(m => drawMine(m));
    if (store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(frameTime * 5)})`; ctx.fill(); ctx.restore(); });
    
    // Draw poison puddles - optimized
    if (store.poisonPuddles) {
        store.poisonPuddles.forEach(puddle => {
            const age = (frameTime * 1000 - puddle.created) / 1000;
            const maxAge = puddle.life + (15 - puddle.life); // Total possible age
            
            ctx.save();
            ctx.translate(puddle.x, puddle.y);
            
            // Animate puddle bubbling - cache sin calculation
            const bubbleOffset = Math.sin(frameTime * 3 + puddle.x * 0.01) * 2;
            
            // Create toxic glow effect - cache gradient by radius
            const glowRadius = puddle.r * 1.5;
            const radiusKey = Math.round(glowRadius);
            let gradient = poisonGradientCache.get(radiusKey);
            if (!gradient) {
                gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                gradient.addColorStop(0, 'rgba(124, 252, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(173, 255, 47, 0.5)');
                gradient.addColorStop(1, 'rgba(124, 252, 0, 0)');
                poisonGradientCache.set(radiusKey, gradient);
            }
            
            const glowAlpha = 0.3 * (puddle.life / 15) + 0.2 * Math.sin(frameTime * 4);
            ctx.globalAlpha = glowAlpha;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // Draw the puddle itself
            const puddleAlpha = Math.max(0.4, puddle.life / 15);
            ctx.fillStyle = `rgba(45, 80, 22, ${puddleAlpha})`;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, puddle.r, 0, Math.PI * 2);
            ctx.fill();
            
            // Add surface texture/ripples
            ctx.strokeStyle = `rgba(124, 252, 0, ${puddleAlpha * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const rippleRadius = puddle.r * (0.3 + i * 0.3) + Math.sin(frameTime * 2 + i) * 3;
                const rippleAlpha = puddleAlpha * (0.8 - i * 0.2);
                ctx.globalAlpha = rippleAlpha;
                ctx.arc(0, bubbleOffset, rippleRadius, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Add occasional toxic bubbles - use time-based approach to reduce randomness
            if (Math.sin(frameTime * 8 + puddle.x * 0.1) > 0.8) {
                const bubbleX = Math.sin(frameTime * 3 + puddle.x) * puddle.r * 0.3;
                const bubbleY = Math.cos(frameTime * 2.5 + puddle.y) * puddle.r * 0.3 + bubbleOffset;
                const bubbleSize = 2 + Math.abs(Math.sin(frameTime * 4 + puddle.x)) * 3;
                
                const bubbleAlpha = 0.6 + Math.abs(Math.cos(frameTime * 5 + puddle.y)) * 0.4;
                ctx.fillStyle = `rgba(124, 252, 0, ${bubbleAlpha})`;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    // Draw mech oil/fuel puddles with aqua color scheme - optimized
    if (store.mechPuddles) {
        store.mechPuddles.forEach(puddle => {
            ctx.save();
            ctx.translate(puddle.x, puddle.y);
            
            // Create flickering aqua energy effect - use cached time
            const flicker = 0.8 + Math.sin(frameTime * 6) * 0.2;
            const pulseOffset = Math.sin(frameTime * 4 + puddle.x * 0.02) * 1.5;
            
            // Calculate shrinking effect as puddle disappears
            const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
            const currentRadius = puddle.r * Math.max(0.3, lifePercent); // Shrink to 30% min size
            
            // Create aqua hazardous glow effect - cache gradient by radius
            const glowRadius = currentRadius * 1.4;
            const radiusKey = Math.round(glowRadius);
            let gradient = mechGradientCache.get(radiusKey);
            if (!gradient) {
                gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 1)'); // Bright cyan
                gradient.addColorStop(0.6, 'rgba(32, 178, 170, 0.7)'); // Light sea green
                gradient.addColorStop(1, 'rgba(0, 139, 139, 0)'); // Dark cyan fade
                mechGradientCache.set(radiusKey, gradient);
            }
            
            const glowAlpha = 0.4 * lifePercent * flicker;
            ctx.globalAlpha = glowAlpha;
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, pulseOffset, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw the puddle base (dark aqua/teal liquid) with shrinking
            const puddleAlpha = Math.max(0.6, lifePercent);
            ctx.fillStyle = `rgba(14, 75, 92, ${puddleAlpha})`; // Dark aqua blue base
            ctx.beginPath();
            ctx.arc(0, pulseOffset, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Add aqua energy surface effects with shrinking
            ctx.strokeStyle = `rgba(64, 224, 208, ${puddleAlpha * 0.9})`; // Turquoise ripples
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < 2; i++) {
                const energyRadius = Math.max(0.1, currentRadius * (0.4 + i * 0.3) + Math.sin(frameTime * 3 + i * 2) * 2);
                const energyAlpha = puddleAlpha * (0.7 - i * 0.3) * flicker;
                ctx.globalAlpha = energyAlpha;
                ctx.arc(0, pulseOffset, energyRadius, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Add occasional aqua energy bubbles (only if puddle is large enough)
            if (currentRadius > 5 && Math.random() < 0.15) {
                const bubbleX = (Math.random() - 0.5) * currentRadius * 0.8;
                const bubbleY = (Math.random() - 0.5) * currentRadius * 0.8 + pulseOffset;
                const bubbleSize = 1 + Math.random() * 2;
                
                ctx.fillStyle = `rgba(0, 255, 255, ${0.8 + Math.random() * 0.2})`; // Bright cyan bubbles
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    store.enemies.forEach(e => drawEnemy(e));
    drawGibs(ctx); // <-- ADD THIS LINE TO DRAW THE GIBS
    drawShadowEchoes();
    if (store.boss && store.boss.visible !== false) drawBoss(store.boss);
    store.flameParticles.forEach(p => { 
        if (p.draw) p.draw(); 
        else if (p.color) {
            ctx.save();
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size || 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
    });
    store.drones.forEach(d => drawDrone(d));
    if (store.shadowHounds) store.shadowHounds.forEach(h => drawShadowHound(h));
    store.hounds.forEach(h => drawHound(h));
    const champion = store.playerChampion;
    if (champion && !champion.dead) {
        const minions = store.championMinions || [];
        if (minions.length) {
            ctx.save();
            minions.forEach(minion => {
                if (!minion || minion.dead) return;
                const gradient = ctx.createLinearGradient(champion.x, champion.y, minion.x, minion.y);
                gradient.addColorStop(0, 'rgba(180, 190, 255, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1.4;
                ctx.globalAlpha = 0.4 + Math.min(0.35, (champion.level || 1) * 0.05);
                ctx.beginPath();
                ctx.moveTo(champion.x, champion.y);
                ctx.lineTo(minion.x, minion.y);
                ctx.stroke();
            });
            ctx.restore();

            minions.forEach(minion => {
                if (!minion || minion.dead) return;
                drawChampionMinion(minion, champion);
            });
        }

        drawPlayerChampion(champion);
    }
    if (store.iceman) drawIceman(store.iceman);
    if (store.beefClone) drawBeefClone(store.beefClone);
    drawShip(store.player.x, store.player.y, store.player);
    
    // Draw EMP disabled effect on player
    if (store.player.empDisabled) {
        const sizzleIntensity = 0.5 + 0.5 * Math.sin(frameTime * 15);
        
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        
        // Electric sparks around player
        ctx.strokeStyle = `rgba(255, 140, 0, ${sizzleIntensity})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 8;
        
        for (let i = 0; i < 8; i++) {
            if (Math.random() < 0.7) {
                const angle = (i / 8) * Math.PI * 2 + frameTime * 5;
                const radius = store.player.r + 5;
                const x1 = Math.cos(angle) * radius;
                const y1 = Math.sin(angle) * radius;
                const x2 = x1 + (Math.random() - 0.5) * 15;
                const y2 = y1 + (Math.random() - 0.5) * 15;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        // Purple inner glow
        ctx.fillStyle = `rgba(138, 43, 226, ${sizzleIntensity * 0.3})`;
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(0, 0, store.player.r * 1.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Draw poison effect on player
    if (store.player.isPoisoned) {
        const poisonAlpha = 0.3 + 0.2 * Math.sin(frameTime * 8);
        
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = `rgba(0, 255, 0, ${poisonAlpha})`;
        ctx.beginPath();
        ctx.arc(store.player.x, store.player.y, store.player.r + 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Add poison particle effect around player
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        for (let i = 0; i < 6; i++) {
            const angle = frameTime * 2 + i * Math.PI / 3;
            const x = Math.cos(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
            const y = Math.sin(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
            
            ctx.fillStyle = `rgba(124, 252, 0, ${0.4 + 0.3 * Math.sin(frameTime * 6 + i)})`;
            ctx.beginPath();
            ctx.arc(x, y, 2 + Math.sin(frameTime * 5 + i), 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
// ...existing code...
    // Draw voidmancer laser beam (Phasestriker only)
    if (store.player.hasVoidLaser && store.player.voidLaserTarget && !store.player.voidLaserTarget.dead) {
        const p = store.player;
        const target = p.voidLaserTarget;
        
        // Determine laser color based on player ship color
        let laserColor = '#b266ff'; // Default purple
        switch (p.subclass) {
            case 'juggernaut':
                laserColor = '#ff3333';
                break;
            case 'marauder':
                laserColor = '#33cc33';
                break;
            case 'railgunner':
                laserColor = '#ff6600';
                break;
            case 'demolitionist':
                laserColor = '#ff4500';
                break;
            case 'phasestriker':
                laserColor = '#9900ff';
                break;
            case 'stormcaller':
                laserColor = '#00ccff';
                break;
        }
        
        const time = performance.now() / 1000;
        const pulseAlpha = 0.6 + 0.4 * Math.sin(time * 12);
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Calculate ramping size for level 2 phasestriker
        let baseLineWidth = 3;
        let glowLineWidth = 6;
        
        if (p.phasestRikerLevel >= 2) {
            const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // Same ramp as damage
            const sizeMultiplier = Math.min(rampMultiplier, 3.0); // Cap at 3x size
            baseLineWidth *= sizeMultiplier;
            glowLineWidth *= sizeMultiplier;
        }
        
        // Draw laser beam(s) - double beam for level 4 phasestriker
        const beamCount = (p.phasestRikerLevel >= 4 && p.doubleBeam) ? 2 : 1;
        const beamOffsets = beamCount === 2 ? [-8, 8] : [0]; // Parallel beams offset left and right
        
        for (let i = 0; i < beamCount; i++) {
            const offsetX = beamOffsets[i];
            
            // Draw main laser beam
            ctx.strokeStyle = laserColor;
            ctx.globalAlpha = pulseAlpha;
            ctx.lineWidth = baseLineWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + offsetX, p.y - 12);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
            
            // Draw laser glow effect - create gradient here
            const gradient = ctx.createLinearGradient(p.x + offsetX, p.y - 12, target.x, target.y);
            gradient.addColorStop(0, laserColor + '40');
            gradient.addColorStop(1, laserColor + '80');
            
            ctx.strokeStyle = gradient;
            ctx.globalAlpha = pulseAlpha * 0.5;
            ctx.lineWidth = glowLineWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + offsetX, p.y - 12);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
        }
        
        // Add impact effect at target
        ctx.fillStyle = laserColor;
        ctx.globalAlpha = pulseAlpha;
        ctx.beginPath();
        ctx.arc(target.x, target.y, 4 + Math.sin(time * 8) * 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Draw wiper lasers (for both Phasestriker and Stormcaller ultimate)
    if (store.player.wiperLasers) {
        const p = store.player;
        
        // Determine laser color based on player ship color
        let laserColor = '#b266ff'; // Default purple
        switch (p.subclass) {
            case 'juggernaut':
                laserColor = '#ff3333';
                break;
            case 'marauder':
                laserColor = '#33cc33';
                break;
            case 'railgunner':
                laserColor = '#ff6600';
                break;
            case 'demolitionist':
                laserColor = '#ff4500';
                break;
            case 'phasestriker':
                laserColor = '#9900ff';
                break;
            case 'stormcaller':
                laserColor = '#00ccff';
                break;
        }
        
        const time = performance.now() / 1000;
        const isSlashing = p.isBlinkSlashing;
        const basePulseAlpha = 0.8 + 0.2 * Math.sin(time * 10);
        const pulseAlpha = isSlashing ? basePulseAlpha * 1.3 : basePulseAlpha; // Brighter during slash
        const laserLength = 180; // Shorter, just long enough to hit boss from safe zone
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Draw motion blur trail first (behind main lasers)
        if (p.wiperLaserBlurTrail && p.wiperLaserBlurTrail.length > 0) {
            for (const trail of p.wiperLaserBlurTrail) {
                const trailAlpha = (trail.life / 0.15) * trail.intensity;
                if (trailAlpha > 0.05) {
                    const trailLasers = [
                        { angle: trail.angle1, offset: -8 },
                        { angle: trail.angle2, offset: 8 }
                    ];
                    
                    trailLasers.forEach(trailLaser => {
                        const trailEndX = p.x + Math.cos(trailLaser.angle) * laserLength;
                        const trailEndY = p.y + Math.sin(trailLaser.angle) * laserLength;
                        
                        // Draw blur trail effect
                        ctx.strokeStyle = laserColor + Math.floor(trailAlpha * 100).toString(16).padStart(2, '0');
                        ctx.globalAlpha = trailAlpha * 0.6;
                        ctx.lineWidth = isSlashing ? 8 : 4;
                        ctx.beginPath();
                        ctx.moveTo(p.x + trailLaser.offset, p.y - 12);
                        ctx.lineTo(trailEndX, trailEndY);
                        ctx.stroke();
                    });
                }
            }
        }
        
        // Draw two main wiper lasers
        const lasers = [
            { angle: p.wiperLaser1Angle, offset: -8 },
            { angle: p.wiperLaser2Angle, offset: 8 }
        ];
        
        lasers.forEach(laser => {
            const endX = p.x + Math.cos(laser.angle) * laserLength;
            const endY = p.y + Math.sin(laser.angle) * laserLength;
            
            // Enhanced visuals during blink slash
            const coreWidth = isSlashing ? 3 : 2;
            const mainWidth = isSlashing ? 7 : 5;
            const glowWidth = isSlashing ? 14 : 10;
            
            // Draw lightsaber core (bright white center)
            ctx.strokeStyle = isSlashing ? '#ffffee' : '#ffffff';
            ctx.globalAlpha = pulseAlpha * (isSlashing ? 1.0 : 0.9);
            ctx.lineWidth = coreWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + laser.offset, p.y - 12);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw main laser beam (colored)
            const mainColor = isSlashing ? laserColor + 'ee' : laserColor;
            ctx.strokeStyle = mainColor;
            ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.9 : 0.8);
            ctx.lineWidth = mainWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + laser.offset, p.y - 12);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw inner glow
            const gradient = ctx.createLinearGradient(p.x + laser.offset, p.y - 12, endX, endY);
            const glowIntensity = isSlashing ? '90' : '80';
            gradient.addColorStop(0, laserColor + glowIntensity);
            gradient.addColorStop(0.5, laserColor + (isSlashing ? '70' : '60'));
            gradient.addColorStop(1, laserColor + (isSlashing ? '40' : '30'));
            
            ctx.strokeStyle = gradient;
            ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.7 : 0.6);
            ctx.lineWidth = glowWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + laser.offset, p.y - 12);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Add outer glow effect
            const outerGlow = isSlashing ? laserColor + '60' : laserColor + '40';
            const outerWidth = isSlashing ? 20 : 16;
            ctx.strokeStyle = outerGlow;
            ctx.globalAlpha = isSlashing ? 0.5 : 0.4;
            ctx.lineWidth = outerWidth;
            ctx.beginPath();
            ctx.moveTo(p.x + laser.offset, p.y - 12);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Add sweeping motion trail (skip during slash mode - we have blur trail instead)
            if (!isSlashing) {
                const trailAngle = laser.angle - (p.wiperLaserSpeed * 0.3);
                const trailEndX = p.x + Math.cos(trailAngle) * laserLength * 0.8;
                const trailEndY = p.y + Math.sin(trailAngle) * laserLength * 0.8;
                
                ctx.strokeStyle = laserColor + '20';
                ctx.globalAlpha = 0.2;
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(p.x + laser.offset, p.y - 12);
                ctx.lineTo(trailEndX, trailEndY);
                ctx.stroke();
            }
            
            // Add polished circular cap at the end of the laser
            const capRadius = isSlashing ? 10 : 8;
            
            // Bright glowing core of the cap
            ctx.fillStyle = isSlashing ? '#ffffee' : '#ffffff';
            ctx.globalAlpha = pulseAlpha * (isSlashing ? 1.0 : 0.9);
            ctx.beginPath();
            ctx.arc(endX, endY, capRadius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Main colored cap
            ctx.fillStyle = isSlashing ? laserColor + 'ee' : laserColor;
            ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.9 : 0.8);
            ctx.beginPath();
            ctx.arc(endX, endY, capRadius * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // Outer glow cap
            const capGradient = ctx.createRadialGradient(endX, endY, 0, endX, endY, capRadius);
            const capGlowIntensity = isSlashing ? '90' : '80';
            capGradient.addColorStop(0, laserColor + capGlowIntensity);
            capGradient.addColorStop(0.5, laserColor + (isSlashing ? '70' : '60'));
            capGradient.addColorStop(1, laserColor + (isSlashing ? '30' : '20'));
            
            ctx.fillStyle = capGradient;
            ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.7 : 0.6);
            ctx.beginPath();
            ctx.arc(endX, endY, capRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Pulsing rim effect
            const rimIntensity = isSlashing ? '60' : '40';
            ctx.strokeStyle = laserColor + rimIntensity;
            const rimPulse = isSlashing ? 0.5 + 0.4 * Math.sin(time * 20) : 0.4 + 0.3 * Math.sin(time * 15);
            ctx.globalAlpha = rimPulse;
            ctx.lineWidth = isSlashing ? 3 : 2;
            ctx.beginPath();
            ctx.arc(endX, endY, capRadius * (isSlashing ? 1.3 : 1.2), 0, Math.PI * 2);
            ctx.stroke();
        });
        
        ctx.restore();
    }
// ...existing code...
    
    
    closeBullets.forEach(item => {
        const b = item.bullet;
        const dist = item.dist;
        
        // Apply fade-in for Death Engine bullet rain
        let fadeAlpha = 1.0;
        if (b.fadeInTime && b.spawnTime) {
            const timeAlive = (performance.now() - b.spawnTime) / 1000;
            fadeAlpha = Math.min(1.0, timeAlive / b.fadeInTime);
        }
        
        const proxFactor = 1.0 - (dist / proximityThreshold);

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = proxFactor * fadeAlpha; 
        const glowRadius = b.r * 2;
        const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
        gradient.addColorStop(0.3, b.col);
        gradient.addColorStop(1, b.col + '00');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = fadeAlpha;
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255, 255, 255, ${proxFactor * 0.8 * fadeAlpha})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
    
    store.activeEffects.forEach(e => e.draw && e.draw());
    renderVoidStepSystems(ctx);
    renderImpactSystem(ctx);
    

    
    // Throttle HUD updates to avoid layout thrashing on every frame
    if (!window.lastHudUpdate || Date.now() - window.lastHudUpdate > 16) { // ~60fps
        updateHUD();
        window.lastHudUpdate = Date.now();
    }
}
    
    function takeDamage(dmg) {
        if (store.player.isInvincible || playerIsInvulnerable()) return;
        // Removed boss invincibility check here - that was preventing ALL damage incorrectly

        if (store.player.hasShieldBubble) {
            store.player.hasShieldBubble = false;
            store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
            return;
        }
        const p = store.player;
        
        // Beef shield takes damage first if pilot is beef
        if (p.pilotGenome === 'beef' && p.beefShield > 0 && p.beefShieldCooldown <= 0) {
            const beefAbsorbed = Math.min(p.beefShield, dmg);
            p.beefShield -= beefAbsorbed;
            dmg -= beefAbsorbed;
            p.beefShieldDamageTaken += beefAbsorbed;
            
            // Reset shield recharge delay when beef shield takes damage
            if (beefAbsorbed > 0) {
                p.shieldRechargeDelay = p.shieldRechargeDelayMax;
                p.shieldRecharging = false;
            }
            
            // If beef shield was depleted, start cooldown
            if (p.beefShield <= 0) {
                p.beefShieldCooldown = 2.0; // 2 second cooldown before shield can absorb again
            }
            
            if (dmg <= 0) return; // All damage absorbed by beef shield
        }
        
        const a = Math.min(p.shield, dmg);
        if (a < dmg) playSound('hit');
        p.shield -= a;
        dmg -= a;
        
        // Reset shield recharge delay whenever any damage is taken
        if (a > 0 || dmg > 0) {
            p.shieldRechargeDelay = p.shieldRechargeDelayMax;
            p.shieldRecharging = false;
        }
        
        // Check for nano save BEFORE applying damage
        const hpAfterDamage = p.hp - dmg;
        if (hpAfterDamage <= 0 && p.nanoSaves > 0) {
            p.nanoSaves--;
            const revivedHp = Math.max(p.hpMax * 0.3, hpAfterDamage + p.hpMax * 0.35);
            p.hp = Math.max(1, Math.min(p.hpMax, revivedHp));
            store.activeEffects.push(createEffect("nanoHeal"));
            announce('NANO SAVE ACTIVATED!');
            return; // Don't apply the lethal damage
        }
        
        p.hp = Math.max(0, hpAfterDamage);

        if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
            store.world.lowHealthTutorialShown = true;
            showShopWithHighlight();
        }
    }
    
    function updateBeefShield() {
        if (store.player.pilotGenome !== 'beef') return;
        
        const p = store.player;
        const damageDealt = p.beefShieldDamageDealt;
        const damageTaken = p.beefShieldDamageTaken;
        
        // Skip if no damage events
        if (damageDealt === 0 && damageTaken === 0) return;
        
        // Update cooldown
        if (p.beefShieldCooldown > 0) {
            p.beefShieldCooldown -= 0.016; // Decrease by ~1/60 (assuming 60 FPS)
            if (p.beefShieldCooldown < 0) p.beefShieldCooldown = 0;
        }
        
        // Growth rate: 1 shield per 50 damage dealt, shrinkage rate: 1 shield per 30 damage taken
        // Made more responsive for better gameplay feel
        const shieldChange = (damageDealt * 0.02) - (damageTaken * 0.033);
        
        if (shieldChange > 0) {
            // Shield grows
            p.beefShield = Math.min(p.beefShieldMax, p.beefShield + shieldChange);
        } else if (shieldChange < 0) {
            // Shield shrinks (but not below 0)
            p.beefShield = Math.max(0, p.beefShield + shieldChange);
        }
        
        // Reset damage tracking counters
        p.beefShieldDamageDealt = 0;
        p.beefShieldDamageTaken = 0;
        

    }
    
    function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function announce(text) { const el = q('announce'); el.textContent = text; el.classList.remove('hide'); clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); }
// ...existing code...
    function updateHUD() { 
        const player = store.player;
        if (!player) return;

        const pilotTitle = q("pilotTitle");
        const scoreNum = q("scoreNum");
        const goldNum = q("goldNum");
        const hpBarFill = q("hpBarFill");
        const hpText = q("hpText");
        const beefShieldBar = q("beefShieldBar");
        const beefShieldBarFill = q("beefShieldBarFill");
        const beefShieldText = q("beefShieldText");
        const shieldBar = q("shieldBar");
        const shieldBarFill = q("shieldBarFill");
        const shieldTextEl = q("shieldText");
        const waveNum = q("waveNum");
        const killsNum = q("killsNum");
        const levelNum = q("levelNum");
        const bossContent = q("hudBossContent");
        const bossTitle = q("bossTitle");
        const bossBarFill = q("bossBarFill");
        const powerupEl = q("hudPowerup");
        const powerupList = q("powerupList");
        const equipEl = q("hudEquipment");
        const equipmentList = q("equipmentList");
        const grenadeBtn = q('grenadeBtnUI');
        const fpsEl = q('fps');

        if (!pilotTitle || !scoreNum || !goldNum || !hpBarFill || !hpText || !shieldBar || !shieldBarFill || !shieldTextEl) {
            if (!store._hudInitWarned && typeof console !== 'undefined') {
                console.warn('[HUD] Elements missing, skipping update until UI is ready.');
                store._hudInitWarned = true;
            }
            return;
        }
        store._hudInitWarned = false;

        const hpPercent = Math.round((player.hp / player.hpMax) * 100);
        const shieldPercent = player.shieldMax > 0 ? Math.round((player.shield / player.shieldMax) * 100) : 0;
        const beefShieldPercent = player.pilotGenome === 'beef' && player.beefShieldMax > 0 ? Math.round((player.beefShield / player.beefShieldMax) * 100) : 0;

        pilotTitle.textContent = store.name ? `â—¢ ${store.name} â—£` : "â—¢ UNIDENTIFIED â—£";
        scoreNum.textContent = store.world.score;
        goldNum.textContent = store.world.gold;
        if (!store.world.mechForgeGoldTriggered && store.world.gold >= 135) {
            triggerMechForgeGoldMilestone();
        }

        hpBarFill.style.width = `${hpPercent}%`;
        hpText.textContent = `HP: ${Math.round(player.hp)} / ${player.hpMax}`;

        if (beefShieldBar && beefShieldText && beefShieldBarFill) {
            if (player.pilotGenome === 'beef' && player.beefShieldMax > 0) {
                beefShieldBar.style.display = "block";
                beefShieldBarFill.style.width = `${beefShieldPercent}%`;
                beefShieldText.textContent = `BEEF SHIELD: ${Math.round(player.beefShield)} / ${player.beefShieldMax}`;
            } else {
                beefShieldBar.style.display = "none";
                beefShieldText.textContent = "";
            }
        }

        shieldBar.style.display = "block";
        shieldBarFill.style.width = `${shieldPercent}%`;
        shieldTextEl.textContent = player.shieldMax > 0
            ? `SHIELD: ${Math.round(player.shield)} / ${player.shieldMax}`
            : 'SHIELD: 0 / 0';

        if (waveNum) waveNum.textContent = store.world.wave;
        if (killsNum) killsNum.textContent = store.world.kills;
        if (levelNum) levelNum.textContent = store.world.level;

        if (bossContent && bossTitle && bossBarFill) {
            if (store.boss) {
                bossContent.classList.remove("hide");
                bossTitle.textContent = `âš¡ ${store.boss.name} âš¡`;
                bossBarFill.style.width = `${Math.round((store.boss.hp / store.boss.hpMax) * 100)}%`;
            } else {
                bossContent.classList.add("hide");
            }
        }

        if (powerupEl && powerupList) {
            const timedPowerups = Object.keys(player.powerupTimers || {});
            if (timedPowerups.length > 0) {
                let timedContent = '';
                timedPowerups.forEach(key => {
                    const timer = player.powerupTimers[key];
                    if (!timer || !POWERUP_TYPES[key]) return;
                    const percent = Math.round((timer.remaining / timer.max) * 100);
                    timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`;
                });
                powerupList.innerHTML = timedContent;
                powerupEl.classList.remove('hide');
            } else {
                powerupEl.classList.add('hide');
            }
        }

        if (equipEl && equipmentList) {
            const hasEquipment = player.hasLauncher || player.hasHounds || player.nanoSaves > 0;
            if (hasEquipment) {
                let content = '';
                if (player.nanoSaves > 0) content += `<div>NANO SAVE [${player.nanoSaves}]</div>`;
                if (player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`;
                if (player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`;
                equipmentList.innerHTML = content;
                equipEl.classList.remove('hide');
            } else {
                equipEl.classList.add('hide');
            }
        }

        if (grenadeBtn) {
            if (player.grenades > 0) {
                grenadeBtn.classList.remove('hide');
                grenadeBtn.textContent = `GRENADE [${player.grenades}]`;
                grenadeBtn.disabled = false;
            } else {
                grenadeBtn.classList.add('hide');
            }
        }

        if (!store.fpsLastTime) {
            store.fpsLastTime = performance.now();
            store.fpsFrameCount = 0;
        }
        store.fpsFrameCount++;
        const now = performance.now();
        if (fpsEl && now - store.fpsLastTime >= 1000) {
            const fps = Math.round((store.fpsFrameCount * 1000) / (now - store.fpsLastTime));
            fpsEl.textContent = fps;
            
            // COMMENTED OUT: Enhanced collar display with better feedback
            /*
            const collarStacks = sanitizeCollarStacks();
            const collarBonus = calculateCollarBonus(collarStacks);
            const collarPercent = (collarBonus - 1) * 100;
            const collarStatus = collarStacks === 0 ? 'LOOSE' : 
                                collarStacks < 25 ? 'CRUSHING' : 'MAXIMUM';
            q('collar').textContent = `${collarStacks.toFixed(1)} (${collarPercent.toFixed(0)}%) ${collarStatus}`;
            */
            
            // COMMENTED OUT: Calculate damage per bullet and average enemy HP
            /*
            const baseDamage = 15; // Updated from 20 to 15 (75% of original)
            const actualDamage = baseDamage * store.player.dmgMult;
            q('damagePerBullet').textContent = `${actualDamage.toFixed(1)}`;
            
            // Calculate average enemy HP across all enemy types
            const enemyTypes = [
            ];
            const avgBaseHp = enemyTypes.reduce((sum, type) => sum + type.hp, 0) / enemyTypes.length;
            const waveMultiplier = Math.pow(1.03, store.world.wave - 1);
            const avgCurrentHp = avgBaseHp * waveMultiplier * collarBonus;
            q('avgEnemyHp').textContent = `${avgCurrentHp.toFixed(0)}`;
            */
            
            const spawnDebugEl = q('spawnDebug');
            if (spawnDebugEl) {
                // Spawn debug info can stay if needed for development
            }
            
            store.fpsFrameCount = 0;
            store.fpsLastTime = now;
            
            // COMMENTED OUT: Update health table
            /*
            if (store.enemies.length > 0) {
                const enemy = store.enemies[0]; // Get first enemy for reference
                q('enemyCurrentHp').textContent = Math.round(enemy.hp);
            } else {
                q('enemyCurrentHp').textContent = '0';
            }
            if (store.boss) {
                q('bossCurrentHp').textContent = Math.round(store.boss.hp);
                q('bossBaseHp').textContent = Math.round(store.boss.hpMax);
            } else {
                q('bossCurrentHp').textContent = '0';
                q('bossBaseHp').textContent = '0';
            }
            */
        }
    }
// ...existing code...
    function normalizeLeaderboardEntries(source) {
        if (!source) return null;

        if (Array.isArray(source)) {
            return source;
        }

        if (Array.isArray(source.entries)) {
            return source.entries;
        }

        if (Array.isArray(source.top50)) {
            return source.top50;
        }

        if (Array.isArray(source.top10)) {
            return source.top10;
        }

        if (source.top50 && Array.isArray(source.top50.entries)) {
            return source.top50.entries;
        }

        if (source.top10 && Array.isArray(source.top10.entries)) {
            return source.top10.entries;
        }

        if (Array.isArray(source.data)) {
            return source.data;
        }

        if (source.data && Array.isArray(source.data.entries)) {
            return source.data.entries;
        }

        return null;
    }

    function updateLeaderboard(leaderboardData) { 
        const fallbackData = [
            { name: "ACE PILOT", score: 50000, waves: 10 },
            { name: "VOID RUNNER", score: 35000, waves: 8 },
            { name: "STAR HUNTER", score: 25000, waves: 6 },
            { name: "NOVA STRIKER", score: 18000, waves: 5 },
            { name: "COSMIC GUARD", score: 12000, waves: 4 }
        ]; 
        
        const entries = normalizeLeaderboardEntries(leaderboardData) ?? fallbackData;

        if (entries === fallbackData && leaderboardData) {
            console.warn("Leaderboard payload had unexpected shape, using fallback:", leaderboardData);
        }
        
        const safeEntries = entries.filter(entry => entry && typeof entry === "object");
        
        const listHtml = safeEntries.map(s => `<li>${escapeHtml(s.name ?? "UNKNOWN PILOT")} â€” ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");
        const popupHtml = safeEntries.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name ?? "UNKNOWN PILOT")} â€” ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");
        
        const hsList = q("hsList");
        const hsListPopup = q("hsListPopup");
        if (hsList) hsList.innerHTML = listHtml;
        if (hsListPopup) hsListPopup.innerHTML = popupHtml;
    }
    
    async function refreshScoreList() { 
        try { 
            const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 }); 
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`); 
            const data = await res.json(); 
            // data.entries contains up to 50 players
            updateLeaderboard(data); 
        } catch (err) { 
            console.warn("Failed to fetch leaderboard, using offline data:", err.message); 
            updateLeaderboard(null); 
        } 
    }
    async function addScore(score) {
        if (store.cheatsUsed) {
            announce("Score not submitted: Cheats used");
            return;
        }
        const name = (store.name || "ROGUE").slice(0, 16); 
        try { 
            const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 }); 
            if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`); 
            const { nonce } = await nonceRes.json(); 
            const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce }; 
            const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 }); 
            if (!res.ok) throw new Error(`Submit failed: ${res.status}`); 
            const data = await res.json(); 
            if (data.ok) { 
                updateLeaderboard(data); 
            } else { 
                console.warn("Score rejected:", data.err); 
                announce(`Score rejected: ${data.err}`); 
                refreshScoreList(); 
            } 
        } catch (err) { 
            console.warn("Score submission failed, game continues offline:", err.message); 
        } 
    }
    function fireBullet(x, y, vx, vy, props = {}) { 
        const p = store.player; 
        const swirlFlag = props.isSwirl !== undefined ? props.isSwirl : !!p.swirlShots;
        return spawnBullet({
            x, y, vx, vy,
            r: p.explosive ? 5 : 3,
            col: p.explosive ? "#ED2F32" : "#b266ff",
            dmg: 15 * p.dmgMult,
            pierce: p.piercing,
            explosive: p.explosive,
            ...props,
            isSwirl: swirlFlag
        });
    }
    function firePlayer() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        const baseBulletSpeed = 420;
        const bulletSpeed = baseBulletSpeed;
        const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0);
        const angleSpread = 10;
        for (let i = 0; i < totalMultishot; i++) { 
            const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; 
            spawnBullet({
                x: p.x + 10 * Math.sin(angle),
                y: p.y - 12,
                vx: Math.sin(angle) * bulletSpeed,
                vy: -Math.cos(angle) * bulletSpeed,
                r: p.explosive ? 5 : 3,
                col: p.explosive ? "#cc99ff" : "#b266ff",
                dmg: 15 * p.dmgMult,
                pierce: p.piercing,
                explosive: p.explosive,
                isSwirl: p.swirlShots
            });
        }
        if (p.hasIceman && store.iceman) {
            for (let i = 0; i < totalMultishot; i++) {
                const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                spawnBullet({
                    x: store.iceman.x + 10 * Math.sin(angle),
                    y: store.iceman.y - 12,
                    vx: Math.sin(angle) * bulletSpeed,
                    vy: -Math.cos(angle) * bulletSpeed,
                    r: p.explosive ? 5 : 3,
                    col: "#66aaff",
                    dmg: 15 * p.dmgMult * 0.35,
                    pierce: p.piercing,
                    explosive: p.explosive,
                    isIceman: true,
                    isSwirl: p.swirlShots
                });
            }
        }
        if (p.hasBeefClone && store.beefClone) {
            for (let i = 0; i < totalMultishot; i++) {
                const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                spawnBullet({
                    x: store.beefClone.x + 10 * Math.sin(angle),
                    y: store.beefClone.y - 12,
                    vx: Math.sin(angle) * bulletSpeed,
                    vy: -Math.cos(angle) * bulletSpeed,
                    r: p.explosive ? 5 : 3,
                    col: "#66ff66", // Green color for beef clone
                    dmg: 15 * p.dmgMult * 0.35,
                    pierce: p.piercing,
                    explosive: p.explosive,
                    isBeefClone: true,
                    isSwirl: p.swirlShots
                });
            }
        }
        if (p.rearMultishot > 0) {
            const rearAngleSpread = 15;
            for (let i = 0; i < p.rearMultishot; i++) {
                const angle = (i - (p.rearMultishot - 1) / 2) * rearAngleSpread;
                const radAngle = angle * Math.PI / 180;
                spawnBullet({
                    x: p.x + 10 * Math.sin(radAngle),
                    y: p.y + 12,
                    vx: Math.sin(radAngle) * bulletSpeed,
                    vy: Math.cos(radAngle) * bulletSpeed,
                    r: 3,
                    col: "#ffddff",
                    dmg: 11.25 * p.dmgMult,
                    pierce: p.piercing > 0 ? p.piercing - 1 : 0,
                    isSwirl: p.swirlShots
                });
            }
        }
        store.drones.forEach(drone => spawnBullet({
            x: p.x + drone.offset,
            y: p.y + 20,
            vx: 0,
            vy: -bulletSpeed,
            r: 3,
            col: "#66aaff",
            dmg: 15 * p.dmgMult * 0.4,
            isDrone: true,
            isSwirl: p.swirlShots
        }));
        if (p.hasLauncher) {
            const speed = 350;
            const numPairs = store.player.upgradeLevels.launcher || 1;
            for (let i = 0; i < numPairs; i++) {
                const spread = 15 + i * 10;
                const vx_offset = 50 + i * 20;
                spawnBullet({ x: p.x - spread, y: p.y, vx: -vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                spawnBullet({ x: p.x + spread, y: p.y, vx: vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                if (p.hasIceman && store.iceman) {
                    spawnBullet({ x: store.iceman.x - spread, y: store.iceman.y, vx: -vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                    spawnBullet({ x: store.iceman.x + spread, y: store.iceman.y, vx: vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                }
                if (p.hasBeefClone && store.beefClone) {
                    spawnBullet({ x: store.beefClone.x - spread, y: store.beefClone.y, vx: -vx_offset, vy: -speed, r: 4, col: '#66ff66', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isBeefClone: true });
                    spawnBullet({ x: store.beefClone.x + spread, y: store.beefClone.y, vx: vx_offset, vy: -speed, r: 4, col: '#66ff66', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isBeefClone: true });
                }
            }
        }
    }
    
    function fireFlamethrower() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        
        let numFlames, angleRange, speed, life;
        switch (p.flamethrowerLevel) {
            case 1: numFlames = 4; angleRange = 40; speed = 250; life = 0.35; break;    // Halved from 8
            case 2: numFlames = 6; angleRange = 70; speed = 280; life = 0.4; break;     // Halved from 12
            default: numFlames = 8; angleRange = 90; speed = 320; life = 0.5; break;    // Halved from 16
        }
        
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
            const currentSpeed = speed + Math.random() * 40;
            const sideOffset = (i % 2 === 0) ? -15 : 15;
            const spawnX = p.x + sideOffset;
            const spawnY = p.y + 5;
            spawnBullet({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 3, col: `rgba(255, ${60 + Math.random() * 60}, 0, 0.9)`, dmg: 2 * p.dmgMult, life: life * 1.5, isFlame: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
        }
        
        if (p.hasIceman && store.iceman) {
            for (let i = 0; i < numFlames; i++) {
                const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                const currentSpeed = speed + Math.random() * 40;
                const sideOffset = (i % 2 === 0) ? -15 : 15;
                const spawnX = store.iceman.x + sideOffset;
                const spawnY = store.iceman.y + 5;
                spawnBullet({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 2, col: `rgba(100, 150, 255, 0.7)`, dmg: 2 * p.dmgMult * 0.35, life: life, isFlame: true, isIceman: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
            }
        }
    }

    function launchStarProjectile(originX, originY, angle, options = {}) {
        const speedMultiplier = options.speedMultiplier ?? 1;
        const projectile = {
            x: originX,
            y: originY,
            vx: Math.sin(angle) * STAR_CANNON_SPEED * speedMultiplier,
            vy: -Math.cos(angle) * STAR_CANNON_SPEED * speedMultiplier,
            size: STAR_CANNON_SIZE,
            rotation: 0,
            trail: [],
            maxTrailLength: 28,
            hitIds: new Set(),
            damageScale: options.damageScale ?? 1,
            isIceman: options.isIceman || false,
            hitboxScale: options.hitboxScale ?? STAR_CANNON_HITBOX_SCALE,
            trailColor: options.trailColor || null,
            primaryColor: options.primaryColor || null,
            coreColor: options.coreColor || null,
            shadowColor: options.shadowColor || null,
            isEnemy: options.isEnemy || false,
            enemyDamage: options.enemyDamage ?? 0
        };
        store.starProjectiles.push(projectile);
    }

    function fireStarCannon() {
        const p = store.player;
        playSound('stargun');
        const originY = p.y - 12;
        const lateralOffset = 26;
        const shots = [];
        if (p.starCannonLevel >= 1) {
            shots.push({ originX: p.x - lateralOffset, angle: -Math.PI / 6, offset: -lateralOffset });
        }
        if (p.starCannonLevel >= 2) {
            shots.push({ originX: p.x + lateralOffset, angle: Math.PI / 6, offset: lateralOffset });
        }

        for (const shot of shots) {
            launchStarProjectile(shot.originX, originY, shot.angle, {
                hitboxScale: STAR_CANNON_HITBOX_SCALE
            });
        }

        if (p.starCannonIcemanSupport && p.hasIceman && store.iceman) {
            const icemanOriginY = store.iceman.y - 12;
            for (let i = 0; i < shots.length; i++) {
                const shot = shots[i];
                store.pendingStarClones.push({
                    delay: STAR_CANNON_CLONE_DELAY,
                    originX: store.iceman.x + shot.offset,
                    originY: icemanOriginY,
                    angle: shot.angle,
                    damageScale: STAR_CANNON_ICEMAN_DAMAGE_SCALE,
                    playSound: true
                });
            }
        }
        if (p.starCannonIcemanSupport && p.hasBeefClone && store.beefClone) {
            const beefCloneOriginY = store.beefClone.y - 12;
            for (let i = 0; i < shots.length; i++) {
                const shot = shots[i];
                store.pendingStarClones.push({
                    delay: STAR_CANNON_CLONE_DELAY,
                    originX: store.beefClone.x + shot.offset,
                    originY: beefCloneOriginY,
                    angle: shot.angle,
                    damageScale: STAR_CANNON_ICEMAN_DAMAGE_SCALE,
                    playSound: true
                });
            }
        }
    }

    function updateStarProjectiles(dt) {
        if (store.pendingStarClones.length) {
            for (let i = store.pendingStarClones.length - 1; i >= 0; i--) {
                const pending = store.pendingStarClones[i];
                pending.delay -= dt;
                if (pending.delay <= 0) {
                    launchStarProjectile(pending.originX, pending.originY, pending.angle, {
                        damageScale: pending.damageScale,
                        isIceman: true,
                        hitboxScale: STAR_CANNON_HITBOX_SCALE
                    });
                    if (pending.playSound) {
                        playSound('stargun');
                    }
                    store.pendingStarClones.splice(i, 1);
                }
            }
        }

        if (!store.starProjectiles.length) return;
        const p = store.player;
        const baseDamage = STAR_CANNON_DAMAGE * p.dmgMult;
        const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;

        for (let i = store.starProjectiles.length - 1; i >= 0; i--) {
            const star = store.starProjectiles[i];
            star.x += star.vx * dt;
            star.y += star.vy * dt;
            star.rotation += dt * 2.4;

            star.trail.push({ x: star.x, y: star.y, life: 1, size: star.size * 0.55 });
            if (star.trail.length > star.maxTrailLength) star.trail.shift();
            for (let t = star.trail.length - 1; t >= 0; t--) {
                const particle = star.trail[t];
                particle.life -= dt * 2.6;
                particle.size *= 1 - dt * 1.6;
                if (particle.life <= 0 || particle.size <= 0.2) star.trail.splice(t, 1);
            }

            const hitRadius = star.size * (star.hitboxScale || STAR_CANNON_HITBOX_SCALE);
            if (star.isEnemy) {
                const player = store.player;
                const playerRadius = player.r || 18;
                const dx = star.x - player.x;
                const dy = star.y - player.y;
                const combined = hitRadius + playerRadius;
                if (dx * dx + dy * dy <= combined * combined) {
                    if (star.enemyDamage > 0) {
                        takeDamage(star.enemyDamage);
                    }
                    store.starProjectiles.splice(i, 1);
                    continue;
                }

                if (store.iceman) {
                    const icemanRadius = 18;
                    const iDx = star.x - store.iceman.x;
                    const iDy = star.y - store.iceman.y;
                    const iCombined = hitRadius + icemanRadius;
                    if (iDx * iDx + iDy * iDy <= iCombined * iCombined) {
                        store.starProjectiles.splice(i, 1);
                        continue;
                    }
                }

                if (store.beefClone) {
                    const cloneRadius = 18;
                    const cDx = star.x - store.beefClone.x;
                    const cDy = star.y - store.beefClone.y;
                    const cCombined = hitRadius + cloneRadius;
                    if (cDx * cDx + cDy * cDy <= cCombined * cCombined) {
                        store.starProjectiles.splice(i, 1);
                        continue;
                    }
                }
            } else {
                for (const target of targets) {
                    if (!target || target.dead || target.hp <= 0) continue;
                    if (target === store.boss && target.isInvincible) continue;
                    if (target.isHeatDeath) continue;

                    const targetRadius = target.r || target.radius || 18;
                    const dx = star.x - target.x;
                    const dy = star.y - target.y;
                    const combined = hitRadius + targetRadius;
                    if (dx * dx + dy * dy <= combined * combined) {
                        const id = target.id || target.__starId || target;
                        if (!star.hitIds.has(id)) {
                            const starDamage = baseDamage * (star.damageScale ?? 1);
                            applyStarDamage(target, starDamage);
                            star.hitIds.add(id);
                        }
                    }
                }
            }

            if (star.x < -80 || star.x > W + 80 || star.y < -120 || star.y > H + 120) {
                store.starProjectiles.splice(i, 1);
            }
        }
    }

    function applyStarDamage(target, dmg) {
        const p = store.player;
        let damage = dmg;

        if (Math.random() < p.critChance) {
            damage *= p.critDamage;
            store.activeEffects.push(createEffect('critText', target.x, target.y));
            if (Math.random() < 0.05) spawnPowerup(target.x, target.y);
        }

        if (target === store.boss) playSound('hit');
        target.hp -= damage;
        store.world.totalDamage = (store.world.totalDamage || 0) + damage;

        if (p.pilotGenome === 'beef') {
            p.beefShieldDamageDealt = (p.beefShieldDamageDealt || 0) + damage;
        }

        if (p.vampirism > 0) {
            let healAmount = damage * p.vampirism;
            healAmount = Math.max(healAmount, 1);
            healAmount = Math.min(healAmount, 5);
            p.hp = Math.min(p.hpMax, p.hp + healAmount);
        }

        if (target.hp <= 0) {
            target.dead = true;
            if (target.type === 'void_champion') {
                store.enemies.forEach(minion => {
                    if (minion.orbitTargetId === target.id && !minion.dead) {
                        spawnGibs(minion.x, minion.y, minion.color);
                        minion.dead = true;
                    }
                });
                handleVoidChampionReward(target);
            }

            if (target === store.boss) {
                handleBossDefeat();
            } else {
                spawnGibs(target.x, target.y, target.color);
                store.world.score += target.score;
                store.world.gold += target.gold;
                store.world.xp += target.xp;
                store.world.kills++;

                spawnPowerup(target.x, target.y);
                explode(target.x, target.y);
            }
        }
    }

    function drawStarProjectiles() {
        if (!store.starProjectiles.length) return;
        for (const star of store.starProjectiles) {
            const isEnemyStar = !!star.isEnemy;
            const isIcemanStar = !!star.isIceman && !isEnemyStar;
            const trailFillBase = isEnemyStar
                ? (star.trailColor || 'rgba(150, 160, 220, ')
                : (isIcemanStar ? 'rgba(190, 225, 255, ' : 'rgba(255, 255, 200, ');
            const trailShadowBase = isEnemyStar
                ? 'rgba(80, 90, 160, '
                : (isIcemanStar ? 'rgba(140, 200, 255, ' : 'rgba(255, 240, 150, ');
            for (const particle of star.trail) {
                const trailAlpha = Math.max(0, Math.min(1, particle.life * 0.6));
                const shadowAlpha = Math.max(0, Math.min(1, particle.life));
                ctx.fillStyle = `${trailFillBase}${trailAlpha})`;
                ctx.shadowColor = `${trailShadowBase}${shadowAlpha})`;
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.save();
            ctx.translate(star.x, star.y);
            ctx.rotate(star.rotation);

            ctx.fillStyle = isEnemyStar
                ? (star.primaryColor || 'rgba(200, 205, 255, 0.82)')
                : (isIcemanStar ? 'rgba(180, 215, 255, 0.85)' : 'rgba(255, 255, 140, 0.85)');
            ctx.shadowColor = isEnemyStar
                ? (star.shadowColor || 'rgba(70, 80, 160, 0.9)')
                : (isIcemanStar ? 'rgba(140, 200, 255, 0.9)' : 'rgba(255, 220, 120, 0.9)');
            ctx.shadowBlur = 24;
            drawStarShape(ctx, 0, 0, 5, star.size, star.size * 0.45);
            ctx.fill();

            ctx.fillStyle = isEnemyStar
                ? (star.coreColor || '#c8ccff')
                : (isIcemanStar ? '#eef7ff' : '#fffbe6');
            ctx.shadowBlur = 12;
            drawStarShape(ctx, 0, 0, 5, star.size * 0.65, star.size * 0.28);
            ctx.fill();

            ctx.restore();
            ctx.shadowBlur = 0;
        }
    }

    function drawShadowEchoes() {
        if (!store.shadowEchoes || !store.shadowEchoes.length) return;
        ctx.save();
        for (const echo of store.shadowEchoes) {
            const lifeRatio = echo.maxLife ? Math.max(0, Math.min(1, echo.life / echo.maxLife)) : 1;
            if (lifeRatio <= 0) continue;
            ctx.globalAlpha = 0.35 * lifeRatio;
            ctx.fillStyle = `rgba(150, 160, 255, ${0.25 + lifeRatio * 0.35})`;
            ctx.beginPath();
            ctx.ellipse(echo.x, echo.y, 24 * lifeRatio, 16 * lifeRatio, echo.rotation || 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
        ctx.globalAlpha = 1;
    }

    function drawStarShape(ctx, cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        const step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius;
            y = cy + Math.sin(rot) * outerRadius;
            ctx.lineTo(x, y);
            rot += step;

            x = cx + Math.cos(rot) * innerRadius;
            y = cy + Math.sin(rot) * innerRadius;
            ctx.lineTo(x, y);
            rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
    }

    function drawGoldenOrbs() {
        if (!store.goldenOrbs || store.goldenOrbs.length === 0) {
            return;
        }
        const time = performance.now() / 1000;

        for (const orb of store.goldenOrbs) {
            if (orb.trail && orb.trail.length) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const node of orb.trail) {
                    const lifeRatio = Math.max(0, node.life / GOLDEN_ORB_CONFIG.trailLife);
                    if (lifeRatio <= 0) continue;
                    ctx.globalAlpha = lifeRatio * 0.45;
                    ctx.fillStyle = `rgba(255, 210, 120, ${lifeRatio * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 9 * lifeRatio, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            ctx.save();
            ctx.translate(orb.x, orb.y);
            if (orb.state === 'homing') {
                ctx.rotate(orb.heading || 0);
            }
            ctx.globalCompositeOperation = 'lighter';

            const pulse = 0.85 + Math.sin(time * 6 + (orb.pulseOffset || 0)) * 0.15;
            const outerGlowRadius = orb.r * (1.4 + pulse * 0.25);
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerGlowRadius);
            glowGradient.addColorStop(0, 'rgba(255, 255, 220, 0.18)');
            glowGradient.addColorStop(0.5, 'rgba(255, 210, 100, 0.4)');
            glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(0, 0, outerGlowRadius, 0, Math.PI * 2);
            ctx.fill();

            const ringOuter = orb.r * (0.95 + pulse * 0.12);
            const ringInner = ringOuter * 0.55;
            const ringGradient = ctx.createRadialGradient(0, 0, ringInner * 0.75, 0, 0, ringOuter);
            ringGradient.addColorStop(0, 'rgba(255, 250, 210, 0.85)');
            ringGradient.addColorStop(0.45, 'rgba(255, 210, 90, 0.75)');
            ringGradient.addColorStop(0.9, 'rgba(255, 130, 20, 0.35)');
            ringGradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
            ctx.fillStyle = ringGradient;
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 225, 140, 0.95)';
            ctx.lineWidth = Math.max(3, orb.r * 0.18);
            ctx.beginPath();
            ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255, 255, 220, 0.5)';
            ctx.lineWidth = Math.max(2, orb.r * 0.12);
            ctx.beginPath();
            ctx.arc(0, 0, ringInner, 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalAlpha = 0.6 + 0.3 * Math.sin(time * 8 + (orb.pulseOffset || 0));
            ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
            ctx.beginPath();
            ctx.arc(0, 0, ringInner * 0.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
        ctx.globalAlpha = 1;
    }
    
    function ensureShadowCloneInit(b) {
        if (b.shadowInitialized) return;
        b.shadowInitialized = true;
        b.shadowAbilityCooldown = 30;
        b.shadowAbilityTimers = {
            star: 6 + Math.random() * 2,
            lightning: 12 + Math.random() * 2,
            hounds: 18 + Math.random() * 2,
            charge: 24 + Math.random() * 2
        };
        b.shadowAbilityOrder = ['star', 'lightning', 'hounds', 'charge'];
        b.shadowAbilityIndex = 0;
        b.multishotTimer = 0.9;
        b.shadowChargeVX = 0;
        b.shadowChargeVY = 0;
        b.shadowChargeTrailCooldown = 0;
        b.shadowChargeHit = false;
        b.shadowTelegraph = null;
        b.shadowTelegraphTarget = null;
        spawnShadowChampionEscort(b);
    }

    function getActiveShadowChampion() {
        if (!store.shadowChampionId) return null;
        return store.enemies.find(e => e.id === store.shadowChampionId && !e.dead) || null;
    }

    function spawnShadowChampionEscort(boss) {
        if (!store || !store.enemies) return null;
        if (store.shadowChampionDefeated) return null;
        const existing = getActiveShadowChampion();
        if (existing) {
            store.shadowChampionLastPos = { x: existing.x, y: existing.y };
            return existing;
        }

        const guardRadius = 130;
        const spawnAngle = Math.random() * Math.PI * 2;
        const offsetX = Math.cos(spawnAngle) * guardRadius;
        const offsetY = Math.sin(spawnAngle) * Math.max(guardRadius * 0.55, 60);
        const targetY = clamp(boss.y + 90, 120, H * 0.78);
        const spawnX = clamp(boss.x + offsetX, 60, W - 60);
        const spawnProps = {
            x: spawnX,
            y: targetY,
            hpScale: Math.max(1.1, boss.hpMax ? boss.hpMax / 4500 : 1.1),
            damageMult: 1 + Math.max(0, store.world.wave - 8) * 0.025,
            guardRadius,
            guardAngle: spawnAngle,
            angularSpeed: 0.7 + Math.random() * 0.25,
            anchorOffsetY: 90,
            bossLinkId: boss._instanceId || (boss._instanceId = performance.now() + Math.random()),
            fireCooldown: boss.isEnraged ? 1.1 : 1.35,
            momentum: 3.6
        };

        const champion = spawnEnemy('shadow_champion', spawnProps);
        if (!champion) return null;

        champion.x = spawnX;
        champion.y = targetY;
        store.enemies.push(champion);
        store.shadowChampionId = champion.id;
    store.shadowChampionDefeated = false;
    store.shadowChampionTokenDropped = false;
        store.shadowChampionLastPos = { x: champion.x, y: champion.y };

        activateSpawnIntro(champion, {
            duration: 0.75,
            dropDistance: 200,
            targetY,
            effectColor: '#8f9bff',
            topClampBuffer: 0.7,
            fireDelayBuffer: 0.6,
            clusterIndex: -1
        });

        store.activeEffects.push(createEffect('spawnTeleport', champion.x, targetY, champion.r || 22, {
            duration: 1.1,
            color: '#8f9bff',
            clusterIndex: -1,
            isChampion: true
        }));

        announce('Shadow champion joins the mirror!');
        return champion;
    }

    function dropShadowChampionToken(x, y) {
        if (store.shadowChampionTokenDropped) return;
        if (!store.powerups) store.powerups = [];
        const dropX = clamp(x, 20, W - 20);
        const dropY = clamp(y, 40, H - 40);
        store.powerups.push({ x: dropX, y: dropY, r: 16, type: 'shadow_champion_token' });
        store.shadowChampionTokenDropped = true;
        announce('Champion sigil recovered! Summon secured.');
    }

    function finalizeShadowChampionAfterBoss(bossX, bossY) {
        if (store.shadowChampionTokenDropped) return;
        let dropPos = { x: bossX, y: bossY };
        const champion = getActiveShadowChampion();
        if (champion) {
            dropPos = { x: champion.x, y: champion.y - 18 };
            champion.dead = true;
            spawnGibs(champion.x, champion.y, champion.color);
        } else if (store.shadowChampionLastPos) {
            dropPos = { x: store.shadowChampionLastPos.x, y: store.shadowChampionLastPos.y - 18 };
        }
        store.shadowChampionId = null;
        store.shadowChampionDefeated = true;
        store.shadowChampionLastPos = { x: dropPos.x, y: dropPos.y };
        dropShadowChampionToken(dropPos.x, dropPos.y);
    }

    const PLAYER_CHAMPION_CONFIG = Object.freeze({
        baseGuardRadius: 110,
        baseAngularSpeed: 1.35,
        baseFireCooldown: 1.25,
        baseDashCooldown: 2.8,
        maxLevel: 5,
        maxMinions: 3
    });

    function ensureChampionCollections() {
        if (!store.championMinions) store.championMinions = [];
    }

    function spawnChampionMinion(owner) {
        ensureChampionCollections();
        if (!owner) return null;
        const level = owner.level || 1;
        const minionCount = store.championMinions.length;
        if (minionCount >= PLAYER_CHAMPION_CONFIG.maxMinions) return null;
        const id = performance.now() + Math.random();
        
        // Position minions in a triangle formation (120 degrees apart)
        const baseAngle = (minionCount * Math.PI * 2) / 3; // 120 degrees apart
        const orbitRadius = 58 + minionCount * 8; // Slight radius variation
        
        const minion = {
            id,
            ownerId: owner.id,
            orbitRadius: orbitRadius,
            orbitAngle: baseAngle + Math.random() * 0.2 - 0.1, // Small random offset
            orbitSpeed: 1.65 + minionCount * 0.15, // Slight speed variation
            pulsePhase: Math.random() * Math.PI * 2,
            swirlPhase: Math.random() * Math.PI * 2,
            fireCooldown: Math.max(0.9, 1.4 - level * 0.12),
            fireTimer: 0.35 + Math.random() * 0.4,
            damageScale: 1 + (level - 1) * 0.18,
            dead: false
        };
        const anchorX = owner.x + Math.cos(minion.orbitAngle) * minion.orbitRadius;
        const anchorY = owner.y + Math.sin(minion.orbitAngle) * minion.orbitRadius * 0.55;
        minion.x = anchorX;
        minion.y = anchorY;
        store.championMinions.push(minion);
        store.activeEffects.push(createEffect('spawnTeleport', owner.x, owner.y, owner.r * 1.6, {
            duration: 0.6,
            color: '#e7e9ff',
            clusterIndex: -1,
            isChampion: true
        }));
        return minion;
    }

    function grantChampionCompanion() {
        ensureChampionCollections();
        const now = performance.now();
        if (!store.playerChampion || store.playerChampion.dead) {
            const champion = {
                id: now + Math.random(),
                x: clamp(store.player.x, 60, W - 60),
                y: clamp(store.player.y - 90, 80, H - 120),
                r: 20,
                guardRadius: PLAYER_CHAMPION_CONFIG.baseGuardRadius,
                guardAngle: Math.random() * Math.PI * 2,
                angularSpeed: PLAYER_CHAMPION_CONFIG.baseAngularSpeed,
                anchorOffsetY: -80,
                fireCooldown: PLAYER_CHAMPION_CONFIG.baseFireCooldown,
                fireTimer: 0.45,
                dashCooldown: PLAYER_CHAMPION_CONFIG.baseDashCooldown,
                dashTimer: 0,
                dashDuration: 0,
                dashVX: 0,
                dashVY: 0,
                dashCooldownTimer: 1.4,
                state: null,
                level: 1,
                damageScale: 1,
                volleySpread: 0.16,
                volleySize: 4,
                momentum: 4.1,
                auraPulse: Math.random() * Math.PI * 2,
                swirlPhase: Math.random() * Math.PI * 2,
                roamAnchor: null,
                roamTimer: 0,
                roamMode: 'idle',
                echoCooldown: 0,
                dead: false,
                isPlayerChampion: true
            };
            store.playerChampion = champion;
            store.championMinions.length = 0;
            // Spawn 3 minions immediately for better visual formation
            for (let i = 0; i < 3; i++) {
                spawnChampionMinion(champion);
            }
            store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.y, champion.r * 2.1, {
                duration: 1.05,
                color: '#cbd4ff',
                clusterIndex: -1,
                isChampion: true
            }));
            announce('âš”ï¸ Champion sigil aligned! Guardian bound to you.');
            playSound('epicHorn');
            return;
        }

        const champion = store.playerChampion;
        if (champion.dead) {
            store.playerChampion = null;
            grantChampionCompanion();
            return;
        }

        const nextLevel = Math.min((champion.level || 1) + 1, PLAYER_CHAMPION_CONFIG.maxLevel);
        const levelDelta = nextLevel - (champion.level || 1);
        champion.level = nextLevel;
        champion.damageScale = 1 + (champion.level - 1) * 0.25;
        champion.fireCooldown = Math.max(0.6, champion.fireCooldown * (levelDelta > 0 ? 0.9 : 1));
        champion.dashCooldown = Math.max(1.5, champion.dashCooldown * (levelDelta > 0 ? 0.92 : 1));
        champion.momentum = Math.min(6.2, champion.momentum + 0.25 * levelDelta);
        champion.volleySize = Math.min(7, 4 + champion.level);
        champion.volleySpread = Math.min(0.22, 0.16 + (champion.level - 1) * 0.015);
        champion.guardRadius = PLAYER_CHAMPION_CONFIG.baseGuardRadius + champion.level * 6;
        champion.angularSpeed = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (champion.level - 1) * 0.08;
        champion.roamTimer = 0;

        // No need to spawn additional minions since we start with all 3
        // Just update existing minions' stats instead
        for (let minion of store.championMinions) {
            if (minion && !minion.dead) {
                minion.damageScale = 1 + (champion.level - 1) * 0.18;
                minion.fireCooldown = Math.max(0.9, 1.4 - champion.level * 0.12);
            }
        }

        store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.y, champion.r * 2.4, {
            duration: 0.7,
            color: '#f4f0ff',
            clusterIndex: -1,
            isChampion: true
        }));
        announce(`Champion ascends to rank ${champion.level}!`);
        playSound('epicHorn');
    }

    function startShadowAbility(b, ability) {
        b.currentAbility = ability;
        b.abilityStage = 'windup';
        b.shadowTelegraph = { type: ability, progress: 0 };
        b.shadowTelegraphTarget = { x: store.player.x, y: store.player.y };
        let windupBase;
        switch (ability) {
            case 'star': windupBase = b.isEnraged ? 0.6 : 0.8; break;
            case 'lightning': windupBase = b.isEnraged ? 0.65 : 0.85; break;
            case 'hounds': windupBase = b.isEnraged ? 0.7 : 0.9; break;
            case 'charge': windupBase = b.isEnraged ? 0.9 : 1.1; break;
            default: windupBase = 0.8; break;
        }
        b.abilityWindupTotal = windupBase;
        b.abilityTimer = windupBase;
    }

    function finishShadowAbility(b) {
        b.currentAbility = null;
        b.abilityStage = null;
        b.abilityTimer = 0;
        b.abilityWindupTotal = 0;
        b.shadowTelegraph = null;
        b.shadowTelegraphTarget = null;
        b.shadowChargeVX = 0;
        b.shadowChargeVY = 0;
        b.shadowChargeTrailCooldown = 0;
        b.shadowChargeHit = false;
    }

    function shadowCloneFireMultishot(b, dmgScale) {
        const volley = b.isEnraged ? 7 : 5;
        const spread = Math.PI / 6;
        const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
        const bulletSpeed = 320 + (b.isEnraged ? 40 : 0);
        for (let i = 0; i < volley; i++) {
            const offset = i - (volley - 1) / 2;
            const angle = baseAngle + offset * (spread / Math.max(1, volley - 1));
            const bullet = getEBulletFromPool({
                x: b.x,
                y: b.y,
                vx: Math.cos(angle) * bulletSpeed,
                vy: Math.sin(angle) * bulletSpeed,
                r: 4,
                col: '#aab0ff',
                dmg: 14 * dmgScale,
                life: 3.2
            });
            store.eBullets.push(bullet);
        }
    }

    function shadowCloneFireStarVolley(b, dmgScale) {
        const player = store.player;
        const baseAngle = Math.atan2(player.y - b.y, player.x - b.x);
        const starCount = b.isEnraged ? 4 : 3;
        const angleStep = 0.18;
        const radialOffset = 28;
        for (let i = 0; i < starCount; i++) {
            const offsetIdx = i - (starCount - 1) / 2;
            const angle = baseAngle + offsetIdx * angleStep;
            const originX = b.x + Math.cos(angle + Math.PI / 2) * radialOffset;
            const originY = b.y + Math.sin(angle + Math.PI / 2) * radialOffset;
            launchStarProjectile(originX, originY, angle, {
                isEnemy: true,
                enemyDamage: 20 * dmgScale * (b.isEnraged ? 1.2 : 1),
                speedMultiplier: b.isEnraged ? 1.05 : 0.92,
                trailColor: 'rgba(170, 180, 255, ',
                primaryColor: '#e0e4ff',
                coreColor: '#545b99',
                shadowColor: '#2c2f58'
            });
        }
        playSound('stargun');
    }

    function generateShadowLightningPath(start, end, segments) {
        segments = segments || 5;
        const points = [{ x: start.x, y: start.y }];
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const length = Math.sqrt(dx * dx + dy * dy) || 1;
        const nx = -dy / length;
        const ny = dx / length;
        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const jitterScale = 1 - Math.abs(0.5 - t) * 1.4;
            const jitter = (Math.random() - 0.5) * 90 * jitterScale;
            points.push({
                x: start.x + dx * t + nx * jitter,
                y: start.y + dy * t + ny * jitter
            });
        }
        points.push({ x: end.x, y: end.y });
        return points;
    }

    function shadowCloneCastLightning(b, dmgScale) {
        const start = { x: b.x, y: b.y - b.r * 0.25 };
        const targets = [{ type: 'player', x: store.player.x, y: store.player.y }];
        if (store.iceman) targets.push({ type: 'iceman', x: store.iceman.x, y: store.iceman.y });
        if (store.beefClone) targets.push({ type: 'beefClone', x: store.beefClone.x, y: store.beefClone.y });
        const maxTargets = b.isEnraged ? 3 : 2;
        while (targets.length > maxTargets) targets.pop();
        for (let i = 0; i < targets.length; i++) {
            const target = targets[i];
            const endPoint = { x: target.x, y: target.y };
            const points = generateShadowLightningPath(start, endPoint, 5);
            store.lightningBolts.push({
                points,
                life: 0.45,
                maxLife: 0.45,
                dead: false,
                isEnemy: true,
                color: '#d7dcff',
                glowColor: '#4a58c7'
            });
            store.activeEffects.push(createEffect('lightningFlash', endPoint.x, endPoint.y));
            if (target.type === 'player') {
                takeDamage(24 * dmgScale * (b.isEnraged ? 1.2 : 1));
            }
        }
        playSound('thunder');
    }

    function spawnShadowHoundsFromBoss(b, count, dmgScale) {
        if (!store.shadowHounds) store.shadowHounds = [];
        count = count || 3;
        for (let i = 0; i < count; i++) {
            const offsetIdx = i - (count - 1) / 2;
            const lifespan = 11 + (b.isEnraged ? 4 : 0);
            store.shadowHounds.push({
                x: b.x + offsetIdx * 24,
                y: b.y + 24 + Math.abs(offsetIdx) * 6,
                vx: 0,
                vy: 0,
                speed: (b.isEnraged ? 260 : 220),
                damage: 8 * dmgScale * (b.isEnraged ? 1.2 : 1),
                life: lifespan,
                maxLife: lifespan,
                attackCooldown: 0.4,
                wobble: Math.random() * Math.PI * 2,
                dead: false
            });
        }
        playSound('dogs');
    }

    function addShadowEcho(x, y) {
        if (!store.shadowEchoes) store.shadowEchoes = [];
        store.shadowEchoes.push({
            x,
            y,
            life: 0.4,
            maxLife: 0.4,
            rotation: Math.random() * Math.PI * 2,
            dead: false
        });
    }

    function updateShadowEchoes(dt) {
        if (!store.shadowEchoes || !store.shadowEchoes.length) return;
        for (let i = store.shadowEchoes.length - 1; i >= 0; i--) {
            const echo = store.shadowEchoes[i];
            echo.life -= dt;
            if (echo.life <= 0) {
                store.shadowEchoes.splice(i, 1);
            }
        }
    }

    function stepBossShadowClone(dt, b, dmgScale) {
        ensureShadowCloneInit(b);
        if (!b.isEnraged && b.hp / b.hpMax <= 0.35) {
            b.isEnraged = true;
            b.shadowAbilityCooldown = 24;
            playSound('horn');
            announce('THE SHADOW MIRROR UNLEASHES ITS POWER!');
        }

        for (const key in b.shadowAbilityTimers) {
            if (Object.prototype.hasOwnProperty.call(b.shadowAbilityTimers, key)) {
                b.shadowAbilityTimers[key] -= dt;
            }
        }

        if (b.currentAbility) {
            if (b.abilityStage === 'windup') {
                b.abilityTimer -= dt;
                if (b.shadowTelegraph) {
                    const total = b.abilityWindupTotal || 1;
                    b.shadowTelegraph.progress = Math.min(1, Math.max(0, 1 - (b.abilityTimer / total)));
                }
                if (b.currentAbility === 'lightning') {
                    b.shadowTelegraphTarget = { x: store.player.x, y: store.player.y };
                }
                if (b.abilityTimer <= 0) {
                    switch (b.currentAbility) {
                        case 'star':
                            shadowCloneFireStarVolley(b, dmgScale);
                            b.abilityStage = 'recover';
                            b.abilityTimer = 0.55;
                            b.shadowTelegraph = null;
                            b.shadowTelegraphTarget = null;
                            break;
                        case 'lightning':
                            shadowCloneCastLightning(b, dmgScale);
                            b.abilityStage = 'recover';
                            b.abilityTimer = 0.65;
                            b.shadowTelegraph = null;
                            b.shadowTelegraphTarget = null;
                            break;
                        case 'hounds':
                            spawnShadowHoundsFromBoss(b, b.isEnraged ? 4 : 3, dmgScale);
                            b.abilityStage = 'recover';
                            b.abilityTimer = 0.6;
                            b.shadowTelegraph = null;
                            b.shadowTelegraphTarget = null;
                            break;
                        case 'charge':
                            b.shadowTelegraph = null;
                            b.shadowTelegraphTarget = null;
                            b.abilityStage = 'charge';
                            b.abilityTimer = b.isEnraged ? 0.85 : 1.05;
                            const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                            const speed = b.isEnraged ? 640 : 560;
                            b.shadowChargeVX = Math.cos(angle) * speed;
                            b.shadowChargeVY = Math.sin(angle) * speed;
                            b.shadowChargeTrailCooldown = 0;
                            b.shadowChargeHit = false;
                            addShadowEcho(b.x, b.y);
                            break;
                    }
                }
            } else if (b.abilityStage === 'charge') {
                b.abilityTimer -= dt;
                b.x += b.shadowChargeVX * dt;
                b.y += b.shadowChargeVY * dt;
                addShadowEcho(b.x, b.y);
                b.shadowChargeTrailCooldown -= dt;
                if (b.shadowChargeTrailCooldown <= 0) {
                    b.shadowChargeTrailCooldown = 0.08;
                    const pulse = getEBulletFromPool({
                        x: b.x,
                        y: b.y,
                        vx: 0,
                        vy: 0,
                        r: 7,
                        col: '#5460d8',
                        dmg: 10 * dmgScale,
                        life: 0.35
                    });
                    store.eBullets.push(pulse);
                }
                const margin = b.r;
                if (b.x <= margin || b.x >= W - margin || b.y <= margin || b.y >= H * 0.92) {
                    b.abilityTimer = 0;
                }
                const player = store.player;
                const playerRadius = player.r || 18;
                const dx = player.x - b.x;
                const dy = player.y - b.y;
                if (!b.shadowChargeHit && dx * dx + dy * dy <= Math.pow(playerRadius + b.r * 0.55, 2)) {
                    takeDamage(30 * dmgScale * (b.isEnraged ? 1.25 : 1));
                    b.shadowChargeHit = true;
                }
                if (b.abilityTimer <= 0) {
                    b.abilityStage = 'recover';
                    b.abilityTimer = 0.55;
                    b.shadowChargeVX = 0;
                    b.shadowChargeVY = 0;
                }
            } else if (b.abilityStage === 'recover') {
                b.abilityTimer -= dt;
                if (b.abilityTimer <= 0) {
                    finishShadowAbility(b);
                }
            }
        } else {
            const abilities = b.shadowAbilityOrder;
            for (let i = 0; i < abilities.length; i++) {
                const index = (b.shadowAbilityIndex + i) % abilities.length;
                const abilityName = abilities[index];
                if (b.shadowAbilityTimers[abilityName] <= 0) {
                    startShadowAbility(b, abilityName);
                    b.shadowAbilityTimers[abilityName] = b.shadowAbilityCooldown;
                    b.shadowAbilityIndex = (index + 1) % abilities.length;
                    break;
                }
            }
        }

        if (!b.currentAbility) {
            b.multishotTimer -= dt;
            if (b.multishotTimer <= 0) {
                shadowCloneFireMultishot(b, dmgScale);
                b.multishotTimer = b.isEnraged ? 0.45 : 0.65;
            }
        }

        if (b.abilityStage !== 'charge') {
            b.moveT += dt;
            const follow = clamp(store.player.x, b.r + 40, W - b.r - 40);
            const strafe = Math.sin(b.moveT * (b.isEnraged ? 1.4 : 1.0)) * (140 + (b.isEnraged ? 40 : 0));
            const desiredX = clamp(follow + strafe * 0.3, b.r, W - b.r);
            b.x += (desiredX - b.x) * dt * 3.2;
            const targetY = 130 + Math.sin(b.moveT * 0.9) * 16;
            b.y += (targetY - b.y) * dt * 2.6;
        }
    }

    function stepBossOmegaSentinel(dt, b, dmgScale) {
        // Movement behavior
        if (b.y >= 100) {
            b.moveT += dt;
            b.x += Math.sin(b.moveT * 2) * 200 * dt;
            b.x = clamp(b.x, 100, W - 100);
        }
        
        // Initialize EMP nova timer if not set
        if (b.empNovaTimer === undefined) {
            b.empNovaTimer = 8; // EMP nova every 8 seconds
        }
        
        // EMP Nova attack countdown
        b.empNovaTimer -= dt;
        if (b.empNovaTimer <= 0) {
            // Create EMP nova
            store.empNovas.push({
                x: b.x,
                y: b.y,
                radius: 0,
                maxRadius: H / 3, // 1/3 of screen height
                speed: 80, // Slow expansion speed
                life: 15, // Lives for 15 seconds
                dead: false
            });
            b.empNovaTimer = 8; // Reset timer
        }
        
        // Regular attack patterns
        b.fireT -= dt;
        if (b.fireT <= 0) {
            if (b.patternPhase % 4 === 0) {
                // Radial burst
                b.fireT = 1.5;
                const n = 12;
                for (let i = 0; i < n; i++) {
                    const a = (i * Math.PI / 6) + b.t;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: 150 * Math.cos(a),
                        vy: 150 * Math.sin(a),
                        r: 4,
                        col: '#4169e1',
                        dmg: 12 * dmgScale
                    });
                }
            } else {
                // Aimed shot
                b.fireT = 0.2;
                const a = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                store.eBullets.push({
                    x: b.x,
                    y: b.y,
                    vx: 250 * Math.cos(a),
                    vy: 250 * Math.sin(a),
                    r: 5,
                    col: '#add8e6',
                    dmg: 18 * dmgScale
                });
            }
            b.patternPhase++;
        }
    }
    function stepBossCoreMalignus(dt, b, dmgScale) { if (b.hp / b.hpMax <= 0.07 && !b.isEnraged) { b.isEnraged = true; playSound('horn'); } if (b.y >= 100) { b.moveT += dt; b.x = W / 2 + (W / 2 - 100) * Math.sin(b.moveT * 0.5); } b.fireT -= dt; if (b.fireT <= 0) { b.fireT = b.isEnraged ? 0.6 : 0.8; const n = 12, g = 3, s = Math.floor(Math.random() * (n - g)); for (let i = 0; i < n; i++) { if (i >= s && i < s + g) continue; const p = (W / (n + 1)) * (i + 1); store.eBullets.push({ x: p, y: b.y, vx: 0, vy: 180, r: 6, col: b.color, dmg: 20 * dmgScale }); } } }
    function stepBossTheHex(dt, b, dmgScale) { 
        if (b.y >= 100) {
            b.moveT += dt;
            if (b.dashTimer && b.dashTimer > 0) {
                b.dashTimer -= dt;
                b.x += b.vx * dt;
                b.x = clamp(b.x, b.r, W - b.r);
                if (b.dashTimer <= 0) {
                    b.dashTimer = 0;
                    b.vx = 0;
                    b.dashTrailCooldown = 0;
                }
            } else {
                const desiredX = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4));
                const followSpeed = 6;
                b.x += (desiredX - b.x) * Math.min(1, followSpeed * dt);
            }
        }

        b.fireT -= dt; 
        if (b.hp / b.hpMax < 0.5 && !b.isEnraged) { 
            b.isEnraged = true; 
            playSound('trap'); 
        } 
        const fireRate = b.isEnraged ? 0.8 : 1.5; 
        if (b.fireT <= 0) { 
            b.fireT = fireRate; 
            b.attackPhase = (b.attackPhase + 1) % 3; 
            switch(b.attackPhase) { 
                case 0: 
                    // Gold rain with interspersed powerups for strategic gambling
                    b.rainEvent = {
                        remaining: 20,
                        interval: 0.05,
                        timer: 0
                    };
                    break; 
                case 1: 
                    for (let i = 0; i < 4; i++) { 
                        const isHorizontal = i < 2; 
                        const y = isHorizontal ? 100 + i * 150 : 0; 
                        const x = isHorizontal ? 0 : 200 + (i-2) * 250; 
                        const vx = isHorizontal ? 300 : 0; 
                        const vy = isHorizontal ? 0 : 300; 
                        store.eBullets.push({ 
                            x: x, 
                            y: y, 
                            vx: vx, 
                            vy: vy, 
                            r: 4, 
                            col: '#80ffff', 
                            dmg: 20 * dmgScale, 
                            isLaser: true, 
                            life: 2.5 
                        }); 
                    } 
                    break; 
                case 2: 
                    const targetX = store.player.x; 
                    const dx = targetX - b.x; 
                    const dashSpeed = 800;
                    const direction = dx === 0 ? (Math.random() < 0.5 ? -1 : 1) : Math.sign(dx);
                    b.vx = direction * dashSpeed;
                    b.dashTimer = 0.5;
                    b.dashTrailCooldown = 0;
                    break; 
            } 
        } 
        if (b.rainEvent && b.rainEvent.remaining > 0) {
            b.rainEvent.timer -= dt;
            while (b.rainEvent.timer <= 0 && b.rainEvent.remaining > 0) {
                b.rainEvent.timer += b.rainEvent.interval;
                b.rainEvent.remaining--;
                if (Math.random() < 0.2) {
                    const powerupTypes = ['double', 'missile', 'drones', 'shield'];
                    const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];

                    store.powerups.push({
                        x: Math.random() * W,
                        y: 0,
                        vx: 0,
                        vy: 250,
                        r: 6,
                        type: randomType,
                        life: H / 250 + 2
                    });
                } else {
                    store.eBullets.push({
                        x: Math.random() * W,
                        y: 0,
                        vx: 0,
                        vy: 250,
                        r: 5,
                        col: '#ffc83d',
                        dmg: 15 * dmgScale
                    });
                }
            }
            if (b.rainEvent.remaining <= 0) {
                b.rainEvent = null;
            }
        }
        if (b.dashTimer && b.dashTimer > 0) {
            b.dashTrailCooldown -= dt;
            if (b.dashTrailCooldown <= 0) {
                b.dashTrailCooldown += 0.12;
                store.eBullets.push({
                    x: b.x,
                    y: b.y,
                    vx: 0,
                    vy: 0,
                    r: 8,
                    col: '#ff8080',
                    dmg: 25 * dmgScale,
                    life: 1
                });
            }
        } 
    }
    function stepBossGeometron(dt, b, dmgScale) { 
        // Handle DEATH ENGINE specific behavior
        if (b.name === 'DEATH ENGINE') {
            // Initialize skull ship specific properties
            if (!b.skullPhaseInitialized) {
                b.skullPhaseInitialized = true;
                b.phase = 1;
                b.disappearPhase = false;
                b.disappearStartTime = 0;
                b.safeZoneY = H * 0.5; // Start safe zone in middle
                b.safeZoneChanges = 0;
                b.maxSafeZoneChanges = 3;
                b.hasDoneSecondDisappear = false;
            }

            // Phase 1: Normal attacks until 50% HP
            if (b.phase === 1 && b.hp / b.hpMax > 0.5) {
                // Movement
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * 0.3); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Normal attack pattern
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                            // Trigger Death Engine laugh
                            b.isLaughing = true;
                            b.laughStartTime = performance.now();
                            if (b.skullRenderer) {
                                b.skullRenderer.triggerAttack(true);
                            }
                            const n = 12; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 160 * Math.cos(a), vy: 160 * Math.sin(a), r: 4, col: '#8B0000', dmg: 18 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Aimed shots at player
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < 5; i++) { 
                                const angle = angleToPlayer + (i - 2) * 0.15; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 280 * Math.cos(angle), vy: 280 * Math.sin(angle), r: 5, col: '#FF4500', dmg: 22 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // Spawn construct gold
                            const numgold = 2 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 120; 
                                gold.y = b.y + 60; 
                                gold.color = '#8B0000';
                                store.enemies.push(gold); 
                            } 
                            break;
                        case 3:
                            // New attack phase: Bouncing skull projectiles
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * Math.PI / 3) + (Math.random() - 0.5) * 0.3;
                                const speed = 150 + Math.random() * 50;
                                store.eBullets.push({ 
                                    x: b.x, 
                                    y: b.y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    r: 6, 
                                    col: '#DC143C', 
                                    dmg: 20 * dmgScale,
                                    bounces: 2, // Special bouncing bullets
                                    life: 4.0
                                }); 
                            }
                            break; 
                    }
                }
            }
            // Phase transition: Disappear and start train bullet pattern
            else if (b.phase === 1 && b.hp / b.hpMax <= 0.5) {
                b.phase = 2;
                b.disappearPhase = true;
                b.disappearStartTime = performance.now();
                b.isInvincible = true;
                b.visible = false; // Hide the boss
                
                // Move boss offscreen below player so it can't be shot
                b.x = W / 2;
                b.y = H + 200; // Move well below the screen
                
                // Update skull renderer position to be offscreen too
                if (b.skullRenderer) {
                    b.skullRenderer.x = b.x;
                    b.skullRenderer.y = b.y;
                }
                
                playSound('shao_kahn'); // Skull laugh when disappearing
                announce('THE DEATH ENGINE VANISHES INTO THE VOID!');
                
                // Reset safe zone position and changes
                b.safeZoneY = H * 0.5;
                b.safeZoneChanges = 0;
            }
            // Phase 2: Disappear phase with train bullets
            else if (b.disappearPhase) {
                const disappearTime = (performance.now() - b.disappearStartTime) / 1000;
                
                // Spawn train bullets continuously - 2 chunks moving opposite directions with safe zone in middle
                if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                b.trainBulletTimer -= dt;
                
                if (b.trainBulletTimer <= 0) {
                    b.trainBulletTimer = 0.08; // Very frequent spawning
                    
                    const safeZoneHeight = 120; // Safe zone in middle
                    const safeZoneY = H * 0.5; // Center of screen
                    const bulletSpeed = 280;
                    const bulletSpacing = 25;
                    
                    // Top chunk: bullets moving right to left (from top)
                    const topBoundary = safeZoneY - safeZoneHeight/2;
                    if (topBoundary > 30) {
                        for (let y = 0; y < topBoundary; y += bulletSpacing) {
                            store.eBullets.push({
                                x: -10, y: y,
                                vx: bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                    
                    // Bottom chunk: bullets moving left to right (from bottom)
                    const bottomBoundary = safeZoneY + safeZoneHeight/2;
                    if (bottomBoundary < H - 30) {
                        for (let y = bottomBoundary; y < H; y += bulletSpacing) {
                            store.eBullets.push({
                                x: W + 10, y: y,
                                vx: -bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                }
                
                // Return after 4 seconds (single phase)
                if (disappearTime > 4) {
                    b.disappearPhase = false;
                    b.visible = true;
                    b.isInvincible = false;
                    b.fireT = 1.0;
                    
                    // Reposition boss
                    b.x = W / 2;
                    b.y = 100;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Another laugh as he returns
                    announce('THE DEATH ENGINE RETURNS!');
                }
            }
            // Second disappear phase (enraged) - 2 fields of bullets with contact safe zone
            else if (b.disappearPhase && b.hasDoneSecondDisappear) {
                const disappearTime = (performance.now() - b.disappearStartTime) / 1000;
                
                // Spawn train bullets continuously - 2 fields going opposite directions with contact safe zone
                if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                b.trainBulletTimer -= dt;
                
                if (b.trainBulletTimer <= 0) {
                    b.trainBulletTimer = 0.06; // Even more frequent spawning for enraged phase
                    
                    const safeZoneWidth = 60; // Narrower safe zone - contact without buffer
                    const safeZoneX = W * 0.5; // Center of screen
                    const bulletSpeed = 320; // Faster bullets
                    const bulletSpacing = 20;
                    
                    // Left field: bullets moving right (from left side)
                    const leftBoundary = safeZoneX - safeZoneWidth/2;
                    if (leftBoundary > 30) {
                        for (let x = 0; x < leftBoundary; x += bulletSpacing) {
                            for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                store.eBullets.push({
                                    x: x, y: y,
                                    vx: bulletSpeed, vy: 0,
                                    r: 5, col: '#FF0000',
                                    dmg: 30 * dmgScale, // Higher damage
                                    life: (W + 20) / bulletSpeed + 1,
                                    fadeInTime: 2.0, // 2 second fade-in
                                    spawnTime: performance.now()
                                });
                            }
                        }
                    }
                    
                    // Right field: bullets moving left (from right side)
                    const rightBoundary = safeZoneX + safeZoneWidth/2;
                    if (rightBoundary < W - 30) {
                        for (let x = rightBoundary; x < W; x += bulletSpacing) {
                            for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                store.eBullets.push({
                                    x: x, y: y,
                                    vx: -bulletSpeed, vy: 0,
                                    r: 5, col: '#FF0000',
                                    dmg: 30 * dmgScale, // Higher damage
                                    life: (W + 20) / bulletSpeed + 1,
                                    fadeInTime: 2.0, // 2 second fade-in
                                    spawnTime: performance.now()
                                });
                            }
                        }
                    }
                }
                
                // Return after 5 seconds (longer enraged phase)
                if (disappearTime > 5) {
                    b.disappearPhase = false;
                    b.visible = true;
                    b.isInvincible = false;
                    b.fireT = 0.5; // Very aggressive after returning
                    
                    // Reposition boss
                    b.x = W / 2;
                    b.y = 100;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Final laugh as he returns
                    announce('THE DEATH ENGINE RETURNS FOR THE FINAL ASSAULT!');
                }
            }
            // Phase 2: Normal combat after returning
            else if (b.phase === 2 && !b.disappearPhase) {
                // Calculate health percentage for final phase mechanics
                const healthPercent = b.hp / b.hpMax;
                const isFinalPhase = healthPercent <= 0.25; // Final phase at 25% health
                
                // Second disappear phase when enraged (red)
                if (isFinalPhase && !b.hasDoneSecondDisappear) {
                    b.hasDoneSecondDisappear = true;
                    b.disappearPhase = true;
                    b.disappearStartTime = performance.now();
                    b.isInvincible = true;
                    b.visible = false;
                    
                    // Move boss offscreen
                    b.x = W / 2;
                    b.y = H + 200;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Skull laugh when disappearing again
                    announce('THE DEATH ENGINE VANISHES INTO THE VOID AGAIN!');
                    
                    // Reset bullet timer
                    b.trainBulletTimer = 0;
                }
                
                // Red coloration and faster movement in final phase
                const moveSpeed = isFinalPhase ? 0.9 : 0.6; // Faster movement when low on health
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Override skull ship color to red when in final phase
                if (isFinalPhase && b.color !== '#FF0000') {
                    b.color = '#FF0000'; // Turn red in final phase
                }
                
                // ENRAGE PHASE: Spawn 1/4 density of intermission bullets passing through play field
                if (isFinalPhase) {
                    if (!b.enrageBulletTimer) b.enrageBulletTimer = 0;
                    b.enrageBulletTimer -= dt;
                    
                    if (b.enrageBulletTimer <= 0) {
                        b.enrageBulletTimer = 0.32; // 1/4 density of normal intermission (0.08 * 4)
                        
                        const bulletSpeed = 280;
                        const bulletSpacing = 25;
                        
                        // Spawn bullets from left side moving right (top half)
                        for (let y = 0; y < H * 0.5; y += bulletSpacing * 4) { // Every 4th bullet spacing
                            store.eBullets.push({
                                x: -10, y: y,
                                vx: bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                        
                        // Spawn bullets from right side moving left (bottom half)
                        for (let y = H * 0.5; y < H; y += bulletSpacing * 4) { // Every 4th bullet spacing
                            store.eBullets.push({
                                x: W + 10, y: y,
                                vx: -bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                }
                
                // More aggressive attacks, even faster in final phase
                const fireRate = isFinalPhase ? 1.2 : 1.8; // Faster attacks in final phase
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = fireRate;
                    switch(b.attackPhase) { 
                        case 0: 
                            // Trigger Death Engine laugh
                            b.isLaughing = true;
                            b.laughStartTime = performance.now();
                            if (b.skullRenderer) {
                                b.skullRenderer.triggerAttack(true);
                            }
                            // Dense spiral (more bullets in final phase)
                            const n = isFinalPhase ? 20 : 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 1.2; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 200 * Math.cos(a), vy: 200 * Math.sin(a), r: 5, col: bulletColor, dmg: 20 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Triple aimed shots (more spread in final phase)
                            const shotCount = isFinalPhase ? 9 : 7;
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < shotCount; i++) { 
                                const angle = angleToPlayer + (i - Math.floor(shotCount/2)) * 0.12; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#FF4500';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 320 * Math.cos(angle), vy: 320 * Math.sin(angle), r: 5, col: bulletColor, dmg: 25 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // More gold (significantly more in final phase)
                            const basegold = 3 + Math.floor(store.world.wave / 8);
                            const finalPhaseBonus = isFinalPhase ? Math.floor(basegold * 0.75) : 0; // 75% more adds in final phase
                            const numgold = basegold + finalPhaseBonus;
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 150; 
                                gold.y = b.y + 60; 
                                gold.color = isFinalPhase ? '#FF0000' : '#FF0000';
                                gold.hp *= isFinalPhase ? 1.5 : 1.3; // Tougher adds in final phase
                                store.enemies.push(gold); 
                            } 
                            break; 
                        case 3: 
                            // Cross pattern (more layers in final phase)
                            const layers = isFinalPhase ? 4 : 3;
                            for (let i = 0; i < 4; i++) {
                                const angle = i * Math.PI / 2;
                                for (let j = 1; j <= layers; j++) {
                                    const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                    store.eBullets.push({ 
                                        x: b.x, y: b.y, 
                                        vx: 180 * j * 0.7 * Math.cos(angle), 
                                        vy: 180 * j * 0.7 * Math.sin(angle), 
                                        r: 4, col: bulletColor, dmg: 18 * dmgScale 
                                    }); 
                                }
                            }
                            break;
                    }
                }
            }
        } else {
            // Original GEOMETRON logic (unchanged)
            if (b.hp / b.hpMax < 0.5 && b.phase === 1) { 
                b.phase = 2; 
                b.isInvincible = true; 
                playSound('horn'); 
                store.activeEffects.push(createEffect("bossPhaseChange", b.x, b.y)); 
                b.attackPhase = 0; 
                b.fireT = 2.0; 
                setTimeout(() => { b.isInvincible = false; }, 2000); 
                announce('GEOMETRON ENRAGED!'); 
            }
            
            // Movement logic
            if (b.y >= 100) { 
                b.moveT += dt; 
                const moveSpeed = (b.phase === 1) ? 0.3 : 0.7; 
                b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
            } 
            
            // Attack logic
            b.fireT -= dt; 
            if (b.fireT <= 0) { 
                if (b.phase === 1) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const n = 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numgold = 3 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 100; 
                                gold.y = b.y + 50; 
                                store.enemies.push(gold); 
                            } 
                            break; 
                    } 
                } else { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.0; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const spread = 8; 
                            const numShots = 8; 
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < numShots; i++) { 
                                const angle = angleToPlayer + (i - (numShots - 1) / 2) * (spread * Math.PI / 180) * 0.1; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 350 * Math.cos(angle), vy: 350 * Math.sin(angle), r: 4, col: '#ff4500', dmg: 22 * dmgScale, life: 2.0 }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numgold = 2; 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (i === 0 ? -50 : 50); 
                                gold.y = b.y + 50; 
                                gold.hp *= 1.5; 
                                gold.v *= 1.3; 
                                gold.color = '#ff4500'; 
                                store.enemies.push(gold); 
                            } 
                            break; 
                    } 
                } 
            }
        }
    }
    function stepBossVoidRaven(dt, b, dmgScale) { b.moveT += dt; if (!b.isDiving) { b.y = 100 + Math.sin(b.moveT * 2) * 20; b.x = W/2 + Math.cos(b.moveT * 0.5) * (W/2 - 100); } b.fireT -= dt; if (b.fireT <=0) { b.attackPhase = (b.attackPhase + 1) % 5; switch(b.attackPhase) { case 0: case 2: b.fireT = 1.2; for(let i = 0; i < 7; i++) { const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: '#4169e1', dmg: 18 * dmgScale }); } break; case 1: case 3: b.fireT = 2.0; const numHatchlings = 2 + Math.floor(store.world.wave / 15); for(let i = 0; i < numHatchlings; i++) { const hatchling = spawnEnemy('avian_hatchling'); hatchling.x = b.x + (Math.random() - 0.5) * 80; hatchling.y = b.y + 40; store.enemies.push(hatchling); } break; case 4: b.fireT = 4.0; b.isDiving = true; b.diveTarget = { x: store.player.x, y: store.player.y }; const dx = b.diveTarget.x - b.x; const dy = b.diveTarget.y - b.y; const dist = Math.sqrt(dx*dx + dy*dy); b.vx = (dx / dist) * 400; b.vy = (dy / dist) * 400; setTimeout(() => { b.isDiving = false; b.vx = 0; b.vy = 30; }, 1500); break; } } if (b.isDiving) { b.x += b.vx * dt; b.y += b.vy * dt; } }
    
    function stepBossBroodlord(dt, b, dmgScale) {
        // Initialize poison puddles array if not exists
        if (!store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        
        // Broodlord skittering movement
        b.moveT += dt;
        if (!b.spiderInit) {
            b.spiderInit = true;
            b.spiderVX = (Math.random() < 0.5 ? -1 : 1) * (120 + Math.random() * 40);
            b.spiderVY = 90 + Math.random() * 50;
            b.webRetargetT = 1.4;
            b.poisonTrailT = 1.2;
        }

        const speedScale = 1 + Math.min(0.75, Math.max(0, store.world.wave - 10) * 0.02);
        b.x += b.spiderVX * speedScale * dt;
        b.y += b.spiderVY * speedScale * dt;

        const minX = 90;
        const maxX = W - 90;
        const minY = 90;
        const maxY = Math.min(H - 170, H * 0.78);

        if (b.x <= minX && b.spiderVX < 0) {
            b.x = minX;
            b.spiderVX = Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
            b.spiderVY += (Math.random() - 0.5) * 140;
        } else if (b.x >= maxX && b.spiderVX > 0) {
            b.x = maxX;
            b.spiderVX = -Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
            b.spiderVY += (Math.random() - 0.5) * 140;
        }

        if (b.y <= minY && b.spiderVY < 0) {
            b.y = minY;
            b.spiderVY = Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
            b.spiderVX += (Math.random() - 0.5) * 110;
        } else if (b.y >= maxY && b.spiderVY > 0) {
            b.y = maxY;
            b.spiderVY = -Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
            b.spiderVX += (Math.random() - 0.5) * 110;
        }

        b.spiderVX = clamp(b.spiderVX, -260, 260);
        b.spiderVY = clamp(b.spiderVY, -240, 240);

        b.webRetargetT -= dt;
        if (b.webRetargetT <= 0) {
            const player = store.player;
            const dx = player.x - b.x;
            const dy = (player.y - 40) - b.y;
            const dist = Math.max(120, Math.hypot(dx, dy));
            const chaseStrengthX = 180 + Math.random() * 60;
            const chaseStrengthY = 170 + Math.random() * 60;
            b.spiderVX = clamp(b.spiderVX * 0.5 + (dx / dist) * chaseStrengthX, -260, 260);
            b.spiderVY = clamp(b.spiderVY * 0.5 + (dy / dist) * chaseStrengthY, -240, 240);
            b.webRetargetT = 1.3 + Math.random() * 0.9;
        }

        b.poisonTrailT -= dt;
        if (b.poisonTrailT <= 0) {
            const puddleX = clamp(b.x + (Math.random() - 0.5) * 120, 40, W - 40);
            const puddleY = clamp(b.y + Math.random() * 120, 80, H - 80);
            store.poisonPuddles.push({
                x: puddleX,
                y: puddleY,
                r: 18 + Math.random() * 12,
                life: getHivePuddleLifetime(4.8, 3.2, { min: 4.2, maxWaveBonus: 4.5 }),
                damage: 10 * dmgScale,
                created: performance.now()
            });
            const trailReset = 2.4 - Math.min(1.4, store.world.wave * 0.035);
            b.poisonTrailT = Math.max(0.9, trailReset);
        }
        
        // Attack phases
        b.fireT -= dt;
        if (b.fireT <= 0) {
            b.attackPhase = (b.attackPhase + 1) % 4;
            
            switch(b.attackPhase) {
                case 0:
                case 2:
                    // Poison blob barrage
                    b.fireT = 1.8;
                    const numBlobs = 5 + Math.floor(store.world.wave / 10);
                    for (let i = 0; i < numBlobs; i++) {
                        const spread = Math.PI * 0.6;
                        const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                        const angle = baseAngle + (Math.random() - 0.5) * spread;
                        const speed = 180 + Math.random() * 80;
                        
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 8,
                            col: '#7cfc00',
                            dmg: 22 * dmgScale,
                            life: 4,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 1:
                    // Acid spit pattern
                    b.fireT = 2.2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI / 4) + b.t * 0.5;
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * 160,
                            vy: Math.sin(angle) * 160,
                            r: 6,
                            col: '#adff2f',
                            dmg: 20 * dmgScale,
                            life: 3,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 3:
                    // Toxic ground slam - saturate arena with dangerous puddles
                    b.fireT = 2.6;
                    const playerPos = store.player;
                    const webSpots = [
                        { x: clamp(playerPos.x, 80, W - 80), y: clamp(playerPos.y + 40, 120, H - 90) },
                        { x: clamp(playerPos.x + 180, 80, W - 80), y: clamp(playerPos.y - 20, 120, H - 90) },
                        { x: clamp(playerPos.x - 180, 80, W - 80), y: clamp(playerPos.y + 80, 120, H - 90) },
                        { x: W * 0.25 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                        { x: W * 0.75 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                        { x: W * 0.5 + (Math.random() - 0.5) * 220, y: H * 0.55 + (Math.random() - 0.5) * 140 }
                    ];
                    for (let i = 0; i < 6; i++) {
                        const node = webSpots[i % webSpots.length];
                        const puddleX = clamp(node.x + (Math.random() - 0.5) * 70, 40, W - 40);
                        const puddleY = clamp(node.y + (Math.random() - 0.5) * 70, 80, H - 70);
                        store.poisonPuddles.push({
                            x: puddleX,
                            y: puddleY,
                            r: 28 + Math.random() * 18,
                            life: getHivePuddleLifetime(7.5, 4.5, { min: 6.5, waveBonusPer: 0.4, maxWaveBonus: 6.5 }),
                            damage: 15 * dmgScale,
                            created: performance.now()
                        });
                    }
                    break;
            }
        }
        
        const now = performance.now();
        const bossRadius = b.r || 80;
        const puddleDamageInterval = 600; // ms between damage ticks while boss is in the acid

        for (let i = store.poisonPuddles.length - 1; i >= 0; i--) {
            const puddle = store.poisonPuddles[i];
            puddle.life -= dt;
            if (puddle.life <= 0) {
                store.poisonPuddles.splice(i, 1);
                continue;
            }

            const dx = b.x - puddle.x;
            const dy = b.y - puddle.y;
            const dist = Math.hypot(dx, dy);
            const effectiveRadius = puddle.r + bossRadius * 0.55;

            if (dist < effectiveRadius) {
                // Standing in the acid slows and harms the Hive Sovereign
                b.slowTimer = Math.max(b.slowTimer || 0, 0.45);

                if (!b.lastPuddleDamageTime || now - b.lastPuddleDamageTime >= puddleDamageInterval) {
                    const puddleDamage = Math.max(8, puddle.damage * 0.9);
                    b.hp -= puddleDamage;
                    store.world.totalDamage += puddleDamage;
                    b.lastPuddleDamageTime = now;

                    if (b.hp <= 0) {
                        handleBossDefeat();
                        return;
                    }
                }
            }
        }
    }
    
    function stepBoss(dt) {
        const b = store.boss;
        b.t += dt;
        if (b.y < 100) { b.y += b.vy * dt; }
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        
        if (b.slowTimer > 0) { b.slowTimer -= dt; dt *= 0.3; }

        switch (b.behavior) {
            case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break;
            case 'malignus': stepBossCoreMalignus(dt, b, dmgScale); break;
            case 'hex':      stepBossTheHex(dt, b, dmgScale); break;
            case 'construct': stepBossGeometron(dt, b, dmgScale); break;
            case 'shadow_clone': stepBossShadowClone(dt, b, dmgScale); break;
            case 'avian':    stepBossVoidRaven(dt, b, dmgScale); break;
            case 'broodlord': stepBossBroodlord(dt, b, dmgScale); break;
        }
    }
    function drawMissile(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2);

        if (m.isStealth) {
            // Advanced stealth rocket design - sleeker and more futuristic
            ctx.fillStyle = "#2a2a2a"; // Dark metallic body
            ctx.strokeStyle = "#00ffff"; // Cyan highlights
            ctx.lineWidth = 1;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            
            // Main body - longer and sleeker
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(3, 0);
            ctx.lineTo(2, 6);
            ctx.lineTo(-2, 6);
            ctx.lineTo(-3, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Stealth fins
            ctx.beginPath();
            ctx.moveTo(-2, 2);
            ctx.lineTo(-5, 4);
            ctx.lineTo(-2, 6);
            ctx.moveTo(2, 2);
            ctx.lineTo(5, 4);
            ctx.lineTo(2, 6);
            ctx.stroke();
            
            // Advanced plasma exhaust
            const flameSize = 10 + 3 * Math.sin(performance.now() / 30);
            const grad = ctx.createLinearGradient(0, 6, 0, 6 + flameSize);
            grad.addColorStop(0, 'rgba(0, 255, 255, 0.9)');
            grad.addColorStop(0.5, 'rgba(0, 150, 255, 0.7)');
            grad.addColorStop(1, 'rgba(0, 100, 200, 0.3)');
            ctx.fillStyle = grad;
            
            ctx.beginPath();
            ctx.moveTo(-2, 6);
            ctx.lineTo(2, 6);
            ctx.lineTo(1, 6 + flameSize * 0.7);
            ctx.lineTo(0, 6 + flameSize);
            ctx.lineTo(-1, 6 + flameSize * 0.7);
            ctx.closePath();
            ctx.fill();
        } else {
            // Regular missile design
            ctx.fillStyle = m.isIceman ? "#a0e9ff" : "#ffddff";
            ctx.shadowColor = m.isIceman ? '#3c9aed' : '#ff8080';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(4, 5); 
            ctx.lineTo(-4, 5);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;

            const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
            ctx.fillStyle = m.isIceman ? `rgba(60, 154, 237, ${0.6 + 0.4 * Math.random()})` : `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;

            ctx.beginPath();
            ctx.moveTo(-3, 5);
            ctx.lineTo(3, 5); 
            ctx.lineTo(0, 5 + flameSize);
            ctx.closePath();
            ctx.fill();
        }

        ctx.restore();
    }
    function drawPowerup(p) {
        const cfg = POWERUP_TYPES[p.type];
        ctx.save();
        ctx.translate(p.x, p.y);

        const time = performance.now();
        const pulse = 0.8 + 0.2 * Math.sin(time / 150 + (p.pulseOffset || 0));
        ctx.scale(pulse, pulse);

        let glowInner = '#FFD70099';
        let glowOuter = '#FFD70000';
        let coreFill = '#FFD70044';
        let borderColor = '#FFD700';
        let iconColor = '#FFFFFF';
        let iconFont = 'bold 16px Orbitron';

        if (p.type === 'shadow_champion_token') {
            glowInner = 'rgba(160, 180, 255, 0.85)';
            glowOuter = 'rgba(80, 100, 235, 0)';
            coreFill = 'rgba(80, 100, 220, 0.5)';
            borderColor = 'rgba(220, 230, 255, 0.95)';
            iconColor = '#f8f9ff';
            iconFont = 'bold 18px Orbitron';
        }

        ctx.beginPath();
        ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3);
        glow.addColorStop(0, glowInner);
        glow.addColorStop(1, glowOuter);
        ctx.fillStyle = glow;
        ctx.fill();

        ctx.beginPath();
        ctx.arc(0, 0, p.r, 0, Math.PI * 2);
        ctx.fillStyle = coreFill;
        ctx.fill();

        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        if (p.type === 'shadow_champion_token') {
            const spin = (time / 480) % (Math.PI * 2);
            ctx.save();
            ctx.rotate(spin);
            ctx.strokeStyle = 'rgba(245, 247, 255, 0.75)';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            const runeRadius = p.r * 0.65;
            ctx.moveTo(-runeRadius, 0);
            ctx.lineTo(runeRadius, 0);
            ctx.moveTo(0, -runeRadius);
            ctx.lineTo(0, runeRadius);
            ctx.stroke();
            ctx.restore();

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.strokeStyle = 'rgba(235, 240, 255, 0.8)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, p.r * 0.45, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        ctx.fillStyle = iconColor;
        ctx.font = iconFont;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(cfg.icon, 0, 1);
        ctx.restore();
    }
    function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }
    
    function drawLaser(laser) {
        ctx.save();
        const trailLength = 200;
        const angle = Math.atan2(laser.vy, laser.vx);
        const startX = laser.x - Math.cos(angle) * trailLength;
        const startY = laser.y - Math.sin(angle) * trailLength;

        const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
        grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
        grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = laser.r * 1.5;
        ctx.lineCap = 'round';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 25;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(laser.x, laser.y);
        ctx.stroke();
        
        // Inner bright core
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = `rgba(200, 220, 255, 0.8)`;
        ctx.shadowBlur = 10;
        ctx.stroke();

        ctx.restore();
    }
// Helper: safely add alpha to a hex color (falls back if not hex)
    function addAlpha(color, alpha) {
        const a = Math.max(0, Math.min(1, alpha));
        if (typeof color === 'string' && color.startsWith('#')) {
            let hex = color.slice(1);
            if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
            if (hex.length >= 6) {
            const r = parseInt(hex.slice(0, 2), 16);
            const g = parseInt(hex.slice(2, 4), 16);
            const b = parseInt(hex.slice(4, 6), 16);
            return `rgba(${r},${g},${b},${a})`;
            }
        }
        // If it's not hex, return as-is (the caller can tweak globalAlpha if needed)
        return color;
        }

    // Skull Ship Drawing Functions

    /**
     * @class Boss
     * Represents the main antagonist character.
     * This class encapsulates all logic for rendering, animating, and managing the state of the boss.
     */
    class Boss {
        /**
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context for the canvas.
         * @param {number} x The initial X position of the boss.
         * @param {number} y The initial Y position of the boss.
         * @param {string} skullColor The color for the skull (supports red final phase).
         */
        constructor(ctx, x, y, skullColor = '#e54d24') {
            this.ctx = ctx;
            this.x = x;
            this.y = y;
            this.skullColor = skullColor;

            this.width = 180;
            this.height = 280;

            // Animation state
            this.isAttacking = false;
            this.attackStartTime = 0;
            this.bloodDrips = [];
        }

        /**
         * Triggers the boss's attack animation (laugh and scythe swipe).
         * This should be called from the main game logic (e.g., on a timer or player action).
         * @param {boolean} playAudio - Whether to play the laugh sound effect.
         */
        triggerAttack(playAudio = true) {
            if (!this.isAttacking) {
                this.isAttacking = true;
                this.attackStartTime = Date.now();

                // Play death engine laugh sound using game's sound system
                if (playAudio && typeof playSound !== 'undefined') {
                    playSound('shao_kahn');
                }

                // Reset the attack state after the animation duration
                setTimeout(() => {
                    this.isAttacking = false;
                }, 3000);
            }
        }

        /**
         * Updates the boss's state. This should be called every frame in the game loop.
         * It handles internal animations like the blood drips.
         */
        update() {
            this._updateBloodDrips();
        }

        /**
         * Renders the boss on the canvas. This should be called every frame in the game loop after `update`.
         */
        draw() {
            this.ctx.save();
            this.ctx.translate(this.x, this.y);
            this._drawHorns();
            this._drawHead();
            this._drawFacialFeatures();
            this._addWeathering(); // Scars
            this._drawBloodDrips();
            this.ctx.restore();
        }

        // --- Private Helper Methods ---

        _drawHorns() {
            const { ctx, width: skullWidth, height: skullHeight } = this;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            let swipeAngle = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                const duration = 1000;
                if (elapsedTime < duration) {
                    const progress = elapsedTime / duration;
                    swipeAngle = Math.sin(progress * Math.PI) * -0.3;
                }
            }

            const drawHornScythe = (isFlipped) => {
                const side = isFlipped ? -1 : 1;
                ctx.save();
                
                const handleGradient = ctx.createLinearGradient(0, -200, 0, 100);
                handleGradient.addColorStop(0, '#111111');
                handleGradient.addColorStop(0.5, '#333333');
                handleGradient.addColorStop(1, '#222222');
                ctx.fillStyle = handleGradient;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 18;

                ctx.beginPath();
                ctx.moveTo(side * skullWidth * 0.35, -skullHeight * 0.4);
                const handleEndX = side * 400;
                const handleEndY = -skullHeight * 0.20;
                ctx.bezierCurveTo(side * 220, -skullHeight * 0.9, side * 350, -skullHeight * 0.1, handleEndX, handleEndY);
                ctx.bezierCurveTo(side * 360, 0, side * 230, -skullHeight * 0.55, side * skullWidth * 0.25, -skullHeight * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 10, handleEndY, 14, 20, side * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 35, handleEndY - 5, 12, 18, side * 0.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.translate(handleEndX, handleEndY);
                const baseRotation = Math.PI / 4;
                ctx.rotate(side * baseRotation + side * swipeAngle);

                const bladeGradient = ctx.createLinearGradient(side * 50, 0, side * 150, 300);
                bladeGradient.addColorStop(0, '#ffffff');
                bladeGradient.addColorStop(0.5, '#e3dac9');
                bladeGradient.addColorStop(1, '#c1b8a8');
                ctx.fillStyle = bladeGradient;
                ctx.strokeStyle = '#8c8273';
                ctx.lineWidth = 4;

                ctx.beginPath();
                const tipX = side * 150;
                const tipY = 220;
                ctx.moveTo(0, -15);
                ctx.bezierCurveTo(side * 180, 80, side * 200, 200, tipX, tipY);
                ctx.bezierCurveTo(side * 130, 160, side * 40, 70, 0, 15);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.clip();
                ctx.strokeStyle = 'rgba(80, 70, 60, 0.2)';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    const startX = side * (Math.random() * 250);
                    const startY = -15 + Math.random() * 300;
                    const length = 20 + Math.random() * 30;
                    const angle = Math.random() * Math.PI * 2;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
                    ctx.stroke();
                }
                ctx.restore();
                
                if (this.isAttacking && Math.random() < 0.3) {
                    const dripSpawnPoint = { x: tipX / 2, y: tipY / 1.5 };
                    const rotatedPoint = {
                        x: dripSpawnPoint.x * Math.cos(side * baseRotation) - dripSpawnPoint.y * Math.sin(side * baseRotation),
                        y: dripSpawnPoint.x * Math.sin(side * baseRotation) + dripSpawnPoint.y * Math.cos(side * baseRotation)
                    };
                    this._addBloodDrip(handleEndX + rotatedPoint.x, handleEndY + rotatedPoint.y);
                }

                ctx.restore();
            };

            drawHornScythe(false);
            drawHornScythe(true);
        }

        _drawHead() {
            const { ctx, width: skullWidth, height: skullHeight, skullColor } = this;
            const gradient = ctx.createRadialGradient(0, -50, skullWidth * 0.1, 0, 0, skullWidth * 1.2);
            
            if (skullColor === '#FF0000') {
                // Red final phase colors
                gradient.addColorStop(0, '#ff6666');
                gradient.addColorStop(0.5, '#ff0000');
                gradient.addColorStop(1, '#660000');
            } else {
                // Original orange colors
                gradient.addColorStop(0, '#ff8c66');
                gradient.addColorStop(0.5, '#e54d24');
                gradient.addColorStop(1, '#661a00');
            }

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#1a0a05';
            ctx.lineWidth = 8;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 20;

            ctx.beginPath();
            ctx.moveTo(0, -skullHeight * 0.55);
            ctx.bezierCurveTo(-skullWidth * 0.6, -skullHeight * 0.6, -skullWidth * 0.6, -skullHeight * 0.1, -skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(-skullWidth * 0.6, skullHeight * 0.3, -skullWidth * 0.2, skullHeight * 0.55, 0, skullHeight * 0.52);
            ctx.bezierCurveTo(skullWidth * 0.2, skullHeight * 0.55, skullWidth * 0.6, skullHeight * 0.3, skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(skullWidth * 0.6, -skullHeight * 0.1, skullWidth * 0.6, -skullHeight * 0.6, 0, -skullHeight * 0.55);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.shadowColor = 'transparent';
        }

        _drawFacialFeatures() {
            const { ctx, height: skullHeight } = this;

            const drawMirrorEye = (offsetX, isFlipped) => {
                ctx.save();
                ctx.translate(offsetX, -10);
                if (isFlipped) ctx.scale(-1, 1);
                const eyePath = new Path2D();
                eyePath.moveTo(-30, -20); eyePath.lineTo(30, -30); eyePath.lineTo(25, 28); eyePath.lineTo(-25, 25); eyePath.closePath();
                for (let i = 0; i < 6; i++) {
                    ctx.fillStyle = (i % 2 === 0 || i === 5) ? '#1a0a05' : '#ff3300';
                    ctx.fill(eyePath);
                    ctx.scale(0.8, 0.75);
                }
                ctx.restore();
            };
            drawMirrorEye(-35, true);
            drawMirrorEye(35, false);

            let mouthOpenness = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 15;
            }

            ctx.strokeStyle = 'rgba(26, 10, 5, 0.8)';
            ctx.lineWidth = 2;

            for (let i = -6; i <= 6; i++) {
                if (i === 0) continue;
                let toothWidth = 10;
                let toothHeight = 25 - Math.abs(i) * 1.2;
                const isCanine = Math.abs(i) === 5 || Math.abs(i) === 6;
                if (isCanine) {
                    toothHeight += 18;
                    toothWidth -= 2;
                }
                const xPos = i * 9;
                let yPos = skullHeight * 0.53;
                yPos -= Math.pow(i, 2) * 1.8;
                yPos += mouthOpenness;
                ctx.save();
                ctx.translate(xPos, yPos);
                ctx.beginPath();
                ctx.moveTo(-toothWidth / 2, 0);
                ctx.lineTo(toothWidth / 2, 0);
                ctx.lineTo(0, toothHeight);
                ctx.closePath();
                ctx.fillStyle = '#e8d9a9';
                ctx.fill();
                ctx.stroke();
                const tipY = toothHeight;
                ctx.fillStyle = '#8c1803';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 3, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        _addWeathering() {
            const { ctx } = this;
            ctx.strokeStyle = 'rgba(26, 10, 5, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, -30);
            ctx.lineTo(70, 10);
            ctx.lineTo(65, 15);
            ctx.stroke();
        }

        _addBloodDrip(x, y) {
            if (this.bloodDrips.length > 100) return;
            this.bloodDrips.push({
                x: x,
                y: y,
                speed: 2 + Math.random() * 3,
                size: 2 + Math.random() * 3
            });
        }

        _updateBloodDrips() {
            for (let i = this.bloodDrips.length - 1; i >= 0; i--) {
                const drip = this.bloodDrips[i];
                drip.y += drip.speed;
                if (drip.y > this.ctx.canvas.height) {
                    this.bloodDrips.splice(i, 1);
                }
            }
        }

        _drawBloodDrips() {
            const { ctx } = this;
            ctx.fillStyle = '#8c1803';
            for (const drip of this.bloodDrips) {
                ctx.beginPath();
                ctx.arc(drip.x, drip.y, drip.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawBoss(t) {
        // Special rendering for Heat Death of the Universe
        if (t.isHeatDeath) {
            // Darken the top half of screen with haze effect
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, W, H/2);
            
            // Add dark gray haze
            ctx.fillStyle = 'rgba(32, 32, 32, 0.6)';
            ctx.fillRect(0, 0, W, H/2);
            
            // No health bar or physical form - just the void
            ctx.restore();
            return;
        }
        
        ctx.save(); ctx.translate(t.x, t.y); if (t.isEnraged) {ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50);} const hpRatio = Math.max(0, Math.min(1, ((t.hp || 0) / (t.hpMax || 1)))); ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(-60, -t.r - 20, 120, 8); const healthBarColor = t.name === 'EVIL BABYMOON' ? '#ffd700' : (t.color || '#ff4444'); ctx.fillStyle = healthBarColor; ctx.fillRect(-60, -t.r - 20, 120 * hpRatio, 8); ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.strokeRect(-60, -t.r - 20, 120, 8); if (t.behavior === "malignus") {const time = performance.now() / 1000; ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.4, 0, Math.PI * 2); ctx.fill(); const numgold = 5; for (let i = 0; i < numgold; i++) {ctx.save(); const angle = time * (0.5 + 0.1 * i) + i * (2 * Math.PI / numgold); const dist = 0.8 * t.r; ctx.rotate(angle); ctx.translate(dist, 0); ctx.rotate(2 * time); ctx.fillStyle = addAlpha(t.color, 0.67); ctx.strokeStyle = "#FFFFFF"; ctx.lineWidth = 2; const goldize = 0.3 * t.r; ctx.beginPath(); ctx.moveTo(0, -goldize); ctx.lineTo(goldize / 2, goldize); ctx.lineTo(-goldize / 2, goldize); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();}} else if (t.behavior === "hex") {ctx.translate(0, 30); const bodyW_top = t.r * 1.5; const bodyW_bottom = t.r * 2.5; const bodyH = t.r * 1.5; ctx.fillStyle = "#66aaff"; ctx.strokeStyle = "#5599e5"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_bottom / 2, bodyH / 2); ctx.lineTo(-bodyW_bottom / 2, bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#e03434"; ctx.strokeStyle = "#c02d2d"; const crownH = t.r * 0.8, crownW = bodyW_top * 0.9; ctx.beginPath(); ctx.moveTo(-crownW / 2, -bodyH / 2); ctx.lineTo(-crownW / 2 + crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(0, -bodyH / 2 - crownH / 2); ctx.lineTo(crownW / 2 - crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(crownW / 2, -bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#000"; ctx.fillRect(-t.r * 0.6, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(t.r * 0.2, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(-t.r * 0.4, 0, t.r * 0.8, t.r * 0.1); ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 8; ctx.beginPath(); ctx.arc(0, 0, t.r * 1.1, 0.5, Math.PI - 0.5); ctx.stroke(); ctx.fillStyle = "#ffd700"; ctx.strokeStyle = "#daa520"; ctx.lineWidth = 3; const medR = t.r * 0.5; ctx.beginPath(); ctx.moveTo(0, t.r * 1.1 + medR); for (let i = 1; i <= 8; i++) {const angle = i * (2 * Math.PI / 8); ctx.lineTo(medR * Math.sin(angle), t.r * 1.1 + medR * Math.cos(angle));} ctx.closePath(); ctx.fill(); ctx.stroke();} else if (t.behavior === "construct") {
        // Check if this is the DEATH ENGINE boss
        if (t.name === 'DEATH ENGINE') {
            // Update skull renderer position and color for red final phase
            if (t.skullRenderer) {
                t.skullRenderer.x = 0; // Relative position since we're already translated
                t.skullRenderer.y = 0; // Relative position since we're already translated  
                t.skullRenderer.skullColor = t.color || '#e54d24';
                
                // Handle attack animation
                if (t.isLaughing && !t.skullRenderer.isAttacking) {
                    // Trigger attack animation with sound effect
                    t.skullRenderer.triggerAttack(true);
                }
                
                // Update and draw using Boss class
                t.skullRenderer.update();
                t.skullRenderer.draw();
            } else {
                // Fallback to original drawing if skullRenderer is missing (shouldn't happen)
                const skullWidth = t.r * 2; 
                const skullHeight = t.r * 2.8; 
                
                // Calculate mouth openness for animation
                let mouthOpenness = 0;
                if (t.isLaughing) {
                    const elapsedTime = performance.now() - t.laughStartTime;
                    mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 7;
                }

                // Draw all parts of the skull ship (pass boss color for red final phase)
                const skullColor = t.color || '#e54d24';
                drawSkullHorns(ctx, skullWidth, skullHeight, skullColor);
                drawSkullMain(ctx, skullWidth, skullHeight, skullColor);
                drawSkullFace(ctx, skullWidth, skullHeight, mouthOpenness, skullColor);
                drawSkullWeathering(ctx, skullWidth, skullHeight, skullColor);
            }
        } else {
            // Original GEOMETRON drawing code
            const phaseColor = t.phase === 1 ? (t.color || "#ff4500") : "#ff4500"; ctx.fillStyle = addAlpha(phaseColor, 0.67); ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; if (t.phase === 2) {ctx.shadowColor = phaseColor; ctx.shadowBlur = 25;} const bodyW = t.r * 1.2, bodyH = t.r * 1.5, headH = t.r * 0.7; ctx.beginPath(); ctx.moveTo(-bodyW * 0.5, bodyH * 0.5); ctx.lineTo(-bodyW * 0.6, bodyH * 0.2); ctx.lineTo(-bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(0, -bodyH * 0.5); ctx.lineTo(bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(bodyW * 0.6, bodyH * 0.2); ctx.lineTo(bodyW * 0.5, bodyH * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); const shoulderY = -bodyH * 0.3, shoulderX = bodyW * 0.4; const armW = 0.4 * t.r, armH = 0.9 * t.r; ctx.beginPath(); ctx.moveTo(-shoulderX, shoulderY); ctx.lineTo(-shoulderX - armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(-shoulderX, shoulderY + armH); ctx.lineTo(-shoulderX + armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(shoulderX + armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(shoulderX, shoulderY + armH); ctx.lineTo(shoulderX - armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); const eyeR = Math.max(1, t.r * 0.2 + 2 * Math.sin(performance.now() / 200)); ctx.fillStyle = "#ffffff"; ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -headH * 0.1, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        }
    } else if (t.behavior === "avian") {ctx.save(); ctx.rotate(-Math.PI / 2); const wingY = -t.r * 0.4; ctx.strokeStyle = "#FFFFFF"; ctx.fillStyle = t.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-t.r * 0.4, wingY); ctx.quadraticCurveTo(-t.r * 0.8, wingY - t.r * 0.6, -t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(-t.r * 0.9, wingY - t.r * 0.1, -t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(t.r * 0.4, wingY); ctx.quadraticCurveTo(t.r * 0.8, wingY - t.r * 0.6, t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(t.r * 0.9, wingY - t.r * 0.1, t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0, 0, t.r * 0.6, t.r * 0.8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); const eyeSize = t.r * 0.15; ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = "#FF6600"; ctx.beginPath(); ctx.moveTo(0, t.r * 0.1); ctx.lineTo(-t.r * 0.15, t.r * 0.3); ctx.lineTo(t.r * 0.15, t.r * 0.3); ctx.closePath(); ctx.fill(); ctx.restore();} else if (t.behavior === "sentinel") {
        // Cyberpunk VOID SENTINEL with purple-orange sunset gradient
        const time = performance.now() / 1000;
        
        // Create radial gradient for cyberpunk sunset effect
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
        gradient.addColorStop(0, '#FF6B35'); // Orange center
        gradient.addColorStop(0.4, '#FF8E53'); // Orange-purple transition
        gradient.addColorStop(0.7, '#8B4A9C'); // Purple
        gradient.addColorStop(1, '#2D1B69'); // Deep purple edge
        
        // Main body - hexagonal cyberpunk shape
        ctx.fillStyle = gradient;
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const sides = 6;
        for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const x = Math.cos(angle) * t.r;
            const y = Math.sin(angle) * t.r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Inner core with pulsing effect
        const pulseSize = 0.6 + 0.2 * Math.sin(time * 3);
        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 0.5);
        coreGradient.addColorStop(0, '#FFFFFF');
        coreGradient.addColorStop(0.3, '#FF6B35');
        coreGradient.addColorStop(1, '#8B4A9C');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, t.r * 0.4 * pulseSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Cyberpunk energy rings
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            const ringTime = time * (2 + i * 0.5);
            const opacity = 0.3 + 0.4 * Math.sin(ringTime);
            ctx.globalAlpha = opacity;
            
            ctx.beginPath();
            ctx.arc(0, 0, t.r * (0.7 + i * 0.15), 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        
        // Rotating cyberpunk elements
        ctx.strokeStyle = '#8B4A9C';
        ctx.fillStyle = '#FF6B35';
        ctx.lineWidth = 2;
        
        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate(i * Math.PI / 4 + time * 0.5);
            ctx.translate(t.r * 0.8, 0);
            
            // Small diamond-shaped elements
            ctx.beginPath();
            ctx.moveTo(0, -t.r * 0.08);
            ctx.lineTo(t.r * 0.06, 0);
            ctx.lineTo(0, t.r * 0.08);
            ctx.lineTo(-t.r * 0.06, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
        // Glowing eyes with cyberpunk effect
        ctx.shadowColor = '#FF6B35';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#FFFFFF';
        
        const eyeOffset = t.r * 0.25;
        ctx.beginPath();
        ctx.arc(-eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
    } else if (t.behavior === "broodlord") {
        // Draw cyberpunk HIVE SOVEREIGN - sleek and menacing
        const time = performance.now() / 1000;
        const pulseFactor = 1 + 0.08 * Math.sin(time * 3);
        
        // Create sunset gradient for main body
        const mainGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
        mainGradient.addColorStop(0, '#FF6B35'); // Orange center
        mainGradient.addColorStop(0.4, '#FF8E53'); // Orange-purple blend
        mainGradient.addColorStop(0.7, '#8B4A9C'); // Purple
        mainGradient.addColorStop(1, '#2D1B69'); // Deep void purple
        
        // Main carapace body with cyberpunk glow
        ctx.fillStyle = mainGradient;
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#8B4A9C';
        ctx.shadowBlur = 20 * pulseFactor;
        
        ctx.beginPath();
        ctx.ellipse(0, 0, t.r * 1.2 * pulseFactor, t.r * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Segmented armor plating with energy lines
        ctx.strokeStyle = "#FF8E53";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        
        for (let i = -2; i <= 2; i++) {
            const segmentPulse = 0.9 + 0.1 * Math.sin(time * 4 + i * 0.5);
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.ellipse(0, i * t.r * 0.25, t.r * 1.1 * pulseFactor * segmentPulse, t.r * 0.15, 0, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        
        // Cyberpunk energy claws/appendages
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.translate(side * t.r * 0.8, (i - 1) * t.r * 0.4);
                ctx.rotate(side * (Math.PI/6 + i * Math.PI/12) + Math.sin(time * 2 + i) * 0.15);
                
                // Energy claw with gradient
                const clawGradient = ctx.createLinearGradient(0, 0, t.r * 0.8, 0);
                clawGradient.addColorStop(0, '#8B4A9C');
                clawGradient.addColorStop(0.7, '#FF6B35');
                clawGradient.addColorStop(1, '#FFFFFF');
                
                ctx.fillStyle = clawGradient;
                ctx.strokeStyle = '#FF8E53';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FF6B35';
                ctx.shadowBlur = 8;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.lineTo(t.r * 0.7, -t.r * 0.1);
                ctx.lineTo(t.r * 0.8, 0);
                ctx.lineTo(t.r * 0.7, t.r * 0.1);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            }
        }
        ctx.shadowBlur = 0;
        
        // Cyberpunk energy eyes
        const eyeGlow = 0.6 + 0.4 * Math.sin(time * 5);
        
        for (let side = -1; side <= 1; side += 2) {
            // Outer eye glow
            ctx.shadowColor = '#FF6B35';
            ctx.shadowBlur = 20 * eyeGlow;
            ctx.fillStyle = '#FF6B35';
            
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.18 * eyeGlow, 0, Math.PI * 2);
            ctx.fill();
            
            // Main eye
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.12, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy core pupil
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#8B4A9C';
            ctx.fillStyle = '#2D1B69';
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.06, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Cyberpunk mandibles with energy effect
        ctx.shadowBlur = 0;
        const mandibleOffset = Math.sin(time * 3) * 0.12;
        
        for (let side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(side * t.r * 0.2, t.r * 0.2);
            ctx.rotate(side * (Math.PI/8 + mandibleOffset));
            
            // Mandible gradient
            const mandibleGradient = ctx.createLinearGradient(0, 0, t.r * 0.4, 0);
            mandibleGradient.addColorStop(0, '#2D1B69');
            mandibleGradient.addColorStop(0.6, '#8B4A9C');
            mandibleGradient.addColorStop(1, '#FF6B35');
            
            ctx.fillStyle = mandibleGradient;
            ctx.strokeStyle = '#FF8E53';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#8B4A9C';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(t.r * 0.3, -t.r * 0.1);
            ctx.lineTo(t.r * 0.4, 0);
            ctx.lineTo(t.r * 0.3, t.r * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        ctx.shadowBlur = 0;
        
    } else if (t.behavior === "shadow_clone") {
        const player = (typeof store !== 'undefined' && store && store.player) ? store.player : {};
        const subclass = player && player.subclass ? player.subclass : '';
        const time = performance.now() / 1000;
        const basePulse = 0.6 + 0.25 * Math.sin(time * 4.3);
        let accent = '#8fa0ff';
        switch (subclass) {
            case 'juggernaut': accent = '#ff6b6b'; break;
            case 'marauder': accent = '#66ff99'; break;
            case 'demolitionist': accent = '#ffd166'; break;
            case 'railgunner': accent = '#b794ff'; break;
            case 'phasestriker': accent = '#ff91d2'; break;
            case 'stormcaller': accent = '#6dd0ff'; break;
        }
        const glowStrength = t.isEnraged ? 1.0 : 0.7;
        let facing = Math.atan2(((player && player.y) ? player.y : t.y) - t.y, ((player && player.x) ? player.x : t.x) - t.x) + Math.PI / 2;
        if (t.abilityStage === 'charge' && (Math.abs(t.shadowChargeVX || 0) + Math.abs(t.shadowChargeVY || 0)) > 16) {
            facing = Math.atan2(t.shadowChargeVY || 0, t.shadowChargeVX || 0) + Math.PI / 2;
        }
        const wobble = Math.sin(time * 3 + (t.moveT || 0)) * 0.05;
        ctx.save();
        ctx.rotate(facing + wobble);
        const scalePulse = 1 + (t.currentAbility ? basePulse * 0.05 : 0);
        ctx.scale(scalePulse, 1);

        ctx.shadowColor = addAlpha(accent, glowStrength);
        ctx.shadowBlur = t.isEnraged ? 30 : 18;

        const bodyGradient = ctx.createLinearGradient(0, -t.r * 1.4, 0, t.r * 1.3);
        bodyGradient.addColorStop(0, addAlpha('#f4f7ff', 0.85));
        bodyGradient.addColorStop(0.45, addAlpha('#3b4268', 0.95));
        bodyGradient.addColorStop(1, addAlpha('#060712', 0.95));
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.moveTo(0, -t.r * 1.35);
        ctx.lineTo(t.r * 0.92, t.r * 0.88);
        ctx.lineTo(0, t.r * 1.15);
        ctx.lineTo(-t.r * 0.92, t.r * 0.88);
        ctx.closePath();
        ctx.fill();
        ctx.lineWidth = 2.4;
        ctx.strokeStyle = addAlpha('#ccd2ef', 0.55);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -t.r * 0.95);
        ctx.lineTo(t.r * 0.55, t.r * 0.68);
        ctx.lineTo(0, t.r * 0.9);
        ctx.lineTo(-t.r * 0.55, t.r * 0.68);
        ctx.closePath();
        ctx.fillStyle = 'rgba(22, 26, 52, 0.9)';
        ctx.fill();
        ctx.lineWidth = 1.4;
        ctx.strokeStyle = addAlpha(accent, 0.55 + 0.3 * basePulse);
        ctx.stroke();

        ctx.globalAlpha = 0.9;
        ctx.fillStyle = addAlpha('#f7fbff', 0.85);
        ctx.beginPath();
        ctx.arc(0, -t.r * 0.32, t.r * 0.28, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = addAlpha(accent, 0.6 + 0.3 * Math.sin(time * 6));
        ctx.beginPath();
        ctx.arc(0, -t.r * 0.32, t.r * 0.16, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.lineWidth = 3;
        ctx.strokeStyle = addAlpha(accent, 0.45 + 0.35 * basePulse);
        for (let side = -1; side <= 1; side += 2) {
            ctx.beginPath();
            ctx.moveTo(side * t.r * 0.65, -t.r * 0.1);
            ctx.quadraticCurveTo(side * t.r * 1.2, t.r * 0.15, side * t.r * 0.95, t.r * 0.95);
            ctx.stroke();
        }

        ctx.lineWidth = 1.2;
        ctx.strokeStyle = addAlpha('#dde3ff', 0.4);
        ctx.beginPath();
        ctx.moveTo(-t.r * 0.35, -t.r * 0.2);
        ctx.lineTo(-t.r * 0.55, t.r * 0.6);
        ctx.moveTo(t.r * 0.35, -t.r * 0.2);
        ctx.lineTo(t.r * 0.55, t.r * 0.6);
        ctx.stroke();

        const exhaustPulse = 0.6 + 0.35 * Math.sin(time * 10 + (t.isEnraged ? Math.PI / 4 : 0));
        ctx.globalAlpha = 0.45 + 0.4 * exhaustPulse;
        ctx.fillStyle = addAlpha(accent, 0.8);
        ctx.beginPath();
        ctx.ellipse(-t.r * 0.38, t.r * 1.08, t.r * 0.2, t.r * (0.45 + 0.12 * exhaustPulse), 0, 0, Math.PI * 2);
        ctx.ellipse(t.r * 0.38, t.r * 1.08, t.r * 0.2, t.r * (0.45 + 0.12 * exhaustPulse), 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        if (t.abilityStage === 'charge') {
            ctx.lineWidth = 2.6;
            ctx.strokeStyle = addAlpha(accent, 0.85);
            ctx.beginPath();
            ctx.moveTo(-t.r * 0.5, t.r * 0.6);
            ctx.lineTo(-t.r * 0.75, t.r * 1.4);
            ctx.moveTo(t.r * 0.5, t.r * 0.6);
            ctx.lineTo(t.r * 0.75, t.r * 1.4);
            ctx.stroke();
        }

        ctx.shadowBlur = 0;
        ctx.restore();

        if (t.shadowTelegraph) {
            const telegraph = t.shadowTelegraph;
            const progress = Math.max(0, Math.min(1, telegraph.progress || 0));
            if (telegraph.type === 'star') {
                const ringRadius = t.r * (1.05 + progress * 0.65);
                ctx.save();
                ctx.globalAlpha = 0.4 + 0.4 * progress;
                ctx.lineWidth = 2 + progress * 3;
                ctx.strokeStyle = addAlpha(accent, 0.8);
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 0.6;
                const starCount = 6;
                for (let i = 0; i < starCount; i++) {
                    ctx.save();
                    ctx.rotate(time * (t.isEnraged ? 2.1 : 1.6) + i * (Math.PI * 2 / starCount));
                    ctx.translate(0, ringRadius);
                    const size = 7 + progress * 6;
                    ctx.fillStyle = addAlpha('#f6f8ff', 0.9);
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.45, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size * 0.45, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.lineWidth = 1.2;
                    ctx.strokeStyle = addAlpha(accent, 0.6);
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            } else if (telegraph.type === 'lightning' && t.shadowTelegraphTarget) {
                const targetX = t.shadowTelegraphTarget.x - t.x;
                const targetY = t.shadowTelegraphTarget.y - t.y;
                const dist = Math.sqrt(targetX * targetX + targetY * targetY) || 1;
                const segments = 7;
                ctx.globalAlpha = 0.25 + 0.55 * progress;
                ctx.lineWidth = 2 + progress * 2.5;
                ctx.strokeStyle = addAlpha(accent, 0.7);
                ctx.beginPath();
                ctx.moveTo(0, -t.r * 0.25);
                for (let i = 1; i <= segments; i++) {
                    const tSeg = i / segments;
                    const px = targetX * tSeg;
                    const py = targetY * tSeg;
                    const offsetScale = (1 - Math.abs(0.5 - tSeg) * 1.8);
                    const offset = Math.sin(time * 12 + i * 1.7) * offsetScale * 24 * (0.3 + progress);
                    const nx = -targetY / dist;
                    const ny = targetX / dist;
                    const jitterX = px + nx * offset;
                    const jitterY = py + ny * offset;
                    ctx.lineTo(jitterX, jitterY);
                }
                ctx.stroke();
                ctx.setLineDash([10, 8]);
                ctx.lineWidth = 1.4;
                ctx.strokeStyle = addAlpha('#f1f3ff', 0.6);
                ctx.beginPath();
                ctx.moveTo(0, -t.r * 0.3);
                ctx.lineTo(targetX, targetY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 0.6;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(targetX, targetY, 14 + progress * 18, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            } else if (telegraph.type === 'hounds') {
                const baseRadius = t.r * 0.9;
                const ringRadius = baseRadius + progress * t.r * 0.6;
                ctx.save();
                ctx.translate(0, t.r * 1.1);
                ctx.scale(1, 0.55);
                ctx.globalAlpha = 0.3 + 0.4 * progress;
                ctx.fillStyle = 'rgba(10, 12, 28, 0.9)';
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.lineWidth = 2;
                ctx.strokeStyle = addAlpha(accent, 0.7);
                ctx.setLineDash([4, 3]);
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.shadowColor = addAlpha(accent, 0.6);
                ctx.shadowBlur = 15;
                const pawCount = 4;
                for (let i = 0; i < pawCount; i++) {
                    const angle = time * (t.isEnraged ? 2.4 : 1.6) + i * (Math.PI * 2 / pawCount);
                    const radius = ringRadius * (0.45 + 0.25 * Math.sin(time * 3 + i));
                    const px = Math.cos(angle) * radius;
                    const py = Math.sin(angle) * radius;
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.rotate(angle);
                    const size = 6 + progress * 4;
                    ctx.fillStyle = addAlpha('#f4f7ff', 0.85);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, size, size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                ctx.shadowBlur = 0;
                ctx.restore();
            } else if (telegraph.type === 'charge' && t.shadowTelegraphTarget) {
                const targetX = t.shadowTelegraphTarget.x - t.x;
                const targetY = t.shadowTelegraphTarget.y - t.y;
                const dist = Math.sqrt(targetX * targetX + targetY * targetY) || 1;
                const dirX = targetX / dist;
                const dirY = targetY / dist;
                const reach = Math.min(dist, t.r * (2.8 + 1.4 * progress));
                ctx.globalAlpha = 0.4 + 0.45 * progress;
                ctx.lineWidth = 3.2;
                ctx.strokeStyle = addAlpha(accent, 0.8);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(dirX * reach, dirY * reach);
                ctx.stroke();
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = addAlpha('#f3f6ff', 0.75);
                ctx.beginPath();
                ctx.moveTo(dirX * (reach + 12), dirY * (reach + 12));
                ctx.lineTo(dirX * (reach - 10) - dirY * 8, dirY * (reach - 10) + dirX * 8);
                ctx.lineTo(dirX * (reach - 10) + dirY * 8, dirY * (reach - 10) - dirX * 8);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(targetX, targetY);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(targetX, targetY, 14 + progress * 14, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }
    } else {const time = performance.now() / 1000; ctx.fillStyle = '#2c2c54'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, t.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#706fd3'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f0932b'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.3, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 6; i++) {ctx.save(); ctx.rotate(i * Math.PI / 3 + time * 0.3); ctx.translate(t.r * 0.6, 0); ctx.fillStyle = '#ff6348'; ctx.strokeStyle = '#2f3542'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore();} const eyeSize = t.r * 0.12; ctx.fillStyle = '#ff3838'; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 4; i++) {ctx.save(); ctx.rotate(i * Math.PI / 2 + time * -0.5); ctx.translate(t.r * 0.9, 0); ctx.fillStyle = '#3c6382'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 2; ctx.fillRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.strokeRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.restore();}} ctx.restore();}

    function drawShip(t, e, player) {
        let mainColor = '#b266ff', accentColor1 = '#7a49cc', accentColor2 = '#4d2a80',
            wingStrokeColor = '#c49cff', engineColor = '#cc99ff';

        switch (player.subclass) {
            case 'juggernaut':
                mainColor = '#ff3333'; accentColor1 = '#cc0000'; accentColor2 = '#990000';
                wingStrokeColor = '#ff6666'; engineColor = '#ffaaaa';
                break;
            case 'marauder':
                mainColor = '#33cc33'; accentColor1 = '#009900'; accentColor2 = '#006600';
                wingStrokeColor = '#66ff66'; engineColor = '#aaffaa';
                break;
            case 'demolitionist':
                mainColor = '#ffcc00'; accentColor1 = '#ffaa00'; accentColor2 = '#cc8800';
                wingStrokeColor = '#ffeeaa'; engineColor = '#ffffcc';
                break;
            case 'railgunner':
                mainColor = '#9933ff'; accentColor1 = '#6600cc'; accentColor2 = '#440088';
                wingStrokeColor = '#cc99ff'; engineColor = '#e6ccff';
                break;
            case 'phasestriker':
                mainColor = '#ff69b4'; accentColor1 = '#ff1493'; accentColor2 = '#c71585';
                wingStrokeColor = '#ffb6c1'; engineColor = '#ffc0cb';
                break;
            case 'stormcaller':
                mainColor = '#00bfff'; accentColor1 = '#1e90ff'; accentColor2 = '#0000cd';
                wingStrokeColor = '#87cefa'; engineColor = '#add8e6';
                break;
        }

        ctx.save();
        ctx.translate(t,e);
        if(player.isInvincible || player.hasShieldBubble){
            ctx.beginPath();ctx.arc(0,0,24,0,2*Math.PI);
            const g=ctx.createRadialGradient(0,0,18,0,0,24);
            g.addColorStop(0,"#9a66ff11");g.addColorStop(1,"#9a66ff");
            ctx.fillStyle=g;ctx.fill()
        }
        ctx.beginPath();
        ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);
        ctx.closePath();
        const o=ctx.createLinearGradient(0,-20,0,14);
        o.addColorStop(0, mainColor);o.addColorStop(.5, accentColor1);o.addColorStop(1, accentColor2);
        ctx.fillStyle=o;ctx.fill();
        ctx.lineWidth=2;ctx.strokeStyle=wingStrokeColor;ctx.stroke();
        ctx.strokeStyle=mainColor;ctx.lineWidth=2;
        ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();
        const r=performance.now()/1e3;
    ctx.globalAlpha=.8+.2*Math.sin(10*r);
    ctx.fillStyle=engineColor;
    ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,2*Math.PI);ctx.ellipse(5,16,3,6,0,0,2*Math.PI);ctx.fill();
    ctx.globalAlpha=1;
    ctx.fillStyle="#ffffff";ctx.beginPath();ctx.arc(0,-8,3,0,2*Math.PI);ctx.fill();

    const time = performance.now() / 1000;
        
        // Draw beef shield bubble if pilot is beef and shield is active
        if (player.pilotGenome === 'beef' && player.beefShield > 0) {
            const shieldPercent = player.beefShield / player.beefShieldMax;
            const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 2.5);
            
            // Base radius scales with shield level (8px minimum, up to 30px at full shield)
            const baseRadius = 8 + (22 * shieldPercent); // 8px at 0%, 30px at 100%
            // Add wobbling effect on top of the scaled base
            const wobbleAmount = 4 * shieldPercent; // Wobble gets stronger as shield grows
            const shieldRadius = baseRadius + wobbleAmount * Math.sin(time * 3);
            
            // Create void power shield gradient (dark purple/black energy)
            const shieldGradient = ctx.createRadialGradient(0, 0, shieldRadius * 0.2, 0, 0, shieldRadius);
            shieldGradient.addColorStop(0, `rgba(75, 0, 130, ${0.8 * shieldPercent})`); // Dark purple core (increased opacity)
            shieldGradient.addColorStop(0.4, `rgba(25, 25, 112, ${0.6 * shieldPercent * pulseIntensity})`); // Midnight blue (increased)
            shieldGradient.addColorStop(0.7, `rgba(72, 61, 139, ${0.7 * shieldPercent})`); // Dark slate blue (increased)
            shieldGradient.addColorStop(1, `rgba(138, 43, 226, ${0.5 * shieldPercent})`); // Purple edge (was black, now purple)
            
            ctx.beginPath();
            ctx.arc(0, 0, shieldRadius, 0, 2 * Math.PI);
            ctx.fillStyle = shieldGradient;
            ctx.fill();
            
            // Add void energy sparkles
            ctx.strokeStyle = `rgba(138, 43, 226, ${0.9 * shieldPercent * pulseIntensity})`; // Blue violet sparkles (increased opacity)
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
            
            // Add inner void energy core
            if (shieldPercent > 0.2) {
                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shieldRadius * 0.3);
                coreGradient.addColorStop(0, `rgba(147, 0, 211, ${0.6 * shieldPercent})`); // Dark violet (increased)
                coreGradient.addColorStop(1, `rgba(75, 0, 130, ${0.3 * shieldPercent})`); // (increased)
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, 0, shieldRadius * 0.3 * Math.abs(Math.sin(time * 4)), 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // Draw universal health and shield meters above ship for all pilots
        const meterWidth = 55;
        const meterHeight = 3;
        const meterSpacing = 6;
        const cornerRadius = 1.5;
        let meterY = -35;
        
        // Helper function for rounded rectangles
        const drawRoundedRect = (x, y, width, height, radius, fill = true, stroke = false) => {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        };
        
        // Health bar (always visible)
        const healthPercent = player.hp / player.hpMax;
        
        // Health bar background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        drawRoundedRect(-meterWidth/2, meterY, meterWidth, meterHeight, cornerRadius);
        
        // Health bar fill
        if (healthPercent > 0) {
            const healthGradient = ctx.createLinearGradient(-meterWidth/2, meterY, meterWidth/2, meterY);
            if (healthPercent > 0.6) {
                healthGradient.addColorStop(0, 'rgba(50, 205, 50, 0.8)'); // Lime green
                healthGradient.addColorStop(1, 'rgba(34, 139, 34, 0.8)'); // Forest green
            } else if (healthPercent > 0.3) {
                healthGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)'); // Orange
                healthGradient.addColorStop(1, 'rgba(255, 140, 0, 0.8)'); // Dark orange
            } else {
                healthGradient.addColorStop(0, 'rgba(255, 69, 0, 0.8)'); // Red orange
                healthGradient.addColorStop(1, 'rgba(178, 34, 34, 0.8)'); // Fire brick red
            }
            
            ctx.fillStyle = healthGradient;
            drawRoundedRect(-meterWidth/2, meterY, meterWidth * healthPercent, meterHeight, cornerRadius);
        }
        
        // Health bar border
        ctx.strokeStyle = healthPercent > 0.6 ? 'rgba(50, 205, 50, 0.6)' : 
                         healthPercent > 0.3 ? 'rgba(255, 165, 0, 0.6)' : 'rgba(255, 69, 0, 0.6)';
        ctx.lineWidth = 0.5;
        drawRoundedRect(-meterWidth/2, meterY, meterWidth, meterHeight, cornerRadius, false, true);
        
        // Health text
        ctx.fillStyle = healthPercent > 0.6 ? 'rgba(50, 205, 50, 0.9)' : 
                       healthPercent > 0.3 ? 'rgba(255, 165, 0, 0.9)' : 'rgba(255, 69, 0, 0.9)';
        ctx.font = '8px monospace';
        ctx.textAlign = 'center';
        const healthText = `${Math.round(player.hp)}/${Math.round(player.hpMax)}`;
        ctx.fillText(healthText, 0, meterY - 2);
        
        // Shield bars (show if any shield type exists)
        const hasRegularShield = player.shieldMax > 0;
        const hasBeefShield = player.pilotGenome === 'beef' && player.beefShieldMax > 0;
        
        if (hasRegularShield || hasBeefShield) {
            meterY -= meterSpacing;
            
            // Regular shield bar
            if (hasRegularShield) {
                const shieldPercent = player.shield / player.shieldMax;
                
                // Shield bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                drawRoundedRect(-meterWidth/2, meterY, meterWidth, meterHeight, cornerRadius);
                
                // Shield bar fill
                if (shieldPercent > 0) {
                    const shieldGradient = ctx.createLinearGradient(-meterWidth/2, meterY, meterWidth/2, meterY);
                    shieldGradient.addColorStop(0, 'rgba(100, 149, 237, 0.8)'); // Cornflower blue
                    shieldGradient.addColorStop(1, 'rgba(65, 105, 225, 0.8)'); // Royal blue
                    
                    ctx.fillStyle = shieldGradient;
                    drawRoundedRect(-meterWidth/2, meterY, meterWidth * shieldPercent, meterHeight, cornerRadius);
                }
                
                // Shield bar border
                ctx.strokeStyle = 'rgba(100, 149, 237, 0.6)';
                ctx.lineWidth = 0.5;
                drawRoundedRect(-meterWidth/2, meterY, meterWidth, meterHeight, cornerRadius, false, true);
                
                // Shield text
                ctx.fillStyle = 'rgba(100, 149, 237, 0.9)';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                const shieldText = `${Math.round(player.shield)}/${Math.round(player.shieldMax)}`;
                ctx.fillText(shieldText, 0, meterY - 2);
                
                if (hasBeefShield) meterY -= meterSpacing;
            }
            
            // Beef shield bar
            if (hasBeefShield) {
                const beefShieldPercent = player.beefShield / player.beefShieldMax;
                
                // Beef shield bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                drawRoundedRect(-meterWidth/2, meterY, meterWidth, meterHeight, cornerRadius);
                
                // Beef shield bar fill
                if (beefShieldPercent > 0) {
                    const beefShieldGradient = ctx.createLinearGradient(-meterWidth/2, meterY, meterWidth/2, meterY);
                    beefShieldGradient.addColorStop(0, 'rgba(75, 0, 130, 0.8)'); // Dark purple
                    beefShieldGradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.8)'); // Blue violet
                    beefShieldGradient.addColorStop(1, 'rgba(147, 0, 211, 0.8)'); // Dark violet
                    
                    ctx.fillStyle = beefShieldGradient;
                    drawRoundedRect(-meterWidth/2, meterY, meterWidth * beefShieldPercent, meterHeight, cornerRadius);
                }
                
                // Beef shield bar border
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.6)';
                ctx.lineWidth = 0.5;
                drawRoundedRect(-meterWidth/2, meterY, meterWidth, meterHeight, cornerRadius, false, true);
                
                // Beef shield text
                ctx.fillStyle = 'rgba(138, 43, 226, 0.9)';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                const beefShieldText = `${Math.round(player.beefShield)}/${Math.round(player.beefShieldMax)}`;
                ctx.fillText(beefShieldText, 0, meterY - 2);
            }
        }

        if (player.pilotGenome === 'rocketman' && player.hasFirewall) {
            const flameCharge = Math.max(0, Math.min(1, player.flameWallCharge || 0));
            const noseY = -20;
            const tailY = 14;
            const band = Math.max(0.04, 0.12 - flameCharge * 0.05);
            const boundary = Math.max(0, Math.min(1, 1 - flameCharge));
            const waveTime = performance.now() / 1000;
            
            // Show afterburner indicators when active
            if (player.afterburnerActive) {
                const afterburnerProgress = 1 - (player.afterburnerTimer / player.afterburnerMaxDuration);
                const glowIntensity = 0.3 + 0.7 * Math.sin(waveTime * 8);
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                // Left and right afterburner glows
                for (let side = -1; side <= 1; side += 2) {
                    ctx.fillStyle = `rgba(255, 140, 20, ${glowIntensity * 0.4})`;
                    ctx.beginPath();
                    ctx.ellipse(side * 12, tailY + 6, 8, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = `rgba(255, 200, 60, ${glowIntensity * 0.6})`;
                    ctx.beginPath();
                    ctx.ellipse(side * 12, tailY + 6, 4, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(12, 8);
            ctx.lineTo(8, 14);
            ctx.lineTo(0, 10);
            ctx.lineTo(-8, 14);
            ctx.lineTo(-12, 8);
            ctx.closePath();
            ctx.clip();

            const gradient = ctx.createLinearGradient(0, noseY, 0, tailY);
            const yellowAlpha = 0.35 + flameCharge * 0.2;
            const orangeAlpha = 0.25 + flameCharge * 0.45;
            const yellow = `rgba(255, 210, 80, ${yellowAlpha})`;
            const orange = `rgba(255, 110, 0, ${orangeAlpha})`;
            const lowerCut = Math.max(0, boundary - band);
            const upperCut = Math.min(1, boundary + band);

            gradient.addColorStop(0, yellow);
            gradient.addColorStop(lowerCut, yellow);
            gradient.addColorStop(Math.max(lowerCut, boundary), orange);
            gradient.addColorStop(upperCut, orange);
            gradient.addColorStop(1, orange);

            ctx.fillStyle = gradient;
            ctx.fillRect(-22, noseY - 2, 44, tailY - noseY + 4);

            const shimmerOffset = Math.sin(waveTime * 3.1) * (8 + flameCharge * 10);
            const shimmer = ctx.createLinearGradient(-14, noseY - 10 + shimmerOffset, 14, tailY + 4 - shimmerOffset);
            shimmer.addColorStop(0, `rgba(255, 240, 180, ${0.04 + flameCharge * 0.12})`);
            shimmer.addColorStop(0.5, `rgba(255, 190, 120, ${0.08 + flameCharge * 0.16})`);
            shimmer.addColorStop(1, `rgba(255, 120, 40, ${0.05 + flameCharge * 0.14})`);

            ctx.globalAlpha = 0.9;
            ctx.fillStyle = shimmer;
            ctx.fillRect(-20, noseY - 8, 40, tailY - noseY + 12);

            ctx.restore();

            ctx.save();
            ctx.shadowColor = `rgba(255, 120, 0, ${0.4 + flameCharge * 0.4})`;
            ctx.shadowBlur = 12 + flameCharge * 14;
            ctx.strokeStyle = `rgba(255, 220, 120, ${0.3 + flameCharge * 0.5})`;
            ctx.lineWidth = 1.2 + flameCharge;
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(12, 8);
            ctx.lineTo(8, 14);
            ctx.lineTo(0, 10);
            ctx.lineTo(-8, 14);
            ctx.lineTo(-12, 8);
            ctx.closePath();
            ctx.stroke();

            ctx.restore();
        }

        if (player.hasRearGuard && player.rearGuardReady) {
            const pulse = 0.4 + 0.3 * Math.sin(performance.now() / 200);
            ctx.fillStyle = `rgba(100, 255, 255, ${pulse})`;
            ctx.beginPath();
            ctx.arc(0, 15, 8, 0, 2 * Math.PI);
            ctx.fill();
        }

        ctx.restore();
    }

    function drawMine(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        const time = performance.now();
        const pulse = 0.8 + 0.2 * Math.sin(time / 150);
        const fuseRatio = m.fuse / 5;
        const color = `rgb(255, ${100 * fuseRatio}, ${80 * fuseRatio})`;

        ctx.beginPath();
        ctx.arc(0, 0, m.r * 1.5 * pulse, 0, 2 * Math.PI);
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, m.r * 1.5 * pulse);
        grad.addColorStop(0, color + '99');
        grad.addColorStop(1, color + '00');
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(0, 0, m.r, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, m.r * 0.4 * pulse, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    const VOID_CHAMPION_COLOR_SCHEMES = {
        purple: {
            name: 'Void Wraith',
            shadowColor: '#b56bff',
            auraColor: '#7a34ff',
            hullGradient: ['#5f18c4', '#1b0635', '#320a63'],
            strokeColor: '#c6a4ff',
            finColor: [155, 69, 255],
            visorGradient: ['#f5d9ff', '#7d2cff'],
            eyeColor: '#ff508f',
            coreGlow: '#e499ff',
            coreColor: '#ffe6ff',
            thrusterColor: '#732bff'
        },
        crimson: {
            name: 'Crimson Reaper',
            shadowColor: '#ff4444',
            auraColor: '#cc1100',
            hullGradient: ['#8b0000', '#330000', '#4a0000'],
            strokeColor: '#ff6666',
            finColor: [200, 50, 50],
            visorGradient: ['#ffcccc', '#990000'],
            eyeColor: '#ffff00',
            coreGlow: '#ff8888',
            coreColor: '#ffffff',
            thrusterColor: '#cc0000'
        },
        azure: {
            name: 'Azure Phantom',
            shadowColor: '#4488ff',
            auraColor: '#0044cc',
            hullGradient: ['#1144aa', '#001122', '#002244'],
            strokeColor: '#66aaff',
            finColor: [100, 150, 255],
            visorGradient: ['#ccddff', '#0066cc'],
            eyeColor: '#00ffff',
            coreGlow: '#88bbff',
            coreColor: '#ffffff',
            thrusterColor: '#0088ff'
        },
        emerald: {
            name: 'Emerald Specter',
            shadowColor: '#44ff44',
            auraColor: '#00cc44',
            hullGradient: ['#006600', '#001100', '#003300'],
            strokeColor: '#66ff66',
            finColor: [50, 200, 50],
            visorGradient: ['#ccffcc', '#009900'],
            eyeColor: '#ffff00',
            coreGlow: '#88ff88',
            coreColor: '#ffffff',
            thrusterColor: '#00cc00'
        },
        golden: {
            name: 'Golden Harbinger',
            shadowColor: '#ffcc44',
            auraColor: '#cc8800',
            hullGradient: ['#b8860b', '#4a3c00', '#6b5b00'],
            strokeColor: '#ffd700',
            finColor: [255, 200, 50],
            visorGradient: ['#fffacd', '#daa520'],
            eyeColor: '#ff4500',
            coreGlow: '#ffd700',
            coreColor: '#ffffff',
            thrusterColor: '#b8860b'
        }
    };

    function getVoidChampionColorScheme(enemy) {
        if (!enemy.colorScheme) {
            const schemes = Object.keys(VOID_CHAMPION_COLOR_SCHEMES);
            const seed = enemy.id || (enemy.x + enemy.y * 1000);
            const schemeIndex = Math.abs(Math.floor(seed)) % schemes.length;
            enemy.colorScheme = schemes[schemeIndex];
            enemy.displayName = VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme].name;
        }
        return VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme];
    }

    function drawEnemy(e) {
        const { x: t, y: o, r: a, type: r, color: n, hp: l, hpMax: s, t: c } = e;
        ctx.save();
        let drawX = t;
        let drawY = o;
        if (e.hitShakeTimer && e.hitShakeTimer > 0 && e.hitShakeIntensity) {
            const baseDuration = e.hitShakeDuration || 0.16;
            const ratio = baseDuration > 0 ? Math.max(0, Math.min(1, e.hitShakeTimer / baseDuration)) : 0;
            const intensity = e.hitShakeIntensity * Math.pow(ratio, 0.6);
            const phaseSeed = (e.id || 0) * 13.37;
            const time = performance.now() * 0.006 + phaseSeed;
            drawX += Math.sin(time) * intensity;
            drawY += Math.cos(time * 1.6) * intensity * 0.7;
        }
        ctx.translate(drawX, drawY);
        const spawnAlpha = e.spawnOpacity !== undefined ? Math.max(0.2, Math.min(1, e.spawnOpacity)) : 1;
        ctx.globalAlpha *= spawnAlpha;
        if (e.spawnPhase === 'teleport') {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const time = performance.now() / 200;
            const ringRadius = (a + 8) * (0.9 + 0.05 * Math.sin(time + (e.spawnClusterIndex || 0)));
            const ringAlpha = 0.35 + 0.25 * spawnAlpha;
            ctx.globalAlpha = ringAlpha;
            ctx.strokeStyle = e.spawnEffectColor || '#9ad7ff';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = ringAlpha * 0.7;
            ctx.beginPath();
            ctx.arc(0, 0, ringRadius * 0.65, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        // Apply flattening effect if enemy has flattenScale property
        if (e.flattenScale !== undefined) {
            if (typeof e.flattenScale === 'number') {
                ctx.scale(1, e.flattenScale);
            } else {
                ctx.scale(e.flattenScale.x || 1, e.flattenScale.y || 1);
            }
        }
    l<s&&l>0&&(ctx.fillStyle='rgba(0,0,0,0.5)',ctx.fillRect(-a,-a-8,2*a,3),ctx.fillStyle="#b266ff",ctx.fillRect(-a,-a-8,2*a*(l/s),3));ctx.lineWidth=2;ctx.beginPath();switch(r){case"avian_hatchling":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a*1.2);ctx.lineTo(a,-a*0.5);ctx.lineTo(a,a*0.5);ctx.lineTo(0,a*1.2);ctx.lineTo(-a,a*0.5);ctx.lineTo(-a,-a*0.5);ctx.closePath();ctx.fill();ctx.stroke();break;case"construct_gold":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a);ctx.lineTo(a,0);ctx.lineTo(0,a);ctx.lineTo(-a,0);ctx.closePath();ctx.fill();ctx.stroke();break;case"trap_king_add":case"drone":const droneGradient=ctx.createLinearGradient(-a,-a,a,a);droneGradient.addColorStop(0,"#E0E0E0");droneGradient.addColorStop(1,"#A0A0A0");ctx.fillStyle=droneGradient;ctx.strokeStyle="#808080";ctx.beginPath();ctx.moveTo(-1.2*a,0);ctx.quadraticCurveTo(0,-a,1.2*a,0);ctx.quadraticCurveTo(0,.6*a,-1.2*a,0);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#aaddff";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-.2*a,.6*a,Math.PI,0);ctx.fill();ctx.stroke();ctx.fillStyle=r==="trap_king_add"?"#ffc83d":"#32CD32";ctx.beginPath();ctx.ellipse(0,-.2*a,.3*a,.4*a,0,0,2*Math.PI);ctx.fill();ctx.fillStyle="#000000";ctx.beginPath();ctx.ellipse(-.1*a,-.25*a,.08*a,.15*a,-.5,0,2*Math.PI);ctx.ellipse(.1*a,-.25*a,.08*a,.15*a,.5,0,2*Math.PI);ctx.fill();break;
        case "hunter": {
            const time = performance.now() / 1000;
            const segments = 8;
            const length = a * 2;
            const amplitude = a * 0.5;

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            ctx.setLineDash([]);

            const top = [];
            const bottom = [];

            for (let i = 0; i <= segments; i++) {
                const progress = i / segments;
                const width = a * Math.sin(progress * Math.PI) * 0.4;
                const x = Math.sin(progress * 2 * Math.PI + c * 4) * amplitude;
                const y = (progress - 0.5) * length;
                top.push({ x: x + width, y });
                bottom.push({ x: x - width, y });
            }

            ctx.fillStyle = '#cc3344';
            ctx.strokeStyle = '#7a1b24';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(top[0].x, top[0].y);
            for (let i = 1; i < top.length; i++) ctx.lineTo(top[i].x, top[i].y);
            for (let i = bottom.length - 1; i >= 0; i--) ctx.lineTo(bottom[i].x, bottom[i].y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            const headX = Math.sin(c * 4) * amplitude;
            const headY = -0.5 * length;

            ctx.fillStyle = '#e47777';
            ctx.strokeStyle = '#7a1b24';
            ctx.beginPath();
            ctx.arc(headX, headY, a * 0.35, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#250b0b';
            const eyeOffsetX = a * 0.12;
            const eyeOffsetY = a * 0.05;
            const eyeRadius = a * 0.08;
            ctx.beginPath();
            ctx.arc(headX - eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.arc(headX + eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#7a1b24';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(headX, headY + a * 0.1);
            ctx.lineTo(headX, headY + a * 0.4);
            ctx.stroke();

            break;
        }
        case "phantom":
            ctx.globalAlpha=.6+.4*Math.sin(5*c);ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-.8*a);ctx.quadraticCurveTo(a,-.5*a,.8*a,.8*a);ctx.quadraticCurveTo(0,.5*a,-.8*a,.8*a);ctx.quadraticCurveTo(-a,-.5*a,0,-.8*a);ctx.closePath();ctx.fill();ctx.stroke();for(let e=-1;e<=1;e++)ctx.beginPath(),ctx.moveTo(e*.4*a,.6*a),ctx.quadraticCurveTo(e*.5*a,a,e*.3*a+2*Math.sin(4*c+e),1.2*a),ctx.stroke();break;
    case "mech": 
            // Enhanced mechanical tank enemy with Aquaman aqua blue theme
            const time = performance.now() / 1000;
            const pulseFactor = 1 + 0.05 * Math.sin(time * 4);
            
            // Aquaman color scheme: aqua blues and ocean greens
            const mainColor = '#0e4b5c'; // Deep aqua blue
            const accentColor = '#20b2aa'; // Light sea green
            const metalColor = '#2e8b8b'; // Dark cyan/teal
            const glowColor = '#00ffff'; // Bright cyan glow
            const highlightColor = '#40e0d0'; // Turquoise highlights
            
            ctx.lineWidth = 2;
            
            // Main chassis with aqua gradient shading
            const chassisGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.2);
            chassisGradient.addColorStop(0, highlightColor);
            chassisGradient.addColorStop(0.6, mainColor);
            chassisGradient.addColorStop(1, '#051e28'); // Deep ocean blue
            
            ctx.fillStyle = chassisGradient;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.moveTo(-a * 1.2, -a * 1.0);
            ctx.lineTo(a * 1.2, -a * 1.0); 
            ctx.lineTo(a * 0.7, a * 0.6);  
            ctx.lineTo(-a * 0.7, a * 0.6); 
            ctx.closePath(); 
            ctx.fill(); 
            ctx.stroke();
            
            // Armor plating with rivets
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 1;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(i * a * 0.2, -a * 0.8);
                ctx.lineTo(i * a * 0.15, a * 0.4);
                ctx.stroke();
            }
            
            // Rivets with aqua metallic finish
            ctx.fillStyle = '#5f9ea0'; // Cadet blue rivets
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    ctx.beginPath();
                    ctx.arc(i * a * 0.3, j * a * 0.3, a * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Weapon turrets with menacing design
            ctx.lineWidth = 3;
            // Left turret
            ctx.fillStyle = mainColor;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.rect(-a * 1.6, -a * 0.9, a * 0.7, a * 1.8);
            ctx.fill(); ctx.stroke();
            
            // Left cannon barrel
            ctx.fillStyle = metalColor;
            ctx.beginPath();
            ctx.rect(-a * 1.3 - a * 0.5, -a * 0.1, a * 0.8, a * 0.2);
            ctx.fill(); ctx.stroke();
            
            // Right turret
            ctx.fillStyle = mainColor;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.rect(a * 0.9, -a * 0.9, a * 0.7, a * 1.8);
            ctx.fill(); ctx.stroke();
            
            // Right cannon barrel
            ctx.fillStyle = metalColor;
            ctx.beginPath();
            ctx.rect(a * 1.3, -a * 0.1, a * 0.8, a * 0.2);
            ctx.fill(); ctx.stroke();
            
            // Aqua blue eyes/sensors with oceanic glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 8 * pulseFactor;
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(-a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Tank treads with aqua metallic detail
            ctx.fillStyle = '#1c4e4e'; // Dark teal treads
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 2;
            
            // Left tread
            ctx.beginPath();
            ctx.arc(-a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            
            // Tread segments
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time * 2;
                const x = -a * 1.3 + Math.cos(angle) * a * 0.4;
                const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                ctx.fillStyle = '#4682b4'; // Steel blue segments
                ctx.beginPath();
                ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                ctx.fill();
            }
            
            // Right tread
            ctx.fillStyle = '#1c4e4e'; // Dark teal treads
            ctx.beginPath();
            ctx.arc(a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            
            // Right tread segments
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time * 2;
                const x = a * 1.3 + Math.cos(angle) * a * 0.4;
                const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                ctx.fillStyle = '#4682b4'; // Steel blue segments
                ctx.beginPath();
                ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                ctx.fill();
            }
            
            // Command center/cockpit with aqua gradient
            const cockpitGradient = ctx.createLinearGradient(0, -a * 1.4, 0, -a * 1.0);
            cockpitGradient.addColorStop(0, accentColor);
            cockpitGradient.addColorStop(0.5, mainColor);
            cockpitGradient.addColorStop(1, '#0a2533'); // Deep ocean blue
            
            ctx.fillStyle = cockpitGradient;
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(-a * 0.4, -a * 1.4, a * 0.8, a * 0.5);
            ctx.fill(); ctx.stroke();
            
            // Antenna/communication array
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -a * 1.4);
            ctx.lineTo(-a * 0.2, -a * 1.8);
            ctx.moveTo(0, -a * 1.4);
            ctx.lineTo(a * 0.2, -a * 1.8);
            ctx.stroke();
            
            // Aqua warning lights
            ctx.fillStyle = time % 1 < 0.5 ? glowColor : '#004d4d';
            ctx.beginPath();
            ctx.arc(-a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
            ctx.fill();
            
            // Aqua energy exhaust vents
            ctx.fillStyle = '#00bfff'; // Deep sky blue exhaust
            ctx.shadowColor = '#00bfff';
            ctx.shadowBlur = 4;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.rect(-a * 0.1 + i * a * 0.1, a * 0.4, a * 0.05, a * 0.2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            break;
        case "shadow_champion": {
            const time = performance.now() / 1000;
            const pulse = 0.8 + 0.2 * Math.sin(time * 5 + c * 3);
            const swirl = c * 6;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.25 * pulse;
            ctx.fillStyle = '#8f9bff';
            ctx.beginPath();
            ctx.arc(0, 0, a * 1.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;

            const bodyGradient = ctx.createLinearGradient(0, -a * 1.2, 0, a * 1.1);
            bodyGradient.addColorStop(0, '#eef1ff');
            bodyGradient.addColorStop(0.55, '#cbd4ff');
            bodyGradient.addColorStop(1, '#7a80d4');
            ctx.fillStyle = bodyGradient;
            ctx.strokeStyle = '#4f55b7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -a * 1.05);
            ctx.quadraticCurveTo(a * 0.95, -a * 0.05, a * 0.5, a * 0.95);
            ctx.lineTo(-a * 0.5, a * 0.95);
            ctx.quadraticCurveTo(-a * 0.95, -a * 0.05, 0, -a * 1.05);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#191a33';
            ctx.beginPath();
            ctx.ellipse(0, -a * 0.25, a * 0.52, a * 0.34, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#7b86ff';
            ctx.beginPath();
            ctx.ellipse(0, -a * 0.22, a * 0.45, a * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.save();
            ctx.rotate(swirl);
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(0, a * 0.2);
                ctx.lineTo(0, a * 1.3);
                ctx.stroke();
                ctx.rotate(Math.PI / 2);
            }
            ctx.restore();

            ctx.fillStyle = 'rgba(139, 149, 255, 0.45)';
            ctx.beginPath();
            ctx.arc(0, a * 0.35, a * 0.42, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
            break;
        }
        case "void_champion": {
            const time = performance.now() / 1000;
            const shimmer = 0.55 + 0.45 * Math.sin(time * 6 + c * 3);
            const wingPulse = 0.8 + 0.2 * Math.sin(time * 5 + c * 2);
            
            // Get color scheme for this specific enemy
            const colors = getVoidChampionColorScheme(e);

            ctx.save();
            ctx.shadowColor = colors.shadowColor;
            ctx.shadowBlur = 8 * shimmer;

            // Outer aura to hint at teleport energy
            ctx.globalAlpha = 0.28 * shimmer;
            ctx.fillStyle = colors.auraColor;
            ctx.beginPath();
            ctx.arc(0, 0, a * 1.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Player-like hull with evil tint
            const hullGradient = ctx.createLinearGradient(0, -a * 1.3, 0, a * 1.1);
            hullGradient.addColorStop(0, colors.hullGradient[0]);
            hullGradient.addColorStop(0.45, colors.hullGradient[1]);
            hullGradient.addColorStop(1, colors.hullGradient[2]);
            ctx.fillStyle = hullGradient;
            ctx.strokeStyle = colors.strokeColor;
            ctx.lineWidth = 1.8;
            ctx.beginPath();
            ctx.moveTo(0, -a * 1.15);
            ctx.lineTo(a * 0.78, a * 0.35);
            ctx.lineTo(0, a * 1.1);
            ctx.lineTo(-a * 0.78, a * 0.35);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Mirrored shoulder fins
            ctx.fillStyle = `rgba(${colors.finColor[0]}, ${colors.finColor[1]}, ${colors.finColor[2]}, ${0.4 + 0.4 * shimmer})`;
            ctx.beginPath();
            ctx.moveTo(-a * 1.05, -a * 0.05);
            ctx.quadraticCurveTo(-a * 1.4, a * 0.35 * wingPulse, -a * 0.55, a * 0.55);
            ctx.lineTo(-a * 0.3, a * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(a * 1.05, -a * 0.05);
            ctx.quadraticCurveTo(a * 1.4, a * 0.35 * wingPulse, a * 0.55, a * 0.55);
            ctx.lineTo(a * 0.3, a * 0.1);
            ctx.closePath();
            ctx.fill();

            // Face visor resembling the player silhouette
            const visorGradient = ctx.createLinearGradient(0, -a * 0.8, 0, -a * 0.2);
            visorGradient.addColorStop(0, colors.visorGradient[0]);
            visorGradient.addColorStop(1, colors.visorGradient[1]);
            ctx.fillStyle = visorGradient;
            ctx.beginPath();
            ctx.moveTo(-a * 0.4, -a * 0.5);
            ctx.quadraticCurveTo(0, -a * 0.9, a * 0.4, -a * 0.5);
            ctx.quadraticCurveTo(0, -a * 0.25, -a * 0.4, -a * 0.5);
            ctx.fill();

            // Eyes for villain vibe
            ctx.fillStyle = colors.eyeColor;
            ctx.beginPath();
            ctx.ellipse(-a * 0.18, -a * 0.55, a * 0.11, a * 0.08, -0.3, 0, Math.PI * 2);
            ctx.ellipse(a * 0.18, -a * 0.55, a * 0.11, a * 0.08, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Chest core
            ctx.shadowBlur = 12 * shimmer;
            ctx.shadowColor = colors.coreGlow;
            ctx.fillStyle = colors.coreColor;
            ctx.beginPath();
            ctx.arc(0, a * 0.15, a * (0.32 + 0.08 * shimmer), 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Trail thruster
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = colors.thrusterColor;
            ctx.beginPath();
            ctx.moveTo(-a * 0.28, a * 1.05);
            ctx.lineTo(0, a * (1.45 + 0.2 * shimmer));
            ctx.lineTo(a * 0.28, a * 1.05);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.restore();
            break;
        }
        case "void_champion_orb": {
            const time = performance.now() / 1000;
            const flicker = 0.6 + 0.4 * Math.sin(time * 10 + c * 8);
            const radius = a * (0.85 + 0.15 * flicker);

            ctx.fillStyle = `rgba(255, 122, 229, ${0.35 + 0.4 * flicker})`;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 1.6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff7deb';
            ctx.strokeStyle = '#ffe0f8';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(-radius * 0.6, -radius * 0.2);
            ctx.lineTo(radius * 0.9, 0);
            ctx.lineTo(-radius * 0.6, radius * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(radius * 0.25, 0, radius * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff4fb5';
            ctx.beginPath();
            ctx.arc(radius * 0.25, 0, radius * 0.18, 0, Math.PI * 2);
            ctx.fill();

            // trailing spark
            ctx.strokeStyle = `rgba(255, 125, 235, ${0.4 + 0.3 * flicker})`;
            ctx.lineWidth = 1.8;
            ctx.beginPath();
            ctx.moveTo(-radius * 1.2, 0);
            ctx.lineTo(-radius * 2, 0);
            ctx.stroke();
            break;
        }
        case "angler": {
            const scale = a / 20;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle = n + "99"; ctx.strokeStyle = n; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-20,0);
            ctx.quadraticCurveTo(0,-18,24,0);
            ctx.quadraticCurveTo(0,16,-20,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-6,5);
            ctx.quadraticCurveTo(2,10,10,4);
            ctx.stroke();
            ctx.beginPath(); ctx.moveTo(8,-6);
            ctx.quadraticCurveTo(20,-24,32,-28); ctx.stroke();
            ctx.shadowColor="#00FFD5"; ctx.shadowBlur=12;
            ctx.beginPath(); ctx.arc(32,-28,4,0,Math.PI*2); ctx.fillStyle="#00FFD5"; ctx.fill();
            ctx.restore();
            break;
        }
        case "manta": {
            const scale = a / 36;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle= n + "cc"; ctx.strokeStyle=n; ctx.lineWidth=2;

            ctx.beginPath();
            ctx.moveTo(-36,0);
            ctx.quadraticCurveTo(-8,-18,0,-8);
            ctx.quadraticCurveTo(8,-18,36,0);
            ctx.quadraticCurveTo(8,14,0,8);
            ctx.quadraticCurveTo(-8,14,-36,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0,8);
            ctx.quadraticCurveTo(4,22,0,30);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
            ctx.restore();
            break;
        }
    }
    if (e.stunTimer && e.stunTimer > 0) {
        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + 0.3 * Math.sin(performance.now() / 100)})`;
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('STUN', 0, -a - 12);
    }
    if (e.vulnerabilityPulseStrength && e.vulnerabilityPulseColor) {
        const pulse = (Math.sin(performance.now() / 120) + 1) * 0.5;
        ctx.save();
        ctx.globalAlpha = Math.min(0.9, e.vulnerabilityPulseStrength);
        ctx.strokeStyle = e.vulnerabilityPulseColor;
        ctx.lineWidth = 2.5 + pulse * 2;
        ctx.beginPath();
        ctx.arc(0, 0, a * (1.05 + 0.2 * pulse), 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
    if (e.railgunArmorTimer > 0) {
        ctx.save();
        ctx.strokeStyle = `rgba(215,240,255,${Math.min(0.8, e.railgunArmorTimer / 2)})`;
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(-a * 0.6, -a * 0.3);
        ctx.lineTo(0, 0);
        ctx.lineTo(a * 0.5, -a * 0.2);
        ctx.moveTo(0, 0);
        ctx.lineTo(-a * 0.2, a * 0.5);
        ctx.stroke();
        ctx.restore();
    }
    if (e.phaseLockTimer > 0) {
        ctx.save();
        ctx.globalAlpha = 0.4 + 0.2 * Math.sin(performance.now() / 60);
        ctx.strokeStyle = '#9e7cff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, a * 1.2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-a * 1.2, 0);
        ctx.lineTo(a * 1.2, 0);
        ctx.moveTo(0, -a * 1.2);
        ctx.lineTo(0, a * 1.2);
        ctx.stroke();
        ctx.restore();
    }
    if (e.stormShockTimer > 0) {
        ctx.save();
        ctx.globalAlpha = Math.min(0.8, 0.4 + e.stormShockTimer * 0.3);
        ctx.strokeStyle = '#66d6ff';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2 + performance.now() / 250;
            ctx.beginPath();
            ctx.moveTo(Math.cos(angle) * a * 0.4, Math.sin(angle) * a * 0.4);
            ctx.lineTo(Math.cos(angle) * a * 1.3, Math.sin(angle) * a * 1.3);
            ctx.stroke();
        }
        ctx.restore();
    }
    if (e.demolitionPulseWarmup > 0) {
        ctx.save();
        ctx.globalAlpha = Math.min(0.6, e.demolitionPulseWarmup * 1.2);
        const grad = ctx.createRadialGradient(0, 0, a * 0.2, 0, 0, a * 1.4);
        grad.addColorStop(0, 'rgba(255, 170, 90, 0.7)');
        grad.addColorStop(1, 'rgba(255, 90, 0, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, a * (1 + (1 - e.demolitionPulseWarmup) * 0.4), 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    ctx.restore()
    }
    function createEffect(type,x,y, radius, options = {}){
        const opts = options || {};
        let effect={isActive:!0,life:1,maxLife:1,x,y,radius,opts};
        switch(type){
            case "heartbeatPulse":
                effect.maxLife = 0.6;
                effect.life = effect.maxLife;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const alpha = Math.sin((this.life / this.maxLife) * Math.PI) * 0.4;
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "beefCharge":
                effect.maxLife = opts.duration ?? 0.38;
                effect.origin = x;
                effect.target = y;
                effect.opts = opts;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const progress = 1 - this.life;
                    const eased = 1 - Math.pow(1 - progress, 2.2);
                    const currentX = this.origin.x + (this.target.x - this.origin.x) * eased;
                    const currentY = this.origin.y + (this.target.y - this.origin.y) * eased;
                    const subclass = this.opts.subclass;
                    const chain = this.opts.segmentLabel === 'chain';
                    const colorMain = subclass === 'juggernaut' ? '255, 210, 120' : '255, 120, 120';
                    const colorEdge = subclass === 'juggernaut' ? '255, 180, 70' : '255, 80, 80';

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    if (progress > 0.45) {
                        const shockwaveProgress = (progress - 0.45) / 0.55;
                        const decay = 1 - shockwaveProgress;
                        ctx.strokeStyle = `rgba(${colorEdge}, ${0.55 * decay})`;
                        ctx.lineWidth = 6 * decay;
                        ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, (this.opts.rangeOverride ?? 85) * shockwaveProgress, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    ctx.strokeStyle = `rgba(${colorMain}, ${0.85 * this.life})`;
                    ctx.lineWidth = (chain ? 10 : 13) * this.life;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.origin.x, this.origin.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();

                    ctx.globalAlpha = 0.6 * this.life;
                    ctx.lineWidth = 2.5 * (chain ? 1.2 : 1);
                    ctx.strokeStyle = `rgba(${colorEdge}, ${0.9 * this.life})`;
                    ctx.beginPath();
                    ctx.moveTo(this.origin.x, this.origin.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();

                    ctx.restore();
                };
                break;
            case "marauderImpact":
                effect.maxLife = 0.48;
                effect.life = effect.maxLife;
                effect.radius = radius || 90;
                effect.opts = opts;
                effect.shards = Array.from({ length: opts.subclass === 'juggernaut' ? 22 : 16 }, () => ({
                    angle: Math.random() * Math.PI * 2,
                    speed: 140 + Math.random() * 160,
                    width: 5 + Math.random() * 3.5
                }));
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const t = 1 - (this.life / this.maxLife);
                    const subclass = this.opts.subclass;
                    const primary = subclass === 'juggernaut' ? '255, 205, 120' : '255, 120, 120';
                    const secondary = subclass === 'juggernaut' ? '255, 175, 60' : '255, 90, 70';

                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalCompositeOperation = 'lighter';

                    const coreRadius = this.radius * (0.45 + 0.25 * Math.sin(performance.now() / 140));
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * (0.8 + t * 0.4));
                    gradient.addColorStop(0, `rgba(${primary}, ${0.65 * this.life})`);
                    gradient.addColorStop(0.55, `rgba(${secondary}, ${0.45 * this.life})`);
                    gradient.addColorStop(1, 'rgba(255, 70, 20, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (0.8 + 0.35 * t), 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * this.life})`;
                    ctx.lineWidth = 6 * (1 - t) + 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, coreRadius * (0.9 + t * 0.6), 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.9 * this.life;
                    this.shards.forEach((shard, index) => {
                        const length = this.radius * (0.25 + t * 1.1);
                        const decay = Math.pow(1 - t, 0.5);
                        const sx = Math.cos(shard.angle) * length * decay;
                        const sy = Math.sin(shard.angle) * length * decay;
                        ctx.lineWidth = Math.max(1.2, shard.width * this.life * 0.75);
                        ctx.strokeStyle = subclass === 'juggernaut' ? '#ffe7a0' : '#ffc1b1';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(sx, sy);
                        ctx.stroke();
                    });

                    ctx.restore();
                };
                break;
            case "spawnTeleport":
                effect.maxLife = opts.duration ?? 0.85;
                effect.life = effect.maxLife;
                effect.radius = radius || 18;
                effect.color = opts.color || '#9ad7ff';
                effect.clusterIndex = opts.clusterIndex ?? 0;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const t = 1 - (this.life / this.maxLife);
                    const eased = 1 - Math.pow(1 - t, 2.4);
                    const alpha = Math.max(0, 0.75 * (1 - eased));
                    const ringPulse = 0.8 + Math.sin(performance.now() / 140 + this.clusterIndex) * 0.15;
                    const baseRadius = this.radius * (0.85 + eased * 0.55);
                    ctx.save();
                    ctx.translate(this.x, this.y + (opts.fallback ? 6 : 0));
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = alpha;
                    const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, baseRadius * 1.15);
                    gradient.addColorStop(0, `${this.color}aa`);
                    gradient.addColorStop(1, `${this.color}00`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * 1.15, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * ringPulse, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.lineWidth = 1.2;
                    ctx.globalAlpha *= 0.8;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * (0.55 + Math.sin(performance.now() / 180 + this.clusterIndex) * 0.1), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "goldenOrbSpawn":
                effect.maxLife = 0.65;
                effect.life = effect.maxLife;
                effect.radius = radius || 70;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const progress = 1 - (this.life / this.maxLife);
                    const currentRadius = this.radius * (0.55 + progress * 0.7);
                    const time = performance.now() / 1000;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalCompositeOperation = 'lighter';
                    const glow = ctx.createRadialGradient(0, 0, currentRadius * 0.25, 0, 0, currentRadius);
                    glow.addColorStop(0, 'rgba(255, 245, 200, 0.75)');
                    glow.addColorStop(0.6, 'rgba(255, 210, 90, 0.55)');
                    glow.addColorStop(1, 'rgba(255, 110, 20, 0)');
                    ctx.globalAlpha = 0.85 - progress * 0.5;
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 220, 120, ${0.9 - progress})`;
                    ctx.lineWidth = 3 + 4 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(0, 0, currentRadius * (0.7 + Math.sin(time * 12) * 0.08), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "goldenOrbDetonation":
                effect.maxLife = 0.6;
                effect.life = effect.maxLife;
                effect.radius = radius || 150;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const t = 1 - (this.life / this.maxLife);
                    const ringRadius = this.radius * t;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalCompositeOperation = 'lighter';
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, ringRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 0.75)');
                    gradient.addColorStop(0.35, 'rgba(255, 210, 90, 0.55)');
                    gradient.addColorStop(0.8, 'rgba(255, 120, 0, 0.15)');
                    gradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 200, 80, ${1 - t})`;
                    ctx.lineWidth = 6 * (1 - t);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius * 0.72, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "hitSpark":
                effect.maxLife = 0.22;
                effect.life = effect.maxLife;
                effect.radius = radius || 14;
                effect.sparks = Array.from({ length: opts.crit ? 8 : 5 }, (_, i) => {
                    const spread = (Math.random() - 0.5) * 0.9;
                    const angle = (opts.angle ?? 0) + spread;
                    const power = (opts.strength ?? 120) * (0.45 + Math.random() * 0.35);
                    return {
                        angle,
                        speed: power * 0.015,
                        length: effect.radius * (opts.crit ? 1.6 : 1.2) * (0.9 + Math.random() * 0.3),
                        offset: (i / Math.max(1, (opts.crit ? 8 : 5))) * 0.35
                    };
                });
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const t = 1 - (this.life / this.maxLife);
                    const fade = 1 - t;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.75 * fade;
                    ctx.strokeStyle = opts.crit ? '#ffd6ff' : '#ff9adb';
                    ctx.lineWidth = opts.crit ? 2.6 * fade : 1.8 * fade;
                    this.sparks.forEach(spark => {
                        const dist = spark.length * fade;
                        const dx = Math.cos(spark.angle) * dist;
                        const dy = Math.sin(spark.angle) * dist;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(spark.angle) * spark.offset * this.radius, Math.sin(spark.angle) * spark.offset * this.radius);
                        ctx.lineTo(dx, dy);
                        ctx.stroke();
                    });
                    ctx.restore();
                };
                break;
            case "rearGuardBlock":
                effect.maxLife = 0.5;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${this.life})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 5, 20 * (1.2 - this.life), Math.PI * 0.2, Math.PI * 0.8);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "gravityWell":
                effect.maxLife = 7;
                effect.life = 7;
                effect.radius = 0;
                effect.maxRadius = 150;
                effect.damagePulseT = 1;
                effect.totalDamageDealtToBoss = 0;
                effect.stars = [];
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * effect.maxRadius;
                    effect.stars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        r: Math.random() * 1.5,
                        initialDist: dist
                    });
                }
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) {
                        this.isActive = false;
                        screenFlash(1, 400, 'rgba(255, 255, 255, 0.5)');
                        return;
                    }
                    if (this.radius < this.maxRadius) {
                        this.radius += 200 * dt;
                    }

                    this.damagePulseT -= dt;
                    const damageThisFrame = this.damagePulseT <= 0;
                    if (damageThisFrame) {
                        this.damagePulseT = 1;
                    }
                    
                    const pullStrength = 300;
                    const damageRadiusSq = (this.maxRadius * 0.7)**2;

                    store.enemies.forEach(e => {
                        if (e.dead) {
                            return; 
                        }
                        const dx = this.x - e.x;
                        const dy = this.y - e.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < this.radius**2) {
                            const dist = Math.sqrt(distSq);
                            if (dist > 10) {
                                const resistance = (e.type === 'mech' || e.type === 'hunter') ? 0.7 : 1.0;
                                e.x += (dx / dist) * pullStrength * resistance * dt;
                                e.y += (dy / dist) * pullStrength * resistance * dt;
                            }
                            
                            if (damageThisFrame && distSq < damageRadiusSq) {
                                const damage = e.hpMax * (0.25 * store.player.dmgMult);
                                e.hp -= damage;
                                store.world.totalDamage += damage;
                                
                                // Apply vampirism healing for blink damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = damage * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }
                            }
                        }
                    });
                     if (store.boss) {
                         const b = store.boss;
                          const dx = this.x - b.x;
                          const dy = this.y - b.y;
                          const distSq = dx*dx + dy*dy;
                          if(distSq < this.radius**2) {
                               const dist = Math.sqrt(distSq);
                               if (dist > 50) {
                                   b.x += (dx/dist) * pullStrength * 0.5 * dt;
                                   b.y += (dy/dist) * pullStrength * 0.5 * dt;
                               }
                               if (damageThisFrame && distSq < damageRadiusSq) {
                                    const damageToDeal = b.hpMax * (0.10 * store.player.dmgMult);
                                    const cap = b.hpMax * 0.5;
                                    let actualDamage = damageToDeal;
                                    if (this.totalDamageDealtToBoss + actualDamage > cap) {
                                        actualDamage = cap - this.totalDamageDealtToBoss;
                                    }
                                    if (actualDamage > 0) {
                                        b.hp -= actualDamage;
                                        this.totalDamageDealtToBoss += actualDamage;
                                        store.world.totalDamage += actualDamage;
                                        
                                        // Apply vampirism healing for blink damage on boss
                                        if (store.player.vampirism > 0) {
                                            let healAmount = actualDamage * store.player.vampirism;
                                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                        }
                                    }
                               }
                           }
                      }
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const time = performance.now();
                    const lifeRatio = this.life / this.maxLife;

                    ctx.fillStyle = 'white';
                    this.stars.forEach(star => {
                        const pullFactor = 1 - lifeRatio;
                        const currentDist = star.initialDist * (1 - pullFactor * 0.95);
                        const angle = Math.atan2(star.y, star.x) + pullFactor * 3;
                        const sx = Math.cos(angle) * currentDist;
                        const sy = Math.sin(angle) * currentDist;
                        
                        if (currentDist < this.radius) {
                            ctx.globalAlpha = lifeRatio * (currentDist / this.radius);
                            ctx.beginPath();
                            ctx.arc(sx, sy, star.r, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                    ctx.globalAlpha = 1;

                    for (let i = 0; i < 5; i++) {
                        const rotation = (time / (2000 + i * 200)) % (2 * Math.PI);
                        ctx.strokeStyle = `rgba(0, 0, 5, ${0.4 * lifeRatio})`;
                        ctx.lineWidth = (2 + i) * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, (this.radius / 5) * (i + 1), rotation, rotation + Math.PI * 1.5);
                        ctx.stroke();
                    }
                    
                    const corePulse = 3 + Math.sin(time / 100) * 2;
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse * 2);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    coreGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.7)');
                    coreGrad.addColorStop(1, 'rgba(150, 150, 255, 0)');
                    ctx.fillStyle = coreGrad;
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, corePulse * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case"grenadeExplosion":
                effect.maxLife=.5;
                effect.radius=radius || 60;
                effect.step=function(dt){this.life-=2*dt;this.life<=0&&(this.isActive=!1)};
                effect.draw=function(){
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.radius*(1-this.life),0,2*Math.PI);
                    ctx.fillStyle=`rgba(255, 153, 51, ${.8*this.life})`;
                    ctx.fill()
                };
                break;
            case"shieldBreak":effect.maxLife=.6;effect.step=function(dt){this.life-=1.5*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.strokeStyle=`rgba(154, 102, 255, ${this.life})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(this.x,this.y,24*(1.5-this.life),0,2*Math.PI);ctx.stroke()};break;
            case "nanoHeal":
                effect.maxLife = 0.7;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const p = 1 - this.life;
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                    ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "jugFearIgnite":
                effect.maxLife = 0.6;
                effect.radius = radius || 40;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const progress = 1 - this.life;
                    ctx.globalAlpha = 0.5 + 0.4 * Math.sin(performance.now() / 60);
                    ctx.fillStyle = 'rgba(255,80,40,0.6)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (0.7 + progress * 0.6), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = 'rgba(255,200,120,0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (0.4 + progress * 0.3), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "jugFearEmber":
                effect.maxLife = 0.4;
                effect.radius = radius || 20;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 40 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = 'rgba(255,150,80,0.8)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (0.4 + 0.6 * this.life), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "marauderLaunchTrail":
                const trailCfg = radius || {};
                effect.maxLife = trailCfg.duration || 0.5;
                effect.life = effect.maxLife;
                effect.followEnemy = trailCfg.enemy || null;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.followEnemy) {
                        this.x = this.followEnemy.x;
                        this.y = this.followEnemy.y;
                    }
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                    ctx.strokeStyle = 'rgba(170, 209, 255, 0.7)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30 * (1 + (1 - this.life / this.maxLife)), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "maraImpactShockwave":
                effect.maxLife = 0.4;
                effect.radius = radius || 45;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(150, 210, 255, 0.9)';
                    ctx.lineWidth = 6 - (5 * (1 - this.life));
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "armorCrackFlash":
                effect.maxLife = 0.5;
                effect.level = radius || 1;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(210, 240, 255, 0.8)';
                    ctx.lineWidth = 1.2;
                    for (let i = 0; i < 3 + this.level; i++) {
                        const angle = (i / (3 + this.level)) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                        ctx.stroke();
                    }
                    ctx.restore();
                };
                break;
            case "demolitionPulseCharge":
                effect.maxLife = 0.7;
                effect.radius = radius || 40;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(255, 170, 90, 0.8)';
                    ctx.lineWidth = 2 + (1 - this.life) * 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "voidLockChains":
                effect.maxLife = 0.6;
                effect.radius = radius || 45;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const rotation = performance.now() / 200;
                    ctx.globalAlpha = 0.5 + 0.3 * this.life;
                    ctx.strokeStyle = 'rgba(140, 120, 255, 0.9)';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotation + (i / 4) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                        ctx.lineTo(Math.cos(angle + Math.PI) * this.radius * 0.4, Math.sin(angle + Math.PI) * this.radius * 0.4);
                        ctx.stroke();
                    }
                    ctx.restore();
                };
                break;
            case "stormDischarge":
                effect.maxLife = 0.35;
                effect.radius = radius || 60;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life * 0.8;
                    ctx.strokeStyle = 'rgba(110, 210, 255, 1)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1.1 - this.life * 0.4), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "stormArc":
                const arcTarget = radius || { x, y };
                effect.maxLife = 0.2;
                effect.target = arcTarget;
                effect.x = x;
                effect.y = y;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(120, 220, 255, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    const controlX = (this.x + this.target.x) / 2 + (Math.random() - 0.5) * 30;
                    const controlY = (this.y + this.target.y) / 2 + (Math.random() - 0.5) * 30;
                    ctx.quadraticCurveTo(controlX, controlY, this.target.x, this.target.y);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "delayedFlamePulse":
                effect.maxLife = 0.5;
                effect.radius = radius || 90;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.globalAlpha = this.life;
                    ctx.strokeStyle = 'rgba(255, 150, 60, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * (1 + (1 - this.life) * 0.3), 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "critText":
                effect.maxLife = 0.6;
                effect.text = "CRITICAL!";
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 30 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                };
                break;
            case "bossPhaseChange":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; this.radius += 600 * dt; };
                effect.draw = function() {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                    ctx.lineWidth = 1 + 4 * this.life;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                };
                break;
             case "screenFlash":
                effect.maxLife = y / 1000;
                effect.life = effect.maxLife;
                effect.color = radius;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.globalAlpha = this.life / this.maxLife;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "timeRippleExplosion":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.maxRadius = 80;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.radius = this.maxRadius * (1 - this.life);
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Create time ripple effect with concentric circles
                    for (let i = 0; i < 3; i++) {
                        const rippleRadius = this.radius * (0.3 + i * 0.3);
                        const alpha = this.life * (1 - i * 0.2);
                        
                        // Outer ripple ring
                        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                        ctx.lineWidth = 3 - i;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Inner glow
                        ctx.fillStyle = `rgba(150, 220, 255, ${alpha * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius * 0.8, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    // Central time distortion effect
                    const centerAlpha = this.life * 0.6;
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                    grad.addColorStop(0, `rgba(200, 240, 255, ${centerAlpha})`);
                    grad.addColorStop(0.7, `rgba(100, 200, 255, ${centerAlpha * 0.5})`);
                    grad.addColorStop(1, `rgba(50, 150, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case "lightningFlash":
                effect.maxLife = 0.15; // Very short flash duration
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Calculate flash intensity based on remaining life
                    const intensity = Math.sin(this.life * Math.PI); // Sine wave for smooth fade
                    const alpha = intensity * 0.8;
                    
                    // Outer blue glow
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                    grad.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 150, 255, ${alpha * 0.6})`);
                    grad.addColorStop(1, `rgba(30, 100, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Inner bright white core
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Electric sparks around the edge
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI + this.life * 10; // Rotate sparks
                        const sparkX = Math.cos(angle) * (20 + Math.random() * 10);
                        const sparkY = Math.sin(angle) * (20 + Math.random() * 10);
                        
                        ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.7})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(sparkX * 0.7, sparkY * 0.7);
                        ctx.lineTo(sparkX, sparkY);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                };
                break;
        }
        return effect
    }
    

    function explodeMine(mine) {
        playSound('explosion');
        const p = store.player;
        
        const numBullets = 18;
        for (let i = 0; i < numBullets; i++) {
            const angle = (i / numBullets) * 2 * Math.PI;
            const bulletSpeed = 300;
            spawnBullet({
                x: mine.x,
                y: mine.y,
                vx: Math.cos(angle) * bulletSpeed,
                vy: Math.sin(angle) * bulletSpeed,
                r: 3,
                col: '#ff9966',
                dmg: 20 * p.dmgMult,
                pierce: false,
                life: 0.28
            });
        }

        const numFlames = 15;
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * 120 * Math.PI / 180;
            const speed = 250 + Math.random() * 50;
            spawnBullet({
                x: mine.x,
                y: mine.y,
                vx: Math.sin(angle) * speed,
                vy: -Math.cos(angle) * speed,
                r: 3 + Math.random() * 2,
                col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`,
                dmg: 2 * p.dmgMult,
                life: 0.3,
                isFlame: true
            });
        }

        store.activeEffects.push(createEffect("grenadeExplosion", mine.x, mine.y, 55));
    }


    let shopItemOrder = [];
    function showShop() {
        pauseGame();
        const panel = q("shopPanel"),
            grid = q("shopGrid"),
            goldEl = q("shopgold");
        goldEl.textContent = store.world.gold;



        const currentItems = Object.keys(SHOP_UPGRADES).map(key => {
            const u = SHOP_UPGRADES[key];
            let currentLevel = store.player.upgradeLevels[key] || 0,
                cost = 0;
            if (key === 'vampirism') {
                cost = 12 + (store.player.vampirismLevel * 5);
                if (store.player.vampirismLevel >= u.max) cost = Infinity
            } else if (u.isPremium) {
                cost = u.cost
            } else {
                if (currentLevel >= u.maxLevel) {
                    cost = Infinity
                } else {
                    if (u.increment) {
                        cost = u.baseCost + (currentLevel * u.increment);
                    } else {
                        cost = Math.floor(u.baseCost * Math.pow(u.scale, currentLevel))
                    }
                }
            }
            return {
                key, ...u,
                cost
            }
        });
        const temporarilyDisabled = [];

        if (shopItemOrder.length === 0) {
            const itemsToSort = [...currentItems];
            itemsToSort.sort((a, b) => {
                const aIsDisabled = temporarilyDisabled.includes(a.key);
                const bIsDisabled = temporarilyDisabled.includes(b.key);
                if (aIsDisabled && !bIsDisabled) return 1;
                if (!aIsDisabled && bIsDisabled) return -1;
                return a.cost - b.cost;
            });
            shopItemOrder = itemsToSort.map(item => item.key);
        }

        const shopItems = shopItemOrder.map(key => currentItems.find(item => item.key === key));
        
        let content = "";
        for (const u of shopItems) {
            const key = u.key;
            let currentLevel = store.player.upgradeLevels[key] || 0,
                isDisabled = false,
                cost = u.cost,
                desc = typeof u.desc === 'function' ? u.desc(currentLevel) : u.desc,
                name = u.name;
            if (u.isPremium) {
                if (key === 'vampirism') {
                    if (store.player.vampirismLevel >= u.max) isDisabled = true
                } else if (key === 'repair') {
                    if (store.player.hp >= store.player.hpMax) {
                        isDisabled = true;
                        desc = "Health is already full."
                    }
                } else if (key === 'nano_save') {
                    if (store.player.nanoSaves >= u.max) {
                        isDisabled = true;
                        desc = "Max charges reached."
                    }
                } else if (u.isUnlock) {
                    if ( (key === 'gravity_well' && store.player.hasVoidBeam) ||
                         (key === 'lazarus_beam' && store.player.hasLazarusBeam) ||
                         (key === 'launcher' && store.player.hasLauncher) ||
                         (key === 'luck_boost' && store.player.luckBoost > 0) ||
                         (key === 'magnet_pull' && store.player.magnetRadius > 0) ||
                         (key === 'rear_guard' && store.player.hasRearGuard) ||
                         (key === 'iceman' && store.player.hasIceman)) {
                        isDisabled = true;
                        desc = "Already Unlocked"
                    }
                } else {
                    if (store.player.grenades >= u.max) {
                        isDisabled = true;
                        desc = "At maximum capacity"
                    }
                }
            } else {
                if (currentLevel >= u.maxLevel) {
                    isDisabled = true;
                    desc = "Max Level Reached"
                }
            }
            if (store.world.gold < cost) isDisabled = true;
            if (temporarilyDisabled.includes(key)) {
                isDisabled = true;
                desc = "Under maintenance.";
            }
            const costText = isFinite(cost) ? cost : '---';
            content += `<div class="skill-card shop-item ${isDisabled?'disabled':''} shop-item-${u.category}" data-key="${key}"><div class="skill-icon">${u.icon}</div><div><div class="skill-title">${name}</div><div class="skill-desc">${desc}</div></div><div style="color:var(--accent);margin-top:4px;font-size:11px;">Cost: ${costText}</div></div>`
        }
        grid.innerHTML = content;
        grid.querySelectorAll(".shop-item").forEach(item => {
            item.addEventListener("click", () => {
                if (item.classList.contains('disabled')) return;
                const key = item.dataset.key;
                const upgrade = SHOP_UPGRADES[key];
                let purchaseSuccessful = false;
                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const cost = 12 + (store.player.vampirismLevel * 5);
                        if (store.world.gold >= cost) {
                            purchaseSuccessful = upgrade.apply()
                        }
                    } else {
                        const cost = upgrade.cost;
                        if (store.world.gold >= cost) {
                            store.world.gold -= cost;
                            purchaseSuccessful = upgrade.apply()
                        }
                    }
                } else {
                    const currentLevel = store.player.upgradeLevels[key] || 0;
                    let cost;
                    if (upgrade.increment) {
                        cost = upgrade.baseCost + (currentLevel * upgrade.increment);
                    } else {
                        cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                    }

                    if (store.world.gold >= cost) {
                        store.world.gold -= cost;
                        upgrade.effect(currentLevel);
                        store.player.upgradeLevels[key] = (store.player.upgradeLevels[key] || 0) + 1;
                        purchaseSuccessful = true;
                    }
                }
                if (purchaseSuccessful) {
                    // Defer shop update to next frame to avoid blocking interaction response
                    requestAnimationFrame(() => showShop());
                }
            })
        });

        panel.classList.remove("hide")
    }

    function showMechForgeMenu() {
        pauseGame();
        const panel = q("mechForgeMenuPanel");
        
        // Set up mobile controls toggle
        const toggle = q('mobileControlsToggleMenu');
        if (toggle) {
            toggle.checked = document.body.classList.contains('mobile-controls-active');
            toggle.addEventListener('change', () => {
                if (toggle.checked) {
                    document.body.classList.add('mobile-controls-active');
                    try { localStorage.setItem('mobileControlsEnabled', 'true'); } catch(e) {}
                } else {
                    document.body.classList.remove('mobile-controls-active');
                    try { localStorage.setItem('mobileControlsEnabled', 'false'); } catch(e) {}
                }
            });
        }
        
        // Enable/disable skill tree button based on subclass
        const skillTreeBtn = q('openSkillTreeReadonly');
        if (skillTreeBtn) {
            const hasSubclass = store.player && store.player.subclass;
            skillTreeBtn.disabled = !hasSubclass;
            if (!hasSubclass) {
                skillTreeBtn.querySelector('.forge-menu-desc').textContent = 'Select a specialization first';
            } else {
                skillTreeBtn.querySelector('.forge-menu-desc').textContent = 'Review specialization progress';
            }
        }
        
        panel.classList.remove("hide");
    }
    
    function showCharacterSheet() {
        pauseGame();
        const panel = q("characterSheetPanel");
        const body = q("characterSheetBody");
        
        if (body) {
            renderCharacterSheet(body);
        }
        
        panel.classList.remove("hide");
    }
    
    function showSkillTreeReadonly() {
        if (!store.player || !store.player.subclass) {
            announce('Select a specialization first!');
            return;
        }
        
        // Use the existing skill tree modal system but mark it as read-only from forge
        showSkillTreeModal(true);
        
        // Update the title to indicate it's read-only after the modal opens
        setTimeout(() => {
            const panel = q("subclassPanel");
            if (panel) {
                const title = panel.querySelector('h2');
                if (title) {
                    title.textContent = `â­ ${store.player.subclass.toUpperCase()} SKILL TREE (VIEW-ONLY)`;
                }
                // Disable all skill buttons to make it truly read-only
                const skillButtons = panel.querySelectorAll('.skill-icon-button, .skill-card');
                skillButtons.forEach(btn => {
                    btn.style.pointerEvents = 'none';
                    btn.style.opacity = '0.8';
                });
            }
        }, 50);
    }

    function renderCharacterSheet(container) {
        if (!container) {
            return;
        }

        const player = store.player || {};
        const world = store.world || {};

        const toNumber = (value, fallback = 0) => {
            const num = Number(value);
            return Number.isFinite(num) ? num : fallback;
        };

        const pad = (value, digits = 2) => {
            const num = toNumber(value);
            const negative = num < 0;
            const abs = Math.abs(Math.floor(num));
            const padded = abs.toString().padStart(digits, '0');
            return negative ? `-${padded}` : padded;
        };

        const fmt = (value, digits = 2) => {
            const num = toNumber(value);
            return num.toFixed(digits);
        };

        const pct = (value, digits = 1) => {
            const num = toNumber(value);
            return (num * 100).toFixed(digits) + '%';
        };

        const escapeHtml = (value) => {
            if (value === undefined || value === null) return '';
            return String(value)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        };

        const getSkillTreeContext = () => {
            if (typeof getActiveSubclassAndTree !== 'function') {
                return { subclass: player.subclass || null, treeData: null };
            }
            const { subclass, treeData } = getActiveSubclassAndTree();
            return { subclass, treeData };
        };

        const { subclass, treeData } = getSkillTreeContext();
        const genomeName = player.pilotGenome ? player.pilotGenome.toUpperCase() : 'PENDING';
        
        // Only show subclass if actually selected, not just from tree data
        const actualSubclass = player.subclass;
        let subclassDisplay;
        if (actualSubclass && treeData && treeData.title) {
            subclassDisplay = treeData.title.replace(' MASTERY TREE', '').toUpperCase();
        } else if (actualSubclass) {
            subclassDisplay = actualSubclass.toUpperCase();
        } else {
            subclassDisplay = 'PENDING SELECTION';
        }

        const summaryLines = [
            `GENOME ROUTE â–¸ ${genomeName} âžœ ${subclassDisplay}`,
            `MISSION STATUS â–¸ W${pad(world.wave || 1)} | LV ${pad(world.level || 1)} | BOSSES ${pad(world.bosses || 0)} | KILLS ${pad(world.kills || 0, 3)}`,
            `FORGE LEDGER â–¸ GOLD ${pad(world.gold || 0, 4)} | XP ${pad(world.xp || 0, 4)} | SCORE ${pad(world.score || 0, 6)}`,
            `PROGRESSION â–¸ TOTAL ${pad(player.totalProgressionPoints || 0)} | SPENT ${pad(player.skillPointsSpent || 0)} | UNSPENT ${pad(player.unspentProgressionPoints || 0)}`
        ];

        // Only show skill matrix if subclass is actually selected
        const skillMatrixData = actualSubclass ? computeSkillMatrix(treeData, player, subclassDisplay) : null;
        if (skillMatrixData && skillMatrixData.laneSummaries.length) {
            skillMatrixData.laneSummaries.forEach(line => summaryLines.push(line));
        }

        const sections = [];
        sections.push(renderSummarySection(summaryLines));

        const coreRows = [
            {
                key: 'Hull Integrity',
                value: `${pad(toNumber(player.hp || 0), 3)}/${pad(toNumber(player.hpMax || player.hp || 0), 3)}`,
                detail: player.damageReduction ? `Damage Reduction ${pct(player.damageReduction)}` : null
            },
            {
                key: 'Shield Matrix',
                value: `${pad(toNumber(player.shield || 0), 3)}/${pad(toNumber(player.shieldMax || 0), 3)}`,
                detail: player.shieldRechargeDelayMax ? `Recharge Delay ${fmt(player.shieldRechargeDelayMax, 2)}s` : null
            },
            {
                key: 'Velocity',
                value: `${pad(toNumber(player.speed || 0), 3)}`,
                detail: `Magnet ${pad(toNumber(player.magnetRadius || 0), 3)} â€¢ Luck ${pct(player.luckBoost || 0)}`
            },
            {
                key: 'Safety Net',
                value: `Nano ${pad(player.nanoSaves || 0)} â€¢ Vamp ${pct(player.vampirism || 0)}`,
                detail: `Grenades ${pad(player.grenades || 0)} â€¢ Collar ${pad(world.collarStacks || 0)}`
            }
        ];
        sections.push(renderGridSection('Core Systems', coreRows));

        const fireRate = toNumber(player.fireRate || 0);
        const shotsPerSecond = fireRate > 0 ? 1 / fireRate : 0;
        const offenseRows = [
            {
                key: 'Damage Suite',
                value: `x${fmt(player.dmgMult || 1, 2)}`,
                detail: `Crit ${pct(player.critChance || 0)} | Crit Dmg x${fmt(player.critDamage || 1.5, 2)}`
            },
            {
                key: 'Volley Matrix',
                value: `${fmt(shotsPerSecond, 1)} /s`,
                detail: `Projectiles ${pad(player.multishot || 1)} â€¢ Pierce ${pad(player.piercing || player.missilePierce || 0)}`
            },
            {
                key: 'Arsenal',
                value: `Missiles ${pad(player.missileVolley || 0)} â€¢ Grenades ${pad(player.grenades || 0)}`,
                detail: `Fragment Launcher ${player.hasLauncher ? 'ONLINE' : 'LOCKED'} â€¢ Lazarus ${player.hasLazarusBeam ? 'ONLINE' : 'LOCKED'}`
            },
            {
                key: 'Special Ammo',
                value: `Storm ${player.hasStormcaller ? 'ONLINE' : 'LOCKED'} â€¢ Phase ${player.hasPhasestriker ? 'ONLINE' : 'LOCKED'}`,
                detail: player.hasBlink ? `Blink ${player.autoBlinkEnabled ? 'AUTO' : 'MANUAL'}` : 'Blink locked'
            }
        ];
        sections.push(renderGridSection('Offensive Matrix', offenseRows));

        const economyRows = [
            {
                key: 'Resources',
                value: `Gold ${pad(world.gold || 0, 4)} â€¢ XP ${pad(world.xp || 0, 4)}`,
                detail: `Score ${pad(world.score || 0, 6)} â€¢ Threat ${fmt(world.lastThreatScale || 1, 2)}`
            },
            {
                key: 'Boss Progress',
                value: `Bosses ${pad(world.bosses || 0)} â€¢ Wave ${pad(world.wave || 1)}`,
                detail: `Kills ${pad(world.kills || 0, 4)} â€¢ XP Mult ${fmt(world.xpMultiplier || 1, 2)}`
            }
        ];
        sections.push(renderGridSection('Economy & Progress', economyRows));

        const forgeUpgrades = buildForgeUpgradeList(player);
        sections.push(renderListSection('Forge Upgrades', forgeUpgrades, 'No forge upgrades purchased yet.'));        

        const systemList = buildSystemList(player);
        sections.push(renderListSection('Active Systems', systemList, 'No special systems online.'));

        if (skillMatrixData) {
            sections.push(renderSkillMatrixSection(skillMatrixData));
            if (skillMatrixData.powerSummaries.length) {
                sections.push(renderListSection('Power Summary', skillMatrixData.powerSummaries));
            }
        }

        const learnedSkillList = buildLearnedSkillList(player);
        if (learnedSkillList.length) {
            sections.push(renderListSection('Unlocked Skills', learnedSkillList));
        }

        const calibrationList = buildCalibrationList(player);
        if (calibrationList.length) {
            sections.push(renderListSection('Calibrations', calibrationList));
        }

        const championSection = renderChampionSection();
        if (championSection) {
            sections.push(championSection);
        }

        container.innerHTML = sections.join('');

        function renderSummarySection(lines) {
            if (!lines || !lines.length) return '';
            return `
                <div class="intel-section">
                    <div class="intel-title">Route Overview</div>
                    <div class="intel-summary">
                        ${lines.map(line => `<div class="intel-summary-line">${escapeHtml(line)}</div>`).join('')}
                    </div>
                </div>`;
        }

        function renderGridSection(title, rows, note) {
            if (!rows || !rows.length) return '';
            return `
                <div class="intel-section">
                    <div class="intel-title">${escapeHtml(title)}</div>
                    <div class="intel-grid">
                        ${rows.map(row => `
                            <div class="intel-cell">
                                <div class="intel-key">${escapeHtml(row.key)}</div>
                                <div class="intel-val">${escapeHtml(row.value)}</div>
                                ${row.detail ? `<div class="intel-detail">${escapeHtml(row.detail)}</div>` : ''}
                            </div>`).join('')}
                    </div>
                    ${note ? `<div class="intel-note">${escapeHtml(note)}</div>` : ''}
                </div>`;
        }

        function renderListSection(title, items, emptyText) {
            if (!items || !items.length) {
                if (!emptyText) return '';
                return `
                    <div class="intel-section">
                        <div class="intel-title">${escapeHtml(title)}</div>
                        <div class="intel-note">${escapeHtml(emptyText)}</div>
                    </div>`;
            }
            return `
                <div class="intel-section">
                    <div class="intel-title">${escapeHtml(title)}</div>
                    <ul class="intel-list">
                        ${items.map(item => `<li>${escapeHtml(item)}</li>`).join('')}
                    </ul>
                </div>`;
        }

        function buildForgeUpgradeList(p) {
            if (!p.upgradeLevels) return [];
            const entries = Object.entries(p.upgradeLevels).filter(([, lvl]) => lvl > 0);
            if (!entries.length) return [];
            entries.sort((a, b) => {
                const upA = SHOP_UPGRADES[a[0]];
                const upB = SHOP_UPGRADES[b[0]];
                const catA = upA && upA.category ? upA.category : '';
                const catB = upB && upB.category ? upB.category : '';
                if (catA !== catB) return catA.localeCompare(catB);
                const nameA = upA && upA.name ? upA.name : a[0];
                const nameB = upB && upB.name ? upB.name : b[0];
                return nameA.localeCompare(nameB);
            });
            return entries.map(([key, lvl]) => {
                const upg = SHOP_UPGRADES[key];
                const name = upg && upg.name ? upg.name.toUpperCase() : key.replace(/_/g, ' ').toUpperCase();
                const category = upg && upg.category ? upg.category.toUpperCase() : 'GENERAL';
                return `${name} â€¢ L${pad(lvl)} â€¢ ${category}`;
            });
        }

        function buildSystemList(p) {
            const systems = [];
            if (p.hasVoidBeam) systems.push('Gravity Well â–¸ Singularity ready');
            if (p.hasLazarusBeam) systems.push('Lazarus Beam â–¸ Dual smite online');
            if (p.hasLauncher) systems.push('Fragment Launcher â–¸ Payload linked');
            if (p.hasHounds) {
                const packSize = Array.isArray(store.hounds) ? store.hounds.filter(h => h && !h.dead).length : 2;
                systems.push(`Ghost Hounds â–¸ Pack ${pad(packSize)}`);
            }
            if (p.hasIceman) systems.push('The Iceman â–¸ Mirror support active');
            if (p.hasRearGuard) systems.push(`Rear Guard â–¸ Cooldown ${fmt(p.rearGuardCooldown || 6, 1)}s`);
            if (p.hasBlink) systems.push(`Blink â–¸ ${p.autoBlinkEnabled ? 'Auto-response' : 'Manual trigger'}`);
            if (p.hasVoidLaser || p.hasPhasestriker) systems.push('Void Laser â–¸ Target lock established');
            if (p.hasChainLightning || p.hasStormcaller) systems.push('Chain Lightning â–¸ Arc lattice primed');
            if (p.starCannonLevel) systems.push(`Star Cannon â–¸ MK${pad(p.starCannonLevel)}${p.starCannonIcemanSupport ? ' + Iceman sync' : ''}`);
            if (p.attackSpeedStacks) systems.push(`Hyper Drive â–¸ ${pad(p.attackSpeedStacks)} stacks`);
            return systems;
        }

        function computeSkillMatrix(treeData, p, subclassDisplay) {
            if (!treeData || !p.subclass) return null; // Don't show matrix without actual subclass selection
            const result = {
                rows: [],
                laneSummaries: [],
                laneNotes: [],
                powerSummaries: []
            };
            const skillTree = p.skillTree || {};

            const lanes = [];
            // Lane 1: Core progression path
            if (treeData.path && Array.isArray(treeData.path.nodes)) {
                const lane = {
                    index: 1,
                    name: treeData.path.name || 'Core Path',
                    nodes: []
                };
                treeData.path.nodes.forEach((node, idx) => {
                    const unlocked = !!skillTree[node.id];
                    const order = idx + 1;
                    result.rows.push({
                        tier: `T${order}`,
                        lane: 'Lane Î± â€“ Core Path',
                        name: node.name,
                        status: unlocked ? 'ONLINE' : 'LOCKED',
                        desc: node.desc,
                        active: unlocked
                    });
                    lane.nodes.push({
                        order,
                        name: node.name,
                        desc: node.desc,
                        unlocked,
                        statusSymbol: unlocked ? 'âœ”' : 'âœ–'
                    });
                    if (unlocked) {
                        result.powerSummaries.push(`${node.name} â€” ${node.desc}`);
                    }
                });
                lanes.push(lane);
            }

            // Lane 2: Signature â†’ Crossover â†’ Ultimate progression
            const succession = [];
            if (treeData.classAbility) {
                succession.push({ node: treeData.classAbility, kind: 'Signature' });
            }
            const crossDetails = typeof getCrossUnlockNode === 'function' ? getCrossUnlockNode(treeData) : null;
            if (crossDetails && crossDetails.node) {
                succession.push({ node: crossDetails.node, kind: 'Crossover', requirement: crossDetails.config && crossDetails.config.requiredInvestments });
            }
            if (treeData.ultimateAbility) {
                succession.push({ node: treeData.ultimateAbility, kind: 'Ultimate' });
            }
            
            if (succession.length) {
                const lane = {
                    index: 2,
                    name: `${subclassDisplay || 'SIGNATURE'} Abilities`,
                    nodes: []
                };
                succession.forEach((entry, idx) => {
                    const id = entry.node.id;
                    const unlocked = !!skillTree[id];
                    const laneLabel = `Lane Î² â€“ ${entry.kind}`;
                    result.rows.push({
                        tier: entry.kind.toUpperCase(),
                        lane: laneLabel,
                        name: entry.node.name,
                        status: unlocked ? 'ONLINE' : 'LOCKED',
                        desc: entry.node.desc,
                        active: unlocked
                    });
                    lane.nodes.push({
                        order: entry.kind, // Use ability type instead of number
                        name: entry.node.name,
                        desc: entry.node.desc,
                        unlocked,
                        statusSymbol: unlocked ? 'âœ”' : 'âœ–',
                        requirement: entry.requirement,
                        kind: entry.kind
                    });
                    if (unlocked) {
                        result.powerSummaries.push(`${entry.node.name} â€” ${entry.node.desc}`);
                    }
                });
                lanes.push(lane);
            }

            if (!result.rows.length) {
                return null;
            }

            lanes.forEach(lane => {
                if (lane.index === 1) {
                    // Core path uses numbered nodes
                    const nodeStatus = lane.nodes.map(node => `${node.statusSymbol}${node.order}`);
                    result.laneSummaries.push(`LANE ${lane.index} â–¸ ${lane.name.toUpperCase()} â†’ Nodes ${nodeStatus.join(' ')}`);
                } else {
                    // Ability path uses ability types
                    const nodeStatus = lane.nodes.map(node => `${node.statusSymbol}${node.kind.substring(0, 3)}`);
                    result.laneSummaries.push(`LANE ${lane.index} â–¸ ${lane.name.toUpperCase()} â†’ ${nodeStatus.join(' ')}`);
                }
                
                result.laneNotes.push(lane.nodes.map(node => {
                    const requirement = node.requirement ? ` (req ${node.requirement})` : '';
                    return `${node.kind || node.order}. ${node.name}${requirement} (${node.unlocked ? 'active' : 'locked'})`;
                }).join(' | '));
            });

            return result;
        }

        function renderSkillMatrixSection(data) {
            if (!data.rows.length) return '';
            return `
                <div class="intel-section">
                    <div class="intel-title">Skill Path Matrix</div>
                    <table class="intel-table">
                        <thead>
                            <tr>
                                <th>Tier</th>
                                <th>Lane</th>
                                <th>Node</th>
                                <th>Status</th>
                                <th>Effect</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.rows.map(row => `
                                <tr class="${row.active ? 'active' : 'inactive'}">
                                    <td>${escapeHtml(row.tier)}</td>
                                    <td>${escapeHtml(row.lane)}</td>
                                    <td>${escapeHtml(row.name)}</td>
                                    <td>${escapeHtml(row.status)}</td>
                                    <td>${escapeHtml(row.desc)}</td>
                                </tr>`).join('')}
                        </tbody>
                    </table>
                    ${data.laneNotes.length ? `
                        <div class="intel-subtitle">Lane Breakdown</div>
                        <div class="intel-summary">
                            ${data.laneNotes.map(note => `<div class="intel-summary-line">${escapeHtml(note)}</div>`).join('')}
                        </div>` : ''}
                </div>`;
        }

        function buildLearnedSkillList(p) {
            if (!Array.isArray(p.learnedSkills) || !p.learnedSkills.length) return [];
            const unique = Array.from(new Set(p.learnedSkills));
            return unique.map(id => {
                const meta = resolveSkillMeta(id);
                if (meta) {
                    return `${meta.name.toUpperCase()}`;
                }
                return id.replace(/_/g, ' ').toUpperCase();
            });
        }

        function buildCalibrationList(p) {
            const list = [];
            if (p.attackSpeedStacks) list.push(`Hyper Drive Stacks â–¸ ${pad(p.attackSpeedStacks)}`);
            if (p.voidCoreStacks) {
                list.push(`Void Core Resonance â–¸ ${pad(p.voidCoreStacks)} (Damage x${fmt(p.voidCoreDmgMult || 1, 2)} | Fire ${fmt(p.voidCoreFireRateMult || 1, 2)}x)`);
            }
            if (p.stormstrikerLevel) list.push(`Stormcaller Intensity â–¸ L${fmt(p.stormstrikerLevel, 1)}`);
            if (p.phasestRikerLevel) list.push(`Phase Laser Ramp â–¸ L${fmt(p.phasestRikerLevel, 1)}`);
            if (p.starCannonLevel) list.push(`Star Cannon Calibration â–¸ MK${pad(p.starCannonLevel)}`);
            if (p.vampirismLevel) list.push(`Vampiric Augments â–¸ L${pad(p.vampirismLevel)} (${pct(p.vampirism)})`);
            return list;
        }

        function renderChampionSection() {
            const champion = store.playerChampion;
            if (!champion || champion.dead) {
                return renderListSection('Champion Companion', [], 'Champion offline. Secure sigils to deploy guardian.');
            }
            const minions = Array.isArray(store.championMinions) ? store.championMinions.filter(m => m && !m.dead).length : 0;
            const rows = [
                { key: 'Level', value: pad(champion.level || 1), detail: `Damage x${fmt(champion.damageScale || 1, 2)}` },
                { key: 'Volley', value: `${pad(champion.volleySize || 0)} rounds`, detail: `Cooldown ${fmt(champion.fireCooldown || 0, 2)}s` },
                { key: 'Dash', value: `${fmt(champion.dashCooldown || 0, 2)}s`, detail: `Momentum ${fmt(champion.momentum || 0, 2)}` },
                { key: 'Minions', value: pad(minions), detail: `Guard Radius ${fmt(champion.guardRadius || 0, 1)}` }
            ];
            return renderGridSection('Champion Companion', rows);
        }

        function resolveSkillName(skillId) {
            const meta = resolveSkillMeta(skillId);
            if (meta && meta.name) {
                return meta.name;
            }
            return skillId ? skillId.replace(/_/g, ' ') : '';
        }

        function resolveSkillMeta(skillId) {
            if (!skillId || typeof SKILL_TREE_DATA === 'undefined') return null;
            for (const key of Object.keys(SKILL_TREE_DATA)) {
                const tree = SKILL_TREE_DATA[key];
                if (!tree) continue;
                if (tree.path && Array.isArray(tree.path.nodes)) {
                    const node = tree.path.nodes.find(n => n.id === skillId);
                    if (node) return node;
                }
                if (tree.classAbility && tree.classAbility.id === skillId) return tree.classAbility;
                if (tree.ultimateAbility && tree.ultimateAbility.id === skillId) return tree.ultimateAbility;
                const cross = typeof getCrossUnlockNode === 'function' ? getCrossUnlockNode(tree) : null;
                if (cross && cross.node && cross.node.id === skillId) return cross.node;
            }
            return null;
        }
    }

    function showShopWithHighlight() { showShop(); announce('Low health! Use the Mech Forge to repair!'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }

    function triggerMechForgeGoldMilestone() {
        store.world.mechForgeGoldTriggered = true;
        const mechForgeBtn = q('shopBtn');
        if (mechForgeBtn) {
            mechForgeBtn.classList.add('mech-forge-pulse');
            if (mechForgeBtn._forgePulseTimeout) {
                clearTimeout(mechForgeBtn._forgePulseTimeout);
            }
            const timeoutId = setTimeout(() => {
                mechForgeBtn.classList.remove('mech-forge-pulse');
                mechForgeBtn._forgePulseTimeout = null;
                store.world.mechForgePulseTimeout = null;
            }, 12000);
            mechForgeBtn._forgePulseTimeout = timeoutId;
            store.world.mechForgePulseTimeout = timeoutId;
        }
        announce('Forge unlocked! Spend that gold!');
        showShop();
    }
    function getChampionPrimaryTarget(origin) {
        if (!origin) return null;
        const ox = origin.x ?? store.player.x;
        const oy = origin.y ?? store.player.y;
        let best = null;
        let bestDist = Infinity;
        let bestChampion = null;
        let bestChampionDist = Infinity;

        // Always prioritize boss first
        if (store.boss && !store.boss.dead) {
            const dx = store.boss.x - ox;
            const dy = store.boss.y - oy;
            const dist = dx * dx + dy * dy;
            if (dist < bestDist) {
                bestDist = dist;
                best = store.boss;
            }
        }

        // Search for enemy champions and regular enemies
        for (let i = 0; i < store.enemies.length; i++) {
            const enemy = store.enemies[i];
            if (!enemy || enemy.dead || enemy.hp <= 0) continue;
            const dx = enemy.x - ox;
            const dy = enemy.y - oy;
            const dist = dx * dx + dy * dy;
            
            // Check if this is a champion type enemy
            const isChampion = enemy.type === 'void_champion' || enemy.type === 'shadow_champion';
            
            if (isChampion) {
                // Track the closest champion separately
                if (dist < bestChampionDist) {
                    bestChampionDist = dist;
                    bestChampion = enemy;
                }
            } else {
                // Regular enemy - only consider if no champions found yet
                if (dist < bestDist) {
                    bestDist = dist;
                    best = enemy;
                }
            }
        }

        // Prioritize champions over regular enemies (unless boss exists)
        if (bestChampion && (!store.boss || store.boss.dead)) {
            return bestChampion;
        }

        return best;
    }

    function resolveChampionTarget(entity, options = {}) {
        if (!entity) return null;
        const now = performance.now();
        const stickRange = options.stickRange ?? 620;
        const lingerMs = options.lingerMs ?? 260;
        const originX = entity.x ?? store.player?.x ?? 0;
        const originY = entity.y ?? store.player?.y ?? 0;
        const stickRangeSq = stickRange * stickRange;

        const existing = entity.currentTarget;
        if (existing && !existing.dead && existing.hp > 0) {
            const dx = existing.x - originX;
            const dy = existing.y - originY;
            if (dx * dx + dy * dy <= stickRangeSq) {
                entity.currentTarget = existing;
                entity._lastTargetSeen = now;
                return existing;
            }
        }

        const fresh = getChampionPrimaryTarget(entity);
        if (fresh) {
            entity.currentTarget = fresh;
            entity._lastTargetSeen = now;
            return fresh;
        }

        if (existing && !existing.dead && existing.hp > 0 && entity._lastTargetSeen && (now - entity._lastTargetSeen) < lingerMs) {
            return existing;
        }

        entity.currentTarget = null;
        return null;
    }

    function championDealDamage(target, damage, options = {}) {
        if (!target || target.dead || damage <= 0) return;
        const pseudoBullet = {
            x: options.x ?? target.x,
            y: options.y ?? target.y,
            dmg: damage,
            pierce: true,
            explosive: false,
            isChampionShot: true
        };
        handleBulletImpact(pseudoBullet, target);
    }

    function championFireVolley(champion, target) {
        if (!champion || champion.dead || !target) return;
        const player = store.player;
        const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
        const baseAngle = Math.atan2(target.y - champion.y, target.x - champion.x);
        const volley = Math.max(3, champion.volleySize || 4);
        const spread = champion.volleySpread || 0.16;
        const projectileSpeed = 360 + (champion.level || 1) * 45;
        const baseDamage = (26 + (champion.level || 1) * 8) * dmgMult;

        for (let i = 0; i < volley; i++) {
            const offsetIdx = i - (volley - 1) / 2;
            const angle = baseAngle + offsetIdx * spread;
            const bullet = spawnBullet({
                x: champion.x + Math.cos(baseAngle) * 10,
                y: champion.y + Math.sin(baseAngle) * 10,
                vx: Math.cos(angle) * projectileSpeed,
                vy: Math.sin(angle) * projectileSpeed,
                r: champion.level >= 4 ? 6 : 5,
                col: champion.level >= 4 ? 'rgba(205, 210, 255, 0.96)' : 'rgba(162, 170, 255, 0.94)',
                dmg: baseDamage,
                life: 1.9,
                pierce: champion.level >= 4,
                isChampionShot: true
            });
            bullet.collisionSearchRadius = 160;
        }

        const jitter = 0.06 + Math.random() * 0.08;
        champion.fireTimer = (champion.fireCooldown || 1) + jitter;
        const now = performance.now();
        if (!champion.lastShotTime || (now - champion.lastShotTime) > 200) {
            playSound('stargun');
            champion.lastShotTime = now;
        }
        store.activeEffects.push(createEffect('hitSpark', champion.x + Math.cos(baseAngle) * 6, champion.y + Math.sin(baseAngle) * 6, 14, { strength: 45 }));
    }

    function championUseSpecialAbility(champion, target) {
        if (!champion || champion.dead || !target) return;
        const player = store.player;
        const playerGenome = player.pilotGenome;
        
        if (!champion.lastSpecialUse) champion.lastSpecialUse = 0;
        const now = performance.now();
        
        // Cooldown for special abilities
        if (now - champion.lastSpecialUse < 2000) {
            championFireVolley(champion, target);
            return;
        }
        
        champion.lastSpecialUse = now;
        const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
        
        // Random class ability based on pilot genome
        const abilities = [];
        if (playerGenome === 'beef') abilities.push('charge');
        if (playerGenome === 'rocketman') abilities.push('stealth_rockets');  
        if (playerGenome === 'voidmancer') abilities.push('lightning', 'laser');
        
        // Always add a basic ability as fallback
        abilities.push('volley');
        
        const chosenAbility = abilities[Math.floor(Math.random() * abilities.length)];
        
        switch (chosenAbility) {
            case 'charge':
                championPerformCharge(champion, target, dmgMult);
                break;
            case 'stealth_rockets':
                championFireStealthRockets(champion, target, dmgMult);
                break;
            case 'lightning':
                championCastLightning(champion, target, dmgMult);
                break;
            case 'laser':
                championFireLaser(champion, target, dmgMult);
                break;
            default:
                championFireVolley(champion, target);
                break;
        }
    }

    function championPerformCharge(champion, target, dmgMult) {
        const dx = target.x - champion.x;
        const dy = target.y - champion.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const chargeSpeed = 600;
        
        // Play charge sound
        playSound('beefCharge');
        
        champion.state = 'special_charge';
        champion.dashTimer = 0.4;
        champion.dashDuration = 0.4;
        champion.dashVX = (dx / dist) * chargeSpeed;
        champion.dashVY = (dy / dist) * chargeSpeed;
        champion.visualAim = Math.atan2(champion.dashVY, champion.dashVX);
        champion.dashHits = new Set();
        champion.echoCooldown = 0;
        
        // Enhanced charge damage
        champion.chargeDamage = (80 + (champion.level || 1) * 20) * dmgMult;
        
        // Visual effect - charge trail
        for (let i = 0; i < 8; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 50 + Math.random() * 30;
            const particle = createParticle(
                champion.x + Math.random() * 10 - 5,
                champion.y + Math.random() * 10 - 5,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed,
                '#4080ff',
                200 + Math.random() * 100
            );
            if (particle) particle.size = 2 + Math.random() * 2;
            store.flameParticles.push(particle);
        }
        
        addShadowEcho(champion.x, champion.y);
        champion.fireTimer = 1.2;
        playSound('beefCharge');
    }

    function championFireStealthRockets(champion, target, dmgMult) {
        const baseAngle = Math.atan2(target.y - champion.y, target.x - champion.x);
        const rocketCount = 2 + Math.floor((champion.level || 1) / 2);
        
        for (let i = 0; i < rocketCount; i++) {
            const angleSpread = 0.3;
            const offsetIdx = i - (rocketCount - 1) / 2;
            const angle = baseAngle + offsetIdx * (angleSpread / Math.max(1, rocketCount - 1));
            
            const rocket = spawnBullet({
                x: champion.x + Math.cos(angle) * 15,
                y: champion.y + Math.sin(angle) * 15,
                vx: Math.cos(angle) * 280,
                vy: Math.sin(angle) * 280,
                r: 4,
                col: 'rgba(80, 140, 220, 0.9)',
                dmg: (45 + (champion.level || 1) * 12) * dmgMult,
                life: 2.5,
                pierce: true,
                explosive: true,
                isChampionShot: true,
                stealthRocket: true
            });
            rocket.collisionSearchRadius = 180;
        }
        
        champion.fireTimer = 1.8;
        playSound('stargun');
        store.activeEffects.push(createEffect('hitSpark', champion.x, champion.y, 18, { strength: 60 }));
    }

    function championCastLightning(champion, target, dmgMult) {
        // Play thunder sound
        playSound('thunder');
        
        const damage = (35 + (champion.level || 1) * 10) * dmgMult;
        const maxJumps = 2 + Math.floor((champion.level || 1) / 2);
        
        // Create lightning chain starting from champion to target
        let currentTarget = target;
        let jumpCount = 0;
        const hitTargets = new Set();
        
        while (currentTarget && jumpCount < maxJumps && !hitTargets.has(currentTarget)) {
            hitTargets.add(currentTarget);
            
            // Deal damage
            championDealDamage(currentTarget, damage * (0.8 ** jumpCount), { x: champion.x, y: champion.y });
            
            // Visual effect
            store.activeEffects.push(createEffect('lightning', champion.x, champion.y, 30, {
                targetX: currentTarget.x,
                targetY: currentTarget.y,
                strength: 70 - jumpCount * 15
            }));
            
            // Find next target
            let nextTarget = null;
            let bestDist = 200;
            
            forEachEnemyNearby(currentTarget.x, currentTarget.y, bestDist, enemy => {
                if (!enemy || enemy.dead || hitTargets.has(enemy)) return false;
                const dx = enemy.x - currentTarget.x;
                const dy = enemy.y - currentTarget.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < bestDist) {
                    bestDist = dist;
                    nextTarget = enemy;
                }
                return false;
            });
            
            currentTarget = nextTarget;
            jumpCount++;
        }
        
        champion.fireTimer = 1.5;
        playSound('thunder');
    }

    function championFireLaser(champion, target, dmgMult) {
        const damage = (25 + (champion.level || 1) * 8) * dmgMult;
        const laserDuration = 0.8;
        
        // Create sustained laser beam
        champion.laserTarget = target;
        champion.laserTimer = laserDuration;
        champion.laserDamage = damage;
        champion.fireTimer = 2.0;
        
        // Visual laser effect
        store.activeEffects.push(createEffect('laser', champion.x, champion.y, 25, {
            targetX: target.x,
            targetY: target.y,
            duration: laserDuration,
            strength: 80
        }));
        
        playSound('stargun');
    }

    function stepPlayerChampion(dt) {
        const champion = store.playerChampion;
        const player = store.player;
        if (!champion || champion.dead || !player) return;

        champion.auraPulse = (champion.auraPulse || 0) + dt * 2.4;
        if (champion.dashCooldownTimer > 0) {
            champion.dashCooldownTimer -= dt;
        }

        const hadTarget = !!(champion.currentTarget && !champion.currentTarget.dead && champion.currentTarget.hp > 0);
        const fireTimerBase = champion.fireTimer ?? champion.fireCooldown ?? PLAYER_CHAMPION_CONFIG.baseFireCooldown;
        champion.fireTimer = Math.max(0, fireTimerBase - dt);

        const target = resolveChampionTarget(champion);
        if (!hadTarget && target && champion.fireTimer > 0.15) {
            champion.fireTimer = Math.min(champion.fireTimer, 0.15);
        }

        if (target) {
            champion.visualAim = Math.atan2(target.y - champion.y, target.x - champion.x);
        } else if (champion.roamAnchor) {
            champion.visualAim = Math.atan2(champion.roamAnchor.y - champion.y, champion.roamAnchor.x - champion.x);
        } else {
            const dx = champion.x - player.x;
            const dy = champion.y - player.y;
            champion.visualAim = Math.atan2(dy, dx);
        }

        const dashActive = champion.state === 'dash' || champion.state === 'special_charge';
        champion.swirlPhase = (champion.swirlPhase || 0) + dt * (dashActive ? 9 : 5.4);
        if (champion.swirlPhase > Math.PI * 2) champion.swirlPhase -= Math.PI * 2;

        // Handle laser beam damage over time
        if (champion.laserTimer > 0) {
            champion.laserTimer -= dt;
            if (champion.laserTarget && !champion.laserTarget.dead && champion.laserDamage) {
                championDealDamage(champion.laserTarget, champion.laserDamage * dt * 2, { x: champion.x, y: champion.y });
            }
            if (champion.laserTimer <= 0) {
                champion.laserTarget = null;
                champion.laserDamage = 0;
            }
        }

        const marginX = champion.r || 18;
        const marginY = champion.r || 18;
        const clampAnchor = (x, y) => ({
            x: clamp(x, marginX, W - marginX),
            y: clamp(y, marginY, H - marginY)
        });

        if (!champion.roamAnchor) {
            champion.roamAnchor = clampAnchor(player.x, player.y - 120);
            champion.roamMode = 'idle';
            champion.roamTimer = 0;
        } else {
            champion.roamAnchor = clampAnchor(champion.roamAnchor.x, champion.roamAnchor.y);
        }

        champion.roamTimer = (champion.roamTimer || 0) - dt;

        if (target) {
            if (champion.roamMode !== 'target' || champion.roamTimer <= 0) {
                const baseRadius = Math.max(120, Math.min(210, champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius));
                const offsetAngle = Math.random() * Math.PI * 2;
                const offsetDist = baseRadius * (0.4 + Math.random() * 0.8);
                const anchorX = target.x + Math.cos(offsetAngle) * offsetDist;
                const anchorY = target.y + Math.sin(offsetAngle) * offsetDist * 0.65;
                champion.roamAnchor = clampAnchor(anchorX, anchorY);
                champion.roamMode = 'target';
                champion.roamTimer = 1.1 + Math.random() * 1.8;
            }
        } else if (champion.roamMode !== 'idle' || champion.roamTimer <= 0) {
            const px = clamp(player.x, 80, W - 80);
            const py = clamp(player.y - 140, 80, H - 160);
            const idleAngle = Math.random() * Math.PI * 2;
            const idleDist = 140 + Math.random() * 160;
            const anchorX = px + Math.cos(idleAngle) * idleDist;
            const anchorY = py + Math.sin(idleAngle) * 90;
            champion.roamAnchor = clampAnchor(anchorX, anchorY);
            champion.roamMode = 'idle';
            champion.roamTimer = 2.4 + Math.random() * 1.8;
        }

        if (dashActive) {
            champion.dashTimer -= dt;
            if (champion.dashVX || champion.dashVY) {
                champion.visualAim = Math.atan2(champion.dashVY || 0, champion.dashVX || 0);
            }
            champion.x += (champion.dashVX || 0) * dt;
            champion.y += (champion.dashVY || 0) * dt;
            champion.echoCooldown = (champion.echoCooldown || 0) - dt;
            if ((champion.echoCooldown || 0) <= 0) {
                addShadowEcho(champion.x, champion.y);
                champion.echoCooldown = 0.035;
            }

            const dashRadius = (champion.r || 20) + (champion.state === 'special_charge' ? 10 : 6);
            const damage = champion.state === 'special_charge' && champion.chargeDamage ? 
                          champion.chargeDamage : 
                          (120 + (champion.level || 1) * 28) * (player.dmgMult || 1) * (champion.damageScale || 1);

            if (!champion.dashHits) champion.dashHits = new Set();

            if (store.boss && !store.boss.dead) {
                const boss = store.boss;
                const dx = boss.x - champion.x;
                const dy = boss.y - champion.y;
                const hitRadius = (boss.r || 70) + dashRadius;
                if (dx * dx + dy * dy <= hitRadius * hitRadius && !champion.dashHits.has('boss')) {
                    championDealDamage(boss, damage, { x: champion.x, y: champion.y });
                    champion.dashHits.add('boss');
                    store.activeEffects.push(createEffect('hitSpark', boss.x, boss.y, boss.r || 60, { strength: 90 }));
                }
            }

            forEachEnemyNearby(champion.x, champion.y, dashRadius + 48, enemy => {
                if (!enemy || enemy.dead) return false;
                if (enemy.id && champion.dashHits.has(enemy.id)) return false;
                const dx = enemy.x - champion.x;
                const dy = enemy.y - champion.y;
                const hitRadius = (enemy.r || 18) + dashRadius;
                if (dx * dx + dy * dy <= hitRadius * hitRadius) {
                    championDealDamage(enemy, damage, { x: champion.x, y: champion.y });
                    if (enemy.id) champion.dashHits.add(enemy.id);
                    store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, enemy.r || 18, { strength: 65 }));
                }
                return false;
            });

            if (champion.dashTimer <= 0) {
                champion.state = null;
                champion.dashVX = 0;
                champion.dashVY = 0;
                champion.dashHits = null;
            }
        } else {
            const guardRadius = Math.max(100, champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius);
            const orbitAspect = 0.55 + Math.min(0.25, (champion.level || 1) * 0.04);
            champion.guardAngle = (champion.guardAngle || Math.random() * Math.PI * 2) + (champion.angularSpeed || 1.2) * dt * (target ? 1.2 : 0.85);
            const desiredX = champion.roamAnchor.x + Math.cos(champion.guardAngle) * guardRadius;
            const desiredY = champion.roamAnchor.y + Math.sin(champion.guardAngle) * guardRadius * orbitAspect;
            const followFactor = Math.min(1, (champion.momentum || 4.3) * dt);
            champion.x += (desiredX - champion.x) * followFactor;
            champion.y += (desiredY - champion.y) * followFactor * 0.92;

            if (target) {
                const dx = target.x - champion.x;
                const dy = target.y - champion.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                if (dist > 420) {
                    const chase = Math.min(220, (dist - 420) * 0.6);
                    champion.x += (dx / dist) * chase * dt;
                    champion.y += (dy / dist) * chase * dt * 0.85;
                }
            }

            if (target && champion.fireTimer <= 0) {
                const dx = target.x - champion.x;
                const dy = target.y - champion.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const canDash = (champion.dashCooldownTimer || 0) <= 0 && dist <= 420;
                const dashChance = dist <= 220 ? 0.65 : dist <= 320 ? 0.45 : 0.28;

                if (canDash && Math.random() < dashChance) {
                    const dashSpeed = 480 + (champion.level || 1) * 55;
                    champion.state = 'dash';
                    champion.dashTimer = 0.32;
                    champion.dashDuration = 0.32;
                    champion.dashVX = (dx / dist) * dashSpeed;
                    champion.dashVY = (dy / dist) * dashSpeed;
                    champion.dashCooldownTimer = champion.dashCooldown || PLAYER_CHAMPION_CONFIG.baseDashCooldown;
                    champion.visualAim = Math.atan2(champion.dashVY, champion.dashVX);
                    champion.dashHits = new Set();
                    champion.echoCooldown = 0;
                    addShadowEcho(champion.x, champion.y);
                    champion.fireTimer = 0.4;
                } else {
                    // 30% chance to use special class ability instead of normal volley
                    if (Math.random() < 0.3) {
                        championUseSpecialAbility(champion, target);
                    } else {
                        championFireVolley(champion, target);
                    }
                }
            }
        }

        champion.x = clamp(champion.x, marginX, W - marginX);
        champion.y = clamp(champion.y, marginY, H - marginY);
    }

    function stepChampionMinions(dt) {
        if (!store.championMinions || store.championMinions.length === 0) return;
        const owner = store.playerChampion;
        if (!owner || owner.dead) {
            store.championMinions.length = 0;
            return;
        }

        for (let i = store.championMinions.length - 1; i >= 0; i--) {
            const minion = store.championMinions[i];
            if (!minion || minion.dead) {
                store.championMinions.splice(i, 1);
                continue;
            }

            minion.orbitAngle += (minion.orbitSpeed || 1.6) * dt;
            minion.pulsePhase = (minion.pulsePhase || 0) + dt * 3.1;
            const radius = minion.orbitRadius * (1 + Math.sin(minion.pulsePhase) * 0.03);
            const targetX = owner.x + Math.cos(minion.orbitAngle) * radius;
            const targetY = owner.y + Math.sin(minion.orbitAngle) * radius * 0.55;
            minion.x += (targetX - minion.x) * Math.min(1, 10 * dt);
            minion.y += (targetY - minion.y) * Math.min(1, 10 * dt);

            const desiredCooldown = Math.max(0.75, 1.4 - (owner.level || 1) * 0.12);
            minion.fireCooldown += (desiredCooldown - minion.fireCooldown) * Math.min(1, dt * 3);
            minion.damageScale = 1 + ((owner.level || 1) - 1) * 0.18;

            const hadTarget = !!(minion.currentTarget && !minion.currentTarget.dead && minion.currentTarget.hp > 0);
            const fireBase = minion.fireTimer ?? minion.fireCooldown ?? desiredCooldown;
            minion.fireTimer = Math.max(0, fireBase - dt);

            const target = resolveChampionTarget(minion, { stickRange: 520, lingerMs: 220 });
            if (!hadTarget && target && minion.fireTimer > 0.2) {
                minion.fireTimer = Math.min(minion.fireTimer, 0.2);
            }
            if (minion.fireTimer <= 0 && target) {
                const angle = Math.atan2(target.y - minion.y, target.x - minion.x);
                const speed = 340 + (owner.level || 1) * 30;
                const damage = (18 + (owner.level || 1) * 6) * (store.player?.dmgMult || 1) * (minion.damageScale || 1);
                const bullet = spawnBullet({
                    x: minion.x,
                    y: minion.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    r: 4,
                    col: '#cdd0ff',
                    dmg: damage,
                    life: 1.6,
                    pierce: owner.level >= 4,
                    isChampionShot: true
                });
                bullet.collisionSearchRadius = 150;
                minion.fireTimer = minion.fireCooldown + Math.random() * 0.1;
            }
        }
    }

    function createHound(side) {
        const isTuxedo = side === -1 || side === -2;
        let color = isTuxedo ? { main: '#222222', accent: '#FFFFFF' } : { main: '#F0E68C', accent: '#BDB76B' };
        
        let isUpgraded = false;
        let eyeType = 'normal';
        let expression = 'normal';

        if (Math.abs(side) > 1) { 
            isUpgraded = true;
            if (side === -2) { 
                color = { main: '#c4b5a0', accent: '#333' }; 
                eyeType = 'swirly';
                expression = 'silly';
            } else { 
                color = { main: '#ffb366', accent: '#000' }; 
                eyeType = 'dilated';
                expression = 'mischievous';
            }
        }

        return {
            x: store.player.x + 50 * side,
            y: store.player.y + 20,
            side,
            target: null,
            attackT: 0,
            r: 12,
            killCount: 0,
            color,
            isUpgraded,
            eyeType,
            expression
        };
    }
    function stepHounds(dt) { if (!store.player.hasHounds) return; store.hounds.forEach(h => { if (!h.target || h.target.dead || h.target.hp <= 0) { let closest = null, closestDist = Infinity; const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies; potentialTargets.forEach(e => { if (e.dead || e.hp <= 0) return; const dist = (h.x - e.x)**2 + (h.y - e.y)**2; if (dist < closestDist) { closestDist = dist; closest = e; } }); h.target = closest; } if (h.target) { const tx = h.target.x, ty = h.target.y; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); const speed = 350; if (dist > 30) { h.x += (dx / dist) * speed * dt; h.y += (dy / dist) * speed * dt; } else { h.attackT -= dt; if (h.attackT <= 0) { h.attackT = 0.25; let dmg = 8 * store.player.dmgMult; if (h.target === store.boss) dmg *= 0.3; if (!h.target.dead && h.target.hp > 0) { h.target.hp -= dmg; if (store.player.vampirism > 0) { let healAmount = dmg * store.player.vampirism; healAmount = Math.max(healAmount, 0.5); healAmount = Math.min(healAmount, 2); store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount); } if (h.target.hp <= 0) { h.killCount++; if (h.killCount > 0 && h.killCount % 12 === 0) { playSound('dogs'); } } } } } } else { const tx = store.player.x + h.side * 50, ty = store.player.y + 20; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 5) { h.x += dx * 5 * dt; h.y += dy * 5 * dt; } } }); }

    function stepShadowHounds(dt) {
        if (!store.shadowHounds || !store.shadowHounds.length) return;
        const player = store.player;
        for (let i = store.shadowHounds.length - 1; i >= 0; i--) {
            const h = store.shadowHounds[i];
            if (!h) {
                store.shadowHounds.splice(i, 1);
                continue;
            }
            h.life -= dt;
            if (h.life <= 0 || h.dead) {
                store.shadowHounds.splice(i, 1);
                continue;
            }
            h.attackCooldown = Math.max(0, h.attackCooldown - dt);
            h.wobble += dt * 3.4;
            const targetOffsetX = Math.sin(h.wobble) * 16;
            const targetOffsetY = Math.cos(h.wobble * 0.7) * 12;
            const targetX = clamp(player.x + targetOffsetX, 20, W - 20);
            const targetY = clamp(player.y + targetOffsetY, 40, H - 40);
            const dx = targetX - h.x;
            const dy = targetY - h.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const step = Math.min(dist, h.speed * dt);
            h.x += (dx / dist) * step;
            h.y += (dy / dist) * step;

            const px = player.x - h.x;
            const py = player.y - h.y;
            const hitRadius = (player.r || 18) + 10;
            if (px * px + py * py <= hitRadius * hitRadius && h.attackCooldown <= 0) {
                takeDamage(h.damage);
                h.attackCooldown = 0.7;
            }
        }
    }
    function drawHound(h) {
        ctx.save();
        ctx.translate(h.x, h.y);
        const time = performance.now();
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time / 1000 + h.side);
        let r = h.r;
        
        // Make the 4th dog (tanish orange one with regular pupils) half size
        if (h.side === 2) {
            r = r * 0.5;
        }

        if (!h.isUpgraded) {
            const { main, accent } = h.color;
            const isTuxedo = accent === '#FFFFFF';

            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.5);
            ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
            ctx.quadraticCurveTo(r * 1.2, 0, r, r);
            ctx.lineTo(-r, r);
            ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.4);
            ctx.lineTo(-r * 0.5, -r * 1.2);
            ctx.lineTo(-r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r, -r * 0.4);
            ctx.lineTo(r * 0.5, -r * 1.2);
            ctx.lineTo(r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();

            if (isTuxedo) {
                ctx.fillStyle = accent;
                ctx.beginPath();
                ctx.moveTo(-r * 0.6, r * 0.2);
                ctx.quadraticCurveTo(0, r, r * 0.6, r * 0.2);
                ctx.lineTo(0, r * 0.5);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.3, r * 0.5, r * 0.4, 0, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, r * 0.5);
            ctx.lineTo(-r * 0.1, r * 0.5);
            ctx.lineTo(-r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.3, r * 0.5);
            ctx.lineTo(r * 0.1, r * 0.5);
            ctx.lineTo(r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
        } else {
            const color = h.color.main;
            const opacity = ctx.globalAlpha;
            const eyeType = h.eyeType;
            const expression = h.expression;
            const radius = r * 1.5;

            if (h.side === 2) {
                ctx.save();
                ctx.globalAlpha = 0.7 * opacity;
                ctx.fillStyle = '#9966ff';
                ctx.beginPath();
                ctx.moveTo(0, -radius * 1.8);
                ctx.lineTo(-radius * 0.8, -radius * 0.9);
                ctx.lineTo(radius * 0.8, -radius * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius * 0.6, -radius * 0.7);
            ctx.lineTo(-radius * 0.4, -radius * 1.2);
            ctx.lineTo(-radius * 0.2, -radius * 0.8);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.6, -radius * 0.7);
            ctx.lineTo(radius * 0.4, -radius * 1.2);
            ctx.lineTo(radius * 0.2, -radius * 0.8);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius, 0);
            for(let i = 0; i <= 6; i++) {
                let waveX = -radius + (radius * 2 / 6) * i;
                let waveY = radius + Math.sin(i * 0.8 + time * 0.005) * radius * 0.2;
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(radius, 0);
            ctx.fill();

            ctx.fillStyle = 'white';
            
            if (eyeType === 'dilated') {
                ctx.beginPath();
                ctx.ellipse(-radius * 0.35, -radius * 0.1, radius * 0.28, radius * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(radius * 0.35, -radius * 0.15, radius * 0.25, radius * 0.32, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-radius * 0.3 + Math.sin(time * 0.001) * radius * 0.05,
                      -radius * 0.05, radius * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.4,
                      -radius * 0.2 + Math.cos(time * 0.001) * radius * 0.05,
                      radius * 0.06, 0, Math.PI * 2);
                ctx.fill();
            } else { // 'swirly'
                ctx.beginPath();
                ctx.arc(-radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'black';
                ctx.lineWidth = radius * 0.04;
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = -radius * 0.35 + Math.cos(t + time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t + time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = radius * 0.35 + Math.cos(t - time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t - time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            
            ctx.fillStyle = 'white';
            
            ctx.beginPath();
            ctx.moveTo(-radius * 0.25, radius * 0.2);
            ctx.lineTo(-radius * 0.2, radius * 0.5);
            ctx.lineTo(-radius * 0.15, radius * 0.2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.25, radius * 0.2);
            ctx.lineTo(radius * 0.2, radius * 0.5);
            ctx.lineTo(radius * 0.15, radius * 0.2);
            ctx.fill();
            
            for(let i = -1; i <= 1; i++) {
                if(i === 0) continue;
                ctx.beginPath();
                ctx.moveTo(i * radius * 0.08, radius * 0.2);
                ctx.lineTo(i * radius * 0.08 + radius * 0.02, radius * 0.35);
                ctx.lineTo(i * radius * 0.08 - radius * 0.02, radius * 0.35);
                ctx.fill();
            }
            
            ctx.strokeStyle = expression === 'silly' ? '#000' : '#333';
            ctx.lineWidth = radius * 0.03;
            ctx.beginPath();
            
            if (expression === 'silly') {
                ctx.moveTo(-radius * 0.3, radius * 0.15);
                ctx.quadraticCurveTo(-radius * 0.1, radius * 0.05, 0, radius * 0.15);
                ctx.quadraticCurveTo(radius * 0.1, radius * 0.25, radius * 0.3, radius * 0.15);
            } else {
                ctx.arc(0, 0, radius * 0.35, Math.PI * 0.2, Math.PI * 0.8);
            }
            ctx.stroke();
        }
        ctx.restore();
    }

    function drawShadowHound(h) {
        ctx.save();
        ctx.translate(h.x, h.y);
        const time = performance.now() / 1000;
        const lifeRatio = h.maxLife ? Math.max(0, Math.min(1, h.life / h.maxLife)) : 1;
        const pulse = 0.5 + 0.4 * Math.sin(time * 6 + h.wobble);

        ctx.globalAlpha = 0.55 + 0.35 * lifeRatio;

        const bodyWidth = 18;
        const bodyHeight = 12;

        const gradient = ctx.createRadialGradient(0, 0, bodyHeight * 0.4, 0, 0, bodyWidth);
        gradient.addColorStop(0, `rgba(35, 38, 62, ${0.9})`);
        gradient.addColorStop(1, `rgba(18, 20, 34, ${0.9 * lifeRatio})`);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = `rgba(205, 211, 255, ${0.8})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
        ctx.stroke();

        ctx.shadowColor = 'rgba(120, 130, 220, 0.7)';
        ctx.shadowBlur = 18 * lifeRatio;
        ctx.fillStyle = `rgba(200, 210, 255, ${0.55 + pulse * 0.25})`;
        ctx.beginPath();
        ctx.arc(-6, -2, 3, 0, Math.PI * 2);
        ctx.arc(6, -2, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#2a2f4e';
        ctx.beginPath();
        ctx.moveTo(-bodyWidth * 0.25, bodyHeight * 0.2);
        ctx.lineTo(-bodyWidth * 0.45, bodyHeight * 0.95);
        ctx.lineTo(-bodyWidth * 0.28, bodyHeight * 0.95);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(bodyWidth * 0.25, bodyHeight * 0.2);
        ctx.lineTo(bodyWidth * 0.45, bodyHeight * 0.95);
        ctx.lineTo(bodyWidth * 0.28, bodyHeight * 0.95);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = `rgba(150, 160, 240, ${0.8})`;
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(-bodyWidth * 0.6, -bodyHeight * 0.2);
        ctx.quadraticCurveTo(-bodyWidth * 0.1, -bodyHeight * 0.9, 0, -bodyHeight * 0.4);
        ctx.quadraticCurveTo(bodyWidth * 0.1, -bodyHeight * 0.9, bodyWidth * 0.6, -bodyHeight * 0.2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bodyWidth * 0.4, -bodyHeight * 0.05);
        ctx.quadraticCurveTo(bodyWidth * 0.9, -bodyHeight * 0.4, bodyWidth * 0.7, bodyHeight * 0.2);
        ctx.stroke();

        ctx.restore();
    }

    function drawChampionMinion(minion, owner) {
        if (!minion) return;
        const level = owner?.level || 1;
        const baseRadius = 6 + Math.min(level, 3);
    const now = performance.now() / 1000;
    const pulse = 0.6 + 0.35 * Math.sin(now * 6 + (minion.pulsePhase || 0));
    const swirl = now * 5.2 + (minion.swirlPhase || 0);
        const fireCooldown = Math.max(0.12, minion.fireCooldown || 0.6);
        const fireRatio = Math.max(0, Math.min(1, (minion.fireTimer || 0) / fireCooldown));

        ctx.save();
        ctx.translate(minion.x, minion.y);

        if (owner) {
            const angleToOwner = Math.atan2(owner.y - minion.y, owner.x - minion.x);
            const tailLength = baseRadius * (2.2 + level * 0.35);

            ctx.save();
            ctx.rotate(angleToOwner + Math.PI);
            ctx.globalAlpha = 0.32 + 0.28 * (1 - fireRatio);
            const tailGradient = ctx.createLinearGradient(-tailLength, 0, 0, 0);
            tailGradient.addColorStop(0, 'rgba(25, 28, 52, 0)');
            tailGradient.addColorStop(0.9, 'rgba(70, 80, 150, 0.28)');
            tailGradient.addColorStop(1, 'rgba(150, 160, 245, 0.72)');
            ctx.fillStyle = tailGradient;
            ctx.beginPath();
            ctx.moveTo(-tailLength, -baseRadius * 0.55);
            ctx.quadraticCurveTo(-tailLength * 0.6, -baseRadius, -baseRadius * 0.25, -baseRadius * 0.4);
            ctx.lineTo(0, 0);
            ctx.lineTo(-baseRadius * 0.25, baseRadius * 0.4);
            ctx.quadraticCurveTo(-tailLength * 0.6, baseRadius, -tailLength, baseRadius * 0.55);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.4 + 0.25 * (1 - fireRatio);
        const auraRadius = baseRadius * (1.9 + pulse * 0.35 + level * 0.1);
        const auraGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, auraRadius);
        auraGradient.addColorStop(0, 'rgba(150, 200, 255, 0.7)');
        auraGradient.addColorStop(0.52, `rgba(80, 140, 220, ${0.4 + level * 0.05})`);
        auraGradient.addColorStop(1, 'rgba(20, 40, 80, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';

        ctx.save();
        ctx.rotate(swirl * 0.4);
        ctx.globalAlpha = 0.4 + 0.2 * (1 - fireRatio);
        ctx.lineWidth = 1.25;
        ctx.strokeStyle = 'rgba(100, 160, 255, 0.7)';
        ctx.beginPath();
        ctx.ellipse(0, 0, baseRadius * (1.18 + 0.08 * Math.sin(swirl)), baseRadius * (0.62 + 0.1 * Math.cos(swirl * 1.3)), 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.rotate(-swirl * 0.45);
        ctx.globalAlpha = 0.25 + 0.2 * (1 - fireRatio);
        ctx.lineWidth = 0.9;
        ctx.strokeStyle = 'rgba(60, 120, 200, 0.6)';
        ctx.beginPath();
        ctx.ellipse(0, 0, baseRadius * 1.45, baseRadius * 0.78, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        ctx.globalAlpha = 0.95;
        const coreGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.22, 0, 0, baseRadius * 0.92);
        coreGradient.addColorStop(0, 'rgba(180, 220, 255, 0.95)');
        coreGradient.addColorStop(0.4, 'rgba(100, 160, 240, 0.9)');
        coreGradient.addColorStop(0.75, 'rgba(40, 80, 160, 0.95)');
        coreGradient.addColorStop(1, 'rgba(20, 35, 70, 1)');
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, baseRadius * (0.95 + pulse * 0.05), 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 0.8;
        ctx.lineWidth = 1.6;
        ctx.strokeStyle = level >= 5 ? 'rgba(120, 180, 255, 0.9)' : 'rgba(80, 140, 220, 0.85)';
        ctx.beginPath();
        ctx.arc(0, 0, baseRadius * 1.1, 0, Math.PI * 2);
        ctx.stroke();

        ctx.save();
        ctx.rotate(0.12 * Math.sin(swirl));
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = 'rgba(140, 190, 255, 0.9)';
        ctx.beginPath();
        ctx.moveTo(-baseRadius * 0.52, -baseRadius * 0.12);
        ctx.quadraticCurveTo(-baseRadius * 0.12, -baseRadius * 0.58, baseRadius * 0.48, -baseRadius * 0.05);
        ctx.quadraticCurveTo(-baseRadius * 0.08, baseRadius * 0.28, -baseRadius * 0.45, baseRadius * 0.1);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 0.65;
        ctx.strokeStyle = 'rgba(60, 120, 200, 0.85)';
        ctx.lineWidth = 0.9;
        ctx.stroke();
        ctx.restore();

        ctx.globalAlpha = 0.6 * (1 - fireRatio);
        const thrusterGradient = ctx.createRadialGradient(0, baseRadius * 0.95, baseRadius * 0.1, 0, baseRadius * 1.25, baseRadius * 0.6);
        thrusterGradient.addColorStop(0, 'rgba(120, 180, 255, 0.8)');
        thrusterGradient.addColorStop(1, 'rgba(40, 80, 160, 0)');
        ctx.fillStyle = thrusterGradient;
        ctx.beginPath();
        ctx.ellipse(0, baseRadius * 1.05, baseRadius * 0.6, baseRadius * 0.36, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawPlayerChampion(champion) {
        if (!champion) return;

        const level = champion.level || 1;
        const baseRadius = champion.r || 20;
        const now = performance.now() / 1000;
        const auraPhase = champion.auraPulse || 0;
        const auraPulse = 0.8 + 0.18 * Math.sin(now * 3 + auraPhase);
        const dashActive = champion.state === 'dash';
        const facing = typeof champion.visualAim === 'number' ? champion.visualAim : 0;
        const swirl = champion.swirlPhase || 0;

        ctx.save();
        ctx.translate(champion.x, champion.y);

        // Dark blue aura (darker than iceman)
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.38 + 0.22 * Math.sin(now * 2.5 + auraPhase * 0.9);
        const auraRadius = baseRadius * (2.0 + auraPulse * 0.7 + level * 0.1);
        const auraGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.3, 0, 0, auraRadius);
        auraGradient.addColorStop(0, 'rgba(120, 180, 255, 0.25)');
        auraGradient.addColorStop(0.5, `rgba(45, 85, 160, ${0.4 + level * 0.05})`);
        auraGradient.addColorStop(1, 'rgba(15, 25, 65, 0)');
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        if (dashActive && (champion.dashVX || champion.dashVY)) {
            const dashDuration = champion.dashDuration || 0.01;
            const dashProgress = Math.max(0, Math.min(1, 1 - (champion.dashTimer || 0) / dashDuration));
            const streakLength = baseRadius * (3.2 + level * 0.35);
            const trailAngle = Math.atan2(champion.dashVY || 0, champion.dashVX || 1);

            ctx.save();
            ctx.rotate(trailAngle);
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.6 + 0.3 * dashProgress;
            const streakGradient = ctx.createLinearGradient(-streakLength, 0, baseRadius * 0.9, 0);
            streakGradient.addColorStop(0, 'rgba(15, 30, 80, 0)');
            streakGradient.addColorStop(0.4, 'rgba(60, 120, 200, 0.5)');
            streakGradient.addColorStop(1, 'rgba(120, 180, 255, 0.9)');
            ctx.fillStyle = streakGradient;
            ctx.beginPath();
            ctx.moveTo(-streakLength, -baseRadius * 0.6);
            ctx.lineTo(baseRadius * 0.9, -baseRadius * 0.2);
            ctx.lineTo(baseRadius * 0.9, baseRadius * 0.2);
            ctx.lineTo(-streakLength, baseRadius * 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Angular diamond body
        ctx.save();
        ctx.rotate(facing);

        // Main diamond body - darker blue gradient
        const bodyGradient = ctx.createLinearGradient(0, -baseRadius * 1.2, 0, baseRadius * 1.1);
        bodyGradient.addColorStop(0, '#2a3560');
        bodyGradient.addColorStop(0.3, '#1e2845');
        bodyGradient.addColorStop(0.7, '#3c4f78');
        bodyGradient.addColorStop(1, '#253555');
        ctx.fillStyle = bodyGradient;
        ctx.strokeStyle = '#6090d0';
        ctx.lineWidth = 2.2;
        ctx.globalAlpha = 0.95;
        
        // Angular diamond shape
        ctx.beginPath();
        ctx.moveTo(0, -baseRadius * 1.1);                    // Top point
        ctx.lineTo(baseRadius * 0.9, -baseRadius * 0.15);    // Top-right
        ctx.lineTo(baseRadius * 0.6, baseRadius * 0.9);      // Bottom-right
        ctx.lineTo(0, baseRadius * 1.05);                    // Bottom point
        ctx.lineTo(-baseRadius * 0.6, baseRadius * 0.9);     // Bottom-left
        ctx.lineTo(-baseRadius * 0.9, -baseRadius * 0.15);   // Top-left
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Angular inner sections
        ctx.fillStyle = '#1a2440';
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.moveTo(-baseRadius * 0.25, -baseRadius * 0.3);
        ctx.lineTo(baseRadius * 0.25, -baseRadius * 0.3);
        ctx.lineTo(baseRadius * 0.4, baseRadius * 0.15);
        ctx.lineTo(-baseRadius * 0.4, baseRadius * 0.15);
        ctx.closePath();
        ctx.fill();

        // Visor - angular hexagonal shape
        ctx.fillStyle = '#0f1525';
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(0, -baseRadius * 0.55);
        ctx.lineTo(baseRadius * 0.45, -baseRadius * 0.25);
        ctx.lineTo(baseRadius * 0.35, baseRadius * 0.05);
        ctx.lineTo(-baseRadius * 0.35, baseRadius * 0.05);
        ctx.lineTo(-baseRadius * 0.45, -baseRadius * 0.25);
        ctx.closePath();
        ctx.fill();

        // Glowing visor
        const visorGradient = ctx.createLinearGradient(-baseRadius * 0.4, -baseRadius * 0.3, baseRadius * 0.4, 0);
        visorGradient.addColorStop(0, 'rgba(80, 150, 255, 0.8)');
        visorGradient.addColorStop(0.5, 'rgba(120, 180, 255, 0.95)');
        visorGradient.addColorStop(1, 'rgba(60, 120, 200, 0.7)');
        ctx.fillStyle = visorGradient;
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(0, -baseRadius * 0.5);
        ctx.lineTo(baseRadius * 0.4, -baseRadius * 0.22);
        ctx.lineTo(baseRadius * 0.3, 0);
        ctx.lineTo(-baseRadius * 0.3, 0);
        ctx.lineTo(-baseRadius * 0.4, -baseRadius * 0.22);
        ctx.closePath();
        ctx.fill();

        // Angular accent lines
        const accentColor = level >= 4 ? '#80c0ff' : '#6090d0';
        ctx.globalAlpha = 0.8;
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 1.8;
        ctx.beginPath();
        ctx.moveTo(-baseRadius * 0.35, baseRadius * 0.25);
        ctx.lineTo(baseRadius * 0.35, baseRadius * 0.25);
        ctx.moveTo(-baseRadius * 0.25, baseRadius * 0.6);
        ctx.lineTo(baseRadius * 0.25, baseRadius * 0.6);
        ctx.stroke();

        // Level indicators
        if (level >= 2) {
            ctx.globalAlpha = 0.6 + 0.25 * Math.sin(now * 5.5 + auraPhase);
            ctx.lineWidth = level >= 4 ? 2.5 : 1.8;
            ctx.beginPath();
            ctx.moveTo(0, -baseRadius * 1.5);
            ctx.lineTo(0, -baseRadius * 2.0);
            ctx.moveTo(-baseRadius * 0.3, -baseRadius * 1.75);
            ctx.lineTo(baseRadius * 0.3, -baseRadius * 1.75);
            ctx.stroke();
        }

        // Special ability charge indicator
        if (champion.specialAbilityCooldown > 0) {
            const cooldownRatio = champion.specialAbilityCooldown / 5000; // 5 second cooldown
            ctx.globalAlpha = 0.7;
            ctx.strokeStyle = '#4080ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius * 1.2, -Math.PI / 2, -Math.PI / 2 + (1 - cooldownRatio) * Math.PI * 2);
            ctx.stroke();
            
            // Class ability icons when ready
            if (cooldownRatio <= 0) {
                const iconPulse = 0.8 + 0.2 * Math.sin(now * 4);
                ctx.globalAlpha = 0.9 * iconPulse;
                
                // Determine next ability type (same logic as the special ability function)
                const player = store.player;
                let abilityType = 'beef'; // default
                if (player) {
                    if (player.pilotGenome === 'rocketman') abilityType = 'rocket';
                    else if (player.pilotGenome === 'voidmancer') {
                        abilityType = champion.lastVoidmancerAbility === 'lightning' ? 'laser' : 'lightning';
                    }
                }
                
                // Draw ability icon
                ctx.fillStyle = '#80c0ff';
                ctx.font = `${baseRadius * 0.4}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let iconText = 'âš¡';
                if (abilityType === 'beef') iconText = 'ðŸ’¨';
                else if (abilityType === 'rocket') iconText = 'ðŸš€';
                else if (abilityType === 'laser') iconText = 'ðŸ”«';
                
                ctx.fillText(iconText, 0, baseRadius * 1.8);
            }
        }

        ctx.restore();

        // Rotating energy field
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = 'rgba(80, 140, 220, 0.6)';
        ctx.lineWidth = 1.8;
        ctx.rotate(swirl * 0.8);
        for (let i = 0; i < 6; i++) {
            ctx.beginPath();
            ctx.moveTo(0, baseRadius * 0.3);
            ctx.lineTo(0, baseRadius * 1.4);
            ctx.stroke();
            ctx.rotate(Math.PI / 3);
        }
        ctx.restore();

        // Core energy orb
        ctx.globalAlpha = 0.7;
        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 0.5);
        coreGradient.addColorStop(0, 'rgba(140, 200, 255, 0.8)');
        coreGradient.addColorStop(1, 'rgba(60, 120, 200, 0.2)');
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, baseRadius * 0.15, baseRadius * 0.45, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawIceman(iceman) {
        const { x, y } = iceman;
        ctx.save();
        ctx.translate(x, y);
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12, 8);
        ctx.lineTo(8, 14);
        ctx.lineTo(0, 10);
        ctx.lineTo(-8, 14);
        ctx.lineTo(-12, 8);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
        bodyGrad.addColorStop(0, "#a0e9ff");
        bodyGrad.addColorStop(1, "#3c9aed");
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d0f8ff";
        ctx.stroke();

        ctx.strokeStyle = "#a0e9ff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 5);
        ctx.lineTo(-20, -2);
        ctx.lineTo(-18, 8);
        ctx.moveTo(12, 5);
        ctx.lineTo(20, -2);
        ctx.lineTo(18, 8);
        ctx.stroke();

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(0, -8, 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawBeefClone(beefClone) {
        const { x, y } = beefClone;
        ctx.save();
        ctx.translate(x, y);
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12, 8);
        ctx.lineTo(8, 14);
        ctx.lineTo(0, 10);
        ctx.lineTo(-8, 14);
        ctx.lineTo(-12, 8);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
        bodyGrad.addColorStop(0, "#a0ffa0"); // Light green
        bodyGrad.addColorStop(1, "#3ced3c"); // Darker green
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d0ffd0"; // Light green outline
        ctx.stroke();

        // Arms - green colored
        ctx.strokeStyle = "#a0ffa0";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 5);
        ctx.lineTo(-20, -2);
        ctx.lineTo(-18, 8);
        ctx.moveTo(12, 5);
        ctx.lineTo(20, -2);
        ctx.lineTo(18, 8);
        ctx.stroke();

        // Eye - white dot
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(0, -8, 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawLightningBolt(bolt) {
        const { points, life, maxLife } = bolt;
        const t = life / maxLife;
        if (t <= 0) return;

        ctx.save();
        ctx.lineWidth = 4 * t;
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * t})`;
        ctx.shadowColor = '#9a66ff';
        ctx.shadowBlur = 20 * t;
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        
        ctx.lineWidth = 1.5 * t;
        ctx.strokeStyle = `rgba(200, 220, 255, ${t})`;
        ctx.shadowBlur = 10 * t;
        ctx.stroke();

        ctx.restore();
    }

    function drawEmpNova(nova) {
        ctx.save();
        
        // Create pulsing effect
        const time = performance.now() / 1000;
        const pulse = 0.8 + 0.2 * Math.sin(time * 8);
        const opacity = Math.min(1, nova.life / 2) * 0.3; // Fade in over 2 seconds
        
        // Draw expanding EMP ring
        ctx.strokeStyle = `rgba(255, 140, 0, ${opacity * pulse})`; // Orange cyberpunk color
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]); // Dashed line for tech effect
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner energy ring
        ctx.strokeStyle = `rgba(138, 43, 226, ${opacity * pulse * 0.7})`; // Purple
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 10;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        
        // Add some sparking effects around the perimeter
        ctx.setLineDash([]);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * pulse})`;
        ctx.lineWidth = 1;
        
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2 + time * 2;
            const x1 = nova.x + Math.cos(angle) * (nova.radius - 5);
            const y1 = nova.y + Math.sin(angle) * (nova.radius - 5);
            const x2 = nova.x + Math.cos(angle) * (nova.radius + 5);
            const y2 = nova.y + Math.sin(angle) * (nova.radius + 5);
            
            if (Math.random() < 0.3) { // Random sparking
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        ctx.restore();
    }

    function activateGravityWell() {
        if (!store.isPaused) {
            const spawnX = W * 0.2 + Math.random() * W * 0.6;
            const spawnY = H * 0.2 + Math.random() * H * 0.6;
            store.activeEffects.push(createEffect("gravityWell", spawnX, spawnY));
            announce('GRAVITY WELL ACTIVATED');
            screenFlash(2, 250, 'rgba(255, 255, 255, 0.7)');
        }
    }
    function activateLazarus() {
        if (store.player.hasLazarusBeam && !store.isPaused) {
            const angle = Math.random() * 2 * Math.PI,
                speed = 800,
                p = store.player;
            store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 6, r: 12, hitEnemies: new Set });
            
            if (p.upgradeLevels.lazarus_beam > 1) {
                const oppositeAngle = angle + Math.PI;
                store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(oppositeAngle) * speed, vy: Math.sin(oppositeAngle) * speed, life: 6, r: 12, hitEnemies: new Set });
            }
        }
    }
    function useGrenade() {
        if (store.player.grenades > 0 && !store.isPaused) {
            playSound('explosion');
            store.player.grenades--;
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 400;
                spawnBullet({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 5,
                    col: '#ff8080',
                    dmg: 40 * p.dmgMult,
                    pierce: true,
                    life: 0.8
                });
            }
            store.activeEffects.push(createEffect("shieldBreak", p.x, p.y));
        }
    }
    
    function stepVoidLaser(dt) {
        const p = store.player;
        
        // Determine range based on phasestriker level
        let maxRange;
        if (p.phasestRikerLevel >= 1) {
            // Level 1+: Global range - can hit anything on screen (unlimited range upgrade)
            maxRange = Math.max(W, H) * 2; // Unlimited range using game dimensions
        } else if (p.phasestRikerLevel >= 0.5) {
            // Base phasestriker: Use voidLaserRange (medium range)
            maxRange = p.voidLaserRange || 250;
        } else {
            // No phasestriker: Default short range
            maxRange = p.r * 12;
        }
        
        // Timer for retargeting - check for new targets every 0.1 seconds
        p.voidLaserRetargetTimer -= dt;
        if (p.voidLaserRetargetTimer <= 0) {
            p.voidLaserRetargetTimer = 0.1;
            
            // Find closest enemy within range
            const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
            let closestTarget = null;
            let closestDistSq = maxRange * maxRange;
            
            allEnemies.forEach(e => {
                const distSq = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                if (distSq < closestDistSq) {
                    closestDistSq = distSq;
                    closestTarget = e;
                }
            });
            
            // Reset ramp time if target changed
            if (closestTarget !== p.voidLaserLastTarget) {
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = closestTarget;
            }
            
            p.voidLaserTarget = closestTarget;
        }
        
        // Apply continuous damage if we have a target
        if (p.voidLaserTarget && !p.voidLaserTarget.dead) {
            // Check if target is still in range
            const distSq = (p.x - p.voidLaserTarget.x) ** 2 + (p.y - p.voidLaserTarget.y) ** 2;
            if (distSq <= maxRange * maxRange) {
                // Increase ramp time for level 2 phasestriker
                if (p.phasestRikerLevel >= 2) {
                    p.voidLaserRampTime += dt;
                }
                
                // Damage timer - apply damage every 0.1 seconds for smooth continuous damage
                p.voidLaserDamageTimer -= dt;
                if (p.voidLaserDamageTimer <= 0) {
                    p.voidLaserDamageTimer = 0.1;
                    
                    // Base damage
                    let damage = 8.5 * p.dmgMult;
                    
                    // Level 2 phasestriker: Ramping damage based on time on target
                    if (p.phasestRikerLevel >= 2) {
                        const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // +80% damage per second
                        damage *= Math.min(rampMultiplier, 4.0); // Cap at 4x damage
                    }
                    
                    // Level 4 phasestriker: Double Long Range Intensifying Beam - double damage with intensification
                    if (p.phasestRikerLevel >= 4 && p.doubleBeam) {
                        damage *= 2; // Double beam doubles the damage
                        // Additional intensification over time
                        if (p.beamIntensifyRate && p.voidLaserRampTime > 0) {
                            const intensifyMultiplier = 1 + (p.voidLaserRampTime * p.beamIntensifyRate);
                            damage *= Math.min(intensifyMultiplier, 2.0); // Cap at 2x additional intensification
                        }
                    }
                    
                    if (p.voidLaserTarget === store.boss) damage *= 0.4; // Reduced damage to boss
                    
                    const voidLaserVuln = applySubclassVulnerability(p.voidLaserTarget, damage, {
                        subclass: p.subclass,
                        player: p,
                        damageTags: ['void', 'magic'],
                        source: 'voidLaser',
                        baseDamage: damage
                    });
                    damage = voidLaserVuln.damage;

                    p.voidLaserTarget.hp -= damage;
                    store.world.totalDamage += damage;
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.1); // Minimum heal
                        healAmount = Math.min(healAmount, 0.6); // Increased heal cap slightly
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            } else {
                // Target out of range
                p.voidLaserTarget = null;
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = null;
            }
        } else {
            // No target or target dead - reset ramp
            p.voidLaserTarget = null;
            p.voidLaserRampTime = 0;
            p.voidLaserLastTarget = null;
        }
    }
    
    function stepWiperLasers(dt) {
        const p = store.player;
        const time = performance.now() / 1000;
        
        // Initialize wiper laser blur tracking if needed
        if (!p.wiperLaserBlurTrail) p.wiperLaserBlurTrail = [];
        
        // Different behavior during blink slash vs normal mode
        if (p.isBlinkSlashing) {
            // SLASH MODE: Focused, dramatic blade-like movement
            const slashSpeed = 4.5; // Faster, more dramatic during slash
            const slashRange = Math.PI; // Wider sweep range (Â±180Â°)
            
            // Create synchronized slashing motion
            const slashPhase = time * slashSpeed;
            p.wiperLaser1Angle = Math.sin(slashPhase) * slashRange * 0.5;
            p.wiperLaser2Angle = p.wiperLaser1Angle + Math.PI; // Opposite side
            
            // Add motion blur during slash
            p.wiperLaserBlurTrail.unshift({
                angle1: p.wiperLaser1Angle,
                angle2: p.wiperLaser2Angle,
                life: 0.15,
                intensity: 0.8
            });
            
        } else {
            // NORMAL MODE: Ninja-like variable speed movement
            const baseSpeed = 1.8; // Slightly slower for better control
            const speedVariation = 1.2 * Math.sin(time * 2.5) + 0.6 * Math.cos(time * 4.8);
            const currentSpeed = baseSpeed + speedVariation;
            
            // Add occasional direction changes for more dynamic movement
            if (Math.random() < 0.001) { // Less frequent for smoother flow
                p.wiperLaserSpeed *= -1;
            }
            
            // Update wiper laser angles with variable speed
            const adjustedSpeed = p.wiperLaserSpeed * currentSpeed;
            p.wiperLaser1Angle += adjustedSpeed * dt;
            p.wiperLaser2Angle += adjustedSpeed * dt;
            
            // Normal range limits (Â±135Â°)
            const normalRange = Math.PI * 0.75;
            if (p.wiperLaser1Angle > normalRange) {
                p.wiperLaserSpeed = -Math.abs(p.wiperLaserSpeed);
            } else if (p.wiperLaser1Angle < -normalRange) {
                p.wiperLaserSpeed = Math.abs(p.wiperLaserSpeed);
            }
            
            // Keep second laser offset by PI (opposite side)
            p.wiperLaser2Angle = p.wiperLaser1Angle + Math.PI;
            
            // Add subtle motion blur for normal movement
            if (Math.abs(adjustedSpeed) > 2.0) { // Only blur during fast movement
                p.wiperLaserBlurTrail.unshift({
                    angle1: p.wiperLaser1Angle,
                    angle2: p.wiperLaser2Angle,
                    life: 0.08,
                    intensity: 0.3
                });
            }
        }
        
        // Update blur trail
        for (let i = p.wiperLaserBlurTrail.length - 1; i >= 0; i--) {
            p.wiperLaserBlurTrail[i].life -= dt;
            if (p.wiperLaserBlurTrail[i].life <= 0) {
                p.wiperLaserBlurTrail.splice(i, 1);
            }
        }
        
        // Cap blur trail length
        if (p.wiperLaserBlurTrail.length > 8) {
            p.wiperLaserBlurTrail.length = 8;
        }
        
        // Apply damage continuously
        p.wiperLaserDamageTimer -= dt;
        if (p.wiperLaserDamageTimer <= 0) {
            p.wiperLaserDamageTimer = 0.15; // Damage every 0.15 seconds
            
            // Calculate laser endpoints
            const laserLength = 180; // Fixed laser length - matches visual
            const laser1EndX = p.x + Math.cos(p.wiperLaser1Angle) * laserLength;
            const laser1EndY = p.y + Math.sin(p.wiperLaser1Angle) * laserLength;
            const laser2EndX = p.x + Math.cos(p.wiperLaser2Angle) * laserLength;
            const laser2EndY = p.y + Math.sin(p.wiperLaser2Angle) * laserLength;
            
            // Check for enemies hit by laser beams
            const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
            const laserWidth = 20; // Width of laser beam for collision
            
            allEnemies.forEach(enemy => {
                // Check collision with laser 1
                if (isPointNearLine(enemy.x, enemy.y, p.x, p.y, laser1EndX, laser1EndY, laserWidth)) {
                    let damage = 6 * p.dmgMult; // Base wiper laser damage
                    if (enemy === store.boss) damage *= 0.3; // Reduced damage to boss
                    
                    const wiperVuln = applySubclassVulnerability(enemy, damage, {
                        subclass: p.subclass,
                        player: p,
                        damageTags: ['void', 'magic'],
                        source: 'wiperLaser',
                        baseDamage: damage
                    });
                    damage = wiperVuln.damage;
                    
                    enemy.hp -= damage;
                    store.world.totalDamage += damage;
                    
                    // Apply vampirism healing
                    if (p.vampirism > 0) {
                        let healAmount = damage * p.vampirism;
                        healAmount = Math.max(healAmount, 0.1);
                        healAmount = Math.min(healAmount, 0.4);
                        p.hp = Math.min(p.hpMax, p.hp + healAmount);
                    }
                }
                
                // Check collision with laser 2
                if (isPointNearLine(enemy.x, enemy.y, p.x, p.y, laser2EndX, laser2EndY, laserWidth)) {
                    let damage = 6 * p.dmgMult; // Base wiper laser damage
                    if (enemy === store.boss) damage *= 0.3; // Reduced damage to boss
                    
                    const wiperVuln = applySubclassVulnerability(enemy, damage, {
                        subclass: p.subclass,
                        player: p,
                        damageTags: ['void', 'magic'],
                        source: 'wiperLaser',
                        baseDamage: damage
                    });
                    damage = wiperVuln.damage;
                    
                    enemy.hp -= damage;
                    store.world.totalDamage += damage;
                    
                    // Apply vampirism healing
                    if (p.vampirism > 0) {
                        let healAmount = damage * p.vampirism;
                        healAmount = Math.max(healAmount, 0.1);
                        healAmount = Math.min(healAmount, 0.4);
                        p.hp = Math.min(p.hpMax, p.hp + healAmount);
                    }
                }
            });
        }
    }
    
    // Helper function to check if a point is near a line segment
    function isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        
        if (lenSq === 0) return Math.sqrt(A * A + B * B) <= threshold;
        
        let param = dot / lenSq;
        param = Math.max(0, Math.min(1, param));
        
        const xx = x1 + param * C;
        const yy = y1 + param * D;
        
        const dx = px - xx;
        const dy = py - yy;
        
        return Math.sqrt(dx * dx + dy * dy) <= threshold;
    }
    
    function fireChainLightning() {
        const p = store.player;
        
        if (p.stormstrikerLevel >= 3) {
            // Level 3: Fire four simultaneous chain lightning bolts from all positions (Thunder Lord)
            const positions = [
                { x: p.x - 25, y: p.y - 15 }, // Far left
                { x: p.x - 8, y: p.y - 8 },  // Left wing
                { x: p.x + 8, y: p.y - 8 },  // Right wing  
                { x: p.x + 25, y: p.y - 15 } // Far right
            ];
            
            // Fire all four bolts simultaneously
            positions.forEach(pos => {
                fireChainLightningBolt(1.0, pos);
            });
        } else if (p.stormstrikerLevel >= 2) {
            // Level 2: Fire simultaneous twin lightning from both wing guns
            const leftWing = { x: p.x - 18, y: p.y - 8 };
            const rightWing = { x: p.x + 18, y: p.y - 8 };
            fireChainLightningBolt(1.0, leftWing);
            fireChainLightningBolt(1.0, rightWing);
        } else if (p.hasHybridVoid) {
            // Fire single lightning bolt (reduced power for hybrid)
            fireChainLightningBolt(0.7); // 70% damage for hybrid mode
        } else {
            // Standard single chain lightning from ship center (default stormcaller)
            fireChainLightningBolt();
        }
    }
    
    function fireChainLightningBolt(damageMultiplier = 1.0, startPos = null) {
        const p = store.player;
        const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
        if (allEnemies.length === 0) return;

        // Use custom start position or default to center above player
        const startPoint = startPos || { x: p.x, y: p.y - 20 };

        let closestDistSq = Infinity;
        let currentTarget = null;
        allEnemies.forEach(e => {
            const distSq = (startPoint.x - e.x)**2 + (startPoint.y - e.y)**2;
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                currentTarget = e;
            }
        });

        if (!currentTarget) return;

        const maxJumps = 100; // High limit for unlimited potential with probabilistic limiting
        const chainChance = 0.65; // 65% chance to chain each jump
        let currentDamage = 95 * p.dmgMult * damageMultiplier * (p.chainLightningDamage || 1.0);
        const targetsHit = new Set();
        const chainPoints = [startPoint];

        for (let i = 0; i < maxJumps && currentTarget; i++) {
            targetsHit.add(currentTarget);
            chainPoints.push({ x: currentTarget.x, y: currentTarget.y });

            // Create blue lightning flash at hit point
            store.activeEffects.push(createEffect('lightningFlash', currentTarget.x, currentTarget.y));

            let dmg = currentDamage;
            if (currentTarget === store.boss) dmg *= 0.3;
            const lightningResult = applySubclassVulnerability(currentTarget, dmg, {
                subclass: store.player.subclass,
                player: store.player,
                damageTags: ['lightning', 'magic'],
                source: 'chainLightning',
                baseDamage: dmg
            });
            dmg = lightningResult.damage;
            currentTarget.hp -= dmg;
            store.world.totalDamage += dmg;
            
            // Apply vampirism healing for chain lightning damage
            if (store.player.vampirism > 0) {
                let healAmount = dmg * store.player.vampirism;
                healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for lightning
                healAmount = Math.min(healAmount, 3); // Cap at 3 HP for lightning
                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
            }

            // Check if the lightning should chain (50% chance each jump)
            if (Math.random() >= chainChance) {
                // Chain failed - stop here
                break;
            }

            // Find next target for chaining
            let nextTarget = null;
            let nextDistSq = Infinity;
            allEnemies.forEach(e => {
                if (e.dead || targetsHit.has(e)) return;
                const distSq = (currentTarget.x - e.x)**2 + (currentTarget.y - e.y)**2;
                if (distSq < nextDistSq) {
                    nextDistSq = distSq;
                    nextTarget = e;
                }
            });

            // If no valid target found, stop chaining
            if (!nextTarget) break;

            currentTarget = nextTarget;
            currentDamage *= 0.85; // Slightly less decay since we have probabilistic limiting
        }

        if (chainPoints.length > 1) {
            store.lightningBolts.push({
                points: chainPoints,
                life: 0.4,
                maxLife: 0.4,
                dead: false
            });
        }
    }
    
    const VOIDSTEP = {
        cooldownMs: 2500,
        iframeMs: 450,
        riftMs: 600,
        edgePadding: 6
    };
    let lastVoidStep = -9999;
    let invulUntil = 0;
    const rifts = [];
    const blinkFlashes = [];

        // Ensure the result is never NaN
    
    function spawnBlinkFlash(x, y, life=200){ blinkFlashes.push({x, y, life, birth: performance.now(), dead:false}); }
    function spawnRift(x1,y1,x2,y2, life=VOIDSTEP.riftMs){
        rifts.push({ x1,y1,x2,y2, birth: performance.now(), life, dead:false });
    }

function executeBlinkLineDamage(player, start, end, damageMultiplier = 1) {
    if (!player || !player.blinkDamage) return;

    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const distSq = dx * dx + dy * dy;
    if (distSq <= 0.001) return;

    const baseDamage = (player.blinkDamageEnhanced ? 200 : 150) * player.dmgMult * damageMultiplier;

    store.enemies.forEach(e => {
        if (e.dead) return;
        const dot = (((e.x - start.x) * dx) + ((e.y - start.y) * dy)) / distSq;
        if (dot <= 0 || dot >= 1) return;

        const closestX = start.x + dot * dx;
        const closestY = start.y + dot * dy;
        const distToLine = Math.sqrt((e.x - closestX) ** 2 + (e.y - closestY) ** 2);
        if (distToLine > e.r + 10) return;

        e.hp -= baseDamage;
        store.world.totalDamage += baseDamage;

        if (player.vampirism > 0) {
            let healAmount = baseDamage * player.vampirism;
            healAmount = Math.max(healAmount, 1);
            healAmount = Math.min(healAmount, 6);
            player.hp = Math.min(player.hpMax, player.hp + healAmount);
        }
    });
}

function clampToField(nx, ny){
    const pad = VOIDSTEP.edgePadding;
    nx = Math.max(pad, Math.min(W - pad, nx));
    ny = Math.max(pad, Math.min(H - pad, ny));
    return { nx, ny };
}

function tryVoidStep(player, target, now = performance.now()){
    const cd = VOIDSTEP.cooldownMs;
    if (now - lastVoidStep < cd) return false;

    const start = { x: player.x, y: player.y };
    let { nx, ny } = clampToField(target.x, target.y);

    if (player.blinkDamage) {
        executeBlinkLineDamage(player, start, { x: nx, y: ny });
    }

    spawnRift(start.x, start.y, nx, ny, VOIDSTEP.riftMs);

    player.x = nx; player.y = ny;

    if (typeof mouse !== 'undefined' && !document.body.classList.contains('mobile-controls-active')) {
        mouse.x = nx;
        mouse.y = ny;
    }
    invulUntil = now + VOIDSTEP.iframeMs;
    lastVoidStep = now;

    // Phasestriker mastery: Time ripple explosion at destination
    if (player.blinkDamageEnhanced) {
        // Create time ripple explosion effect
        store.activeEffects.push(createEffect("timeRippleExplosion", nx, ny));
        
        // Damage enemies in explosion radius
        const explosionRadius = 80;
        const explosionDamage = 120 * player.dmgMult;
        const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
        targets.forEach(e => {
            if (e.dead) return;
            const distSq = (e.x - nx)**2 + (e.y - ny)**2;
            if (distSq < explosionRadius**2) {
                e.hp -= explosionDamage;
                store.world.totalDamage += explosionDamage;
            }
        });
    }

    // Impact shockwave for earthquake enhancement
    if (player.hasImpactPhase) {
        createImpactShockwave(nx, ny, player.dmgMult);
    }

    spawnBlinkFlash(nx, ny);
    return true;
}
function performBlinkSlash(player, bullet, now = performance.now()) {
    const cd = VOIDSTEP.cooldownMs;
    if (player.isBlinkSlashing) return false;
    if (now - lastVoidStep < cd) return false;

    const origin = { x: player.x, y: player.y };

    let dirX = -(bullet?.vx || 0);
    let dirY = -(bullet?.vy || 0);
    if (Math.abs(dirX) < 0.001 && Math.abs(dirY) < 0.001 && bullet) {
        dirX = bullet.x - origin.x;
        dirY = bullet.y - origin.y;
    }
    let mag = Math.hypot(dirX, dirY);
    if (mag < 0.001) {
        dirX = 0;
        dirY = -1;
        mag = 1;
    }
    dirX /= mag;
    dirY /= mag;

    const blinkRange = Math.min(player.blinkRange || 250, 320);
    const searchRadius = blinkRange * 1.1;

    const candidates = [];
    store.enemies.forEach(e => {
        if (e.dead) return;
        const dx = e.x - origin.x;
        const dy = e.y - origin.y;
        const distSq = dx * dx + dy * dy;
        if (distSq <= searchRadius * searchRadius) {
            candidates.push({ x: e.x, y: e.y, dist: Math.sqrt(distSq) });
        }
    });

    candidates.sort((a, b) => a.dist - b.dist);
    const maxTargets = 4;
    const selected = candidates.slice(0, maxTargets);
    for (let i = selected.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [selected[i], selected[j]] = [selected[j], selected[i]];
    }

    const slashPoints = selected.map(candidate => {
        const offsetAngle = Math.random() * Math.PI * 2;
        const offsetDist = Math.random() * 35;
        const tx = candidate.x + Math.cos(offsetAngle) * offsetDist;
        const ty = candidate.y + Math.sin(offsetAngle) * offsetDist;
        const clamped = clampToField(tx, ty);
        return { x: clamped.nx, y: clamped.ny };
    });

    if (!slashPoints.length) {
        const fallbackCount = 3;
        for (let i = 0; i < fallbackCount; i++) {
            const angleVariance = (Math.random() - 0.5) * Math.PI * 0.9;
            const baseAngle = Math.atan2(dirY, dirX);
            const angle = baseAngle + angleVariance;
            const dist = blinkRange * (0.35 + Math.random() * 0.4);
            const clampPos = clampToField(
                origin.x + Math.cos(angle) * dist,
                origin.y + Math.sin(angle) * dist
            );
            slashPoints.push({ x: clampPos.nx, y: clampPos.ny });
        }
    }

    const legDelay = 120;
    const initialDelay = 60;
    const totalDuration = initialDelay + legDelay * (slashPoints.length + 1);

    invulUntil = now + VOIDSTEP.iframeMs + totalDuration;
    lastVoidStep = now;
    player.autoBlinkLastTrigger = now;
    player.isBlinkSlashing = true;
    if (bullet) {
        bullet.dead = true;
    }

    spawnBlinkFlash(origin.x, origin.y, 320);

    const runSlashStep = (index, currentPos) => {
        const isReturn = index >= slashPoints.length;
        const dest = isReturn ? origin : slashPoints[index];
        const dx = dest.x - currentPos.x;
        const dy = dest.y - currentPos.y;
        const hasTravel = Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5;

        if (hasTravel) {
            spawnRift(currentPos.x, currentPos.y, dest.x, dest.y, VOIDSTEP.riftMs * 1.5);
            const damageMultiplier = isReturn
                ? (slashPoints.length ? 1.1 : 1.0)
                : (index === 0 ? 1.2 : 1.0);
            executeBlinkLineDamage(player, currentPos, dest, damageMultiplier);
        }

        spawnBlinkFlash(dest.x, dest.y, isReturn ? 340 : 280);
        player.x = dest.x;
        player.y = dest.y;

        if (isReturn) {
            player.isBlinkSlashing = false;
            player.autoBlinkLastTrigger = performance.now();
            invulUntil = performance.now() + VOIDSTEP.iframeMs * 1.2;
            spawnBlinkFlash(origin.x, origin.y, 360);
            return;
        }

        setTimeout(() => runSlashStep(index + 1, dest), legDelay);
    };

    setTimeout(() => runSlashStep(0, origin), initialDelay);
    return true;
}

    const AUTO_BLINK_DEFAULT_LOOKAHEAD = 0.45;
    const AUTO_BLINK_MIN_SPEED = 40;

    function attemptAutoBlink(player, bullet, now = performance.now()) {
        if (!player || !bullet) return false;
        if (!player.autoBlinkEnabled || !player.hasBlink) return false;
        if (player.isBlinkSlashing) return false;
        if (store.isPaused || store.isGameOver) return false;
        if (store.boss && !store.boss.dead) return false;
        if (playerIsInvulnerable()) return false;

        const range = player.autoBlinkRange || Math.max(150, (player.blinkRange || 0) * 0.6);
        const dx = player.x - bullet.x;
        const dy = player.y - bullet.y;
        const distSq = dx * dx + dy * dy;
        if (distSq > range * range) return false;

        const vx = bullet.vx || 0;
        const vy = bullet.vy || 0;
        const speedSq = vx * vx + vy * vy;
        if (speedSq < AUTO_BLINK_MIN_SPEED * AUTO_BLINK_MIN_SPEED) return false;

        const dist = Math.sqrt(distSq) || 1;
        const speed = Math.sqrt(speedSq);
        const approach = vx * dx + vy * dy;
        if (approach <= 0) return false; // Bullet moving away or across

        const lookahead = player.autoBlinkLookahead ?? AUTO_BLINK_DEFAULT_LOOKAHEAD;
        if (dist / speed > lookahead) return false; // Too early to react

        if (player.autoBlinkLastTrigger && now - player.autoBlinkLastTrigger < 200) return false;

        return performBlinkSlash(player, bullet, now);
    }
    
    // Impact shockwave system for earthquake enhancement
    const impactRipples = [];
    
    function createImpactShockwave(x, y, dmgMult) {
        const shockDamage = 200 * dmgMult;  // High impact damage
        const maxRadius = 120;  // Large earthquake radius
        
        // Create expanding ripple effect
        impactRipples.push({
            x: x, y: y,
            radius: 0,
            maxRadius: maxRadius,
            life: 0.8,
            maxLife: 0.8,
            birth: performance.now(),
            dead: false
        });
        
        // Damage all enemies in impact radius
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3; // 30% falloff at edge
                const actualDamage = shockDamage * damageFalloff;
                e.hp -= actualDamage;
                store.world.totalDamage += actualDamage;
                
                // Knockback effect
                if (dist > 0) {
                    const knockbackForce = 200;
                    const knockbackX = (e.x - x) / dist * knockbackForce;
                    const knockbackY = (e.y - y) / dist * knockbackForce;
                    e.knockback = { x: knockbackX, y: knockbackY, duration: 0.3, timer: 0.3 };
                }
            }
        });
        
        // Damage boss if in range
        if (store.boss && !store.boss.dead) {
            const dist = Math.sqrt((store.boss.x - x)**2 + (store.boss.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3;
                const bossDamage = shockDamage * damageFalloff * 0.4;
                store.boss.hp -= bossDamage; // Reduced boss damage
                store.world.totalDamage += bossDamage;
            }
        }
        
        playSound('thunder'); // Play earthquake sound
    }
    
    function updateImpactSystem() {
        const now = performance.now();
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const age = (now - ripple.birth) / 1000; // Convert to seconds
            ripple.radius = (age / ripple.maxLife) * ripple.maxRadius;
            
            if (age >= ripple.maxLife) {
                ripple.dead = true;
            }
        }
        
        // Remove dead ripples
        for (let i = impactRipples.length - 1; i >= 0; i--) {
            if (impactRipples[i].dead) {
                impactRipples.splice(i, 1);
            }
        }
    }
    
    function renderImpactSystem(ctx) {
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const now = performance.now();
            const age = (now - ripple.birth) / 1000;
            const progress = age / ripple.maxLife;
            const alpha = 1.0 - progress; // Fade out over time
            
            ctx.save();
            ctx.globalAlpha = alpha * 0.6;
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;  // Yellow earthquake ripples
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner ripple for more impact
            if (progress < 0.7) {
                ctx.globalAlpha = alpha * 0.4;
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius * 0.6, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    
    function updateVoidStepSystems(enemies){
        for (const r of rifts) if (!r.dead) {
        if(performance.now() - r.birth >= r.life) r.dead = true;
        }
        for (const f of blinkFlashes) if (!f.dead) {
        if(performance.now() - f.birth >= f.life) f.dead = true;
        }
        for (let i=rifts.length-1; i>=0; i--) if (rifts[i].dead) rifts.splice(i,1);
        for (let i=blinkFlashes.length-1; i>=0; i--) if (blinkFlashes[i].dead) blinkFlashes.splice(i,1);
    }

    function renderVoidStepSystems(ctx){
        rifts.forEach(r => {
            const t = (performance.now() - r.birth)/r.life;
            if (t>=1) { r.dead = true; return; }
            const a = (1 - t) * 0.8 + 0.2;
            ctx.save();
            ctx.globalAlpha = a;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 10 * (1-t);
            ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 25 * (1-t);
            ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
            ctx.restore();
        });
        blinkFlashes.forEach(f => {
            const t = (performance.now() - f.birth)/f.life;
            if (t>=1) { f.dead = true; return; }
            ctx.save();
            ctx.globalAlpha = 1 - t;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 4 * (1 - t);
            ctx.shadowColor="#b266ff"; ctx.shadowBlur=20;
            ctx.beginPath();
            ctx.arc(f.x, f.y, 20 + 30 * t, 0, Math.PI*2);
            ctx.stroke();

            ctx.globalAlpha = 1 - t*t;
            ctx.beginPath(); ctx.arc(f.x, f.y, 20 * (1-t), 0, Math.PI*2);
            ctx.fillStyle="#ffddff"; ctx.fill();
            ctx.restore();
        });
    }
    
    function playerIsInvulnerable(){ return performance.now() < invulUntil; }
    
    function screenFlash(count, duration, color) {
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                store.activeEffects.push(createEffect("screenFlash", 0, duration, color));
            }, i * (duration / 2));
        }
    }

    // --- PAUSE & MENU LOGIC ---
    const PANELS = ['namePanel', 'pilotPanel', 'scorePanel', 'levelPanel', 'shopPanel', 'storyPanel', 'subclassPanel', 'teleportTutorialPanel'];
    function isAnyPanelOpen() {
        return PANELS.some(id => !q(id).classList.contains('hide'));
    }
    
    function pauseGame() {
        if (!store.isPaused) {
            store.isPaused = true;
            q('pauseBtn').classList.add('hide');
        }
    }

    function resumeGame() {
        if (!isAnyPanelOpen()) {
            store.isPaused = false;
            q('pauseBtn').classList.remove('hide');
            q('pauseBtn').textContent = 'PAUSE';
        }
    }
    
    // --- EVENT LISTENERS & INITIALIZATION ---
    function showPilotSelect() {
        playSound('epicHorn');
        pauseGame();
        const panel = q('pilotPanel');
        
        panel.classList.remove('hide');
        const cards = panel.querySelectorAll('.skill-card');
        
        const clickHandler = (e) => {
            const card = e.currentTarget;
            const genome = card.dataset.genome;
            store.player.pilotGenome = genome;
            panel.classList.add('hide');
            applyGenomeBonus(genome);
            
            // Spend progression point for successful class selection
            spendProgressionPoint();
            
            // Update mobile controls ability button icon
            updateAbilityButtonIcon();
            
            // Resume game for all genomes (removed teleport tutorial popup)
            resumeGame();
            cards.forEach(c => c.removeEventListener('click', clickHandler));
        };
        
        cards.forEach(card => {
            card.addEventListener('click', clickHandler);
        });
    }

    function showTeleportTutorial() {
        const panel = q('teleportTutorialPanel');
        panel.classList.remove('hide');
        
        // Set up close button handler
        const closeBtn = q('closeTeleportTutorial');
        const closeHandler = () => {
            panel.classList.add('hide');
            closeBtn.removeEventListener('click', closeHandler);
            resumeGame();
        };
        
        closeBtn.addEventListener('click', closeHandler);
    }

    // --- GIBBING EFFECT ---

    // Initialize the gibs array in your game's store
    store.gibs = [];

    /**
     * Spawns a cluster of gib particles at a specific location.
     * Call this function when an enemy dies.
     * @param {number} x - The x-coordinate of the enemy.
     * @param {number} y - The y-coordinate of the enemy.
     * @param {string} color - The base color of the enemy.
     * @param {number} [amount=15] - The number of gibs to create.
     */
    function spawnGibs(x, y, color, amount = 12) {
        for (let i = 0; i < amount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 50 + Math.random() * 150;
            const size = 2 + Math.random() * 4;
            const life = 0.5 + Math.random() * 0.5;

            store.gibs.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                r: size,
                life,
                maxLife: life,
                color,
                gravity: 300, // Pulls gibs downward
            });
        }
    }

    /**
     * Updates the position and lifetime of all active gibs.
     * This should be called once per frame from your main game loop.
     * @param {number} dt - Delta time, the time since the last frame.
     */
    function updateGibs(dt) {
        for (let i = store.gibs.length - 1; i >= 0; i--) {
            const gib = store.gibs[i];
            
            // Apply physics
            gib.vy += gib.gravity * dt;
            gib.x += gib.vx * dt;
            gib.y += gib.vy * dt;
            gib.life -= dt;

            // Remove gibs that have expired
            if (gib.life <= 0) {
                store.gibs.splice(i, 1);
            }
        }
    }

    /**
     * Draws all active gibs to the canvas.
     * This is called from the main render() function.
     * @param {object} ctx - The 2D rendering context of the canvas.
     */
    function drawGibs(ctx) {
        store.gibs.forEach(gib => {
            const alpha = gib.life / gib.maxLife; // Fade out effect
            
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha);
            ctx.fillStyle = gib.color;
            ctx.beginPath();
            ctx.fillRect(gib.x - gib.r / 2, gib.y - gib.r / 2, gib.r, gib.r);
            ctx.restore();
        });
    }

    function applyGenomeBonus(genome) {
        if (!genome) return;

        // Reset all potential subclass stats to their defaults
        const p = store.player;
        p.subclass = null;
        p.beefMaxCharges = 1;
        p.missilePierce = 0;
        p.missileCluster = false;
        p.blinkDamage = false;
        p.hasChainLightning = false;
        p.stormstrikerLevel = 0;
        p.lightningAlternate = false;
        p.lightningCycleIndex = 0;
        p.chainLightningDamage = 1.0;
        p.phasestRikerLevel = 0;
        p.voidLaserRampTime = 0;
        p.voidLaserLastTarget = null;
        p.hasVoidLaser = false;
        p.voidLaserTarget = null;
        p.voidLaserDamageTimer = 0;
        p.voidLaserRetargetTimer = 0;
    p.isBlinkSlashing = false;

        store.world.bossesAtPilotSelection = store.world.bosses;
        
        switch(genome) {
            case 'beef':
                // Base beef no longer gets abilities by default - subclasses must unlock them via skill trees
                break;
            case 'voidmancer':
                // Give +2 multishot base and mild speed boost for base voidmancer
                p.multishot = (p.multishot || 2) + 2; // Base 2 + 2 = 4 bullets total
                p.speed = (p.speed || 2.5) * 1.05; // 5% speed boost
                break;
            case 'rocketman':
                // Rocketman no longer auto-gains the frag launcher; keep any previously unlocked state
                p.hasLauncher = !!p.hasLauncher;
                break;
        }
    }
    
    // 4-Node Skill Tree Data Structure + Separate Class Ability - Single focused path per subclass
    const SKILL_TREE_DATA = {
        // Each subclass gets a focused 4-node skill tree + separate class ability (available immediately)
        marauder: {
            title: 'MARAUDER MASTERY TREE',
            path: {
                name: 'MARAUDER PATH',
                nodes: [
                    { id: 'marauder_multi_charge', name: 'Multi Charge', desc: 'Gain 3 charge attacks with enhanced chain capability', icon: 'mar11.png', tier: 1 },
                    { id: 'marauder_chain_assault', name: 'Chain Assault', desc: 'Keep charge chains active and add +50% chain damage.', icon: 'mar2.png', tier: 2 },
                    { id: 'marauder_combat_mastery', name: 'Combat Mastery', desc: 'Double chain damage bonuses and boost attack speed by 30%.', icon: 'mar3.png', tier: 3 },
                    { id: 'marauder_elite_warrior', name: 'Elite Warrior', desc: 'Unlock 5 charges and elite double-hits that strike for 3x damage.', icon: 'mar4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' },
            crossUnlock: { subclass: 'juggernaut', requiredInvestments: 3 },
            ultimateAbility: { id: 'marauder_clone', name: 'Battle Clone', desc: 'Summon a powerful green clone ally that fights alongside you', icon: 'clone.png', tier: 'ultimate' }
        },
        juggernaut: {
            title: 'JUGGERNAUT MASTERY TREE',
            path: {
                name: 'CHARGE PATH',
                nodes: [
                    { id: 'juggernaut_charge_power', name: 'Charge Power', desc: '+100% charge damage and knockback, +50% charge range', icon: 'jug1.png', tier: 1 },
                    { id: 'juggernaut_charge_mastery', name: 'Charge Mastery', desc: 'Charge creates damaging shockwave, +2 charge capacity', icon: 'jug22.png', tier: 2 },
                    { id: 'juggernaut_heavy_armor', name: 'Heavy Armor', desc: '+50 HP, 25% damage reduction, knockback immunity', icon: 'jug33.png', tier: 3 },
                    { id: 'juggernaut_unstoppable', name: 'Unstoppable Force', desc: '2.5x explosion radius, 3x damage - devastating impact', icon: 'jug4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' },
            crossUnlock: { subclass: 'marauder', requiredInvestments: 3 },
            ultimateAbility: { id: 'juggernaut_clone', name: 'War Clone', desc: 'Summon a powerful green clone ally that fights alongside you', icon: 'clone.png', tier: 'ultimate' }
        },
        railgunner: {
            title: 'RAILGUNNER MASTERY TREE',
            path: {
                name: 'RAILGUN PATH',
                nodes: [
                    { id: 'railgunner_super_pierce', name: 'Super Pierce', desc: 'Missiles pierce 5 enemies with +30% pierce damage', icon: 'one.png', tier: 1 },
                    { id: 'railgunner_perfect_aim', name: 'Perfect Aim', desc: '+25% critical hit chance with +50% accuracy', icon: 'two.png', tier: 2 },
                    { id: 'railgunner_advanced_ballistics', name: 'Advanced Ballistics', desc: 'Pierce 8 enemies with +80% velocity and homing', icon: 'three.png', tier: 3 },
                    { id: 'railgunner_precision_master', name: 'Precision Master', desc: '+50% critical chance, 2x crit damage, and full railgun mastery.', icon: 'four.png', tier: 4 }
                ]
            },
            classAbility: { id: 'firewall_unlock', name: 'FIREWALL', desc: 'UNLOCK: Deployable burning barrier for area control', icon: 'firewall.png', tier: 'class' },
            crossUnlock: { subclass: 'demolitionist', requiredInvestments: 3 },
            ultimateAbility: { id: 'railgunner_stealth_rockets', name: 'Stealth Rockets', desc: 'More badass rockets!', icon: 'badass.png', tier: 'ultimate' }
        },
        demolitionist: {
            title: 'DEMOLITIONIST MASTERY TREE',
            path: {
                name: 'CLUSTER PATH',
                nodes: [
                    { id: 'demolitionist_bigger_clusters', name: 'Bigger Clusters', desc: 'Cluster bombs are 2x larger with increased blast radius', icon: 'demo1.png', tier: 1 },
                    { id: 'demolitionist_cluster_mastery', name: 'Cluster Mastery', desc: 'Clusters split into secondary explosions, +50% cluster count', icon: 'demo2.png', tier: 2 },
                    { id: 'demolitionist_explosive_mastery', name: 'Explosive Mastery', desc: 'Guarantee 12 cluster bombs and chain detonations across explosions.', icon: 'demo3.png', tier: 3 },
                    { id: 'demolitionist_demolition_expert', name: 'Demolition Expert', desc: 'Double cluster blast radius and add a 30% mega explosion chance.', icon: 'demo4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'firewall_unlock', name: 'FIREWALL', desc: 'UNLOCK: Deployable burning barrier for area control', icon: 'firewall.png', tier: 'class' },
            crossUnlock: { subclass: 'railgunner', requiredInvestments: 3 },
            ultimateAbility: { id: 'demolitionist_stealth_rockets', name: 'Stealth Rockets', desc: 'More badass rockets!', icon: 'badass.png', tier: 'ultimate' }
        },
        phasestriker: {
            title: 'PHASESTRIKER MASTERY TREE',
            path: {
                name: 'LASER PATH',
                nodes: [
                    { id: 'phasestriker_unlimited_range', name: 'Unlimited Range', desc: 'Void laser can target enemies anywhere on screen - no range limitations', icon: 'phase1.png', tier: 1 },
                    { id: 'phasestriker_ramping_power', name: 'Ramping Power', desc: 'Laser increases in size and damage each millisecond on the same target', icon: 'phase2.png', tier: 2 },
                    { id: 'phasestriker_dimensional_control', name: 'Dimensional Control', desc: 'Void laser phases through reality with 2.5x damage', icon: 'phase3.png', tier: 3 },
                    { id: 'phasestriker_double_beam', name: 'Double Long Range Intensifying Beam', desc: 'Fires two parallel beams that intensify over time, dealing massive damage', icon: 'phase4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' },
            crossUnlock: { subclass: 'stormcaller', requiredInvestments: 3 },
            ultimateAbility: { id: 'phasestriker_wiper_lasers', name: 'Wiper Lasers', desc: 'Two lasers sweep back and forth like windshield wipers!', icon: 'sweep.png', tier: 'ultimate' }
        },
        stormcaller: {
            title: 'STORMCALLER MASTERY TREE',
            path: {
                name: 'LIGHTNING PATH',
                nodes: [
                    { id: 'stormcaller_chain_boost', name: 'Twin Lightning', desc: 'Alternating left/right wing lightning at double fire rate', icon: 'storm1.png', tier: 1 },
                    { id: 'stormcaller_storm_mastery', name: 'Storm Mastery', desc: '+50% jump range and +80% chain lightning damage', icon: 'storm2.png', tier: 2 },
                    { id: 'stormcaller_thunder_lord', name: 'Thunder Lord', desc: '4 simultaneous lightning bolts from all positions - devastating coverage', icon: 'storm3.png', tier: 3 },
                    { id: 'stormcaller_storm_god', name: 'Storm God', desc: '3x lightning damage multiplier - omnipotent electrical dominance', icon: 'storm4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' },
            crossUnlock: { subclass: 'phasestriker', requiredInvestments: 3 },
            ultimateAbility: { id: 'stormcaller_wiper_lasers', name: 'Wiper Lasers', desc: 'Two lasers sweep back and forth like windshield wipers!', icon: 'sweep.png', tier: 'ultimate' }
        }
    };

    const SUBCLASSES = {
        rocketman: [
            { id: 'railgunner', name: 'Railgunner', desc: 'Missiles pierce through multiple enemies with devastating precision.', icon: 'rail.png' },
            { id: 'demolitionist', name: 'Demolitionist', desc: 'Missiles explode into deadly cluster bombs on impact.', icon: 'demo.png' }
        ],
        beef: [
            { id: 'juggernaut', name: 'juggernaut', desc: 'Charge ability creates a damaging explosion on impact.', icon: 'jug2.png' },
            { id: 'marauder', name: 'Marauder', desc: 'Gain a second charge for your special ability.', icon: 'marauder.png' }
        ],
        voidmancer: [
            { id: 'phasestriker', name: 'Phase Striker', desc: 'Basic short-range void laser that can be upgraded for unlimited range and power.', icon: 'phase.png' },
            { id: 'stormcaller', name: 'Stormcaller', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
        ]
    };

    function showSubclassSelect() {
        pauseGame();
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const skillTree = q('skillTree');
        const genome = store.player.pilotGenome;

        if (!panel || !grid) {
            console.warn('Subclass UI unavailable; skipping selection.');
            resumeGame();
            return;
        }

        // Show traditional card selection for all pilots (including beef)
        const choices = SUBCLASSES[genome];
        if (!choices) {
            resumeGame();
            return;
        }
        if (skillTree) {
            skillTree.classList.add('hide');
        }
        grid.classList.remove('hide');
        panel.classList.remove('skill-tree-active'); // Ensure normal panel size for subclass selection
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-subclass="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const subclassId = card.dataset.subclass;
                store.player.subclass = subclassId;
                applySubclassBonus(subclassId);
                
                // Spend progression point for successful subclass selection
                spendProgressionPoint();
                
                // Update mobile controls ability button icon
                updateAbilityButtonIcon();
                
                panel.classList.add('hide');
                resumeGame();
            }, { once: true });
        });

        const heading = panel.querySelector('h2');
        if (heading) {
            heading.style.display = 'block'; // Show h2 for subclass selection
        }
        panel.classList.remove('hide');
    }

    function showProgressiveSkillTree() {
        showSkillTreeModal();
    }

    function showSkillTreeModal(openedFromForge = false) {
        if (!store.player.pilotGenome || store.player.pilotGenome === 'pending') {
            return;
        }

        const panel = q('subclassPanel');
        if (!panel) {
            console.warn('Skill tree panel unavailable; skipping modal open.');
            resumeGame();
            return;
        }

        const grid = q('subclassGrid');
        let skillTree = q('skillTree');

        window.skillTreeOpenedFromForge = openedFromForge;

        if (!openedFromForge) {
            playSound('epicHorn');
        }

        pauseGame();

        if (grid) {
            grid.classList.add('hide');
        }

        if (!skillTree) {
            skillTree = document.createElement('div');
            skillTree.id = 'skillTree';
            panel.appendChild(skillTree);
        } else if (!panel.contains(skillTree)) {
            panel.appendChild(skillTree);
        }

        skillTree.classList.remove('hide');

        panel.classList.remove('hide');
        panel.classList.add('skill-tree-active');
        panel.scrollTop = 0;

        const heading = panel.querySelector('h2');
        if (heading) {
            if (!panel.dataset.originalHeading) {
                panel.dataset.originalHeading = heading.textContent || '';
            }
            heading.textContent = 'SPECIALIZATION MASTERY';
            heading.style.display = 'block';
        }

        generateDynamicSkillTree();

        const closeBtn = q('skillTreeCloseBtn');
        if (closeBtn) closeBtn.onclick = () => closeSkillTree();
        const closeBottomBtn = q('skillTreeCloseBottomBtn');
        if (closeBottomBtn) closeBottomBtn.onclick = () => closeSkillTree();
    }

    function viewCurrentSkillTree() {
        showSkillTreeModal(true);
    }



    function generateDynamicSkillTree() {
        const skillTreeElement = q('skillTree');
        const genome = store.player.pilotGenome;
        
        // Map pilot genome to default subclass for skill tree display
        let subclass = store.player.subclass;
        if (!subclass) {
            // Default subclass based on genome if none selected
            switch (genome) {
                case 'rocketman': subclass = 'railgunner'; break;
                case 'beef': subclass = 'marauder'; break;
                case 'voidmancer': subclass = 'phasestriker'; break;
                default: 
                    console.error('Unknown pilot genome:', genome);
                    return;
            }
        }
        
        // Get the skill tree data for the current subclass
        const treeData = SKILL_TREE_DATA[subclass];
        if (!treeData) {
            console.error('No skill tree data found for subclass:', subclass);
            return;
        }

        const buildSkillCard = (node, options = {}) => {
            const {
                tier,
                parentId,
                extraClasses = '',
                note = '',
                crossSource,
                crossRequired,
                imageExtraClass = ''
            } = options;

            const escapeAttr = value => String(value).replace(/"/g, '&quot;');

            const classList = ['skill-icon-button', 'locked'];
            if (extraClasses) {
                extraClasses.split(' ').filter(Boolean).forEach(cls => classList.push(cls));
            }

            const tierAttr = tier ? ` data-tier="${tier}"` : '';
            const parentAttr = parentId ? ` data-parent="${parentId}"` : '';
            const crossSourceAttr = crossSource ? ` data-cross-source="${crossSource}"` : '';
            const crossRequiredAttr = crossRequired ? ` data-cross-required="${crossRequired}"` : '';
            const noteAttr = note ? ` data-note="${escapeAttr(note)}"` : '';
            const titleAttr = node.name ? ` data-title="${escapeAttr(node.name)}"` : '';
            const imageClass = `skill-icon-image${imageExtraClass ? ` ${imageExtraClass}` : ''}`;
            const noteHTML = note ? `<div class="skill-info-note">${note}</div>` : '';

            return `
                        <div class="${classList.join(' ')}" data-skill="${node.id}"${tierAttr}${parentAttr}${crossSourceAttr}${crossRequiredAttr}${noteAttr}${titleAttr}>
                            <div class="skill-icon-frame">
                                <img src="${node.icon}" alt="${node.name}" class="${imageClass}">
                            </div>
                            <div class="skill-info-table">
                                <div class="skill-info-row">
                                    <div class="skill-info-label">Ability</div>
                                    <div class="skill-info-value">${node.name}</div>
                                </div>
                                <div class="skill-info-row">
                                    <div class="skill-info-label">Details</div>
                                    <div class="skill-info-value">${node.desc}</div>
                                </div>
                                ${noteHTML}
                            </div>
                        </div>`;
        };
        
        const formatTitle = (text) => {
            if (!text) return '';
            return text
                .replace(/_/g, ' ')
                .toLowerCase()
                .replace(/\b\w/g, char => char.toUpperCase());
        };

        const path = treeData.path;
        const classAbility = treeData.classAbility;
        const crossDetails = getCrossUnlockNode(treeData);
        let crossSummary = '';
        let crossTitle = '';
        if (crossDetails) {
            crossTitle = crossDetails.tree.title ? crossDetails.tree.title.replace(' MASTERY TREE', '').trim() : crossDetails.tree.path.name;
        }
        const friendlyCrossTitle = crossTitle ? formatTitle(crossTitle) : '';
        if (friendlyCrossTitle) {
            crossSummary = ` Unlock your signature ability to cross-train into <strong>${friendlyCrossTitle}</strong>.`;
        }

        const pathCardsHTML = path.nodes.map((node, index) => {
            const card = buildSkillCard(node, {
                tier: `${index + 1}`,
                parentId: index > 0 ? path.nodes[index - 1].id : undefined
            });
            const connector = index < path.nodes.length - 1 ? '<div class="skill-track-connector" aria-hidden="true"></div>' : '';
            return card + connector;
        }).join('');

        const signatureEntries = [];
        if (classAbility) {
            signatureEntries.push({
                node: classAbility,
                options: {
                    tier: 'class',
                    extraClasses: 'class-ability-solo',
                    note: 'Unlock this to access crossover training.',
                    imageExtraClass: 'class-ability'
                }
            });
        }
        if (crossDetails) {
            signatureEntries.push({
                node: crossDetails.node,
                options: {
                    tier: 'cross',
                    parentId: classAbility ? classAbility.id : undefined,
                    extraClasses: 'cross-ability',
                    note: 'Unlocks after mastering your signature ability.',
                    crossSource: crossDetails.config.subclass
                }
            });
        }
        if (treeData.ultimateAbility) {
            const ultimateOptions = {
                tier: 'ultimate',
                parentId: crossDetails ? crossDetails.node.id : 'cross',
                extraClasses: 'ultimate-ability',
                note: crossDetails && friendlyCrossTitle ? `Unlocks once your ${friendlyCrossTitle} crossover is mastered.` : 'Unlocks once crossover training is complete.',
                crossRequired: 'true'
            };
            signatureEntries.push({ node: treeData.ultimateAbility, options: ultimateOptions });
        }

        const signatureCardsHTML = signatureEntries.map((entry, index, arr) => {
            const card = buildSkillCard(entry.node, entry.options);
            const connector = index < arr.length - 1 ? '<div class="skill-track-connector" aria-hidden="true"></div>' : '';
            return card + connector;
        }).join('');

        const subclassTitle = formatTitle(subclass);
        const genomeTitle = formatTitle(store.player.pilotGenome || '') || 'Signature';
        const pathToggleLabel = treeData.toggleLabels?.path || `${subclassTitle} Tree (Main Track)`;
        const signatureToggleLabel = treeData.toggleLabels?.signature || `${genomeTitle} Tree`;

        skillTreeElement.innerHTML = `
            <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
            <div class="skill-tree-title">${treeData.title}</div>
            <div class="skill-view-wrapper">
                <div class="skill-view-toggle" role="group" aria-label="Skill tree view">
                    <button type="button" class="skill-view-btn active" data-view="main">${pathToggleLabel}</button>
                    <button type="button" class="skill-view-btn" data-view="signature">${signatureToggleLabel}</button>
                </div>
            </div>
            <div class="skill-grid" data-active-view="main">
                <div class="skill-row">
                    <div class="skill-track view-main">
                        <div class="track-title">${path.name}</div>
                        ${pathCardsHTML}
                    </div>
                    <div class="skill-track class-ability-track view-signature">
                        <div class="track-title" style="color: #FFD700;">SIGNATURE TRAINING</div>
                        ${signatureCardsHTML}
                    </div>
                </div>
            </div>
            <div class="skill-description" id="skillDescription">
                Master your ${subclass} specialization through focused training. Spend progression points to unlock path upgrades and your signature ability.${crossSummary}
            </div>
            <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;

    initializeSkillTreeViewToggle();
        
        // Initialize skill tree progression
        initializeSkillTree();
    }

    function initializeSkillTreeViewToggle() {
        const skillTreeElement = q('skillTree');
        if (!skillTreeElement) return;

        const grid = skillTreeElement.querySelector('.skill-grid');
        const buttons = skillTreeElement.querySelectorAll('.skill-view-btn');
        if (!grid || buttons.length === 0) return;

        const setActiveView = (view) => {
            const normalized = view === 'signature' ? 'signature' : 'main';
            grid.dataset.activeView = normalized;
            buttons.forEach(btn => {
                const isActive = btn.dataset.view === normalized;
                btn.classList.toggle('active', isActive);
                btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
        };

        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                setActiveView(btn.dataset.view);
            });
        });

        setActiveView('main');
    }
    
    function getActiveSubclassAndTree() {
        const p = store.player;
        let subclass = p.subclass;

        if (!subclass) {
            switch (p.pilotGenome) {
                case 'rocketman':
                    subclass = 'railgunner';
                    break;
                case 'beef':
                    subclass = 'marauder';
                    break;
                case 'voidmancer':
                    subclass = 'phasestriker';
                    break;
                default:
                    console.error('Unknown pilot genome for skill tree:', p.pilotGenome);
                    return { subclass: null, treeData: null };
            }
        }

        const treeData = SKILL_TREE_DATA[subclass];
        if (!treeData) {
            console.error('Missing skill tree data for subclass:', subclass);
            return { subclass: null, treeData: null };
        }

        return { subclass, treeData };
    }

    function getCrossUnlockNode(treeData) {
        if (!treeData || !treeData.crossUnlock) return null;
        const otherTree = SKILL_TREE_DATA[treeData.crossUnlock.subclass];
        if (!otherTree || !otherTree.path || !otherTree.path.nodes || otherTree.path.nodes.length === 0) return null;
        return {
            config: treeData.crossUnlock,
            tree: otherTree,
            node: otherTree.path.nodes[0]
        };
    }

    // Old skill tree code - now commented out as we use dynamic trees
    /*
    function generateOldSkillTree() {
        // Old static skill trees removed - now using SKILL_TREE_DATA structure
    }
            // Create voidmancer skill tree
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
                <div class="skill-tree-title">VOIDMANCER SPECIALIZATION TREE</div>
                <div class="skill-grid">
                    <div class="skill-row">
                        <div class="skill-track">
                            <div class="track-title">PHASE STRIKER</div>
                            <div class="skill-icon-button available" data-skill="phasestriker" data-tier="1">
                                <img src="phase.png" alt="Phase Striker" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">PHASE STRIKER</div>
                                    <div class="skill-overlay-desc">Void manipulation specialist with damaging blink teleportation</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="phasestriker_enhanced" data-tier="2" data-parent="phasestriker">
                                <img src="phase.png" alt="Ramping Laser" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">RAMPING LASER</div>
                                    <div class="skill-overlay-desc">MASTERY: Laser grows in size and damage while fixated on the same target</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">STORMCALLER</div>
                            <div class="skill-icon-button available" data-skill="stormcaller" data-tier="1">
                                <img src="storm.png" alt="Stormcaller" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">STORMCALLER</div>
                                    <div class="skill-overlay-desc">Lightning manipulation specialist with chain lightning weaponry</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="stormcaller_enhanced" data-tier="2" data-parent="stormcaller">
                                <img src="storm.png" alt="Chain Storm" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">CHAIN STORM</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced stormcaller with maximum chain lightning power</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">BLINK ABILITY</div>
                            <div class="skill-icon-button available" data-skill="blink_ability" data-tier="1">
                                <img src="blink.png" alt="Blink Ability" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">BLINK ABILITY</div>
                                    <div class="skill-overlay-desc">Mobility specialist with instant teleportation and damage</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="blink_ability_enhanced" data-tier="2" data-parent="blink_ability">
                                <img src="blink.png" alt="Void Step" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">VOID STEP</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced blink with area damage and faster cooldown</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">VOID LASER</div>
                            <div class="skill-icon-button available" data-skill="void_laser" data-tier="1">
                                <img src="voidlaser.png" alt="Void Laser" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">VOID LASER</div>
                                    <div class="skill-overlay-desc">Energy weapons specialist with focused beam attacks</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="void_laser_enhanced" data-tier="2" data-parent="void_laser">
                                <img src="voidlaser.png" alt="Annihilation Beam" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">ANNIHILATION BEAM</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced void laser with ramping damage and wider beam</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="skill-description" id="skillDescription">
                    Choose your specialization path: Phase Striker for void teleportation, Stormcaller for chain lightning, Blink Ability for mobility, Void Laser for focused damage. Mix and match for powerful combos!
                </div>
                <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        } else {
            // Fallback for unknown pilot types
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
                <div class="skill-tree-title">UNKNOWN PILOT TYPE</div>
                <div class="skill-description" id="skillDescription">
                    Skill tree not available for this pilot type.
                </div>
                <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        }
    }
    
    */
    
    function initializeSkillTree() {
        const p = store.player;
        const { subclass, treeData } = getActiveSubclassAndTree();
        if (!subclass || !treeData) {
            return;
        }

        // Initialize skill tree properties if needed
        if (!p.skillTree) {
            p.skillTree = {};
        }

        ensureSkillTrackingLists();
        const learnedSkillSet = new Set(p.learnedSkills || []);

        // Ensure current subclass nodes exist on the player's skill tree map
        treeData.path.nodes.forEach(node => {
            if (p.skillTree[node.id] === undefined) {
                p.skillTree[node.id] = false;
            }
            if (learnedSkillSet.has(node.id)) {
                p.skillTree[node.id] = true;
            }
        });

        if (p.skillTree[treeData.classAbility.id] === undefined) {
            p.skillTree[treeData.classAbility.id] = false;
        }
        if (learnedSkillSet.has(treeData.classAbility.id)) {
            p.skillTree[treeData.classAbility.id] = true;
        }

        const crossDetails = getCrossUnlockNode(treeData);
        if (crossDetails && p.skillTree[crossDetails.node.id] === undefined) {
            p.skillTree[crossDetails.node.id] = false;
        }
        if (crossDetails && learnedSkillSet.has(crossDetails.node.id)) {
            p.skillTree[crossDetails.node.id] = true;
        }

        if (treeData.ultimateAbility) {
            const ultimateId = treeData.ultimateAbility.id;
            if (p.skillTree[ultimateId] === undefined) {
                p.skillTree[ultimateId] = false;
            }
            if (learnedSkillSet.has(ultimateId)) {
                p.skillTree[ultimateId] = true;
            }
        }
        
    if (!p.skillTreeProgress) p.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
    if (typeof p.skillPoints !== 'number') p.skillPoints = 0;
    if (typeof p.skillPointsSpent !== 'number') p.skillPointsSpent = 0;
        
        // Don't award skill points here - they're awarded in handleBossDefeat
        // Just update the UI with whatever points we have
        updateSkillTreeUI();
        setupSkillTreeHandlers();
    }
    
    function updateSkillTreeUI() {
        const p = store.player;
        const panel = q('subclassPanel');
        
        // Early return if skill tree panel is not visible - major performance optimization
        if (!panel || panel.classList.contains('hide') || !panel.classList.contains('skill-tree-active')) {
            return;
        }
        
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        
        // Update button states first, regardless of whether tree will close
        iconButtons.forEach(button => {
            const skill = button.dataset.skill;
            const tierRaw = button.dataset.tier;
            let tier;
            if (tierRaw === 'class') {
                tier = 'class';
            } else if (tierRaw === 'cross') {
                tier = 'cross';
            } else if (tierRaw === 'ultimate') {
                tier = 'ultimate';
            } else {
                tier = parseInt(tierRaw, 10);
            }
            const parent = button.dataset.parent;
            
            // Remove all state classes
            button.classList.remove('available', 'active', 'locked');
            
            if (p.skillTree && p.skillTree[skill]) {
                // Skill is learned - show active glow effect
                button.classList.add('active');
            } else if (canLearnSkill(skill, tier, parent)) {
                // Skill can be learned - show available state
                button.classList.add('available');
            } else {
                // Skill is locked - show dim state
                button.classList.add('locked');
            }
        });
        
        // Update skill description based on progression state
        const skillDescription = document.getElementById('skillDescription');
        const unspentProgPts = p.unspentProgressionPoints || 0;
        const skillPointsSpent = p.skillPointsSpent || 0;

        const { treeData } = getActiveSubclassAndTree();
        const pathNodes = treeData && Array.isArray(treeData.path?.nodes) ? treeData.path.nodes : [];
        const unlockedPathNodes = pathNodes.filter(node => p.skillTree && p.skillTree[node.id]).length;
        const signatureId = treeData && treeData.classAbility ? treeData.classAbility.id : null;
        const signatureUnlocked = signatureId ? !!(p.skillTree && p.skillTree[signatureId]) : false;
        const crossDetails = treeData ? getCrossUnlockNode(treeData) : null;
        const crossTitle = crossDetails ? (crossDetails.tree.title ? crossDetails.tree.title.replace(' MASTERY TREE', '').trim() : crossDetails.tree.path.name) : '';
        const crossUnlocked = crossDetails ? !!(p.skillTree && p.skillTree[crossDetails.node.id]) : false;
        const ultimateAbility = treeData ? treeData.ultimateAbility : null;
        const ultimateUnlocked = ultimateAbility ? !!(p.skillTree && p.skillTree[ultimateAbility.id]) : false;

        const statusLines = [];
        if (pathNodes.length) {
            statusLines.push(`<div class="skill-status-line">Path progress: <strong>${unlockedPathNodes}/${pathNodes.length}</strong></div>`);
        }
        if (signatureId) {
            statusLines.push(`<div class="skill-status-line">Signature ability: <strong>${signatureUnlocked ? 'Unlocked' : 'Locked'}</strong></div>`);
        }
        if (crossDetails) {
            const crossStateText = crossUnlocked
                ? `${crossTitle} active`
                : signatureUnlocked
                    ? `${crossTitle} available`
                    : 'Locked â€” master your signature ability first';
            statusLines.push(`<div class="skill-status-line">Crossover: <strong>${crossStateText}</strong></div>`);
        }
        if (ultimateAbility) {
            statusLines.push(`<div class="skill-status-line">Ultimate ability: <strong>${ultimateUnlocked ? 'Ready' : 'Locked'}</strong></div>`);
        }

        if (skillDescription) {
            const statusMarkup = statusLines.join('');
            if (unspentProgPts === 0) {
                skillDescription.innerHTML = `
                    <div class="skill-status-heading readonly">Read-only overview</div>
                    <div class="skill-status-body">Defeat bosses to earn specialization points, then invest them to advance your path.</div>
                    ${statusMarkup}
                    <div class="skill-status-line">Points spent so far: <strong>${skillPointsSpent}</strong></div>
                `;
            } else {
                skillDescription.innerHTML = `
                    <div class="skill-status-heading">Progression ready</div>
                    <div class="skill-status-body">You have <strong>${unspentProgPts}</strong> specialization point${unspentProgPts !== 1 ? 's' : ''} awaiting assignment.</div>
                    ${statusMarkup}
                `;
            }
            skillDescription.dataset.defaultDescription = skillDescription.innerHTML;
        }

        const availableNodes = Array.from(iconButtons).some(button => button.classList.contains('available'));
        const openedFromMechForge = window.skillTreeOpenedFromForge;
        if (!unspentProgPts && !availableNodes && !openedFromMechForge) {
            const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
            setTimeout(() => {
                closeSkillTree();
            }, delay);
            return;
        }
        
        // If tree is fully capped, also close it
        if (isSkillTreeFullyCapped()) {
            const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
            setTimeout(() => {
                closeSkillTree();
            }, delay);
            return;
        }
        
        // If 4 skill points have been spent, don't auto-close (allow viewing)
        // const skillPointsSpent = p.skillPointsSpent || 0;
        // if (skillPointsSpent >= 4 && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
        //     setTimeout(() => {
        //         console.log(`Auto-closing skill tree from updateSkillTreeUI - 4 skill points spent (${skillPointsSpent}/4)`);
        //         closeSkillTree();
        //     }, 100);
        //     return;
        // }
    }
    
    function canLearnSkill(skill, tier, parent) {
        const p = store.player;

        // Can't learn a skill that's already learned
        if (p.skillTree && p.skillTree[skill]) return false;

        // Initialize progression tracking
        initializeProgressionTracking();

        const totalUnspentPts = p.unspentProgressionPoints || 0;
        const totalSpentPts = p.skillPointsSpent || 0;

        // NEW PROGRESSION SYSTEM:
        if (tier === 'class') {
            // Signature abilities become available as soon as a progression point is free
            return totalUnspentPts > 0;
        }

        if (tier === 'cross') {
            const hasSignatureUnlocked = parent && p.skillTree && p.skillTree[parent];
            return totalUnspentPts > 0 && !!hasSignatureUnlocked;
        }

        if (tier === 1) {
            // Tier 1 skills: First unlock once a progression point is available
            return totalUnspentPts > 0;
        }

        if (tier === 2) {
            // Tier 2 skills: Need one prior spend and the tier 1 parent
            return totalUnspentPts > 0 && totalSpentPts >= 1 && p.skillTree && p.skillTree[parent];
        }

        if (tier === 3) {
            // Tier 3 skills: Need two prior spends and the tier 2 parent
            return totalUnspentPts > 0 && totalSpentPts >= 2 && p.skillTree && p.skillTree[parent];
        }

        if (tier === 4) {
            // Tier 4 skills: Need three prior spends and the tier 3 parent
            return totalUnspentPts > 0 && totalSpentPts >= 3 && p.skillTree && p.skillTree[parent];
        }

        if (tier === 'ultimate') {
            // Ultimate skills: Need the crossover skill (parent) to be unlocked
            const hasCrossoverUnlocked = parent && p.skillTree && p.skillTree[parent];
            return totalUnspentPts > 0 && !!hasCrossoverUnlocked;
        }
        
        return false;
    }
    
    function setupSkillTreeHandlers() {
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        const description = q('skillDescription');
        if (description) {
            description.dataset.defaultDescription = description.dataset.defaultDescription || description.innerHTML;
        }
        
        // Remove any existing handlers first to prevent duplicates
        iconButtons.forEach(button => {
            button.replaceWith(button.cloneNode(true));
        });
        
        // Re-query after cloning to get fresh elements
        const freshButtons = document.querySelectorAll('.skill-icon-button');
        
        // Updated skill descriptions sourced from tree data + key legacy abilities
        const skillDescriptions = {};
        const addSkillDescription = (id, name, desc) => {
            if (!id || !name || !desc) return;
            skillDescriptions[id] = { name, desc };
        };

        Object.values(SKILL_TREE_DATA).forEach(treeData => {
            if (treeData.path && Array.isArray(treeData.path.nodes)) {
                treeData.path.nodes.forEach(node => {
                    addSkillDescription(node.id, node.name, node.desc);
                });
            }
            if (treeData.classAbility) {
                addSkillDescription(treeData.classAbility.id, treeData.classAbility.name, treeData.classAbility.desc);
            }
            if (treeData.ultimateAbility) {
                addSkillDescription(treeData.ultimateAbility.id, treeData.ultimateAbility.name, treeData.ultimateAbility.desc);
            }
        });

        [
            { id: 'blink_ability', name: 'Blink Assault', desc: 'Unlocks a damaging blink teleport for rapid repositioning.' },
            { id: 'blink_ability_enhanced', name: 'Blink Assault+', desc: 'Enhances blink with wider range, area damage, and faster recharge.' },
            { id: 'void_laser', name: 'Void Laser', desc: 'Activates the void laser beam weapon for precise, sustained damage.' },
            { id: 'void_laser_enhanced', name: 'Void Laser+', desc: 'Supercharges the void laser with ramping power and a wider beam.' },
            { id: 'flame_barrier', name: 'Flame Barrier', desc: 'Deploys a protective wall of fire that scorches incoming threats.' },
            { id: 'flame_barrier_enhanced', name: 'Flame Barrier+', desc: 'Fortifies the flame barrier with explosive retaliation and longer uptime.' },
            { id: 'missile_volley', name: 'Missile Volley', desc: 'Fires a multi-missile salvo for overwhelming burst damage.' },
            { id: 'missile_volley_enhanced', name: 'Missile Volley+', desc: 'Maximizes missile volleys with faster reload and additional rockets.' },
            { id: 'beef_shield', name: 'Beef Shield', desc: 'Activates regenerating armor plating that absorbs incoming damage.' },
            { id: 'beef_shield_enhanced', name: 'Beef Shield+', desc: 'Improves the beef shield with faster regeneration and reflective plating.' },
            { id: 'beef_charge', name: 'Beef Charge', desc: 'Unlocks a devastating beef charge rush attack.' },
            { id: 'beef_charge_enhanced', name: 'Beef Charge+', desc: 'Boosts charge range and impact for unstoppable momentum.' },
            { id: 'firewall_unlock', name: 'Firewall', desc: 'Unlocks the Firewall signature ability for area-denial flame walls.' },
            { id: 'blink_unlock', name: 'Blink', desc: 'Unlocks the Blink signature ability for instantaneous teleportation.' },
            { id: 'beef_shield_unlock', name: 'Beef Shield', desc: 'Unlocks the Beef Shield signature ability for defensive fortification.' }
        ].forEach(entry => addSkillDescription(entry.id, entry.name, entry.desc));

        const defaultDescriptionHTML = description ? (description.dataset.defaultDescription || description.innerHTML) : '';
        
        // Add hover effects to icon buttons
        freshButtons.forEach(button => {
            const skill = button.dataset.skill;
            
            button.addEventListener('mouseenter', () => {
                if (!description) return;
                const info = skillDescriptions[skill];
                const note = button.dataset.note ? `<div class="skill-hover-note">${button.dataset.note}</div>` : '';
                if (info) {
                    description.innerHTML = `
                        <div class="skill-hover-title">${info.name}</div>
                        <div class="skill-hover-body">${info.desc}</div>
                        ${note}
                    `;
                } else {
                    const fallbackTitle = button.dataset.title || (button.querySelector('.skill-info-value')?.textContent?.trim() || 'Specialization Node');
                    description.innerHTML = `
                        <div class="skill-hover-title">${fallbackTitle}</div>
                        <div class="skill-hover-body">Review the specialization card for full details.</div>
                        ${note}
                    `;
                }
            });
            
            button.addEventListener('mouseleave', () => {
                if (!description) return;
                const fallback = description.dataset.defaultDescription || defaultDescriptionHTML;
                if (fallback) {
                    description.innerHTML = fallback;
                }
            });
        });
        
        // Click handlers - icon buttons are directly clickable
        freshButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Skill button clicked
                if (button.classList.contains('available')) {
                    const skill = button.dataset.skill;
                    // About to learn skill
                    learnSkill(skill);
                }
            });
        });
    }
    
    let isLearningSkill = false;
    
    function learnSkill(skill) {
        if (isLearningSkill) {
            // Already learning a skill, ignoring duplicate call
            return;
        }
        
        isLearningSkill = true;
        
        try {
            const p = store.player;
            const skillButton = document.querySelector(`[data-skill="${skill}"]`);
            if (!skillButton) {
                console.warn(`Skill button for ${skill} not found.`);
                isLearningSkill = false;
                return;
            }

            const tierRaw = skillButton.dataset.tier;
            let tier;
            if (tierRaw === 'class') {
                tier = 'class';
            } else if (tierRaw === 'cross') {
                tier = 'cross';
            } else if (tierRaw === 'ultimate') {
                tier = 'ultimate';
            } else {
                tier = parseInt(tierRaw, 10);
            }
            const parentId = skillButton.dataset.parent;

            if (!canLearnSkill(skill, tier, parentId)) {
                isLearningSkill = false;
                return;
            }
            
            const spentPoint = spendProgressionPoint();
            if (!spentPoint) {
                isLearningSkill = false;
                return;
            }

            if (!p.skillTree) p.skillTree = {};
            p.skillTree[skill] = true;
            ensureSkillTrackingLists();
            if (!p.learnedSkills.includes(skill)) {
                p.learnedSkills.push(skill);
            }
            if (p.skillPoints > 0) {
                p.skillPoints--;
            }
            p.skillPointsSpent = (p.skillPointsSpent || 0) + 1; // Track total spent
            
            // Handle signature ability flag for class tier skills
            if (tier === 'class') {
                if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
                    p.signatureAbilities = {};
                }
                p.signatureAbilities[skill] = true;
                p.signatureAbility = true;
            }
            
            // Apply the skill effects
            applySkillBonus(skill);
            
            // Check for combo when both base skills are learned
            // Check for combo when both base skills are learned
            const pilotType = p.pilotGenome;
            if (tier === 1) {
                if (pilotType === 'beef' && p.skillTree.marauder && p.skillTree.juggernaut) {
                    p.beefDoubleCharge = true;
                    announce('DOUBLE CHARGE COMBO ACTIVATED!');
                } else if (pilotType === 'rocketman' && p.skillTree.railgunner && p.skillTree.demolitionist) {
                    p.rocketmanHybrid = true;
                    announce('HYBRID MISSILES COMBO ACTIVATED!');
                } else if (pilotType === 'voidmancer' && p.skillTree.phasestriker && p.skillTree.stormcaller) {
                    p.voidmancerHybrid = true;
                    announce('VOID STORM COMBO ACTIVATED!');
                }
            }
            
            updateSkillTreeUI();
            
            // Update remaining skill points display
            
            // Check if tree is now fully capped
            if (isSkillTreeFullyCapped()) {
                const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                setTimeout(() => {
                    closeSkillTree();
                }, delay);
            } else {
                // Check if no progression is available
                const unspentProgPts = p.unspentProgressionPoints || 0;
                const skillPointsSpent = p.skillPointsSpent || 0;
                const hasSignature = p.signatureAbility;
                const canProgress = unspentProgPts > 0 || (!hasSignature && unspentProgPts > 0) || (skillPointsSpent >= 2 && skillPointsSpent < 5);
                
                if (!canProgress) {
                    const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                    setTimeout(() => {
                        closeSkillTree();
                    }, delay);
                }
            }
            // Note: No longer auto-closing when 4 skill points are spent - allow viewing
        } catch (error) {
            console.error('Error in learnSkill:', error);
        } finally {
            isLearningSkill = false;
        }
    }
    
    function closeSkillTree() {
        // Clear the flag for Mech Forge opened skill tree
        window.skillTreeOpenedFromForge = false;

        const panel = q('subclassPanel');
        if (!panel) {
            resumeGame();
            return;
        }

        const skillTree = q('skillTree');
        if (skillTree) {
            skillTree.classList.add('hide');
        }

        if (panel.dataset && panel.dataset.originalHeading) {
            const heading = panel.querySelector('h2');
            if (heading) {
                heading.textContent = panel.dataset.originalHeading;
            }
        }

        panel.classList.add('hide');
        panel.classList.remove('skill-tree-active');
        resumeGame();
    }
    
    function isSkillTreeFullyCapped() {
        const p = store.player;
        const { subclass, treeData } = getActiveSubclassAndTree();

        if (!p.skillTree || !subclass || !treeData) return false;

        const pathNodes = treeData.path.nodes.map(node => node.id);
        const pathComplete = pathNodes.every(skill => p.skillTree[skill] === true);
        if (!pathComplete) return false;

        const crossDetails = getCrossUnlockNode(treeData);
        if (crossDetails && !p.skillTree[crossDetails.node.id]) return false;

        // Check ultimate ability if it exists
        if (treeData.ultimateAbility && !p.skillTree[treeData.ultimateAbility.id]) return false;

        return true;
    }
    
    function ensurePhasestrikerLoadout(p) {
        let newlyUnlocked = false;

        if (!p.hasPhasestriker) {
            p.hasPhasestriker = true;
            newlyUnlocked = true;
        }

        if (!p.hasVoidLaser) {
            p.hasVoidLaser = true;
            newlyUnlocked = true;
        }

        if (p.voidLaserTarget === undefined) {
            p.voidLaserTarget = null;
        }
        if (p.voidLaserDamageTimer === undefined) {
            p.voidLaserDamageTimer = 0;
        }
        if (p.voidLaserRetargetTimer === undefined) {
            p.voidLaserRetargetTimer = 0;
        }

        const baseRange = 250;
        if (!p.voidLaserRange || p.voidLaserRange < baseRange) {
            p.voidLaserRange = baseRange;
        }
        p.phasestRikerLevel = Math.max(p.phasestRikerLevel || 0, 0.5);

        return newlyUnlocked;
    }

    function ensureStormcallerLoadout(p) {
        let newlyUnlocked = false;

        if (!p.hasStormcaller) {
            p.hasStormcaller = true;
            newlyUnlocked = true;
        }

        if (!p.hasChainLightning) {
            p.hasChainLightning = true;
            newlyUnlocked = true;
        }

        if (p.chainLightningCooldown === undefined) {
            p.chainLightningCooldown = 0;
        }

        p.stormstrikerLevel = Math.max(p.stormstrikerLevel || 0, 1);

        return newlyUnlocked;
    }

    function applySkillBonus(skill) {
        const p = store.player;
        
        switch(skill) {


                
            // Tier 2 Enhanced Skills
            case 'marauder_enhanced':
                p.beefMaxCharges = 3;
                p.beefCharges = Math.max(p.beefCharges, 3);
                p.beefChainMode = true; // Enable chain jumping for enhanced marauder
                announce('TRIPLE CHAIN ACTIVATED!');
                break;
            case 'juggernaut_enhanced':
                p.beefBigExplosion = true;
                announce('BIG BANG EXPLOSION ACTIVATED!');
                break;
                

                
            // Rocketman Tier 2 Enhanced Skills
            case 'railgunner_enhanced':
                // Enhanced railgunner should preserve existing abilities
                if (!p.missilePierce) p.missilePierce = 2; // Give basic piercing if they don't have it
                p.missilePierce = Math.max(p.missilePierce, 4);
                announce('SUPER PIERCE ACTIVATED - Maximum Penetration!');
                break;
            case 'demolitionist_enhanced':
                // Enhanced demolitionist should preserve existing abilities
                if (!p.missileCluster) p.missileCluster = true; // Give basic clusters if they don't have them
                p.missileClusterEnhanced = true;
                announce('MEGA CLUSTERS ACTIVATED - Devastating Explosions!');
                break;
                
            // Voidmancer skills  



            case 'railgunner_barrier':
                p.subclass = 'railgunner';
                // Give flame barrier ability
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 8; // 8 seconds
                p.flameBarrierRecharge = 15; // 15 second cooldown
                announce('RAILGUNNER ACTIVATED - Flame Barrier Defense!');
                break;
            case 'demolitionist_barrier':
                p.subclass = 'demolitionist';
                // Give enhanced flame barrier ability
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 12; // Longer duration than railgunner
                p.flameBarrierRecharge = 10; // Faster cooldown than railgunner
                p.flameBarrierExplosive = true; // Explosive reactive damage
                announce('DEMOLITIONIST ACTIVATED - Explosive Flame Wall!');
                break;
                
            // Voidmancer Tier 2 Enhanced Skills
            case 'phasestriker_enhanced':
                p.phasestRikerLevel = 2; // Level 2: Global range + ramping damage/size
                announce('PHASESTRIKER LV2 - Ramping Laser Power!');
                break;
            case 'stormcaller_enhanced':
                p.chainLightningEnhanced = true;
                p.stormstrikerLevel = 2; // Level 2: Twin wing lightning
                announce('STORMSTRIKER LV2 - Twin Wing Lightning!');
                break;
                
            // New Beef Skills
            case 'beef_shield':
                p.beefShieldMax = 100;
                p.beefShield = 100;
                p.beefShieldRegenRate = 5; // Shield per second
                announce('BEEF SHIELD ACTIVATED - Defensive Armor Plating!');
                break;
            case 'beef_shield_enhanced':
                p.beefShieldMax = Math.max(p.beefShieldMax || 100, 200);
                p.beefShield = p.beefShieldMax;
                p.beefShieldRegenRate = 15; // Faster regeneration
                p.beefShieldReflect = true; // Reflect damage back to enemies
                announce('FORTRESS MODE ACTIVATED - Enhanced Defense and Reflection!');
                break;
            case 'beef_charge':
                p.beefChargeState = 'ready';
                p.beefChargeCooldown = 0;
                p.beefChargeSpeed = Math.max(p.beefChargeSpeed || 0, 1.35);
                // Don't reset charges if already have more than 1 (preserve subclass bonuses)
                if (!p.beefMaxCharges || p.beefMaxCharges < 1) {
                    p.beefCharges = 1;
                    p.beefMaxCharges = 1;
                }
                announce('BEEF CHARGE ACTIVATED - Devastating Rush Attack!');
                break;
            case 'beef_charge_enhanced':
                p.beefChargeDamageMultiplier = 2.0; // Double charge damage
                p.beefChargeRange = 1.5; // Increased range
                announce('RAMMING SPEED ACTIVATED - Enhanced Charge Power!');
                break;
                
            // New Rocketman Skills
            case 'flame_barrier':
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 8; // 8 seconds
                p.flameBarrierRecharge = 15; // 15 second cooldown
                announce('FLAME BARRIER ACTIVATED - Burning Protective Field!');
                break;
            case 'flame_barrier_enhanced':
                p.flameBarrierDuration = 12; // Longer duration
                p.flameBarrierRecharge = 10; // Faster cooldown
                p.flameBarrierExplosive = true; // Explosive reactive damage
                announce('INFERNO WALL ACTIVATED - Explosive Reactive Defense!');
                break;
            case 'missile_volley':
                p.missileVolley = Math.max(p.missileVolley || 2, 4);
                announce('MISSILE VOLLEY ACTIVATED - Multi-Missile Salvos!');
                break;
            case 'missile_volley_enhanced':
                p.missileVolley = Math.max(p.missileVolley || 4, 6);
                p.missileReloadBonus = 0.5; // 50% faster reload
                announce('BARRAGE MODE ACTIVATED - Maximum Firepower!');
                break;
                
            // New Voidmancer Skills  
            case 'blink_ability':
                p.blinkDamage = true;
                p.blinkCooldown = 0;
                p.blinkRecharge = 3; // 3 second cooldown
                p.hasBlink = true;
                p.autoBlinkEnabled = true;
                p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 160);
                p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.4);
                p.autoBlinkLastTrigger = 0;
                announce('BLINK ABILITY ACTIVATED - Damaging Teleportation!');
                break;
            case 'blink_ability_enhanced':
                p.blinkDamageEnhanced = true;
                p.blinkRecharge = 2; // Faster cooldown
                p.blinkAreaDamage = true; // Area damage on teleport
                p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 200);
                p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.5);
                announce('VOID STEP ACTIVATED - Enhanced Teleportation Power!');
                break;
            case 'void_laser': {
                const unlocked = ensurePhasestrikerLoadout(p);
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                announce(unlocked ? 'VOID LASER CROSS-TRAINED - Focused Beam Online!' : 'VOID LASER ACTIVATED - Focused Beam Weapon!');
                break;
            }
            case 'void_laser_enhanced':
                ensurePhasestrikerLoadout(p);
                p.voidLaserEnhanced = true;
                p.voidLaserRampingDamage = 1.0; // Starts at 1x, builds up
                p.voidLaserBeamWidth = 2.0; // Wider beam
                announce('ANNIHILATION BEAM ACTIVATED - Ramping Laser Power!');
                break;
                
            // NEW 5-NODE SKILL TREE SKILLS
            // Marauder Tree Skills
            case 'marauder_multi_charge':
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3);
                p.beefCharges = Math.max(p.beefCharges, 3);
                announce('MULTI CHARGE ACTIVATED - Additional Charge Attacks!');
                break;
            case 'marauder_chain_assault':
                p.beefChainMode = true;
                p.beefChainBonus = 1.5; // 50% bonus damage on chain
                announce('CHAIN ASSAULT ACTIVATED - Chain Between Enemies!');
                break;
            case 'marauder_armor_boost':
                p.hpMax += 25;
                p.hp += 25;
                p.damageReduction = (p.damageReduction || 0) + 0.15;
                announce('BATTLE ARMOR ACTIVATED - Enhanced Durability!');
                break;
            case 'marauder_shield_mastery':
                if (p.beefShieldMax) {
                    p.beefShieldRegenRate = (p.beefShieldRegenRate || 5) * 2;
                    p.beefShieldRegenDelay = Math.max((p.beefShieldRegenDelay || 3) - 1, 1);
                }
                announce('SHIELD MASTERY ACTIVATED - Enhanced Shield Regeneration!');
                break;
                
            // Juggernaut Tree Skills
            case 'juggernaut_charge_power':
                p.beefChargeDamage = (p.beefChargeDamage || 1.0) * 2.0; // 100% more damage
                p.beefChargeKnockback = (p.beefChargeKnockback || 1.0) * 2.0; // 100% more knockback
                p.beefChargeRange = (p.beefChargeRange || 1.0) * 1.5; // 50% more range
                announce('CHARGE POWER ACTIVATED - Enhanced Charge Strength!');
                break;
            case 'juggernaut_charge_mastery':
                p.beefChargeShockwave = true; // Charge creates damaging shockwave
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3); // +2 charges
                p.beefCharges = Math.max(p.beefCharges || 0, 3);
                announce('CHARGE MASTERY ACTIVATED - Shockwave & Extra Charges!');
                break;
            case 'juggernaut_speed_boost':
                p.speedMult *= 1.4;
                p.beefChargeSpeed = (p.beefChargeSpeed || 1.0) * 1.6;
                announce('HEAVY MOMENTUM ACTIVATED - Enhanced Speed and Charge!');
                break;
            case 'juggernaut_dash_mastery':
                p.beefKnockbackResistance = true;
                p.beefChargeCooldown = Math.max((p.beefChargeCooldown || 3) - 1, 1);
                announce('UNSTOPPABLE FORCE ACTIVATED - Enhanced Mobility!');
                break;
                
            // Railgunner Tree Skills
            case 'railgunner_super_pierce':
                p.missilePierce = Math.max(p.missilePierce || 1, 5); // Enhance to 5 enemies (from basic)
                p.missilePierceDamage = (p.missilePierceDamage || 1.0) * 1.3;
                announce('SUPER PIERCE ACTIVATED - Enhanced Missile Pierce!');
                break;
            case 'railgunner_perfect_aim':
                p.missileCritChance = (p.missileCritChance || 0) + 0.25;
                p.missileAccuracy = (p.missileAccuracy || 1.0) * 1.5;
                announce('PERFECT AIM ACTIVATED - Enhanced Targeting!');
                break;
            case 'railgunner_flame_mastery':
                p.flameBarrierDamage = (p.flameBarrierDamage || 1.0) * 1.8;
                p.flameBarrierRadius = (p.flameBarrierRadius || 1.0) * 1.4;
                announce('FLAME MASTERY ACTIVATED - Enhanced Fire Power!');
                break;
            case 'railgunner_wall_control':
                p.flameBarrierCount = (p.flameBarrierCount || 1) + 1;
                p.flameBarrierDuration *= 1.5;
                announce('WALL CONTROL ACTIVATED - Advanced Flame Tactics!');
                break;
                
            // Demolitionist Tree Skills
            case 'demolitionist_bigger_clusters':
                // Make cluster bombs 2x larger with increased blast radius
                p.missileClusterSize = (p.missileClusterSize || 1.0) * 2.0;
                p.missileClusterRadius = (p.missileClusterRadius || 1.0) * 2.0;
                announce('BIGGER CLUSTERS ACTIVATED - Massive Cluster Bombs!');
                break;
            case 'demolitionist_cluster_mastery':
                // Clusters split into secondary explosions, +50% cluster count
                p.missileClusterSecondary = true;
                p.missileClusterCount = Math.max(p.missileClusterCount || 4, Math.floor((p.missileClusterCount || 4) * 1.5));
                announce('CLUSTER MASTERY ACTIVATED - Secondary Explosions!');
                break;
            case 'demolitionist_fire_boost':
                p.fireDamageBonus = (p.fireDamageBonus || 1.0) * 2.0;
                p.burnDuration = (p.burnDuration || 3) * 1.5;
                announce('INFERNO BOOST ACTIVATED - Enhanced Fire Damage!');
                break;
            case 'demolitionist_flame_master':
                p.flameBarrierExplosive = true;
                p.flameBarrierReactiveDamage = 150;
                announce('FLAME MASTER ACTIVATED - Explosive Barriers!');
                break;
                
            // Phasestriker Tree Skills
            case 'phasestriker_unlimited_range': {
                const unlocked = ensurePhasestrikerLoadout(p);
                // Remove range limitation from void laser
                p.voidLaserRange = 999999; // Unlimited range - can hit any enemy
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 1); // Ensure level reflects upgrade
                announce(unlocked ? 'VOID LASER CROSS-TRAINED - Unlimited Range Achieved!' : 'UNLIMITED RANGE ACTIVATED - Global Laser Targeting!');
                break;
            }
            case 'phasestriker_ramping_power':
                ensurePhasestrikerLoadout(p);
                // Enable ramping damage/size effect
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 2); // Level 2: Ramping damage/size
                announce('RAMPING POWER ACTIVATED - Growing Laser Strength!');
                break;
            case 'phasestriker_blink_boost':
                ensurePhasestrikerLoadout(p);
                const baseBlinkRange = p.blinkRange || 200;
                p.blinkRange = baseBlinkRange * 1.8;
                p.blinkCooldown = Math.max((p.blinkCooldown || 5) - 2, 1);
                p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, p.blinkRange * 0.7);
                p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.55);
                announce('BLINK BOOST ACTIVATED - Enhanced Teleportation!');
                break;
            case 'phasestriker_phase_mastery':
                ensurePhasestrikerLoadout(p);
                p.blinkDamage = (p.blinkDamage || 50) * 2;
                p.blinkInvulnerable = true; // Brief invulnerability during blink
                announce('PHASE MASTERY ACTIVATED - Dimensional Superiority!');
                break;
                
            // Stormcaller Tree Skills
            case 'stormcaller_chain_boost': {
                const unlocked = ensureStormcallerLoadout(p);
                // Add twin lightning bolts from wing guns
                p.stormstrikerLevel = Math.max(p.stormstrikerLevel, 2); // Twin wing lightning
                announce(unlocked ? 'CHAIN LIGHTNING CROSS-TRAINED - Twin Lightning Ready!' : 'TWIN LIGHTNING ACTIVATED - Dual Chain Lightning!');
                break;
            }
            case 'stormcaller_storm_mastery':
                ensureStormcallerLoadout(p);
                p.chainLightningDamage = (p.chainLightningDamage || 1.0) * 1.8; // 80% damage boost
                p.chainLightningRange = (p.chainLightningRange || 150) * 1.5; // 50% jump range boost
                announce('STORM MASTERY ACTIVATED - Enhanced Range & Power!');
                break;
            case 'stormcaller_warp_boost':
                ensureStormcallerLoadout(p);
                if (!p.blinkRange) p.blinkRange = 200;
                p.blinkRange *= 1.6;
                p.blinkRecharge = Math.max((p.blinkRecharge || 5) - 1.5, 1);
                p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, p.blinkRange * 0.65);
                p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.5);
                announce('WARP BOOST ACTIVATED - Enhanced Teleportation!');
                break;
            case 'stormcaller_void_control':
                ensureStormcallerLoadout(p);
                p.blinkTimeRipple = true;
                p.blinkRippleDamage = 100;
                announce('VOID CONTROL ACTIVATED - Time Ripple Effects!');
                break;
                
            // NEW TIER 3 & 4 SKILLS FOR SINGLE PATH PROGRESSION
            // Marauder Advanced Skills
            case 'marauder_combat_mastery':
                p.beefChainDamageBonus = (p.beefChainDamageBonus || 1.0) * 2.0;
                p.beefAttackSpeed = (p.beefAttackSpeed || 1.0) * 1.3;
                announce('COMBAT MASTERY ACTIVATED - Advanced Assault Techniques!');
                break;
            case 'marauder_elite_warrior':
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 3, 5);
                p.beefCharges = Math.max(p.beefCharges, 5);
                p.beefEliteCombat = true;
                p.marauderDoubleHitBonus = 3.0; // Elite double-hit gives 3x damage instead of 2x
                announce('ELITE WARRIOR ACTIVATED - Peak Marauder Prowess!');
                break;
            case 'marauder_clone':
                p.hasBeefClone = true;
                store.beefClone = { x: p.x, y: p.y + 50, t: 0 };
                announce('BATTLE CLONE ACTIVATED - Green ally summoned!');
                break;
                
            // Juggernaut Advanced Skills
            case 'juggernaut_heavy_armor':
                p.hpMax += 50;
                p.hp += 50;
                p.damageReduction = (p.damageReduction || 0) + 0.25;
                p.knockbackImmunity = true;
                announce('HEAVY ARMOR ACTIVATED - Superior Protection!');
                break;
            case 'juggernaut_unstoppable':
                p.beefExplosionRadius = (p.beefExplosionRadius || 1.0) * 2.5;
                p.beefExplosionDamage = (p.beefExplosionDamage || 1.0) * 3.0;
                p.beefUnstoppableForce = true;
                announce('UNSTOPPABLE FORCE ACTIVATED - Maximum Impact Power!');
                break;
            case 'juggernaut_clone':
                p.hasBeefClone = true;
                store.beefClone = { x: p.x, y: p.y + 50, t: 0 };
                announce('WAR CLONE ACTIVATED - Green ally summoned!');
                break;
                
            // Railgunner Advanced Skills
            case 'railgunner_advanced_ballistics':
                p.missilePierce = Math.max(p.missilePierce || 5, 8);
                p.missileVelocity = (p.missileVelocity || 1.0) * 1.8;
                p.missileHomingStrength = (p.missileHomingStrength || 0.5) * 1.5;
                announce('ADVANCED BALLISTICS ACTIVATED - Superior Missile Technology!');
                break;
            case 'railgunner_precision_master':
                p.missileCritChance = (p.missileCritChance || 0.25) + 0.5;
                p.missileCritDamage = (p.missileCritDamage || 2.0) * 2.0;
                p.railgunMastery = true;
                announce('PRECISION MASTER ACTIVATED - Ultimate Accuracy!');
                break;
                
            // Demolitionist Advanced Skills
            case 'demolitionist_explosive_mastery':
                p.missileClusterCount = Math.max(p.missileClusterCount || 8, 12);
                p.explosionChain = true;
                p.explosionChainCount = 3;
                announce('EXPLOSIVE MASTERY ACTIVATED - Chain Detonations!');
                break;
            case 'demolitionist_demolition_expert':
                p.missileClusterRadius *= 2.0;
                p.megaExplosionChance = 0.3; // 30% chance for mega explosions
                p.demolitionExpert = true;
                announce('DEMOLITION EXPERT ACTIVATED - Maximum Destructive Force!');
                break;
            case 'railgunner_stealth_rockets':
                p.stealthRockets = true;
                p.stealthRocketDamage = 1.25; // 25% damage boost
                p.stealthRocketSpeed = 1.5; // 50% speed boost
                announce('STEALTH ROCKETS ACTIVATED - Advanced Stealth Technology!');
                break;
            case 'demolitionist_stealth_rockets':
                p.stealthRockets = true;
                p.stealthRocketDamage = 1.25; // 25% damage boost
                p.stealthRocketSpeed = 1.5; // 50% speed boost
                announce('STEALTH ROCKETS ACTIVATED - Advanced Stealth Technology!');
                break;
            case 'phasestriker_wiper_lasers':
                p.wiperLasers = true;
                p.wiperLaserCount = 2; // Additional wiper lasers
                playSound('epicHorn'); // Epic activation sound
                announce('WIPER LASERS ACTIVATED - Sweeping Laser Array!');
                break;
            case 'stormcaller_wiper_lasers':
                p.wiperLasers = true;
                p.wiperLaserCount = 2; // Additional wiper lasers
                playSound('epicHorn'); // Epic activation sound
                announce('WIPER LASERS ACTIVATED - Sweeping Laser Array!');
                break;
                
            // Phasestriker Advanced Skills
            case 'phasestriker_dimensional_control':
                p.voidLaserPhase = true;
                p.voidLaserPhaseDamage = 2.5;
                p.dimensionalControl = true;
                announce('DIMENSIONAL CONTROL ACTIVATED - Reality Manipulation!');
                break;
            case 'phasestriker_double_beam':
                // Double Long Range Intensifying Beam - fires two parallel beams with intensifying damage
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 4); // Level 4: Double beam
                p.doubleBeam = true;
                p.beamIntensifyRate = 0.1; // 10% damage increase per second of sustained fire
                p.voidLaserMaxRamp *= 2.0; // Double the ramp potential
                announce('DOUBLE LONG RANGE INTENSIFYING BEAM!');
                break;
                
            // Stormcaller Advanced Skills  
            case 'stormcaller_thunder_lord':
                p.stormstrikerLevel = 3; // 4-bolt lightning storm
                p.lightningStorm = true;
                p.thunderLordPower = true;
                announce('THUNDER LORD ACTIVATED - 4 Simultaneous Bolts!');
                break;
            case 'stormcaller_storm_god':
                p.chainLightningDamage *= 3.0;
                p.stormGodPower = true;
                p.omnipotentLightning = true;
                announce('STORM GOD ACTIVATED - Divine Electrical Mastery!');
                break;
                
            // CLASS ABILITY UNLOCKS (5th node rewards)
            case 'beef_shield_unlock':
                p.beefShieldMax = 150;
                p.beefShield = 150;
                p.beefShieldRegenRate = 8;
                p.beefShieldRegenDelay = 3;
                p.beefShieldDamageDealt = 0; // Track damage dealt for shield charging
                p.beefShieldDamageTaken = 0; // Track damage taken for shield depletion
                p.beefShieldCooldown = 0; // Cooldown after depletion before shield can absorb again
                p.hasBeefShield = true;
                playSound('powerup');
                announce('ðŸ›¡ï¸ BEEF SHIELD UNLOCKED! - Class Ability Activated!');
                break;
            case 'blink_unlock':
                p.hasBlink = true;
                p.blinkRange = 250;
                p.blinkCooldown = 4;
                p.blinkDamage = 75;
                p.autoBlinkEnabled = true;
                p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 190);
                p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.45);
                p.autoBlinkLastTrigger = 0;
                p.isBlinkSlashing = false;
                playSound('powerup');
                announce('âœ¨ BLINK UNLOCKED! - Class Ability Activated!');
                break;
            case 'firewall_unlock':
                p.hasFirewall = true;
                p.firewallDuration = 10;
                p.firewallCooldown = 15;
                p.firewallDamage = 50;
                p.flameWallCooldownMax = 10;
                p.flameWallCooldown = 0;
                p.flameWallActiveDuration = 0.5;
                p.flameWallActiveT = 0;
                p.shipFlameColor = '#ff7b32';
                p.shipHighlightColor = '#ffd166';
                p.flameWallCharge = 0;
                p.flameWallInitialized = false;
                playSound('powerup');
                announce('ðŸ”¥ FIREWALL UNLOCKED! - Class Ability Activated!');
                break;
        }
    }

    function applySubclassBonus(subclass) {
        const p = store.player;

        switch(subclass) {
            case 'railgunner': 
                p.subclass = 'railgunner';
                p.missilePierce = 2;
                announce('RAILGUNNER ACTIVATED - Piercing Missiles!');
                break;
            case 'demolitionist': 
                p.subclass = 'demolitionist';
                p.missileCluster = true;
                announce('DEMOLITIONIST ACTIVATED - Cluster Bombs!');
                break;
            case 'juggernaut': 
                p.subclass = 'juggernaut';
                // Give 2 charges (beef shield must be purchased separately via skill tree)
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                p.beefCharges = Math.max(p.beefCharges, 2);
                announce('JUGGERNAUT ACTIVATED - Enhanced Charges!');
                break;
            case 'marauder': 
                p.subclass = 'marauder';
                // Give 2 charges and enable chain jumping (beef shield must be purchased separately via skill tree)
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);  
                p.beefCharges = Math.max(p.beefCharges, 2);
                p.beefChainMode = true; // Enable chain jumping for marauder
                p.marauderHitTargets = new Set(); // Initialize double-hit tracking
                announce('MARAUDER ACTIVATED - Chain Jumping!');
                break;
            case 'phasestriker': 
                p.subclass = 'phasestriker';
                // Give basic SHORT RANGE void laser as first upgrade
                p.hasVoidLaser = true;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                p.voidLaserRange = 250; // 25% longer base range
                p.phasestRikerLevel = 0.5; // Base phasestriker level (between 0 and 1)
                break;
            case 'stormcaller':
                p.subclass = 'stormcaller';
                // Give basic chain lightning ability
                p.hasChainLightning = true;
                p.chainLightningCooldown = 0;
                break;
            case 'voidmancer':
                p.subclass = 'voidmancer';
                // Base voidmancer bonus applied during genome selection
                break;
        }
        store.world.enemyHealthBonus *= 1.10;
}

    function showSpecSelect(isAdditive = false) {
        pauseGame();
        const panel = q('subclassPanel'); // Reuse the subclass panel
        const grid = q('subclassGrid');
        const p = store.player;
        const genome = p.pilotGenome;
        
        let choices = [];
        
        if (genome === 'rocketman') {
            if (p.subclass === 'demolitionist') {
                if (isAdditive && p.enhancedClusters) {
                    // If they already have enhanced clusters, double current power
                    choices = [{ id: 'double_clusters', name: 'MEGA CLUSTERS', desc: 'Cluster explosions are twice as large and deal massive damage.', icon: 'demo.png' }];
                } else if (isAdditive && p.missilePierce > 0) {
                    // If they have railgunner abilities, give them enhanced clusters
                    choices = [{ id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' }];
                } else {
                    // First spec or missing railgunner - offer both
                    const opts = [
                        { id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' },
                        { id: 'railgunner_pierce', name: 'PIERCING MISSILES', desc: 'Missiles pierce through 3 enemies with devastating force.', icon: 'rail.png' },
                        { id: 'compact_clusters_pierce', name: 'COMPACT PIERCING', desc: 'Smaller clusters but missiles pierce through 2 enemies.', icon: 'rail.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_clusters');
                }
            } else if (p.subclass === 'railgunner') {
                if (isAdditive && p.enhancedPierce) {
                    choices = [{ id: 'mega_pierce', name: 'ULTRA PIERCE', desc: 'Missiles pierce through 6 enemies with increased damage.', icon: 'rail.png' }];
                } else if (isAdditive && p.enhancedClusters) {
                    choices = [{ id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' }];
                } else {
                    const opts = [
                        { id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' },
                        { id: 'cluster_missiles', name: 'CLUSTER MISSILES', desc: 'Missiles explode into smaller cluster bombs.', icon: 'demo.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_pierce');
                }
            }
        } else if (genome === 'voidmancer') {
            // Voidmancer only gets the power they don't have
            if (!p.hasStormcaller && !p.hasPhasestriker) {
                // First spec - let them choose
                choices = [
                    { id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' },
                    { id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                ];
            } else if (!p.hasStormcaller) {
                choices = [{ id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }];
            } else if (!p.hasPhasestriker) {
                choices = [{ id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' }];
            } else {
                // They have both - offer three enhanced void caller options
                choices = [
                    { id: 'double_storm', name: 'TWIN LIGHTNING', desc: 'Fires two chain lightning bolts instead of one.', icon: 'storm.png' },
                    { id: 'hybrid_void', name: 'VOID STORM', desc: 'Voidstep damages enemies + unlocks single lightning bolt.', icon: 'phase.png' },
                    { id: 'impact_phase', name: 'EARTHQUAKE', desc: 'Voidstep creates a massive impact shockwave at destination.', icon: 'void.png' }
                ];
            }
        } else if (genome === 'beef') {
            // Handle beef subclasses similarly
            if (p.subclass === 'juggernaut') {
                choices = [{ id: 'enhanced_juggernaut', name: 'MEGA JUGGERNAUT', desc: 'Massive charge radius and knockback increase.', icon: 'jug2.png' }];
            } else if (p.subclass === 'marauder') {
                choices = [{ id: 'enhanced_marauder', name: 'SHIELD MASTER', desc: 'Charge restores even more shields and grants temporary invulnerability.', icon: 'marauder.png' }];
            }
        }
        
        if (!choices.length) {
            resumeGame();
            return;
        }
        
        const title = isAdditive ? 'ENHANCED SPECIALIZATION' : 'CHOOSE SPECIALIZATION';
        document.querySelector('#subclassPanel h2').textContent = title;
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-spec="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const specId = card.dataset.spec;
                applySpecBonus(specId);
                panel.classList.add('hide');
                resumeGame();
                document.querySelector('#subclassPanel h2').textContent = 'CHOOSE SPECIALIZATION'; // Reset title
            }, { once: true });
        });

        panel.classList.remove('hide');
    }

    // DISABLED: applySpecBonus function for stability  
    function applySpecBonus(specId) {
        const p = store.player;
        
        switch(specId) {
            case 'enhanced_clusters':
                p.enhancedClusters = true;
                announce('ENHANCED CLUSTERS ACTIVATED!');
                break;
            case 'double_clusters':
                // Implement double cluster damage
                announce('MEGA CLUSTERS ACTIVATED!');
                break;
            case 'railgunner_pierce':
                p.missilePierce = 3;
                announce('PIERCING MISSILES ACTIVATED!');
                break;
            case 'compact_clusters_pierce':
                p.missilePierce = 2;
                // Keep clusters small but add pierce
                announce('COMPACT PIERCING ACTIVATED!');
                break;
            case 'enhanced_pierce':
                p.enhancedPierce = true;
                p.missilePierce = Math.max(p.missilePierce, 4); // Ensure at least 4 pierce
                announce('ENHANCED PIERCE ACTIVATED!');
                break;
            case 'mega_pierce':
                p.missilePierce = 6;
                announce('ULTRA PIERCE ACTIVATED!');
                break;
            case 'cluster_missiles':
                p.missileCluster = true;
                announce('CLUSTER MISSILES ACTIVATED!');
                break;
            case 'phasestriker':
                p.hasPhasestriker = true;
                announce('PHASESTRIKER ACTIVATED!');
                break;
            case 'stormcaller':
                p.hasStormcaller = true;
                p.hasChainLightning = true;
                announce('CHAIN LIGHTNING ACTIVATED!');
                playSound('thunder');
                break;
            case 'double_storm':
                p.hasDoubleStorm = true;
                announce('TWIN CHAIN LIGHTNING ACTIVATED!');
                break;
            case 'hybrid_void':
                p.hasHybridVoid = true; 
                p.blinkDamage = true;  // Enable voidstep damage
                announce('VOID STORM ACTIVATED!');
                break;
            case 'impact_phase':
                p.hasImpactPhase = true;
                p.blinkDamage = true;  // Ensure voidstep does damage
                announce('EARTHQUAKE ACTIVATED!');
                break;
            case 'enhanced_storm':
                announce('MEGA STORM ACTIVATED!');
                break;
            case 'enhanced_phase':
                announce('VOID MASTERY ACTIVATED!');
                break;
            case 'enhanced_juggernaut':
                announce('MEGA JUGGERNAUT ACTIVATED!');
                break;
            case 'enhanced_marauder':
                announce('SHIELD MASTER ACTIVATED!');
                break;
        }
    }


    function ensureName(){
        if(!store.name){
            pauseGame();
            const panel = q("namePanel");
            
            panel.classList.remove("hide");
            q("nameInput").value="";
            setTimeout(()=>q("nameInput").focus(),50)
        } else {
            resumeGame();
            if (store.player.pilotGenome === null) {
                initWave();
            }
        }
    }
    
    q("restartBtn").addEventListener("click", resetGame);
    
    q("saveName").addEventListener("click",()=>{const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}});
    
    const closeShopLogic = () => {
        q("shopPanel").classList.add('hide');
        resumeGame();
        const highlighted = document.querySelector('.shop-item.highlight');
        if (highlighted) highlighted.classList.remove('highlight');
        const mechForgeBtn = q('shopBtn');
        if (mechForgeBtn) {
            mechForgeBtn.classList.remove('mech-forge-pulse');
            if (mechForgeBtn._forgePulseTimeout) {
                clearTimeout(mechForgeBtn._forgePulseTimeout);
                mechForgeBtn._forgePulseTimeout = null;
            }
        }
        if (store.world.mechForgePulseTimeout) {
            clearTimeout(store.world.mechForgePulseTimeout);
            store.world.mechForgePulseTimeout = null;
        }
    };
    q("closeShopTopBtn").addEventListener("click", closeShopLogic);
    q("closeShop").addEventListener("click", closeShopLogic);

    q("shopBtn").addEventListener("click", () => {
        if (q('mechForgeMenuPanel').classList.contains('hide')) {
            showMechForgeMenu();
        } else {
            q('mechForgeMenuPanel').classList.add('hide');
            resumeGame();
        }
    });

    const closeScoresLogic = () => { q('scorePanel').classList.add('hide'); resumeGame(); };
    // q("closeScores").addEventListener("click", closeScoresLogic); // Button hidden via CSS
    
    // Mech Forge Menu event listeners
    q("closeMechForgeMenu").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); resumeGame(); });
    q("closeMechForgeMenuBtn").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); resumeGame(); });
    q("openShopFromMenu").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); showShop(); });
    q("openCharacterSheet").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); showCharacterSheet(); });
    q("openSkillTreeReadonly").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); showSkillTreeReadonly(); });
    
    // Character Sheet event listeners
    q("closeCharacterSheet").addEventListener("click", () => { q("characterSheetPanel").classList.add("hide"); resumeGame(); });
    q("closeCharacterSheetBtn").addEventListener("click", () => { q("characterSheetPanel").classList.add("hide"); resumeGame(); });
    
    q("menuBtn").addEventListener("click",()=>{
        if (q('scorePanel').classList.contains('hide')) {
            pauseGame();
            
            q('scorePanel').classList.remove('hide');
        } else {
            closeScoresLogic();
        }
    });

    q("fsEnterBtn").addEventListener('click',()=>{const r=document.documentElement;if(!document.fullscreenElement){if(r.requestFullscreen)r.requestFullscreen();else if(r.webkitRequestFullscreen)r.webkitRequestFullscreen();else if(r.msRequestFullscreen)r.msRequestFullscreen()}else{if(document.exitFullscreen)document.exitFullscreen()}});
    
    q('pauseBtn').addEventListener('click',()=>{
        if(store.isGameOver || isAnyPanelOpen()) return;
        store.isPaused = !store.isPaused;
        q('pauseBtn').textContent = store.isPaused ? 'RESUME' : 'PAUSE';
    });
    
    q('grenadeBtnUI').addEventListener('click',useGrenade);

    /* Commented out for future implementation
    q('storyBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        pauseGame();
        
        q('storyPanel').classList.remove('hide');
    });
    q('storyPanel').addEventListener('click', () => {
        q('storyPanel').classList.add('hide');
        if (!q('pilotPanel').classList.contains('hide')) {
        } else {
            resumeGame();
        }
    });
    */
    
    q("nameInput").addEventListener("keydown",(e)=>{if(e.key==="Enter"){const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}}});

    q("namePanel").addEventListener("click", (e) => {
        if(e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
            q('nameInput').blur();
        }
    });
    
    let cheatCodeBuffer = "";
    let cheatTapCount = 0;
    let lastCheatTap = 0;

    function activateDamageOffCheat() {
        if (store.isDamageOff) return;
        store.isDamageOff = true;
        store.cheatsUsed = true;
        announce('CHEAT: DAMAGE & ABILITIES OFF');

        const p = store.player;
        const propsToDisable = [
            'dmgMult', 'multishot', 'rearMultishot', 'piercing', 'explosive',
            'flamethrowerLevel', 'missileVolley', 'critChance', 'critDamage',
            'hasLauncher', 'hasHounds', 'hasLazarusBeam', 'hasVoidBeam',
            'hasChainLightning', 'hasIceman', 'hasBeefClone', 'blinkDamage', 'missilePierce', 'missileCluster',
            'hasDoubleStorm', 'hasHybridVoid', 'hasImpactPhase'
        ];

        store.savedPlayerState = {};
        propsToDisable.forEach(prop => {
            store.savedPlayerState[prop] = p[prop];
            if (typeof p[prop] === 'number') {
                p[prop] = 0;
            } else if (typeof p[prop] === 'boolean') {
                p[prop] = false;
            }
        });

        store.savedPlayerState.hounds = store.hounds;
        store.hounds = [];
        store.savedPlayerState.iceman = store.iceman;
        store.iceman = null;
        store.savedPlayerState.beefClone = store.beefClone;
        store.beefClone = null;
        store.savedPlayerState.playerChampion = store.playerChampion;
        if (store.playerChampion) {
            store.playerChampion.currentTarget = null;
            store.playerChampion._lastTargetSeen = 0;
        }
        store.savedPlayerState.championMinions = store.championMinions;
        if (Array.isArray(store.championMinions)) {
            store.championMinions.forEach(minion => {
                if (!minion) return;
                minion.currentTarget = null;
                minion._lastTargetSeen = 0;
            });
        }
        store.playerChampion = null;
        store.championMinions = [];
    }

    function deactivateDamageOffCheat() {
        if (!store.isDamageOff || !store.savedPlayerState) return;
        store.isDamageOff = false;
        announce('CHEAT: DAMAGE & ABILITIES ON');

        const p = store.player;
        for (const prop in store.savedPlayerState) {
            if (prop === 'hounds') {
                store.hounds = store.savedPlayerState.hounds;
            } else if (prop === 'iceman') {
                store.iceman = store.savedPlayerState.iceman;
            } else if (prop === 'beefClone') {
                store.beefClone = store.savedPlayerState.beefClone;
            } else if (prop === 'playerChampion') {
                store.playerChampion = store.savedPlayerState.playerChampion || null;
                if (store.playerChampion) {
                    store.playerChampion.state = null;
                    store.playerChampion.dashTimer = 0;
                    store.playerChampion.dashVX = 0;
                    store.playerChampion.dashVY = 0;
                    store.playerChampion.dashHits = null;
                    store.playerChampion.dashCooldownTimer = Math.max(0, store.playerChampion.dashCooldownTimer || 0);
                    store.playerChampion.currentTarget = null;
                    store.playerChampion._lastTargetSeen = 0;
                    store.playerChampion.fireTimer = Math.max(0, store.playerChampion.fireTimer || 0);
                }
            } else if (prop === 'championMinions') {
                const savedMinions = store.savedPlayerState.championMinions;
                store.championMinions = Array.isArray(savedMinions) ? savedMinions : [];
                if (store.playerChampion && store.championMinions.length) {
                    store.championMinions.forEach(minion => {
                        if (!minion) return;
                        minion.dead = false;
                        minion.fireTimer = Math.max(0, minion.fireTimer || 0);
                        minion.currentTarget = null;
                        minion._lastTargetSeen = 0;
                    });
                }
            } else if (p.hasOwnProperty(prop)) {
                p[prop] = store.savedPlayerState[prop];
            }
        }
        
        store.savedPlayerState = null;
}

    function activateSubclassCheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (store.player.subclass) {
            announce("CHEAT FAILED: Subclass already chosen.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO SUBCLASS SELECT');
        showSubclassSelect();
    }
    
    function activateClassCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO CLASS SELECT');
        showPilotSelect();
    }
    
    function activatePowerCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: POWER UP!');
        resetGame();
        store.world.gold = 2000;
        store.player.multishot = 5;
        initWave();
        cheatCodeBuffer = "";
    }

    // ENABLED: Spec2 cheat functions  
    function activateSpec2Cheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (!store.player.subclass) {
            announce("CHEAT FAILED: Choose a Subclass first.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: JUMPING TO SUB2');
        showSpecSelect(true); // true = additive/second spec
    }

    function activateSpeedCheat() {
        // Initialize if not present
        if (!window.gameSpeedMultiplier || window.gameSpeedMultiplier < 1) {
            window.gameSpeedMultiplier = 1;
        }
        
        // Cycle through speed multipliers: 1x -> 2x -> 3x -> 1x
        if (window.gameSpeedMultiplier === 1) {
            window.gameSpeedMultiplier = 2;
            announce('CHEAT: GAME SPEED 2X');
        } else if (window.gameSpeedMultiplier === 2) {
            window.gameSpeedMultiplier = 3;
            announce('CHEAT: GAME SPEED 3X');
        } else {
            window.gameSpeedMultiplier = 1;
            announce('CHEAT: GAME SPEED NORMAL');
        }
        
        store.cheatsUsed = true;
    }

    const SUBCLASS_CHEAT_CODES = {
        jug: { subclass: 'juggernaut', genome: 'beef', label: 'JUGGERNAUT' },
        mar: { subclass: 'marauder', genome: 'beef', label: 'MARAUDER' },
        dem: { subclass: 'demolitionist', genome: 'rocketman', label: 'DEMOLITIONIST' },
        rai: { subclass: 'railgunner', genome: 'rocketman', label: 'RAILGUNNER' },
        pha: { subclass: 'phasestriker', genome: 'voidmancer', label: 'PHASESTRIKER' },
        sto: { subclass: 'stormcaller', genome: 'voidmancer', label: 'STORMCALLER' }
    };

    function clearSubclassEffects() {
        const p = store.player;
        if (!p || !p.subclass) return;

        switch (p.subclass) {
            case 'railgunner':
                p.missilePierce = player_initial_state.missilePierce || 0;
                break;
            case 'demolitionist':
                p.missileCluster = player_initial_state.missileCluster || false;
                break;
            case 'marauder':
                p.beefChainMode = false;
                if (p.marauderHitTargets && typeof p.marauderHitTargets.clear === 'function') {
                    p.marauderHitTargets.clear();
                }
                break;
            case 'phasestriker':
                if (!p.hasPhasestriker) {
                    p.hasVoidLaser = false;
                }
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                p.voidLaserRange = 0;
                break;
            case 'stormcaller':
                if (!p.hasStormcaller) {
                    p.hasChainLightning = false;
                }
                p.chainLightningCooldown = 0;
                break;
        }

        p.subclass = null;
    }

    function activateSubclassOverrideCheat(targetSubclass, requiredGenome, label) {
        const p = store.player;
        if (!p || !p.pilotGenome) {
            announce('CHEAT FAILED: Choose a Pilot first.');
            cheatCodeBuffer = "";
            return;
        }

        if (requiredGenome && p.pilotGenome !== requiredGenome) {
            announce(`CHEAT FAILED: Requires ${requiredGenome.toUpperCase()} pilot.`);
            cheatCodeBuffer = "";
            return;
        }

        store.cheatsUsed = true;

        if (p.subclass === targetSubclass) {
            updateAbilityButtonIcon();
            announce(`CHEAT: ${targetSubclass.toUpperCase()} ALREADY ACTIVE`);
            cheatCodeBuffer = "";
            return;
        }

        clearSubclassEffects();

        const originalEnemyBonus = store.world ? store.world.enemyHealthBonus : null;
        if (label) {
            announce(`CHEAT: ${label} READY`);
        }
        applySubclassBonus(targetSubclass);
        if (store.world && originalEnemyBonus !== null && originalEnemyBonus !== undefined) {
            store.world.enemyHealthBonus = originalEnemyBonus;
        }

        if (targetSubclass === 'marauder' && (!p.marauderHitTargets || typeof p.marauderHitTargets.clear !== 'function')) {
            p.marauderHitTargets = new Set();
        }

        updateAbilityButtonIcon();
        cheatCodeBuffer = "";
    }

    function activateSevenCheat() {
        store.cheatsUsed = true;
        initializeProgressionTracking();

        const pointsGranted = 7;
        for (let i = 0; i < pointsGranted; i++) {
            checkProgressionLogic(true);
        }

        announce(`CHEAT: +${pointsGranted} PROGRESSION POINTS`);
        updateSkillTreeUI();
        cheatCodeBuffer = "";
    }

    q('diagBox').children[0].addEventListener('click', () => {
        const now = performance.now();
        if (now - lastCheatTap > 500) {
            cheatTapCount = 0;
        }
        lastCheatTap = now;
        cheatTapCount++;
        if (cheatTapCount >= 3) {
            activatePowerCheat();
            cheatTapCount = 0;
        }
    });

    addEventListener("keydown", e => {
        const key = e.key.toLowerCase();
        if (document.activeElement.tagName === "INPUT") return;

        if (/[a-z]/.test(key)) {
            cheatCodeBuffer += key;
            if (cheatCodeBuffer.length > 10) {
                cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
            }

            if (cheatCodeBuffer.endsWith('power')) {
                activatePowerCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('off')) {
                activateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('on')) {
                deactivateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('fast')) {
                activateSpeedCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('class')) {
                activateClassCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('sub')) {
                activateSubclassCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('spec2')) {
                activateSpec2Cheat();
                cheatCodeBuffer = "";
            } else {
                const subclassCode = Object.keys(SUBCLASS_CHEAT_CODES).find(code => cheatCodeBuffer.endsWith(code));
                if (subclassCode) {
                    const { subclass, genome, label } = SUBCLASS_CHEAT_CODES[subclassCode];
                    activateSubclassOverrideCheat(subclass, genome, label);
                } else if (cheatCodeBuffer.endsWith('seven')) {
                    activateSevenCheat();
                }
            }
        } else {
            if (key !== ' ' && key !== 'b') {
                cheatCodeBuffer = "";
            }
        }

        if (key === ' ') { e.preventDefault(); useGrenade() }
        if (key === 'escape') { 
            e.preventDefault(); 
            // Close skill tree if it's open
            if (!q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                closeSkillTree();
            }
        }
    });

    let lastTapTime = 0;
    cvs.addEventListener('touchend', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
            const now = performance.now();
            const DOUBLE_TAP_DELAY = 300;
            if (now - lastTapTime < DOUBLE_TAP_DELAY) {
                const p = pointFromEvent(e);
                tryVoidStep(store.player, p);
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: false });

    cvs.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
            const p = pointFromEvent(e);
            tryVoidStep(store.player, p);
        }
    });


    // PERFORMANCE: Enhanced performance monitoring
    let perfFrameCount = 0;
    let perfLastFPSUpdate = 0;
    let perfFPS = 0;
    let perfWorstFrameTime = 0;

    function createPerformanceMetrics() {
        return {
            stepWorldTime: 0,
            renderTime: 0,
            frameTime: 0,
            // New detailed metrics
            hudUpdateTime: 0,
            bulletUpdateTime: 0,
            enemyUpdateTime: 0,
            collisionTime: 0,
            drawCallTime: 0,
            memoryUsage: 0,
            slowFrameCount: 0,
            lastSlowLog: 0,
            activeEnemies: 0,
            activeBullets: 0,
            activeFlames: 0
        };
    }

    let performanceMetrics = createPerformanceMetrics();
    
    // Performance budget alerts
    const PERFORMANCE_BUDGETS = {
        frameTime: 16.67, // 60fps budget
        stepWorld: 8,     // Half frame budget for logic
        render: 4,        // Quarter frame budget for rendering
        hudUpdate: 1      // HUD should be very fast
    };
    
    function setTelemetryEnabled(enabled, forceReset = false) {
        const normalized = !!enabled;
        if (!forceReset && normalized === store.telemetryEnabled) {
            return normalized;
        }

        store.telemetryEnabled = normalized;

        try {
            if (window.localStorage) {
                window.localStorage.setItem('voidTelemetry', normalized ? '1' : '0');
            }
        } catch (err) {
            // Ignore storage access issues
        }

        if (normalized) {
            performanceMetrics = createPerformanceMetrics();
            perfFrameCount = 0;
            perfLastFPSUpdate = performance.now();
            perfWorstFrameTime = 0;
        }

        console.info(`[PERF] Telemetry ${normalized ? 'enabled' : 'disabled'}`);
        return normalized;
    }

    window.enableTelemetry = () => setTelemetryEnabled(true);
    window.disableTelemetry = () => setTelemetryEnabled(false);
    window.toggleTelemetry = () => setTelemetryEnabled(!store.telemetryEnabled);

    setTelemetryEnabled(store.telemetryEnabled, true);

    function frame(now) {
        const telemetryActive = !!store.telemetryEnabled;
        const frameStart = telemetryActive ? performance.now() : 0;
        
        const rawDt = Math.min((now - store.last) / 1000, 0.07);
        const speedMultiplier = window.gameSpeedMultiplier || 1;
        
        // Cap the dt to prevent simulation instability even with speed multiplier
        const dt = Math.min(rawDt * speedMultiplier, 0.1); 
        
        store.last = now;
        
        let stepStart;
        if (telemetryActive) {
            stepStart = performance.now();
        }
        if (!store.isPaused && !store.isGameOver) {
            stepWorld(dt);
        }
        if (telemetryActive && stepStart !== undefined) {
            performanceMetrics.stepWorldTime = performance.now() - stepStart;
        }
        
        let renderStart;
        if (telemetryActive) {
            renderStart = performance.now();
        }
        render(rawDt); // Use original dt for rendering to avoid visual issues
        if (telemetryActive && renderStart !== undefined) {
            performanceMetrics.renderTime = performance.now() - renderStart;
        }

        if (telemetryActive) {
            const currentFrameTime = performance.now() - frameStart;
            if (currentFrameTime > PERFORMANCE_BUDGETS.frameTime) {
                performanceMetrics.slowFrameCount++;
            }

            const frameTime = currentFrameTime;
            performanceMetrics.frameTime = frameTime;
            performanceMetrics.activeEnemies = store.enemies ? store.enemies.length : 0;
            performanceMetrics.activeBullets = store.bullets ? store.bullets.length : 0;
            performanceMetrics.activeFlames = store._activeFlamesCache ? store._activeFlamesCache.length : 0;

            if (frameTime > perfWorstFrameTime) {
                perfWorstFrameTime = frameTime;
            }

            if (frameTime > 33 && (!performanceMetrics.lastSlowLog || now - performanceMetrics.lastSlowLog > 1500)) {
                console.warn(
                    `[PERF] Slow frame ${frameTime.toFixed(1)}ms (logic ${performanceMetrics.stepWorldTime.toFixed(1)}ms, ` +
                    `render ${performanceMetrics.renderTime.toFixed(1)}ms, enemies ${performanceMetrics.activeEnemies}, ` +
                    `bullets ${performanceMetrics.activeBullets}, flames ${performanceMetrics.activeFlames})`
                );
                performanceMetrics.lastSlowLog = now;
            }

            perfFrameCount++;
            if (now - perfLastFPSUpdate > 3000) { // Log every 3 seconds
                perfFPS = Math.round(perfFrameCount / 3);
                perfFrameCount = 0;
                perfLastFPSUpdate = now;

                // Calculate memory usage if available
                if (performance.memory) {
                    performanceMetrics.memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                }
            }
        }
        
        requestAnimationFrame(frame);
        
    }
    
    // Game initialization moved to DOMContentLoaded event
    

    // Optimized Asset Preloader System
    class AssetPreloader {
        constructor() {
            // Prioritized asset groups for progressive loading
            // ASSET GROUPS DISABLED FOR PERFORMANCE TESTING
            this.assetGroups = {
                critical: {
                    images: [], // ['cow.png', 'rockyboy.png', 'goggles.png'], // Pilot selection UI
                    audio: [] // ['Horn.wav', 'epichorntrimmed.m4a'] // Essential UI sounds
                },
                gameplay: {
                    images: [], // ['marauder.png', 'jug2.png', 'phase.png', 'storm.png'], // Subclass icons
                    audio: [] // ['Explosion.m4a', 'thunk.wav', 'cluster.mp3', 'thunder.mp3'] // Core game sounds
                },
                extended: {
                    images: [], // ['mar11.png', 'mar2.png', 'mar3.png', 'mar4.png', 'jug3.png'], // Skill trees
                    audio: [] // ['trap.m4a', 'dogs.m4a', 'charge.m4a', 'beefcharge.m4a', 'shao_kahn.m4a']
                }
            };
            
            this.loadedAssets = new Map(); // Cache for loaded assets
            this.loadingPromises = new Map(); // Prevent duplicate loading
            this.lastUsed = new Map(); // Track usage for cleanup
            this.memoryLimit = 150 * 1024 * 1024; // 150MB memory limit
            this.currentMemoryUsage = 0;
            
            this.loaded = 0;
            this.total = this.getTotalAssetCount();
            this.progress = 0;
        }

        getTotalAssetCount() {
            return Object.values(this.assetGroups).reduce((total, group) => {
                return total + group.images.length + group.audio.length;
            }, 0);
        }

        updateProgress(assetName, category) {
            this.loaded++;
            this.progress = Math.floor((this.loaded / this.total) * 100);
            
            const loadingBar = document.getElementById('loadingBar');
            const loadingText = document.getElementById('loadingText');
            const loadingDetails = document.getElementById('loadingDetails');
            
            if (loadingBar) loadingBar.style.width = this.progress + '%';
            if (loadingText) loadingText.textContent = `Loading Assets... ${this.progress}%`;
            if (loadingDetails) {
                const categoryName = category === 'image' ? 'Visual Assets' : 'Audio Systems';
                loadingDetails.textContent = `${categoryName}: ${assetName}`;
            }

            if (this.loaded >= this.total) {
                setTimeout(() => this.finishLoading(), 500);
            }
        }

        estimateAssetSize(src, type) {
            // Rough size estimates for memory management
            if (type === 'image') {
                // Estimate based on typical icon sizes: 64x64 = 16KB, 128x128 = 64KB
                return src.includes('skill') || src.includes('tree') ? 16384 : 32768;
            } else if (type === 'audio') {
                // Audio files typically 50KB-500KB
                return src.includes('.m4a') ? 200000 : 100000;
            }
            return 50000; // Default estimate
        }

        cleanupUnusedAssets() {
            // Skip cleanup if we're under memory pressure threshold (75% of limit)
            if (this.currentMemoryUsage < this.memoryLimit * 0.75) {
                return;
            }

            const now = Date.now();
            const cleanupThreshold = 300000; // 5 minutes
            let cleanedMemory = 0;
            const assetsToCleanup = [];

            // Batch identify assets for cleanup to avoid iteration issues
            for (const [key, timestamp] of this.lastUsed) {
                if (now - timestamp > cleanupThreshold && this.loadedAssets.has(key)) {
                    assetsToCleanup.push(key);
                }
            }

            // Prioritize cleanup of largest assets first
            assetsToCleanup.sort((a, b) => {
                const sizeA = this.estimateAssetSize(a, this.loadedAssets.get(a) instanceof Image ? 'image' : 'audio');
                const sizeB = this.estimateAssetSize(b, this.loadedAssets.get(b) instanceof Image ? 'image' : 'audio');
                return sizeB - sizeA;
            });

            // Clean up assets
            assetsToCleanup.forEach(key => {
                const asset = this.loadedAssets.get(key);
                const estimatedSize = this.estimateAssetSize(key, asset instanceof Image ? 'image' : 'audio');
                
                this.loadedAssets.delete(key);
                this.lastUsed.delete(key);
                this.loadingPromises.delete(key); // Also clean up loading promises
                this.currentMemoryUsage -= estimatedSize;
                cleanedMemory += estimatedSize;
            });


        }

        loadAssetGroup(groupName) {
            return new Promise((resolve) => {
                const group = this.assetGroups[groupName];
                if (!group) {
                    resolve();
                    return;
                }

                const allAssets = [...group.images.map(src => ({src, type: 'image'})), 
                                ...group.audio.map(src => ({src, type: 'audio'}))];
                
                if (allAssets.length === 0) {
                    resolve();
                    return;
                }

                let loadedCount = 0;
                const timeout = setTimeout(() => {
                    console.warn(`${groupName} group loading timeout - continuing anyway`);
                    resolve();
                }, 8000);

                allAssets.forEach(({src, type}) => {
                    this.loadSingleAsset(src, type).then(() => {
                        loadedCount++;
                        this.updateProgress(src, type);
                        if (loadedCount === allAssets.length) {
                            clearTimeout(timeout);
                            resolve();
                        }
                    }).catch(() => {
                        loadedCount++;
                        this.updateProgress(src, type);
                        if (loadedCount === allAssets.length) {
                            clearTimeout(timeout);
                            resolve();
                        }
                    });
                });
            });
        }

        loadSingleAsset(src, type) {
            // Check if already loaded or loading
            if (this.loadedAssets.has(src)) {
                this.lastUsed.set(src, Date.now());
                return Promise.resolve(this.loadedAssets.get(src));
            }
            
            if (this.loadingPromises.has(src)) {
                return this.loadingPromises.get(src);
            }

            // Check memory limit before loading
            const estimatedSize = this.estimateAssetSize(src, type);
            if (this.currentMemoryUsage + estimatedSize > this.memoryLimit) {
                this.cleanupUnusedAssets();
            }

            const promise = new Promise((resolve, reject) => {
                if (type === 'image') {
                    const img = new Image();
                    img.onload = () => {
                        this.loadedAssets.set(src, img);
                        this.lastUsed.set(src, Date.now());
                        this.currentMemoryUsage += estimatedSize;
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load image: ${src}`);
                        reject(new Error(`Failed to load ${src}`));
                    };
                    img.src = src;
                } else if (type === 'audio') {
                    const audio = new Audio();
                    audio.oncanplaythrough = () => {
                        this.loadedAssets.set(src, audio);
                        this.lastUsed.set(src, Date.now());
                        this.currentMemoryUsage += estimatedSize;
                        resolve(audio);
                    };
                    audio.onerror = () => {
                        console.warn(`Failed to load audio: ${src}`);
                        reject(new Error(`Failed to load ${src}`));
                    };
                    audio.volume = 0.1;
                    audio.src = src;
                }
            });

            this.loadingPromises.set(src, promise);
            return promise;
        }

        // Method to get a loaded asset (lazy load if needed)
        getAsset(src, type = 'image') {
            if (this.loadedAssets.has(src)) {
                this.lastUsed.set(src, Date.now()); // Update usage
                return this.loadedAssets.get(src);
            }
            
            // Lazy load if not available
            this.loadSingleAsset(src, type).catch(err => 
                console.warn(`Failed to lazy load ${src}:`, err)
            );
            
            return null; // Return null for immediate use, will be available later
        }

        // Method to preload assets for a specific feature
        preloadForFeature(feature) {
            const featureAssets = {
                'pilot-selection': ['cow.png', 'rockyboy.png', 'goggles.png'],
                'subclass-selection': ['marauder.png', 'jug2.png', 'phase.png', 'storm.png'],
                'skill-tree': ['mar11.png', 'mar2.png', 'mar3.png', 'jug3.png', 'phase2.png'],
                'combat-audio': ['Explosion.m4a', 'thunk.wav', 'cluster.mp3']
            };

            const assets = featureAssets[feature] || [];
            return Promise.all(assets.map(src => {
                const type = src.includes('.') && (src.endsWith('.mp3') || src.endsWith('.m4a') || src.endsWith('.wav')) ? 'audio' : 'image';
                return this.loadSingleAsset(src, type);
            }));
        }

        async startLoading() {
            try {
                const loadingDetails = document.getElementById('loadingDetails');
                if (loadingDetails) loadingDetails.textContent = 'Initializing combat protocols...';
                
                // Small delay for visual effect
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Progressive loading: Critical first, then gameplay, then extended
                if (loadingDetails) loadingDetails.textContent = 'ðŸš€ Loading critical assets...';
                await this.loadAssetGroup('critical');
                
                if (loadingDetails) loadingDetails.textContent = 'âš”ï¸ Loading gameplay assets...';
                await this.loadAssetGroup('gameplay');
                
                // Load extended assets in background after main loading finishes
                setTimeout(() => {
                    this.loadAssetGroup('extended').then(() => {
                        // Assets loaded silently
                    });
                }, 2000);
                
                // Start memory cleanup timer
                setInterval(() => this.cleanupUnusedAssets(), 180000); // Every 3 minutes
                
            } catch (error) {
                console.error('Asset loading failed:', error);
                this.finishLoading(); // Continue anyway
            }
        }

        finishLoading() {
            const loadingDetails = document.getElementById('loadingDetails');
            const loadingText = document.getElementById('loadingText');
            
            if (loadingDetails) loadingDetails.textContent = 'ðŸš€ Combat systems online! Engaging...';
            if (loadingText) loadingText.textContent = 'Ready for Combat! 100%';
            
            // Make asset manager globally available
            window.assetManager = this;
            
            // Fade out loading screen
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.transition = 'opacity 1s ease-out';
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.pointerEvents = 'none';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        this.initializeGame();
                    }, 1000);
                }
            }, 800);
        }

        initializeGame() {
            // Initialize mobile controls and start the game
            setupMobileControls();
            
            // Show a brief "systems online" message
            setTimeout(() => {
                if (typeof announce === 'function') {
                    announce('ðŸš€ VOID SKIES: Combat systems online!');
                }
            }, 500);
        }
    }

    // Game initialization runs immediately (like fghfgh.html working version)
    try{
        ensureName();
        refreshScoreList();
        requestAnimationFrame(frame);
    }catch(error){
        console.error("Game initialization failed:",error);
        try{
            updateLeaderboard(null);
            ensureName();
            requestAnimationFrame(frame);
            console.log("Game started in offline mode")
        }catch(criticalError){
            console.error("Critical startup failure:",criticalError);
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        // SKIP ASSET LOADING FOR PERFORMANCE TESTING - Start game immediately
        
        // Hide loading screen immediately
        const loadingScreen = document.getElementById('loadingScreen');
        if (loadingScreen) {
            loadingScreen.style.display = 'none';
        }
        
        // Initialize mobile controls if the function exists (like fghfgh.html)
        if (typeof setupMobileControls === 'function') {
            setupMobileControls();
        }
    });

})();
</script>
</body>
</html>
