<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
  <title>Void Skies</title>
  <style>
    :root {
      --bg:#050008; --fg:#ff99cc;
      --accent:#ff00ff; --p1:#ff3366; --p2:#cc00ff; --danger:#ff0066;
      --panel:#1a0022; --edge:rgba(255,0,255,.3);
      --hud-text: clamp(10px, 1.2vw, 14px);
      --btn-text: clamp(12px, 1.3vw, 16px);
      --btn-pad-y: clamp(6px, 0.8vw, 10px);
      --btn-pad-x: clamp(10px, 1.5vw, 14px);
      --maxw: 95vw;
    }
    html,body{
      height:100%;margin:0;
      background:radial-gradient(1200px 800px at 50% 40%, #330044, var(--bg));
      color:var(--fg);
      font-family:'Audiowide', ui-sans-serif, system-ui;
    }
    #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:
      calc(8px + env(safe-area-inset-top))
      calc(8px + env(safe-area-inset-right))
      calc(8px + env(safe-area-inset-bottom))
      calc(8px + env(safe-area-inset-left));}
    .stage{
      width:min(95vw, var(--maxw)); aspect-ratio:16/9; position:relative; display:grid; place-items:center;
      background:#000; border-radius:12px; overflow:hidden; box-shadow:0 0 60px rgba(255,0,255,.4);
      container-type:inline-size;
    }
    canvas{background:transparent; border-radius:16px; touch-action:none; cursor:none;}

    #topBar{position:absolute; left:0; right:0; top:0; display:grid; place-items:center; padding:6px; pointer-events:none;}
    #hud{display:grid; gap:4px; pointer-events:none; font-size:var(--hud-text); justify-items:center; align-items:center; width:100%; max-width:600px;}
    .hud-card{pointer-events:none; border:1px solid var(--edge); background:linear-gradient(180deg, rgba(255,0,255,.1), rgba(255,0,255,.05)); backdrop-filter:blur(8px); padding:4px 8px; border-radius:8px; width:100%;}
    .hud-title{opacity:.85; font-weight:600; margin-bottom:2px; font-family:'Orbitron','Audiowide',ui-sans-serif; text-align:center; font-size:10px; color:#ff66cc;}
    .bar{height:6px;width:100%;background:rgba(255,0,255,.1);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
    .bar>span{display:block;height:100%;background:linear-gradient(90deg,#ff0066,#ff00ff,#cc00ff)}

    #announce{position:absolute; left:50%; transform:translateX(-50%); top:40px; background:linear-gradient(180deg, rgba(255,0,255,.3), rgba(255,0,255,.1)); border:1px solid #ff00ff; padding:6px 10px; border-radius:10px; font-weight:600; text-shadow:0 0 10px #ff00ff; font-family:'Orbitron','Audiowide',ui-sans-serif; font-size:12px; color:#fff;}

    #diagBox{position:absolute; right:8px; bottom:8px; display:grid; gap:4px; pointer-events:none;}
    .chip{pointer-events:auto; background:rgba(0,0,0,.7); border:1px solid var(--edge); padding:4px 8px; border-radius:8px; font-size:10px; letter-spacing:.3px; font-family:'Orbitron','Audiowide',ui-sans-serif; text-align:right; color:#ff66cc;}

    .btn{background:#330044;color:#ff99cc;border:1px solid #ff00ff;border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all 0.2s;}
    .btn:hover{background:#550066;box-shadow:0 0 15px rgba(255,0,255,.5);}
    .panel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(26,0,34,.95);border:1px solid #ff00ff;border-radius:16px;padding:20px;width:min(900px,92vw);pointer-events:auto;backdrop-filter:blur(12px);color:#ff99cc;box-shadow:0 0 40px rgba(255,0,255,.3);}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
    .hide{display:none!important}

    #belowBoard{width:min(95vw, var(--maxw)); margin:8px auto 0; padding:8px; display:grid; gap:8px;}
    #hsCard{border:1px solid var(--edge); background:linear-gradient(180deg, rgba(255,0,255,.1), rgba(255,0,255,.05)); backdrop-filter:blur(8px); padding:8px; border-radius:8px;}
    #hsCard h3{margin:0 0 6px 0; font-family:'Orbitron','Audiowide',ui-sans-serif; text-align:center; font-size:14px; color:#ff66cc;}
    #hsList{list-style:decimal; margin:0; padding:0 0 0 1rem; line-height:1.4; font-size:12px; color:#ff99cc;}

    .skill-card{background:rgba(51,0,68,.8);border:1px solid #ff00ff;border-radius:8px;padding:10px;cursor:pointer;transition:all 0.2s;}
    .skill-card:hover{background:rgba(85,0,102,.9);box-shadow:0 0 20px rgba(255,0,255,.6);transform:scale(1.05);}
    .skill-title{font-weight:bold;color:#ff66cc;margin-bottom:4px;}
    .skill-desc{font-size:11px;color:#ff99cc;}

    @media (max-width: 820px){
      canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}
      .panel{width:min(700px,94vw)}
      .stage{width:98vw;}
      #belowBoard{width:98vw;}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div>
      <div class="stage" id="stage">
        <div id="topBar">
          <div id="hud">
            <div id="hudWaveContent" class="hud-card"></div>
            <div id="hudPilotContent" class="hud-card"></div>
            <div id="hudBossContent" class="hud-card hide"></div>
          </div>
          <div id="announce" class="hide" aria-live="polite"></div>
        </div>

        <canvas id="game" width="960" height="540"></canvas>

        <div id="diagBox">
          <div class="chip"> v2.0</div>
          <div class="chip">FPS <span id="fps">‚Äî</span></div>
        </div>
      </div>

      <div id="belowBoard">
        <div id="hsCard">
          <h3>‚ö° ACE PILOTS ‚ö°</h3>
          <ol id="hsList"></ol>
        </div>
      </div>
    </div>
  </div>

  <!-- Panels -->
  <div id="ui">
    <div id="levelPanel" class="panel hide">
      <h2 style="font-family:'Orbitron';color:#ff00ff;">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
      <p style="color:#ff99cc;">Select your neural enhancement:</p>
      <div id="skillsGrid" class="grid"></div>
    </div>
    
    <div id="shopPanel" class="panel hide">
      <h2 style="font-family:'Orbitron';color:#ff00ff;">üîß MECH FORGE üîß</h2>
      <p style="color:#ff99cc;">Blood Shards: <span id="shopParts">0</span></p>
      <div id="shopGrid" class="grid"></div>
      <div class="row" style="justify-content:flex-end;margin-top:10px;">
        <button id="closeShop" class="btn" type="button">OKAY</button>
      </div>
    </div>
  </div>

  <button id="menuBtn" type="button" style="position:fixed;top:8px;right:8px;z-index:5;border-radius:8px;padding:6px 8px;background:rgba(255,0,255,.2);border:1px solid #ff00ff;backdrop-filter:blur(8px);cursor:pointer;font-size:12px;color:#ff99cc;">‚öôÔ∏è</button>

<script>
(() => {
  // ---------- Constants ----------
  const W = 960, H = 540;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const collide = (a, b) => {
    const dx = a.x - b.x, dy = a.y - b.y;
    const rr = (a.r || 0) + (b.r || 0);
    return dx*dx + dy*dy < rr*rr;
  };

  // In-memory storage
  const memoryStore = { scores: [], playerName: '', upgrades: {} };
  const LS = {
    load: (k, fallback) => memoryStore[k] !== undefined ? memoryStore[k] : fallback,
    save: (k, v) => (memoryStore[k] = v)
  };
  const q = (id) => document.getElementById(id);

  // ---------- Canvas setup ----------
  const cvs = q('game');
  const ctx = cvs.getContext('2d');
  const stage = q('stage');

  function resize() {
    const rect = stage.getBoundingClientRect();
    const cssW = Math.floor(rect.width);
    const cssH = Math.floor(rect.height);
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cvs.style.width = cssW + 'px';
    cvs.style.height = cssH + 'px';
    cvs.width = Math.floor(cssW * dpr);
    cvs.height = Math.floor(cssH * dpr);
    ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
  }
  new ResizeObserver(resize).observe(stage); resize();

  // ---------- Input ----------
  const mouse = { x: W / 2, y: H * 0.8 };
  function pointFromEvent(e) {
    const r = cvs.getBoundingClientRect();
    const cx = 'clientX' in e ? e.clientX : e.touches[0].clientX;
    const cy = 'clientY' in e ? e.clientY : e.touches[0].clientY;
    const scaleX = W / r.width, scaleY = H / r.height;
    return { x: (cx - r.left) * scaleX, y: (cy - r.top) * scaleY };
  }
  cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
  cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive:false });
  cvs.addEventListener('touchmove',  (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive:false });

  // ---------- Game State ----------
  const store = {
    frame: 0, last: performance.now(),
    world: { wave: 1, score: 0, parts: 0, xp: 0, level: 1 },
    player: { 
      x: W*0.5, y: H-60, r: 14, hp: 180, hpMax: 100, 
      fireT: 0, speed: 380, 
      // RPG stats
      dmgMult: 1, fireRate: 0.18, vampirism: 0, shield: 0, shieldMax: 0,
      multishot: 1, piercing: 0, explosive: false
    },
    boss: null,
    bullets: [],
    eBullets: [],
    enemies: [],
    particles: [],
    scores: LS.load('scores', []),
    name: LS.load('playerName', ''),
    upgrades: LS.load('upgrades', {})
  };

  // Skills/Upgrades
  const SKILLS = [
    { id: 'dmg', name: 'PLASMA CORE', desc: '+25% damage output', apply: () => store.player.dmgMult *= 1.25 },
    { id: 'speed', name: 'NEURAL BOOST', desc: '+15% movement speed', apply: () => store.player.speed *= 1.15 },
    { id: 'hp', name: 'BLOOD ARMOR', desc: '+10 max HP', apply: () => { store.player.hpMax += 10; store.player.hp += 50; } },
    { id: 'fire', name: 'OVERCLOCK', desc: '+25% fire rate', apply: () => store.player.fireRate *= 0.75 },
    { id: 'vamp', name: 'VAMPIRIC ROUNDS', desc: 'Heal 5% damage dealt', apply: () => store.player.vampirism += 0.05 },
    { id: 'multi', name: 'SCATTER PROTOCOL', desc: '+1 projectile', apply: () => store.player.multishot += 1 },
    { id: 'pierce', name: 'PHASE ROUNDS', desc: 'Bullets pierce enemies', apply: () => store.player.piercing = 1 },
    { id: 'shield', name: 'VOID SHIELD', desc: '+30 regenerating shield', apply: () => { store.player.shieldMax += 30; store.player.shield = store.player.shieldMax; } },
    { id: 'explode', name: 'NOVA WARHEADS', desc: 'Explosive rounds', apply: () => store.player.explosive = true }
  ];

  // ---------- Spawner ----------
  let spawnLeft = 8, spawnTimer = 0, spawnInterval = 0.8;
  
  function initWave() {
    const isBossWave = store.world.wave % 5 === 0;
    if (isBossWave) {
      spawnLeft = 0;
      store.boss = createBoss();
      announce(`‚ö° LORD BONGO: ${store.boss.name} ‚ö°`);
    } else {
      spawnLeft = 6 + Math.floor(store.world.wave * 1.5);
      spawnTimer = 0;
      spawnInterval = Math.max(0.25, 0.95 - store.world.wave * 0.05);
      announce(`‚ó¢ SECTOR ${store.world.wave} BREACHED ‚ó£`);
      
      // Show shop every 3 waves
      if (store.world.wave % 3 === 1 && store.world.wave > 1) {
        setTimeout(showShop, 1000);
      }
    }
  }

  function createBoss() {
    const types = [
      { name: 'DONGULUS', hp: 800, color: '#ff0066', pattern: 'spiral' },
      { name: 'MECHANICUS MAXIMUS', hp: 1000, color: '#cc00ff', pattern: 'laser' },
      { name: 'VOIDCREEPER', hp: 1200, color: '#ff00ff', pattern: 'chaos' }
    ];
    const type = types[Math.floor(store.world.wave / 5) % types.length];
    return {
      ...type,
      x: W/2, y: -80, r: 50, 
      hpMax: type.hp, 
      t: 0, fireT: 0, moveT: 0,
      vx: 100, vy: 30
    };
  }

  function stepSpawner(dt) {
    if (!store.boss) {
      spawnTimer += dt;
      if (spawnLeft > 0 && spawnTimer >= spawnInterval) {
        spawnTimer = 0; spawnLeft--;
        const types = ['drone', 'drone', 'hunter', 'phantom', 'mech'];
        const type = types[Math.min(Math.floor(Math.random() * types.length), types.length - 1)];
        store.enemies.push(spawnEnemy(type));
      }
    }
    
    const empty = store.enemies.length === 0 && !store.boss && spawnLeft === 0;
    if (empty) { 
      store.world.wave++; 
      initWave(); 
    }
  }

  function spawnEnemy(type='drone') {
    const configs = {
      drone: { r: 10, v: 80, hp: 20, color: '#ff6600', xp: 5 },
      hunter: { r: 12, v: 120, hp: 30, color: '#ff0066', xp: 8 },
      phantom: { r: 14, v: 100, hp: 25, color: '#cc00ff', xp: 10, phase: true },
      mech: { r: 18, v: 60, hp: 60, color: '#9900ff', xp: 15 }
    };
    const cfg = configs[type] || configs.drone;
    return { 
      type, 
      x: 20 + Math.random() * (W-40), 
      y: -50 - Math.random()*150, 
      r: cfg.r, 
      v: cfg.v, 
      hp: cfg.hp,
      hpMax: cfg.hp,
      color: cfg.color,
      xp: cfg.xp,
      phase: cfg.phase || false,
      t: Math.random() * Math.PI * 2
    };
  }

  // ---------- Player ----------
  function stepPlayer(dt) {
    const p = store.player, t = mouse;
    const vx = t.x - p.x, vy = t.y - p.y, d = Math.hypot(vx, vy);
    if (d > 1) { 
      p.x = clamp(p.x + (vx/d)*p.speed*dt, 20, W-20); 
      p.y = clamp(p.y + (vy/d)*p.speed*dt, 20, H-20); 
    }
    
    // Auto-fire
    p.fireT -= dt;
    if (p.fireT <= 0) { 
      firePlayer(); 
      p.fireT = p.fireRate; 
    }
    
    // Shield regen
    if (p.shieldMax > 0 && p.shield < p.shieldMax) {
      p.shield = Math.min(p.shieldMax, p.shield + 10 * dt);
    }
  }

  function firePlayer() {
    const p = store.player, bspd = 420;
    const spread = p.multishot > 2 ? 15 : 10;
    
    for (let i = 0; i < p.multishot; i++) {
      const angle = (i - (p.multishot-1)/2) * spread * Math.PI/180;
      const vx = Math.sin(angle) * bspd;
      const vy = -Math.cos(angle) * bspd;
      store.bullets.push({
        x: p.x + Math.sin(angle)*10,
        y: p.y - 12,
        vx, vy,
        r: p.explosive ? 5 : 3,
        col: p.explosive ? '#ff00ff' : '#ff3366',
        dmg: 20 * p.dmgMult,
        pierce: p.piercing,
        explosive: p.explosive
      });
    }
  }

  function takeDamage(dmg) {
    const p = store.player;
    if (p.shield > 0) {
      const absorbed = Math.min(p.shield, dmg);
      p.shield -= absorbed;
      dmg -= absorbed;
    }
    p.hp = Math.max(0, p.hp - dmg);
  }

  // ---------- Boss ----------
  function stepBoss(dt) {
    const b = store.boss;
    if (!b) return;
    
    b.t += dt;
    
    // Entry animation
    if (b.y < 100) {
      b.y += b.vy * dt;
    } else {
      // Movement patterns
      b.moveT += dt;
      if (b.pattern === 'spiral') {
        b.x = W/2 + Math.sin(b.moveT * 1.5) * 200;
        b.y = 100 + Math.sin(b.moveT * 2) * 50;
      } else if (b.pattern === 'laser') {
        b.x = W/2 + Math.sin(b.moveT) * 300;
        b.y = 100 + Math.abs(Math.sin(b.moveT * 1.5)) * 80;
      } else {
        b.x += Math.sin(b.t * 3) * 150 * dt;
        b.y = 100 + Math.sin(b.moveT * 2) * 60;
      }
      b.x = clamp(b.x, 60, W-60);
    }
    
    // Fire patterns
    b.fireT += dt;
    if (b.fireT > 0.5) {
      b.fireT = 0;
      fireBoss(b);
    }
  }

  function fireBoss(b) {
    if (b.pattern === 'spiral') {
      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI / 4) + b.t * 2;
        store.eBullets.push({
          x: b.x + Math.cos(angle) * 30,
          y: b.y + Math.sin(angle) * 30,
          vx: Math.cos(angle) * 120,
          vy: Math.sin(angle) * 120,
          r: 5, col: b.color, dmg: 15
        });
      }
    } else if (b.pattern === 'laser') {
      const dx = store.player.x - b.x;
      const dy = store.player.y - b.y;
      const d = Math.hypot(dx, dy);
      for (let i = -2; i <= 2; i++) {
        store.eBullets.push({
          x: b.x + i * 15,
          y: b.y + 20,
          vx: (dx/d) * 200 + i * 20,
          vy: (dy/d) * 200,
          r: 4, col: b.color, dmg: 12
        });
      }
    } else {
      for (let i = 0; i < 12; i++) {
        const angle = (i * Math.PI / 6);
        store.eBullets.push({
          x: b.x, y: b.y,
          vx: Math.cos(angle) * 150,
          vy: Math.sin(angle) * 150,
          r: 6, col: b.color, dmg: 18
        });
      }
    }
  }

  // ---------- World Update ----------
  function stepWorld(dt) {
    stepPlayer(dt);
    stepSpawner(dt);
    stepBoss(dt);
    
    // Update particles
    for (const p of store.particles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.life -= dt;
      if (p.life <= 0) p.dead = true;
    }

    // Enemy bullets
    for (const b of store.eBullets) {
      b.x += b.vx*dt; 
      b.y += b.vy*dt;
      if (b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) b.dead = true;
      if (collide(b, store.player)) {
        takeDamage(b.dmg || 10);
        b.dead = true;
        addParticles(b.x, b.y, '#ff0066', 8);
      }
    }
    
    // Enemies
    for (const e of store.enemies) {
      e.t += dt;
      if (e.phase) {
        e.x += Math.sin(e.t * 3) * 50 * dt;
      }
      e.y += e.v * dt;
      if (e.y > H+30) e.dead = true;
      
      if (Math.random() < 0.004) {
        store.eBullets.push({ 
          x: e.x, y: e.y, 
          vx: 0, vy: 150, 
          r: 3, col: e.color, 
          dmg: 8 
        });
      }
      
      if (collide(e, store.player)) {
        takeDamage(15);
        e.dead = true;
        addParticles(e.x, e.y, e.color, 12);
      }
    }
    
    // Player bullets
    for (const b of store.bullets) {
      b.x += b.vx*dt; 
      b.y += b.vy*dt;
      if (b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) b.dead = true;
      
      // Hit enemies
      for (const e of store.enemies) {
        if (!e.dead && collide(b, e)) {
          const dmg = b.dmg || 20;
          e.hp -= dmg;
          
          if (e.hp <= 0) { 
            e.dead = true; 
            store.world.score += 10;
            store.world.parts += 1;
            store.world.xp += e.xp || 5;
            addParticles(e.x, e.y, e.color, 15);
            
            // Vampirism
            if (store.player.vampirism > 0) {
              store.player.hp = Math.min(store.player.hpMax, 
                store.player.hp + dmg * store.player.vampirism);
            }
          }
          
          if (b.explosive) {
            explode(b.x, b.y);
          }
          
          if (!b.pierce || b.pierce <= 0) {
            b.dead = true;
          } else {
            b.pierce--;
          }
        }
      }
      
      // Hit boss
      if (store.boss && collide(b, store.boss)) {
        const dmg = b.dmg || 20;
        store.boss.hp -= dmg;
        
        if (store.boss.hp <= 0) {
          store.world.score += 500;
          store.world.parts += 50;
          store.world.xp += 100;
          addParticles(store.boss.x, store.boss.y, store.boss.color, 50);
          store.boss = null;
          announce('‚ö° GUARDIAN DEFEATED ‚ö°');
        }
        
        if (b.explosive) {
          explode(b.x, b.y);
        }
        
        if (!b.pierce) b.dead = true;
      }
    }
    
    // Level up check
    const xpNeeded = store.world.level * 100;
    if (store.world.xp >= xpNeeded) {
      store.world.xp -= xpNeeded;
      store.world.level++;
      levelUp();
    }

    // Cleanup
    store.bullets = store.bullets.filter(b => !b.dead);
    store.eBullets = store.eBullets.filter(b => !b.dead);
    store.enemies = store.enemies.filter(e => !e.dead);
    store.particles = store.particles.filter(p => !p.dead);

    // Game over
    if (store.player.hp === 0) handleGameOver();
  }

  function explode(x, y) {
    for (const e of store.enemies) {
      const d = Math.hypot(e.x - x, e.y - y);
      if (d < 60) {
        e.hp -= 30 * store.player.dmgMult;
        if (e.hp <= 0) {
          e.dead = true;
          store.world.score += 5;
        }
      }
    }
    addParticles(x, y, '#ff00ff', 20, true);
  }

  function addParticles(x, y, color, count, explosion = false) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
      const speed = explosion ? 200 + Math.random() * 100 : 50 + Math.random() * 100;
      store.particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: explosion ? 3 : 2,
        color,
        life: explosion ? 0.5 : 0.3
      });
    }
  }

  // ---------- RPG Systems ----------
  function levelUp() {
    announce(`‚ö° LEVEL ${store.world.level} REACHED ‚ö°`);
    const panel = q('levelPanel');
    const grid = q('skillsGrid');
    
    // Pick 3 random skills
    const available = SKILLS.filter(s => !store.upgrades[s.id] || store.upgrades[s.id] < 5);
    const choices = [];
    for (let i = 0; i < 3 && available.length > 0; i++) {
      const idx = Math.floor(Math.random() * available.length);
      choices.push(available[idx]);
      available.splice(idx, 1);
    }
    
    grid.innerHTML = choices.map(skill => `
      <div class="skill-card" data-id="${skill.id}">
        <div class="skill-title">${skill.name}</div>
        <div class="skill-desc">${skill.desc}</div>
      </div>
    `).join('');
    
    grid.querySelectorAll('.skill-card').forEach(card => {
      card.addEventListener('click', () => {
        const id = card.dataset.id;
        const skill = SKILLS.find(s => s.id === id);
        if (skill) {
          skill.apply();
          store.upgrades[id] = (store.upgrades[id] || 0) + 1;
          LS.save('upgrades', store.upgrades);
        }
        panel.classList.add('hide');
      });
    });
    
    panel.classList.remove('hide');
  }

  function showShop() {
    const panel = q('shopPanel');
    const grid = q('shopGrid');
    const parts = q('shopParts');
    
    parts.textContent = store.world.parts;
    
    const items = [
      { name: 'REPAIR NANOBOTS', cost: 20, desc: 'Restore 25 HP', 
        buy: () => store.player.hp = Math.min(store.player.hpMax, store.player.hp + 25) },
      { name: 'SHIELD BOOSTER', cost: 30, desc: '+20 shield capacity', 
        buy: () => { store.player.shieldMax += 20; store.player.shield += 20; } },
      { name: 'PLASMA UPGRADE', cost: 40, desc: '+15% damage', 
        buy: () => store.player.dmgMult *= 1.15 },
      { name: 'SPEED DEMON', cost: 35, desc: '+10% move speed', 
        buy: () => store.player.speed *= 1.1 }
    ];
    
    grid.innerHTML = items.map((item, i) => `
      <div class="skill-card shop-item" data-idx="${i}">
        <div class="skill-title">${item.name}</div>
        <div class="skill-desc">${item.desc}</div>
        <div style="color:#ff00ff;margin-top:4px;">Cost: ${item.cost} shards</div>
      </div>
    `).join('');
    
    grid.querySelectorAll('.shop-item').forEach(card => {
      card.addEventListener('click', () => {
        const idx = parseInt(card.dataset.idx);
        const item = items[idx];
        if (store.world.parts >= item.cost) {
          store.world.parts -= item.cost;
          item.buy();
          parts.textContent = store.world.parts;
          card.style.opacity = '0.5';
          card.style.pointerEvents = 'none';
        }
      });
    });
    
    panel.classList.remove('hide');
  }

  q('closeShop').addEventListener('click', () => {
    q('shopPanel').classList.add('hide');
  });

  // ---------- Rendering ----------
  const starsA = Array.from({ length: 100 }, () => ({ 
    x: Math.random()*W, y: Math.random()*H, 
    r: Math.random()*1.5, pulse: Math.random()*10 
  }));
  const starsB = Array.from({ length: 80 }, () => ({ 
    x: Math.random()*W, y: Math.random()*H, 
    r: Math.random()*2, pulse: Math.random()*10 
  }));
  const nebulaClouds = Array.from({ length: 5 }, () => ({
    x: Math.random()*W, y: Math.random()*H,
    r: 100 + Math.random()*150,
    color: ['#ff00ff', '#cc00ff', '#ff0066'][Math.floor(Math.random()*3)],
    pulse: Math.random()*10
  }));

  function render(dt) {
    const time = performance.now() * 0.001;
    
    // Dark cyberpunk background
    ctx.fillStyle = '#050008';
    ctx.fillRect(0, 0, W, H);
    
    // Bright nebula clouds
    ctx.globalCompositeOperation = 'screen';
    for (const cloud of nebulaClouds) {
      const pulse = 0.3 + 0.2 * Math.sin(time * 0.5 + cloud.pulse);
      const grad = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.r);
      grad.addColorStop(0, cloud.color + '44');
      grad.addColorStop(0.5, cloud.color + '22');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.globalAlpha = pulse;
      ctx.fillRect(cloud.x - cloud.r, cloud.y - cloud.r, cloud.r * 2, cloud.r * 2);
    }
    ctx.globalCompositeOperation = 'source-over';
    
    // Parallax stars with pulsing
    ctx.globalAlpha = 0.8;
    for (const s of starsA) {
      s.y += 30 * (1/60);
      if (s.y > H) s.y -= H;
      const pulse = 0.5 + 0.5 * Math.sin(time * 2 + s.pulse);
      ctx.fillStyle = `rgba(255,0,255,${pulse})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    
    ctx.globalAlpha = 0.6;
    for (const s of starsB) {
      s.y += 60 * (1/60);
      if (s.y > H) s.y -= H;
      const pulse = 0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse);
      ctx.fillStyle = `rgba(204,0,255,${pulse})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, Math.max(0.1, s.r * pulse), 0, Math.PI*2);
      ctx.fill();
    }
    
    // Grid lines for cyberpunk effect
    ctx.globalAlpha = 0.1;
    ctx.strokeStyle = '#ff00ff';
    ctx.lineWidth = 0.5;
    for (let i = 0; i < W; i += 40) {
      ctx.beginPath();
      ctx.moveTo(i, 0);
      ctx.lineTo(i, H);
      ctx.stroke();
    }
    for (let i = 0; i < H; i += 40) {
      ctx.beginPath();
      ctx.moveTo(0, i);
      ctx.lineTo(W, i);
      ctx.stroke();
    }
    
    ctx.globalAlpha = 1;
    
    // Particles
    for (const p of store.particles) {
      if (p.life > 0 && p.r > 0) {
        ctx.globalAlpha = Math.max(0, Math.min(1, p.life * 2));
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(0.1, p.r), 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    
    // Enemies
    for (const e of store.enemies) {
      drawEnemy(e);
    }
    
    // Boss
    if (store.boss) {
      drawBoss(store.boss);
    }
    
    // Bullets
    for (const b of store.eBullets) {
      ctx.shadowColor = b.col;
      ctx.shadowBlur = 8;
      ctx.fillStyle = b.col;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }
    
    for (const b of store.bullets) {
      ctx.shadowColor = b.col;
      ctx.shadowBlur = b.explosive ? 12 : 6;
      ctx.fillStyle = b.col;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      if (b.explosive) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
    ctx.shadowBlur = 0;
    
    // Player ship
    drawShip(store.player.x, store.player.y);
    
    // Shield effect
    if (store.player.shield > 0) {
      ctx.strokeStyle = `rgba(0,255,255,${0.3 + 0.2 * Math.sin(time * 5)})`;
      ctx.lineWidth = 2;
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(store.player.x, store.player.y, Math.max(1, store.player.r + 8), 0, Math.PI*2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    updateHUD();
    updateFPS(dt);
  }

  function drawEnemy(e) {
    const { x, y, r, type, color, hp, hpMax } = e;
    ctx.save();
    ctx.translate(x, y);
    
    // HP bar
    if (hp < hpMax) {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(-r, -r-8, r*2, 3);
      ctx.fillStyle = '#ff0066';
      ctx.fillRect(-r, -r-8, r*2*(hp/hpMax), 3);
    }
    
    ctx.shadowColor = color;
    ctx.shadowBlur = 15;
    ctx.strokeStyle = color;
    ctx.fillStyle = color + '99';
    ctx.lineWidth = 2;
    
    if (type === 'phantom') {
      ctx.globalAlpha = 0.7 + 0.3 * Math.sin(e.t * 5);
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI / 3) + e.t;
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
    } else if (type === 'mech') {
      ctx.fillRect(-r*0.8, -r*0.8, r*1.6, r*1.6);
      ctx.strokeRect(-r*0.8, -r*0.8, r*1.6, r*1.6);
      ctx.fillStyle = color;
      ctx.fillRect(-r*0.5, -r*0.5, r*0.3, r*0.3);
      ctx.fillRect(r*0.2, -r*0.5, r*0.3, r*0.3);
    } else if (type === 'hunter') {
      ctx.beginPath();
      ctx.moveTo(0, -r);
      ctx.lineTo(r, r*0.5);
      ctx.lineTo(0, r);
      ctx.lineTo(-r, r*0.5);
      ctx.closePath();
    } else {
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI*2);
    }
    
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawBoss(b) {
    ctx.save();
    ctx.translate(b.x, b.y);
    
    // Boss HP bar
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(-60, -b.r-20, 120, 8);
    ctx.fillStyle = b.color;
    ctx.fillRect(-60, -b.r-20, 120*(b.hp/b.hpMax), 8);
    ctx.strokeStyle = '#ff00ff';
    ctx.lineWidth = 1;
    ctx.strokeRect(-60, -b.r-20, 120, 8);
    
    // Boss body
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 30;
    ctx.strokeStyle = b.color;
    ctx.lineWidth = 3;
    
    // Rotating parts
    for (let i = 0; i < 3; i++) {
      ctx.save();
      ctx.rotate(b.t * (1 + i*0.5));
      ctx.beginPath();
      ctx.arc(0, 0, b.r - i*10, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Core
    const pulse = 0.8 + 0.2 * Math.sin(b.t * 3);
    ctx.fillStyle = b.color + 'aa';
    ctx.beginPath();
    ctx.arc(0, 0, Math.max(1, b.r * 0.3 * pulse), 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
  }

  function drawShip(x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Vampire mech design
    ctx.beginPath();
    ctx.moveTo(0, -20);
    ctx.lineTo(12, 8);
    ctx.lineTo(8, 14);
    ctx.lineTo(0, 10);
    ctx.lineTo(-8, 14);
    ctx.lineTo(-12, 8);
    ctx.closePath();
    
    const g = ctx.createLinearGradient(0, -20, 0, 14);
    g.addColorStop(0, '#ff0066');
    g.addColorStop(0.5, '#cc0033');
    g.addColorStop(1, '#660019');
    ctx.fillStyle = g;
    ctx.fill();
    
    ctx.shadowColor = '#ff00ff';
    ctx.shadowBlur = 20;
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#ff66cc';
    ctx.stroke();
    
    // Wings
    ctx.strokeStyle = '#ff00ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-12, 5);
    ctx.lineTo(-20, -2);
    ctx.lineTo(-18, 8);
    ctx.moveTo(12, 5);
    ctx.lineTo(20, -2);
    ctx.lineTo(18, 8);
    ctx.stroke();
    
    // Engines
    const time = performance.now() * 0.001;
    ctx.globalAlpha = 0.8 + 0.2 * Math.sin(time * 10);
    ctx.fillStyle = '#ff00ff';
    ctx.beginPath();
    ctx.ellipse(-5, 16, 3, 6, 0, 0, Math.PI*2);
    ctx.ellipse(5, 16, 3, 6, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Cockpit
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(0, -8, 3, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
  }

  // ---------- HUD ----------
  function escapeHtml(s) { 
    s = String(s ?? ''); 
    return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
  }
  
  function updateHUD() {
    const hc = q('hudWaveContent');
    const hp = q('hudPilotContent');
    const hb = q('hudBossContent');
    
    if (hc) {
      hc.innerHTML = `
        <div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div>
        <div style="text-align:center">
          SECTOR <b>${store.world.wave}</b> ‚Ä¢ 
          CASH <b>${store.world.score}</b> ‚Ä¢ 
          POWER GEMS <b>${store.world.parts}</b> ‚Ä¢
          LVL <b>${store.world.level}</b>
        </div>`;
    }
    
    if (hp) {
      const p = store.player;
      const hpPct = Math.round(p.hp / p.hpMax * 100);
      const shieldPct = p.shieldMax > 0 ? Math.round(p.shield / p.shieldMax * 100) : 0;
      const xpPct = Math.round(store.world.xp / (store.world.level * 100) * 100);
      
      hp.innerHTML = `
        <div class="hud-title">${store.name ? ('‚ó¢ ' + escapeHtml(store.name) + ' ‚ó£') : '‚ó¢ UNIDENTIFIED VOID PILOT ‚ó£'}</div>
        <div style="text-align:center">HULL ${hpPct}% ${p.shieldMax > 0 ? `‚Ä¢ SHIELD ${shieldPct}%` : ''}</div>
        <div class="bar"><span style="width:${hpPct}%"></span></div>
        ${p.shieldMax > 0 ? `<div class="bar" style="margin-top:2px;"><span style="width:${shieldPct}%;background:linear-gradient(90deg,#00ffff,#0099ff)"></span></div>` : ''}
        <div style="text-align:center;margin-top:4px;font-size:9px;">XP ${store.world.xp}/${store.world.level * 100}</div>
        <div class="bar" style="height:3px;"><span style="width:${xpPct}%;background:linear-gradient(90deg,#ffff00,#ff9900)"></span></div>`;
    }
    
    if (store.boss) {
      if (hb) {
        hb.classList.remove('hide');
        const bPct = Math.round(store.boss.hp / store.boss.hpMax * 100);
        hb.innerHTML = `
          <div class="hud-title">‚ö° ${store.boss.name} ‚ö°</div>
          <div class="bar"><span style="width:${bPct}%;background:linear-gradient(90deg,${store.boss.color},#ff0066)"></span></div>`;
      }
    } else {
      if (hb) hb.classList.add('hide');
    }
  }

  let fpsEMA = 60, fpsAlpha = 0.12;
  function updateFPS(dt) {
    const el = q('fps');
    if (!dt || !isFinite(dt) || dt <= 0) return;
    const fps = 1/dt;
    fpsEMA = fpsEMA*(1-fpsAlpha) + fps*fpsAlpha;
    if (el) el.textContent = String(Math.round(fpsEMA));
  }

  function announce(text) {
    const el = q('announce');
    if (!el) return;
    el.textContent = text;
    el.classList.remove('hide');
    clearTimeout(el._t);
    el._t = setTimeout(() => el.classList.add('hide'), 2500);
  }

  // ---------- High Scores ----------
  function addScore(score) {
    const name = (store.name || 'ROGUE').slice(0, 16);
    const arr = store.scores || [];
    arr.push({ name, score, level: store.world.level, ts: Date.now() });
    arr.sort((a, b) => b.score - a.score);
    store.scores = arr.slice(0, 10);
    LS.save('scores', store.scores);
    refreshScoreList();
  }

  function refreshScoreList() {
    const ol = q('hsList');
    if (!ol) return;
    ol.innerHTML = (store.scores || []).map((s) => 
      `<li>${escapeHtml(s.name)} ‚Äî ${s.score} (LVL ${s.level || 1})</li>`
    ).join('') || `<li>NO GOOD PILOTS</li>`;
  }

  // ---------- Game Over ----------
  let gameOverShown = false;
  function handleGameOver() {
    if (gameOverShown) return;
    gameOverShown = true;
    addScore(store.world.score);
    announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£');
    
    setTimeout(() => {
      // Reset game
      store.player = {
        x: W*0.5, y: H-60, r: 14, hp: 100, hpMax: 100,
        fireT: 0, speed: 380,
        dmgMult: 1, fireRate: 0.18, vampirism: 0, shield: 0, shieldMax: 0,
        multishot: 2, piercing: 0, explosive: false
      };
      store.world = { wave: 1, score: 0, parts: 0, xp: 0, level: 1 };
      store.boss = null;
      store.enemies.length = 0;
      store.bullets.length = 0;
      store.eBullets.length = 0;
      store.particles.length = 0;
      store.upgrades = {};
      gameOverShown = false;
      initWave();
    }, 2000);
  }

  // ---------- Main Loop ----------
  function step(dt) { stepWorld(dt); }
  
  function frame(now) {
    const dt = Math.min(0.033, (now - store.last) / 1000);
    store.last = now;
    store.frame++;
    step(dt);
    render(dt);
    requestAnimationFrame(frame);
  }

  // ---------- Boot ----------
  addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'n') {
      const v = prompt('Enter pilot callsign (max 16 chars)', store.name || '') || '';
      store.name = v.slice(0, 16).trim();
      LS.save('playerName', store.name);
      updateHUD();
    }
  });
  
  q('menuBtn').addEventListener('click', () => {
    const reset = confirm('Reset all progress and high scores?');
    if (reset) {
      memoryStore.scores = [];
      memoryStore.playerName = '';
      memoryStore.upgrades = {};
      location.reload();
    }
  });

  refreshScoreList();
  initWave();
  requestAnimationFrame(frame);
})();
</script>

</body>
</html>
