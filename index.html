<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 95vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:calc(8px + env(safe-area-inset-top)) calc(8px + env(safe-area-inset-right)) calc(8px + env(safe-area-inset-bottom)) calc(8px + env(safe-area-inset-left))}
        .stage{width:min(95vw,var(--maxw));aspect-ratio:16/9;position:relative;display:grid;place-items:center;background:#000;border-radius:12px;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
        canvas{background:transparent;border-radius:16px;touch-action:none;cursor:none}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce{position:absolute;left:50%;transform:translateX(-50%);top:40px;background:linear-gradient(180deg,rgba(150,80,255,.26),rgba(150,80,255,.1));border:1px solid var(--accent);padding:6px 10px;border-radius:10px;font-weight:600;text-shadow:0 0 10px var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif;font-size:12px;color:#fff}
        #diagBox{position:absolute;right:8px;bottom:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:right;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        .panel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(26,0,34,.95);border:1px solid var(--accent);border-radius:16px;padding:20px;width:min(900px,92vw);backdrop-filter:blur(12px);color:#ffddff;box-shadow:0 0 40px rgba(178,102,255,.3);z-index:100;}
        .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
        .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
        .hide{display:none!important}
        #belowBoard{width:min(95vw,var(--maxw));margin:8px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        .skill-card{background:rgba(51,0,68,.8);border:1px solid var(--accent);border-radius:8px;padding:10px;cursor:pointer;transition:all .2s}
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        .skill-title{font-weight:700;color:#c49cff;margin-bottom:4px}
        .skill-desc{font-size:11px;color:#ffddff}
        .fixed-btn{position:fixed;z-index:5;border-radius:10px;padding:var(--btn-pad-y) var(--btn-pad-x);background:rgba(150,80,255,.2);border:1px solid var(--accent);backdrop-filter:blur(8px);cursor:pointer;font-size:var(--btn-text);color:#ffddff;height:auto;min-width:180px;text-align:center;}
        .fixed-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #menuBtn{right:20px; bottom:20px;}
        #fsEnterBtn{left:20px; bottom:20px;}
        #shopBtn{right:220px; bottom:20px; z-index: 5;}
        #pauseBtn{top:20px;right:20px; z-index:5;}
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif}
        
        #abilityBar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 6; 
            pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; 
            bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; 
            padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(700px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
    </style>
</head>
<body>
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide"></div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card"></div>
                        <div id="hudPilotContent" class="hud-card"></div>
                        <div id="hudBossContent" class="hud-card hide"></div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide"></div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <div class="chip">v3.3.0</div>
                    <div class="chip">FPS <span id="fps">‚Äî</span></div>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üöÄ PILOT LOST üöÄ</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">ü™™ CALLSIGN</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. NIGHTWRAITH" />
                        <div class="row" style="justify-content:flex-end;margin-top:12px">
                            <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üèÜ ACE PILOTS üèÜ</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:flex-end;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">üîß MECH FORGE üîß</h2>
                        <p style="color:#ffddff">Available Shards: <span id="shopShards">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:flex-end;margin-top:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                    <button id="voidBeamBtnUI" class="fixed-btn ability-btn hide" type="button">VOID BEAM</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>‚ö° ACE PILOTS ‚ö°</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <button id="menuBtn" class="fixed-btn" type="button">üèÜ TOP PILOTS</button>
    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <button id="shopBtn" class="fixed-btn" type="button">üîß MECH FORGE</button>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://poetry-lines-persian-birds.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => { 
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height), 
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); 
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px'; 
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr); 
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0); 
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    const pointFromEvent = (e) => { 
        const r = cvs.getBoundingClientRect(), 
        cx = 'clientX' in e ? e.clientX : e.touches[0].clientX, 
        cy = 'clientY' in e ? e.clientY : e.touches[0].clientY; 
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) }; 
    };

    const canvasButtons = {
        grenade: { x: 0, y: 0, w: 80, h: 28, visible: false },
        voidBeam: { x: 0, y: 0, w: 80, h: 28, visible: false }
    };

    cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
    cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    
    cvs.addEventListener('click', (e) => {
        if (store.isPaused || store.isGameOver) return;
        const p = pointFromEvent(e);

        if (canvasButtons.grenade.visible) {
            const b = canvasButtons.grenade;
            if (p.x > b.x && p.x < b.x + b.w && p.y > b.y && p.y < b.y + b.h) {
                useGrenade();
            }
        }

        if (canvasButtons.voidBeam.visible) {
            const b = canvasButtons.voidBeam;
            if (p.x > b.x && p.x < b.x + b.w && p.y > b.y && p.y < b.y + b.h) {
                activateVoidBeam();
            }
        }
    });


    // --- AUDIO ---
    const bgm = q('bgmAudio');

    // --- GAME STATE & DATA ---
    const player_initial_state = { 
        x: W / 2, y: H * 0.8, r: 14, hp: 100, hpMax: 100, fireT: 0, speed: 380, dmgMult: 1, fireRate: 0.18, 
        vampirism: 0, shield: 0, shieldMax: 0, multishot: 1, piercing: 0, explosive: false, levelUpEffect: null, 
        weaponType: 'default', hasShieldBubble: false, powerupTimers: {}, 
        upgradeLevels: { dmg: 0, speed: 0, hp: 0, shield: 0 }, grenades: 0, hasVoidBeam: false, 
        voidBeamCooldown: 0, hasLauncher: false, hasHounds: false, missileFireT: 0
    };
    
    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        world: { wave: 1, score: 0, shards: 0, xp: 0, level: 1, kills: 0, bosses: 0 },
        player: { ...player_initial_state },
        boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], grenades: [], hounds: [], missiles: [], activeEffects: [],
        _startTs: performance.now()
    };

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', desc: '+25% damage', apply: () => store.player.dmgMult *= 1.25 },
        { id: 'speed', name: 'NEURAL BOOST', desc: '+15% speed', apply: () => store.player.speed *= 1.15 },
        { id: 'hp', name: 'BLOOD ARMOR', desc: '+10 max HP', apply: () => { store.player.hpMax += 10; store.player.hp += 10; } },
        { id: 'fire', name: 'OVERCLOCK', desc: '+25% fire rate', apply: () => store.player.fireRate *= 0.75 },
        { id: 'vamp', name: 'VAMPIRIC ROUNDS', desc: 'Heal 2% damage dealt', apply: () => store.player.vampirism += 0.02 },
        { id: 'multi', name: 'SCATTER PROTOCOL', desc: '+1 projectile', apply: () => store.player.multishot += 1 },
        { id: 'pierce', name: 'PHASE ROUNDS', desc: 'Bullets pierce enemies', apply: () => store.player.piercing = 1 },
        { id: 'shield', name: 'VOID SHIELD', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'explode', name: 'NOVA WARHEADS', desc: 'Explosive rounds', apply: () => store.player.explosive = true },
    ];
    
    const SHOP_UPGRADES = {
        'dmg': { name: "DAMAGE", baseCost: 25, scale: 1.5, maxLevel: 10, effect: () => store.player.dmgMult += 0.1, desc: level => `+10% Damage (Lvl ${level + 1})` },
        'speed': { name: "SPEED", baseCost: 30, scale: 1.6, maxLevel: 8, effect: () => store.player.speed += 30, desc: level => `+30 Speed (Lvl ${level + 1})` },
        'hp': { name: "MAX HP", baseCost: 20, scale: 1.4, maxLevel: 10, effect: () => { store.player.hpMax += 10; store.player.hp += 10; }, desc: level => `+10 Max HP (Lvl ${level + 1})` },
        'shield': { name: "MAX SHIELD", baseCost: 40, scale: 1.8, maxLevel: 5, effect: () => { store.player.shieldMax += 25; store.player.shield += 25; }, desc: level => `+25 Max Shield (Lvl ${level + 1})` },
        'repair': { name: "NANO REPAIR", cost: 3, isPremium: true, apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'grenade': { name: "NOVA GRENADE", cost: 35, isPremium: true, max: 3, apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'void_beam': { name: "VOID BEAM", cost: 75, isPremium: true, isUnlock: true, apply: () => { if (!store.player.hasVoidBeam) { store.player.hasVoidBeam = true; return true; } return false; }, desc: () => `Unlock Ultimate Weapon` },
        'launcher': { name: 'FRAGMENTATION LAUNCHER', cost: 50, isPremium: true, isUnlock: true, apply: () => { if (!store.player.hasLauncher) { store.player.hasLauncher = true; return true; } return false; }, desc: () => `Adds swirling nova projectiles to your primary fire.` },
        'ghost_hounds': { name: "GHOST HOUNDS", cost: 75, isPremium: true, isUnlock: true, apply: () => { if (!store.player.hasHounds) { store.player.hasHounds = true; store.hounds = [createHound(-1), createHound(1)]; return true; } return false; }, desc: () => `Unlocks 2 spectral hounds to attack enemies.` }
    };
    
    const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: 'D', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'W', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'S', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: '+', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'M', duration: 20, type: 'timed' }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) { 
        const baseChance = 0.15;
        const wave = store.world.wave;
        const waveReductionFactor = 0.005;
        const chance = Math.max(0.05, baseChance - (wave - 1) * waveReductionFactor);

        if (Math.random() > chance) return;
        
        const types = Object.keys(POWERUP_TYPES); 
        const typeKey = types[Math.floor(Math.random() * types.length)]; 
        store.powerups.push({ x, y, r: 12, type: typeKey }); 
    }
    
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
    
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) {
                p.powerupTimers[typeKey].remaining += powerup.duration;
            } else {
                if (typeKey === 'drones') {
                    store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                }
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') {
                p.multishot++;
                announce('SCATTER SHOT!');
            }
        }
    }

    function initWave() {
        const isBossWave = store.world.wave % 5 === 0;
        if (isBossWave) {
            store.enemies = [];
            const bossHpScale = 1 + (store.world.wave / 5 - 1) * 1.5;
            store.boss = createBoss(bossHpScale);
            announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
        } else {
            store.enemies = [];
            const spawnCount = 6 + Math.floor(store.world.wave * 1.5);
            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter', 'phantom', 'mech'];
                store.enemies.push(spawnEnemy(types[Math.floor(Math.random() * types.length)]));
            }
            announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
        }
    }
    
    function createBoss(scale) {
        const bossCycle = Math.floor((store.world.wave - 5) / 5) % 3;
        const types = [
            { name: 'MAJOR JUEVO', baseHp: 1200, r: 55, behavior: 'sentinel', color: '#ff8080' },
            { name: 'TRAP KING', baseHp: 1500, r: 50, behavior: 'hex', color: '#66aaff', spawnAddsT: 8},
            { name: 'CORE MALIGNUS', baseHp: 1800, r: 60, behavior: 'malignus', color: '#2E8B57' }
        ];
        const type = types[bossCycle];
        const hp = type.baseHp * scale;
        return { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, mines: [] };
    }

    function spawnEnemy(type = 'drone') {
        const cfgs = {
            drone: { r: 10, v: 80, hp: 25, color: '#C0C0C0', xp: 5, score: 50, shards: 1, fireRateChance: 0.004 },
            hunter: { r: 20, v: 100, hp: 20, color: '#DC143C', xp: 8, score: 80, shards: 1, fireRateChance: 0.005 },
            trap_king_add: { r: 8, v: 90, hp: 10, color: '#ffc83d', damage: 5, xp: 2, score: 10, shards: 1 },
            phantom: { r: 14, v: 90, hp: 40, color: '#FFFFFF', xp: 10, score: 100, shards: 2, fireRateChance: 0.006, fireCooldown: 1.5 },
            mech: { r: 18, v: 40, hp: 90, color: '#FF8500', xp: 15, score: 150, shards: 3, fireRateChance: 0.007 }
        };
        let c = { ...cfgs[type] };
        const wave = store.world.wave;
        if (wave > 1) {
            c.hp *= Math.pow(1.075, wave);
            c.fireRateChance *= 1 + (wave * 0.05);
        }
        return { ...c, type, x: 20 + Math.random() * (W - 40), y: -50 - Math.random() * 250, hpMax: c.hp, phase: type === 'phantom', t: 0, fireT: (c.fireCooldown || 0), isBursting: false, burstTimer: 0 };
    }

    function stepPlayer(dt) {
        const p = store.player;
        const vx = mouse.x - p.x, vy = mouse.y - p.y;
        p.x += (vx * p.speed * dt * 0.005);
        p.y += (vy * p.speed * dt * 0.005);
        p.x = clamp(p.x, 20, W - 20);
        p.y = clamp(p.y, 20, H - 20);
        
        p.fireT -= dt;
        if (p.fireT <= 0) { 
            firePlayer(); 
            p.fireT = p.fireRate; 
        }

        if (p.powerupTimers['missile']) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = 1.1;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });

                if (closest) {
                    store.missiles.push({
                        x: p.x, y: p.y, vx: 0, vy: -300, r: 4, target: closest,
                        speed: 400, turnRate: 3, life: 0, dmg: 45 * p.dmgMult,
                    });
                }
            }
        }
        
        if (p.shieldMax > 0 && p.shield < p.shieldMax) { 
            p.shield = Math.min(p.shieldMax, p.shield + 2 * dt); 
        }
        
        if (p.levelUpEffect) { 
            p.levelUpEffect.t += dt; 
            if (p.levelUpEffect.t >= p.levelUpEffect.maxT) p.levelUpEffect = null; 
        }
        
        for (const key in p.powerupTimers) { 
            p.powerupTimers[key].remaining -= dt; 
            if (p.powerupTimers[key].remaining <= 0) { 
                if (key === 'drones') store.drones = []; 
                delete p.powerupTimers[key]; 
            } 
        }
        
        if (p.voidBeamCooldown > 0) p.voidBeamCooldown -= dt;
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            m.life += dt;
            if (m.life > 6) { m.dead = true; return; }

            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt;
                    m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) {
                m.vx = (m.vx / currentSpeed) * m.speed;
                m.vy = (m.vy / currentSpeed) * m.speed;
            }
            m.x += m.vx * dt; m.y += m.vy * dt;
            
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;

            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            for (const e of targets) {
                if (!e.dead && collide(m, e)) {
                    e.hp -= m.dmg;
                    m.dead = true;
                    explode(m.x, m.y, false, true);
                    break;
                }
            }
        });
    }
    
    function stepWorld(dt) {
        stepPlayer(dt);
        if (store.boss) stepBoss(dt);
        stepHounds(dt);
        stepMissiles(dt);

        const dmgScale = Math.pow(1.065, store.world.wave - 1);

        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        
        store.grenades.forEach(g => { 
            g.x += g.vx * dt; g.y += g.vy * dt; g.fuse -= dt; 
            if (g.fuse <= 0) { g.dead = true; explodeGrenade(g.x, g.y); } 
        });
        
        store.eBullets.forEach(b => { 
            b.x += b.vx * dt; b.y += b.vy * dt; 
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;
            if (collide(b, store.player)) { takeDamage(b.dmg || 10); b.dead = true; }
        });
        
        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) {
                    store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                    mine.dead = true;
                }
                if (collide(mine, store.player)) { takeDamage(50 * dmgScale); mine.dead = true; }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }

        store.enemies.forEach(e => {
            e.t += dt; e.y += e.v * dt;
            if (e.phase) e.x = e.x + Math.sin(e.t * 3) * 80 * dt; 
            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) { takeDamage(15 * dmgScale); e.dead = true; }
            
            e.fireT -= dt;
            if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                switch (e.type) {
                    case 'hunter': { 
                        const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); 
                        store.eBullets.push({ x: e.x, y: e.y, vx: Math.cos(a) * 180, vy: Math.sin(a) * 180, r: 3, col: e.color, dmg: 10 * dmgScale }); 
                        e.fireT = 1.0; break; 
                    }
                    case 'phantom': { 
                        store.eBullets.push({ x: e.x, y: e.y, vx: 0, vy: 180, r: 3, col: e.color, dmg: 8 * dmgScale }); 
                        e.fireT = e.fireCooldown; break; 
                    }
                    case 'mech': { 
                        for (let i = -1; i <= 1; i++) { 
                            const a = (90 + i * 15) * Math.PI / 180; 
                            store.eBullets.push({ x: e.x, y: e.y, vx: Math.cos(a) * 140, vy: Math.sin(a) * 140, r: 4, col: e.color, dmg: 12 * dmgScale }); 
                        } 
                        e.fireT = 2.0; break; 
                    }
                    default: { 
                        store.eBullets.push({ x: e.x, y: e.y, vx: 0, vy: 150, r: 3, col: e.color, dmg: 8 * dmgScale }); 
                        e.fireT = 0.5; 
                    }
                }
            }
        });
        
        store.bullets.forEach(b => {
            b.x += b.vx * dt; b.y += b.vy * dt;
            if (b.isSwirl) { b.life = (b.life || 0) + dt; b.x += Math.sin(b.life * 15) * 150 * dt; }
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;
            
            store.enemies.forEach(e => { 
                if (!e.dead && collide(b, e)) { 
                    const dmg = b.dmg || 20; e.hp -= dmg; 
                    if (e.hp <= 0) { 
                        e.dead = true; store.world.score += e.score; 
                        store.world.shards += e.shards;
                        store.world.xp += e.xp; store.world.kills++; 
                        spawnPowerup(e.x, e.y); 
                        if (store.player.vampirism > 0) store.player.hp = Math.min(store.player.hpMax, store.player.hp + dmg * store.player.vampirism);
                        explode(e.x, e.y); 
                    } 
                    if (b.explosive) explode(b.x, b.y, false, true); 
                    if (!b.pierce) b.dead = true; 
                } 
            });
            
            if (store.boss && !b.dead && collide(b, store.boss)) { 
                let dmg = b.dmg || 20; if (b.isDrone) dmg *= 0.4; store.boss.hp -= dmg; 
                if (store.boss.hp <= 0) { 
                    store.world.score += 2000; store.world.shards += 25; store.world.xp += 100; store.world.bosses++; 
                    store.boss = null; announce('‚ö° GUARDIAN DEFEATED ‚ö°'); explode(b.x, b.y, true); 
                } 
                if (b.explosive) explode(b.x, b.y, false, true); 
                if (!b.pierce) b.dead = true; 
            }
        });
        
        store.powerups.forEach(p => { 
            p.y += 40 * dt; 
            if (collide(p, store.player)) { p.dead = true; applyPowerup(p.type); } 
            if (p.y > H + 20) p.dead = true; 
        });

        store.bullets = store.bullets.filter(b => !b.dead); 
        store.eBullets = store.eBullets.filter(b => !b.dead); 
        store.enemies = store.enemies.filter(e => !e.dead); 
        store.powerups = store.powerups.filter(p => !p.dead); 
        store.grenades = store.grenades.filter(g => !g.dead);
        store.missiles = store.missiles.filter(m => !m.dead);
        store.activeEffects = store.activeEffects.filter(e => e.isActive !== false);
        
        if (!store.boss && store.enemies.length === 0) { store.world.wave++; initWave(); }

        const xpNeeded = store.world.level * 100; 
        if (store.world.xp >= xpNeeded) { store.world.xp -= xpNeeded; store.world.level++; levelUp(); }
        
        if (store.player.hp <= 0) handleGameOver();
    }

    function explode(x, y, isBoss = false, isSmall = false) {
        if (isBoss) for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
    }
    
    function levelUp() { 
        announce(`LEVEL UP! ‚ö° CHOOSE YOUR AUGMENTATION!`); 
        store.player.levelUpEffect = { t: 0, maxT: 1 }; store.player.speed *= 1.5; store.player.multishot += 2; 
        setTimeout(() => { store.player.speed /= 1.5; store.player.multishot -= 2; }, 3000); 
        store.isPaused = true; 
        const panel = q('levelPanel'), grid = q('skillsGrid'); 
        const multiShotUpgrade = LEVEL_UPGRADES.find(u => u.id === 'multi'); 
        let otherUpgrades = LEVEL_UPGRADES.filter(u => u.id !== 'multi'); 
        for (let i = otherUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [otherUpgrades[i], otherUpgrades[j]] = [otherUpgrades[j], otherUpgrades[i]]; } 
        const choices = [multiShotUpgrade, ...otherUpgrades.slice(0, 2)]; 
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div>`).join(''); 
        grid.querySelectorAll('.skill-card').forEach(c => c.addEventListener('click', () => { 
            const id = c.dataset.id; const upgrade = LEVEL_UPGRADES.find(s => s.id === id); 
            if (upgrade) upgrade.apply(); 
            panel.classList.add('hide'); store.isPaused = false; 
        })); 
        panel.classList.remove('hide'); 
    }
    
    function handleGameOver() { 
        if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); 
        addScore(store.world.score); announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£'); 
        q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide'); 
    }
    
    function resetGame() {
        store.player = JSON.parse(JSON.stringify(player_initial_state));
        store.world = { wave: 1, score: 0, shards: 0, xp: 0, level: 1, kills: 0, bosses: 0 };
        store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = [];
        store.powerups = []; store.drones = []; store.grenades = []; store.hounds = []; store.missiles = []; store.activeEffects = [];
        store._startTs = performance.now(); store.isGameOver = false;
        q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide');
        initWave();
    }

    // --- RENDER & DRAW FUNCTIONS ---
    const starCountA = 100, starCountB = 80;
    const starsA = Array.from({ length: starCountA }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.5, pulse: Math.random() * 10 }));
    const starsB = Array.from({ length: starCountB }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 2, pulse: Math.random() * 10 }));

    function render(dt) {
        ctx.fillStyle = '#050008'; ctx.fillRect(0, 0, W, H);
        const time = performance.now() / 1000;
        ctx.globalAlpha = 0.8; 
        for (const s of starsA) { s.y += 30 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(255,0,255,${0.5 + 0.5 * Math.sin(time * 2 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, 2 * Math.PI); ctx.fill(); }
        ctx.globalAlpha = 0.6; 
        for (const s of starsB) { s.y += 60 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(204,0,255,${0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, Math.max(0.1, s.r * (0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse))), 0, 2 * Math.PI); ctx.fill(); }
        ctx.globalAlpha = 1;
        
        store.powerups.forEach(p => drawPowerup(p));
        store.grenades.forEach(g => drawGrenade(g));
        store.missiles.forEach(m => drawMissile(m));
        store.eBullets.forEach(b => { ctx.fillStyle = b.col; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, 2 * Math.PI); ctx.fill(); });
        store.bullets.forEach(b => { ctx.fillStyle = b.col; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, 2 * Math.PI); ctx.fill(); });
        if(store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(performance.now() / 200)})`;
                ctx.fill(); ctx.restore();
            });
        }
        store.enemies.forEach(e => drawEnemy(e));
        if (store.boss) drawBoss(store.boss);
        store.drones.forEach(d => drawDrone(d));
        store.hounds.forEach(h => drawHound(h));
        drawShip(store.player.x, store.player.y);
        drawPlayerAbilityButtons(store.player);
        store.activeEffects.forEach(e => e.draw && e.draw());
        if (store.player.levelUpEffect) { 
            const e = store.player.levelUpEffect, p = e.t / e.maxT; 
            ctx.save(); ctx.translate(store.player.x, store.player.y); ctx.strokeStyle = `rgba(178,102,255,${1 - p})`; 
            ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, p * 150, 0, 2 * Math.PI); ctx.stroke(); ctx.restore(); 
        }
        updateHUD();
    }
    
    function takeDamage(dmg) { 
        if (store.player.hasShieldBubble) { store.player.hasShieldBubble = false; store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y)); return; } 
        const p = store.player, a = Math.min(p.shield, dmg); p.shield -= a; dmg -= a; p.hp = Math.max(0, p.hp - dmg); 
    }
    
    function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    
    function announce(text) { 
        const el = q('announce'); el.textContent = text; el.classList.remove('hide'); 
        clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); 
    }
    
    function updateHUD() {
        q("hudWaveContent").innerHTML = `<div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div><div style="text-align:center">SECTOR <b>${store.world.wave}</b> ‚Ä¢ KILLS <b>${store.world.kills}</b> ‚Ä¢ LVL <b>${store.world.level}</b></div>`;
        const t = store.player, e = Math.round(t.hp / t.hpMax * 100), o = t.shieldMax > 0 ? Math.round(t.shield / t.shieldMax * 100) : 0;
        q("hudPilotContent").innerHTML = `<div class="hud-title">${store.name ? `‚ó¢ ${escapeHtml(store.name)} ‚ó£` : "‚ó¢ UNIDENTIFIED ‚ó£"}</div><div style="text-align:center">SCORE <b>${store.world.score}</b> ‚Ä¢ SHARDS <b>${store.world.shards}</b></div><div class="bar"><span style="width:${e}%"></span></div>${t.shieldMax > 0 ? `<div class="bar" style="margin-top:2px;"><span style="width:${o}%;background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>` : ""}`;
        
        if (store.boss) {
            q("hudBossContent").classList.remove("hide");
            q("hudBossContent").innerHTML = `<div class="hud-title">‚ö° ${store.boss.name} ‚ö°</div><div class="bar"><span style="width:${Math.round(store.boss.hp / store.boss.hpMax * 100)}%"></span></div>`;
        } else { q("hudBossContent").classList.add("hide"); }
        
        const powerupEl = q("hudPowerup");
        const timedPowerups = Object.keys(store.player.powerupTimers);
        let timedContent = '';
        if (timedPowerups.length > 0) {
            timedPowerups.forEach(key => {
                const timer = store.player.powerupTimers[key]; const percent = Math.min(100, (timer.remaining / timer.max) * 100);
                timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`;
            });
        }
        powerupEl.innerHTML = `<div class="hud-title">‚ó¢ SYSTEMS ONLINE ‚ó£</div>${timedContent}`;
        powerupEl.classList.toggle('hide', !timedContent);
        
        const equipEl = q("hudEquipment");
        if (store.player.hasLauncher || store.player.hasHounds) {
            equipEl.classList.remove('hide'); let content = `<div class="hud-title">‚ó¢ EQUIPMENT ‚ó£</div>`;
            if (store.player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`;
            if (store.player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`;
            equipEl.innerHTML = content;
        } else { equipEl.classList.add('hide'); }
        
        const voidBeamBtn = q('voidBeamBtnUI');
        if (store.player.hasVoidBeam) {
            voidBeamBtn.classList.remove('hide'); const cd = store.player.voidBeamCooldown;
            if (cd > 0) { voidBeamBtn.textContent = `VOID BEAM [${Math.ceil(cd)}s]`; voidBeamBtn.disabled = true; } 
            else { voidBeamBtn.textContent = 'VOID BEAM [READY]'; voidBeamBtn.disabled = false; }
        } else { voidBeamBtn.classList.add('hide'); }
        
        const grenadeBtn = q('grenadeBtnUI');
        if (store.player.grenades > 0) {
            grenadeBtn.classList.remove('hide'); grenadeBtn.textContent = `GRENADE [${store.player.grenades}]`; grenadeBtn.disabled = false;
        } else { grenadeBtn.classList.add('hide'); }
    }

    // ... (All other functions from drawShip to the end of the script remain largely the same, but with the new function calls and logic integrated where appropriate) ...
    
    // THE FOLLOWING FUNCTIONS ARE INCLUDED FOR COMPLETENESS, BUT THE KEY CHANGES ARE ABOVE.
    // ...
    function updateLeaderboard(top10) { 
        const fallbackData = [{ name: "ACE PILOT", score: 50000, waves: 10 },{ name: "VOID RUNNER", score: 35000, waves: 8 },{ name: "STAR HUNTER", score: 25000, waves: 6 },{ name: "NOVA STRIKER", score: 18000, waves: 5 },{ name: "COSMIC GUARD", score: 12000, waves: 4 }];
        const data = top10 && top10.length > 0 ? top10 : fallbackData;
        q("hsList").innerHTML = data.map(s => `<li>${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); 
        q("hsListPopup").innerHTML = data.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); 
    }
    
    async function refreshScoreList() { 
        try { 
            const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 }); 
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            const data = await res.json(); updateLeaderboard(data); 
        } catch (err) { console.warn("Failed to fetch leaderboard, using offline data:", err.message); updateLeaderboard(null); } 
    }
    
    async function addScore(score) { 
        const name = (store.name || "ROGUE").slice(0, 16); 
        try { 
            const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 }); 
            if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`);
            const { nonce } = await nonceRes.json(); 
            const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce }; 
            const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 }); 
            if (!res.ok) throw new Error(`Submit failed: ${res.status}`);
            const data = await res.json(); 
            if (data.ok) { updateLeaderboard(data.top10); } 
            else { console.warn("Score rejected:", data.err); announce(`Score rejected: ${data.err}`); refreshScoreList(); } 
        } catch (err) { console.warn("Score submission failed, game continues offline:", err.message); } 
    }
    
    function fireBullet(x, y, vx, vy, props = {}) { 
        const p = store.player; 
        store.bullets.push({ x, y, vx, vy, r: p.explosive ? 5 : 3, col: p.explosive ? "#cc99ff" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive, ...props }); 
    }
    
    function firePlayer() {
        const p = store.player, bulletSpeed = 420;
        const effectiveMultishot = Math.max(1, Math.min(p.multishot, 3) + Math.floor(Math.max(0, p.multishot - 3) * 0.5));
        const angleSpread = effectiveMultishot > 2 ? 15 : 10;
        for (let i = 0; i < effectiveMultishot; i++) {
            const angle = (i - (effectiveMultishot - 1) / 2) * angleSpread * Math.PI / 180;
            store.bullets.push({ x: p.x + 10 * Math.sin(angle), y: p.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: p.explosive ? "#cc99ff" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive });
        }
        store.drones.forEach(drone => store.bullets.push({ x: p.x + drone.offset, y: p.y + 20, vx: 0, vy: -bulletSpeed, r: 3, col: "#66aaff", dmg: 20 * p.dmgMult * 0.4, isDrone: true }));
        if (p.hasLauncher) {
            const speed = 350;
            store.bullets.push({ x: p.x - 15, y: p.y, vx: -50, vy: -speed, r: 4, col: '#ff8080', dmg: 5 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
            store.bullets.push({ x: p.x + 15, y: p.y, vx: 50, vy: -speed, r: 4, col: '#ff8080', dmg: 5 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
        }
    }
    
    function stepBoss(dt) { 
        if (!store.boss) return; const b = store.boss; b.t += dt; 
        if (b.y < 100) { b.y += b.vy * dt; } 
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        switch (b.behavior) { 
            case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break; 
            case 'malignus': stepBossCoreMalignus(dt, b, dmgScale); break; 
            case 'hex': stepBossTheHex(dt, b, dmgScale); break;
        } 
    }
    
    function stepBossOmegaSentinel(dt, b, dmgScale) { 
        if (b.y >= 100) { b.moveT += dt; b.x += Math.sin(b.moveT * 2) * 200 * dt; b.x = clamp(b.x, 100, W - 100); } 
        b.fireT -= dt; 
        if (b.fireT <= 0) { 
            if (b.patternPhase % 4 === 0) { 
                b.fireT = 1.5; const n = 12; 
                for (let i = 0; i < n; i++) { const a = (i * Math.PI / 6) + b.t; store.eBullets.push({ x: b.x, y: b.y, vx: 150 * Math.cos(a), vy: 150 * Math.sin(a), r: 4, col: b.color, dmg: 12 * dmgScale }); } 
            } else { 
                b.fireT = 0.2; const a = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                store.eBullets.push({ x: b.x, y: b.y, vx: 250 * Math.cos(a), vy: 250 * Math.sin(a), r: 5, col: b.color, dmg: 18 * dmgScale }); 
            } 
            b.patternPhase++; 
        } 
    }

    function stepBossCoreMalignus(dt, b, dmgScale) { 
        if (b.y >= 100) { b.moveT += dt; b.x = W / 2 + (W / 2 - 100) * Math.sin(b.moveT * 0.5); } 
        b.fireT -= dt; 
        if (b.fireT <= 0) { 
            b.fireT = 0.8; const n = 12, g = 3, s = Math.floor(Math.random() * (n - g)); 
            for (let i = 0; i < n; i++) { 
                if (i >= s && i < s + g) continue; 
                const p = (W / (n + 1)) * (i + 1); 
                store.eBullets.push({ x: p, y: b.y, vx: 0, vy: 180, r: 6, col: b.color, dmg: 20 * dmgScale }); 
            } 
        } 
    }

    function stepBossTheHex(dt, b, dmgScale) {
        if (b.y >= 100) { b.moveT += dt; b.x = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4)); }
        b.fireT -= dt;
        if (b.fireT <= 0) {
            b.fireT = 1.5; b.mines.push({ x: b.x, y: b.y + 40, fuse: 2, dead: false });
            for (let i = -1; i <= 1; i++) {
                const a = Math.atan2(store.player.y - b.y, store.player.x - b.x) + i * 0.2;
                store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(a) * 160, vy: Math.sin(a) * 160, r: 4, col: '#80ffff', dmg: 10 * dmgScale });
            }
        }
        b.spawnAddsT -= dt;
        if (b.spawnAddsT <= 0) {
            b.spawnAddsT = 12; 
            for (let i = 0; i < 3; i++) {
                setTimeout(() => { const enemy = spawnEnemy('trap_king_add'); enemy.x = (i % 2 === 0) ? -30 : W + 30; enemy.y = b.y + Math.random() * 100; enemy.v = 50; enemy.phase = true; store.enemies.push(enemy); }, i * 400);
            }
        }
    }
    
    function drawMissile(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2);
        
        ctx.fillStyle = "#ffddff"; ctx.shadowColor = '#ff8080'; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(4, 5); ctx.lineTo(-4, 5); ctx.closePath(); ctx.fill();
        
        ctx.shadowBlur = 0;
        const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
        ctx.fillStyle = `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;
        ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(3, 5 + flameSize / 2); ctx.lineTo(-3, 5 + flameSize / 2); ctx.closePath(); ctx.fill();
        ctx.restore();
    }
    
    // ... (rest of draw functions: drawPowerup, drawDrone, drawBoss, drawShip, etc. are unchanged)
    
    // This is a placeholder for the numerous unchanged drawing functions. 
    // The full, correct code is generated in the single block, but these are here to show the structure.
    function drawPowerup(p) { const cfg=POWERUP_TYPES[p.type];ctx.save();ctx.translate(p.x,p.y);const pulse=.8+.2*Math.sin(performance.now()/150);ctx.scale(pulse,pulse);ctx.beginPath();ctx.arc(0,0,p.r+3,0,2*Math.PI);const grad=ctx.createRadialGradient(0,0,0,0,0,p.r+3);grad.addColorStop(0,"#FFD70099");grad.addColorStop(1,"#FFD70000");ctx.fillStyle=grad;ctx.fill();ctx.beginPath();ctx.arc(0,0,p.r,0,2*Math.PI);ctx.fillStyle="#FFD70044";ctx.fill();ctx.strokeStyle="#FFD700";ctx.lineWidth=2;ctx.stroke();ctx.fillStyle="#FFFFFF";ctx.font="bold 16px Orbitron";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(cfg.icon,0,1);ctx.restore() }
    function drawDrone(d) { const p=store.player;ctx.save();ctx.translate(p.x+d.offset,p.y+20);ctx.beginPath();ctx.moveTo(0,-8);ctx.lineTo(6,6);ctx.lineTo(-6,6);ctx.closePath();ctx.fillStyle="#c49cff";ctx.fill();ctx.restore() }
    function drawBoss(t) { ctx.save();ctx.translate(t.x,t.y);ctx.fillStyle="rgba(0,0,0,0.7)";ctx.fillRect(-60,-t.r-20,120,8);ctx.fillStyle=t.color;ctx.fillRect(-60,-t.r-20,120*(t.hp/t.hpMax),8);ctx.strokeStyle="#fff";ctx.lineWidth=1;ctx.strokeRect(-60,-t.r-20,120,8);if(t.behavior==="malignus"){const time=performance.now()/1e3;ctx.fillStyle=t.color;ctx.beginPath();const pulse=t.r*(.3+.05*Math.sin(4*time));ctx.arc(0,0,pulse,0,2*Math.PI);ctx.fill();ctx.fillStyle="white";ctx.beginPath();ctx.arc(0,0,.4*pulse,0,2*Math.PI);ctx.fill();const numShards=5;for(let i=0;i<numShards;i++){ctx.save();const angle=time*(.5+.1*i)+i*2*Math.PI/numShards,dist=.8*t.r;ctx.rotate(angle);ctx.translate(dist,0);ctx.rotate(2*time);ctx.fillStyle=t.color+"aa";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=2;ctx.beginPath();const shardSize=.3*t.r;ctx.moveTo(0,-shardSize);ctx.lineTo(shardSize/2,shardSize);ctx.lineTo(-shardSize/2,shardSize);ctx.closePath();ctx.fill();ctx.stroke();ctx.restore()}}else if(t.behavior==="hex"){const time=performance.now()/1e3;ctx.fillStyle="#66aaff";ctx.strokeStyle="#ff8080";ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(0,-1.5*t.r);ctx.lineTo(t.r,-.7*t.r);ctx.lineTo(.8*t.r,t.r);ctx.lineTo(-.8*t.r,t.r);ctx.lineTo(-t.r,-.7*t.r);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(0,.2*t.r,.6*t.r,0,2*Math.PI);ctx.fillStyle="rgba(255, 128, 128, "+(.4+.3*Math.sin(5*time))+")";ctx.fill()}else{ctx.strokeStyle=t.color;ctx.lineWidth=3;for(let e=0;e<3;e++){ctx.save();ctx.rotate(t.t*(1+.5*e));ctx.beginPath();ctx.arc(0,0,t.r-10*e,0,2*Math.PI);ctx.stroke();ctx.restore()}ctx.fillStyle=t.color+"aa";ctx.beginPath();ctx.arc(0,0,Math.max(1,.3*t.r*(.8+.2*Math.sin(3*t.t))),0,2*Math.PI);ctx.fill()}ctx.restore() }
    function drawShip(t, e) { ctx.save();ctx.translate(t,e);if(store.player.hasShieldBubble){ctx.beginPath();ctx.arc(0,0,24,0,2*Math.PI);const g=ctx.createRadialGradient(0,0,18,0,0,24);g.addColorStop(0,"#9a66ff11");g.addColorStop(1,"#9a66ff");ctx.fillStyle=g;ctx.fill()}ctx.beginPath();ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);ctx.closePath();const o=ctx.createLinearGradient(0,-20,0,14);o.addColorStop(0,"#b266ff");o.addColorStop(.5,"#7a49cc");o.addColorStop(1,"#4d2a80");ctx.fillStyle=o;ctx.fill();ctx.lineWidth=2;ctx.strokeStyle="#c49cff";ctx.stroke();ctx.strokeStyle="#b266ff";ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();const r=performance.now()/1e3;ctx.globalAlpha=.8+.2*Math.sin(10*r);ctx.fillStyle="#cc99ff";ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,2*Math.PI);ctx.ellipse(5,16,3,6,0,0,2*Math.PI);ctx.fill();ctx.globalAlpha=1;ctx.fillStyle="#ffffff";ctx.beginPath();ctx.arc(0,-8,3,0,2*Math.PI);ctx.fill();ctx.restore() }
    function drawGrenade(g) { ctx.save();ctx.translate(g.x,g.y);ctx.rotate(5*g.fuse);ctx.fillStyle="#ff8080";ctx.beginPath();ctx.arc(0,0,8,0,2*Math.PI);ctx.fill();ctx.fillStyle="white";ctx.beginPath();ctx.arc(0,0,3,0,2*Math.PI);ctx.fill();ctx.restore() }
    function drawEnemy(e) { const{x:t,y:o,r:a,type:r,color:n,hp:l,hpMax:s,t:c}=e;ctx.save();ctx.translate(t,o);l<s&&l>0&&(ctx.fillStyle="rgba(0,0,0,0.5)",ctx.fillRect(-a,-a-8,2*a,3),ctx.fillStyle="#b266ff",ctx.fillRect(-a,-a-8,2*a*(l/s),3));ctx.lineWidth=2;ctx.beginPath();switch(r){case"drone":const e=ctx.createLinearGradient(-a,-a,a,a);e.addColorStop(0,"#E0E0E0");e.addColorStop(1,"#A0A0A0");ctx.fillStyle=e;ctx.strokeStyle="#808080";ctx.beginPath();ctx.moveTo(-1.2*a,0);ctx.quadraticCurveTo(0,-a,1.2*a,0);ctx.quadraticCurveTo(0,.6*a,-1.2*a,0);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#aaddff";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-.2*a,.6*a,Math.PI,0);ctx.fill();ctx.stroke();ctx.fillStyle="#32CD32";ctx.beginPath();ctx.ellipse(0,-.2*a,.3*a,.4*a,0,0,2*Math.PI);ctx.fill();ctx.fillStyle="#000000";ctx.beginPath();ctx.ellipse(-.1*a,-.25*a,.08*a,.15*a,-.5,0,2*Math.PI);ctx.ellipse(.1*a,-.25*a,.08*a,.15*a,.5,0,2*Math.PI);ctx.fill();break;case"hunter":ctx.shadowColor=n;ctx.shadowBlur=15;ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-a);ctx.lineTo(.8*a,.8*a);ctx.lineTo(0,.3*a);ctx.lineTo(-.8*a,.8*a);ctx.closePath();ctx.fill();ctx.stroke();ctx.shadowBlur=0;break;case"phantom":ctx.globalAlpha=.6+.4*Math.sin(5*c);ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-.8*a);ctx.quadraticCurveTo(a,-.5*a,.8*a,.8*a);ctx.quadraticCurveTo(0,.5*a,-.8*a,.8*a);ctx.quadraticCurveTo(-a,-.5*a,0,-.8*a);ctx.closePath();ctx.fill();ctx.stroke();for(let e=-1;e<=1;e++)ctx.beginPath(),ctx.moveTo(e*.4*a,.6*a),ctx.quadraticCurveTo(e*.5*a,a,e*.3*a+2*Math.sin(4*c+e),1.2*a),ctx.stroke();break;case"mech":ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.rect(-.8*a,-.6*a,1.6*a,1.2*a);ctx.moveTo(-.8*a,-.4*a);ctx.lineTo(-1.2*a,0);ctx.lineTo(-.8*a,.4*a);ctx.moveTo(.8*a,-.4*a);ctx.lineTo(1.2*a,0);ctx.lineTo(.8*a,.4*a);ctx.fill();ctx.stroke();ctx.fillStyle="#ff99cc";ctx.beginPath();ctx.arc(0,0,.3*a,0,2*Math.PI);ctx.fill();break;case"trap_king_add":ctx.fillStyle=n;ctx.strokeStyle="#ffaa00";ctx.beginPath();ctx.arc(0,0,a,0,2*Math.PI);ctx.fill();ctx.stroke()}ctx.restore() }
    function drawPlayerAbilityButtons(player) { const availableAbilities=[];player.grenades>0&&availableAbilities.push({type:"grenade",label:`GRENADE [${player.grenades}]`});player.hasVoidBeam&&player.voidBeamCooldown<=0&&availableAbilities.push({type:"voidBeam",label:"VOID BEAM"});canvasButtons.grenade.visible=!1;canvasButtons.voidBeam.visible=!1;if(0!==availableAbilities.length){const totalWidth=availableAbilities.length*canvasButtons.grenade.w+(availableAbilities.length-1)*10;let startX=player.x-totalWidth/2;const startY=player.y+35;ctx.font="bold 10px Orbitron";ctx.textAlign="center";ctx.textBaseline="middle";availableAbilities.forEach(ability=>{const btn=canvasButtons[ability.type];btn.x=startX;btn.y=startY;btn.visible=!0;ctx.globalAlpha=.8;ctx.fillStyle="#330044";ctx.strokeStyle="#b266ff";ctx.lineWidth=1;ctx.fillRect(btn.x,btn.y,btn.w,btn.h);ctx.strokeRect(btn.x,btn.y,btn.w,btn.h);ctx.fillStyle="#ffddff";ctx.fillText(ability.label,btn.x+btn.w/2,btn.y+btn.h/2);ctx.globalAlpha=1;startX+=btn.w+10})}}
    function createEffect(type,x,y){let effect={isActive:!0,life:1,maxLife:1,x,y};switch(type){case"grenadeExplosion":effect.maxLife=.5;effect.radius=150;effect.step=function(dt){this.life-=2*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.beginPath();ctx.arc(this.x,this.y,this.radius*(1-this.life),0,2*Math.PI);ctx.fillStyle=`rgba(255, 128, 128, ${.8*this.life})`;ctx.fill()};break;case"shieldBreak":effect.maxLife=.6;effect.step=function(dt){this.life-=1.5*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.strokeStyle=`rgba(154, 102, 255, ${this.life})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(this.x,this.y,24*(1.5-this.life),0,2*Math.PI);ctx.stroke()};break;case"voidBeam":effect.maxLife=2;effect.step=function(dt){this.life-=dt/this.maxLife;this.life<=0&&(this.isActive=!1);const beamWidth=200,beamDmg=200*store.player.dmgMult*dt;store.enemies.forEach(e=>{Math.abs(e.x-store.player.x)<beamWidth/2&&(e.hp-=beamDmg)});store.boss&&Math.abs(store.boss.x-store.player.x)<beamWidth/2&&(store.boss.hp-=beamDmg)};effect.draw=function(){const beamWidth=200,p=store.player;ctx.fillStyle=`rgba(255, 255, 255, ${.4*Math.sin(this.life*Math.PI)})`;ctx.fillRect(p.x-beamWidth/2,0,beamWidth,H);ctx.fillStyle=`rgba(178, 102, 255, ${.3*Math.sin(this.life*Math.PI)})`;ctx.fillRect(p.x-beamWidth/4,0,beamWidth/2,H)}}return effect}
    function explodeGrenade(x,y){store.activeEffects.push(createEffect("grenadeExplosion",x,y));const radius=150;store.enemies.forEach(e=>{(e.x-x)**2+(e.y-y)**2<radius**2&&(e.hp-=.5*e.hpMax)})}
    function showShop(){store.isPaused=!0;q("pauseBtn").classList.add("hide");const panel=q("shopPanel"),grid=q("shopGrid"),shardsEl=q("shopShards");shardsEl.textContent=store.world.shards;let content="";for(const key in SHOP_UPGRADES){const u=SHOP_UPGRADES[key];let currentLevel=store.player.upgradeLevels[key]||0,isDisabled=!1,cost=0,desc=u.desc(currentLevel),name=u.name;u.isPremium?(cost=u.cost,"repair"===key?store.player.hp>=store.player.hpMax&&(isDisabled=!0,desc="Health is already full."):u.isUnlock?("void_beam"===key&&store.player.hasVoidBeam||"launcher"===key&&store.player.hasLauncher||"ghost_hounds"===key&&store.player.hasHounds)&&(isDisabled=!0,desc="Already Unlocked"):store.player.grenades>=u.max&&(isDisabled=!0,desc="At maximum capacity")):(currentLevel>=u.maxLevel&&(isDisabled=!0,desc="Max Level Reached"),cost=Math.floor(u.baseCost*u.scale**currentLevel));store.world.shards<cost&&(isDisabled=!0);content+=`<div class="skill-card shop-item ${isDisabled?"disabled":""}" data-key="${key}"> <div class="skill-title">${name}</div> <div class="skill-desc">${desc}</div> <div style="color:var(--accent);margin-top:4px;">Cost: ${cost>0?cost:"---"} shards</div> </div>`}grid.innerHTML=content;grid.querySelectorAll(".shop-item").forEach(item=>{item.addEventListener("click",()=>{if(!item.classList.contains("disabled")){const key=item.dataset.key,upgrade=SHOP_UPGRADES[key];let cost=0;cost=upgrade.isPremium?upgrade.cost:Math.floor(upgrade.baseCost*upgrade.scale**(store.player.upgradeLevels[key]||0));if(store.world.shards>=cost){let purchaseSuccessful=!1;purchaseSuccessful=upgrade.isPremium?upgrade.apply():(upgrade.effect(),store.player.upgradeLevels[key]=(store.player.upgradeLevels[key]||0)+1,!0);purchaseSuccessful&&(store.world.shards-=cost);showShop()}}})});panel.classList.remove("hide")}
    function createHound(side){return{x:store.player.x+50*side,y:store.player.y+20,side,target:null,attackT:0,r:12}}
    function stepHounds(dt){if(store.player.hasHounds)store.hounds.forEach(h=>{if(!h.target||h.target.dead||h.target.hp<=0){let closest=null,closestDist=1/0;const potentialTargets=store.boss?[...store.enemies,store.boss]:store.enemies;potentialTargets.forEach(e=>{if(!e.dead&&!(e.hp<=0)){const dist=(h.x-e.x)**2+(h.y-e.y)**2;dist<closestDist&&(closest=e,closestDist=dist)}});h.target=closest}if(h.target){const tx=h.target.x,ty=h.target.y,dx=tx-h.x,dy=ty-h.y,dist=Math.sqrt(dx*dx+dy*dy),speed=350;dist>30?(h.x+=dx/dist*speed*dt,h.y+=dy/dist*speed*dt):(h.attackT-=dt,h.attackT<=0&&(h.attackT=.25,h.target.hp-=(h.target===store.boss?2.4:8)*store.player.dmgMult))}else{const tx=store.player.x+50*h.side,ty=store.player.y+20,dx=tx-h.x,dy=ty-h.y,dist=Math.sqrt(dx*dx+dy*dy);dist>5&&(h.x+=5*dx*dt,h.y+=5*dy*dt)}})}
    function drawHound(h){ctx.save();ctx.translate(h.x,h.y);const time=performance.now()/100;ctx.globalAlpha=.5+.2*Math.sin(time+h.side);ctx.fillStyle="#9a66ff";ctx.beginPath();ctx.arc(0,0,h.r,Math.PI,0);ctx.lineTo(h.r,h.r);ctx.lineTo(.6*h.r,.7*h.r);ctx.lineTo(0,h.r);ctx.lineTo(-.6*h.r,.7*h.r);ctx.lineTo(-h.r,h.r);ctx.closePath();ctx.fill();ctx.fillStyle="#000";ctx.beginPath();ctx.arc(-4,-2,2,0,2*Math.PI);ctx.arc(4,-2,2,0,2*Math.PI);ctx.fill();ctx.restore()}
    function activateVoidBeam(){store.player.hasVoidBeam&&store.player.voidBeamCooldown<=0&&!store.isPaused&&(store.player.voidBeamCooldown=20,store.activeEffects.push(createEffect("voidBeam")))}
    function useGrenade(){store.player.grenades>0&&!store.isPaused&&(store.player.grenades--,store.grenades.push({x:store.player.x,y:store.player.y,vx:0,vy:-200,fuse:1.5,r:8}))}
    function ensureName(){if(!store.name){store.isPaused=!0;q("namePanel").classList.remove("hide");q("nameInput").value="";setTimeout(()=>q("nameInput").focus(),50)}}
    q("restartBtn").addEventListener("click",resetGame);
    q("saveName").addEventListener("click",()=>{const t=(q("nameInput").value||"").slice(0,16).trim();t&&(store.name=t,q("namePanel").classList.add("hide"),store.isPaused=!1)});
    q("closeShop").addEventListener("click",()=>{q("shopPanel").classList.add("hide");store.isPaused=!1;q("pauseBtn").classList.remove("hide")});
    q("shopBtn").addEventListener("click",showShop);
    q("menuBtn").addEventListener("click",()=>{store.isPaused=!0;q("scorePanel").classList.remove("hide");q("pauseBtn").classList.add("hide")});
    q("closeScores").addEventListener("click",()=>{store.isPaused=!1;q("scorePanel").classList.add("hide");q("pauseBtn").classList.remove("hide")});
    q("fsEnterBtn").addEventListener("click",()=>{const r=document.documentElement;document.fullscreenElement?document.exitFullscreen&&document.exitFullscreen():r.requestFullscreen?r.requestFullscreen():r.webkitRequestFullscreen?r.webkitRequestFullscreen():r.msRequestFullscreen&&r.msRequestFullscreen()});
    q("pauseBtn").addEventListener("click",()=>{!store.isGameOver&&q("shopPanel").classList.contains("hide")&&q("levelPanel").classList.contains("hide")&&q("namePanel").classList.contains("hide")&&q("scorePanel").classList.contains("hide")&&(store.isPaused=!store.isPaused,q("pauseBtn").textContent=store.isPaused?"RESUME":"PAUSE")});
    q("grenadeBtnUI").addEventListener("click",useGrenade);
    q("voidBeamBtnUI").addEventListener("click",activateVoidBeam);
    q("nameInput").addEventListener("keydown",e=>{if("Enter"===e.key){const t=(q("nameInput").value||"").slice(0,16).trim();t&&(store.name=t,q("namePanel").classList.add("hide"),store.isPaused=!1)}});
    addEventListener("keydown",e=>{const key=e.key.toLowerCase();"INPUT"!==document.activeElement.tagName&&(" "===key&&(e.preventDefault(),useGrenade()),"b"===key&&activateVoidBeam())});
    function frame(now){const dt=Math.min(.033,(now-store.last)/1e3);store.last=now;!store.isGameOver&&!store.isPaused&&stepWorld(dt);render(dt);q("fps").textContent=(1/dt).toFixed(0);requestAnimationFrame(frame)}
    try{initWave();refreshScoreList();ensureName();requestAnimationFrame(frame)}catch(error){console.error("Game initialization failed:",error);try{updateLeaderboard(null);ensureName();requestAnimationFrame(frame);console.log("Game started in offline mode")}catch(criticalError){console.error("Critical startup failure:",criticalError);alert("Game failed to start. Please refresh the page.")}}
    
})();
</script>
</body>
</html>
