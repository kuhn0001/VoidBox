<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg%20xmlns%3D%27http://www.w3.org/2000/svg%27%20viewBox%3D%270%200%2064%2064%27%3E%3Crect%20width%3D%2764%27%20height%3D%2764%27%20rx%3D%2712%27%20fill%3D%27%23130029%27/%3E%3Cpath%20d%3D%27M16%2044L32%2020l16%2024%27%20stroke%3D%27%23ff66cc%27%20stroke-width%3D%276%27%20stroke-linecap%3D%27round%27%20stroke-linejoin%3D%27round%27%20fill%3D%27none%27/%3E%3Ccircle%20cx%3D%2732%27%20cy%3D%2732%27%20r%3D%276%27%20fill%3D%27%238a7fff%27/%3E%3C/svg%3E" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap"
        rel="stylesheet" />
    <!-- PixiJS v8 -->
    <script src="https://pixijs.download/release/pixi.js"></script>
    <title>Void Skies</title>
    <style>
        :root {
            --bg: #050008;
            --fg: #ff99cc;
            --accent: #b266ff;
            --accent2: #9a66ff;
            --edge: rgba(178, 102, 255, .35);
            --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px);
            --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px);
            --maxw: 98vw;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: radial-gradient(1200px 800px at 50% 40%, #330044, var(--bg));
            color: var(--fg);
            font-family: 'Audiowide', ui-sans-serif, system-ui
        }

        /* Hide VS Code browser controls */
        .monaco-workbench .part.titlebar,
        .vs-dark .monaco-workbench .part.titlebar,
        .titlebar,
        .browser-close-button,
        .browser-action-buttons,
        .monaco-action-bar {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            opacity: 0 !important;
        }

        .close-btn {
            position: absolute;
            top: 12px;
            right: 16px;
            background: rgba(40, 14, 60, 0.82);
            border: 1px solid rgba(210, 170, 255, 0.55);
            color: #f1d9ff;
            font-size: 24px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: 700;
            line-height: 1;
            cursor: pointer;
            opacity: 0.84;
            transition: opacity 0.2s, transform 0.2s, box-shadow 0.2s;
            padding: 6px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 18px rgba(210, 170, 255, 0.35);
            z-index: 5;
        }

        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Hide only the specific problematic close buttons */
        #closeScores {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* More aggressive hiding of browser UI */
        body {
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden;
        }

        /* Hide any top-level browser chrome */
        :root {
            --browser-chrome-height: 0px;
        }

        #wrap {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            min-height: 100svh;
            padding: 0;
        }

        .stage {
            width: 100vw;
            height: 100svh;
            position: relative;
            display: grid;
            place-items: center;
            background: #000;
            border-radius: 0;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(255, 0, 255, .4);
            container-type: inline-size;
            z-index: 2;
        }

        canvas {
            background: transparent;
            border-radius: 16px;
            touch-action: none;
            cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;
        }

        #ui {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .panel {
            pointer-events: auto;
        }

        #topBar {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: start;
            padding: 4px;
            pointer-events: none;
            z-index: 5
        }

        #hud {
            display: flex;
            gap: 8px;
            pointer-events: none;
            font-size: var(--hud-text);
            justify-content: center;
            align-items: flex-start;
            width: auto;
            max-width: none;
            transform: translateY(2px);
            grid-column: 2
        }

        .hud-card {
            pointer-events: none;
            border: 1px solid var(--edge);
            background: linear-gradient(180deg, rgba(150, 80, 255, .12), rgba(150, 80, 255, .06));
            backdrop-filter: blur(8px);
            padding: 6px 10px;
            border-radius: 8px;
            width: auto;
            min-width: 220px
        }

        .hud-title {
            opacity: .85;
            font-weight: 600;
            margin-bottom: 4px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-align: center;
            font-size: 10px;
            color: #c49cff
        }

        #hudPowerup {
            grid-column: 1;
            justify-self: start;
            margin-left: 8px;
            min-width: 150px
        }

        #hudEquipment {
            grid-column: 3;
            justify-self: end;
            margin-right: 8px;
            min-width: 150px;
            text-align: right;
        }

        .bar {
            height: 4px;
            width: 100%;
            background: rgba(150, 80, 255, .12);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid var(--edge);
            margin-top: 2px
        }

        .bar>span {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent2))
        }

        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }

        #diagBox {
            position: absolute;
            left: 8px;
            top: 8px;
            display: grid;
            gap: 4px;
            pointer-events: none
        }

        .chip {
            pointer-events: auto;
            background: rgba(0, 0, 0, .7);
            border: 1px solid var(--edge);
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 10px;
            letter-spacing: .3px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-align: left;
            color: #c49cff
        }

        .btn {
            background: #330044;
            color: #ffddff;
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            font-size: var(--btn-text);
            cursor: pointer;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            transition: all .2s;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .btn:hover {
            background: #4c0e72;
            box-shadow: 0 0 15px rgba(178, 102, 255, .5)
        }

        .btn.secondary {
            background: transparent;
            border-color: #ff9cff;
            color: #ffd6ff;
            box-shadow: none;
        }

        .btn.secondary:hover {
            background: rgba(255, 156, 255, 0.12);
            box-shadow: 0 0 15px rgba(255, 156, 255, 0.4)
        }

        .panel {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 0, 34, .95);
            border: 1px solid var(--accent);
            border-radius: 16px;
            padding: 20px 18px 18px;
            width: min(560px, 88vw);
            max-height: min(84vh, 720px);
            overflow-y: auto;
            overscroll-behavior: contain;
            backdrop-filter: blur(12px);
            color: #ffddff;
            box-shadow: 0 0 40px rgba(178, 102, 255, .3);
            z-index: 100;
        }

        .panel::-webkit-scrollbar {
            width: 8px
        }

        .panel::-webkit-scrollbar-thumb {
            background: rgba(178, 102, 255, 0.35);
            border-radius: 999px
        }

        .panel.panel-floating-close {
            padding-top: 58px
        }

        .panel-back-btn {
            position: absolute;
            top: 14px;
            left: 16px;
            padding: 8px 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 215, 128, 0.55);
            background: linear-gradient(135deg, rgba(255, 215, 128, 0.18), rgba(255, 160, 64, 0.16));
            color: #ffe6b3;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 11px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 6;
        }

        .panel-back-btn:hover {
            border-color: rgba(255, 215, 128, 0.9);
            background: linear-gradient(135deg, rgba(255, 215, 128, 0.32), rgba(255, 170, 80, 0.26));
            box-shadow: 0 0 14px rgba(255, 200, 110, 0.28);
        }

        .panel-back-btn.hide {
            display: none;
        }


        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }

        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }

        #shopPanel h2,
        #levelPanel h2,
        #scorePanel h2,
        #namePanel h2,
        #pilotPanel h2,
        #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }

        #shopPanel p,
        #levelPanel p,
        #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }

        #shopGrid,
        #scorePanel div {
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 8px;
        }

        #shopGrid {
            display: block;
        }

        .character-sheet-body {
            font-family: 'Orbitron', 'Audiowide', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.55;
            color: #f6ecff;
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 6px;
        }

        .character-sheet-body::-webkit-scrollbar {
            width: 6px;
        }

        .character-sheet-body::-webkit-scrollbar-thumb {
            background: rgba(189, 128, 255, 0.45);
            border-radius: 10px;
        }

        .intel-section {
            margin-bottom: 16px;
        }

        .intel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #f7d7ff;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        .intel-summary {
            display: flex;
            flex-direction: column;
            gap: 4px;
            background: rgba(124, 62, 160, 0.22);
            border-left: 2px solid rgba(228, 189, 255, 0.55);
            padding: 8px 12px;
            border-radius: 6px;
        }

        .intel-summary-line {
            font-size: 11px;
            letter-spacing: 0.05em;
            color: #f3e3ff;
        }

        .intel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .intel-cell {
            background: rgba(82, 34, 120, 0.32);
            border: 1px solid rgba(201, 146, 255, 0.35);
            border-radius: 10px;
            padding: 8px 10px 9px;
            box-shadow: inset 0 0 12px rgba(150, 70, 200, 0.25);
        }

        .intel-key {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: #dfc2ff;
            opacity: 0.82;
        }

        .intel-val {
            font-size: 14px;
            font-weight: 700;
            color: #f6ecff;
        }

        .intel-detail {
            font-size: 10px;
            color: #d5b9ff;
            opacity: 0.85;
            margin-top: 4px;
        }

        .intel-list {
            margin: 0;
            padding-left: 18px;
            font-size: 11px;
            color: #f3e3ff;
        }

        .intel-list li {
            margin-bottom: 4px;
        }

        .intel-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: rgba(66, 24, 110, 0.48);
            border: 1px solid rgba(205, 150, 255, 0.4);
            border-radius: 10px;
            overflow: hidden;
        }

        .intel-table thead {
            background: rgba(118, 58, 168, 0.55);
        }

        .intel-table th,
        .intel-table td {
            padding: 6px 8px;
            color: #f2e6ff;
            border-bottom: 1px solid rgba(205, 150, 255, 0.22);
            text-align: left;
        }

        .intel-table tr:last-child td {
            border-bottom: none;
        }

        .intel-table tr.active {
            background: rgba(151, 83, 214, 0.35);
        }

        .intel-table tr.inactive {
            opacity: 0.55;
        }

        .intel-subtitle {
            margin-top: 10px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #f0d9ff;
        }

        .intel-note {
            font-size: 10px;
            color: #d4baff;
            opacity: 0.75;
            margin-top: 6px;
        }

        .forge-toolbar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            margin-bottom: 12px;
        }

        .forge-toolbar .mobile-toggle-container {
            flex: 1 1 auto;
        }

        .forge-toolbar-btn {
            background: linear-gradient(135deg, rgba(138, 70, 214, 0.85), rgba(84, 36, 140, 0.9));
            border: 1px solid rgba(214, 170, 255, 0.7);
            border-radius: 20px;
            padding: 6px 14px;
            font-size: 11px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #f8eaff;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .forge-toolbar-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 14px rgba(210, 160, 255, 0.6);
        }

        .forge-toolbar-btn[aria-pressed="true"] {
            background: linear-gradient(135deg, rgba(167, 90, 240, 0.95), rgba(110, 48, 180, 0.95));
            box-shadow: 0 0 18px rgba(214, 170, 255, 0.7);
        }

        .grid {
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .shop-section {
            margin-bottom: 18px;
            padding-bottom: 14px;
            border-bottom: 1px solid rgba(178, 102, 255, 0.24);
        }

        .shop-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .shop-section-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
        }

        .shop-section-title {
            margin: 0;
            font-size: clamp(14px, 1.8vw, 18px);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #f6e4ff;
        }

        .shop-section-subtitle {
            margin: 0;
            font-size: clamp(10px, 1.4vw, 12px);
            letter-spacing: 0.06em;
            color: rgba(214, 190, 255, 0.78);
            flex: 1 1 auto;
            text-align: right;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .shop-section-grid {
            margin-top: 10px;
            display: grid;
            gap: 8px;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }

        .shop-control-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: stretch;
            margin: 16px 0;
        }

        .shop-control-block {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 14px;
            border: 1px solid rgba(178, 102, 255, 0.35);
            background: rgba(20, 4, 40, 0.65);
            flex: 1 1 260px;
            min-width: 220px;
            box-shadow: inset 0 0 12px rgba(178, 102, 255, 0.18);
        }

        .shop-control-copy {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1 1 auto;
        }

        .shop-control-title {
            margin: 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.09em;
            color: var(--accent);
        }

        .shop-control-desc {
            margin: 0;
            font-size: 10px;
            line-height: 1.4;
            color: rgba(214, 190, 255, 0.82);
        }

        .shop-control-status {
            font-size: 10px;
            color: #9fead8;
            line-height: 1.4;
        }

        .shop-advanced-btn {
            background: linear-gradient(140deg, rgba(140, 80, 255, 0.9), rgba(70, 20, 140, 0.92));
            border: 1px solid rgba(210, 160, 255, 0.8);
            border-radius: 14px;
            padding: 10px 18px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #ffffff;
            flex: 0 0 auto;
            align-self: center;
        }

        .shop-advanced-btn:hover {
            background: linear-gradient(140deg, rgba(160, 100, 255, 0.95), rgba(80, 30, 160, 0.95));
            border-color: rgba(230, 200, 255, 0.9);
            box-shadow: 0 0 18px rgba(178, 102, 255, 0.5);
        }

        .shop-view-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .shop-lab-button-row {
            display: flex;
            justify-content: center;
            width: 100%;
            margin: 14px 0 18px;
        }

        #openChampionDressingRoom {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            height: 30.8px;
            padding: 0 32px;
            border-radius: 999px;
            border: 1px solid rgba(120, 255, 210, 0.75);
            background: linear-gradient(160deg, rgba(42, 210, 140, 0.92), rgba(18, 130, 92, 0.94));
            box-shadow: inset 0 2px 6px rgba(255, 255, 255, 0.25), inset 0 -3px 10px rgba(6, 70, 48, 0.7), 0 0 18px rgba(50, 255, 190, 0.35);
            color: #e8fff4;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 11px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
            overflow: hidden;
        }

        #openChampionDressingRoom.hide {
            display: none;
        }

        #openChampionDressingRoom::after {
            content: '';
            position: absolute;
            top: -90%;
            left: -40%;
            width: 50%;
            height: 280%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.4) 45%, rgba(255, 255, 255, 0) 100%);
            transform: rotate(20deg);
            transition: transform 0.4s ease;
        }

        #openChampionDressingRoom:hover {
            transform: translateY(-1px) scale(1.01);
            background: linear-gradient(160deg, rgba(54, 230, 158, 0.98), rgba(24, 150, 110, 0.98));
            box-shadow: inset 0 1px 6px rgba(255, 255, 255, 0.28), inset 0 -3px 10px rgba(8, 60, 38, 0.65), 0 0 24px rgba(90, 255, 210, 0.55);
        }

        #openChampionDressingRoom:hover::after {
            transform: translateX(220%) rotate(20deg);
        }

        #openChampionDressingRoom:focus-visible {
            outline: 2px solid rgba(180, 255, 230, 0.85);
            outline-offset: 2px;
        }

        #openChampionDressingRoom .lab-icon {
            font-size: 16px;
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.45));
        }

        #openChampionDressingRoom .lab-label {
            font-weight: 600;
            letter-spacing: 0.2em;
        }

        #openChampionDressingRoom .lab-dna {
            font-size: 13px;
        }

        .shop-view-btn {
            flex: 1 1 180px;
            padding: 8px 16px;
            border-radius: 999px;
            border: 1px solid rgba(178, 102, 255, 0.35);
            background: rgba(24, 4, 44, 0.6);
            color: #eadeff;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shop-view-btn:hover {
            background: rgba(178, 102, 255, 0.18);
            box-shadow: 0 0 12px rgba(178, 102, 255, 0.28);
        }

        .shop-view-btn.active {
            background: linear-gradient(135deg, rgba(140, 70, 255, 0.92), rgba(70, 20, 150, 0.9));
            border-color: rgba(210, 160, 255, 0.85);
            color: #ffffff;
            box-shadow: 0 0 16px rgba(178, 102, 255, 0.4);
        }

        .shop-view {
            display: block;
        }

        .shop-power-section {
            margin-bottom: 18px;
            padding: 14px 16px 16px;
            border-radius: 14px;
            border: 1px solid rgba(178, 102, 255, 0.25);
            background: linear-gradient(160deg, rgba(18, 0, 32, 0.7), rgba(30, 10, 50, 0.6));
            box-shadow: inset 0 0 12px rgba(178, 102, 255, 0.15);
        }

        .shop-power-section:last-of-type {
            margin-bottom: 0;
        }

        .shop-power-section h4 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--accent);
        }

        .shop-power-section p {
            margin: 0 0 10px 0;
            font-size: 10px;
            color: rgba(214, 190, 255, 0.78);
            line-height: 1.5;
        }

        .shop-powerup-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .shop-power-card {
            background: rgba(40, 10, 68, 0.65);
            border: 1px solid rgba(178, 102, 255, 0.3);
            border-radius: 12px;
            padding: 12px 14px;
            color: #f6edff;
            box-shadow: inset 0 0 10px rgba(178, 102, 255, 0.18);
        }

        .shop-power-card-title {
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin: 0 0 6px 0;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .shop-power-card-title svg.powerup-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            filter: drop-shadow(0 0 4px rgba(255, 95, 180, 0.65));
        }

        .shop-power-card-title .powerup-icon--fallback {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1;
            flex-shrink: 0;
        }

        .shop-power-card-title .shop-power-card-name {
            display: inline-flex;
            align-items: center;
        }

        .shop-power-card-meta {
            font-size: 10px;
            color: rgba(214, 190, 255, 0.86);
            margin-bottom: 6px;
        }

        .shop-power-bar {
            height: 6px;
            border-radius: 999px;
            overflow: hidden;
            background: rgba(178, 102, 255, 0.25);
        }

        .shop-power-bar span {
            display: block;
            height: 100%;
            background: linear-gradient(90deg, #ffd45a, #ff8bff);
        }

        .shop-powerup-list {
            margin: 6px 0 0 0;
            padding-left: 18px;
            list-style: square;
            font-size: 11px;
            line-height: 1.6;
            color: #e8dcff;
        }

        .shop-powerup-list strong {
            color: var(--accent);
        }

        .shop-empty-subtle {
            text-align: center;
            padding: 12px;
            border: 1px dashed rgba(178, 102, 255, 0.3);
            border-radius: 12px;
            font-size: 11px;
            color: rgba(230, 210, 255, 0.78);
        }

        .shop-item-cost {
            color: #ffd95a;
            margin-top: 6px;
            font-size: 12px;
            letter-spacing: 0.08em;
            font-weight: 700;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 205, 90, 0.6), 0 0 18px rgba(255, 140, 40, 0.35);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .shop-item-cost::before {
            content: "âœ¦";
            font-size: 13px;
            color: #ffe8a3;
            text-shadow: inherit;
        }

        .shop-empty {
            text-align: center;
            padding: 16px;
            border: 1px dashed rgba(214, 190, 255, 0.35);
            border-radius: 12px;
            font-size: 12px;
            letter-spacing: 0.08em;
            color: rgba(230, 210, 255, 0.75);
        }

        /* Character Sheet Panel */
        #characterSheetPanel {
            width: min(900px, 95vw);
            max-height: 85vh;
            overflow-y: auto;
        }

        /* Upgrade Hangar Menu Panel */
        #mechForgeMenuPanel {
            width: min(660px, 92vw);
            padding: 28px 32px 30px;
            background: radial-gradient(circle at top, rgba(40, 12, 68, 0.92) 0%, rgba(22, 4, 40, 0.95) 55%, rgba(16, 0, 28, 0.96) 100%);
        }

        .forge-menu-header {
            text-align: center;
            margin-bottom: 28px;
        }

        .forge-menu-title-large {
            margin: 0;
            font-size: 26px;
            letter-spacing: 0.2em;
            color: var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-transform: uppercase;
        }

        .forge-menu-subtitle {
            margin: 12px auto 0;
            max-width: 500px;
            font-size: 12px;
            line-height: 1.6;
            color: #d7caff;
        }

        .forge-menu-highlight {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 9px 18px;
            margin-top: 15px;
            border-radius: 999px;
            border: 1px solid rgba(160, 120, 255, 0.5);
            background: rgba(100, 60, 200, 0.22);
            font-size: 11px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: #f6edff;
        }

        .forge-menu-section {
            margin-bottom: 24px;
            background: rgba(18, 0, 26, 0.75);
            border: 1px solid rgba(160, 110, 255, 0.28);
            border-radius: 14px;
            padding: 18px 20px 20px;
            box-shadow: 0 0 22px rgba(122, 68, 210, 0.22);
        }

        .forge-menu-section:last-of-type {
            margin-bottom: 0;
        }

        .forge-menu-section-head {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 16px;
        }

        .forge-menu-title {
            font-size: 15px;
            color: var(--accent);
            margin: 0 0 4px;
            text-align: left;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }

        .forge-menu-section-hint {
            font-size: 11px;
            color: #cbb8ff;
            line-height: 1.5;
        }

        .forge-menu-grid {
            display: grid;
            gap: 14px;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .forge-profile-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        }

        .forge-profile-card {
            position: relative;
            border: 1px solid rgba(160, 110, 255, 0.28);
            background: linear-gradient(145deg, rgba(16, 0, 32, 0.85), rgba(30, 0, 48, 0.65));
            border-radius: 12px;
            padding: 12px 14px 14px;
            color: #f0eaff;
            text-align: left;
            font-size: 12px;
            line-height: 1.5;
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }

        .forge-profile-card:hover {
            transform: translateY(-2px);
            border-color: rgba(190, 150, 255, 0.5);
            box-shadow: 0 10px 24px rgba(90, 40, 150, 0.25);
        }

        .forge-profile-card.active {
            border-color: var(--accent);
            box-shadow: 0 12px 28px rgba(120, 70, 220, 0.38);
            background: linear-gradient(150deg, rgba(34, 4, 70, 0.95), rgba(18, 0, 40, 0.9));
        }

        .forge-profile-card-title {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 13px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            margin-bottom: 6px;
            color: var(--accent);
        }

        .forge-profile-card-summary {
            font-size: 12px;
            color: #d7caff;
        }

        .forge-profile-card.active .forge-profile-card-summary {
            color: #ffffff;
        }

        .forge-profile-summary {
            margin-top: 16px;
            font-size: 12px;
            line-height: 1.6;
            color: #d7caff;
            min-height: 40px;
        }

        .forge-menu-btn {
            background: linear-gradient(135deg, rgba(150, 80, 255, 0.3), rgba(120, 60, 200, 0.4));
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 18px 22px;
            color: #ffddff;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 10px;
            min-height: 110px;
        }

        .forge-menu-btn-title {
            font-size: 15px;
            letter-spacing: 0.08em;
        }

        #openPrimordialLabFromMenu {
            background: linear-gradient(135deg, rgba(120, 70, 255, 0.95), rgba(40, 160, 255, 0.88));
            border-color: rgba(200, 170, 255, 0.85);
            color: #f7f3ff;
            padding: 22px 24px;
            font-size: 15px;
            box-shadow: 0 0 22px rgba(150, 120, 255, 0.38);
        }

        #openPrimordialLabFromMenu .forge-menu-desc {
            color: rgba(246, 240, 255, 0.82);
            opacity: 0.95;
        }

        #openPrimordialLabFromMenu:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(140, 92, 255, 0.98), rgba(70, 190, 255, 0.92));
            box-shadow: 0 0 28px rgba(168, 132, 255, 0.55);
        }

        #openCharacterSheet {
            background: linear-gradient(135deg, rgba(140, 90, 255, 0.45), rgba(100, 40, 200, 0.6));
            border-color: #b88bff;
            color: #f2e8ff;
        }

        #openCharacterSheet .forge-menu-desc {
            color: rgba(236, 222, 255, 0.8);
        }

        #openCharacterSheet:hover {
            background: linear-gradient(135deg, rgba(170, 120, 255, 0.65), rgba(120, 60, 220, 0.75));
            box-shadow: 0 0 24px rgba(184, 139, 255, 0.45);
        }

        #openShopTutorial {
            background: linear-gradient(135deg, rgba(60, 200, 125, 0.45), rgba(20, 150, 95, 0.6));
            border-color: #4fd688;
            color: #e8fff4;
        }

        #openShopTutorial .forge-menu-desc {
            color: rgba(224, 255, 242, 0.85);
        }

        #openShopTutorial:hover {
            background: linear-gradient(135deg, rgba(90, 230, 150, 0.65), rgba(30, 170, 110, 0.75));
            box-shadow: 0 0 22px rgba(94, 232, 170, 0.45);
        }

        .forge-menu-btn:hover {
            background: linear-gradient(135deg, rgba(180, 100, 255, 0.5), rgba(150, 80, 230, 0.6));
            box-shadow: 0 0 20px rgba(178, 102, 255, 0.5);
            transform: translateY(-2px);
        }

        .forge-menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .forge-menu-desc {
            font-size: 11px;
            color: #ccaaff;
            line-height: 1.6;
            text-align: left;
            opacity: 0.88;
        }

        .forge-menu-meta {
            margin-top: 6px;
            font-size: 11px;
            line-height: 1.5;
            color: #dee4ff;
            text-align: left;
        }

        .forge-menu-meta strong {
            color: #a9baff;
            font-weight: 600;
        }

        .forge-menu-meta.locked {
            color: #ffadc9;
        }

        .forge-menu-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 18px;
            background: rgba(45, 20, 70, 0.62);
            border: 1px solid rgba(160, 120, 255, 0.3);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 12px;
            color: #e9dcff;
        }

        .forge-menu-toggle:last-child {
            margin-bottom: 0;
        }

        .forge-menu-toggle-copy {
            flex: 1;
            text-align: left;
        }

        .forge-menu-toggle-title {
            font-size: 12px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #f4e8ff;
        }

        .forge-menu-toggle-desc {
            margin-top: 4px;
            font-size: 11px;
            color: #cbb8ff;
            line-height: 1.5;
        }

        .forge-menu-footnote {
            margin: 22px 0 0;
            font-size: 11px;
            color: #bfa8ff;
            text-align: center;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        @media (max-width: 540px) {
            #mechForgeMenuPanel {
                padding: 24px 18px;
            }

            .forge-menu-title-large {
                font-size: 22px;
                letter-spacing: 0.14em;
            }

            .forge-menu-section-head {
                flex-direction: column;
                gap: 8px;
            }

            .forge-menu-toggle {
                flex-direction: column;
                align-items: flex-start;
            }

            .forge-menu-toggle .switch {
                align-self: flex-end;
            }
        }

        .hide {
            display: none !important
        }

        #belowBoard {
            width: min(98vw, var(--maxw));
            margin: 50px auto 0;
            padding: 8px;
            display: grid;
            gap: 8px
        }

        #hsCard {
            border: 1px solid var(--edge);
            background: linear-gradient(180deg, rgba(150, 80, 255, .12), rgba(150, 80, 255, .06));
            backdrop-filter: blur(8px);
            padding: 8px;
            border-radius: 8px
        }

        #hsCard h3 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            text-align: center;
            font-size: 14px;
            color: #c49cff
        }

        #hsList {
            list-style: decimal;
            margin: 0;
            padding: 0 0 0 1rem;
            line-height: 1.4;
            font-size: 12px;
            color: #ffddff
        }

        .skill-card {
            background: radial-gradient(circle, rgba(51, 0, 68, 1) 0%, rgba(51, 0, 68, 0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }

        .skill-card:hover {
            background: rgba(85, 0, 120, .9);
            box-shadow: 0 0 20px rgba(178, 102, 255, .6);
            transform: scale(1.05)
        }

        .skill-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important
        }

        .skill-card.unlocked {
            background: radial-gradient(circle, rgba(30, 30, 40, 0.6) 0%, rgba(25, 25, 35, 0.5) 70%);
            border: 1px solid rgba(120, 120, 140, 0.3);
            opacity: 0.65;
            cursor: default;
        }

        .skill-card.unlocked:hover {
            background: radial-gradient(circle, rgba(30, 30, 40, 0.6) 0%, rgba(25, 25, 35, 0.5) 70%);
            box-shadow: none;
            transform: none;
        }

        .unlocked-label {
            display: inline-block;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.12em;
            color: rgba(140, 140, 160, 0.75);
            text-shadow: 0 0 8px rgba(100, 100, 120, 0.4);
            text-transform: uppercase;
        }

        /* Primordial Soldier Laboratory Styles */
        #championDressingRoom {
            width: min(85vw, 650px);
            max-height: 85vh;
            overflow-y: auto;
        }

        .dressing-room-header {
            text-align: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(178, 102, 255, .3);
            padding-bottom: 12px;
        }

        .dressing-room-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 18px;
            margin-bottom: 15px;
        }

        @media (max-width: 600px) {
            .dressing-room-content {
                grid-template-columns: 1fr;
                gap: 16px;
            }
        }

        .champion-preview-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .preview-viewport {
            position: relative;
            width: 160px;
            height: 160px;
            border: 2px solid var(--accent);
            border-radius: 10px;
            background: radial-gradient(circle, rgba(20, 0, 40, 0.9) 0%, rgba(5, 0, 15, 0.95) 100%);
            overflow: hidden;
            margin-bottom: 8px;
            box-shadow: inset 0 0 15px rgba(178, 102, 255, .2);
        }

        #championPreviewCanvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .preview-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 8px;
            text-align: center;
        }

        .champion-name {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 8px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }



        .champion-stats-section {
            background: rgba(18, 0, 26, 0.6);
            border: 1px solid rgba(178, 102, 255, .2);
            border-radius: 10px;
            padding: 12px;
        }

        .stats-header h3 {
            margin: 0 0 10px 0;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            color: var(--accent);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 6px;
            background: rgba(30, 0, 50, 0.4);
            border: 1px solid rgba(178, 102, 255, .15);
            border-radius: 5px;
        }

        .stat-label {
            font-size: 10px;
            color: #c0b4ff;
            font-family: 'Orbitron', ui-sans-serif;
        }

        .stat-value {
            font-size: 10px;
            color: #ffddff;
            font-weight: bold;
        }

        .attack-types-section,
        .upgrade-preview-section {
            margin-bottom: 12px;
        }

        .attack-types-section h4,
        .upgrade-preview-section h4 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', ui-sans-serif;
            color: var(--accent2);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .attack-types-list,
        .upgrades-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .attack-type-item,
        .upgrade-item {
            background: rgba(40, 0, 60, 0.3);
            border: 1px solid rgba(178, 102, 255, .1);
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 9px;
            color: #e0d4ff;
        }

        .attack-type-item .attack-name,
        .upgrade-item .upgrade-name {
            font-weight: bold;
            color: var(--accent2);
        }

        .ability-icon {
            font-size: 12px;
            margin-right: 6px;
            opacity: 0.85;
        }

        .loadout-section {
            margin-bottom: 12px;
        }

        .loadout-section h4 {
            margin: 0 0 6px 0;
            font-family: 'Orbitron', ui-sans-serif;
            color: var(--accent2);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .loadout-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .loadout-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(26, 0, 45, 0.4);
            border: 1px solid rgba(178, 102, 255, .12);
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 9px;
            color: #e0d4ff;
        }

        .loadout-label {
            color: #c0b4ff;
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .loadout-value {
            font-weight: 600;
            color: #ffddff;
        }

        .champion-class {
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 7px;
            color: rgba(255, 230, 255, 0.9);
            letter-spacing: 0.08em;
            margin-top: 2px;
        }

        .dressing-room-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid rgba(178, 102, 255, .2);
            padding-top: 12px;
        }

        .btn-primary {
            background: linear-gradient(145deg, var(--accent), var(--accent2));
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: linear-gradient(145deg, var(--accent2), var(--accent));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(178, 102, 255, .3);
        }

        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }

        /* Font Awesome icon styling */
        .skill-icon i,
        .shop-item-cost i,
        .skill-card i {
            display: inline-block;
            font-style: normal;
        }

        /* Enhanced Attack Module Selection Styles */
        .builder-select {
            background: rgba(20, 0, 40, 0.8);
            border: 1px solid rgba(178, 102, 255, .3);
            color: #e0d4ff;
            border-radius: 5px;
            padding: 6px 8px;
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 10px;
            width: 100%;
        }

        .builder-select optgroup {
            background: rgba(30, 0, 50, 0.95);
            color: var(--accent);
            font-weight: bold;
            font-size: 9px;
            letter-spacing: 0.05em;
        }

        .builder-select option {
            background: rgba(20, 0, 40, 0.9);
            color: #e0d4ff;
            padding: 4px;
            font-size: 9px;
        }

        .builder-select option:hover {
            background: rgba(178, 102, 255, 0.2);
        }

        /* Attack Module Info Display */
        .module-info-display {
            margin-top: 8px;
            padding: 8px;
            background: rgba(26, 0, 45, 0.4);
            border: 1px solid rgba(178, 102, 255, .15);
            border-radius: 5px;
            font-size: 9px;
            line-height: 1.3;
        }

        .module-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-right: 8px;
        }

        .module-type-kinetic {
            background: rgba(150, 150, 150, 0.3);
            color: #ddd;
        }

        .module-type-fire {
            background: rgba(255, 100, 50, 0.3);
            color: #ffaa88;
        }

        .module-type-laser {
            background: rgba(255, 50, 100, 0.3);
            color: #ff88aa;
        }

        .module-type-lightning {
            background: rgba(100, 150, 255, 0.3);
            color: #88aaff;
        }

        .trade-off-indicator {
            font-style: italic;
            color: #c0b4ff;
            margin-top: 4px;
        }

        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }

        .skill-title {
            font-weight: 700;
            color: #c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }

        .skill-desc {
            font-size: 11px;
            color: #ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }

        .skill-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .skill-row {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .skill-card-node-pair {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .skill-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            width: 100%;
        }

        #subclassPanel.skill-tree-active {
            width: min(900px, 95vw);
            max-height: 80vh;
            overflow-y: auto;
            padding: 20px 24px 28px;
        }

        #skillTree {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .skill-tree-title {
            font-size: 28px;
            color: #ffffff;
            text-transform: uppercase;
            letter-spacing: 0.24em;
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.8);
            text-align: center;
            margin: 0 auto 14px;
            max-width: 680px;
        }

        .skill-view-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 14px;
        }

        /* Champion Builder Styles */
        .champion-builder-section {
            flex: 1;
            min-width: 250px;
            padding: 15px;
            background: linear-gradient(145deg, rgba(30, 10, 50, 0.9), rgba(50, 20, 80, 0.8));
            border: 1px solid rgba(178, 102, 255, 0.3);
            border-radius: 10px;
            margin: 0 15px;
        }

        .builder-header h3 {
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 14px;
            color: var(--accent);
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .builder-guidance {
            font-size: 9px;
            color: #c8b6ff;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .builder-guidance p {
            margin: 0 0 4px 0;
        }

        .builder-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .builder-option {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .builder-option label {
            font-size: 11px;
            color: #ffddff;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .builder-option-desc {
            font-size: 9px;
            color: #b8a8ff;
            line-height: 1.3;
            margin: -2px 0 2px 0;
        }

        .builder-option-detail {
            margin-top: 4px;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(178, 102, 255, 0.32);
            background: linear-gradient(135deg, rgba(30, 10, 60, 0.85), rgba(18, 6, 36, 0.8));
            box-shadow: inset 0 0 10px rgba(178, 102, 255, 0.14);
            color: #efe4ff;
            font-size: 9.5px;
            line-height: 1.45;
        }

        .builder-option-detail p {
            margin: 0;
        }

        .builder-detail-title {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 10px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #ffd9ff;
            margin: 0 0 4px 0;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .builder-detail-title span {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .builder-detail-meta {
            list-style: none;
            margin: 6px 0 0 0;
            padding: 0;
            color: #d9cfff;
            font-size: 9px;
        }

        .builder-detail-meta li {
            margin-bottom: 3px;
        }

        .builder-detail-meta li strong {
            color: #f9ecff;
        }

        .builder-select {
            padding: 6px 10px;
            background: rgba(20, 10, 40, 0.8);
            border: 1px solid rgba(178, 102, 255, 0.4);
            border-radius: 5px;
            color: #ffffff;
            font-size: 12px;
            cursor: pointer;
        }

        .builder-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(178, 102, 255, 0.3);
        }

        .builder-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: center;
        }

        .builder-action-btn {
            padding: 6px 14px;
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border-radius: 9px;
            background: rgba(51, 0, 68, 0.85);
            border: 1px solid rgba(178, 102, 255, 0.55);
            color: #f9e9ff;
            box-shadow: none;
        }

        .builder-action-btn:hover {
            background: linear-gradient(135deg, rgba(140, 60, 255, 0.9), rgba(60, 20, 120, 0.95));
            box-shadow: 0 0 16px rgba(178, 102, 255, 0.45);
        }

        .builder-action-apply {
            background: linear-gradient(135deg, rgba(160, 70, 255, 0.92), rgba(70, 20, 160, 0.9));
            border-color: rgba(210, 150, 255, 0.8);
        }

        .builder-action-apply:hover {
            border-color: rgba(235, 190, 255, 0.95);
            box-shadow: 0 0 18px rgba(210, 150, 255, 0.55);
        }

        .builder-action-reset {
            background: rgba(20, 10, 40, 0.6);
            border-color: rgba(178, 102, 255, 0.35);
            color: #d8ccff;
        }

        .builder-action-reset:hover {
            background: rgba(178, 102, 255, 0.14);
            box-shadow: 0 0 14px rgba(178, 102, 255, 0.35);
        }

        .champion-preset-section {
            margin-top: 18px;
            padding: 14px;
            border-radius: 12px;
            border: 1px solid rgba(178, 102, 255, 0.35);
            background: linear-gradient(145deg, rgba(20, 10, 40, 0.7), rgba(12, 6, 28, 0.85));
            box-shadow: inset 0 0 18px rgba(25, 10, 45, 0.45);
        }

        .champion-preset-section h3 {
            margin: 0 0 6px 0;
            font-size: 15px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .champion-preset-section p {
            margin: 0 0 10px 0;
            color: #dcd0ff;
            font-size: 11px;
        }

        .preset-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .preset-code-output {
            width: 100%;
            resize: none;
            border-radius: 10px;
            border: 1px solid rgba(178, 102, 255, 0.5);
            background: rgba(12, 6, 24, 0.9);
            color: #f0e5ff;
            font-family: 'Consolas', 'Fira Code', monospace;
            font-size: 13px;
            letter-spacing: 0.05em;
            padding: 10px 12px;
        }

        .preset-code-output:focus {
            outline: none;
            border-color: rgba(210, 150, 255, 0.85);
            box-shadow: 0 0 12px rgba(178, 102, 255, 0.35);
        }

        .preset-import {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .preset-code-input {
            flex: 1;
            min-width: 200px;
            border-radius: 10px;
            border: 1px solid rgba(178, 102, 255, 0.45);
            background: rgba(15, 8, 30, 0.92);
            color: #f5e8ff;
            font-family: 'Consolas', 'Fira Code', monospace;
            font-size: 13px;
            letter-spacing: 0.04em;
            padding: 8px 12px;
        }

        .preset-code-input:focus {
            outline: none;
            border-color: rgba(210, 150, 255, 0.85);
            box-shadow: 0 0 12px rgba(178, 102, 255, 0.35);
        }

        .preset-status {
            margin-top: 8px;
            font-size: 11px;
            min-height: 1.2em;
            color: #d8ccff;
        }

        .preset-status.success {
            color: #7df0b8;
        }

        .preset-status.error {
            color: #ff8fb3;
        }

        /* Champion Upgrade Section Styles */
        .champion-upgrade-section {
            flex: 1;
            min-width: 250px;
            padding: 15px;
            background: linear-gradient(145deg, rgba(40, 20, 60, 0.9), rgba(60, 30, 90, 0.8));
            border: 1px solid rgba(178, 102, 255, 0.3);
            border-radius: 10px;
            margin: 0 15px;
        }

        .upgrade-header h3 {
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 14px;
            color: var(--accent);
            margin: 0 0 5px 0;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .upgrade-header p {
            color: #ffddff;
            margin: 0 0 15px 0;
            font-size: 12px;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }

        .upgrade-card {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: rgba(30, 10, 50, 0.8);
            border: 1px solid rgba(178, 102, 255, 0.4);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upgrade-card:hover:not(.disabled) {
            background: rgba(50, 20, 80, 0.9);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .upgrade-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .upgrade-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .upgrade-content {
            flex: 1;
            min-width: 0;
        }

        .upgrade-title {
            font-weight: 600;
            color: #ffddff;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .upgrade-desc {
            font-size: 11px;
            color: #cccccc;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .upgrade-cost {
            font-size: 12px;
            color: #ffd700;
            font-weight: 500;
        }

        /* SKILL TREE - Portrait-oriented Icon Button System */
        .skill-track {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 26px;
            width: 100%;
        }

        .track-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }

        .skill-icon-button {
            position: relative;
            width: min(520px, 100%);
            min-height: 190px;
            cursor: pointer;
            border-radius: 16px;
            padding: 16px;
            display: flex;
            gap: 18px;
            align-items: stretch;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            border: 2px solid rgba(110, 70, 180, 0.6);
            background: radial-gradient(circle at 18% 22%, rgba(66, 18, 110, 0.95), rgba(24, 2, 40, 0.9));
            box-shadow: inset 0 0 18px rgba(122, 60, 190, 0.22);
        }

        .skill-icon-frame {
            flex: 0 0 clamp(160px, 48%, 220px);
            aspect-ratio: 3 / 4;
            border-radius: 14px;
            border: 1px solid rgba(202, 138, 255, 0.45);
            background: radial-gradient(circle at 40% 30%, rgba(120, 70, 200, 0.35), rgba(40, 10, 70, 0.4));
            box-shadow: inset 0 0 24px rgba(150, 80, 255, 0.35);
            display: grid;
            place-items: center;
            overflow: hidden;
        }

        .skill-icon-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease, filter 0.3s ease;
            border-radius: 12px;
        }

        .skill-icon-image.enhanced {
            filter: brightness(1.25) saturate(1.15) drop-shadow(0 0 12px rgba(255, 215, 0, 0.8));
        }

        .skill-info-table {
            flex: 1 1 50%;
            display: grid;
            gap: 10px;
            background: rgba(82, 34, 120, 0.32);
            border: 1px solid rgba(201, 146, 255, 0.32);
            border-radius: 14px;
            padding: 14px 18px;
        }

        .skill-info-row {
            display: grid;
            grid-template-columns: minmax(86px, 30%) 1fr;
            gap: 12px;
            align-items: start;
        }

        .skill-info-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #e6ccff;
            opacity: 0.82;
        }

        .skill-info-value {
            font-size: 12px;
            color: #f5e8ff;
            line-height: 1.4;
        }

        .skill-info-note {
            font-size: 11px;
            color: #ffb3f7;
            opacity: 0.8;
            border-top: 1px solid rgba(201, 146, 255, 0.28);
            padding-top: 8px;
            margin-top: 6px;
        }

        .skill-track-connector {
            width: 3px;
            height: 38px;
            border-radius: 6px;
            background: linear-gradient(180deg, rgba(216, 176, 255, 0.7) 0%, rgba(125, 82, 200, 0.9) 100%);
            box-shadow: 0 0 12px rgba(180, 120, 255, 0.45);
        }

        .skill-view-toggle {
            display: inline-flex;
            align-items: stretch;
            justify-content: center;
            gap: 6px;
            padding: 6px;
            border-radius: 999px;
            background: radial-gradient(circle at 20% 20%, rgba(90, 30, 160, 0.6), rgba(30, 10, 50, 0.8));
            border: 1px solid rgba(210, 165, 255, 0.45);
            box-shadow: 0 0 20px rgba(160, 100, 240, 0.28);
            width: fit-content;
            min-width: 0;
        }

        .skill-view-toggle button {
            border: 1px solid rgba(190, 150, 255, 0.22);
            background: linear-gradient(135deg, rgba(80, 30, 140, 0.55), rgba(40, 18, 82, 0.65));
            color: #d8ceff;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            padding: 10px 18px 12px;
            border-radius: 999px;
            cursor: pointer;
            transition: all 0.28s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            text-shadow: 0 0 10px rgba(90, 40, 160, 0.5);
            min-width: 150px;
        }

        .skill-view-badge {
            font-size: 10px;
            letter-spacing: 0.24em;
            color: rgba(255, 237, 255, 0.85);
            background: rgba(255, 255, 255, 0.12);
            padding: 3px 12px;
            border-radius: 999px;
            box-shadow: inset 0 0 12px rgba(220, 200, 255, 0.15);
        }

        .skill-view-label {
            font-size: 11px;
            letter-spacing: 0.08em;
            color: #f5edff;
            text-align: center;
            line-height: 1.3;
        }

        .skill-view-toggle button.active {
            background: linear-gradient(135deg, rgba(230, 200, 255, 0.95), rgba(150, 90, 255, 0.88));
            color: #1b1031;
            border-color: rgba(255, 235, 255, 0.75);
            box-shadow: 0 0 26px rgba(210, 170, 255, 0.6);
            transform: translateY(-2px) scale(1.015);
            text-shadow: 0 0 12px rgba(255, 240, 255, 0.8);
        }

        .skill-view-toggle button.active .skill-view-badge {
            background: rgba(255, 255, 255, 0.9);
            color: #32164e;
            box-shadow: inset 0 0 18px rgba(255, 220, 255, 0.7);
        }

        .skill-view-toggle button:not(.active):hover {
            border-color: rgba(210, 170, 255, 0.55);
            box-shadow: 0 0 20px rgba(150, 110, 230, 0.45);
            color: #efe3ff;
        }

        .skill-view-toggle button:focus-visible {
            outline: 2px solid rgba(255, 215, 0, 0.7);
            outline-offset: 2px;
        }

        .skill-grid[data-active-view="main"] .view-signature {
            display: none;
        }

        .skill-grid[data-active-view="main"] .view-main {
            display: flex;
        }

        .skill-grid[data-active-view="signature"] .view-main {
            display: none;
        }

        .skill-grid[data-active-view="signature"] .view-signature {
            display: flex;
        }

        .skill-status-heading {
            font-size: 16px;
            font-weight: 700;
            color: #f8d87f;
            letter-spacing: 0.08em;
        }

        .skill-status-heading.readonly {
            color: #ff9c6b;
        }

        .skill-status-body {
            font-size: 13px;
            color: #d8c9ff;
            margin-top: 6px;
            line-height: 1.4;
        }

        .skill-status-line {
            font-size: 12px;
            color: #b8a6ff;
            margin-top: 6px;
        }

        .skill-status-line strong {
            color: #f5e8ff;
        }

        .skill-hover-title {
            font-size: 15px;
            font-weight: 600;
            color: #ffe39f;
            letter-spacing: 0.06em;
        }

        .skill-hover-body {
            font-size: 13px;
            color: #ded2ff;
            margin-top: 6px;
            line-height: 1.5;
        }

        .skill-hover-note {
            font-size: 11px;
            color: #94ffd1;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
        }

        /* SKILL ICON BUTTON STATES */
        .skill-icon-button.available {
            border-color: rgba(102, 255, 178, 0.7);
            box-shadow: 0 0 24px rgba(102, 255, 178, 0.35);
        }

        .skill-icon-button.available .skill-info-table {
            border-color: rgba(120, 255, 210, 0.55);
            box-shadow: inset 0 0 18px rgba(120, 255, 210, 0.18);
        }

        .skill-icon-button.available:hover {
            border-color: rgba(140, 255, 210, 0.85);
            box-shadow: 0 0 32px rgba(120, 255, 200, 0.5);
            transform: translateY(-4px);
        }

        .skill-icon-button.available:hover .skill-icon-image {
            filter: brightness(1.2) saturate(1.1);
            transform: scale(1.02);
        }

        .skill-icon-button.active {
            border-color: rgba(255, 215, 0, 0.95);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.16), rgba(140, 60, 200, 0.24));
            box-shadow: 0 0 26px rgba(255, 215, 0, 0.7), inset 0 0 22px rgba(255, 255, 255, 0.12);
            animation: activeIconGlow 3s ease-in-out infinite;
        }

        .skill-icon-button.active .skill-icon-frame {
            border-color: rgba(255, 215, 0, 0.85);
            box-shadow: inset 0 0 26px rgba(255, 215, 0, 0.35);
        }

        .skill-icon-button.active .skill-icon-image {
            filter: brightness(1.35) saturate(1.2) drop-shadow(0 0 16px rgba(255, 215, 0, 0.85));
        }

        .skill-icon-button.active .skill-info-table {
            border-color: rgba(255, 220, 120, 0.65);
            box-shadow: inset 0 0 24px rgba(255, 220, 120, 0.24);
        }

        .skill-icon-button.locked {
            border-color: rgba(70, 40, 120, 0.65);
            opacity: 0.65;
            cursor: not-allowed;
            filter: grayscale(0.4);
        }

        .skill-icon-button.locked .skill-info-table {
            background: rgba(38, 14, 68, 0.5);
            border-color: rgba(90, 50, 130, 0.35);
        }

        .skill-icon-button.locked:hover {
            transform: none;
            box-shadow: none;
        }

        /* CLASS ABILITY TRACK STYLING */
        .class-ability-track {
            position: relative;
            margin-left: 40px;
            padding: 20px;
            border-left: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 0 12px 12px 0;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(135, 206, 235, 0.05));
        }

        .class-ability-track .track-title {
            color: #FFD700;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        .class-ability-track .skill-icon-button+.skill-icon-button {
            margin-top: 18px;
        }

        .class-ability-solo {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6) !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.2)) !important;
        }

        .class-ability-solo.locked {
            border: 3px solid rgba(70, 40, 120, 0.65) !important;
            box-shadow: none !important;
            background: rgba(38, 14, 68, 0.3) !important;
            opacity: 0.65;
            filter: grayscale(0.4);
        }

        .class-ability-solo .skill-info-table {
            border-color: rgba(255, 223, 120, 0.8) !important;
            box-shadow: inset 0 0 26px rgba(255, 220, 130, 0.32) !important;
            background: rgba(80, 40, 0, 0.28);
        }

        .class-ability-solo.locked .skill-info-table {
            border-color: rgba(90, 50, 130, 0.35) !important;
            box-shadow: none !important;
            background: rgba(38, 14, 68, 0.5) !important;
        }

        .class-ability-solo:hover {
            border-color: #FFF700 !important;
            box-shadow: 0 0 36px rgba(255, 215, 0, 0.75) !important;
            transform: translateY(-5px) scale(1.04) !important;
        }

        .cross-ability {
            border-color: rgba(102, 255, 178, 0.6);
            box-shadow: 0 0 18px rgba(102, 255, 178, 0.3);
        }

        .cross-ability.available {
            border-color: rgba(125, 255, 200, 0.9);
            box-shadow: 0 0 28px rgba(125, 255, 200, 0.6);
        }

        .cross-ability .skill-info-table {
            border-color: rgba(120, 255, 210, 0.6);
        }

        @media (max-width: 640px) {
            .skill-row {
                gap: 24px;
            }

            .skill-icon-button {
                flex-direction: column;
                align-items: stretch;
                min-height: auto;
            }

            .skill-icon-frame {
                flex: 0 0 auto;
                width: 100%;
                max-width: 260px;
                margin: 0 auto 12px;
            }

            .skill-info-table {
                padding: 14px;
            }

            .skill-info-row {
                grid-template-columns: 1fr;
                gap: 6px;
            }

            .skill-info-label {
                font-size: 10px;
                letter-spacing: 0.12em;
            }

            .skill-track-connector {
                display: none;
            }

            .skill-view-toggle {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                padding: 8px;
            }

            .skill-view-toggle button {
                min-width: 0;
                width: 100%;
                padding: 10px 12px 12px;
            }

            .skill-view-badge {
                font-size: 9px;
                letter-spacing: 0.18em;
                padding: 3px 10px;
            }

            .skill-view-label {
                font-size: 10px;
                letter-spacing: 0.06em;
            }
        }

        @media (max-width: 700px) {
            .panel {
                width: min(92vw, 440px);
                max-height: 90vh;
                padding: 22px 16px 18px;
                border-radius: 14px;
            }

            .panel.panel-floating-close {
                padding-top: 60px;
            }

            .close-btn {
                top: 10px;
                right: 12px;
                font-size: 26px;
                width: 42px;
                height: 42px;
            }
        }

        @media (max-width: 480px) {
            .panel {
                width: 94vw;
                padding: 18px 12px 16px;
            }

            .panel.panel-floating-close {
                padding-top: 54px;
            }

            .close-btn {
                right: 10px;
                width: 44px;
                height: 44px;
                font-size: 28px;
            }
        }

        .skill-grid[data-active-view="signature"] .class-ability-track {
            margin-left: 0;
        }

        /* BEAUTIFUL GLOW ANIMATIONS */
        @keyframes activeIconGlow {
            0% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.1);
            }

            50% {
                box-shadow: 0 0 35px rgba(255, 215, 0, 1.0), inset 0 0 25px rgba(255, 255, 255, 0.2), 0 0 50px rgba(135, 206, 235, 0.3);
            }

            100% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.1);
            }
        }

        /* Old skill node classes for compatibility */

        /* Beautiful Marble/Lightning Animations */
        @keyframes marbleSwirl {
            0% {
                background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%);
            }

            25% {
                background: linear-gradient(225deg, #e6e6fa 0%, #f5f5dc 30%, #f8f8ff 60%, #dcdcdc 100%);
            }

            50% {
                background: linear-gradient(315deg, #dcdcdc 0%, #f8f8ff 30%, #f5f5dc 60%, #e6e6fa 100%);
            }

            75% {
                background: linear-gradient(45deg, #f5f5dc 0%, #dcdcdc 30%, #e6e6fa 60%, #f8f8ff 100%);
            }

            100% {
                background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%);
            }
        }

        @keyframes lightningPulse {
            0% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), inset 0 0 8px rgba(255, 255, 255, 0.4);
            }

            50% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), inset 0 0 12px rgba(255, 255, 255, 0.6), 0 0 25px rgba(135, 206, 235, 0.4);
            }

            100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), inset 0 0 8px rgba(255, 255, 255, 0.4);
            }
        }

        .skill-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .skill-node.active,
        .skill-combo-node.active {
            border-color: #FFD700;
            background: #2a2a4e;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        .skill-node.locked,
        .skill-combo-node.locked {
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skill-combo-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .skill-description {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 18px auto 0;
            text-align: center;
            min-height: 40px;
            color: #ffddff;
            font-size: 12px;
            max-width: 680px;
        }

        .ability-hint {
            font-size: 10px;
            color: #87CEEB;
            text-align: center;
            margin-top: 6px;
            font-style: italic;
            text-shadow: 0 0 4px rgba(135, 206, 235, 0.5);
        }

        .ability-icon {
            font-size: 12px;
            margin: 0 2px;
            display: inline-block;
            animation: pulse-glow 2s infinite;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }

        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }

        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }

        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn {
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.5;
            transition: opacity 0.3s ease-in-out;
        }

        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }

        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }

        #bottom-right-controls>.fixed-btn {
            position: static;
        }

        #menuBtn,
        #fsEnterBtn,
        #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn,
        #shopBtnHUD {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }

        #shopBtn {
            opacity: 0.9;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 220, 120, 0.8);
            animation: shopIdleGlow 3.2s ease-in-out infinite;
        }

        #shopBtn:hover {
            opacity: 1;
        }

        #shopBtn.mech-forge-pulse {
            animation: mechForgePulse 1.2s ease-in-out infinite;
            box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25);
        }

        #shopBtn.mech-forge-pulse::after {
            content: "";
            position: absolute;
            inset: -6px;
            border-radius: 18px;
            border: 2px solid rgba(255, 215, 0, 0.65);
            pointer-events: none;
            animation: mechForgeRing 1.2s ease-in-out infinite;
        }

        #shopBtnHUD.mech-forge-pulse {
            animation: mechForgePulse 1.2s ease-in-out infinite;
            box-shadow: 0 0 16px rgba(255, 215, 0, 0.35), 0 0 28px rgba(255, 140, 0, 0.18);
        }

        #pauseBtn {
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }

        .input {
            width: 100%;
            padding: 8px 10px;
            border-radius: 10px;
            background: #17001f;
            color: #ffddff;
            border: 1px solid var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            box-sizing: border-box;
        }

        #abilityBar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 6;
            pointer-events: auto;
        }

        #abilityBar .ability-btn {
            position: relative;
            bottom: auto;
            left: auto;
            right: auto;
            top: auto;
            min-width: 150px;
            padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }

        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }

        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }

        .shop-item-attack {
            border-color: #00bfff;
        }

        .shop-item-health {
            border-color: #00ff00;
        }

        .shop-item-utility {
            border-color: #ffd700;
        }

        .shop-item-champion {
            border-color: #b07bff;
        }

        @keyframes pulse-glow {
            0% {
                box-shadow: 0 0 15px rgba(102, 255, 178, .5);
            }

            50% {
                box-shadow: 0 0 35px rgba(102, 255, 178, 1);
            }

            100% {
                box-shadow: 0 0 15px rgba(102, 255, 178, .5);
            }
        }

        @keyframes mechForgePulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25);
            }

            50% {
                transform: scale(1.03);
                box-shadow: 0 0 28px rgba(255, 215, 0, 0.75), 0 0 45px rgba(255, 140, 0, 0.35);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 18px rgba(255, 215, 0, 0.45), 0 0 35px rgba(255, 140, 0, 0.25);
            }
        }

        @keyframes mechForgeRing {
            0% {
                transform: scale(0.92);
                opacity: 0.9;
            }

            70% {
                transform: scale(1.1);
                opacity: 0.3;
            }

            100% {
                transform: scale(1.15);
                opacity: 0;
            }
        }

        @keyframes shopIdleGlow {
            0% {
                box-shadow: 0 0 6px rgba(255, 215, 0, 0.35);
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.65);
            }

            100% {
                box-shadow: 0 0 6px rgba(255, 215, 0, 0.35);
            }
        }

        @keyframes pulse-glow-ability {
            0% {
                box-shadow: 0 0 10px rgba(178, 102, 255, .5);
            }

            50% {
                box-shadow: 0 0 20px rgba(178, 102, 255, .8);
            }

            100% {
                box-shadow: 0 0 10px rgba(178, 102, 255, .5);
            }
        }

        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        .shop-spotlight {
            position: fixed;
            right: 20px;
            bottom: 95px;
            z-index: 6;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            pointer-events: none;
        }

        .shop-spotlight__badge {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 105, 180, 0.95));
            color: #1d0030;
            font-weight: 700;
            letter-spacing: 0.05em;
            font-size: 13px;
            padding: 8px 16px;
            border-radius: 999px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.45);
            animation: spotlightBadgePulse 2.4s ease-in-out infinite;
        }

        .shop-spotlight__arrow {
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 14px solid rgba(255, 215, 0, 0.85);
            filter: drop-shadow(0 0 12px rgba(255, 215, 0, 0.45));
            animation: spotlightArrowBob 1.6s ease-in-out infinite;
        }

        @keyframes spotlightBadgePulse {
            0% {
                transform: translateY(0);
                opacity: 0.85;
            }

            50% {
                transform: translateY(-3px);
                opacity: 1;
            }

            100% {
                transform: translateY(0);
                opacity: 0.85;
            }
        }

        @keyframes spotlightArrowBob {
            0% {
                transform: translateY(0) scale(1);
            }

            50% {
                transform: translateY(-4px) scale(1.05);
            }

            100% {
                transform: translateY(0) scale(1);
            }
        }

        @media (max-width: 640px) {
            .shop-spotlight {
                right: 50%;
                transform: translateX(50%);
                bottom: 110px;
                align-items: center;
            }
        }

        @media (max-width:820px) {
            canvas {
                width: 100vw;
                height: auto;
                max-height: 75vh;
                border-radius: 8px
            }

            .panel {
                width: min(500px, 94vw)
            }

            .stage {
                width: 98vw
            }

            #belowBoard {
                width: 98vw
            }
        }

        /* Purple gradient classes for different brightness levels */
        .bright {
            color: #e6ccff;
            text-shadow: 0 0 5px #cc99ff, 0 0 10px #cc99ff;
        }

        .medium {
            color: #b366ff;
            text-shadow: 0 0 3px #9933ff;
        }

        .dim {
            color: #6600cc;
            text-shadow: 0 0 2px #6600cc;
        }

        .faded {
            color: #330066;
            opacity: 0.7;
        }

        .very-faded {
            color: #1a0033;
            opacity: 0.4;
        }

        /* Teleport Tutorial Popup */
        #teleportTutorialPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(102, 0, 204, 0.2) 100%);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(204, 153, 255, 0.4);
        }

        #teleportTutorialPanel h2 {
            color: var(--accent);
            font-family: 'Orbitron';
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--accent);
        }

        .teleport-instruction {
            font-size: 18px;
            color: #ffddff;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .teleport-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 5px var(--accent));
        }

        /* --- MOBILE JOYSTICK & BUTTON CONTROLS --- */
        .mobile-control {
            position: fixed;
            z-index: 20;
            opacity: 0.6;
            display: none;
            /* Hidden by default */
        }

        body.mobile-controls-active .mobile-control {
            display: block;
            /* Shown when body class is active */
        }

        #joystick-container {
            bottom: 90px;
            left: 45px;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(50, 0, 70, 0.5);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
        }

        #joystick-stick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ffddff, var(--accent));
            border-radius: 50%;
            pointer-events: none;
            /* Pass touches through to the base */
        }

        #ability-button-container {
            bottom: 100px;
            right: 70px;
        }

        #ability-button {
            width: 90px;
            height: 90px;
            background: rgba(150, 80, 255, 0.3);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(178, 102, 255, .5);
        }

        #ability-icon {
            width: 70px;
            height: 70px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            filter: drop-shadow(0 0 5px white);
        }

        /* --- TOGGLE SWITCH IN UPGRADE HANGAR --- */
        .mobile-toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #330044;
            border: 1px solid var(--accent);
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--accent2);
        }

        input:checked+.slider:before {
            transform: translateX(22px);
        }

        /* Loading Screen Styles */
        #loadingScreen {
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: radial-gradient(ellipse at 50% 40%, #1a0033, #050008);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
        }

        #loadingScreen.loaded {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
            max-width: 600px;
            padding: 20px;
        }

        .loading-logo {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: clamp(32px, 6vw, 56px);
            font-weight: 700;
            color: #ff99cc;
            text-shadow: 0 0 20px rgba(255, 153, 204, 0.6),
                         0 0 40px rgba(178, 102, 255, 0.4);
            margin-bottom: 40px;
            animation: logoGlow 2s ease-in-out infinite alternate;
        }

        @keyframes logoGlow {
            from {
                text-shadow: 0 0 20px rgba(255, 153, 204, 0.6),
                             0 0 40px rgba(178, 102, 255, 0.4);
            }
            to {
                text-shadow: 0 0 30px rgba(255, 153, 204, 0.9),
                             0 0 60px rgba(178, 102, 255, 0.7),
                             0 0 80px rgba(178, 102, 255, 0.5);
            }
        }

        .loading-art-container {
            width: 300px;
            height: 300px;
            margin: 0 auto 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .loading-art-placeholder {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(178, 102, 255, 0.3), rgba(255, 153, 204, 0.2));
            border: 2px solid rgba(178, 102, 255, 0.5);
            box-shadow: 0 0 40px rgba(178, 102, 255, 0.4),
                        inset 0 0 40px rgba(178, 102, 255, 0.2);
            animation: artPulse 3s ease-in-out infinite;
            position: relative;
            overflow: hidden;
        }

        .loading-art-placeholder::before {
            content: '';
            position: absolute;
            inset: 0;
            background: url('data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Cpath d="M100 40 L130 120 L70 120 Z" fill="rgba(255,153,204,0.3)" /%3E%3Ccircle cx="100" cy="100" r="20" fill="rgba(178,102,255,0.4)" /%3E%3C/svg%3E') center/contain no-repeat;
            animation: artRotate 8s linear infinite;
        }

        @keyframes artPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.05); opacity: 1; }
        }

        @keyframes artRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .loading-progress {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        .loading-bar-container {
            height: 8px;
            background: rgba(178, 102, 255, 0.2);
            border: 1px solid rgba(178, 102, 255, 0.4);
            border-radius: 999px;
            overflow: hidden;
            margin-bottom: 12px;
            box-shadow: inset 0 0 10px rgba(178, 102, 255, 0.3);
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #b266ff, #ff99cc, #b266ff);
            background-size: 200% 100%;
            border-radius: 999px;
            transition: width 0.3s ease-out;
            animation: barShimmer 2s linear infinite;
            box-shadow: 0 0 10px rgba(255, 153, 204, 0.6);
        }

        @keyframes barShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .loading-text {
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 14px;
            color: #c49cff;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
        }

        .loading-details {
            font-family: 'Orbitron', ui-sans-serif;
            font-size: 11px;
            color: rgba(196, 156, 255, 0.7);
            letter-spacing: 0.05em;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 3px solid rgba(178, 102, 255, 0.3);
            border-top-color: #ff99cc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-content">
            <div class="loading-logo" style="font-family: 'Orbitron', 'Audiowide', sans-serif; font-size: 72px; font-weight: 700; letter-spacing: 8px; text-shadow: 0 0 30px #ff00ff, 0 0 60px #00ffff; position: absolute; top: 60px; left: 50%; transform: translateX(-50%);">VOID SKIES</div>
            
            <div class="loading-art-container" style="position: absolute; top: 35%; left: 50%; transform: translate(-50%, -50%);">
                <div class="loading-art-placeholder" id="loadingArt">
                    <!-- Custom loading art goes here -->
                </div>
            </div>

            <div class="loading-details" id="loadingDetails" style="position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 900px;">
                <div style="background: rgba(20, 0, 40, 0.85); border: 2px solid #b266ff; box-shadow: 0 0 20px rgba(178, 102, 255, 0.6), 0 0 40px rgba(178, 102, 255, 0.4), inset 0 0 20px rgba(178, 102, 255, 0.1); padding: 20px 40px; border-radius: 8px; font-family: 'Orbitron', sans-serif;">
                    <ul style="color: #ff99cc; text-shadow: 0 0 10px rgba(255, 153, 204, 0.6), 0 0 20px rgba(178, 102, 255, 0.4); font-weight: 500; font-size: 22px; line-height: 1.4; margin: 0; padding-left: 25px; list-style: none; text-align: left;">
                        <li style="margin-bottom: 8px;">â€¢ Use mouse cursor, drag finger, or tap to move your ship</li>
                        <li style="margin-bottom: 8px;">â€¢ Cube Burglar steals your powerups and uses them on enemies</li>
                        <li style="margin-bottom: 8px;">â€¢ Collect <span style="color: #FFD700; text-shadow: 0 0 10px #FFD700, 0 0 20px #FFA500;">ðŸ’° Gold</span> to upgrade or heal your ship</li>
                        <li style="margin-bottom: 8px;">â€¢ Mobile controls and options are in the Upgrade Hanger</li>
                        <li style="margin-bottom: 0;">â€¢ Compete for Global top 30</li>
                    </ul>
                </div>
            </div>

            <div class="loading-progress" style="position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 800px;">
                <div class="loading-text" id="loadingText" style="text-align: center; margin-bottom: 10px;">INITIALIZING SYSTEMS...</div>
                <div class="loading-bar-container">
                    <div class="loading-bar" id="loadingBar" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide">
                        <div class="hud-title">â—¢ SYSTEMS ONLINE â—£</div>
                        <div id="powerupList"></div>
                    </div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card">
                            <div class="hud-title">â—¢ VOID SKIES â—£</div>
                            <div style="text-align:center">
                                SCORE <b id="scoreNum">0</b> â€¢ Gold ðŸ’° <b id="goldNum"
                                    style="color:#FFD700;font-size:1.2em">0</b>
                            </div>
                        </div>
                        <div id="hudPilotContent" class="hud-card">
                            <div class="hud-title" id="pilotTitle">â—¢ UNIDENTIFIED â—£</div>
                            <div style="display:flex;justify-content:space-between;font-size:10px;margin:4px 0 6px 0;">
                                <div>WAVE <b id="waveNum">1</b></div>
                                <div>KILLS <b id="killsNum">0</b></div>
                                <div>LEVEL <b id="levelNum">1</b></div>
                            </div>
                            <div class="bar" id="hpBar"><span id="hpBarFill" style="width:100%"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="hpText">HP: 100 / 100
                            </div>
                            <div class="bar" id="beefShieldBar" style="margin-top:2px;display:none"><span
                                    id="beefShieldBarFill"
                                    style="background:linear-gradient(90deg,#ff8c00,#ff4500)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="beefShieldText"></div>
                <div class="bar" id="shieldBar" style="margin-top:2px;display:none"><span id="shieldBarFill"
                    style="background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>
                <div style="font-size: 9px; text-align: center; line-height: 1;" id="shieldText"></div>
                <div class="bar" id="xpBar" style="margin-top:4px;"><span id="xpBarFill"
                    style="width:0%;background:linear-gradient(90deg,#9bff00,#38ffcc)"></span></div>
                <div style="font-size: 9px; text-align: center; line-height: 1;" id="xpText">XP: 0 / 0</div>
                        </div>
                        <div id="hudBossContent" class="hud-card hide">
                            <div class="hud-title" id="bossTitle">âš¡ BOSS âš¡</div>
                            <div class="bar"><span id="bossBarFill" style="width:100%"></span></div>
                        </div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide">
                        <div class="hud-title">â—¢ EQUIPMENT â—£</div>
                        <div id="equipmentList"></div>
                    </div>

                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <table
                        style="font-size:10px; color:var(--fg); background:rgba(0,0,0,0.7); padding:8px; border-radius:8px; border-spacing:8px 2px;">
                        <tr>
                            <td>v3.8.0</td>
                            <td>FPS:</td>
                            <td><span id="fps">â€”</span></td>
                        </tr>

                    </table>
                </div>

                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">ðŸš€ PILOT LOST ðŸš€</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span
                                id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <!-- <button id="storyBtn" type="button">i</button> -->
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">Cybernetic heavy assault unit with adaptive bio-armor that
                                    responds to hostile engagement. Neural implants trigger reflexive counterstrike
                                    protocols when threatened.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN">
                                </div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">Former corporate military contractor with black-market ordnance
                                    mods. Tactical AI systems provide precision strike capabilities and explosive
                                    payload optimization.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="voidmancer">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER">
                                </div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">Quantum-phase enhanced operative with experimental void-fold
                                    technology. Neural interfaces allow instantaneous spatial displacement through
                                    dimensional rifts.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="subclassPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="subclassPanel">â† BACK</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                        </div>

                    </div>
                    <div id="storyPanel" class="panel hide">
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the
                            plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                            Mammalian life developed specialized spacecraft to venture within and colonize the resources
                            of the primitive creatures.<br><br>
                            The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">ðŸ’€ CALLSIGN ðŸ’€</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button
                                id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">ðŸ† Aces of the Void ðŸ†</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);">âš¡ AUGMENTATION PROTOCOL âš¡</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="shopPanel">â† BACK</button>
                        <button type="button" class="close-btn" id="closeShopTopBtn">Ã—</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">PILOT SYSTEMS UPGRADE CATALOGUE</h2>
                        <p style="color:#ffddff">Gold ðŸ’° <span id="shopgold"
                                style="color:#FFD700;font-size:1.2em">0</span></p>
                        <div class="shop-lab-button-row">
                            <button id="openChampionDressingRoom" class="btn btn-primary hide" type="button">
                                <span class="lab-icon">ðŸ§¬</span>
                                <span class="lab-label">PRIMORDIAL SOLDIER LAB</span>
                                <span class="lab-dna">ðŸ”¬</span>
                            </button>
                        </div>
                        <div class="shop-control-bar">
                            <div class="shop-control-block">
                                <div class="shop-control-copy">
                                    <div class="shop-control-title">Mobile Controls</div>
                                    <div class="shop-control-desc">Toggle the on-screen joystick and ability key for
                                        touch devices.</div>
                                </div>
                                <label class="switch">
                                    <input type="checkbox" id="shopMobileToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="shop-control-block">
                                <div class="shop-control-copy">
                                    <div class="shop-control-title">Auto-Buy Logistics</div>
                                    <div class="shop-control-desc">Let hangar personnel resupply core systems between
                                        waves.</div>
                                    <div id="autoForgeStatusLabel" class="shop-control-status"></div>
                                </div>
                                <label class="switch">
                                    <input type="checkbox" id="shopAutoToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <button id="shopGameMenuBtn" class="btn shop-advanced-btn" type="button">Game Menu</button>
                        </div>

                        <div class="shop-view-tabs">
                            <button id="shopTabPowerups" class="shop-view-btn active" type="button">Powerup
                                Loadout</button>
                            <button id="shopTabUpgrades" class="shop-view-btn" type="button">Upgrade
                                Catalog</button>
                        </div>

                        <div id="shopPowerupView" class="shop-view"></div>
                        <div id="shopUpgradeView" class="shop-view hide">
                            <div id="shopGrid" class="grid"></div>
                        </div>
                        <div class="row" style="justify-content:center;margin-top:10px;gap:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="mechForgeMenuPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="mechForgeMenuPanel">â† BACK</button>
                        <button type="button" class="close-btn" id="closeMechForgeMenuBtn">Ã—</button>
                        <div class="forge-menu-header">
                            <h2 class="forge-menu-title-large">GAME MENU</h2>
                            <p class="forge-menu-subtitle">Configure mission subsystems and references.</p>
                        </div>

                        <div class="forge-menu-section">
                            <div class="mobile-toggle-container forge-menu-toggle">
                                <div class="forge-menu-toggle-copy">
                                    <div class="forge-menu-toggle-title">Upgrade Alerts</div>
                                    <div class="forge-menu-toggle-desc">Display upgrade prompts and reminders between
                                        waves.</div>
                                </div>
                                <label class="switch">
                                    <input type="checkbox" id="shopTutorialToggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                        </div>

                        <div class="forge-menu-section">
                            <div class="forge-menu-section-head">
                                <div>
                                    <div class="forge-menu-title">Auto-Buy Doctrine</div>
                                    <div class="forge-menu-section-hint">Choose a logistics profile to steer procurement
                                        priorities whenever Auto-Buy takes over.</div>
                                </div>
                            </div>
                            <div id="autoForgeProfileGrid" class="forge-profile-grid" role="group"
                                aria-label="Auto-buy doctrines"></div>
                            <div id="autoForgeProfileSummary" class="forge-profile-summary"></div>
                        </div>

                        <div class="forge-menu-section">
                            <div class="forge-menu-grid">
                                <button id="openPrimordialLabFromMenu" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸ§¬ PRIMORDIAL SOLDIER LABORATORY ðŸ§¬</span>
                                    <div class="forge-menu-desc">Refit champion modules, cadence cores, escort protocols, and plating.</div>
                                    <div class="forge-menu-meta" id="championQuickStatus"></div>
                                    <div class="forge-menu-meta">Champion access unlocks once you bind the Shadow Sigil.</div>
                                </button>
                                <button id="openCharacterSheet" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸ“Š CHARACTER STATS &amp; INFO</span>
                                    <div class="forge-menu-desc">Review pilot stats, perks, and mission intel.</div>
                                    <div class="forge-menu-meta">Cross-check loadout bonuses before launch.</div>
                                </button>
                                <button id="openSkillTreeReadonly" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸŒŸ SKILL TREE</span>
                                    <div class="forge-menu-desc">Select a specialization first.</div>
                                </button>
                                <button id="openShopTutorial" class="forge-menu-btn" type="button">
                                    <span class="forge-menu-btn-title">ðŸŽ“ BEGINNER TUTORIAL</span>
                                    <div class="forge-menu-desc">Help learning the basics of the game.</div>
                                </button>
                            </div>
                        </div>

                        <p class="forge-menu-footnote">Combat remains paused while this terminal is open.</p>

                        <div class="row" style="justify-content:center;margin-top:24px">
                            <button id="closeMechForgeMenu" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="characterSheetPanel" class="panel panel-floating-close hide">
                        <button type="button" class="panel-back-btn hide" data-panel-id="characterSheetPanel">â† BACK</button>
                        <button type="button" class="close-btn" id="closeCharacterSheetBtn">Ã—</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">ðŸ“Š CHARACTER SHEET</h2>
                        <div id="characterSheetBody" class="character-sheet-body" aria-live="polite"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeCharacterSheet" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="teleportTutorialPanel" class="panel hide">
                        <h2>âš¡ VOID-FOLD PROTOCOL âš¡</h2>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">ðŸ–±ï¸</span>
                            <span>Right-click to teleport</span>
                        </div>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">ðŸ‘†ðŸ‘†</span>
                            <span>Double-tap to teleport (mobile)</span>
                        </div>
                        <div style="margin-top: 30px;">
                            <p style="color: #ccaaff; font-size: 14px; margin-bottom: 20px;">
                                Quantum displacement damages enemies at origin point.<br>
                                Use strategically to escape danger and deal damage.
                            </p>
                            <button id="closeTeleportTutorial" class="btn" type="button">GOT IT</button>
                        </div>
                    </div>
                    <div id="shopTutorialPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">UPGRADE HANGAR</h2>
                        <p style="color:#ffddff;font-size:14px;line-height:1.5;margin-bottom:14px;">
                            Spend stored gold in the hangar to refit weapons, reinforce hull systems, and restock
                            support gear.
                        </p>
                        <ul style="color:#cfe9ff;font-size:12px;line-height:1.6;padding-left:20px;margin:0 0 18px 0;">
                            <li>Tap an upgrade card to execute the purchase immediately.</li>
                            <li>Enable Auto-Buy to let logistics maintain essentials.</li>
                            <li>Glowing cards flag critical needs such as repairs or shields.</li>
                        </ul>
                        <div class="row" style="justify-content:center;gap:10px;margin-top:10px;flex-wrap:wrap;">
                            <button id="shopTutorialOpen" class="btn" type="button">OPEN UPGRADE HANGAR</button>
                            <button id="shopTutorialSkip" class="btn secondary" type="button">LATER</button>
                        </div>
                        <label
                            style="display:flex;align-items:center;justify-content:center;gap:8px;margin-top:18px;color:#d2baff;font-size:12px;">
                            <input id="shopTutorialDontShow" type="checkbox" style="accent-color:#ffd700;">
                            Don't show this spotlight again
                        </label>
                    </div>
                </div>

                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">SHIELD PULSE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>âš¡ Aces of the Void âš¡</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>

            <!-- Primordial Soldier Laboratory Panel -->
            <div id="championDressingRoom" class="panel panel-floating-close hide">
                <button type="button" class="panel-back-btn hide" data-panel-id="championDressingRoom">â† BACK</button>
                <button type="button" class="close-btn" id="closeDressingRoom">Ã—</button>
                <div class="dressing-room-header">
                    <h2 style="font-family:'Orbitron';color:var(--accent)">PRIMORDIAL SOLDIER LABORATORY</h2>
                    <p style="color:#ffddff;margin:0 0 15px 0">Build and customize your champion guardian with advanced
                        modules and enhancements</p>
                </div>

                <div class="dressing-room-content">
                    <!-- Champion Preview Area -->
                    <div class="champion-preview-section">
                        <div class="preview-viewport">
                            <canvas id="championPreviewCanvas" width="200" height="200"></canvas>
                            <div class="preview-overlay">
                                <div class="champion-name" id="previewChampionName">SHADOW GUARDIAN</div>
                                <div class="champion-class" id="previewChampionClass"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Champion Builder Section -->
                    <div class="champion-builder-section">
                        <div class="builder-header">
                            <h3>Guardian Configuration</h3>
                        </div>
                        <div class="builder-guidance">
                            <p><strong>Attack Modules</strong> are mutually exclusive loadouts. Equipping one replaces
                                the Starfall Salvo until you switch back.</p>
                            <p><strong>Cadence Cores</strong> unlock in tiers. Selecting a higher tier automatically
                                includes the timing bonuses from earlier cores.</p>
                            <p><strong>Minion Protocols</strong> swap escort behaviors. Only one protocol runs at a
                                time, so choose the pattern you want active.</p>
                        </div>

                        <div class="builder-options">
                            <div class="builder-option">
                                <label for="attackModuleSelect">Attack Module</label>
                                <p class="builder-option-desc">Primary weapon pattern for your guardian. Equipping one
                                    replaces the Starfall Salvo until you switch back.</p>
                                <select id="attackModuleSelect" class="builder-select">
                                    <option value="default">Default: Starfall Salvo</option>
                                </select>
                                <div class="builder-option-detail" id="attackModuleDetail"></div>
                            </div>

                            <div class="builder-option">
                                <label for="cadenceSelect">Cadence Core</label>
                                <p class="builder-option-desc">Timing core tiers stack automatically. Higher selections
                                    include the bonuses from earlier cadence cores.</p>
                                <select id="cadenceSelect" class="builder-select">
                                    <option value="0">Default: Baseline Cadence</option>
                                </select>
                                <div class="builder-option-detail" id="cadenceDetail"></div>
                            </div>

                            <div class="builder-option">
                                <label for="protocolSelect">Minion Protocol</label>
                                <p class="builder-option-desc">Choose the escort formation and behavior your minions
                                    will maintain while deployed.</p>
                                <select id="protocolSelect" class="builder-select">
                                    <option value="0">Default: Escort Drones</option>
                                </select>
                                <div class="builder-option-detail" id="protocolDetail"></div>
                            </div>

                            <div class="builder-option">
                                <label for="skinSelect">Plating Skin</label>
                                <p class="builder-option-desc">Cosmetic plating for your champion chassis. Skins do not
                                    alter combat stats.</p>
                                <select id="skinSelect" class="builder-select">
                                    <option value="default">Default: Void Vanguard</option>
                                </select>
                                <div class="builder-option-detail" id="skinDetail"></div>
                            </div>
                        </div>

                        <div class="builder-actions">
                            <button id="applyConfigurationBtn" class="btn builder-action-btn builder-action-apply">Apply
                                Loadout</button>
                            <button id="resetConfigurationBtn" class="btn builder-action-btn builder-action-reset">Reset
                                to Current</button>
                        </div>

                        <div class="champion-preset-section">
                            <h3>Permanent Config Codes</h3>
                            <p>Generate a code from your current champion or load one to restore a saved build.</p>
                            <div class="preset-actions">
                                <button id="generateChampionPresetBtn" class="btn builder-action-btn builder-action-apply" type="button">Generate Code</button>
                                <button id="copyChampionPresetBtn" class="btn builder-action-btn" type="button">Copy to Clipboard</button>
                            </div>
                            <textarea id="championPresetCodeOutput" class="preset-code-output" rows="2" readonly spellcheck="false" placeholder="Your champion code will appear here"></textarea>
                            <div class="preset-import">
                                <input id="championPresetCodeInput" class="preset-code-input" type="text" placeholder="Enter champion code" spellcheck="false" autocomplete="off" />
                                <button id="applyChampionPresetBtn" class="btn builder-action-btn builder-action-apply" type="button">Load Code</button>
                            </div>
                            <div id="championPresetStatus" class="preset-status"></div>
                        </div>
                    </div>

                    <!-- Champion Upgrade Shop Section -->
                    <div class="champion-upgrade-section">
                        <div class="upgrade-header">
                            <h3>Upgrade Laboratory</h3>
                            <p>Purchase new modules and enhancements for your champion</p>
                        </div>

                        <div id="championUpgradeGrid" class="upgrade-grid">
                            <!-- Champion upgrades will be populated by JS -->
                        </div>
                    </div>

                    <!-- Champion Stats Panel -->
                    <div class="champion-stats-section">
                        <div class="stats-header">
                            <h3>Combat Profile</h3>
                        </div>

                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Health</span>
                                <span class="stat-value" id="championHealthStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Shield</span>
                                <span class="stat-value" id="championShieldStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Attack Power</span>
                                <span class="stat-value" id="championAttackStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Fire Rate</span>
                                <span class="stat-value" id="championFireRateStat">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Level</span>
                                <span class="stat-value" id="championLevelStat">1</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Experience</span>
                                <span class="stat-value" id="championExpStat">0/100</span>
                            </div>
                        </div>

                        <div class="loadout-section">
                            <h4>Loadout Highlights</h4>
                            <div class="loadout-list">
                                <div class="loadout-item">
                                    <span class="loadout-label">Skin</span>
                                    <span class="loadout-value" id="championSkinLabel">Void Vanguard</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Attack Module</span>
                                    <span class="loadout-value" id="championAttackModuleLabel">Starfall Salvo</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Cadence Core</span>
                                    <span class="loadout-value" id="championCadenceLabel">Baseline Cadence</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Minion Protocol</span>
                                    <span class="loadout-value" id="championProtocolLabel">Escort Drones</span>
                                </div>
                                <div class="loadout-item">
                                    <span class="loadout-label">Signature</span>
                                    <span class="loadout-value" id="championSignatureLabel">Adaptive Void
                                        Sentinel</span>
                                </div>
                            </div>
                        </div>

                        <div class="attack-types-section">
                            <h4>Attack Capabilities</h4>
                            <div id="championAttackTypesList" class="attack-types-list">
                                <!-- Attack types will be populated by JS -->
                            </div>
                        </div>

                        <div class="upgrade-preview-section">
                            <h4>Active Upgrades</h4>
                            <div id="championUpgradesList" class="upgrades-list">
                                <!-- Active upgrades will be populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>

                <div class="dressing-room-footer">
                    <button id="closeDressingRoomBtn" class="btn" type="button">EXIT LABORATORY</button>
                    <button id="openShopFromDressingRoom" class="btn btn-primary" type="button">UPGRADE HANGAR</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Upgrade Popup Panel -->
    <div id="upgradePopupPanel" class="panel panel-floating-close hide">
        <div style="text-align: center; padding: 20px;">
            <div id="upgradePopupIcon" style="font-size: 48px; margin-bottom: 15px;">âš¡</div>
            <h2 id="upgradePopupTitle" style="font-family:'Orbitron';color:var(--accent);margin:0 0 10px 0;">UPGRADE ACQUIRED</h2>
            <p id="upgradePopupDesc" style="color:#ffddff;font-size:14px;line-height:1.5;margin-bottom:20px;">
                Enhancement applied to your systems.
            </p>
            <div id="upgradePopupTier" style="color:#b19cd9;font-size:12px;margin-bottom:20px;text-transform:uppercase;letter-spacing:1px;"></div>
            <button id="upgradePopupOkBtn" class="btn btn-primary" type="button">ACKNOWLEDGED</button>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>
    <audio id="audioCharge" src="charge.m4a" preload="auto"></audio>
    <audio id="audioBeefCharge" src="beefcharge.m4a" preload="auto"></audio>
    <audio id="audioEpicHorn" src="epichorntrimmed.m4a" preload="auto"></audio>
    <audio id="audioCluster" src="cluster.mp3" preload="auto"></audio>
    <audio id="audioThunder" src="thunder.mp3" preload="auto"></audio>
    <audio id="audioShaoKahn" src="shao_kahn.m4a" preload="auto"></audio>
    <audio id="audioStarGun" src="stargun.m4a" preload="auto"></audio>
    <audio id="audioCoin" src="coin.mp3" preload="auto"></audio>
    <audio id="audioBloop" src="bloop.mp3" preload="auto"></audio>
    <audio id="audioVoidPulse" src="voidpulse.m4a" preload="auto"></audio>
    <audio id="audioIceBreak1" src="icebreak1.m4a" preload="auto"></audio>
    <audio id="audioIceBreak2" src="icebreak2.m4a" preload="auto"></audio>
    <audio id="audioPower" src="power.m4a" preload="auto"></audio>
    <audio id="audioLightningCrit" src="lightningcrit.m4a" preload="auto"></audio>
    <audio id="audioLightningPower" src="lightningpower.mp3" preload="auto"></audio>
    <audio id="audioLightningCrack" src="thundercrack.m4a" preload="auto"></audio>
    <audio id="audioFireWhoosh" src="fire_whoosh.wav" preload="auto"></audio>
    <audio id="audioSizzle" src="sizzle.wav" preload="auto"></audio>
    <audio id="audioUpgradePurchase" src="upgrade_purchase.wav" preload="auto"></audio>
    <audio id="audioVoidPulseAlt" src="void_pulse.wav" preload="auto"></audio>
    <audio id="audioRocketHit" src="rocket_hit.wav" preload="auto"></audio>
    <audio id="audioCoinPickup" src="coin_pickup.wav" preload="auto"></audio>
    <audio id="audioPoisonSplash" src="poison_splash.wav" preload="auto"></audio>
    <audio id="audioSnakeHiss" src="snake_hiss_high.wav" preload="auto"></audio>
    <audio id="audioBugSqueal" src="bug_squeal_redo.wav" preload="auto"></audio>
    <audio id="audioFarExplosion" src="far_explosion.wav" preload="auto"></audio>
    <audio id="audioRobotCrumble" src="robot_crumble.wav" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">UPGRADE HANGAR</button>
        <button id="menuBtn" class="fixed-btn" type="button">ðŸ† TOP PILOTS</button>
    </div>
    <div id="shopSpotlight" class="shop-spotlight hide" aria-live="polite">
        <div id="shopSpotlightMessage" class="shop-spotlight__badge">Upgrade Hangar online. Deploy credits as needed.
        </div>
        <div class="shop-spotlight__arrow"></div>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

    <div id="joystick-container" class="mobile-control">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
    <div id="ability-button-container" class="mobile-control">
        <div id="ability-button">
            <div id="ability-icon"></div>
        </div>
    </div>

    <script>
        (() => {
            // --- CORE SETUP ---
            const W = 960, H = 540;
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            const q = (id) => document.getElementById(id);
            const CHAMPION_SYSTEM_ENABLED = false;
            const API_BASE = "https://transmitted-keen-priced-revealed.trycloudflare.com/api";
            const withAlpha = (color, alpha) => {
                if (!color) return `rgba(255,255,255,${alpha})`;
                const normAlpha = Math.max(0, Math.min(1, alpha));
                if (color.startsWith('rgba(')) {
                    return color.replace(/[\d.]+\)$/,`${normAlpha})`);
                }
                if (color.startsWith('rgb(')) {
                    return color.replace('rgb(','rgba(').replace(')',`,${normAlpha})`);
                }
                if (color.startsWith('#')) {
                    const hex = color.slice(1);
                    const r = parseInt(hex.slice(0,2),16);
                    const g = parseInt(hex.slice(2,4),16);
                    const b = parseInt(hex.slice(4,6),16);
                    return `rgba(${r},${g},${b},${normAlpha})`;
                }
                return color;
            };

            function getCollisionCenter(entity) {
                if (!entity) {
                    return { x: 0, y: 0 };
                }
                const x = Number.isFinite(entity.collisionX) ? entity.collisionX
                    : Number.isFinite(entity.cx) ? entity.cx
                    : Number.isFinite(entity.x) ? entity.x
                    : 0;
                const y = Number.isFinite(entity.collisionY) ? entity.collisionY
                    : Number.isFinite(entity.cy) ? entity.cy
                    : Number.isFinite(entity.y) ? entity.y
                    : 0;
                return { x, y };
            }

            function getCollisionRadius(entity) {
                if (!entity) return 0;
                const candidate = [
                    entity.collisionRadius,
                    entity.hitRadius,
                    entity.hitboxRadius,
                    entity.hitR,
                    entity.r,
                    entity.radius
                ].find(value => Number.isFinite(value));
                if (Number.isFinite(candidate)) {
                    return Math.max(0, candidate);
                }
                const width = Number.isFinite(entity.width) ? Math.abs(entity.width) * 0.5 : 0;
                const height = Number.isFinite(entity.height) ? Math.abs(entity.height) * 0.5 : 0;
                if (width || height) {
                    return Math.max(width, height);
                }
                if (Number.isFinite(entity.size)) {
                    return Math.max(0, entity.size * 0.5);
                }
                return 0;
            }

            function collide(a, b) {
                if (!a || !b) return false;
                const aRadius = getCollisionRadius(a);
                const bRadius = getCollisionRadius(b);
                const paddingA = Number.isFinite(a.collisionPadding) ? a.collisionPadding : 0;
                const paddingB = Number.isFinite(b.collisionPadding) ? b.collisionPadding : 0;
                const combined = aRadius + bRadius + paddingA + paddingB;
                if (combined <= 0) return false;
                const ac = getCollisionCenter(a);
                const bc = getCollisionCenter(b);
                const dx = ac.x - bc.x;
                const dy = ac.y - bc.y;
                return dx * dx + dy * dy <= combined * combined;
            }

            // --- PIXI SETUP ---
            let pixiApp, particleContainer, bulletContainer, cubeBurglarContainer;
            const bulletTextures = {};
            let particleTexture;
            const bulletSpritePool = [];
            const particleSpritePool = [];
            const activeBulletSprites = new Map();
            const activeParticleSprites = new Map();
            (() => {
                try {
                    const stage = document.querySelector('.stage');
                    pixiApp = new PIXI.Application();
                    pixiApp.init({
                        width: W,
                        height: H,
                        backgroundAlpha: 0,
                        antialias: true,
                        resolution: window.devicePixelRatio || 1,
                        autoDensity: true
                    }).then(() => {
                        pixiApp.canvas.style.position = 'absolute';
                        pixiApp.canvas.style.top = '0';
                        pixiApp.canvas.style.left = '0';
                        pixiApp.canvas.style.pointerEvents = 'none';
                        pixiApp.canvas.style.width = '100%';
                        pixiApp.canvas.style.height = '100%';
                        pixiApp.canvas.style.zIndex = '2';
                        stage.appendChild(pixiApp.canvas);

                        resizeGameSurfaces();

                        // Create containers for layering
                        particleContainer = new PIXI.Container();
                        bulletContainer = new PIXI.Container();
                        cubeBurglarContainer = new PIXI.Container();
                        
                        pixiApp.stage.addChild(particleContainer);
                        pixiApp.stage.addChild(bulletContainer);
                        pixiApp.stage.addChild(cubeBurglarContainer);

                        console.log('âœ… PixiJS initialized for bullet rendering');
                        
                        // Set up WebGL context loss/restore handlers
                        setupWebGLContextHandlers();
                    });
                } catch (err) {
                    console.error('âŒ Failed to initialize PixiJS:', err);
                }
            })();

            // WebGL Context Loss Recovery System
            let webglContextLost = false;
            let webglRecoveryAttempts = 0;
            const MAX_RECOVERY_ATTEMPTS = 3;
            
            // Expose for diagnostics
            window.webglContextLost = webglContextLost;
            window.webglRecoveryAttempts = webglRecoveryAttempts;

            function setupWebGLContextHandlers() {
                if (!pixiApp || !pixiApp.canvas) {
                    console.warn('âš ï¸ Cannot set up WebGL handlers - no canvas');
                    return;
                }

                const canvas = pixiApp.canvas;

                // Handle context loss
                canvas.addEventListener('webglcontextlost', (event) => {
                    event.preventDefault();
                    webglContextLost = true;
                    window.webglContextLost = true;
                    console.error('ðŸ”´ WebGL context lost! Pausing game...');
                    
                    // ========== DIAGNOSTIC LOGGING ==========
                    const contextLossInfo = {
                        timestamp: new Date().toISOString(),
                        eventType: event.type,
                        eventTimeStamp: event.timeStamp,
                        renderState: {
                            pixiApp: !!pixiApp,
                            renderer: pixiApp?.renderer ? {
                                type: pixiApp.renderer.constructor.name,
                                width: pixiApp.renderer.width,
                                height: pixiApp.renderer.height,
                                resolution: pixiApp.renderer.resolution,
                                gl: pixiApp.renderer.gl ? 'exists' : 'null',
                                glState: pixiApp.renderer.gl ? {
                                    isContextLost: pixiApp.renderer.gl.isContextLost(),
                                    drawingBufferWidth: pixiApp.renderer.gl.drawingBufferWidth,
                                    drawingBufferHeight: pixiApp.renderer.gl.drawingBufferHeight
                                } : null
                            } : null,
                            bulletTextures: {
                                normal: !!bulletTextures.normal,
                                ice: !!bulletTextures.ice,
                                poison: !!bulletTextures.poison,
                                fire: !!bulletTextures.fire,
                                void: !!bulletTextures.void,
                                lavaBlade: !!bulletTextures.lavaBlade
                            },
                            spritePoolStats: {
                                activeBulletSprites: activeBulletSprites.size,
                                bulletSpritePool: bulletSpritePool.length,
                                activeParticleSprites: activeParticleSprites.size,
                                particleSpritePool: particleSpritePool.length
                            }
                        },
                        gameState: {
                            isPaused: store.isPaused,
                            isGameOver: store.isGameOver,
                            waveNumber: store.wave,
                            bulletCount: store.bullets.length,
                            enemyCount: store.enemies.length,
                            playerHp: store.player?.hp
                        },
                        recoveryAttempts: webglRecoveryAttempts,
                        maxAttempts: MAX_RECOVERY_ATTEMPTS
                    };
                    
                    console.log('ðŸ“Š CONTEXT LOSS DIAGNOSTICS:', JSON.stringify(contextLossInfo, null, 2));
                    window._lastWebGLContextLossInfo = contextLossInfo;
                    // ========== END DIAGNOSTIC LOGGING ==========
                    
                    // Auto-pause to prevent further rendering issues
                    if (!store.isPaused && !store.isGameOver) {
                        store.isPaused = true;
                        const pauseBtn = document.getElementById('pauseBtn');
                        if (pauseBtn) pauseBtn.textContent = 'RESUME';
                    }
                    
                    // Track in diagnostics
                    window._lastBackgroundEvent = 'WebGL Context Lost';
                    window._lastBackgroundTime = Date.now();
                    
                    announce('âš ï¸ GRAPHICS RESET - RESUMING...', 3000);
                }, false);

                // Handle context restoration
                canvas.addEventListener('webglcontextrestored', async (event) => {
                    console.log('ðŸŸ¢ WebGL context restored! Rebuilding renderer...');
                    webglContextLost = false;
                    window.webglContextLost = false;
                    webglRecoveryAttempts++;
                    window.webglRecoveryAttempts = webglRecoveryAttempts;
                    
                    // ========== DIAGNOSTIC LOGGING ==========
                    const contextRestoredInfo = {
                        timestamp: new Date().toISOString(),
                        eventType: event.type,
                        eventTimeStamp: event.timeStamp,
                        recoveryAttempt: webglRecoveryAttempts,
                        maxAttempts: MAX_RECOVERY_ATTEMPTS,
                        renderState: {
                            gl: pixiApp?.renderer?.gl ? {
                                isContextLost: pixiApp.renderer.gl.isContextLost(),
                                extensions: pixiApp.renderer.gl.getSupportedExtensions ? 
                                    pixiApp.renderer.gl.getSupportedExtensions().slice(0, 10) : 'unknown',
                                drawingBufferWidth: pixiApp.renderer.gl.drawingBufferWidth,
                                drawingBufferHeight: pixiApp.renderer.gl.drawingBufferHeight
                            } : null,
                            pixiRenderer: pixiApp?.renderer ? {
                                type: pixiApp.renderer.constructor.name,
                                width: pixiApp.renderer.width,
                                height: pixiApp.renderer.height
                            } : null,
                            texturesStillPresent: {
                                normal: !!bulletTextures.normal,
                                ice: !!bulletTextures.ice
                            }
                        }
                    };
                    
                    console.log('ðŸ“Š CONTEXT RESTORED INFO:', JSON.stringify(contextRestoredInfo, null, 2));
                    window._lastWebGLContextRestoredInfo = contextRestoredInfo;
                    // ========== END DIAGNOSTIC LOGGING ==========
                    
                    window._lastBackgroundEvent = `WebGL Context Restored (Attempt ${webglRecoveryAttempts})`;
                    window._lastBackgroundTime = Date.now();
                    
                    if (webglRecoveryAttempts <= MAX_RECOVERY_ATTEMPTS) {
                        try {
                            console.log('ðŸ”„ Starting rebuild with recovered context...');
                            await rebuildPixiRenderer();
                            announce('âœ… GRAPHICS RESTORED', 2000);
                        } catch (err) {
                            console.error('âŒ Failed to rebuild renderer:', err);
                            console.error('Stack:', err.stack);
                            announce('âŒ GRAPHICS ERROR - CHECK DIAGNOSTICS', 4000);
                            window._lastPixiRebuildError = {
                                message: err.message,
                                stack: err.stack,
                                timestamp: new Date().toISOString()
                            };
                        }
                    } else {
                        console.error('âŒ Too many recovery attempts - manual restart required');
                        announce('âŒ GRAPHICS FAILURE - RESTART REQUIRED', 5000);
                    }
                }, false);

                console.log('âœ… WebGL context handlers registered');
            }

            async function rebuildPixiRenderer() {
                console.log('ðŸ”„ Rebuilding PixiJS renderer...');
                
                const rebuildStartTime = performance.now();
                const rebuildLog = {
                    startTime: new Date().toISOString(),
                    steps: []
                };
                
                try {
                    // Clear sprite pools
                    console.log('   Step 1: Clearing sprite pools...');
                    activeBulletSprites.clear();
                    activeParticleSprites.clear();
                    bulletSpritePool.length = 0;
                    particleSpritePool.length = 0;
                    rebuildLog.steps.push({ step: 'clear_pools', success: true });
                    
                    // Recreate bullet textures
                    console.log('   Step 2: Recreating bullet textures...');
                    if (typeof createBulletTextures === 'function') {
                        try {
                            createBulletTextures();
                            console.log('âœ… Bullet textures recreated');
                            rebuildLog.steps.push({ step: 'recreate_bullet_textures', success: true, textures: Object.keys(bulletTextures) });
                        } catch (e) {
                            console.error('âŒ Bullet texture recreation failed:', e);
                            rebuildLog.steps.push({ step: 'recreate_bullet_textures', success: false, error: e.message });
                            throw e;
                        }
                    } else {
                        console.warn('âš ï¸ createBulletTextures not available');
                        rebuildLog.steps.push({ step: 'recreate_bullet_textures', success: false, error: 'function not available' });
                    }
                    
                    // Recreate particle texture
                    console.log('   Step 3: Recreating particle texture...');
                    if (typeof createParticleTexture === 'function') {
                        try {
                            createParticleTexture();
                            console.log('âœ… Particle textures recreated');
                            rebuildLog.steps.push({ step: 'recreate_particle_texture', success: true });
                        } catch (e) {
                            console.error('âŒ Particle texture recreation failed:', e);
                            rebuildLog.steps.push({ step: 'recreate_particle_texture', success: false, error: e.message });
                            throw e;
                        }
                    } else {
                        console.warn('âš ï¸ createParticleTexture not available');
                        rebuildLog.steps.push({ step: 'recreate_particle_texture', success: false, error: 'function not available' });
                    }
                    
                    // Trigger a resize to ensure proper scaling
                    console.log('   Step 4: Resizing game surfaces...');
                    try {
                        resizeGameSurfaces();
                        rebuildLog.steps.push({ step: 'resize_surfaces', success: true });
                    } catch (e) {
                        console.error('âŒ Resize failed:', e);
                        rebuildLog.steps.push({ step: 'resize_surfaces', success: false, error: e.message });
                        throw e;
                    }
                    
                    // Reset time reference to prevent time jump
                    store.last = performance.now();
                    rebuildLog.steps.push({ step: 'reset_time', success: true });
                    
                    const rebuildDuration = performance.now() - rebuildStartTime;
                    console.log(`âœ… PixiJS renderer rebuilt successfully (${rebuildDuration.toFixed(2)}ms)`);
                    rebuildLog.endTime = new Date().toISOString();
                    rebuildLog.duration = rebuildDuration;
                    rebuildLog.finalState = {
                        pixiApp: !!pixiApp,
                        renderer: !!pixiApp?.renderer,
                        gl: !!pixiApp?.renderer?.gl,
                        bulletTextures: Object.keys(bulletTextures).length,
                        spritePoolSize: bulletSpritePool.length + particleSpritePool.length
                    };
                    
                    console.log('ðŸ“Š REBUILD LOG:', JSON.stringify(rebuildLog, null, 2));
                    window._lastPixiRebuildLog = rebuildLog;
                    
                    // Auto-resume after a brief delay if we were auto-paused
                    setTimeout(() => {
                        if (store.isPaused && !store.isGameOver) {
                            store.isPaused = false;
                            const pauseBtn = document.getElementById('pauseBtn');
                            if (pauseBtn) pauseBtn.textContent = 'PAUSE';
                            console.log('â–¶ï¸ Game resumed after WebGL recovery');
                        }
                    }, 500);
                    
                } catch (error) {
                    console.error('âŒ Error during renderer rebuild:', error);
                    throw error;
                }
            }

            // --- MAIN CANVAS SETUP ---
            const cvs = document.createElement('canvas');
            cvs.width = W;
            cvs.height = H;
            cvs.style.position = 'absolute';
            cvs.style.top = '0';
            cvs.style.left = '0';
            cvs.style.width = '100%';
            cvs.style.height = '100%';
            cvs.style.zIndex = '1';
            document.querySelector('.stage').appendChild(cvs);
            const ctx = cvs.getContext('2d');
            // High-DPI display management state
            const stageElement = document.querySelector('.stage');
            const MAX_DEVICE_SCALE = 3;
            let cssScaleX = 1;
            let cssScaleY = 1;
            let canvasScaleX = 1;
            let canvasScaleY = 1;
            let shadowScaleX = 1;
            let shadowScaleY = 1;
            let shadowBlurScale = 1;
            let storedShadowBlur = 0;
            let storedShadowOffsetX = 0;
            let storedShadowOffsetY = 0;

            const contextProto = Object.getPrototypeOf(ctx);
            const shadowBlurDescriptor = contextProto ? Object.getOwnPropertyDescriptor(contextProto, 'shadowBlur') : null;
            const shadowOffsetXDescriptor = contextProto ? Object.getOwnPropertyDescriptor(contextProto, 'shadowOffsetX') : null;
            const shadowOffsetYDescriptor = contextProto ? Object.getOwnPropertyDescriptor(contextProto, 'shadowOffsetY') : null;

            let applyShadowScaling = () => {};
            try {
                // Intercept shadow properties so their magnitudes follow the CSS scaling ratio
                if (shadowBlurDescriptor && shadowBlurDescriptor.configurable) {
                    storedShadowBlur = shadowBlurDescriptor.get ? shadowBlurDescriptor.get.call(ctx) : 0;
                    Object.defineProperty(ctx, 'shadowBlur', {
                        get() { return storedShadowBlur; },
                        set(value) {
                            storedShadowBlur = Number.isFinite(value) ? value : 0;
                            if (shadowBlurDescriptor.set) {
                                shadowBlurDescriptor.set.call(ctx, storedShadowBlur * shadowBlurScale);
                            }
                        },
                        configurable: true,
                        enumerable: false
                    });
                }

                if (shadowOffsetXDescriptor && shadowOffsetXDescriptor.configurable) {
                    storedShadowOffsetX = shadowOffsetXDescriptor.get ? shadowOffsetXDescriptor.get.call(ctx) : 0;
                    Object.defineProperty(ctx, 'shadowOffsetX', {
                        get() { return storedShadowOffsetX; },
                        set(value) {
                            storedShadowOffsetX = Number.isFinite(value) ? value : 0;
                            if (shadowOffsetXDescriptor.set) {
                                shadowOffsetXDescriptor.set.call(ctx, storedShadowOffsetX * shadowScaleX);
                            }
                        },
                        configurable: true,
                        enumerable: false
                    });
                }

                if (shadowOffsetYDescriptor && shadowOffsetYDescriptor.configurable) {
                    storedShadowOffsetY = shadowOffsetYDescriptor.get ? shadowOffsetYDescriptor.get.call(ctx) : 0;
                    Object.defineProperty(ctx, 'shadowOffsetY', {
                        get() { return storedShadowOffsetY; },
                        set(value) {
                            storedShadowOffsetY = Number.isFinite(value) ? value : 0;
                            if (shadowOffsetYDescriptor.set) {
                                shadowOffsetYDescriptor.set.call(ctx, storedShadowOffsetY * shadowScaleY);
                            }
                        },
                        configurable: true,
                        enumerable: false
                    });
                }

                applyShadowScaling = () => {
                    if (shadowBlurDescriptor && shadowBlurDescriptor.set) {
                        shadowBlurDescriptor.set.call(ctx, storedShadowBlur * shadowBlurScale);
                    }
                    if (shadowOffsetXDescriptor && shadowOffsetXDescriptor.set) {
                        shadowOffsetXDescriptor.set.call(ctx, storedShadowOffsetX * shadowScaleX);
                    }
                    if (shadowOffsetYDescriptor && shadowOffsetYDescriptor.set) {
                        shadowOffsetYDescriptor.set.call(ctx, storedShadowOffsetY * shadowScaleY);
                    }
                };
            } catch (shadowHookError) {
                applyShadowScaling = () => {};
            }

            const getEffectiveDevicePixelRatio = () => {
                const raw = window.devicePixelRatio || 1;
                return Math.min(MAX_DEVICE_SCALE, Math.max(1, raw));
            };

            // Scale the main canvas and Pixi renderer to match the viewport while preserving game coordinates
            const resizeGameSurfaces = () => {
                if (!stageElement) {
                    cssScaleX = cssScaleY = canvasScaleX = canvasScaleY = 1;
                    shadowScaleX = shadowScaleY = shadowBlurScale = 1;
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.imageSmoothingEnabled = false;
                    return;
                }

                const cssWidth = Math.max(1, stageElement.clientWidth || W);
                const cssHeight = Math.max(1, stageElement.clientHeight || H);
                const dpr = getEffectiveDevicePixelRatio();

                cssScaleX = cssWidth / W;
                cssScaleY = cssHeight / H;
                canvasScaleX = Math.max(0.1, cssScaleX * dpr);
                canvasScaleY = Math.max(0.1, cssScaleY * dpr);
                shadowScaleX = Math.max(0.1, cssScaleX);
                shadowScaleY = Math.max(0.1, cssScaleY);
                shadowBlurScale = Math.sqrt(shadowScaleX * shadowScaleY);

                const targetWidth = Math.round(W * canvasScaleX);
                const targetHeight = Math.round(H * canvasScaleY);

                if (cvs.width !== targetWidth || cvs.height !== targetHeight) {
                    cvs.width = targetWidth;
                    cvs.height = targetHeight;
                }

                cvs.style.width = `${cssWidth}px`;
                cvs.style.height = `${cssHeight}px`;

                ctx.setTransform(canvasScaleX, 0, 0, canvasScaleY, 0, 0);
                ctx.imageSmoothingEnabled = false;
                applyShadowScaling();

                if (pixiApp && pixiApp.renderer) {
                    const pixiResolution = Math.max(1, Math.max(cssScaleX, cssScaleY) * dpr);
                    try {
                        if (Math.abs((pixiApp.renderer.resolution || 1) - pixiResolution) > 0.01) {
                            pixiApp.renderer.resolution = pixiResolution;
                            if (typeof pixiApp.renderer.resize === 'function') {
                                if (pixiApp.renderer.resize.length >= 2) {
                                    pixiApp.renderer.resize(W, H);
                                } else {
                                    pixiApp.renderer.resize({ width: W, height: H });
                                }
                            }
                        }
                    } catch (pixiResolutionError) {
                        // Ignore renderer resolution assignment errors
                    }

                    if (pixiApp.canvas) {
                        pixiApp.canvas.style.width = `${cssWidth}px`;
                        pixiApp.canvas.style.height = `${cssHeight}px`;
                    }
                }
            };

            // Re-evaluate scaling whenever the browser's device pixel ratio changes
            resizeGameSurfaces();

            // Poll for device pixel ratio changes that occur without resize/orientation events (multi-monitor setups)
            let lastKnownDpr = getEffectiveDevicePixelRatio();
            setInterval(() => {
                const currentDpr = getEffectiveDevicePixelRatio();
                if (Math.abs(currentDpr - lastKnownDpr) > 0.001) {
                    lastKnownDpr = currentDpr;
                    resizeGameSurfaces();
                }
            }, 750);

            // Track stage element resizes that don't trigger window resize (e.g., UI overlays)
            if (typeof ResizeObserver !== 'undefined' && stageElement) {
                const stageObserver = new ResizeObserver(() => resizeGameSurfaces());
                stageObserver.observe(stageElement);
            }

            // Fullscreen transitions adjust viewport metrics outside window resize events
            document.addEventListener('fullscreenchange', resizeGameSurfaces);
            // Device orientation flips can alter viewport metrics without a traditional resize
            window.addEventListener('orientationchange', resizeGameSurfaces);
            
            // Mobile background/foreground handling to prevent game state loss
            let wasAutoPaused = false;
            window._lastBackgroundEvent = 'None';
            window._lastBackgroundTime = null;
            
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // App went to background - auto-pause to prevent state issues
                    window._lastBackgroundEvent = 'Page Hidden (backgrounded)';
                    window._lastBackgroundTime = Date.now();
                    if (!store.isPaused && !store.isGameOver) {
                        store.isPaused = true;
                        wasAutoPaused = true;
                        const pauseBtn = document.getElementById('pauseBtn');
                        if (pauseBtn) pauseBtn.textContent = 'RESUME';
                        console.log('ðŸŒ™ Game auto-paused (backgrounded)');
                    }
                } else {
                    // App returned to foreground
                    window._lastBackgroundEvent = 'Page Visible (foregrounded)';
                    window._lastBackgroundTime = Date.now();
                    if (wasAutoPaused) {
                        // Reset the time reference to prevent massive dt jump
                        store.last = performance.now();
                        console.log('â˜€ï¸ Game ready to resume (foregrounded)');
                        // Don't auto-resume - let player manually resume for safety
                        wasAutoPaused = false;
                    }
                }
            });

            // Additional mobile safeguard: pause on page blur (iOS Safari)
            window.addEventListener('blur', () => {
                window._lastBackgroundEvent = 'Window Blur';
                window._lastBackgroundTime = Date.now();
                if (!store.isPaused && !store.isGameOver) {
                    store.isPaused = true;
                    wasAutoPaused = true;
                    const pauseBtn = document.getElementById('pauseBtn');
                    if (pauseBtn) pauseBtn.textContent = 'RESUME';
                }
            });

            // Reset time reference on focus to prevent time jumps
            window.addEventListener('focus', () => {
                window._lastBackgroundEvent = 'Window Focus';
                window._lastBackgroundTime = Date.now();
                store.last = performance.now();
            });
            
            // Mouse input tracking
            const mouse = { x: W / 2, y: H / 2 };

            // Bullet texture factory
            function createBulletTextures() {
                if (!pixiApp || !pixiApp.renderer) return;
                
                // Normal bullet (triangle) - WHITE texture so tinting works
                const normalGraphics = new PIXI.Graphics();
                normalGraphics.poly([
                    { x: 0, y: -4.5 },
                    { x: 3.6, y: 3.6 },
                    { x: -3.6, y: 3.6 }
                ]);
                normalGraphics.fill(0xFFFFFF); // White texture for tinting
                bulletTextures.normal = pixiApp.renderer.generateTexture(normalGraphics);
                
                // Ice bullet (gradient line: white -> light ice blue -> darker ice blue)
                const iceGraphics = new PIXI.Graphics();
                // Create gradient effect by drawing multiple segments
                const iceLength = 6;
                const iceSegments = 8;
                const iceColors = [
                    0xFFFFFF,  // White at tip
                    0xE3F4FF,  // Very light ice blue
                    0xB8E6FF,  // Light ice blue
                    0x8CB4FF,  // Medium ice blue
                    0x6699FF,  // Darker ice blue
                    0x4D7FCC,  // Even darker
                    0x3366AA,  // Deep ice blue
                    0x1A4D88   // Darkest ice blue at base
                ];
                
                for (let i = 0; i < iceSegments; i++) {
                    const startY = -iceLength + (i / iceSegments) * (iceLength * 2);
                    const endY = -iceLength + ((i + 1) / iceSegments) * (iceLength * 2);
                    const color = iceColors[i];
                    const alpha = 0.9 + (i / iceSegments) * 0.1; // Slightly more opaque towards base
                    
                    iceGraphics.moveTo(0, startY);
                    iceGraphics.lineTo(0, endY);
                    iceGraphics.stroke({ width: 2.2, color: color, alpha: alpha, cap: 'round' });
                }
                bulletTextures.ice = pixiApp.renderer.generateTexture(iceGraphics);
                
            // Poison bullet (dart shape - narrow and pointed)
                const poisonGraphics = new PIXI.Graphics();
                const dartLength = 7;
                const dartWidth = 1.2;
                const tipLength = dartLength * 0.35;
                
                // Draw dart shape (pointed tip, narrow body)
                poisonGraphics.poly([
                    { x: 0, y: -dartLength },              // Sharp tip
                    { x: dartWidth, y: -dartLength + tipLength },  // Tip flare
                    { x: dartWidth * 0.5, y: dartLength },  // Narrow body to base
                    { x: -dartWidth * 0.5, y: dartLength }, // Other side of base
                    { x: -dartWidth, y: -dartLength + tipLength }  // Other tip flare
                ]);
                poisonGraphics.fill({ color: 0x32FF32, alpha: 0.95 }); // Bright green
                poisonGraphics.stroke({ width: 0.8, color: 0x00AA00, alpha: 0.8 }); // Darker green outline
                bulletTextures.poison = pixiApp.renderer.generateTexture(poisonGraphics);

                // Fire bullet (slender ember line with subtle glow)
                const fireGraphics = new PIXI.Graphics();
                const fireLength = 7;
                const fireSegments = 6;
                const fireColors = [
                    0xFFE0C2,
                    0xFFB676,
                    0xFF8A47,
                    0xFF6A2A,
                    0xFF4C1A,
                    0xD9390F
                ];
                for (let i = 0; i < fireSegments; i++) {
                    const startY = -fireLength + (i / fireSegments) * (fireLength * 2);
                    const endY = -fireLength + ((i + 1) / fireSegments) * (fireLength * 2);
                    const color = fireColors[i];
                    const alpha = 0.8 + (i / fireSegments) * 0.15;
                    fireGraphics.moveTo(0, startY);
                    fireGraphics.lineTo(0, endY);
                    fireGraphics.stroke({ width: 2.2 - i * 0.15, color, alpha, cap: 'round' });
                }
                bulletTextures.fire = pixiApp.renderer.generateTexture(fireGraphics);
                
                // Void bullet (inky orb with luminous violet edge)
                const voidGraphics = new PIXI.Graphics();
                const voidRadius = 4.5;
                const voidGradient = new PIXI.FillGradient(0, -voidRadius, 0, voidRadius);
                voidGradient.addColorStop(0, '#a98cff');
                voidGradient.addColorStop(0.45, '#3b1a48');
                voidGradient.addColorStop(1, '#050008');
                voidGraphics.circle(0, 0, voidRadius);
                voidGraphics.fill(voidGradient);
                voidGraphics.stroke({ width: 1.2, color: '#cebfff', alpha: 0.6 });
                voidGraphics.stroke({ width: 0.6, color: '#150a1f', alpha: 0.95 });
                bulletTextures.void = pixiApp.renderer.generateTexture(voidGraphics);
                
                // Lava blade (sharp cyberpunk electric blade) - high res crisp version
                const lavaGraphics = new PIXI.Graphics();
                const bladeHeight = 16; // Longer and thinner for sharper look
                const bladeWidth = 3.2; // Much thinner width

                // Cyberpunk electric gradient: Neon cyan â†’ Electric purple â†’ Hot magenta â†’ Bright white core
                const gradient = new PIXI.FillGradient(0, -bladeHeight, 0, bladeHeight);
                gradient.addColorStop(0, '#ff3c1a'); // Neon cyan tip
                gradient.addColorStop(0.25, '#ec4899'); // Bright sky blue
                gradient.addColorStop(0.5, '#a855f7'); // Electric purple center
                gradient.addColorStop(0.75, '#000000'); // Hot magenta
                gradient.addColorStop(1, '#fbbf24'); // Bright electric yellow

                // Create sharp blade shape - elongated and thin
                lavaGraphics.poly([
                    { x: 0, y: -bladeHeight },           // Sharp tip
                    { x: bladeWidth * 0.5, y: -bladeHeight * 0.15 },  // Right edge
                    { x: bladeWidth * 0.4, y: bladeHeight * 0.3 },    // Right taper
                    { x: 0, y: bladeHeight },            // Bottom point
                    { x: -bladeWidth * 0.4, y: bladeHeight * 0.3 },   // Left taper
                    { x: -bladeWidth * 0.5, y: -bladeHeight * 0.15 }  // Left edge
                ]);
                lavaGraphics.fill(gradient);

                // Bright energy core - thin vertical line
                const coreGradient = new PIXI.FillGradient(0, -bladeHeight * 0.8, 0, bladeHeight * 0.8);
                coreGradient.addColorStop(0, '#a855f7'); // White hot core
                coreGradient.addColorStop(0.5, '#ec4899'); // Cyan center ec4899
                coreGradient.addColorStop(1, '#a855f7'); // White hot core
                
                lavaGraphics.poly([
                    { x: 0, y: -bladeHeight * 0.85 },
                    { x: bladeWidth * 0.12, y: -bladeHeight * 0.1 },
                    { x: 0, y: bladeHeight * 0.85 },
                    { x: -bladeWidth * 0.12, y: -bladeHeight * 0.1 }
                ]);
                lavaGraphics.fill(coreGradient);

                // Bright neon outline for cyberpunk glow
                lavaGraphics.poly([
                    { x: 0, y: -bladeHeight },
                    { x: bladeWidth * 0.5, y: -bladeHeight * 0.15 },
                    { x: bladeWidth * 0.4, y: bladeHeight * 0.3 },
                    { x: 0, y: bladeHeight },
                    { x: -bladeWidth * 0.4, y: bladeHeight * 0.3 },
                    { x: -bladeWidth * 0.5, y: -bladeHeight * 0.15 },
                    { x: 0, y: -bladeHeight }
                ]);
                lavaGraphics.stroke({ width: 1.2, color: '#ff1a5e', alpha: 0.9 }); // Reddish pink outline
                lavaGraphics.stroke({ width: 0.5, color: '#ff6b9d', alpha: 0.7 }); // Pink glow edge

                // Generate at higher resolution for crisp sharp edges
                bulletTextures.lavaBlade = pixiApp.renderer.generateTexture(lavaGraphics, {
                    resolution: 6,
                    scaleMode: PIXI.SCALE_MODES.LINEAR
                });
                
            console.log('âœ… Bullet textures created', bulletTextures);
            }

            // Global function to reload textures (useful when changing colors)
            window.reloadBulletTextures = function() {
                console.log('ðŸ”„ Reloading bullet textures...');
                
                // Clear active sprites to prevent using destroyed textures
                activeBulletSprites.forEach((sprite, bullet) => {
                    if (sprite && sprite.parent) {
                        sprite.parent.removeChild(sprite);
                    }
                });
                activeBulletSprites.clear();
                
                // Return sprites to pool
                while (bulletSpritePool.length > 0) {
                    const sprite = bulletSpritePool.pop();
                    if (sprite && sprite.parent) {
                        sprite.parent.removeChild(sprite);
                    }
                }
                
                // Don't destroy textures, just clear the cache - let PixiJS handle cleanup
                Object.keys(bulletTextures).forEach(key => delete bulletTextures[key]);
                
                // Regenerate all textures
                createBulletTextures();
                
                console.log('âœ… Bullet textures reloaded! New colors active.');
                return 'Textures reloaded successfully!';
            };

            // Particle texture factory
            function createParticleTexture() {
                if (!pixiApp || !pixiApp.renderer) return;
                
                const graphics = new PIXI.Graphics();
                graphics.circle(0, 0, 8);
                graphics.fill(0xffffff);
                particleTexture = pixiApp.renderer.generateTexture(graphics);
                
                console.log('âœ… Particle texture created', particleTexture);
            }

            // Bullet sprite pool functions
            function getBulletSprite(bullet) {
                if (!bulletContainer) {
                    console.warn('âš ï¸ bulletContainer not ready');
                    return null;
                }
                
                let sprite = bulletSpritePool.pop();
                if (!sprite) {
                    sprite = new PIXI.Sprite();
                    bulletContainer.addChild(sprite);
                }
                
                // Set texture based on bullet type
                sprite.tint = 0xffffff;
                sprite.alpha = 1.0; // Always reset alpha for all bullets
                if (bullet.isLavaBlade && bulletTextures.lavaBlade) {
                    sprite.texture = bulletTextures.lavaBlade;
                    sprite.scale.set(1.2); // Smaller, sharper blades
                } else if (bullet.element === 'ice' && bulletTextures.ice) {
                    sprite.texture = bulletTextures.ice;
                    sprite.scale.set(1);
                    sprite.tint = 0xffffff;
                } else if (bullet.element === 'poison' && bulletTextures.poison) {
                    sprite.texture = bulletTextures.poison;
                    sprite.scale.set(1);
                    sprite.tint = 0xffffff;
                } else if (bullet.element === 'fire' && bulletTextures.fire) {
                    sprite.texture = bulletTextures.fire;
                    sprite.scale.set(1);
                    sprite.tint = 0xffffff;
                } else if (bullet.element === 'void' && bulletTextures.void) {
                    sprite.texture = bulletTextures.void;
                    sprite.scale.set(1);
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0.92;
                } else if (bulletTextures.normal) {
                    sprite.texture = bulletTextures.normal;
                    sprite.scale.set(1);
                    // Parse hex color properly
                    const colorStr = bullet.col.replace('#', '');
                    sprite.tint = parseInt(colorStr, 16);
                } else {
                    console.warn('âš ï¸ No texture available for bullet', bullet.element);
                    return null;
                }
                
                sprite.visible = true;
                sprite.anchor.set(0.5);
                activeBulletSprites.set(bullet, sprite);
                return sprite;
            }

            function releaseBulletSprite(bullet) {
                const sprite = activeBulletSprites.get(bullet);
                if (sprite) {
                    sprite.visible = false;
                    bulletSpritePool.push(sprite);
                    activeBulletSprites.delete(bullet);
                }
            }

            // Particle sprite pool functions
            function getParticleSprite(particle, element) {
                if (!particleContainer || !particleTexture) return null;
                
                let sprite = particleSpritePool.pop();
                if (!sprite) {
                    sprite = new PIXI.Sprite(particleTexture);
                    particleContainer.addChild(sprite);
                }
                
                sprite.anchor.set(0.5);
                sprite.visible = true;
                
                // Set tint based on type
                switch (element) {
                    case 'ice':
                        sprite.tint = 0xffffff;
                        break;
                    case 'poison':
                        sprite.tint = 0x64ff64;
                        break;
                    case 'fire':
                        sprite.tint = 0xff7a3a;
                        break;
                    case 'void':
                        sprite.tint = 0x8c66ff;
                        break;
                    default:
                        sprite.tint = 0xffffff;
                        break;
                }
                
                activeParticleSprites.set(particle, sprite);
                return sprite;
            }

            function releaseParticleSprite(particle) {
                const sprite = activeParticleSprites.get(particle);
                if (sprite) {
                    sprite.visible = false;
                    particleSpritePool.push(sprite);
                    activeParticleSprites.delete(particle);
                }
            }

            // Wait for PixiJS to initialize, then create textures
            setTimeout(() => {
                if (pixiApp && pixiApp.renderer) {
                    createBulletTextures();
                    createParticleTexture();
                }
            }, 100);
            
            // Global double-click prevention to avoid WebGL context loss
            let lastClickTime = 0;
            const MIN_CLICK_INTERVAL = 200; // ms between clicks
            
            document.addEventListener('click', (event) => {
                // Skip throttle for UI elements to prevent menu crash on double-click
                const target = event.target;
                const isUIElement = target.closest('.panel, button, .card, .shop-card, .upgrade-card, .forge-menu-btn, [role="button"]');
                
                if (isUIElement) {
                    return; // Let UI clicks through immediately
                }
                
                const now = performance.now();
                const timeSinceLastClick = now - lastClickTime;
                
                if (timeSinceLastClick < MIN_CLICK_INTERVAL) {
                    console.log(`âš ï¸ Rapid click blocked (${timeSinceLastClick.toFixed(0)}ms interval)`);
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    return false;
                }
                
                lastClickTime = now;
            }, true); // Use capture phase to catch early
            
            // Additional touch event protection for mobile
            let lastTouchTime = 0;
            document.addEventListener('touchstart', (event) => {
                const now = performance.now();
                const timeSinceLastTouch = now - lastTouchTime;
                
                if (timeSinceLastTouch < MIN_CLICK_INTERVAL) {
                    console.log(`âš ï¸ Rapid touch blocked (${timeSinceLastTouch.toFixed(0)}ms interval)`);
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
                
                lastTouchTime = now;
            }, { passive: false, capture: true });
            
            // ============================================================================

            const trackedPanelIds = [
                'shopPanel',
                'mechForgeMenuPanel',
                ...(CHAMPION_SYSTEM_ENABLED ? ['championDressingRoom'] : []),
                'characterSheetPanel',
                'subclassPanel'
            ];
            const panelStack = [];
            let currentPanelId = null;

            const panelRegistry = trackedPanelIds.reduce((acc, id) => {
                const element = q(id);
                if (element) {
                    const backBtn = element.querySelector('.panel-back-btn');
                    if (backBtn) {
                        backBtn.addEventListener('click', () => {
                            handlePanelBack(id);
                        });
                    }
                    acc[id] = { element, backBtn };
                }
                return acc;
            }, {});

            const updatePanelBackButtons = () => {
                trackedPanelIds.forEach(id => {
                    const entry = panelRegistry[id];
                    if (!entry || !entry.backBtn) return;
                    if (panelStack.length === 0 || currentPanelId !== id) {
                        entry.backBtn.classList.add('hide');
                    } else {
                        entry.backBtn.classList.remove('hide');
                    }
                });
            };

            const clearPanelStack = () => {
                panelStack.length = 0;
                currentPanelId = null;
                updatePanelBackButtons();
            };

            const enterPanel = (panelId, { allowDuplicatePush = false } = {}) => {
                if (!panelId) return;
                if (currentPanelId && currentPanelId !== panelId) {
                    const last = panelStack[panelStack.length - 1];
                    if (allowDuplicatePush || last !== currentPanelId) {
                        panelStack.push(currentPanelId);
                    }
                }
                currentPanelId = panelId;
                updatePanelBackButtons();
            };

            const exitPanel = (panelId) => {
                if (!panelId) return;
                if (currentPanelId === panelId) {
                    currentPanelId = null;
                }
                let idx = panelStack.lastIndexOf(panelId);
                while (idx !== -1) {
                    panelStack.splice(idx, 1);
                    idx = panelStack.lastIndexOf(panelId);
                }
                updatePanelBackButtons();
            };

            const runPanelResumeHooks = (panelId) => {
                switch (panelId) {
                    case 'shopPanel': {
                        const goldEl = q('shopgold');
                        if (goldEl && typeof getWorldGold === 'function') {
                            goldEl.textContent = getWorldGold();
                        }
                        if (typeof updateAutoForgeStatusLabel === 'function') {
                            updateAutoForgeStatusLabel();
                        }
                        break;
                    }
                    case 'mechForgeMenuPanel': {
                        if (typeof updateChampionQuickStatus === 'function') {
                            updateChampionQuickStatus();
                        }
                        break;
                    }
                    case 'championDressingRoom': {
                        if (typeof populateChampionBuilder === 'function') {
                            populateChampionBuilder();
                        }
                        if (typeof updateChampionPreview === 'function') {
                            updateChampionPreview();
                        }
                        if (typeof updateChampionStats === 'function') {
                            updateChampionStats();
                        }
                        if (typeof updateChampionBuilderDetails === 'function') {
                            updateChampionBuilderDetails();
                        }
                        if (typeof startChampionPreviewAnimation === 'function') {
                            startChampionPreviewAnimation();
                        }
                        break;
                    }
                    case 'characterSheetPanel': {
                        const body = q('characterSheetBody');
                        if (body && typeof renderCharacterSheet === 'function') {
                            renderCharacterSheet(body);
                        }
                        break;
                    }
                    default:
                        break;
                }
            };

            const handlePanelBack = (panelId) => {
                const entry = panelRegistry[panelId];
                if (!entry) return;

                const destination = panelStack.pop() || null;
                entry.element.classList.add('hide');

                exitPanel(panelId);

                if (destination && panelRegistry[destination]) {
                    const destEntry = panelRegistry[destination];
                    destEntry.element.classList.remove('hide');
                    currentPanelId = destination;
                    runPanelResumeHooks(destination);
                } else if (!destination) {
                    currentPanelId = null;
                    resumeGame();
                    return;
                }
                updatePanelBackButtons();
            };

            updatePanelBackButtons();

            // Simple resize handling without bounds caching
            window.addEventListener('resize', () => {
                resizeGameSurfaces();
                // Mark joystick bounds for update too
                if (typeof joystickState !== 'undefined') {
                    joystickState.boundsNeedUpdate = true;
                }
            }, { passive: true });

            const pointFromEvent = (e) => {
                const r = cvs.getBoundingClientRect();
                let touch = e;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    touch = e.changedTouches[0];
                } else if (e.touches && e.touches.length > 0) {
                    touch = e.touches[0];
                }
                const cx = touch.clientX;
                const cy = touch.clientY;
                return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
            };

            // --- MOBILE JOYSTICK & ABILITY BUTTON SETUP ---
            const joystick = {
                base: q('joystick-base'),
                stick: q('joystick-stick'),
                container: q('joystick-container'),
                abilityButton: q('ability-button'),
                abilityIcon: q('ability-icon')
            };

            const joystickState = {
                active: false,
                touchId: null,
                baseRect: null,
                input: { x: 0, y: 0 }, // Normalized vector for player movement
                cachedBaseRect: null,
                boundsNeedUpdate: true
            };

            // Mobile device detection
            function isMobileDevice() {
                return window.innerWidth <= 768 ||
                    'ontouchstart' in window ||
                    navigator.maxTouchPoints > 0 ||
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            function setupMobileControls() {
                // Only set up joystick if elements exist
                if (joystick.base) {
                    joystick.base.addEventListener('touchstart', handleJoystickStart, { passive: false });
                    document.addEventListener('touchmove', handleJoystickMove, { passive: false });
                    document.addEventListener('touchend', handleJoystickEnd, { passive: false });
                    document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
                }

                // Only set up ability button if it exists
                if (joystick.abilityButton) {
                    joystick.abilityButton.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        if (typeof handleAbilityPress === 'function') {
                            handleAbilityPress();
                        }
                    }, { passive: false });
                }

                // Load saved mobile controls preference
                try {
                    if (localStorage.getItem('mobileControlsEnabled') === 'true') {
                        document.body.classList.add('mobile-controls-active');
                    }
                } catch (e) {
                    // Ignore localStorage errors
                }
            }

            function handleJoystickStart(e) {
                e.preventDefault();
                if (joystickState.active) return;
                const touch = e.changedTouches[0];
                joystickState.active = true;
                joystickState.touchId = touch.identifier;

                // Cache joystick bounds to avoid layout calculations
                if (joystickState.boundsNeedUpdate || !joystickState.cachedBaseRect) {
                    joystickState.cachedBaseRect = joystick.base.getBoundingClientRect();
                    joystickState.boundsNeedUpdate = false;
                }
                joystickState.baseRect = joystickState.cachedBaseRect;

                handleJoystickMove(e); // Process initial position
            }

            function handleJoystickMove(e) {
                if (!joystickState.active) return;
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
                if (!touch) return;

                const baseCenterX = joystickState.baseRect.left + joystickState.baseRect.width / 2;
                const baseCenterY = joystickState.baseRect.top + joystickState.baseRect.height / 2;

                let dx = touch.clientX - baseCenterX;
                let dy = touch.clientY - baseCenterY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxDist = joystickState.baseRect.width / 4; // Stick can move 1/4 of the base width from center

                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }

                joystick.stick.style.transform = `translate(${dx}px, ${dy}px)`;
                joystickState.input.x = dx / maxDist;
                joystickState.input.y = dy / maxDist;
            }

            function handleJoystickEnd(e) {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
                if (!touch) return;

                joystickState.active = false;
                joystickState.touchId = null;
                joystick.stick.style.transform = `translate(0, 0)`;
                joystickState.input = { x: 0, y: 0 };
            }

            function handleAbilityPress() {
                if (store.isPaused || store.isGameOver) return;
                const p = store.player;

                switch (p.pilotGenome) {
                    case 'voidmancer':
                        // Blink in the direction of joystick input, or straight ahead if idle
                        const targetAngle = Math.atan2(joystickState.input.y, joystickState.input.x);
                        const targetDist = 200; // Blink distance
                        const target = {
                            x: p.x + (joystickState.input.x !== 0 ? Math.cos(targetAngle) * targetDist : 0),
                            y: p.y + (joystickState.input.y !== 0 ? Math.sin(targetAngle) * targetDist : p.y - targetDist)
                        };
                        tryVoidStep(p, target);
                        break;
                    case 'beef':
                        // Manually trigger the charge ability
                        p.isRequestingCharge = true; // A flag for the stepPlayer function
                        break;
                    default:
                        // EMP charges now auto-activate on proximity
                        break;
                }
            }

            function updateAbilityButtonIcon() {
                const p = store.player;
                let iconUrl = '';

                // Determine icon based on class and subclass
                switch (p.pilotGenome) {
                    case 'beef':
                        iconUrl = p.subclass === 'marauder' ? 'marauder.png' : 'jug2.png';
                        break;
                    case 'voidmancer':
                        iconUrl = p.subclass === 'phasestriker' ? 'phase.png' : 'storm.png';
                        break;
                    default:
                        iconUrl = 'storm4.png'; // Shield Pulse icon
                        break;
                }
                joystick.abilityIcon.style.backgroundImage = `url('${iconUrl}')`;
            }


            // --- FLAME PARTICLE CLASS ---
            class FlameParticle {
                constructor(x, y, attachedEnemy = null) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 40; // Horizontal spread
                    this.vy = -20 - Math.random() * 30; // Upward drift
                    this.life = 8.4 + Math.random() * 5.6; // 8.4-14 seconds
                    this.maxLife = this.life;
                    this.visualLife = this.life * 1.5; // Visual effect lasts 50% longer than mechanics
                    this.maxVisualLife = this.visualLife;
                    this.size = 8 + Math.random() * 8; // Varied sizes
                    this.attachedEnemy = attachedEnemy;
                    this.damage = 0.45;
                    this.wobble = Math.random() * Math.PI * 2;
                    this.wobbleSpeed = 0.5 + Math.random() * 1;
                    this.heat = 0.8 + Math.random() * 0.2; // Start hot
                    this.flickerOffset = Math.random() * 1000;
                    this.baseSize = this.size;
                    this.gravity = 15; // Slight downward pull
                    this.isDying = false;
                }

                update(dt) {
                    this.life -= dt;
                    this.visualLife -= dt;
                    if (this.visualLife <= 0) return false; // Remove particle when visual effect ends

                    // Standard fire physics
                    if (this.life > 0) {
                        this.vy += this.gravity * dt;
                        this.vy -= 25 * dt;
                        this.x += this.vx * dt;
                        this.y += this.vy * dt;

                        // Air resistance
                        this.vx *= 0.98;
                        this.vy *= 0.98;

                        // Wobble
                        this.wobble += this.wobbleSpeed * dt;
                        this.x += Math.sin(this.wobble) * 8 * dt;
                    }

                    // Heat and void effect - based on VISUAL life for slower fade
                    const visualLifeRatio = this.visualLife / this.maxVisualLife;
                    this.heat = Math.max(0.2, visualLifeRatio * 0.8); // Minimum heat to avoid pure transparency

                    // Size changes - based on visual life for slower shrinking
                    if (visualLifeRatio > 0.7) {
                        this.size = this.baseSize * (1 + (1 - visualLifeRatio) * 2); // Grow when young
                    } else {
                        this.size = Math.max(this.baseSize * 0.5, this.baseSize * visualLifeRatio); // Don't shrink below 50% of base
                    }

                    this.isDying = visualLifeRatio < 0.3;
                    return true;
                }

                draw() {
                    if (this.visualLife <= 0 || this.size <= 0) return;
                    if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;

                    const alpha = this.heat;

                    // Simple flame with just 3 circles - no crackling, no sparkles
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    // Outer glow - simple and clean
                    ctx.fillStyle = `rgba(255, 140, 20, ${alpha * 0.18})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 1.2, 0, 6.283185);
                    ctx.fill();

                    // Middle flame
                    ctx.fillStyle = `rgba(255, 100, 30, ${alpha * 0.38})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 0.7, 0, 6.283185);
                    ctx.fill();

                    // Core flame
                    ctx.fillStyle = `rgba(255, 215, 120, ${alpha * 0.55})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 0.3, 0, 6.283185);
                    ctx.fill();

                    ctx.restore(); // Reset blending mode
                }
            }

            // Simple particle creation function
            function createParticle(x, y, vx, vy, color, life) {
                return {
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: life,
                    maxLife: life,
                    color: color,
                    size: 1
                };
            }


            cvs.addEventListener('mousemove', (e) => {
                try {
                    const p = pointFromEvent(e);
                    mouse.x = p.x;
                    mouse.y = p.y;
                } catch (err) {
                    // Mouse move error silenced
                }
            }, { passive: true });
            cvs.addEventListener('touchstart', (e) => {
                try {
                    const p = pointFromEvent(e);
                    mouse.x = p.x;
                    mouse.y = p.y;
                    e.preventDefault();
                } catch (err) {
                    // Touch start error silenced
                }
            }, { passive: false });
            cvs.addEventListener('touchmove', (e) => {
                try {
                    const p = pointFromEvent(e);
                    mouse.x = p.x;
                    mouse.y = p.y;
                    e.preventDefault();
                } catch (err) {
                    // Touch move error silenced
                }
            }, { passive: false });

            // --- AUDIO ---
            const bgm = q('bgmAudio');
            const sounds = {
                explosion: q('audioExplosion'),
                horn: q('audioHorn'),
                hit: q('audioHit'),
                trap: q('audioTrap'),
                dogs: q('audioDogs'),
                charge: q('audioCharge'),
                beefCharge: q('audioBeefCharge'),
                epicHorn: q('audioEpicHorn'),
                cluster: q('audioCluster'),
                thunder: q('audioThunder'),
                shao_kahn: q('audioShaoKahn'),
                stargun: q('audioStarGun'),
                coin: q('audioCoin'),
                bloop: q('audioBloop'),
                voidpulse: q('audioVoidPulse'),
                icebreak1: q('audioIceBreak1'),
                icebreak2: q('audioIceBreak2'),
                power: q('audioPower'),
                lightningCrit: q('audioLightningCrit'),
                lightningPower: q('audioLightningPower'),
                lightningCrack: q('audioLightningCrack'),
                fireWhoosh: q('audioFireWhoosh'),
                sizzle: q('audioSizzle'),
                upgradePurchase: q('audioUpgradePurchase'),
                voidPulseAlt: q('audioVoidPulseAlt'),
                rocketHit: q('audioRocketHit'),
                coinPickup: q('audioCoinPickup'),
                poisonSplash: q('audioPoisonSplash'),
                snakeHiss: q('audioSnakeHiss'),
                bugSqueal: q('audioBugSqueal'),
                farExplosion: q('audioFarExplosion'),
                robotCrumble: q('audioRobotCrumble')
            };
            let lastExplosionSoundTime = 0;
            let lastBossHitSoundTime = 0;
            let lastClusterSoundTime = 0;
            let lastChampionThunderTime = 0;
            let iceBreakSoundIndex = 0; // 0 for icebreak1, 1 for icebreak2 - strict alternation
            let lastIceBreakTime = 0;
            let lastVoidPulseTime = 0;
            let lastPowerSoundTime = 0;
            let lastLightningCritTime = 0;
            let lastLightningCrackTime = 0;
            const powerSoundPlayedTargets = new Set(); // Track which enemies have had power sound played
            let consecutiveLightningHits = 0; // Track lightning chain hits for lightningCrack sound
            let consecutiveLightningCrits = 0; // Track crits on lightning hits for lightning crack detection
            let lastLightningHitTime = 0; // Track when last lightning hit occurred (reset after 0.8s gap)
            const SOUND_COOLDOWNS = {
                thunder: 1500,
                epicHorn: 2500,
                voidpulse: 2500, // Allow sound to fully play + pause - adjust if you shorten the sound file
                icebreak1: 1000, // One second cooldown for ice break sounds
                icebreak2: 1000,
                power: 2000, // Limit power sound to once every 2 seconds
                lightningCrit: 400, // Cooldown for lightning crit sound (adjusts based on hit upgrade)
                lightningPower: 1200, // Cooldown for lightning power upgrade sound
                lightningCrack: 2000 // Cooldown for huge multi-kill streak sound
            };
            const soundLastPlayTime = {};

            function playSound(name) {
                // Check if audio is muted
                if (store.settings.audioMuted) return;

                const audio = sounds[name];
                if (!audio) return;
                const now = performance.now();
                if (name === 'explosion') {
                    if (now - lastExplosionSoundTime < 50) return;
                    lastExplosionSoundTime = now;
                }
                if (name === 'cluster') {
                    if (now - lastClusterSoundTime < 150) return; // Increased from 60ms to 150ms
                    lastClusterSoundTime = now;
                }
                if (name === 'hit') {
                    if (now - lastBossHitSoundTime < 500) return; // Twice per second max
                    lastBossHitSoundTime = now;
                }
                const cooldown = SOUND_COOLDOWNS[name];
                if (cooldown) {
                    const lastTime = soundLastPlayTime[name] || 0;
                    if (now - lastTime < cooldown) return;
                    soundLastPlayTime[name] = now;
                }
                audio.currentTime = 0;
                audio.play().catch(e => { });
            }


            // --- GAME STATE & DATA ---
            const player_initial_state = {
                x: W / 2, y: H * 0.8, r: 14, hp: 80, hpMax: 100, fireT: 0, speed: 380, dmgMult: 1.2, fireRate: 0.16,
                vampirism: 0, shield: 25, shieldMax: 50, multishot: 2, maxMultishot: 2, isInvincible: false, piercing: 0, explosive: false,
                timeShardStacks: 0, timeShardTimer: 0, timeShardMultiplier: 1,
                hasShieldBubble: false, shieldBubbleCount: 0, powerupTimers: {},
                attackSpeedStacks: 0,
                hasRicochet: false,
                ricochetLevel: 0,
                upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0, launcher: 0, lazarus_beam: 0, gravity_well: 0, star_cannon: 0, fragment_blast: 0, ricochet: 0 },
                grenades: 0, knockbackShields: 0, hasVoidBeam: false, voidBeamCooldown: 0,
                hasLazarusBeam: false, lazarusBeamCooldown: 0,
                hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 1, vampirismLevel: 0, flamethrowerLevel: 0,
                flamethrowerT: 0, // Separate timer for lava blades, unaffected by overclock
                splitShotActive: false,
                splitShotSpread: 0.22,
                piercingPowerupActive: false,
                piercingPowerupBonus: 0,
                fragmentBlasters: [], // Auto-targeting shotgun blasts
                // Shield recharge delay system
                shieldRecharging: false,
                shieldRechargeDelay: 0,
                shieldRechargeDelayMax: 2.0,
                // Rocketman afterburner system
                afterburnerActive: false,
                afterburnerTimer: 0,
                afterburnerMaxDuration: 2.0,
                afterburnerParticleTimer: 0,
                starCannonLevel: 0, starCannonTimer: 0, starCannonIcemanSupport: false, starCannonNextSide: 'left',
                juggernautCloneActive: false,
                luckBoost: 0, luckQuality: 0, luckQuantity: 0, luckUpgradeCount: 0, magnetRadius: 0, hasIceman: false, icemanFireT: 0, hasBeefClone: false, critChance: 0, critDamage: 1.75,
                pilotGenome: null, missileVolley: 2,
                hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
                rearMultishot: 0, maxRearMultishot: 0, addFrontNext: true,
                flameWallCooldown: 0,
                flameWallCooldownMax: 10,
                flameWallCharge: 0,
                flameWallInitialized: false,
                flameWallActiveT: 0,
                beefChargeState: null, beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 0, beefMaxCharges: 0,
                beefChargePlan: null, beefChargeSegmentIndex: 0, beefImpactDelay: 0, beefLastImpact: null, beefQueuedCharge: null,
                beefDoubleCharge: false, beefBigExplosion: false, // New skill tree abilities
                beefChainMode: false, // Chain jumping system for marauder
                beefShield: 0, beefShieldMax: 0, beefShieldDamageDealt: 0, beefShieldDamageTaken: 0, beefShieldCooldown: 0,
                beefShieldTier: 0, beefShieldLastHpMax: 0, beefShieldLastTier: 0, beefShieldLastWave: 0,
                hasChainLightning: false, chainLightningCooldown: 0, stormstrikerLevel: 0, lightningAlternate: false, lightningCycleIndex: 0, chainLightningDamage: 1.0,
                phasestRikerLevel: 0, voidLaserRampTime: 0, voidLaserLastTarget: null,
                wiperLasers: false, wiperLaser1Angle: 0, wiperLaser2Angle: Math.PI, wiperLaserSpeed: 1.5, wiperLaserDamageTimer: 0,
                subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false,
                hasBlink: false, autoBlinkEnabled: false, autoBlinkRange: 0, autoBlinkLookahead: 0.45, autoBlinkLastTrigger: 0,
                isBlinkSlashing: false,
                enhancedClusters: false, enhancedPierce: false, hasStormbringer: false, hasPhasestriker: false,
                // Void caller enhanced options
                hasDoubleStorm: false, hasHybridVoid: false, hasImpactPhase: false,
                // Skill tree progress
                skillPoints: 0, skillPointsSpent: 0, skillTree: { juggernaut: false, marauder: false, double_charge: false, big_explosion: false, triple_charge: false },
                clusterSoundCounter: 0,
                geminiHitSlowTimer: 0,
                geminiHitSlowStrength: 1,
                vibeThreadSlowTimer: 0,
                vibeThreadSlowStrength: 1,
                // EMP nova effects
                empDisabled: false, empDisabledTimer: 0,
                championUnlocked: false,
                championUpgrades: {
                    attackModule: 'default',
                    unlockedAttacks: {
                        // Legacy modules (for backwards compatibility)
                        ember: false, tempest: false, void: false,
                        // New attack modules - some available for testing
                        precision_strike: true, kinetic_swarm: true,
                        inferno_burst: true, plasma_stream: true,
                        focus_beam: false, scatter_array: false,
                        arc_cannon: true, storm_grid: false
                    },
                    cadenceLevel: 0,
                    minionProtocols: 0,
                    skin: 'default',
                    unlockedSkins: { default: true }
                },
                // Bullet element system (ice/poison/fire toggles)
                hasIceBullets: false,
                hasPoisonBullets: false,
                hasFireBullets: false,
                bulletElementToggles: { ice: false, poison: false, fire: false },
                bulletElementCycleIndex: 0
            };

            class Pool {
                constructor(createFn, resetFn) {
                    this.createFn = createFn;
                    this.resetFn = resetFn;
                    this.available = [];
                }

                prefill(count) {
                    for (let i = 0; i < count; i++) {
                        this.available.push(this.createFn());
                    }
                }

                get() {
                    const item = this.available.pop() || this.createFn();
                    if (this.resetFn) this.resetFn(item);
                    return item;
                }

                release(item) {
                    if (this.resetFn) this.resetFn(item);
                    this.available.push(item);
                }
            }

            function resetBulletState(bullet) {
                bullet.x = 0;
                bullet.y = 0;
                bullet.vx = 0;
                bullet.vy = 0;
                bullet.r = 3;
                bullet.col = "#b266ff";
                bullet.dmg = 0;
                bullet.pierce = 0;
                bullet.explosive = false;
                bullet.dead = false;
                bullet.life = undefined;
                bullet.fadeInTime = undefined;
                bullet.spawnTime = undefined;
                bullet.isSwirl = false;
                bullet.isFlame = false;
                bullet.isIceman = false;
                bullet.isDrone = false;
                bullet.isLavaBlade = false;
                bullet.isLevelUpPulse = false;
                bullet.hasRicocheted = false;
                bullet.ricochetDist = 0;
                bullet.maxRicochetDist = 0;
                bullet.originalDmg = undefined;
                bullet.gravity = undefined;
                bullet.target = undefined;
                bullet.particles = null;
                bullet.particleSpawnT = 0;
                bullet.skipSplit = false;
                if (bullet.piercedIds) {
                    bullet.piercedIds.clear();
                } else {
                    bullet.piercedIds = new Set();
                }
            }

            function createBullet() {
                const bullet = {};
                resetBulletState(bullet);
                return bullet;
            }

            const bulletPool = new Pool(createBullet, resetBulletState);
            bulletPool.prefill(100);

            const CORE_ELEMENT_KEYS = ['ice', 'poison', 'fire'];

            function ensureBulletElementState(player) {
                if (!player) return;
                if (!player.bulletElementToggles) {
                    player.bulletElementToggles = { ice: false, poison: false, fire: false };
                } else {
                    const toggles = player.bulletElementToggles;
                    if (typeof toggles.ice !== 'boolean') toggles.ice = !!toggles.ice;
                    if (typeof toggles.poison !== 'boolean') toggles.poison = !!toggles.poison;
                    if (typeof toggles.fire !== 'boolean') toggles.fire = !!toggles.fire;
                }
                if (!Number.isFinite(player.bulletElementCycleIndex)) {
                    player.bulletElementCycleIndex = 0;
                }
            }

            function getUnlockedBulletElements(player) {
                if (!player) return [];
                ensureBulletElementState(player);
                const unlocked = [];
                if (player.hasIceBullets) unlocked.push('ice');
                if (player.hasPoisonBullets) unlocked.push('poison');
                if (player.hasFireBullets) unlocked.push('fire');
                return unlocked;
            }

            function getActiveBulletElements(player) {
                if (!player) return [];
                ensureBulletElementState(player);
                const toggles = player.bulletElementToggles;
                return getUnlockedBulletElements(player).filter(element => !!toggles[element]);
            }

            function setBulletElementToggle(player, element, enabled) {
                if (!player) return;
                ensureBulletElementState(player);
                const unlocked = getUnlockedBulletElements(player);
                if (!unlocked.includes(element)) return;
                const toggles = player.bulletElementToggles;
                const next = !!enabled;
                if (toggles[element] === next) return;
                toggles[element] = next;
                resetBulletElementCycle(player);
            }

            function toggleBulletElement(player, element) {
                if (!player) return;
                ensureBulletElementState(player);
                const unlocked = getUnlockedBulletElements(player);
                if (!unlocked.includes(element)) return;
                player.bulletElementToggles[element] = !player.bulletElementToggles[element];
                resetBulletElementCycle(player);
            }

            function resetBulletElementCycle(player) {
                if (!player) return;
                player.bulletElementCycleIndex = 0;
            }

            function activateBulletElementIfNone(player, element) {
                if (!player) return;
                ensureBulletElementState(player);
                const toggles = player.bulletElementToggles;
                if (!toggles.ice && !toggles.poison && !toggles.fire) {
                    setBulletElementToggle(player, element, true);
                }
            }

            const STAR_CANNON_BASE_COOLDOWN = 7;
            const STAR_CANNON_MIN_COOLDOWN = 1.4;
            const STAR_CANNON_LEVEL_CAP = 16;
            const STAR_CANNON_ALTERNATE_DELAY = 0.22;
            const STAR_CANNON_SPEED = 420;
            const STAR_CANNON_DAMAGE = 220;
            const STAR_CANNON_SIZE = 20;
            const STAR_CANNON_HITBOX_SCALE = 1.0;
            const STAR_CANNON_CLONE_DELAY = 0.35;
            const STAR_CANNON_ICEMAN_DAMAGE_SCALE = 0.3;
            const STAR_CANNON_MINI_DAMAGE_SCALE = 0.18;
            const STAR_CANNON_MINI_SIZE_SCALE = 0.68;
            const STAR_CANNON_MINI_SPEED_SCALE = 0.92;
            const STAR_CANNON_MINI_CLONE_DELAY = 0.44;
            const STAR_CANNON_MINI_STAGGER = 0.08;

            const STAR_VARIANT_PALETTES = {
                player: {
                    trailFillBase: 'rgba(255, 255, 200, ',
                    trailShadowBase: 'rgba(255, 240, 150, ',
                    primaryFill: 'rgba(255, 255, 140, 0.85)',
                    shadowFill: 'rgba(255, 220, 120, 0.9)',
                    coreFill: '#fffbe6'
                },
                'iceman-main': {
                    trailFillBase: 'rgba(190, 225, 255, ',
                    trailShadowBase: 'rgba(140, 200, 255, ',
                    primaryFill: 'rgba(180, 215, 255, 0.85)',
                    shadowFill: 'rgba(140, 200, 255, 0.9)',
                    coreFill: '#eef7ff'
                },
                'iceman-mini': {
                    trailFillBase: 'rgba(205, 235, 255, ',
                    trailShadowBase: 'rgba(155, 210, 255, ',
                    primaryFill: 'rgba(200, 230, 255, 0.78)',
                    shadowFill: 'rgba(150, 205, 255, 0.85)',
                    coreFill: '#f6fbff'
                },
                enemy: {
                    trailFillBase: 'rgba(150, 160, 220, ',
                    trailShadowBase: 'rgba(80, 90, 160, ',
                    primaryFill: 'rgba(200, 205, 255, 0.82)',
                    shadowFill: 'rgba(70, 80, 160, 0.9)',
                    coreFill: '#c8ccff'
                }
            };

            const BEEF_SHIELD_TIERS = Object.freeze({
                1: { ratio: 1.5, min: 150, regenRate: 8, regenDelay: 3 },
                2: { ratio: 1.7, min: 220, regenRate: 10, regenDelay: 2.5 },
                3: { ratio: 1.9, min: 260, regenRate: 15, regenDelay: 2.0, reflect: true }
            });

            function getStarCannonCooldown(level) {
                if (!level || level <= 0) {
                    return STAR_CANNON_BASE_COOLDOWN;
                }
                const clampedLevel = clamp(level, 1, STAR_CANNON_LEVEL_CAP);
                const reductionPerLevel = (STAR_CANNON_BASE_COOLDOWN - STAR_CANNON_MIN_COOLDOWN) / (STAR_CANNON_LEVEL_CAP - 1);
                const cooldown = STAR_CANNON_BASE_COOLDOWN - reductionPerLevel * (clampedLevel - 1);
                return Math.max(STAR_CANNON_MIN_COOLDOWN, cooldown);
            }

            function getStarCannonBurstCount(level) {
                if (!level || level <= 0) return 0;
                const clamped = clamp(level, 1, STAR_CANNON_LEVEL_CAP);
                const base = clamped >= 2 ? 2 : 1;
                const extra = Math.floor(Math.max(0, clamped - 3) / 2);
                return Math.min(base + extra, 6);
            }

            const initialTelemetryEnabled = (() => {
                try {
                    return !!(window.localStorage && window.localStorage.getItem('voidTelemetry') === '1');
                } catch (err) {
                    return false;
                }
            })();

            const storedAutoForgeEnabled = (() => {
                try {
                    if (!window.localStorage) return true;
                    const value = window.localStorage.getItem('voidAutoForge');
                    if (value === null) return true;
                    const normalized = value.toLowerCase();
                    if (normalized === 'off' || normalized === '0' || normalized === 'false') return false;
                    if (normalized === 'on' || normalized === '1' || normalized === 'true') return true;
                    return true;
                } catch (err) {
                    return true;
                }
            })();

            const storedShopTutorialEnabled = (() => {
                try {
                    if (!window.localStorage) return true;
                    const value = window.localStorage.getItem('voidShopTutorial');
                    if (value === null) return true;
                    const normalized = value.toLowerCase();
                    if (normalized === 'off' || normalized === '0' || normalized === 'false') return false;
                    if (normalized === 'on' || normalized === '1' || normalized === 'true') return true;
                    return true;
                } catch (err) {
                    return true;
                }
            })();

            const AUTO_FORGE_DEFAULT_PROFILE_ID = 'baseline_directive';

            const rawAutoForgeProfiles = [
                {
                    id: 'baseline_directive',
                    label: 'Baseline Directive',
                    summary: 'Balanced logistics that rotates through heavy ordnance and sustain.',
                    statusLine: 'Balanced procurement across weapons and hull sustain.',
                    groups: [
                        { keys: ['gravity_well', 'star_cannon', 'ghost_hounds', 'lazarus_beam', 'launcher', 'iceman'], sort: 'cost-desc', isFun: true },
                        { keys: ['nano_save', 'max_shield', 'hp', 'vampirism'], sort: 'cost-desc' },
                        { keys: ['speed', 'luck_boost'], sort: 'cost-asc' }
                    ],
                    fallback: ['dmg', 'crit_chance', 'repair'],
                    repairThreshold: 0.82
                },
                {
                    id: 'void_savant',
                    label: 'Void Savant',
                    summary: 'Singularity tactician favouring beams, speed, and layered shields.',
                    statusLine: 'Prioritizes Gravity Well, Lazarus protocols, and shield fortification.',
                    groups: [
                        { keys: ['gravity_well', 'lazarus_beam'], sort: 'cost-desc', isFun: true },
                        { keys: ['speed', 'magnet_pull'], sort: 'cost-desc' },
                        { keys: ['max_shield', 'rear_guard', 'nano_save'], sort: 'cost-desc' }
                    ],
                    fallback: ['hp', 'vampirism', 'luck_boost'],
                    repairThreshold: 0.78
                },
                {
                    id: 'starcaller',
                    label: 'Starcaller',
                    summary: 'Amplifies orbital cannons while stacking lifesteal and fortune.',
                    statusLine: 'Channels Star Cannon calibrations with vampiric sustain.',
                    groups: [
                        { keys: ['star_cannon'], sort: 'cost-desc', isFun: true },
                        { keys: ['vampirism', 'hp'], sort: 'cost-desc' },
                        { keys: ['luck_boost', 'max_shield', 'nano_save'], sort: 'cost-desc' }
                    ],
                    fallback: ['speed', 'repair', 'dmg'],
                    repairThreshold: 0.76
                },
                {
                    id: 'fleet_admiral',
                    label: 'Fleet Admiral',
                    summary: 'Directs companion cadres and champion support systems.',
                    statusLine: 'Funds hounds, iceman, and champion modules when available.',
                    groups: [
                        { keys: ['ghost_hounds', 'iceman'], sort: 'cost-desc', isFun: true },
                        { keys: ['champion_attack_module', 'champion_cadence', 'champion_protocol'], sort: 'cost-desc', includeRestricted: true },
                        { keys: ['rear_guard', 'nano_save', 'max_shield'], sort: 'cost-desc' }
                    ],
                    fallback: ['hp', 'speed', 'repair'],
                    repairThreshold: 0.8
                },
                {
                    id: 'aegis_warden',
                    label: 'Aegis Warden',
                    summary: 'Fortifies hull integrity and keeps emergency reserves primed.',
                    statusLine: 'Stacks shields, nanosaves, and defensive redundancies.',
                    groups: [
                        { keys: ['max_shield', 'nano_save'], sort: 'cost-desc' },
                        { keys: ['rear_guard', 'hp'], sort: 'cost-desc' },
                        { keys: ['repair', 'magnet_pull'], sort: 'cost-asc' }
                    ],
                    fallback: ['vampirism', 'luck_boost', 'speed'],
                    repairThreshold: 0.9
                },
                {
                    id: 'blitz_vanguard',
                    label: 'Blitz Vanguard',
                    summary: 'Rushdown doctrine emphasising damage spikes and crowd clear.',
                    statusLine: 'Invests in raw damage, crit chains, and explosive salvos.',
                    groups: [
                        { keys: ['dmg', 'crit_chance'], sort: 'cost-desc', isFun: true },
                        { keys: ['speed', 'launcher'], sort: 'cost-desc', isFun: true },
                        { keys: ['grenade', 'knockback_shield', 'star_cannon'], sort: 'cost-desc', isFun: true }
                    ],
                    fallback: ['hp', 'repair', 'max_shield'],
                    repairThreshold: 0.74
                },
                {
                    id: 'arc_technician',
                    label: 'Arc Technician',
                    summary: 'Optimises utility grids, resource pulls, and survivability buffers.',
                    statusLine: 'Focuses on magnetics, luck matrices, and nanosaves.',
                    groups: [
                        { keys: ['magnet_pull', 'luck_boost'], sort: 'cost-desc' },
                        { keys: ['speed', 'nano_save'], sort: 'cost-desc' },
                        { keys: ['rear_guard', 'vampirism'], sort: 'cost-desc' }
                    ],
                    fallback: ['hp', 'max_shield', 'dmg'],
                    repairThreshold: 0.82
                },
                {
                    id: 'stormrunner',
                    label: 'Stormrunner',
                    summary: 'Keeps velocity high while topping off shields and ordnance.',
                    statusLine: 'Funds speed, shield loops, and opportunistic explosives.',
                    groups: [
                        { keys: ['speed', 'magnet_pull'], sort: 'cost-desc' },
                        { keys: ['max_shield', 'nano_save'], sort: 'cost-desc' },
                        { keys: ['grenade', 'knockback_shield', 'dmg'], sort: 'cost-desc', isFun: true }
                    ],
                    fallback: ['hp', 'repair', 'luck_boost'],
                    repairThreshold: 0.8
                }
            ];

            function normalizeAutoForgeProfile(profile) {
                const groups = Array.isArray(profile.groups) ? profile.groups.map(group => Object.freeze({
                    ...group,
                    keys: Object.freeze([...(group.keys || [])])
                })) : [];
                return Object.freeze({
                    ...profile,
                    groups: Object.freeze(groups),
                    fallback: Object.freeze([...(profile.fallback || [])])
                });
            }

            const AUTO_FORGE_PROFILES = Object.freeze(rawAutoForgeProfiles.map(normalizeAutoForgeProfile));
            const AUTO_FORGE_PROFILE_MAP = (() => {
                const map = new Map();
                for (const profile of AUTO_FORGE_PROFILES) {
                    map.set(profile.id, profile);
                }
                return map;
            })();

            function resolveAutoForgeProfileId(candidate) {
                if (candidate && AUTO_FORGE_PROFILE_MAP.has(candidate)) {
                    return candidate;
                }
                return AUTO_FORGE_DEFAULT_PROFILE_ID;
            }

            const storedAutoForgeProfileRaw = (() => {
                try {
                    if (!window.localStorage) return null;
                    return window.localStorage.getItem('voidAutoForgeProfile');
                } catch (err) {
                    return null;
                }
            })();

            const initialAutoForgeProfileId = resolveAutoForgeProfileId(storedAutoForgeProfileRaw);

            const RAW_BOSS_DEFINITIONS = Object.freeze({
                vibemaster: {
                    name: 'VIBEMASTER',
                    baseHp: 4800,
                    r: 62,
                    behavior: 'vibemaster',
                    color: '#c77bff'
                },
                void_sentinel: {
                    name: 'VOID SENTINEL',
                    baseHp: 4000,
                    r: 55,
                    behavior: 'sentinel',
                    color: '#8B4A9C'
                },
                trap_god: {
                    name: 'TRAPEZOID GOD',
                    baseHp: 2200,
                    r: 50,
                    behavior: 'hex',
                    color: '#66aaff'
                },
                aegis_architect: {
                    name: 'AEGIS ARCHITECT',
                    baseHp: 2650,
                    r: 68,
                    behavior: 'aegis_architect',
                    color: '#5dd0ff'
                },
                hive_sovereign: {
                    name: 'HIVE SOVEREIGN',
                    baseHp: 8500,
                    r: 85,
                    behavior: 'broodlord',
                    color: '#2d5016'
                },
                shadow_mirror: {
                    name: 'SHADOW MIRROR',
                    baseHp: 9600,
                    r: 58,
                    behavior: 'shadow_clone',
                    color: '#cbd4ff'
                },
                death_engine: {
                    name: 'DEATH ENGINE',
                    baseHp: 9000,
                    r: 90,
                    behavior: 'construct',
                    color: '#e54d24',
                    phase: 1,
                    isLaughing: false,
                    laughStartTime: 0,
                    visible: true
                },
                sol_luna: {
                    name: 'SOL & LUNA',
                    baseHp: 8800,
                    r: 60,
                    behavior: 'gemini',
                    color: '#ff9f3b'
                },
                asynchronos: {
                    name: 'ASYNCHRONOS',
                    baseHp: 7800,
                    r: 62,
                    behavior: 'asynchronos',
                    color: '#6ff2ff'
                }
            });

            const BOSS_ROTATION = Object.freeze([
                'void_sentinel',
                'trap_god',
                'aegis_architect',
                'hive_sovereign',
                'shadow_mirror',
                'vibemaster',
                'death_engine',
                'sol_luna',
                'asynchronos'
            ]);

            const BOSS_DEFINITIONS = Object.freeze(BOSS_ROTATION.map(key => {
                const def = RAW_BOSS_DEFINITIONS[key];
                if (!def) {
                    console.warn(`[BossConfig] Missing definition for boss "${key}".`);
                    return Object.freeze({ key, name: key.toUpperCase(), baseHp: 3200, r: 55, behavior: 'sentinel', color: '#ffffff' });
                }
                return Object.freeze({ key, ...def });
            }));

            const BOSS_DEFINITION_MAP = (() => {
                const map = new Map();
                BOSS_DEFINITIONS.forEach(def => map.set(def.key, def));
                return map;
            })();

            const BOSS_THEME_MAP = Object.freeze({
                'VIBEMASTER': 'vibemaster',
                'VOID SENTINEL': 'void_sentinel',
                'TRAPEZOID GOD': 'trap_god',
                'AEGIS ARCHITECT': 'aegis_architect',
                'HIVE SOVEREIGN': 'hive_sovereign',
                'SHADOW MIRROR': 'shadow_mirror',
                'DEATH ENGINE': 'death_engine',
                'SOL & LUNA': 'sol_luna',
                'ASYNCHRONOS': 'asynchronos'
            });

            const DEFAULT_MAP_THEME_KEY = 'void_sentinel';

            const MAP_THEME_DEFS = Object.freeze({
                vibemaster: {
                    key: 'vibemaster',
                    label: 'Cosmic Loom',
                    baseFill: '#0e0518',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.42, radius: 0.96, stops: [
                            { offset: 0, color: 'rgba(180, 80, 255, 0.75)' },
                            { offset: 0.55, color: 'rgba(40, 12, 80, 0.7)' },
                            { offset: 1, color: 'rgba(6, 3, 18, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 140, speed: 24, color: 'rgba(245, 205, 255, 0.78)', pulseColor: 'rgba(190, 120, 255, 0.92)', minRadius: 0.25, maxRadius: 1.5, twinkleSpeed: 2.1, twinkleAmplitude: 0.55 },
                        { count: 90, speed: 46, color: 'rgba(120, 220, 255, 0.55)', pulseColor: 'rgba(90, 185, 255, 0.85)', minRadius: 0.22, maxRadius: 1.9, twinkleSpeed: 1.6, twinkleAmplitude: 0.48 }
                    ],
                    auroraBands: [
                        { y: 0.28, thickness: 0.18, alpha: 0.38, waveSpeed: 0.42, waveAmplitude: 0.16, rotation: -0.12, colorStops: ['rgba(120, 40, 200, 0)', 'rgba(200, 120, 255, 0.58)', 'rgba(20, 4, 60, 0)'] },
                        { y: 0.58, thickness: 0.2, alpha: 0.32, waveSpeed: 0.36, waveAmplitude: 0.14, rotation: 0.18, colorStops: ['rgba(20, 140, 190, 0)', 'rgba(120, 240, 255, 0.52)', 'rgba(6, 30, 50, 0)'] }
                    ]
                },
                void_sentinel: {
                    key: 'void_sentinel',
                    label: 'Sentinel Breach',
                    baseFill: '#050008',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.38, radius: 0.95, stops: [
                            { offset: 0, color: 'rgba(120, 0, 160, 0.9)' },
                            { offset: 0.45, color: 'rgba(35, 0, 90, 0.55)' },
                            { offset: 1, color: 'rgba(4, 0, 12, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 120, speed: 26, color: 'rgba(255, 160, 255, 0.75)', pulseColor: 'rgba(255, 225, 255, 0.95)', minRadius: 0.35, maxRadius: 1.4, twinkleSpeed: 2.1, twinkleAmplitude: 0.55 },
                        { count: 80, speed: 52, color: 'rgba(140, 60, 220, 0.6)', pulseColor: 'rgba(225, 140, 255, 0.85)', minRadius: 0.2, maxRadius: 1.9, twinkleSpeed: 1.4, twinkleAmplitude: 0.45 }
                    ],
                    auroraBands: [
                        { y: 0.22, thickness: 0.14, alpha: 0.42, waveSpeed: 0.32, waveAmplitude: 0.12, rotation: 0.14, colorStops: ['rgba(60, 0, 120, 0)', 'rgba(240, 160, 255, 0.55)', 'rgba(10, 0, 30, 0)'] }
                    ]
                },
                trap_god: {
                    key: 'trap_god',
                    label: 'Phantom Glacial Drift',
                    baseFill: '#031024',
                    gradient: {
                        type: 'radial', x: 0.48, y: 0.33, radius: 0.92, stops: [
                            { offset: 0, color: 'rgba(20, 80, 180, 0.8)' },
                            { offset: 0.6, color: 'rgba(5, 18, 50, 0.7)' },
                            { offset: 1, color: 'rgba(3, 10, 28, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 140, speed: 20, color: 'rgba(140, 200, 255, 0.75)', pulseColor: 'rgba(210, 235, 255, 0.95)', minRadius: 0.3, maxRadius: 1.3, twinkleSpeed: 1.6, twinkleAmplitude: 0.5 },
                        { count: 70, speed: 38, color: 'rgba(80, 180, 255, 0.55)', pulseColor: 'rgba(120, 220, 255, 0.8)', minRadius: 0.25, maxRadius: 1.7, twinkleSpeed: 1.1, twinkleAmplitude: 0.4 }
                    ],
                    auroraBands: [
                        { y: 0.68, thickness: 0.18, alpha: 0.36, waveSpeed: 0.24, waveAmplitude: 0.16, rotation: -0.18, colorStops: ['rgba(0, 40, 120, 0)', 'rgba(50, 180, 255, 0.55)', 'rgba(0, 18, 60, 0)'] }
                    ]
                },
                aegis_architect: {
                    key: 'aegis_architect',
                    label: 'Aegis Vault Nexus',
                    baseFill: '#04111c',
                    gradient: {
                        type: 'radial', x: 0.48, y: 0.42, radius: 0.92, stops: [
                            { offset: 0, color: 'rgba(30, 180, 255, 0.78)' },
                            { offset: 0.5, color: 'rgba(10, 70, 120, 0.7)' },
                            { offset: 1, color: 'rgba(4, 12, 20, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 130, speed: 26, color: 'rgba(120, 220, 255, 0.75)', pulseColor: 'rgba(200, 240, 255, 0.95)', minRadius: 0.3, maxRadius: 1.4, twinkleSpeed: 1.9, twinkleAmplitude: 0.52 },
                        { count: 75, speed: 48, color: 'rgba(90, 180, 255, 0.6)', pulseColor: 'rgba(140, 210, 255, 0.85)', minRadius: 0.25, maxRadius: 1.85, twinkleSpeed: 1.3, twinkleAmplitude: 0.44 }
                    ],
                    auroraBands: [
                        { y: 0.46, thickness: 0.2, alpha: 0.34, waveSpeed: 0.38, waveAmplitude: 0.14, rotation: 0.12, colorStops: ['rgba(20, 120, 200, 0)', 'rgba(80, 200, 255, 0.55)', 'rgba(6, 28, 48, 0)'] }
                    ]
                },
                hive_sovereign: {
                    key: 'hive_sovereign',
                    label: 'Hive Nebular Bloom',
                    baseFill: '#1b0d04',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.45, radius: 0.94, stops: [
                            { offset: 0, color: 'rgba(150, 90, 10, 0.8)' },
                            { offset: 0.5, color: 'rgba(50, 20, 4, 0.75)' },
                            { offset: 1, color: 'rgba(14, 6, 2, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 130, speed: 22, color: 'rgba(255, 200, 120, 0.7)', pulseColor: 'rgba(255, 240, 180, 0.92)', minRadius: 0.3, maxRadius: 1.4, twinkleSpeed: 1.7, twinkleAmplitude: 0.55 },
                        { count: 65, speed: 36, color: 'rgba(220, 130, 40, 0.6)', pulseColor: 'rgba(255, 180, 80, 0.85)', minRadius: 0.25, maxRadius: 1.9, twinkleSpeed: 1.3, twinkleAmplitude: 0.4 }
                    ],
                    auroraBands: [
                        { y: 0.3, thickness: 0.22, alpha: 0.34, waveSpeed: 0.28, waveAmplitude: 0.14, rotation: -0.06, colorStops: ['rgba(120, 50, 10, 0)', 'rgba(255, 170, 60, 0.55)', 'rgba(40, 12, 3, 0)'] }
                    ]
                },
                shadow_mirror: {
                    key: 'shadow_mirror',
                    label: 'Shadow Cascade',
                    baseFill: '#04081a',
                    gradient: {
                        type: 'radial', x: 0.52, y: 0.3, radius: 0.88, stops: [
                            { offset: 0, color: 'rgba(60, 0, 140, 0.8)' },
                            { offset: 0.55, color: 'rgba(15, 10, 45, 0.75)' },
                            { offset: 1, color: 'rgba(4, 8, 20, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 150, speed: 28, color: 'rgba(180, 190, 255, 0.75)', pulseColor: 'rgba(230, 235, 255, 0.95)', minRadius: 0.3, maxRadius: 1.25, twinkleSpeed: 2.4, twinkleAmplitude: 0.6 },
                        { count: 80, speed: 50, color: 'rgba(80, 120, 255, 0.6)', pulseColor: 'rgba(160, 180, 255, 0.85)', minRadius: 0.25, maxRadius: 1.75, twinkleSpeed: 1.5, twinkleAmplitude: 0.5 }
                    ],
                    auroraBands: [
                        { y: 0.58, thickness: 0.18, alpha: 0.4, waveSpeed: 0.42, waveAmplitude: 0.18, rotation: 0.18, colorStops: ['rgba(10, 40, 160, 0)', 'rgba(120, 160, 255, 0.6)', 'rgba(4, 14, 40, 0)'] }
                    ]
                },
                death_engine: {
                    key: 'death_engine',
                    label: 'Death Engine Crucible',
                    baseFill: '#120202',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.4, radius: 0.96, stops: [
                            { offset: 0, color: 'rgba(190, 40, 0, 0.85)' },
                            { offset: 0.5, color: 'rgba(80, 10, 0, 0.75)' },
                            { offset: 1, color: 'rgba(18, 2, 2, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 125, speed: 30, color: 'rgba(255, 160, 120, 0.72)', pulseColor: 'rgba(255, 210, 160, 0.95)', minRadius: 0.32, maxRadius: 1.4, twinkleSpeed: 2.0, twinkleAmplitude: 0.58 },
                        { count: 85, speed: 58, color: 'rgba(220, 80, 20, 0.62)', pulseColor: 'rgba(255, 140, 60, 0.86)', minRadius: 0.24, maxRadius: 2.0, twinkleSpeed: 1.4, twinkleAmplitude: 0.5 }
                    ],
                    auroraBands: [
                        { y: 0.4, thickness: 0.26, alpha: 0.38, waveSpeed: 0.5, waveAmplitude: 0.2, rotation: -0.12, colorStops: ['rgba(120, 20, 0, 0)', 'rgba(255, 140, 60, 0.6)', 'rgba(40, 6, 2, 0)'] }
                    ]
                },
                sol_luna: {
                    key: 'sol_luna',
                    label: 'Gemini Ballroom',
                    baseFill: '#0c0616',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.38, radius: 0.95, stops: [
                            { offset: 0, color: 'rgba(255, 160, 80, 0.82)' },
                            { offset: 0.4, color: 'rgba(80, 140, 255, 0.65)' },
                            { offset: 1, color: 'rgba(10, 8, 24, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 140, speed: 24, color: 'rgba(255, 200, 120, 0.7)', pulseColor: 'rgba(255, 240, 200, 0.95)', minRadius: 0.28, maxRadius: 1.4, twinkleSpeed: 1.8, twinkleAmplitude: 0.5 },
                        { count: 110, speed: 38, color: 'rgba(120, 200, 255, 0.65)', pulseColor: 'rgba(180, 235, 255, 0.92)', minRadius: 0.24, maxRadius: 1.8, twinkleSpeed: 1.4, twinkleAmplitude: 0.45 }
                    ],
                    auroraBands: [
                        { y: 0.3, thickness: 0.2, alpha: 0.36, waveSpeed: 0.34, waveAmplitude: 0.12, rotation: -0.1, colorStops: ['rgba(255, 160, 80, 0)', 'rgba(255, 200, 120, 0.6)', 'rgba(60, 30, 10, 0)'] },
                        { y: 0.62, thickness: 0.22, alpha: 0.33, waveSpeed: 0.4, waveAmplitude: 0.18, rotation: 0.16, colorStops: ['rgba(40, 140, 255, 0)', 'rgba(120, 210, 255, 0.55)', 'rgba(12, 30, 80, 0)'] }
                    ]
                },
                asynchronos: {
                    key: 'asynchronos',
                    label: 'Chronoshift Expanse',
                    baseFill: '#04030a',
                    gradient: {
                        type: 'radial', x: 0.5, y: 0.36, radius: 0.94, stops: [
                            { offset: 0, color: 'rgba(90, 240, 255, 0.82)' },
                            { offset: 0.48, color: 'rgba(32, 60, 160, 0.7)' },
                            { offset: 1, color: 'rgba(8, 10, 26, 1)' }
                        ]
                    },
                    starLayers: [
                        { count: 140, speed: 24, color: 'rgba(160, 255, 245, 0.75)', pulseColor: 'rgba(220, 255, 250, 0.95)', minRadius: 0.28, maxRadius: 1.3, twinkleSpeed: 2.1, twinkleAmplitude: 0.48 },
                        { count: 90, speed: 46, color: 'rgba(110, 180, 255, 0.6)', pulseColor: 'rgba(180, 220, 255, 0.86)', minRadius: 0.24, maxRadius: 1.8, twinkleSpeed: 1.5, twinkleAmplitude: 0.42 }
                    ],
                    auroraBands: [
                        { y: 0.28, thickness: 0.18, alpha: 0.36, waveSpeed: 0.36, waveAmplitude: 0.16, rotation: -0.14, colorStops: ['rgba(20, 200, 255, 0)', 'rgba(150, 240, 255, 0.55)', 'rgba(10, 30, 80, 0)'] },
                        { y: 0.64, thickness: 0.2, alpha: 0.28, waveSpeed: 0.42, waveAmplitude: 0.2, rotation: 0.18, colorStops: ['rgba(140, 100, 255, 0)', 'rgba(220, 180, 255, 0.5)', 'rgba(30, 0, 70, 0)'] }
                    ]
                }
            });

            // Enemy density tuning constants - must be defined before store initialization
            const BASE_ENEMY_DENSITY_BONUS = 1.0;
            const MIN_ENEMY_DENSITY_BONUS = 0.6;
            const MAX_ENEMY_DENSITY_BONUS = 20;

            function normalizeEnemyDensityBonus(value) {
                const safe = ensureFiniteNumber(value, BASE_ENEMY_DENSITY_BONUS);
                return Math.min(MAX_ENEMY_DENSITY_BONUS, Math.max(MIN_ENEMY_DENSITY_BONUS, safe));
            }

            const store = {
                frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
                isDamageOff: false,
                savedPlayerState: null,
                world: {
                    wave: 1,
                    score: 0,
                    gold: 0,
                    xp: 0,
                    level: 1,
                    kills: 0,
                    bosses: 0,
                    bossesAtPilotSelection: null,
                    lowHealthTutorialShown: false,
                    bossSpawnTime: 0,
                    waveStartTime: 0,
                    activeBossToken: null,
                    activeBossWave: null,
                    completedBossTokens: Object.create(null),
                    lastBossAwardToken: null,
                    waveTransitionTimer: null,
                    enemyHealthBonus: 1.0,
                    bossHealthBonus: 1.0,
                    enemyDensityBonus: BASE_ENEMY_DENSITY_BONUS,
                    lastBossRapidKillMultiplier: 1,
                    lastEnemyOverdriveAnnounce: 0,
                    powerupCooldown: 0,
                    xpMultiplier: 1.0,
                    collarStacks: 0,
                    collarTargetStacks: 0,
                    collarTargetStacks: 0,
                    lateGameDamageScaling: 1,
                    consecutiveFastKills: 0,
                    fastKillBonus: 0,
                    isLowHealth: false,
                    lastThreatScale: 1,
                    lastSpawnOverflow: 0,
                    lastPlannedSpawnCount: 0,
                    lastSpawnCount: 0,
                    lastSpawnFallback: false,
                    lastSpawnQueueLength: 0,
                    lastSpawnTempo: 0,
                    firstBossOrbsGifted: false,
                    mechForgeGoldTriggered: false,
                    mechForgePulseTimeout: null,
                    mechForgePromptActive: false,
                    mechForgePromptInterval: 250,
                    nextMechForgePrompt: 135,
                    mechForgePromptCount: 0,
                    autoForgeEnabled: storedAutoForgeEnabled,
                    autoForgeReserve: 0,
                    autoForgeDecisionTimer: null,
                    autoForgeAnnounceCooldown: 0,
                    totalForgeSpend: 0,
                    autoForgeTutorialShown: false,
                    shopTutorialShown: false,
                    shopSpotlightDismissed: false,
                    currentThemeKey: DEFAULT_MAP_THEME_KEY,
                    targetThemeKey: DEFAULT_MAP_THEME_KEY,
                    themeTransitionProgress: 1,
                    themeTransitionActive: false,
                    autoForgeProfileId: initialAutoForgeProfileId,
                    voidReaperSpawnedThisWave: false,
                    lastVoidReaperWave: 0,
                    voidReaperCooldown: 0,
                    pendingVoidReaper: null,
                    voidReaperWarningIssued: false,
                    cubeBurglarCooldown: 0,
                    cubeBurglarActive: false,
                    cubeBurglarLastSpawnWave: 0,
                    cubeBurglarLastSpawnTime: 0,
                    cubeBurglarSpawnTimer: 0,
                    cubeBurglarSpawnAttempts: 0,
                    cubeBurglarLastAttemptTime: 0,
                    cubeBurglarDefeated: 0
                },
                settings: {
                    showShopTutorial: storedShopTutorialEnabled,
                    autoForgeProfile: initialAutoForgeProfileId,
                    audioMuted: false
                },
                ui: {
                    shopSpotlightActive: false,
                    shopSpotlightMessage: 'Upgrade Hangar online. Deploy credits as needed.'
                },
                player: { ...player_initial_state },
                boss: null, bullets: [], fragmentProjectiles: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], shadowHounds: [], missiles: [], lasers: [], mines: [], activeEffects: [], starProjectiles: [], pendingStarSalvos: [], pendingStarClones: [], juggernautBombs: [],
                lastBossSnapshot: null,
                lastBossDefeatId: null,
                flameParticles: [],
                lightningBolts: [],
                empNovas: [],
                flamePulses: [], // Rocketman flame pulse rings
                mechPuddles: [], // Hazardous puddles left by mech tank attacks
                poisonPuddles: [],
                tombstones: [], // Zombie spawning structures
                goldenOrbs: [],
                shadowEchoes: [],
                temporalEchoes: [],
                timeShards: [],
                geminiSlowFields: [],
                hunterLightningChains: [], // Lightning chains between Azure Strikers gang members
                championPresetCache: null,
                lastChampionPresetCode: null,
                temporalBeam: null,
                championMinions: [],
                cubeBurglarId: null,
                empCharges: [],
                knockbackCharges: [],
                empGlobalCooldown: 0,
                knockbackGlobalCooldown: 0,
                playerChampion: null,
                shadowChampionId: null,
                shadowChampionDefeated: false,
                shadowChampionTokenDropped: false,
                shadowChampionLastPos: null,
                floatingTexts: [],
                hitParticles: [],
                vibemasterRings: [],
                vibemasterThreads: [],
                vibemasterGuardians: [],
                vibemasterDistortion: null,
                vibemasterVacuum: null,
                _enemySpatial: {
                    cellSize: 160,
                    buckets: new Map(),
                    usedKeys: []
                },
                iceman: null,
                beefClone: null,
                waveSpawnQueue: [],
                pendingSpawnCount: 0,
                vulnerabilityEvents: [],
                // Object pools for performance optimization
                bulletPool: null,
                eBulletPool: [],
                effectPool: [],
                tempFlamePool: [], // For simple flame particles
                _startTs: performance.now(),
                cheatInvincibilityCooldown: 0,
                cheatDogHealCooldown: 0,
                cheatChampionCooldown: 0,
                heartbeatT: 0,
                cheatsUsed: false,
                telemetryEnabled: initialTelemetryEnabled
            };

            window.__voidDebug = {
                get store() {
                    return store;
                },
                countBullets() {
                    return Array.isArray(store?.bullets) ? store.bullets.length : null;
                },
                countBulletSprites() {
                    return activeBulletSprites?.size ?? null;
                },
                countPooledSprites() {
                    return bulletSpritePool?.length ?? null;
                }
            };

            function getActiveAutoForgeProfileId() {
                const worldId = store?.world?.autoForgeProfileId;
                if (worldId && AUTO_FORGE_PROFILE_MAP.has(worldId)) {
                    return worldId;
                }
                const settingsId = store?.settings?.autoForgeProfile;
                if (settingsId && AUTO_FORGE_PROFILE_MAP.has(settingsId)) {
                    return settingsId;
                }
                return AUTO_FORGE_DEFAULT_PROFILE_ID;
            }

            function getActiveAutoForgeProfile() {
                const profileId = getActiveAutoForgeProfileId();
                return AUTO_FORGE_PROFILE_MAP.get(profileId) || AUTO_FORGE_PROFILE_MAP.get(AUTO_FORGE_DEFAULT_PROFILE_ID);
            }

            function setAutoForgeProfile(profileId, options = {}) {
                const resolved = resolveAutoForgeProfileId(profileId);
                const current = getActiveAutoForgeProfileId();
                if (resolved === current && !options.force) {
                    if (!options.skipUi) {
                        updateAutoForgeProfileButtons();
                        updateAutoForgeStatusLabel();
                    }
                    return resolved;
                }

                if (store.settings) {
                    store.settings.autoForgeProfile = resolved;
                }
                if (store.world) {
                    store.world.autoForgeProfileId = resolved;
                }

                try {
                    if (window.localStorage) {
                        window.localStorage.setItem('voidAutoForgeProfile', resolved);
                    }
                } catch (err) { }

                if (!options.skipUi) {
                    updateAutoForgeProfileButtons();
                    updateAutoForgeStatusLabel();
                }

                if (!options.silent && typeof announce === 'function') {
                    const profile = AUTO_FORGE_PROFILE_MAP.get(resolved);
                    if (profile) {
                        announce(`Auto-buy doctrine set: ${profile.label}.`);
                    }
                }

                return resolved;
            }

            function getAutoForgeStatusText() {
                const world = store.world;
                if (!world || !world.autoForgeEnabled) {
                    return 'Auto-buy offline. Route purchases manually.';
                }
                const profile = getActiveAutoForgeProfile();
                if (profile) {
                    return `Auto-buy active: ${profile.label}. ${profile.statusLine}`;
                }
                return 'Auto-buy active. Logistics maintain core systems.';
            }

            function updateAutoForgeStatusLabel() {
                const statusEl = q('autoForgeStatusLabel');
                if (statusEl) {
                    statusEl.textContent = getAutoForgeStatusText();
                }
            }

            function updateAutoForgeProfileButtons() {
                const container = q('autoForgeProfileGrid');
                if (!container) return;
                const activeId = getActiveAutoForgeProfileId();
                container.querySelectorAll('.forge-profile-card').forEach(card => {
                    if (!(card instanceof HTMLElement)) return;
                    const isActive = card.dataset.profileId === activeId;
                    if (isActive) {
                        card.classList.add('active');
                        card.setAttribute('aria-pressed', 'true');
                    } else {
                        card.classList.remove('active');
                        card.setAttribute('aria-pressed', 'false');
                    }
                });
                const summaryEl = q('autoForgeProfileSummary');
                if (summaryEl) {
                    const profile = getActiveAutoForgeProfile();
                    if (!store.world || !store.world.autoForgeEnabled) {
                        summaryEl.textContent = 'Auto-buy is currently offline. Enable the switch above to deploy a doctrine.';
                    } else {
                        summaryEl.textContent = profile ? profile.summary : '';
                    }
                }
            }

            function ensureAutoForgeProfileGrid() {
                const container = q('autoForgeProfileGrid');
                if (!container) return;
                if (!container.dataset.initialized) {
                    container.dataset.initialized = 'true';
                    for (const profile of AUTO_FORGE_PROFILES) {
                        const card = document.createElement('button');
                        card.type = 'button';
                        card.className = 'forge-profile-card';
                        card.dataset.profileId = profile.id;
                        card.setAttribute('aria-pressed', 'false');
                        card.innerHTML = `<div class="forge-profile-card-title">${profile.label}</div><div class="forge-profile-card-summary">${profile.summary}</div>`;
                        card.addEventListener('click', () => {
                            setAutoForgeProfile(profile.id);
                        });
                        container.appendChild(card);
                    }
                }
                updateAutoForgeProfileButtons();
            }

            // --- OBJECT POOLING SYSTEM ---
            store.bulletPool = bulletPool;

            function spawnBullet(props = {}) {
                const bullet = bulletPool.get();
                const skipSplit = props.skipSplit === true;
                const presetElement = typeof props.presetElement === 'string' ? props.presetElement : null;
                Object.assign(bullet, props);
                bullet.skipSplit = skipSplit;
                bullet.hasRicocheted = props.hasRicocheted === true;
                bullet.ricochetDist = typeof props.ricochetDist === 'number' ? props.ricochetDist : 0;
                bullet.maxRicochetDist = typeof props.maxRicochetDist === 'number' ? props.maxRicochetDist : 0;
                bullet.originalDmg = typeof props.originalDmg === 'number' ? props.originalDmg : undefined;
                const player = store.player;
                
                // Determine bullet element based on mode
                if (presetElement) {
                    bullet.element = presetElement;
                } else {
                    const activeElements = getActiveBulletElements(player);
                    let elementMode = 'normal';
                    const hasAllCoreElements = CORE_ELEMENT_KEYS.every(el => activeElements.includes(el));
                    if (hasAllCoreElements) {
                        elementMode = 'void';
                    } else if (activeElements.length === 1) {
                        elementMode = activeElements[0];
                    } else if (activeElements.length > 1) {
                        ensureBulletElementState(player);
                        const idx = player ? (player.bulletElementCycleIndex || 0) : 0;
                        elementMode = activeElements[idx % activeElements.length];
                        if (player) {
                            player.bulletElementCycleIndex = (idx + 1) % activeElements.length;
                        }
                    }
                    bullet.element = elementMode;
                }
                if (bullet.element === 'void' && (!('col' in props) || props.col === undefined)) {
                    bullet.col = '#231530';
                }
                if ('presetElement' in bullet) {
                    delete bullet.presetElement;
                }
                const ricochetLevel = player ? (player.ricochetLevel || (player.hasRicochet ? 1 : 0)) : 0;
                if (props.canRicochet !== undefined) {
                    bullet.canRicochet = !!props.canRicochet;
                } else if (ricochetLevel >= 2) {
                    bullet.canRicochet = true;
                } else if (ricochetLevel >= 1) {
                    bullet.canRicochet = Math.random() < 0.5;
                } else {
                    bullet.canRicochet = false;
                }
                bullet.dead = false;
                if (bullet.isFlame && !Array.isArray(bullet.particles)) {
                    bullet.particles = [];
                }
                if (bullet.canRicochet && !bullet.isFragment && !bullet.isFlame && !bullet.isLavaBlade && !bullet.isLevelUpPulse) {
                    const baseRadius = Number.isFinite(bullet.r) ? bullet.r : 4;
                    if (baseRadius > 3.2) {
                        bullet.r = 3.2;
                    }
                }
                store.bullets.push(bullet);

                if (player && player.splitShotActive && !bullet.skipSplit) {
                    const prohibited = bullet.isFragment || bullet.isFlame || bullet.isLavaBlade || bullet.isLevelUpPulse || bullet.explosive;
                    if (!prohibited) {
                        const speed = Math.hypot(bullet.vx || 0, bullet.vy || 0);
                        if (speed > 60) {
                            const spread = Number.isFinite(player.splitShotSpread) ? player.splitShotSpread : 0.18;
                            const halfSpread = spread * 0.5;
                            const baseAngle = Math.atan2(bullet.vy, bullet.vx);
                            const rightAngle = baseAngle + halfSpread;
                            const leftAngle = baseAngle - halfSpread;

                            bullet.vx = Math.cos(leftAngle) * speed;
                            bullet.vy = Math.sin(leftAngle) * speed;
                            bullet.skipSplit = true;

                            const cloneProps = {
                                x: bullet.x,
                                y: bullet.y,
                                vx: Math.cos(rightAngle) * speed,
                                vy: Math.sin(rightAngle) * speed,
                                r: bullet.r,
                                col: bullet.col,
                                dmg: bullet.dmg,
                                pierce: bullet.pierce,
                                explosive: bullet.explosive,
                                presetElement: bullet.element,
                                isSwirl: bullet.isSwirl,
                                isFlame: bullet.isFlame,
                                isIceman: bullet.isIceman,
                                isDrone: bullet.isDrone,
                                isBeefClone: bullet.isBeefClone,
                                isChampionShot: bullet.isChampionShot,
                                isLavaBlade: bullet.isLavaBlade,
                                isLevelUpPulse: bullet.isLevelUpPulse,
                                hasRicocheted: bullet.hasRicocheted,
                                canRicochet: bullet.canRicochet,
                                ricochetDist: bullet.ricochetDist,
                                maxRicochetDist: bullet.maxRicochetDist,
                                originalDmg: bullet.originalDmg,
                                gravity: bullet.gravity,
                                target: bullet.target,
                                spawnTime: bullet.spawnTime,
                                life: bullet.life,
                                maxLife: bullet.maxLife,
                                skipSplit: true
                            };
                            spawnBullet(cloneProps);
                        }
                    }
                }
                return bullet;
            }

            function consumeBulletPierce(bullet) {
                if (!bullet) return true;
                const remaining = Number.isFinite(bullet.pierce) ? bullet.pierce : 0;
                if (remaining > 0) {
                    bullet.pierce = Math.max(0, remaining - 1);
                    return false;
                }
                bullet.pierce = 0;
                bullet.dead = true;
                return true;
            }

            function getBulletColorForSubclass() {
                const p = store.player;
                if (!p || !p.subclass) {
                    return "#b266ff"; // Default purple
                }
                
                switch (p.subclass) {
                    case 'juggernaut':
                        return "#ff6b6b"; // Red
                    case 'marauder':
                        return "#66ff99"; // Green
                    case 'demolitioner':
                        return "#ffd166"; // Gold/Orange
                    case 'railgunner':
                        return "#b794ff"; // Purple/Violet
                    case 'phasestriker':
                        return "#ff91d2"; // Pink
                    case 'stormbringer':
                        return "#6dd0ff"; // Cyan/Light Blue
                    default:
                        return "#b266ff"; // Default purple
                }
            }

            function spawnFragmentProjectile(props = {}) {
                const defaults = {
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    r: 2,
                    col: '#ff9944',
                    dmg: 8,
                    pierce: 0,
                    explosive: false,
                    lifetime: 0,
                    maxLifetime: 0.35,
                    isFragment: true,
                    isFragmentBlast: true,
                    originX: undefined,
                    originY: undefined
                };
                const projectile = { ...defaults, ...props };
                projectile.dead = false;
                projectile.lifetime = Number.isFinite(projectile.lifetime) ? projectile.lifetime : 0;
                projectile.maxLifetime = Math.max(0.05, Number.isFinite(projectile.maxLifetime) ? projectile.maxLifetime : defaults.maxLifetime);
                projectile.originX = Number.isFinite(projectile.originX) ? projectile.originX : projectile.x;
                projectile.originY = Number.isFinite(projectile.originY) ? projectile.originY : projectile.y;
                if (!Number.isFinite(projectile.impactAngle)) {
                    projectile.impactAngle = Math.atan2(projectile.vy, projectile.vx);
                }
                store.fragmentProjectiles.push(projectile);
                return projectile;
            }

            function ensurePlayerMultishotIntegrity(player) {
                if (!player) return;

                const current = Number.isFinite(player.multishot) ? player.multishot : 2;
                const sanitized = Math.max(1, Math.round(current));
                if (!Number.isFinite(player.maxMultishot)) {
                    player.maxMultishot = Math.max(1, sanitized);
                }
                player.maxMultishot = Math.max(player.maxMultishot, sanitized);
                player.multishot = Math.max(sanitized, player.maxMultishot);

                const rearCurrent = Number.isFinite(player.rearMultishot) ? player.rearMultishot : 0;
                const rearSanitized = Math.max(0, Math.round(rearCurrent));
                if (!Number.isFinite(player.maxRearMultishot)) {
                    player.maxRearMultishot = Math.max(0, rearSanitized);
                }
                player.maxRearMultishot = Math.max(player.maxRearMultishot, rearSanitized);
                player.rearMultishot = Math.max(rearSanitized, player.maxRearMultishot);
            }

            function getEBulletFromPool(props = {}) {
                let bullet;
                if (store.eBulletPool.length > 0) {
                    bullet = store.eBulletPool.pop();
                    // Reset all properties to default
                    Object.assign(bullet, {
                        x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                        dmg: 0, dead: false, life: undefined,
                        fadeInTime: undefined, spawnTime: undefined,
                        bounceCount: 0, maxBounces: 0, type: undefined
                    });
                } else {
                    bullet = {
                        x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                        dmg: 0, dead: false
                    };
                }

                // Apply custom properties
                Object.assign(bullet, props);
                return bullet;
            }

            function returnEBulletToPool(bullet) {
                if (store.eBulletPool.length < 1000) { // Cap pool size
                    store.eBulletPool.push(bullet);
                }
            }

            // PERFORMANCE: Effect pooling for createEffect() calls
            function getEffectFromPool(type, x, y, extra) {
                let effect;
                if (store.effectPool.length > 0) {
                    effect = store.effectPool.pop();
                    effect.type = type;
                    effect.x = x;
                    effect.y = y;
                    effect.extra = extra;
                    effect.isActive = true;
                    effect.dead = false;
                    effect.birth = performance.now();
                } else {
                    effect = createEffect(type, x, y, extra);
                }
                return effect;
            }

            function returnEffectToPool(effect) {
                if (store.effectPool.length < 50) { // Limit pool size
                    effect.isActive = false;
                    effect.dead = true;
                    store.effectPool.push(effect);
                }
            }

            // PERFORMANCE: Simple flame particle pooling
            function getTempFlameFromPool() {
                if (store.tempFlamePool.length > 0) {
                    return store.tempFlamePool.pop();
                }
                return {
                    x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, r: 0, dead: false
                };
            }

            function returnTempFlameToPool(flame) {
                if (store.tempFlamePool.length < 100) {
                    flame.dead = true;
                    store.tempFlamePool.push(flame);
                }
            }

            const ENEMY_SPATIAL_KEY_MASK = 0xffff;

            function computeEnemySpatialKey(cellX, cellY) {
                return ((cellX & ENEMY_SPATIAL_KEY_MASK) << 16) | (cellY & ENEMY_SPATIAL_KEY_MASK);
            }

            function rebuildEnemySpatialIndex() {
                const spatial = store._enemySpatial;
                if (!spatial) return;

                const { buckets, usedKeys, cellSize } = spatial;

                for (let i = 0; i < usedKeys.length; i++) {
                    const key = usedKeys[i];
                    const bucket = buckets.get(key);
                    if (bucket) {
                        bucket.length = 0;
                    }
                }
                usedKeys.length = 0;

                const enemies = store.enemies;
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    if (!enemy || enemy.dead) continue;
                    const cellX = Math.floor(enemy.x / cellSize);
                    const cellY = Math.floor(enemy.y / cellSize);
                    const key = computeEnemySpatialKey(cellX, cellY);
                    let bucket = buckets.get(key);
                    if (!bucket) {
                        bucket = [];
                        buckets.set(key, bucket);
                    }
                    bucket.push(enemy);
                    if (bucket.length === 1) {
                        usedKeys.push(key);
                    }
                }
            }

            function forEachEnemyNearby(x, y, radius, iterator) {
                const spatial = store._enemySpatial;
                if (!spatial) return;

                const { buckets, cellSize } = spatial;
                const minCellX = Math.floor((x - radius) / cellSize);
                const maxCellX = Math.floor((x + radius) / cellSize);
                const minCellY = Math.floor((y - radius) / cellSize);
                const maxCellY = Math.floor((y + radius) / cellSize);

                for (let cellX = minCellX; cellX <= maxCellX; cellX++) {
                    for (let cellY = minCellY; cellY <= maxCellY; cellY++) {
                        const key = computeEnemySpatialKey(cellX, cellY);
                        const bucket = buckets.get(key);
                        if (!bucket || bucket.length === 0) continue;
                        for (let i = 0; i < bucket.length; i++) {
                            const enemy = bucket[i];
                            if (!enemy || enemy.dead) continue;
                            if (iterator(enemy) === true) {
                                return;
                            }
                        }
                    }
                }
            }

            function getBulletSearchRadius(bullet) {
                if (bullet.collisionSearchRadius != null) {
                    return bullet.collisionSearchRadius;
                }

                let radius = 140;
                if (bullet.r) radius += bullet.r;
                if (bullet.explosive) radius = Math.max(radius, 230);
                if (bullet.isLevelUpPulse) radius = Math.max(radius, 260);
                if (bullet.isFlame) radius = Math.max(radius, 220);
                if (bullet.isDrone) radius = Math.max(radius, 200);

                return Math.max(120, Math.min(radius, 320));
            }

            function applyChampionOnHitEffects(bullet, enemy, context) {
                if (!CHAMPION_SYSTEM_ENABLED) return;
                if (!bullet || !enemy || enemy.dead || enemy.hp <= 0) return;
                if (!bullet.isChampionShot) return;

                const championLevel = Math.max(1, bullet.championLevel || context.championLevel || (store.playerChampion?.level || 1));
                const baseDamage = Math.max(0, context.baseDamage || bullet.dmg || 0);
                const finalDamage = Math.max(0, context.finalDamage || bullet.dmg || 0);
                if (finalDamage <= 0) return;

                const moduleId = bullet.championAttackModule || getChampionUpgradeState().attackModule;
                if (!bullet.skipChampionEffects) {
                    switch (moduleId) {
                        // KINETIC MODULES
                        case 'precision_strike':
                            applyPrecisionStrike(enemy, { finalDamage, championLevel });
                            break;
                        case 'kinetic_swarm':
                            applyKineticSwarm(enemy, { finalDamage, championLevel });
                            break;

                        // FIRE MODULES
                        case 'inferno_burst':
                            applyInfernoBurst(bullet, enemy, { finalDamage, championLevel });
                            break;
                        case 'plasma_stream':
                            applyPlasmaStream(enemy, { finalDamage, championLevel });
                            break;

                        // LASER MODULES
                        case 'focus_beam':
                            applyFocusBeam(enemy, { finalDamage, championLevel });
                            break;
                        case 'scatter_array':
                            applyScatterArray(bullet, enemy, { finalDamage, championLevel });
                            break;

                        // LIGHTNING MODULES
                        case 'arc_cannon':
                            applyArcCannon(bullet, enemy, { finalDamage, championLevel });
                            break;
                        case 'storm_grid':
                            applyStormGrid(bullet, enemy, { finalDamage, championLevel });
                            break;

                        // LEGACY MODULES (for backwards compatibility)
                        case 'ember':
                            applyPlasmaStream(enemy, { finalDamage, championLevel }); // Map to plasma stream
                            break;
                        case 'tempest':
                            applyArcCannon(bullet, enemy, { finalDamage, championLevel }); // Map to arc cannon
                            break;
                        case 'void':
                            applyChampionVoidResonance(bullet, enemy, { baseDamage, finalDamage, championLevel });
                            break;
                        default:
                            break;
                    }
                }

                if (bullet.fromChampionMinion) {
                    applyChampionMinionProtocols(bullet, enemy, {
                        baseDamage,
                        championLevel
                    });
                }
            }

            function applyChampionEmberBurn(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;
                const now = performance.now();
                const duration = 2.8 + (championLevel - 1) * 0.6;
                const tickInterval = Math.max(0.28, 0.54 - championLevel * 0.05);
                const damagePerTick = Math.max(8, finalDamage * (0.2 + (championLevel - 1) * 0.05));

                let burn = enemy.championBurn;
                if (!burn) {
                    burn = enemy.championBurn = {};
                }
                burn.timer = Math.max(burn.timer || 0, duration);
                burn.tickInterval = tickInterval;
                burn.tickTimer = Math.min(burn.tickTimer ?? tickInterval, tickInterval * 0.5);
                burn.damagePerTick = Math.max(burn.damagePerTick || 0, damagePerTick);
                burn.lethalFloor = enemy === store.boss ? 0 : 1;
                burn.level = championLevel;
                burn.lastApplied = now;

                if (!burn.visualCooldown || now - burn.visualCooldown > 120) {
                    store.activeEffects.push(createEffect('jugFearEmber', enemy.x, enemy.y, (enemy.r || 18) * 1.1));
                    burn.visualCooldown = now;
                }
            }

            function applyChampionTempestChain(bullet, sourceEnemy, { finalDamage, championLevel }) {
                if (!sourceEnemy || sourceEnemy.dead || sourceEnemy.hp <= 0 || finalDamage <= 0) return;
                const radius = 220 + (championLevel - 1) * 35;
                const maxTargets = 2;
                const chainDamage = finalDamage * 0.6;
                if (chainDamage <= 0) return;

                if (!bullet._tempestVisited) bullet._tempestVisited = new Set();
                const visited = bullet._tempestVisited;
                visited.add(sourceEnemy.id || sourceEnemy);

                const candidates = [];
                forEachEnemyNearby(sourceEnemy.x, sourceEnemy.y, radius, enemy => {
                    if (!enemy || enemy === sourceEnemy || enemy.dead || enemy.hp <= 0) return false;
                    const key = enemy.id || enemy;
                    if (visited.has(key)) return false;
                    const dx = enemy.x - sourceEnemy.x;
                    const dy = enemy.y - sourceEnemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        candidates.push({ enemy, dist });
                    }
                    return false;
                });

                if (store.boss && store.boss !== sourceEnemy && !store.boss.dead) {
                    const dx = store.boss.x - sourceEnemy.x;
                    const dy = store.boss.y - sourceEnemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius + (store.boss.r || 50)) {
                        candidates.push({ enemy: store.boss, dist });
                    }
                }

                candidates.sort((a, b) => a.dist - b.dist);
                for (let i = 0; i < Math.min(maxTargets, candidates.length); i++) {
                    const target = candidates[i].enemy;
                    const key = target.id || target;
                    if (visited.has(key)) continue;
                    visited.add(key);
                    championDealDamage(target, chainDamage, {
                        x: sourceEnemy.x,
                        y: sourceEnemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });
                    store.activeEffects.push(createEffect('lightning', sourceEnemy.x, sourceEnemy.y, 18, {
                        targetX: target.x,
                        targetY: target.y,
                        strength: 42
                    }));
                }
            }

            function applyChampionVoidResonance(bullet, enemy, { baseDamage, finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;
                if (!enemy.championVoidMarks) {
                    enemy.championVoidMarks = { stacks: 0, timer: 0, level: championLevel };
                }
                const state = enemy.championVoidMarks;
                state.stacks = (state.stacks || 0) + 1;
                state.timer = 4.5;
                state.level = championLevel;
                state.lastDamage = finalDamage;
                store.activeEffects.push(createEffect('voidLockChains', enemy.x, enemy.y, (enemy.r || 18) * 1.1));

                if (state.stacks >= 3) {
                    detonateChampionVoidResonance(bullet, enemy, state, { baseDamage, finalDamage, championLevel });
                }
            }

            function detonateChampionVoidResonance(bullet, enemy, state, { baseDamage, finalDamage, championLevel }) {
                state.stacks = 0;
                state.timer = 0;
                const primaryDamage = Math.max(0, finalDamage * (0.75 + (championLevel - 1) * 0.12));
                const splashDamage = Math.max(0, baseDamage * (0.45 + (championLevel - 1) * 0.1));
                const radius = 130 + (championLevel - 1) * 28;
                const originX = enemy.x;
                const originY = enemy.y;

                championDealDamage(enemy, primaryDamage, {
                    x: originX,
                    y: originY,
                    skipChampionEffects: true,
                    sourceAttackModule: bullet.championAttackModule,
                    championLevel
                });
                enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 3.2);
                enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 1, 3);

                const radiusSq = radius * radius;
                forEachEnemyNearby(originX, originY, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const dx = candidate.x - originX;
                    const dy = candidate.y - originY;
                    if (dx * dx + dy * dy > radiusSq) return false;
                    championDealDamage(candidate, splashDamage, {
                        x: originX,
                        y: originY,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });
                    candidate.railgunArmorTimer = Math.max(candidate.railgunArmorTimer || 0, 2.0);
                    candidate.railgunCrackLevel = Math.min((candidate.railgunCrackLevel || 0) + 1, 3);
                    store.activeEffects.push(createEffect('voidLockChains', candidate.x, candidate.y, candidate.r || 18));
                    return false;
                });

                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dxB = store.boss.x - originX;
                    const dyB = store.boss.y - originY;
                    if (dxB * dxB + dyB * dyB <= Math.pow(radius + (store.boss.r || 60), 2)) {
                        championDealDamage(store.boss, splashDamage, {
                            x: originX,
                            y: originY,
                            skipChampionEffects: true,
                            sourceAttackModule: bullet.championAttackModule,
                            championLevel
                        });
                        store.boss.railgunArmorTimer = Math.max(store.boss.railgunArmorTimer || 0, 3.0);
                        store.activeEffects.push(createEffect('voidLockChains', store.boss.x, store.boss.y, (store.boss.r || 60) * 1.2));
                    }
                }
            }

            function applyChampionMinionProtocols(bullet, enemy, { baseDamage, championLevel }) {
                const protocolLevel = bullet.minionProtocolLevel || 0;
                if (protocolLevel <= 0) return;

                if (bullet.minionProtocolSlowFactor) {
                    const slowDuration = 0.55 + protocolLevel * 0.18;
                    enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, bullet.minionProtocolSlowFactor);
                    enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
                }

                if (protocolLevel >= 2 && bullet.minionProtocolNovaDamageScale > 0) {
                    const splashDamage = Math.max(0, baseDamage * bullet.minionProtocolNovaDamageScale);
                    if (splashDamage <= 0) return;
                    const radius = 95 + 14 * Math.max(0, championLevel - 1);
                    const radiusSq = radius * radius;
                    forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                        if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                        const dx = candidate.x - enemy.x;
                        const dy = candidate.y - enemy.y;
                        if (dx * dx + dy * dy > radiusSq) return false;
                        championDealDamage(candidate, splashDamage, {
                            x: enemy.x,
                            y: enemy.y,
                            skipChampionEffects: true,
                            sourceAttackModule: bullet.championAttackModule,
                            championLevel
                        });
                        return false;
                    });

                    if (store.boss && store.boss !== enemy && !store.boss.dead) {
                        const dxB = store.boss.x - enemy.x;
                        const dyB = store.boss.y - enemy.y;
                        if (dxB * dxB + dyB * dyB <= Math.pow(radius + (store.boss.r || 60), 2)) {
                            championDealDamage(store.boss, splashDamage, {
                                x: enemy.x,
                                y: enemy.y,
                                skipChampionEffects: true,
                                sourceAttackModule: bullet.championAttackModule,
                                championLevel
                            });
                        }
                    }
                }
            }

            function tickChampionBurn(target, dt) {
                if (!target || !target.championBurn) return;
                const burn = target.championBurn;
                if (!burn || burn.timer <= 0) {
                    target.championBurn = null;
                    return;
                }

                burn.timer = Math.max(0, burn.timer - dt);
                burn.tickTimer = (burn.tickTimer ?? burn.tickInterval ?? 0.5) - dt;
                const interval = burn.tickInterval || 0.5;
                const lethalFloor = burn.lethalFloor ?? (target === store.boss ? 0 : 1);
                const level = burn.level || 1;

                while (burn.timer > 0 && burn.tickTimer <= 0) {
                    burn.tickTimer += interval;
                    const allowable = Math.max(0, (target.hp ?? 0) - lethalFloor);
                    const tickDamage = Math.min(allowable, burn.damagePerTick || 0);
                    if (tickDamage > 0) {
                        store.activeEffects.push(createEffect('jugFearEmber', target.x, target.y, (target.r || 18) * 1.05));
                        championDealDamage(target, tickDamage, {
                            x: target.x,
                            y: target.y,
                            skipChampionEffects: true,
                            sourceAttackModule: 'ember',
                            championLevel: level
                        });
                        spawnDotDamageText(target, tickDamage, {
                            color: '#ffb66b',
                            riseSpeed: 32,
                            jitter: 6,
                            scale: 0.95
                        });
                        playSound('sizzle'); // Play sizzle sound on burn tick
                    } else {
                        break;
                    }
                }

                if (burn.timer <= 0) {
                    target.championBurn = null;
                }
            }

            function tickChampionVoidMarks(target, dt) {
                if (!target || !target.championVoidMarks) return;
                const state = target.championVoidMarks;
                state.timer = Math.max(0, (state.timer || 0) - dt);
                if (state.timer <= 0) {
                    target.championVoidMarks = null;
                }
            }

            function tickChampionStormGrid(target, dt) {
                if (!target || !target.stormField) return;
                const field = target.stormField;

                field.duration = Math.max(0, field.duration - dt);
                if (field.duration <= 0) {
                    target.stormField = null;
                    return;
                }

                field.tickTimer = Math.max(0, field.tickTimer - dt);
                if (field.tickTimer <= 0) {
                    field.tickTimer = field.tickInterval;

                    // Apply damage to all enemies in the field area
                    const radiusSq = field.radius * field.radius;
                    store.enemies.forEach(enemy => {
                        if (!enemy || enemy.dead || enemy.hp <= 0) return;
                        const dx = enemy.x - field.x;
                        const dy = enemy.y - field.y;
                        if (dx * dx + dy * dy <= radiusSq) {
                            const allowable = Math.max(0, enemy.hp - (enemy === store.boss ? 0 : 1));
                            const tickDamage = Math.min(allowable, field.tickDamage);
                            if (tickDamage > 0) {
                                championDealDamage(enemy, tickDamage, {
                                    x: field.x,
                                    y: field.y,
                                    skipChampionEffects: true,
                                    sourceAttackModule: 'storm_grid',
                                    championLevel: field.level
                                });

                                // Visual feedback
                                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, 18));
                            }
                        }
                    });

                    // Also check boss
                    if (store.boss && !store.boss.dead) {
                        const dx = store.boss.x - field.x;
                        const dy = store.boss.y - field.y;
                        const bossRadius = store.boss.r || 50;
                        if (dx * dx + dy * dy <= Math.pow(field.radius + bossRadius, 2)) {
                            const tickDamage = field.tickDamage;
                            if (tickDamage > 0) {
                                championDealDamage(store.boss, tickDamage, {
                                    x: field.x,
                                    y: field.y,
                                    skipChampionEffects: true,
                                    sourceAttackModule: 'storm_grid',
                                    championLevel: field.level
                                });

                                store.activeEffects.push(createEffect('stormDischarge', store.boss.x, store.boss.y, 24));
                            }
                        }
                    }
                }
            }

            // NEW ATTACK MODULE FUNCTIONS

            // KINETIC MODULES
            function applyPrecisionStrike(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Precision Strike: Armor-piercing massive damage
                enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 4.5);
                enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 2, 3);

                // Visual effect for armor penetration
                const flashLevel = Math.max(1, Math.min(enemy.railgunCrackLevel || 1, 3));
                store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, flashLevel));
            }

            function applyKineticSwarm(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Kinetic Swarm: Rapid fire effect with small visual impact
                const intensity = Math.min(4, championLevel);
            }

            // FIRE MODULES
            function applyInfernoBurst(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Inferno Burst: Area explosion with burn
                const radius = 150 + (championLevel - 1) * 30;
                const splashDamage = finalDamage * (0.6 + (championLevel - 1) * 0.1);
                const burnDuration = 3.5 + (championLevel - 1) * 0.8;
                const burnDamagePerTick = finalDamage * (0.15 + (championLevel - 1) * 0.03);

                // Apply burn to primary target
                applyBurnEffect(enemy, burnDuration, burnDamagePerTick, championLevel);

                // Area damage and burn
                const radiusSq = radius * radius;
                forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const dx = candidate.x - enemy.x;
                    const dy = candidate.y - enemy.y;
                    if (dx * dx + dy * dy > radiusSq) return false;

                    championDealDamage(candidate, splashDamage, {
                        x: enemy.x,
                        y: enemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });
                    applyBurnEffect(candidate, burnDuration * 0.7, burnDamagePerTick * 0.8, championLevel);
                    return false;
                });

                // Boss splash
                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dxB = store.boss.x - enemy.x;
                    const dyB = store.boss.y - enemy.y;
                    if (dxB * dxB + dyB * dyB <= Math.pow(radius + (store.boss.r || 60), 2)) {
                        championDealDamage(store.boss, splashDamage, {
                            x: enemy.x,
                            y: enemy.y,
                            skipChampionEffects: true,
                            sourceAttackModule: bullet.championAttackModule,
                            championLevel
                        });
                        applyBurnEffect(store.boss, burnDuration * 0.7, burnDamagePerTick * 0.8, championLevel);
                    }
                }

                // Explosion effect (subtle)
                const visualRadius = Math.min(52, radius * 0.28);
                store.activeEffects.push(createEffect('jugFearEmber', enemy.x, enemy.y, visualRadius));
            }

            function applyPlasmaStream(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Plasma Stream: Sustained burn (like old ember but balanced)
                const duration = 2.5 + (championLevel - 1) * 0.5;
                const tickInterval = Math.max(0.3, 0.5 - championLevel * 0.03);
                const damagePerTick = Math.max(6, finalDamage * (0.18 + (championLevel - 1) * 0.04));

                applyBurnEffect(enemy, duration, damagePerTick, championLevel, tickInterval);
                store.activeEffects.push(createEffect('jugFearEmber', enemy.x, enemy.y, Math.min(24, (enemy.r || 18) * 0.9)));
            }

            // LASER MODULES
            function applyFocusBeam(enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Focus Beam: Ignores all armor and shields, piercing damage
                enemy.laserIgnoreArmor = true; // Special flag for armor bypass
                enemy.railgunArmorTimer = 0; // Remove armor entirely
                enemy.railgunCrackLevel = 3; // Maximum armor crack

                // Piercing laser effect
                store.activeEffects.push(createEffect('laser', enemy.x, enemy.y, 18, {
                    targetX: enemy.x,
                    targetY: enemy.y - 40,
                    duration: 0.65,
                    strength: 62
                }));
                store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, 3));
            }

            function applyScatterArray(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Scatter Array: Hit multiple nearby targets
                const maxTargets = 2 + Math.floor((championLevel - 1) / 2);
                const radius = 200 + (championLevel - 1) * 25;
                const scatterDamage = finalDamage * (0.75 + (championLevel - 1) * 0.05);

                if (!bullet._scatterVisited) bullet._scatterVisited = new Set();
                const visited = bullet._scatterVisited;
                visited.add(enemy.id || enemy);

                const candidates = [];
                forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const key = candidate.id || candidate;
                    if (visited.has(key)) return false;
                    const dx = candidate.x - enemy.x;
                    const dy = candidate.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        candidates.push({ enemy: candidate, dist });
                    }
                    return false;
                });

                // Include boss
                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dx = store.boss.x - enemy.x;
                    const dy = store.boss.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius + (store.boss.r || 50)) {
                        candidates.push({ enemy: store.boss, dist });
                    }
                }

                candidates.sort((a, b) => a.dist - b.dist);
                for (let i = 0; i < Math.min(maxTargets, candidates.length); i++) {
                    const target = candidates[i].enemy;
                    const key = target.id || target;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    championDealDamage(target, scatterDamage, {
                        x: enemy.x,
                        y: enemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });

                    // Laser beam to each target
                    store.activeEffects.push(createEffect('laser', enemy.x, enemy.y, 14, {
                        targetX: target.x,
                        targetY: target.y,
                        duration: 0.35,
                        strength: 46
                    }));
                }
            }

            // LIGHTNING MODULES
            function applyArcCannon(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Arc Cannon: High primary damage + chain (like improved tempest)
                const radius = 250 + (championLevel - 1) * 40;
                const maxTargets = 2 + Math.floor((championLevel - 1) / 3);
                const chainDamage = finalDamage * (0.65 + (championLevel - 1) * 0.05);

                if (!bullet._arcVisited) bullet._arcVisited = new Set();
                const visited = bullet._arcVisited;
                visited.add(enemy.id || enemy);

                const candidates = [];
                forEachEnemyNearby(enemy.x, enemy.y, radius, candidate => {
                    if (!candidate || candidate === enemy || candidate.dead || candidate.hp <= 0) return false;
                    const key = candidate.id || candidate;
                    if (visited.has(key)) return false;
                    const dx = candidate.x - enemy.x;
                    const dy = candidate.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        candidates.push({ enemy: candidate, dist });
                    }
                    return false;
                });

                // Include boss
                if (store.boss && store.boss !== enemy && !store.boss.dead) {
                    const dx = store.boss.x - enemy.x;
                    const dy = store.boss.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius + (store.boss.r || 50)) {
                        candidates.push({ enemy: store.boss, dist });
                    }
                }

                candidates.sort((a, b) => a.dist - b.dist);
                for (let i = 0; i < Math.min(maxTargets, candidates.length); i++) {
                    const target = candidates[i].enemy;
                    const key = target.id || target;
                    if (visited.has(key)) continue;
                    visited.add(key);

                    championDealDamage(target, chainDamage, {
                        x: enemy.x,
                        y: enemy.y,
                        skipChampionEffects: true,
                        sourceAttackModule: bullet.championAttackModule,
                        championLevel
                    });

                    // Lightning arc effect
                    store.activeEffects.push(createEffect('lightning', enemy.x, enemy.y, 18, {
                        targetX: target.x,
                        targetY: target.y,
                        strength: 46
                    }));
                }

                // Primary target effect
                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, 22));
            }

            function applyStormGrid(bullet, enemy, { finalDamage, championLevel }) {
                if (!enemy || enemy.dead || enemy.hp <= 0 || finalDamage <= 0) return;

                // Storm Grid: Creates persistent electrical field
                const fieldDuration = 4.0 + (championLevel - 1) * 0.8;
                const fieldRadius = 120 + (championLevel - 1) * 20;
                const tickDamage = finalDamage * (0.25 + (championLevel - 1) * 0.03);

                // Create or update storm field at impact location
                let field = enemy.stormField;
                if (!field) {
                    field = enemy.stormField = {
                        x: enemy.x,
                        y: enemy.y,
                        radius: fieldRadius,
                        duration: fieldDuration,
                        tickDamage: tickDamage,
                        tickInterval: 0.4,
                        tickTimer: 0.4,
                        level: championLevel
                    };
                } else {
                    field.duration = Math.max(field.duration, fieldDuration);
                    field.tickDamage = Math.max(field.tickDamage, tickDamage);
                }

                // Visual storm effect
                const pulseRadius = Math.min(40, fieldRadius * 0.35);
                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, pulseRadius));
            }

            // HELPER FUNCTION for burn effects
            function applyBurnEffect(enemy, duration, damagePerTick, championLevel, tickInterval = 0.5) {
                if (!enemy || enemy.dead || enemy.hp <= 0) return;

                let burn = enemy.championBurn;
                if (!burn) {
                    burn = enemy.championBurn = {};
                }
                burn.timer = Math.max(burn.timer || 0, duration);
                burn.tickInterval = tickInterval;
                burn.tickTimer = Math.min(burn.tickTimer ?? tickInterval, tickInterval * 0.5);
                burn.damagePerTick = Math.max(burn.damagePerTick || 0, damagePerTick);
                burn.lethalFloor = enemy === store.boss ? 0 : 1;
                burn.level = championLevel;
                burn.lastApplied = performance.now();
            }

            const FIRE_BURN_OFFSETS = Object.freeze([
                { x: -0.45, y: -0.35 },
                { x: 0.42, y: -0.3 },
                { x: -0.28, y: 0.28 },
                { x: 0.34, y: 0.32 },
                { x: 0.05, y: -0.55 }
            ]);

            function spawnLocalizedFireBurn(enemy, intensity = 0, overrides = {}) {
                if (!enemy || enemy.dead) return;
                const baseRadius = enemy.r || 18;
                const offsets = Array.isArray(overrides.offsets) && overrides.offsets.length ? overrides.offsets : FIRE_BURN_OFFSETS;
                const template = offsets[Math.floor(Math.random() * offsets.length)] || { x: 0, y: -0.4 };
                const offsetScale = overrides.offsetScale ?? 1;
                const offsetX = template.x * baseRadius * offsetScale;
                const offsetY = template.y * baseRadius * offsetScale;
                const anchor = overrides.anchor ?? enemy;
                const radiusScale = overrides.radiusScale ?? 0.6;
                const visualRadius = Math.max(6, baseRadius * radiusScale);
                store.activeEffects.push(createEffect('fireBurn', enemy.x + offsetX, enemy.y + offsetY, visualRadius, {
                    intensity,
                    anchor,
                    offset: { x: offsetX, y: offsetY },
                    follow: overrides.follow !== false
                }));
            }

            function applyFireBulletBurn(enemy, totalDamage, options = {}) {
                if (!enemy || enemy.dead || totalDamage <= 0) return;
                recordStackElementHit(enemy, 'fire');
                const duration = Number.isFinite(options.duration) ? Math.max(0.1, options.duration) : 5;
                const lethalFloor = enemy === store.boss ? 0 : 1;
                const burnEntry = {
                    duration,
                    elapsed: 0,
                    totalDamage,
                    appliedDamage: 0,
                    lethalFloor,
                    effectTimer: 0
                };
                if (!Array.isArray(enemy.fireBurns)) {
                    enemy.fireBurns = [];
                }
                enemy.fireBurns.push(burnEntry);
                spawnLocalizedFireBurn(enemy, 0, options.fireEffect || {});
            }

            function applyBossDamage(boss, amount, options = {}) {
                if (!boss || amount <= 0) return { amount: 0, blocked: false };

                if (boss.behavior === 'vibemaster') {
                    const vibeResult = applyVibemasterDamage(boss, amount, options);
                    if (vibeResult) {
                        return vibeResult;
                    }
                }

                if (boss.behavior === 'gemini') {
                    return applyGeminiBossDamage(boss, amount, options);
                }

                if (!options.skipShield && boss.behavior === 'aegis_architect') {
                    const result = applyAegisShieldDamage(boss, amount, options);
                    if (result && result.blocked) {
                        return { amount: result.damageApplied || 0, blocked: true };
                    }
                }

                boss.hp = Math.max(0, boss.hp - amount);
                store.world.totalDamage += amount;
                if (boss.hp <= 0) {
                    handleBossDefeat();
                }
                return { amount, blocked: false };
            }

            const ICE_SPEED_BY_STACK = [1, 0.55, 0.18, 0];

            function getVoidProfileForBullet(bullet) {
                if (!bullet || bullet.element !== 'void') return null;
                if (bullet.voidProfile && typeof bullet.voidProfile === 'object') {
                    return {
                        fire: !!bullet.voidProfile.fire,
                        ice: !!bullet.voidProfile.ice,
                        poison: !!bullet.voidProfile.poison
                    };
                }
                if (bullet.voidMode === 'random') {
                    const pick = CORE_ELEMENT_KEYS[Math.floor(Math.random() * CORE_ELEMENT_KEYS.length)];
                    return {
                        fire: pick === 'fire',
                        ice: pick === 'ice',
                        poison: pick === 'poison'
                    };
                }
                return { fire: true, ice: true, poison: true };
            }

            const VOID_PULSE_DAMAGE_SCALE = 0.55;

            function triggerVoidPulse(origin, baseDamage, bulletContext = {}) {
                if (!origin || !store) return;
                const originX = Number.isFinite(origin.x) ? origin.x : null;
                const originY = Number.isFinite(origin.y) ? origin.y : null;
                if (originX === null || originY === null) return;

                const playerRadius = store?.player?.r;
                const radius = Number.isFinite(playerRadius) ? playerRadius : 16;
                const damageScale = Number.isFinite(bulletContext.voidPulseDamageScale) ? bulletContext.voidPulseDamageScale : VOID_PULSE_DAMAGE_SCALE;
                const basePulseDamage = Math.max(0, baseDamage);
                const pulseDamage = Math.max(basePulseDamage * damageScale, 5);
                
                // Play void pulse sound with cooldown limiting
                playSound('voidpulse');

                const targets = [];
                if (Array.isArray(store.enemies)) {
                    for (let i = 0; i < store.enemies.length; i++) {
                        const enemy = store.enemies[i];
                        if (enemy && enemy !== origin) targets.push(enemy);
                    }
                }
                if (store.boss && store.boss !== origin && !store.boss.dead) {
                    targets.push(store.boss);
                }

                let affected = 0;
                const radiusSq = radius * radius;
                for (const target of targets) {
                    if (!target || target.dead || target.hp <= 0) continue;
                    const dx = target.x - originX;
                    const dy = target.y - originY;
                    if (!Number.isFinite(dx) || !Number.isFinite(dy)) continue;
                    if (dx * dx + dy * dy > radiusSq) continue;

                    const pseudoBullet = {
                        x: originX,
                        y: originY,
                        vx: 0,
                        vy: 0,
                        dmg: pulseDamage,
                        element: 'void',
                        pierce: 0,
                        col: '#201028',
                        voidMode: 'random',
                        isVoidPulseChild: true,
                        skipSplit: true,
                        isChampionShot: bulletContext.isChampionShot || false,
                        championLevel: bulletContext.championLevel,
                        spawnTime: bulletContext.spawnTime,
                        voidPulseDamageScale: damageScale
                    };

                    handleBulletImpact(pseudoBullet, target);
                    affected++;
                }

                if (!store.activeEffects) {
                    store.activeEffects = [];
                }
                store.activeEffects.push(createEffect('voidPulse', originX, originY, radius, {
                    affected,
                    baseDamage,
                    pulseDamage
                }));
            }

            function handleBulletImpact(b, e) {
                if (b.isFlame) e.slowTimer = 1.0;

                const isVoidElement = b.element === 'void';
                const voidProfile = isVoidElement ? getVoidProfileForBullet(b) : null;
                const isIceElement = b.element === 'ice' || (isVoidElement && voidProfile?.ice);
                const isPoisonElement = b.element === 'poison' || (isVoidElement && voidProfile?.poison);
                const isFireElement = b.element === 'fire' || (isVoidElement && voidProfile?.fire);
                const isVoidPulseChild = b.isVoidPulseChild === true;

                // Handle ice bullets - slow enemy and increase damage taken
                if (isIceElement) {
                    const currentStacks = ensureFiniteNumber(e.iceStacks, 0);
                    
                    // Cube Burglar requires 9 stacks to freeze, regular enemies need 3
                    const isCubeBurglar = e.type === 'cube_burglar';
                    const freezeThreshold = isCubeBurglar ? 9 : 3;
                    const maxStacks = isCubeBurglar ? 9 : 5; // Increased to 5 for regular enemies
                    
                    const nextStacks = (isVoidElement && voidProfile?.ice) ? freezeThreshold : Math.min(maxStacks, currentStacks + 1);
                    e.iceStacks = nextStacks;
                    const iceDuration = (isVoidElement && voidProfile?.ice) ? 4.5 : 3.0;
                    e.iceStackTimer = Math.max(e.iceStackTimer || 0, iceDuration);

                    // Bosses can be slowed but never frozen
                    const isBoss = e === store.boss || e.isBoss;
                    
                    // Determine slow/freeze effect
                    if (isBoss) {
                        // Bosses: Only apply slow (up to 3 stacks for damage), never freeze
                        const slowStacks = Math.min(3, nextStacks);
                        const targetSpeed = ICE_SPEED_BY_STACK[slowStacks] ?? 0;
                        const currentSpeed = e.speedMultiplier ?? 1;
                        e.speedMultiplier = Math.min(currentSpeed, targetSpeed);
                        // Never set isFrozen for bosses
                        if (e.isFrozen) delete e.isFrozen;
                    } else if (isCubeBurglar) {
                        // Cube Burglar: Freeze at 9 stacks for 2 seconds
                        if (nextStacks >= 9) {
                            e.isFrozen = true;
                            e.speedMultiplier = 0;
                            e.freezeAppliedAt = performance.now();
                            e.burglarFreezeTimer = 2.0; // 2 second freeze
                        } else {
                            // Apply slow based on first 3 stacks (for damage)
                            const slowStacks = Math.min(3, nextStacks);
                            const targetSpeed = ICE_SPEED_BY_STACK[slowStacks] ?? 0;
                            const currentSpeed = e.speedMultiplier ?? 1;
                            e.speedMultiplier = Math.min(currentSpeed, targetSpeed);
                            if (e.isFrozen) delete e.isFrozen;
                        }
                    } else {
                        // Regular enemies: Freeze at 3 stacks
                        const targetSpeed = ICE_SPEED_BY_STACK[nextStacks] ?? 0;
                        if (nextStacks >= 3) {
                            e.isFrozen = true;
                            e.speedMultiplier = 0;
                            e.freezeAppliedAt = performance.now();
                        } else {
                            const currentSpeed = e.speedMultiplier ?? 1;
                            e.speedMultiplier = Math.min(currentSpeed, targetSpeed);
                            if (e.isFrozen) {
                                delete e.isFrozen;
                            }
                        }
                    }
                }

                // Handle poison bullets - damage over time with stacking
                let pendingPoison = null;
                if (isPoisonElement) {
                    const currentPoisonStacks = ensureFiniteNumber(e.poisonStacks, 0);
                    const nextPoisonStacks = (isVoidElement && voidProfile?.poison) ? 5 : Math.min(5, currentPoisonStacks + 1); // Increased to 5 stacks
                    e.poisonStacks = nextPoisonStacks;
                    const poisonDuration = (isVoidElement && voidProfile?.poison) ? 4.5 : 3.0;
                    e.poisonStackTimer = Math.max(e.poisonStackTimer || 0, poisonDuration);

                    const bossReduction = e.isBoss ? 0.75 : 1.0;
                    pendingPoison = {
                        bossReduction,
                        baseDamage: b.dmg || 0
                    };
                    e.poisonTickInterval = 0.1;
                    e.poisonLastTick = 0;
                }

                if (isFireElement) {
                    const currentFireStacks = ensureFiniteNumber(e.fireStacks, 0);
                    const nextFireStacks = (isVoidElement && voidProfile?.fire) ? 5 : currentFireStacks; // Increased to 5 for void
                    if (nextFireStacks !== currentFireStacks) {
                        e.fireStacks = nextFireStacks;
                    }
                    if (nextFireStacks > 0 && (isVoidElement && voidProfile?.fire)) {
                        const fireDuration = 4.5;
                        e.fireStackTimer = Math.max(e.fireStackTimer || 0, fireDuration);
                        if (nextFireStacks >= 5) { // Increased to 5
                            e.firePanicActive = true;
                            e.firePanicTimer = Math.max(e.firePanicTimer || 0, 2.0);
                            if (!e.firePanicPhase) e.firePanicPhase = 'burst';
                        }
                    }
                }

                if (e.isHeatDeath) {
                    b.dead = true;
                    return;
                }

                if (e === store.boss && e.isInvincible) {
                    b.dead = true;
                    return;
                }

                if (b.piercedIds) {
                    const targetId = (e && (e.id ?? e._id ?? e.enemyId)) ?? null;
                    if (targetId !== null) {
                        if (b.piercedIds.has(targetId)) {
                            return;
                        }
                        b.piercedIds.add(targetId);
                    }
                }

                let dmg = b.dmg || 15;

                // Void bullets should deal at least 3x damage (equivalent to 3 separate element shots)
                if (isVoidElement) {
                    dmg *= 3;
                }

                if (isVoidElement) {
                    if (voidProfile) {
                        CORE_ELEMENT_KEYS.forEach(key => {
                            if (voidProfile[key]) {
                                recordStackElementHit(e, key);
                            }
                        });
                    }
                } else if (b.element) {
                    recordStackElementHit(e, b.element);
                }
                
                // Lava blades do more damage the closer the enemy is to the player
                if (b.isLavaBlade && store.player) {
                    const distToPlayer = Math.hypot(e.x - store.player.x, e.y - store.player.y);
                    // Steep damage dropoff: full damage at 125px, minimal at 200px
                    let damageMultiplier = 1;
                    if (distToPlayer <= 125) {
                        damageMultiplier = 3; // Full damage up to 125px
                    } else if (distToPlayer <= 200) {
                        // Sharp falloff from 125-200px: 3x down to 0.5x
                        const falloffFactor = (200 - distToPlayer) / 75; // 75px range for falloff
                        damageMultiplier = 0.5 + (falloffFactor * 2.5); // 0.5x to 3x
                    } else {
                        damageMultiplier = 0; // No damage beyond 200px
                    }
                    dmg *= damageMultiplier;
                }
                
                if (b.isChampionShot && b.vulnerabilityProfile && e) {
                    dmg = applyChampionVulnerabilityScaling(dmg, e, b.vulnerabilityProfile);
                }
                let didCrit = false;
                let impactPoint = null;
                let skipDefaultDamage = false;
                let skipDefaultDeathHandling = false;
                let actualDamageApplied = 0;
                if (e === store.boss && b.isDrone) dmg *= 0.4;

                if (Math.random() < store.player.critChance) {
                    dmg *= store.player.critDamage;
                    didCrit = true;
                    store.activeEffects.push(createEffect('critText', e.x, e.y));
                    if (Math.random() < 0.05) spawnPowerup(e.x, e.y);
                    
                    // LIGHTNING CRIT SOUND - for arc_cannon and stormbringer/chain lightning
                    if ((b.championAttackModule === 'arc_cannon' || b.championAttackModule === 'storm_grid' || 
                         store.player.subclass === 'stormbringer') && 
                        store.player.upgradeLevels.hit > 0) {
                        const now = performance.now();
                        const crackCooldown = SOUND_COOLDOWNS.lightningCrit;
                        // Reduce cooldown based on hit upgrades (more upgrades = more frequent crits can sound)
                        const adjustedCooldown = Math.max(200, crackCooldown - (store.player.upgradeLevels.hit * 30));
                        if (now - lastLightningCritTime >= adjustedCooldown) {
                            playSound('lightningCrit');
                            lastLightningCritTime = now;
                            consecutiveLightningCrits++;
                        }
                    }
                }

                if (e === store.boss) playSound('hit');
                const subclass = store.player.subclass;
                let bulletTags;
                switch (subclass) {
                    case 'juggernaut':
                        bulletTags = ['fire', 'explosive'];
                        break;
                    case 'marauder':
                        bulletTags = ['kinetic', 'concussive'];
                        break;
                    case 'railgunner':
                        bulletTags = ['kinetic', 'explosive'];
                        break;
                    case 'demolitioner':
                        bulletTags = ['fire', 'explosive'];
                        break;
                    case 'phasestriker':
                        bulletTags = ['void', 'magic'];
                        break;
                    case 'stormbringer':
                        bulletTags = ['lightning', 'magic'];
                        break;
                    default:
                        bulletTags = b.explosive ? ['fire', 'explosive'] : ['kinetic'];
                }
                const vulnBullet = applySubclassVulnerability(e, dmg, {
                    subclass,
                    player: store.player,
                    damageTags: bulletTags,
                    source: b.explosive ? 'explosiveBullet' : 'bullet',
                    projectile: b,
                    baseDamage: dmg
                });
                dmg = vulnBullet.damage;

                // Apply ice damage multiplier bonus (10% per stack)
                if (e.iceDamageMultiplier && e.iceDamageMultiplier > 1) {
                    dmg *= e.iceDamageMultiplier;
                }

                if (e.type === 'cube_burglar') {
                    const cubeResult = applyCubeBurglarHit(e, b, dmg);
                    if (!cubeResult.hit) {
                        consumeBulletPierce(b);
                        return;
                    }
                    dmg = cubeResult.damageApplied;
                    actualDamageApplied = cubeResult.damageApplied;
                    if (cubeResult.impactPoint) {
                        impactPoint = cubeResult.impactPoint;
                    }
                    skipDefaultDamage = true;
                    skipDefaultDeathHandling = true;
                }
                if (e === store.boss && e.behavior === 'aegis_architect') {
                    const interceptResult = tryAegisShieldInterceptBullet(e, b, dmg);
                    if (interceptResult && interceptResult.blocked) {
                        if (store.player.pilotGenome === 'beef') {
                            store.player.beefShieldDamageDealt += interceptResult.damageApplied;
                        }
                        if (store.player.vampirism > 0) {
                            let healAmount = interceptResult.damageApplied * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1);
                            healAmount = Math.min(healAmount, 5);
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        if (b.isChampionShot) {
                            applyChampionOnHitEffects(b, e, {
                                baseDamage: b.dmg || dmg,
                                finalDamage: interceptResult.damageApplied,
                                championLevel: b.championLevel || (store.playerChampion?.level || 1)
                            });
                        }
                        return;
                    }
                }

                if (e === store.boss) {
                    const bossOptions = {
                        point: { x: b.x, y: b.y },
                        skipShield: true
                    };
                    if (e.behavior === 'gemini') {
                        const hitInfo = testGeminiBulletCollision(e, b);
                        if (hitInfo) {
                            bossOptions.subBoss = hitInfo.id;
                            impactPoint = impactPoint || { x: hitInfo.x, y: hitInfo.y };
                        }
                    }
                    const bossDamageResult = applyBossDamage(e, dmg, bossOptions);
                    dmg = bossDamageResult.amount;
                    actualDamageApplied = bossDamageResult.amount;
                } else if (!skipDefaultDamage) {
                    const prevHp = e.hp;
                    e.hp -= dmg;
                    actualDamageApplied = Math.max(0, prevHp - e.hp);
                    // Mark hunter as just hit for gang abilities (Crimson Vipers lunge)
                    if (e.type === 'hunter' && e.gang && e.gang.ability === 'lunge') {
                        e.wasJustHit = true;
                    }
                }

                if (pendingPoison) {
                    const baseForPoison = Math.max(actualDamageApplied, pendingPoison.baseDamage);
                    const damagePerStack = baseForPoison * 0.1 * pendingPoison.bossReduction;
                    if (damagePerStack > 0) {
                        e.poisonDamagePerStack = damagePerStack;
                    }
                }

                if (dmg > 0) {
                    const impactTime = performance.now();
                    if (isVoidElement && !isVoidPulseChild && actualDamageApplied > 0) {
                        triggerVoidPulse(e, actualDamageApplied, {
                            isChampionShot: b.isChampionShot,
                            championLevel: b.championLevel,
                            spawnTime: b.spawnTime,
                            voidPulseDamageScale: b.voidPulseDamageScale
                        });
                    }
                    if (e !== store.boss) {
                        e.hitCount = ensureFiniteNumber(e.hitCount, 0) + 1;
                        if (!e.firstDamageTime) {
                            e.firstDamageTime = impactTime;
                        }
                        e.lastDamageTime = impactTime;
                    }
                    const hitX = impactPoint ? impactPoint.x : e.x;
                    const hitY = impactPoint ? impactPoint.y : e.y;
                    const impactAngle = Math.atan2(hitY - b.y, hitX - b.x);
                    registerEnemyHit(e, {
                        angle: impactAngle,
                        knockbackStrength: 0,
                        shakeIntensity: b.explosive ? 6 : 3.5,
                        shakeDuration: b.explosive ? 0.22 : 0.14,
                        slowFactor: b.explosive ? 0.8 : 0.9,
                        slowDuration: b.explosive ? 0.22 : 0.12,
                        crit: didCrit,
                        effect: false
                    });

                    // Fragment blast hits get gold spark effect + knockback + slow + gold tint
                    if (b.isFragment) {
                        const sourceX = Number.isFinite(b.originX) ? b.originX : hitX - Math.cos(impactAngle) * 12;
                        const sourceY = Number.isFinite(b.originY) ? b.originY : hitY - Math.sin(impactAngle) * 12;
                        const impactSpeed = Math.hypot(Number.isFinite(b.vx) ? b.vx : 0, Number.isFinite(b.vy) ? b.vy : 0);
                        const travelDistance = Math.hypot(hitX - sourceX, hitY - sourceY);
                        
                        // Neon orange/pink pulse effect on impact
                        store.activeEffects.push(createEffect('fragPulse', hitX, hitY, 35, {
                            duration: 0.35
                        }));
                        
                        store.activeEffects.push(createEffect('fragmentBlast', hitX, hitY, 0, {
                            color: '#FFD700',
                            explosionCount: 15,
                            splashCount: 25,
                            sourceX,
                            sourceY,
                            impactAngle,
                            impactSpeed,
                            travelDistance
                        }));
                        
                        // Knockback from fragment blast
                        const knockbackDir = Math.atan2(e.y - b.y, e.x - b.x);
                        e.knockback = e.knockback || {};
                        e.knockback.vx = Math.cos(knockbackDir) * 200; // Increased from 160
                        e.knockback.vy = Math.sin(knockbackDir) * 200;
                        e.knockback.type = 'impact';
                        e.knockback.duration = 0.18;
                        e.knockback.timer = 0.18;
                        
                        // Slow effect for 3 seconds
                        e.fragmentBlastSlowFactor = 0.65;
                        e.fragmentBlastSlowTimer = 3.0;
                        e.fragmentBlastGoldTint = true;
                    }

                    if (e === store.boss || e.type === 'cube_burglar') {
                        const isBurglar = e.type === 'cube_burglar';
                        const particleColor = e.hitParticleColor || e.color || b.col || '#ffd966';
                        spawnHitParticles(hitX, hitY, particleColor, {
                            count: isBurglar ? 10 : 22,
                            scale: isBurglar ? 0.55 : 1,
                            type: 'explosion'
                        });
                    }

                    if (store.player.pilotGenome === 'beef') {
                        store.player.beefShieldDamageDealt += dmg;
                    }

                    if (store.player.vampirism > 0) {
                        let healAmount = dmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 1);
                        healAmount = Math.min(healAmount, 5);
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }

                    if (b.isChampionShot) {
                        applyChampionOnHitEffects(b, e, {
                            baseDamage: b.dmg || dmg,
                            finalDamage: dmg,
                            championLevel: b.championLevel || (store.playerChampion?.level || 1)
                        });
                    }

                    if (isFireElement) {
                        const burnTotal = Math.max(0, dmg * 0.4);
                        if (burnTotal > 0) {
                            applyFireBulletBurn(e, burnTotal, { duration: 5 });
                        }
                    }

                    let deathElement = null;
                    if (e !== store.boss && e.hp <= 0 && !skipDefaultDeathHandling) {
                        deathElement = getStackDeathType(e, { fallbackElement: b.element });
                        e.deathElement = deathElement;
                        e.dead = true;
                        
                        // Play enemy-specific death sounds
                        if (e.type === 'mech' || e.type === 'mech_elite') {
                            playSound('robotCrumble'); // Mechanical enemies
                        } else if (e.type === 'angler' || e.type === 'manta') {
                            playSound('snakeHiss'); // Aquatic/serpentine enemies
                        } else if (e.type === 'avian_hatchling' || e.type === 'trap_king_add') {
                            playSound('bugSqueal'); // Small bug-like enemies
                        } else {
                            playSound('farExplosion'); // General enemy death
                        }
                        
                        if (e.type === 'void_champion') {
                            store.enemies.forEach(minion => {
                                if (minion.orbitTargetId === e.id && !minion.dead) {
                                    spawnGibs(minion.x, minion.y, minion.color);
                                    minion.dead = true;
                                }
                            });
                            handleVoidChampionReward(e);
                        }

                        if (e.type === 'shadow_champion') {
                            store.shadowChampionDefeated = true;
                            store.shadowChampionLastPos = { x: e.x, y: e.y };
                            store.shadowChampionId = null;
                            if (!store.shadowChampionTokenDropped) {
                                addShadowEcho(e.x, e.y);
                                announce('Champion sigil destabilized!');
                            }
                        }

                        const isVoidReaper = e.type === 'void_reaper';
                        if (isVoidReaper) {
                            finalizeVoidReaperDefeat(e, { preemptive: !e.lungeStarted });
                        }

                        if (!isVoidReaper && deathElement === 'ice') {
                            spawnIceShards(e.x, e.y, {
                                enemyRadius: e.r || 18
                            });
                            // Play ice break sound every other enemy with proper alternation
                            const now = performance.now();
                            if (now - lastIceBreakTime >= 1000) { // One second cooldown
                                const soundName = iceBreakSoundIndex === 0 ? 'icebreak1' : 'icebreak2';
                                playSound(soundName);
                                iceBreakSoundIndex = 1 - iceBreakSoundIndex; // Toggle between 0 and 1
                                lastIceBreakTime = now;
                            }
                        } else if (!isVoidReaper && deathElement === 'fire') {
                            spawnFireWipeDeath(e.x, e.y, {
                                enemyRadius: e.r || 18,
                                baseColor: e.color
                            });
                            // Fire is contagious - spread to nearby enemies (including from void bullets)
                            const spreadRadius = 120;
                            const spreadDamage = (e.poisonDamagePerStack || 10) * 0.8; // 80% of poison tick damage as fire spread
                            store.enemies.forEach(nearbyEnemy => {
                                if (nearbyEnemy === e || nearbyEnemy.dead) return;
                                const dx = nearbyEnemy.x - e.x;
                                const dy = nearbyEnemy.y - e.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist <= spreadRadius) {
                                    // Ignite nearby enemy with fire stacks
                                    nearbyEnemy.fireStacks = 5; // Increased to 5
                                    nearbyEnemy.fireStackTimer = 3.0;
                                    if (spreadDamage > 0) {
                                        applyFireBulletBurn(nearbyEnemy, spreadDamage, { duration: 3 });
                                    }
                                }
                            });
                        } else if (!isVoidReaper) {
                            spawnGibs(e.x, e.y, e.color);
                        }
                        const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                        const scoreGain = Math.floor((Number.isFinite(e.score) ? e.score : 0) * collarBonus);
                        const goldGain = Math.floor((Number.isFinite(e.gold) ? e.gold : 0) * collarBonus);
                        
                        // Increase XP generation after 5th boss (wave 25+)
                        let xpBase = Number.isFinite(e.xp) ? e.xp : 0;
                        if (store.world.wave >= 25) {
                            const wavesAfter25 = store.world.wave - 25;
                            const xpMultiplier = 1 + (wavesAfter25 * 0.05); // +5% per wave after 25
                            xpBase *= xpMultiplier;
                        }
                        const xpGain = Math.floor(xpBase * collarBonus);
                        
                        if (scoreGain) store.world.score += scoreGain;
                        if (goldGain) addWorldGold(goldGain);
                        if (xpGain) awardXp(xpGain); // Apply XP diminishing returns
                        store.world.kills++;

                        if (e.type !== 'shadow_champion') {
                            spawnPowerup(e.x, e.y);
                        }
                        explode(e.x, e.y);

                        applyRapidEnemyAdaptation(e, impactTime);
                    }
                }
                
                if (b.explosive) explode(b.x, b.y, false, true);
                consumeBulletPierce(b);
            }

            function updatePlayerProjectile(b, dt, bossTarget, state) {
                if (!b) return;

                const sharedState = state || { autoBlinkTriggered: false };

                b.x += b.vx * dt;
                b.y += b.vy * dt;

                if (b.isFragment) {
                    b.lifetime = (b.lifetime || 0) + dt;
                    if (b.lifetime >= b.maxLifetime) {
                        b.dead = true;
                    }
                    if (!Number.isFinite(b.originX)) b.originX = b.x;
                    if (!Number.isFinite(b.originY)) b.originY = b.y;
                    b.impactAngle = Math.atan2(b.vy, b.vx);
                }

                if (b.isSwirl) {
                    b.life = (b.life || 0) + dt;
                    b.x += Math.sin(b.life * 15) * 150 * dt;
                }

                if (b.isFlame) {
                    b.life -= dt;
                    if (b.life <= 0) b.dead = true;
                    b.particleSpawnT -= dt;
                    if (b.particleSpawnT <= 0) {
                        b.particleSpawnT = b.isLavaBlade ? 0.1 : 0.05;
                        const life = 0.3 + Math.random() * 0.3;
                        const angle = Math.random() * 2 * Math.PI;
                        const speed = b.isLavaBlade ? 12 + Math.random() * 12 : 20 + Math.random() * 20;
                        if (!Array.isArray(b.particles)) b.particles = [];
                        b.particles.push({
                            x: 0,
                            y: 0,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life,
                            maxLife: life,
                            r: 1 + Math.random() * (b.isLavaBlade ? 1.4 : 2)
                        });
                    }
                    b.particles = b.particles.filter(p => {
                        p.life -= dt;
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        return p.life > 0;
                    });
                } else if (b.element === 'ice' || b.element === 'poison') {
                    // Spawn trail particles for elemental bullets
                    b.particleSpawnT = (b.particleSpawnT || 0) - dt;
                    if (b.particleSpawnT <= 0) {
                        b.particleSpawnT = b.element === 'ice' ? 0.015 : 0.025; // Ice spawns more frequently for dense mist
                        const life = 0.25 + Math.random() * 0.2;
                        const spreadAngle = (Math.random() - 0.5) * 0.4;
                        const spreadSpeed = (Math.random() - 0.5) * 30;
                        if (!Array.isArray(b.particles)) b.particles = [];
                        b.particles.push({
                            x: 0,
                            y: 0,
                            vx: spreadSpeed,
                            vy: spreadSpeed,
                            life,
                            maxLife: life,
                            r: b.element === 'ice' ? (1.2 + Math.random() * 0.8) : (1.5 + Math.random() * 1.5)
                        });
                    }
                    b.particles = b.particles.filter(p => {
                        p.life -= dt;
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        return p.life > 0;
                    });
                } else if (b.element === 'void') {
                    b.particleSpawnT = (b.particleSpawnT || 0) - dt;
                    if (b.particleSpawnT <= 0) {
                        b.particleSpawnT = 0.02;
                        const life = 0.24 + Math.random() * 0.22;
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 18 + Math.random() * 26;
                        if (!Array.isArray(b.particles)) b.particles = [];
                        b.particles.push({
                            x: 0,
                            y: 0,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life,
                            maxLife: life,
                            r: 1.4 + Math.random() * 1.4,
                            spin: Math.random() * Math.PI * 2
                        });
                    }
                    b.particles = b.particles.filter(p => {
                        p.life -= dt;
                        p.spin = (p.spin || 0) + dt * 6.5;
                        p.vx *= 0.9;
                        p.vy *= 0.9;
                        p.x += p.vx * dt + Math.cos(p.spin) * 12 * dt;
                        p.y += p.vy * dt + Math.sin(p.spin) * 12 * dt;
                        return p.life > 0;
                    });
                } else if (b.element === 'fire') {
                    b.particleSpawnT = (b.particleSpawnT || 0) - dt;
                    if (b.particleSpawnT <= 0) {
                        b.particleSpawnT = 0.02;
                        const life = 0.18 + Math.random() * 0.18;
                        if (!Array.isArray(b.particles)) b.particles = [];
                        b.particles.push({
                            x: 0,
                            y: 0,
                            vx: (Math.random() - 0.5) * 28,
                            vy: (Math.random() - 0.5) * 28,
                            life,
                            maxLife: life,
                            r: 1 + Math.random() * 1.4
                        });
                    }
                    b.particles = b.particles.filter(p => {
                        p.life -= dt;
                        p.x += p.vx * dt;
                        p.y += p.vy * dt;
                        return p.life > 0;
                    });
                } else if (b.isLevelUpPulse) {
                    b.life -= dt;
                    if (b.life <= 0) b.dead = true;
                }

                // Ricochet handling - bounce off boundaries
                const ricochetLevel = store.player ? (store.player.ricochetLevel || (store.player.hasRicochet ? 1 : 0)) : 0;
                const canRicochet = b.canRicochet !== undefined ? b.canRicochet : ricochetLevel >= 2;
                if (ricochetLevel > 0 && canRicochet && !b.hasRicocheted && !b.isFragment && !b.isFlame && !b.isLavaBlade && !b.isLevelUpPulse && !b.dead) {
                    let bounced = false;
                    const margin = 5;
                    const travelDistance = 200; // Distance bullet can travel after bounce
                    
                    // Check horizontal boundaries
                    if (b.x <= margin && b.vx < 0) {
                        b.vx = -b.vx * 0.85; // Reverse and slow down by 15%
                        b.x = margin + 1; // Push slightly inward to avoid re-triggering
                        bounced = true;
                    } else if (b.x >= W - margin && b.vx > 0) {
                        b.vx = -b.vx * 0.85;
                        b.x = W - margin - 1;
                        bounced = true;
                    }
                    
                    // Check vertical boundaries
                    if (b.y <= margin && b.vy < 0) {
                        b.vy = -b.vy * 0.85;
                        b.y = margin + 1;
                        bounced = true;
                    } else if (b.y >= H - margin && b.vy > 0) {
                        b.vy = -b.vy * 0.85;
                        b.y = H - margin - 1;
                        bounced = true;
                    }
                    
                    if (bounced) {
                        b.hasRicocheted = true;
                        const originalDmg = b.originalDmg || b.dmg;
                        b.originalDmg = originalDmg;
                        b.dmg = originalDmg * 0.3; // Set to 30% of original (not multiply current)
                        b.ricochetDist = 0; // Track distance traveled after ricochet
                        b.maxRicochetDist = travelDistance;
                        // Visual indicator - change color slightly
                        if (b.col === "#b266ff") b.col = "#9955dd";
                        else if (b.col === "#cc99ff") b.col = "#bb88ee";
                        else if (b.col === "#ED2F32") b.col = "#cc2820";
                    }
                }
                
                // Track ricochet travel distance and kill bullet when it exceeds limit
                if (b.hasRicocheted && !b.dead) {
                    const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                    b.ricochetDist = (b.ricochetDist || 0) + speed * dt;
                    if (b.ricochetDist >= (b.maxRicochetDist || 200)) {
                        b.dead = true;
                    }
                }
                
                // Regular boundary check (kill bullets that go too far out)
                if (!b.dead && (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20)) {
                    b.dead = true;
                }

                if (!b.dead && bossTarget && !bossTarget.dead && collide(b, bossTarget)) {
                    handleBulletImpact(b, bossTarget);
                }

                if (!b.dead && store.enemies.length) {
                    const searchRadius = getBulletSearchRadius(b);
                    forEachEnemyNearby(b.x, b.y, searchRadius, enemy => {
                        if (enemy === bossTarget) return false;
                        if (!collide(b, enemy)) return false;
                        handleBulletImpact(b, enemy);
                        return b.dead && !b.pierce;
                    });
                }

                if (!b.dead && store.timeShards && store.timeShards.length) {
                    for (let si = store.timeShards.length - 1; si >= 0; si--) {
                        const shard = store.timeShards[si];
                        if (!shard || shard.dead) continue;
                        const hitRadius = (shard.r || 14) + (b.r || 3);
                        const dx = b.x - shard.x;
                        const dy = b.y - shard.y;
                        if (dx * dx + dy * dy > hitRadius * hitRadius) continue;

                        const damage = b.dmg || 12;
                        shard.hp -= damage;
                        shard.hitPulse = 0.22;
                        store.activeEffects.push(createEffect('hitSpark', shard.x, shard.y, (shard.r || 14) * 1.6, { strength: 32 }));

                        if (shard.hp <= 0) {
                            applyTimeShardBuff(shard.buffStacks || 1);
                            store.activeEffects.push(createEffect('spawnTeleport', shard.x, shard.y, 36, { color: '#9df7ff', duration: 0.32 }));
                            playSound('stargun');
                            store.timeShards.splice(si, 1);
                        }

                        consumeBulletPierce(b);
                        break;
                    }
                }
                
                // Tombstone collision
                if (!b.dead && store.tombstones && store.tombstones.length) {
                    for (let ti = store.tombstones.length - 1; ti >= 0; ti--) {
                        const tomb = store.tombstones[ti];
                        if (!tomb || tomb.dead || tomb.hp <= 0) continue;
                        const hitRadius = (tomb.r || 20) + (b.r || 3);
                        const dx = b.x - tomb.x;
                        const dy = b.y - tomb.y;
                        if (dx * dx + dy * dy > hitRadius * hitRadius) continue;

                        const damage = b.dmg || 12;
                        tomb.hp -= damage;
                        store.activeEffects.push(createEffect('hitSpark', tomb.x, tomb.y, (tomb.r || 20) * 1.2, { strength: 28 }));
                        
                        if (tomb.hp <= 0) {
                            tomb.dead = true;
                            spawnGibs(tomb.x, tomb.y, tomb.color);
                            store.activeEffects.push(createEffect('enemyExplosion', tomb.x, tomb.y, tomb.r * 2));
                            playSound('explosion');
                        }

                        consumeBulletPierce(b);
                        break;
                    }
                }

                if (!b.dead && store.mechPuddles && store.mechPuddles.length) {
                    for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
                        const puddle = store.mechPuddles[i];
                        const dx = b.x - puddle.x;
                        const dy = b.y - puddle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < puddle.r + (b.r || 2)) {
                            puddle.hp -= (b.dmg || 15);

                            if (puddle.hp <= 0) {
                                addWorldGold(1);
                                awardXp(1); // Apply XP diminishing returns

                                for (let j = 0; j < 5; j++) {
                                    store.flameParticles.push({
                                        x: puddle.x + (Math.random() - 0.5) * 20,
                                        y: puddle.y + (Math.random() - 0.5) * 20,
                                        vx: (Math.random() - 0.5) * 100,
                                        vy: -Math.random() * 100,
                                        life: 0.3 + Math.random() * 0.3,
                                        maxLife: 0.3 + Math.random() * 0.3,
                                        r: 2 + Math.random() * 3,
                                        update: function (delta) {
                                            this.life -= delta;
                                            this.x += this.vx * delta;
                                            this.y += this.vy * delta;
                                            this.vy += 200 * delta;
                                            return this.life > 0;
                                        },
                                        draw: function (ctx) {
                                            ctx.fillStyle = 'rgba(255, 120, 50, 0.8)';
                                            ctx.beginPath();
                                            ctx.arc(this.x, this.y, this.r * (this.life / this.maxLife), 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    });
                                }

                                store.mechPuddles.splice(i, 1);
                            }

                            consumeBulletPierce(b);
                            break;
                        }
                    }
                }

                if (!sharedState.autoBlinkTriggered && !b.dead) {
                    if (attemptAutoBlink(store.player, b)) {
                        sharedState.autoBlinkTriggered = true;
                    }
                }
            }

            const CLASS_DAMAGE_TAGS = {
                juggernaut: ['fire', 'explosive'],
                marauder: ['kinetic', 'concussive'],
                railgunner: ['kinetic', 'explosive'],
                demolitioner: ['fire', 'explosive'],
                phasestriker: ['void', 'magic'],
                stormbringer: ['lightning', 'magic']
            };

            const MARAUDER_VULNERABILITY_ALLOWED_SOURCES = new Set([
                'beefCharge',
                'beefChargeCombo',
                'missileImpact',
                'pierceMissile',
                'clusterMissile',
                'clusterDetonation',
                'voidLaser',
                'chainLightning'
            ]);

            function triggerJuggernautVulnerability(enemy, context) {
                enemy.jugFearTimer = Math.max(enemy.jugFearTimer || 0, 2.6);
                enemy.jugBurnTimer = Math.max(enemy.jugBurnTimer || 0, 3.5);
                enemy.jugBurnTick = 0;
                enemy.jugPulseTimer = Math.max(enemy.jugPulseTimer || 0, 3.0);
                enemy.jugPulsePhase = enemy.jugPulsePhase || 0;
                enemy.vulnerabilityPulseColor = '#ff3b3b';
                enemy.vulnerabilityPulseStrength = 1;
                store.activeEffects.push(createEffect('jugFearIgnite', enemy.x, enemy.y, enemy.r * 1.1));
            }

            function triggerMarauderVulnerability(enemy, context) {
                const angle = context.knockbackAngle ?? Math.atan2(enemy.y - store.player.y, enemy.x - store.player.x);
                const smashSpeed = 1100;
                const smashDuration = 0.55;
                enemy.knockback = {
                    vx: Math.cos(angle) * smashSpeed,
                    vy: Math.sin(angle) * smashSpeed,
                    duration: smashDuration,
                    type: 'maraLaunch'
                };
                enemy.maraLaunchTimer = smashDuration;
                enemy.maraImpactTriggered = false;
                enemy.vulnerabilityPulseColor = '#aad1ff';
                enemy.vulnerabilityPulseStrength = 0.8;
                store.activeEffects.push(createEffect('marauderLaunchTrail', enemy.x, enemy.y, { duration: smashDuration, enemy }));
            }

            function triggerRailgunnerVulnerability(enemy) {
                enemy.railgunArmorTimer = Math.max(enemy.railgunArmorTimer || 0, 4.0);
                enemy.railgunCrackLevel = Math.min((enemy.railgunCrackLevel || 0) + 1, 3);
                enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.35);
                enemy.vulnerabilityPulseColor = '#d7f0ff';
                enemy.vulnerabilityPulseStrength = 0.6;
                store.activeEffects.push(createEffect('armorCrackFlash', enemy.x, enemy.y, enemy.railgunCrackLevel));
            }

            function triggerDemolitionerVulnerability(enemy, context) {
                const fallbackPos = { x: enemy.x, y: enemy.y };
                const sourcePlayer = context.player || store.player;
                scheduleVulnerabilityEvent(0.7, () => {
                    const ref = enemy.dead ? fallbackPos : { x: enemy.x, y: enemy.y };
                    spawnFlamePulse(ref.x, ref.y, 95, context.baseDamage * 0.8, { player: sourcePlayer });
                });
                enemy.demolitionPulseWarmup = Math.max(enemy.demolitionPulseWarmup || 0, 0.7);
                enemy.vulnerabilityPulseColor = '#ffae5b';
                enemy.vulnerabilityPulseStrength = 0.7;
                store.activeEffects.push(createEffect('demolitionPulseCharge', enemy.x, enemy.y, enemy.r * 1.4));
            }

            function triggerPhaseStrikerVulnerability(enemy) {
                enemy.phaseLockTimer = Math.max(enemy.phaseLockTimer || 0, 2.4);
                enemy.phaseLockSlowFactor = 0.35;
                enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.5);
                enemy.vulnerabilityPulseColor = '#8f6bff';
                enemy.vulnerabilityPulseStrength = 0.9;
                store.activeEffects.push(createEffect('voidLockChains', enemy.x, enemy.y, enemy.r * 1.2));
            }

            function triggerStormbringerVulnerability(enemy, context) {
                enemy.stormShockTimer = Math.max(enemy.stormShockTimer || 0, 2.2);
                enemy.stormShockIntensity = 1;
                enemy.vulnerabilityPulseColor = '#6fd2ff';
                enemy.vulnerabilityPulseStrength = 1;
                store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, enemy.r * 1.5));
                const targets = store.enemies.filter(en => !en.dead && en !== enemy);
                const arcTargets = targets.sort((a, b) => ((a.x - enemy.x) ** 2 + (a.y - enemy.y) ** 2) - ((b.x - enemy.x) ** 2 + (b.y - enemy.y) ** 2)).slice(0, 3);
                arcTargets.forEach(target => {
                    store.activeEffects.push(createEffect('stormArc', enemy.x, enemy.y, { x: target.x, y: target.y }));
                    target.stunTimer = Math.max(target.stunTimer || 0, 0.3);
                });
            }

            const ENEMY_VULNERABILITIES = {
                mech: {
                    juggernaut: {
                        multiplier: 1.6,
                        damageTags: ['fire', 'explosive'],
                        cooldownMs: 500,
                        onTrigger: triggerJuggernautVulnerability
                    }
                },
                manta: {
                    marauder: {
                        multiplier: 1.45,
                        damageTags: ['kinetic', 'concussive'],
                        cooldownMs: 400,
                        onTrigger: triggerMarauderVulnerability
                    }
                },
                phantom: {
                    railgunner: {
                        multiplier: 1.4,
                        damageTags: ['kinetic', 'explosive'],
                        cooldownMs: 350,
                        onTrigger: triggerRailgunnerVulnerability
                    }
                },
                void_champion_orb: {
                    demolitioner: {
                        multiplier: 1.35,
                        damageTags: ['fire', 'explosive'],
                        cooldownMs: 650,
                        onTrigger: triggerDemolitionerVulnerability
                    }
                },
                void_champion: {
                    phasestriker: {
                        multiplier: 1.5,
                        damageTags: ['void', 'magic'],
                        cooldownMs: 500,
                        onTrigger: triggerPhaseStrikerVulnerability
                    }
                },
                angler: {
                    stormbringer: {
                        multiplier: 1.4,
                        damageTags: ['lightning', 'magic'],
                        cooldownMs: 450,
                        onTrigger: triggerStormbringerVulnerability
                    }
                }
            };

            function scheduleVulnerabilityEvent(delay, action) {
                store.vulnerabilityEvents.push({ timer: delay, action });
            }

            function processVulnerabilityEvents(dt) {
                for (let i = store.vulnerabilityEvents.length - 1; i >= 0; i--) {
                    const evt = store.vulnerabilityEvents[i];
                    evt.timer -= dt;
                    if (evt.timer <= 0) {
                        try {
                            evt.action?.();
                        } catch (err) {
                            // Vulnerability event error silenced
                        }
                        store.vulnerabilityEvents.splice(i, 1);
                    }
                }
            }

            function spawnFlamePulse(x, y, radius = 90, damage = 40, context = {}) {
                store.activeEffects.push(createEffect('delayedFlamePulse', x, y, radius));
                playSound('fireWhoosh'); // Play fire whoosh sound
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                targets.forEach(enemy => {
                    if (!enemy || enemy.dead) return;
                    const distSq = (enemy.x - x) * (enemy.x - x) + (enemy.y - y) * (enemy.y - y);
                    if (distSq <= radius * radius) {
                        let dmg = damage;
                        if (enemy === store.boss) dmg *= 0.35;
                        const vuln = applySubclassVulnerability(enemy, dmg, {
                            subclass: 'demolitioner',
                            damageTags: ['fire', 'explosive'],
                            player: context.player,
                            source: 'demolitionPulse',
                            disableVulnerability: true
                        });
                        let applied = vuln.damage;
                        if (enemy === store.boss) {
                            const result = applyBossDamage(enemy, applied, {
                                point: { x, y }
                            });
                            if (result.blocked || result.amount <= 0) {
                                applied = 0;
                            } else {
                                applied = result.amount;
                            }
                        } else {
                            enemy.hp -= applied;
                        }

                        // Flame particles removed per user request - pulse visual effect remains
                    }
                });
            }

            function applySubclassVulnerability(enemy, baseDamage, context = {}) {
                if (context.disableVulnerability) {
                    return { damage: baseDamage, triggered: false };
                }

                const player = context.player || store.player;
                if (!player) {
                    return { damage: baseDamage, triggered: false };
                }

                const subclass = context.subclass || player.subclass;
                if (!subclass) {
                    return { damage: baseDamage, triggered: false };
                }

                const config = ENEMY_VULNERABILITIES[enemy.type];
                const subclassConfig = config && config[subclass];
                if (!subclassConfig) {
                    return { damage: baseDamage, triggered: false };
                }

                const appliedTags = context.damageTags || CLASS_DAMAGE_TAGS[subclass] || [];
                const matchesTag = appliedTags.some(tag => subclassConfig.damageTags.includes(tag));
                if (!matchesTag) {
                    return { damage: baseDamage, triggered: false };
                }

                const allowTriggerOverride = context.allowVulnerabilityTrigger;
                let allowTrigger = allowTriggerOverride !== undefined ? !!allowTriggerOverride : true;
                if (allowTrigger && subclass === 'marauder') {
                    const source = context.source;
                    if (!MARAUDER_VULNERABILITY_ALLOWED_SOURCES.has(source) && !context.forceVulnerabilityTrigger) {
                        allowTrigger = false;
                    }
                }

                enemy._lastVulnerabilityTrigger = enemy._lastVulnerabilityTrigger || {};
                const now = performance.now();
                const cooldown = subclassConfig.cooldownMs ?? 350;
                const lastTrigger = enemy._lastVulnerabilityTrigger[subclass] || 0;
                let triggered = false;
                if (allowTrigger && now - lastTrigger >= cooldown) {
                    enemy._lastVulnerabilityTrigger[subclass] = now;
                    triggered = true;
                    if (subclassConfig.onTrigger) {
                        subclassConfig.onTrigger(enemy, { ...context, baseDamage, player });
                    }
                }

                const damage = baseDamage * (subclassConfig.multiplier || 1);
                return { damage, triggered };
            }

            const LEVEL_UPGRADES = [
                { id: 'dmg', name: 'PLASMA CORE', icon: 'ðŸ’¥', desc: '+6% damage', apply: () => { store.player.dmgMult *= 1.06; } },
                { id: 'fire', name: 'OVERCLOCK', icon: 'ðŸ”¥', desc: '+6% fire rate', apply: () => { store.player.fireRate *= 0.60; } },
                {
                    id: 'multi', name: 'SCATTER PROTOCOL', icon: 'â˜„ï¸', desc: '+1 projectile', apply: () => {
                        const p = store.player;
                        if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                    }
                },
                { id: 'shield', name: 'VOID BARRIER', icon: 'ðŸ©µ', desc: 'BIG Shields', apply: () => { store.player.shieldMax *= 1.15 ; store.player.shieldMax += 50 ; store.player.shield = store.player.shieldMax; } },
                { id: 'flamethrower', name: 'LAVA BLADES', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d="M0 179.3c0 7 5.7 12.7 12.7 12.7L477.5 192 519 0 352 0C114.8 0 15 151.1 1.6 173.3 .5 175.1 0 177.1 0 179.3z"/><path d="M456.7 288L519 0 534.9 0c25.5 0 44.5 23.5 39.1 48.4L479.3 486.7c-3.7 17.3-20.7 28.3-38 24.6s-28.3-20.7-24.6-38L442.9 352 352 352c-17.7 0-32-14.3-32-32s14.3-32 32-32l104.7 0z"/></svg>', desc: 'Launches electric cyberpunk lava blades in a cone. Great for up-close enemies.', apply: () => { store.player.flamethrowerLevel++; } }
            ];

            const KNOCKBACK_SHIELD_CONFIG = {
                radius: 440,
                proximityTriggerRadius: 180,
                chargeCooldown: 30,
                globalCooldown: 4.5,
                maxCharges: 3,
                orbitRadius: 34,
                orbitSpeed: 0.95,
                knockbackStrength: 720,
                knockbackDuration: 0.32,
                stunDuration: 0.8,
                slowFactor: 0.65,
                slowDuration: 1.8,
                projectilePurgeRadiusRatio: 0.55,
                screenFlashColor: 'rgba(40, 40, 55, 0.4)',
                contactRadius: 24,
                contactEnemyRadiusScale: 0.6,
                nonBeefRadiusMultiplier: 0.45,
                nonBeefKnockbackMultiplier: 0.4,
                nonBeefStunMultiplier: 0.35,
                nonBeefSlowDurationMultiplier: 0.5,
                nonBeefSlowEffectMultiplier: 0.5,
                nonBeefScreenFlashColor: 'rgba(40, 40, 55, 0.22)',
                nonBeefPurgeMultiplier: 0.4
            };

            function playerHasBeefPrivilege() {
                const p = store?.player;
                if (!p) return false;
                if (p.beef === true) return true;
                if (p.pilotGenome === 'beef') return true;
                if (p.hasBeefShield || p.hasBeefClone) return true;
                if (typeof p.beefShieldMax === 'number' && p.beefShieldMax > 0) return true;
                if (p.skillTree && (p.skillTree.juggernaut_core || p.skillTree.juggernaut_enhanced)) return true;
                return false;
            }

            function getKnockbackShieldStats() {
                const beefMode = playerHasBeefPrivilege();
                const radiusMultiplier = beefMode ? 1 : (KNOCKBACK_SHIELD_CONFIG.nonBeefRadiusMultiplier ?? 0.45);
                const radius = Math.max(20, KNOCKBACK_SHIELD_CONFIG.radius * radiusMultiplier);
                const contactRadius = Math.max(18, KNOCKBACK_SHIELD_CONFIG.contactRadius ?? radius * 0.4);
                const contactEnemyScale = KNOCKBACK_SHIELD_CONFIG.contactEnemyRadiusScale ?? 0.6;
                const knockbackStrength = KNOCKBACK_SHIELD_CONFIG.knockbackStrength * (beefMode ? 1 : (KNOCKBACK_SHIELD_CONFIG.nonBeefKnockbackMultiplier ?? 0.4));
                const knockbackDuration = KNOCKBACK_SHIELD_CONFIG.knockbackDuration;
                const stunDuration = KNOCKBACK_SHIELD_CONFIG.stunDuration * (beefMode ? 1 : (KNOCKBACK_SHIELD_CONFIG.nonBeefStunMultiplier ?? 0.35));
                const baseSlowFactor = KNOCKBACK_SHIELD_CONFIG.slowFactor;
                let slowFactor = baseSlowFactor;
                if (!beefMode) {
                    const effectMultiplier = KNOCKBACK_SHIELD_CONFIG.nonBeefSlowEffectMultiplier ?? 0.5;
                    const difference = 1 - baseSlowFactor;
                    slowFactor = 1 - difference * effectMultiplier;
                }
                const slowDuration = KNOCKBACK_SHIELD_CONFIG.slowDuration * (beefMode ? 1 : (KNOCKBACK_SHIELD_CONFIG.nonBeefSlowDurationMultiplier ?? 0.5));

                return {
                    beefMode,
                    radius,
                    contactRadius,
                    contactEnemyScale,
                    knockbackStrength,
                    knockbackDuration,
                    stunDuration,
                    slowFactor,
                    slowDuration
                };
            }


            const SHOP_UPGRADES = {
                'repair': { name: "NANO REPAIR", icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d="M66.9 432l22.6-22.6 125.1-125.1c8.5 8.5 17 17 25.5 25.5 0 66.8 0 79.9 0 39.4-84 84-126.7 126.7-128 128L66.9 432zm11-377.9l8.4-8.4 89.9 59.9 0 38.3-38.3 0-59.9-89.9zm194.2 54c20.7-35.9 59.5-60.1 104-60.1 6.9 0 13.7 .6 20.3 1.7l-53.3 53.3-7 7 0 92.1c-21.3-21.3-42.7-42.7-64-64 0-10 0-20.1 0-30.1zm64 195.9l60.1 0 112 112-60.1 60.1-112-112 0-60.1zm97.9-96l7-7 53.3-53.3c1.1 6.6 1.7 13.4 1.7 20.3 0 28.1-9.6 53.9-25.8 74.3-14.5-14.6-26-26-34.3-34.3l-1.9 0z"/><path d="M176.1 105.7l-89.9-59.9-8.4 8.4 59.9 89.9 38.3 0 0-38.3zm48-25.7l0 78.1 97.9 97.9 94.1 0c99.4 99.4 152.7 152.7 160 160l-128 128c-7.3-7.3-60.6-60.6-160-160l0-94.1-97.9-97.9-78.1 0-96-144 64-64 144 96zm112 284.1l112 112 60.1-60.1-112-112-60.1 0 0 60.1zM180.7 250.3l33.9 33.9-125.1 125.1-22.6 22.6 45.3 45.3c1.3-1.3 44-44 128-128l0 67.9c-121.5 121.5-116.4 116.4-128 128-.9-.9-33-33-96.2-96.2L-1 432c3.7-3.7 98.1-98.2 181.7-181.7zm155.5-48.2l0-92.1 7-7 53.3-53.3c-6.6-1.1-13.4-1.7-20.3-1.7-44.5 0-83.3 24.2-104 60.1l0-72C300.7 13.5 336.9 0 376.1 0l.8 0c26.8 .1 52.2 6.5 74.7 17.9l1.2 .6c9.3 4.8 18 10.3 26.2 16.7-5.4 5.4-37 37-94.8 94.8l0 30.1 30.1 0c57.9-57.9 89.5-89.5 94.8-94.8 6.3 8.2 11.9 16.9 16.7 26.2l.6 1.2c10.4 20.6 16.6 43.6 17.7 67.9 .1 2.5 .2 5 .2 7.6 0 41.3-14.9 79.2-39.7 108.4l-34.1-34.1c16.1-20.4 25.8-46.3 25.8-74.3 0-6.9-.6-13.7-1.7-20.3l-53.3 53.3-7 7-92.1 0-5.8-5.8z"/></svg>', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
                'vampirism': {
                    name: "VAMPIRIC ROUNDS", icon: 'ðŸ©¸', isPremium: true, max: 4, category: 'utility',
                    apply: () => {
                        const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                        if (getWorldGold() >= cost && p.vampirismLevel < 4) { addWorldGold(-cost); p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
                    },
                    desc: () => {
                        const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                        const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
                    }
                },
                'hp': {
                    name: "MAX HP",
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d="M48 165.1c0-47 38.1-85.1 85.1-85.1 27.3 0 53 13.1 69 35.2l34.4 47.6c4.5 6.2 11.7 9.9 19.4 9.9s14.9-3.7 19.4-9.9l34.4-47.6c16-22.1 41.7-35.2 69-35.2 47 0 85.1 38.1 85.1 85.1 0 14.9-2.9 29.8-7.9 44.4-7.9-1-16-1.5-24.1-1.5-106 0-192 86-192 192 0 9.4 .7 18.7 2 27.7-34.5-26.3-84.7-70.3-125.8-120.3-36.2-43.9-68.1-92.4-68.1-142.3z"/><path d="M378.9 80c-27.3 0-53 13.1-69 35.2l-34.4 47.6c-4.5 6.2-11.7 9.9-19.4 9.9s-14.9-3.7-19.4-9.9l-34.4-47.6c-16-22.1-41.7-35.2-69-35.2-47 0-85.1 38.1-85.1 85.1 0 49.9 32 98.4 68.1 142.3 41.1 49.9 91.4 93.9 125.8 120.3 2.7 18.4 7.9 35.9 15.4 52.2-.5 0-.9 0-1.4 0-15.6 0-30.8-4.7-43.1-14.1-36.5-27.9-89.7-74.4-133.8-127.9-36.2-43.9-79.1-104.2-79.1-172.8 0-73.5 59.6-133.1 133.1-133.1 42.7 0 82.8 20.5 107.9 55.1l15 20.7 15-20.7c25-34.6 65.2-55.1 107.9-55.1 73.5 0 133.1 59.6 133.1 133.1 0 19.5-3.5 38.3-9.3 56.3-14.7-5.8-30.3-9.9-46.6-11.9 5-14.6 7.9-29.4 7.9-44.4 0-47-38.1-85.1-85.1-85.1zM432 256a144 144 0 1 1 0 288 144 144 0 1 1 0-288zm16 80c0-8.8-7.2-16-16-16s-16 7.2-16 16l0 48-48 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l48 0 0 48c0 8.8 7.2 16 16 16s16-7.2 16-16l0-48 48 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-48 0 0-48z"/></svg>',
                    baseCost: 25,
                    scale: 1.1,
                    maxLevel: 999, // Unlimited
                    category: 'health',
                    effect: (level) => {
                        const p = store.player;
                        // Give 10% of current max HP
                        const hpIncrease = Math.round(p.hpMax * 0.10);
                        p.hpMax += hpIncrease;
                        p.hp += hpIncrease;
                        // console.log(`HP upgrade: +${hpIncrease} HP (10% of ${p.hpMax - hpIncrease})`);
                    },
                    desc: level => {
                        const p = store.player;
                        const hpIncrease = Math.round(p.hpMax * 0.10);
                        return `+${hpIncrease} Max HP (+10%) (Lvl ${level + 1})`;
                    }
                },
                'nano_save': { name: "NANO CHARGE", icon: 'ðŸ’¾', cost: 25, isPremium: true, max: 5, category: 'utility', apply: () => { if (store.player.nanoSaves < 5) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Blocks death, sets HP to 10, +15 max HP, opens shop. Charges: ${store.player.nanoSaves}/5` },
                'luck_boost': { 
                    name: "LUCK BOOST", 
                    icon: 'ðŸ€', 
                    baseCost: 50, 
                    scale: 1.35, 
                    maxLevel: 20, 
                    category: 'utility', 
                    effect: (level) => { 
                        const p = store.player;
                        // Track upgrade count (starting from 0)
                        p.luckUpgradeCount = (p.luckUpgradeCount || 0) + 1;
                        
                        // Tier system - alternating pattern with gradual quality increases
                        // Odd tiers (1,3,5,7...): Quantity
                        // Even tiers (2,4,6,8...): Quality
                        const upgradeNum = p.luckUpgradeCount;
                        
                        if (upgradeNum % 2 === 1) {
                            // QUANTITY upgrade: increase drop rate
                            const quantityBonus = 0.12 / Math.pow(1.6, Math.floor(upgradeNum / 2));
                            p.luckQuantity = (p.luckQuantity || 0) + quantityBonus;
                        } else {
                            // QUALITY upgrade: Very gradual quality boost
                            // Start small and increase slowly: 0.08, 0.10, 0.12, 0.14, etc.
                            const qualityBonus = 0.06 + (Math.floor(upgradeNum / 2) * 0.02);
                            p.luckQuality = (p.luckQuality || 0) + qualityBonus;
                        }
                        
                        // Update combined luckBoost for compatibility (quantity only)
                        p.luckBoost = p.luckQuantity;
                    }, 
                    desc: level => {
                        const p = store.player;
                        const nextUpgrade = (p.luckUpgradeCount || 0) + 1;
                        
                        let upgradeType = '';
                        if (nextUpgrade % 2 === 1) {
                            const quantityBonus = 0.12 / Math.pow(1.6, Math.floor(nextUpgrade / 2));
                            upgradeType = `+${(quantityBonus * 100).toFixed(1)}% drop rate`;
                        } else {
                            const qualityBonus = 0.06 + (Math.floor(nextUpgrade / 2) * 0.02);
                            upgradeType = `+${(qualityBonus * 100).toFixed(1)}% better quality`;
                        }
                        
                        return `${upgradeType} (Lvl ${level + 1})`;
                    }
                },
                'dmg': { name: "DAMAGE", icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d="M32 296c0-25.6 17.2-47.2 40.7-53.9L96 235.5 96 168c0-30.9 25.1-56 56-56l40 0c32.7 0 60-8.2 78.2-27.7 18.1-19.5 21.1-43.9 19.7-62.6-.2-3-.5-6-1-8.9 20.1 12.4 31 32.1 31 51.2 0 3.8-.3 7.2-.9 10.2l-7 37.8 47.8 0c30.9 0 56 25.1 56 56l0 67.5 23.3 6.6c23.5 6.7 40.7 28.3 40.7 53.9l0 56-80 0 0-32-51 0 25.2-112-111.2 0c-55.6 48-111.2 96-166.7 144l-64.2 0 0-56z"/><path d="M350.6 48.4c-6.4-35-34.2-63.6-72.7-75-11.7-3.5-24.4-5.4-37.9-5.4 0 0 8.2 14.4 13.6 32.8 9.7 33 10.3 79.2-61.6 79.2l-40 0c-48.6 0-88 39.4-88 88l0 43.3C27.1 221.8 0 255.7 0 296l0 88 80 0 0-18 16.2-14-64.2 0 0-56c0-25.6 17.2-47.2 40.7-53.9L96 235.5 96 168c0-30.9 25.1-56 56-56l40 0c32.7 0 60-8.2 78.2-27.7 18.1-19.5 21.1-43.9 19.7-62.6-.2-3-.5-6-1-8.9 20.1 12.4 31 32.1 31 51.2 0 3.8-.3 7.2-.9 10.2l-7 37.8 47.8 0c30.9 0 56 25.1 56 56l0 67.5 23.3 6.6c23.5 6.7 40.7 28.3 40.7 53.9l0 56-80 0 0 32 112 0 0-88c0-40.3-27.1-74.2-64-84.7l0-43.3c0-40.8-27.8-75.1-65.4-85.1-7.2-1.9-14.8-2.9-22.6-2.9l-9.4 0c.9-5 1.4-10.4 1.4-16 0-5.3-.5-10.5-1.4-15.6zM128 387.9l0 44.1 63 0-25.2 112 33.4 0 152.8-131.9 0-44.1-63 0 25.2-112-33.4 0-152.8 131.9zM230.9 400l-67.9 0 106.8-92.2-20.7 92.2 67.9 0-106.8 92.2 20.7-92.2z"/></svg>', baseCost: 50, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.06, desc: level => `+6% Damage (Lvl ${level + 1})` },
                'crit_chance': { 
                    name: "SHINOBI REFLEXES", 
                    icon: 'ðŸ¥·', 
                    baseCost: 50,
                    scale: 1.5, // Starting multiplier, decreases by 0.05 each level
                    maxLevel: 10, 
                    category: 'attack',
                    cost: function(level) {
                        if (level === 0) return this.baseCost;
                        let cost = this.baseCost;
                        for (let i = 1; i <= level; i++) {
                            const multiplier = this.scale - (i - 1) * 0.05;
                            cost *= multiplier;
                        }
                        return cost;
                    },
                    effect: () => { 
                        const level = store.player.upgradeLevels.crit_chance;
                        // Tier 1: 10% base crit chance
                        // Odd tiers (1, 3, 5, 7, 9): +5% crit chance
                        // Even tiers (2, 4, 6, 8, 10): +5% crit damage (additive, so +0.05 to multiplier)
                        if (level === 0) {
                            // First tier grants 10% crit chance
                            store.player.critChance = 0.10;
                        } else if (level % 2 === 1) {
                            // Odd levels: +5% crit chance
                            store.player.critChance += 0.05;
                        } else {
                            // Even levels: +5% crit damage (0.05 to the multiplier)
                            store.player.critDamage += 0.05;
                        }
                    }, 
                    desc: level => {
                        if (level === 0) {
                            return `10% Crit Chance (Lvl 1)`;
                        } else if (level % 2 === 0) {
                            return `+5% Crit Chance (Lvl ${level + 1})`;
                        } else {
                            return `+5% Crit Damage (Lvl ${level + 1})`;
                        }
                    }
                },
                'speed': { name: "SPEED", icon: 'ðŸš€', baseCost: 40, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
                'grenade': { 
                    name: "SHIELD PULSE", 
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d=""/><path d="M80 88c0-13.3 10.7-24 24-24l152 0c13.3 0 24 10.7 24 24l0 312 104 0 0-152c0-13.3 10.7-24 24-24l80 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-56 0 0 152c0 13.3-10.7 24-24 24l-152 0c-13.3 0-24-10.7-24-24l0-312-104 0 0 152c0 13.3-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l56 0 0-152z"/></svg>', 
                    cost: 70, 
                    isPremium: true, 
                    max: 3, 
                    category: 'attack', 
                    apply: () => { 
                        if (!store.empCharges) store.empCharges = []; 
                        if (store.empCharges.length < 3) { 
                            createEmpCharge(); 
                            return true; 
                        } else {
                            // At max capacity - recharge the charge with longest cooldown
                            let longestCooldownCharge = null;
                            let maxCooldown = 0;
                            for (const charge of store.empCharges) {
                                if (charge && !charge.dead && (charge.cooldown || 0) > maxCooldown) {
                                    maxCooldown = charge.cooldown;
                                    longestCooldownCharge = charge;
                                }
                            }
                            if (longestCooldownCharge) {
                                longestCooldownCharge.cooldown = 0; // Instantly recharge
                                announce('âš¡ Shield Pulse Recharged! âš¡');
                                store.player.grenades = store.empCharges.length;
                                return true;
                            }
                            return false;
                        }
                    }, 
                    desc: () => {
                        const count = store.empCharges?.length || 0;
                        if (count < 3) {
                            return `Add Shield Pulse charge (${count}/3). Auto-activates near threats.`;
                        } else {
                            return `Shield Pulse (3/3). Additional pickups recharge your longest cooldown.`;
                        }
                    }
                },
                'knockback_shield': {
                    name: "KNOCKBACK SHIELD",
                    icon: 'âš«',
                    cost: 70,
                    isPremium: true,
                    max: 3,
                    category: 'utility',
                    apply: () => {
                        ensureKnockbackChargeList();
                        if (store.knockbackCharges.length < (KNOCKBACK_SHIELD_CONFIG.maxCharges || 3)) {
                            createKnockbackShieldCharge();
                            announce('âš« Knockback shield online!');
                            return true;
                        } else {
                            let longestCooldownCharge = null;
                            let maxCooldown = 0;
                            for (const charge of store.knockbackCharges) {
                                if (charge && !charge.dead && (charge.cooldown || 0) > maxCooldown) {
                                    maxCooldown = charge.cooldown;
                                    longestCooldownCharge = charge;
                                }
                            }
                            if (longestCooldownCharge) {
                                longestCooldownCharge.cooldown = 0;
                                announce('âš« Knockback shield recharged!');
                                if (store.player) store.player.knockbackShields = store.knockbackCharges.length;
                                return true;
                            }
                            return false;
                        }
                    },
                    desc: () => {
                        const count = store.knockbackCharges?.length || 0;
                        if (count < (KNOCKBACK_SHIELD_CONFIG.maxCharges || 3)) {
                            return `Add Knockback Shield charge (${count}/3). Blasts enemies back on contact.`;
                        }
                        return `Knockback Shield (3/3). Extra pickups reset your slowest charge.`;
                    }
                },
                'fragment_blast': { 
                    name: "FRAGMENT BLAST", 
                    icon: 'ðŸ‘½', 
                    baseCost: 80, 
                    scale: 2, 
                    maxLevel: 3, 
                    isPremium: true, 
                    category: 'attack',
                    effect: (level) => {
                        const p = store.player;
                        if (!p.fragmentBlasters) {
                            p.fragmentBlasters = [];
                        }
                        p.fragmentBlasters.push({
                            cooldown: 0,
                            maxCooldown: 10,
                            barrelDelay: 0,
                            meleeRange: 120,
                            triggerRange: 60
                        });
                    },
                    desc: level => {
                        if (level === 0) return 'Auto-firing shotgun blast when enemies get close (10s cooldown).';
                        if (level === 1) return 'Add 2nd barrel - fires 1s after first if enemies remain close.';
                        if (level === 2) return 'Add 3rd barrel - independent targeting for maximum coverage.';
                        return 'Max Level';
                    }
                },
                'ricochet': {
                    name: "RICOCHET ROUNDS",
                    icon: 'ðŸ”„',
                    baseCost: 120,
                    scale: 4,
                    maxLevel: 2,
                    isPremium: true,
                    isUnlock: true,
                    category: 'attack',
                    effect: (level) => {
                        const p = store.player;
                        if (!p) return;
                        if (level === 0) {
                            p.hasRicochet = true;
                            p.ricochetLevel = Math.max(p.ricochetLevel || 0, 1);
                            announce('ðŸ”„ Ricochet rounds armed! Half of your shots can rebound.');
                        } else if (level === 1) {
                            p.hasRicochet = true;
                            p.ricochetLevel = 2;
                            announce('ðŸ”„ Ricochet rounds fully calibrated! Every shot can rebound.');
                        }
                    },
                    desc: level => {
                        if (level === 0) {
                            return '50% of your shots shrink slightly and can rebound off screen edges at 30% damage.';
                        }
                        if (level === 1) {
                            return 'Upgrade: calibrate for full ricochet on every shot (smaller rounds, 30% damage after bounce).';
                        }
                        return 'Max level reached.';
                    }
                },
                'max_shield': {
                    name: "MAX SHIELD",
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d="M16.6 113c-2.9 49.9 4.9 126.3 37.3 200.9 32.7 75.2 91 150 189.4 192.6l12.7 5.5 12.7-5.5c98.4-42.6 156.7-117.3 189.4-192.6 32.4-74.7 40.2-151 37.3-200.9L494.3 92.5 475.1 85 267.6 4.5 256 0 244.5 4.5 37 85 17.8 92.5 16.6 113zM160 216c12 0 36 0 72 0l0-72c16 0 32 0 48 0l0 72c36 0 60 0 72 0l0 48c-12 0-36 0-72 0l0 72c-16 0-32 0-48 0l0-72c-36 0-60 0-72 0l0-48z"/><path d="M232 312l0 24 48 0 0-72 72 0 0-48-72 0 0-72-48 0 0 72-72 0 0 48 72 0 0 48z"/></svg>',
                    baseCost: 30,
                    scale: 1.2,
                    maxLevel: 999, // Unlimited
                    category: 'health',
                    effect: (level) => {
                        const p = store.player;
                        if (level < 5) {
                            // First 5 levels: +25 flat shield
                            p.shieldMax += 25;
                            p.shield += 25;
                        } else {
                            // Levels 6+: +25% of current max shield
                            const increase = Math.floor(p.shieldMax * 0.25);
                            p.shieldMax += increase;
                            p.shield += increase;
                        }
                    },
                    desc: level => {
                        if (level < 5) {
                            return `+25 Max Shield (Lvl ${level + 1})`;
                        } else {
                            return `+25% Max Shield (Lvl ${level + 1})`;
                        }
                    }
                },
                'rear_guard': { name: 'AFT FLANKSHIELD', icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="1em" height="1em" fill="currentColor"><path d="M267.6 4.5L256 0 244.5 4.5 37 85 17.8 92.5 16.6 113c-2.9 49.9 4.9 126.3 37.3 200.9 32.7 75.3 91 150 189.4 192.6l12.7 5.5 12.7-5.5c98.4-42.6 156.7-117.3 189.4-192.6 32.4-74.7 40.2-151 37.3-200.9L494.3 92.5 475.1 85 267.6 4.5zM224 81.1l32-12.4 32 12.4 0 78.9 143 0c-1.5 19.5-4.7 41.3-10.1 64l-132.9 0 0 199.8c-10 6.5-20.7 12.6-32 18.1-11.3-5.5-22-11.6-32-18.1l0-199.8-132.8 0c-5.4-22.7-8.6-44.5-10.1-64l142.9 0 0-78.9z"/></svg>', baseCost: 130, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
                'launcher': {
                    name: 'FRAG LAUNCHER',
                    icon: 'ðŸ’¥',
                    baseCost: 100,
                    scale: 2,
                    maxLevel: 3,
                    category: 'attack',
                    effect: () => {
                        store.player.hasLauncher = true;
                    },
                    desc: level => {
                        if (level === 0) return `Unlocks launcher (2 projectiles).`;
                        if (level === 1) return `Add 2 projectiles (4 total).`;
                        if (level === 2) return `Add 2 more projectiles (6 total).`;
                        return "Max projectiles reached.";
                    }
                },
                'star_cannon': {
                    name: 'STAR CANNON',
                    icon: 'ðŸŒ ',
                    baseCost: 150,
                    scale: 1.5,
                    maxLevel: STAR_CANNON_LEVEL_CAP,
                    category: 'attack',
                    effect: level => {
                        const p = store.player;
                        const nextLevel = Math.min(level + 1, STAR_CANNON_LEVEL_CAP);
                        const previous = p.starCannonLevel || 0;
                        if (nextLevel > previous) {
                            p.starCannonLevel = nextLevel;
                        }
                        p.starCannonTimer = 0;
                        if (!p.starCannonNextSide) {
                            p.starCannonNextSide = 'left';
                        }
                        p.starCannonIcemanSupport = p.starCannonLevel >= 3;
                        const cooldownMsg = getStarCannonCooldown(p.starCannonLevel).toFixed(1);
                        let message;
                        if (nextLevel === 1) {
                            message = 'STAR CANNON ONLINE!';
                        } else if (nextLevel === 2) {
                            message = 'STAR CANNON MKII - Alternating Barrage!';
                        } else if (nextLevel === 3) {
                            message = 'STAR CANNON MKIII - Blizzard Sync!';
                        } else {
                            message = `STAR CANNON CALIBRATION MK${pad(nextLevel)} â–¸ Reload ${cooldownMsg}s`;
                        }
                        announce(message);
                    },
                    desc: level => {
                        const upcomingLevel = Math.min(level + 1, STAR_CANNON_LEVEL_CAP);
                        const cooldown = getStarCannonCooldown(upcomingLevel).toFixed(1);
                        if (upcomingLevel === 1) return 'Left-side artillery platform (7.0s reload).';
                        if (upcomingLevel === 2) return 'Unlock right cannon and alternating salvo pattern.';
                        if (upcomingLevel === 3) return 'Iceman mirrors your salvos with frosty stars.';
                        const bursts = getStarCannonBurstCount(upcomingLevel);
                        return `Calibration Mk${pad(upcomingLevel)} â–¸ ${bursts} alternating blasts â€¢ ${cooldown}s reload.`;
                    }
                },
                'iceman': { 
                    name: "THE ICEMAN", 
                    icon: 'â„ï¸', 
                    baseCost: 118, 
                    scale: 2, 
                    maxLevel: 3, 
                    isPremium: true, 
                    category: 'utility', 
                    effect: (level) => { 
                        const p = store.player;
                        if (!p.hasIceman) { 
                            // First purchase - initialize everything
                            p.hasIceman = true;
                            p.icemanFireT = 0;
                            store.iceman = { 
                                x: p.x, 
                                y: p.y + 50, 
                                t: 0, 
                                level: 1 
                            }; 
                            announce('â„ï¸ Iceman is your wingman!');
                        } else {
                            // Upgrade existing iceman
                            if (!store.iceman) {
                                // Safety: recreate iceman if somehow missing
                                store.iceman = { 
                                    x: p.x, 
                                    y: p.y + 50, 
                                    t: 0, 
                                    level: 1 
                                };
                            }
                            store.iceman.level = (store.iceman.level || 1) + 1;
                            announce(`â„ï¸ Iceman upgraded to level ${store.iceman.level}!`);
                        }
                        // Always ensure fireT is a valid number
                        if (typeof p.icemanFireT !== 'number' || isNaN(p.icemanFireT)) {
                            p.icemanFireT = 0;
                        }
                    }, 
                    desc: level => { 
                        if (level === 0) return 'Val Kilmer mirrors your attacks.'; 
                        if (level === 1) return 'Iceman fires 50% faster.'; 
                        if (level === 2) return 'Iceman deals 50% more damage.'; 
                        return 'Max Level'; 
                    } 
                },
                'lazarus_beam': { name: "LORD LAZARUS", icon: 'â˜¢ï¸â˜„ï¸â˜¢ï¸', baseCost: 200, scale: 3, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Summon Lord Lazarus who fires devastating energy beams across the battlefield.'; if (level === 1) return 'Lazarus fires twice as often and launches dual beams.'; return 'Max Level'; } },
                'magnet_pull': { name: "GRAV-PULSE", icon: 'ðŸ§²', cost: 90, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
                'gravity_well': { name: "GRAVITY WELL", icon: 'ðŸ•³ï¸', baseCost: 300, scale: 2, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Unleash a singularity that traps and crushes foes.'; if (level === 1) return 'Summon a second, smaller singularity.'; return 'Max Level'; } },
                'ghost_hounds': {
                    name: "GHOST HOUNDS",
                    icon: 'ðŸ‘»ðŸº',
                    baseCost: 150,
                    scale: 2,
                    maxLevel: 3,
                    category: 'attack',
                    effect: (level) => {
                        if (!Array.isArray(store.hounds)) {
                            store.hounds = [];
                        }

                        const isMini = store.player.miniAbilities && store.player.miniAbilities.has('ghost_hounds');
                        if (level === 0) {
                            store.player.hasHounds = true;
                            store.hounds.push(createHound(-1, isMini));
                            store.hounds.push(createHound(1, isMini));
                        } else if (level === 1) {
                            store.hounds.push(createHound(-2, isMini));
                            store.hounds.push(createHound(2, isMini));
                        } else if (level === 2) {
                            store.hounds.push(createHound(3, isMini));
                            store.hounds.push(createHound(4, isMini));
                        }

                        playSound('dogs');
                    },
                    desc: level => {
                        if (level === 0) return `Unlocks 2 spectral hounds.`;
                        if (level === 1) return `Add 2 more hounds.`;
                        if (level === 2) return `Add 2 Bernese Mountain hounds.`;
                        return "Max hounds reached.";
                    }
                },
                'champion_attack_module': {
                    name: 'CHAMPION MODULE',
                    icon: 'âš”ï¸',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Champion Modules';
                        const state = getChampionUpgradeState();
                        const detail = info?.detail;
                        if (detail?.module) {
                            return `Unlock ${detail.module.name}`;
                        }
                        const activeModule = CHAMPION_ATTACK_MODULE_MAP[state.attackModule];
                        return activeModule ? `Active: ${activeModule.name}` : 'Champion Modules';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.module) {
                            return detail.module.desc;
                        }
                        return 'All champion attack modules unlocked.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionAttackUnlock(state);
                        if (!next) {
                            const activeModule = CHAMPION_ATTACK_MODULE_MAP[state.attackModule];
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'All modules unlocked.',
                                detail: { modules: getChampionAttackCatalogue(state), activeModule }
                            };
                        }
                        const cost = next.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionAttackUnlock(state);
                        if (!detail || !detail.module) return false;
                        const moduleId = detail.module.id;
                        if (state.unlockedAttacks[moduleId]) return false;
                        state.unlockedAttacks[moduleId] = true;
                        state.attackModule = moduleId;
                        notifyChampionLoadoutChanged();
                        announce(`Champion module secured: ${detail.module.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                },
                'champion_cadence': {
                    name: 'CHAMPION CADENCE',
                    icon: 'ðŸŽµ',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Champion Cadence';
                        const detail = info?.detail;
                        if (detail?.option) {
                            return `Upgrade: ${detail.option.name}`;
                        }
                        const state = getChampionUpgradeState();
                        const current = detail?.current || getChampionCadenceOptions(state).find(opt => opt.active);
                        return current ? `Cadence: ${current.name}` : 'Champion Cadence';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.option) {
                            return detail.option.desc || 'Improve guardian firing rhythm and dash cooldown.';
                        }
                        const state = getChampionUpgradeState();
                        const current = getChampionCadenceOptions(state).find(opt => opt.active);
                        return current ? `Current cadence: ${current.name}.` : 'Cadence at base configuration.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionCadenceUpgrade(state);
                        if (!next) {
                            const options = getChampionCadenceOptions(state);
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'Cadence maxed.',
                                detail: { options, current: options.find(opt => opt.active) }
                            };
                        }
                        const cost = next.option.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionCadenceUpgrade(state);
                        if (!detail || !detail.option) return false;
                        const targetLevel = detail.option.level;
                        if (state.cadenceLevel >= targetLevel) return false;
                        state.cadenceLevel = targetLevel;
                        notifyChampionLoadoutChanged();
                        announce(`Champion cadence aligned: ${detail.option.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                },
                'champion_protocol': {
                    name: 'MINION PROTOCOLS',
                    icon: 'ðŸ›°ï¸',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Minion Protocols';
                        const detail = info?.detail;
                        if (detail?.option) {
                            return `Upgrade: ${detail.option.name}`;
                        }
                        const state = getChampionUpgradeState();
                        const current = detail?.current || getChampionProtocolOptions(state).find(opt => opt.active);
                        return current ? `Protocols: ${current.name}` : 'Minion Protocols';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.option) {
                            return detail.option.desc || 'Enhance guardian minion behavior.';
                        }
                        const state = getChampionUpgradeState();
                        const current = getChampionProtocolOptions(state).find(opt => opt.active);
                        return current ? `Current protocol: ${current.name}.` : 'Escort drones in default pattern.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionProtocolUpgrade(state);
                        if (!next) {
                            const options = getChampionProtocolOptions(state);
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'Protocols maxed.',
                                detail: { options, current: options.find(opt => opt.active) }
                            };
                        }
                        const cost = next.option.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionProtocolUpgrade(state);
                        if (!detail || !detail.option) return false;
                        const targetLevel = detail.option.level;
                        if (state.minionProtocols >= targetLevel) return false;
                        state.minionProtocols = targetLevel;
                        notifyChampionLoadoutChanged();
                        announce(`Minion protocols upgraded: ${detail.option.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                },
                'champion_skin': {
                    name: 'CHAMPION PLATING',
                    icon: 'ðŸŽ¨',
                    isPremium: true,
                    category: 'champion',
                    autoForgeEligible: false,
                    getName: (info) => {
                        if (!store.player?.championUnlocked) return 'Champion Plating';
                        const detail = info?.detail;
                        if (detail?.option) {
                            return `Unlock Skin: ${detail.option.name}`;
                        }
                        const state = getChampionUpgradeState();
                        const active = detail?.active || getChampionSkinCatalogue(state).find(opt => opt.active);
                        return active ? `Skin: ${active.name}` : 'Champion Plating';
                    },
                    desc: (level, info) => {
                        if (!store.player?.championUnlocked) {
                            return 'Requires champion sigil from the Shadow Mirror.';
                        }
                        const detail = info?.detail;
                        if (detail?.option) {
                            return detail.option.desc || 'Unlock a new guardian aesthetic.';
                        }
                        const state = getChampionUpgradeState();
                        const active = getChampionSkinCatalogue(state).find(opt => opt.active);
                        if (active) {
                            return `All skins unlocked. Current skin: ${active.name}.`;
                        }
                        return 'All champion skins unlocked.';
                    },
                    getCost: () => {
                        ensureChampionUpgradeState();
                        if (!store.player?.championUnlocked) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Requires champion sigil.' };
                        }
                        const state = getChampionUpgradeState();
                        const next = getNextChampionSkinUnlock(state);
                        if (!next) {
                            const catalogue = getChampionSkinCatalogue(state);
                            return {
                                cost: Infinity,
                                available: false,
                                premium: true,
                                reason: 'All skins unlocked.',
                                detail: { catalogue, active: catalogue.find(opt => opt.active) }
                            };
                        }
                        const cost = next.option.cost ?? 0;
                        return {
                            cost,
                            available: (store.world?.gold ?? 0) >= cost,
                            premium: true,
                            detail: next
                        };
                    },
                    apply: (info) => {
                        if (!store.player?.championUnlocked) return false;
                        ensureChampionUpgradeState();
                        const state = getChampionUpgradeState();
                        const detail = info?.detail || getNextChampionSkinUnlock(state);
                        if (!detail || !detail.option) return false;
                        const skinId = detail.option.id;
                        if (state.unlockedSkins[skinId]) return false;
                        state.unlockedSkins[skinId] = true;
                        state.skin = skinId;
                        notifyChampionLoadoutChanged();
                        announce(`Champion plating unlocked: ${detail.option.name}!`);
                        playSound('epicHorn');
                        return true;
                    }
                },
                'ice_bullets': { 
                    name: "ICE BULLETS", 
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d="M36.8 388.3C43.5 384.1 48 376.6 48 368l0-112C48 141.1 141.1 48 256 48s208 93.1 208 208c0 50.5-18 96.9-48 132.9l0 66.9c-14.8 11.8-30.8 22-48 30.4l0-78.8c19.1-11.1 32-31.7 32-55.4 0-35.3-28.7-64-64-64l-160 0c-35.3 0-64 28.7-64 64s28.7 64 64 64l64 0 0 40c0 13.3 10.7 24 24 24s24-10.7 24-24l0-40 32 0 0 72c0 5.5 1.8 10.6 5 14.6-21.9 6.1-45.1 9.4-69 9.4-14 0-27.7-1.1-41-3.3-14.3-13.5-23-32.1-23-52.7l0-2c-38.4-12.4-71.9-35.7-97-66.2-2.9 17.4-12 32.7-25.3 43.9-12.4-13.2-23.5-27.7-32.9-43.3zM144 208a32 32 0 1 0 64 0 32 32 0 1 0 -64 0zm160 0a32 32 0 1 0 64 0 32 32 0 1 0 -64 0z"/><path d="M48 256C48 141.1 141.1 48 256 48s208 93.1 208 208c0 50.5-18 96.9-48 132.9l0 66.9c18.2-14.6 34.4-31.6 48-50.6l0 50.7c0 13.3 10.7 24 24 24s24-10.7 24-24l0-200C512 114.6 397.4 0 256 0S0 114.6 0 256L0 368c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112zM95 387.8c-2.9 17.6-12.1 33-25.3 43.9 37.8 40.1 88.4 68 145.2 77.1-14.1-13.1-23-31.9-23-52.7l0-2c-38.4-12.4-71.9-35.7-97-66.2zM152 352c0-11.9 8.6-21.8 20-23.7l0 47.3c-11.4-1.9-20-11.8-20-23.7zm84 24l-24 0 0-48 24 0 0 48zm64-48l0 48-24 0 0-48 24 0zm40 .3c11.4 1.9 20 11.8 20 23.7s-8.6 21.8-20 23.7l0-47.3zM176 288c-35.3 0-64 28.7-64 64s28.7 64 64 64l64 0 0 40c0 13.3 10.7 24 24 24s24-10.7 24-24l0-40 32 0 0 72c0 13.3 10.7 24 24 24s24-10.7 24-24l0-80.6c19.1-11.1 32-31.7 32-55.4 0-35.3-28.7-64-64-64l-160 0zm0-48a32 32 0 1 0 0-64 32 32 0 1 0 0 64zm192-32a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"/></svg>', 
                    cost: 250, 
                    isPremium: true, 
                    isUnlock: true, 
                    category: 'attack', 
                    apply: () => { 
                        if (!store.player.hasIceBullets) {
                            store.player.hasIceBullets = true;
                            store.player.dmgMult *= 1.1; // +10% base damage
                            activateBulletElementIfNone(store.player, 'ice');
                            announce('â„ï¸ Ice bullets unlocked! +10% damage. Slow enemies and increase damage taken.');
                            playSound('powerup');
                            return true; 
                        } 
                        return false;
                    }, 
                    desc: () => 'Unlock ice bullets. +10% damage. Slow enemies and increase damage taken up to 30%.' 
                },
                'poison_bullets': { 
                    name: "POISON BULLETS", 
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" width="1em" height="1em" fill="currentColor"><path opacity=".4" d="M48 320c0 79.5 64.5 144 144 144s144-64.5 144-144c0-57.4-33.6-107-82.3-130.2-8.4-4-13.7-12.4-13.7-21.7l0-120.2-96 0 0 120.2c0 9.3-5.3 17.7-13.7 21.7-48.7 23.1-82.3 72.7-82.3 130.2zm32-8c0-48.6 50.1-88 112-88s112 39.4 112 88c0 29.9-19 56.3-48 72.2l0 15.8c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32l0-15.8C99 368.3 80 341.9 80 312z"/><path d="M88 48l8 0 0 105.7C38.6 186.9 0 248.9 0 320 0 426 86 512 192 512s192-86 192-192c0-71.1-38.6-133.1-96-166.3l0-105.7 8 0c13.3 0 24-10.7 24-24S309.3 0 296 0L88 0C74.7 0 64 10.7 64 24S74.7 48 88 48zm56 120.2l0-120.2 96 0 0 120.2c0 9.3 5.3 17.7 13.7 21.7 48.7 23.1 82.3 72.7 82.3 130.2 0 79.5-64.5 144-144 144S48 399.5 48 320c0-57.4 33.6-107 82.3-130.2 8.4-4 13.7-12.4 13.7-21.7zM304 312c0-48.6-50.1-88-112-88S80 263.4 80 312c0 29.9 19 56.3 48 72.2l0 15.8c0 17.7 14.3 32 32 32l64 0c17.7 0 32-14.3 32-32l0-15.8c29-15.9 48-42.3 48-72.2zM152 288a24 24 0 1 1 0 48 24 24 0 1 1 0-48zm56 24a24 24 0 1 1 48 0 24 24 0 1 1 -48 0z"/></svg>', 
                    cost: 250,
                    isPremium: true, 
                    isUnlock: true, 
                    category: 'attack', 
                    apply: () => { 
                        if (!store.player.hasPoisonBullets) {
                            store.player.hasPoisonBullets = true;
                            store.player.dmgMult *= 1.1; // +10% base damage
                            activateBulletElementIfNone(store.player, 'poison');
                            announce('â˜ ï¸ Poison bullets unlocked! +10% damage. Stack poison DoT on enemies.');
                            playSound('powerup');
                            return true; 
                        } 
                        return false;
                    }, 
                    desc: () => 'Unlock poison bullets. +10% damage. Stack poison DoT (10% per stack, up to 50% total).' 
                },
                'fire_bullets': {
                    name: "FIRE BULLETS",
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" width="1em" height="1em" fill="currentColor"><path d="M216 0c-8.8 0-16 7.2-16 16 0 35.3-28.7 64-64 64-44.2 0-80 35.8-80 80 0 11 9 20 20 20 30.9 0 56 25.1 56 56 0 11 9 20 20 20 30.9 0 56 25.1 56 56 0 27.6-20.1 50.5-46.5 55.3C141.2 373.4 96 424.7 96 488c0 13.3 10.7 24 24 24h144c52.9 0 96-43.1 96-96 0-44.9-31-82.6-72.3-93.2C310 301.5 320 276.6 320 248c0-65.2-47.9-119.2-110.9-127.2 5.8-9.6 9.3-20.8 9.3-32.8 0-8.8-7.2-16-16-16z"/></svg>',
                    cost: 500,
                    isPremium: true,
                    isUnlock: true,
                    category: 'attack',
                    apply: () => {
                        if (!store.player.hasFireBullets) {
                            store.player.hasFireBullets = true;
                            store.player.dmgMult *= 1.15; // +15% base damage
                            activateBulletElementIfNone(store.player, 'fire');
                            announce('ðŸ”¥ Fire bullets unlocked! +15% damage. Spreading fire ignites everything.');
                            playSound('powerup');
                            return true;
                        }
                        return false;
                    },
                    desc: () => 'Unlock fire bullets. +15% damage. Burn spreads and escalates automatically.'
                }
            };

            const SHOP_DISPLAY_ORDER = [
                'repair',
                'hp',
                'max_shield',
                'nano_save',
                'vampirism',
                'luck_boost',
                'speed',
                'magnet_pull',
                'rear_guard',
                'dmg',
                'crit_chance',
                'grenade',
                'knockback_shield',
                'fragment_blast',
                'ice_bullets',
                'poison_bullets',
                'fire_bullets',
                'ricochet',
                'launcher',
                'star_cannon',
                'ghost_hounds',
                'iceman',
                'lazarus_beam',
                'gravity_well',
                'champion_attack_module',
                'champion_cadence',
                'champion_protocol',
                'champion_skin'
            ];

            const SPLIT_SHOT_ICON_SVG = `<svg class="powerup-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><path fill="#ff2f6f" d="M10.8 3 5.4 12l5.4 9h-2.6L2.8 12 8.2 3z"/><path fill="#ff7ad6" d="M13.2 3 18.6 12l-5.4 9h2.6L21.2 12 15.8 3z"/></svg>`;
            const PIERCE_SHOT_ICON_SVG = `<svg class="powerup-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9" fill="#2a0129" stroke="#ff4f98" stroke-width="2"/><path fill="#ff90d8" d="M6.5 12h8.2l-2.8-2.8 1.4-1.4L19.5 12l-6.2 6.2-1.4-1.4 2.8-2.8H6.5z"/></svg>`;

            // Powerup quality ranking system (1-10 scale, 10 being highest value)
            const POWERUP_QUALITY = {
                // HIGH VALUE (8-10): Game-changing powerups
                'double': 10,        // Extra bullet is extremely powerful
                'split_shot': 9,     // Neon split is very strong
                'pierce_shot': 9,    // Phase pierce is very strong
                'missile': 8,        // Homing missiles are strong
                'drones': 8,         // Side drones are solid
                'void_core': 8,      // Void core is valuable
                
                // MEDIUM VALUE (5-7): Useful but not game-changing
                'shield': 4,         // Shield is okay but temporary
                'repair': 3,         // Health restore is low value
                
                // SPECIAL (not affected by quality filter)
                'upgrade': 10,
                'cash': 5,
                'attack_speed': 10,
                'star_upgrade': 10,
                'shadow_champion_token': 10,
                'collar_fragment': 10,
                'champion_upgrade': 10
            };

            const POWERUP_TYPES = {
                'double': { name: 'SCATTER SHOT', icon: 'â¬†ï¸', duration: 0, type: 'instant' },
                'drones': { name: 'SIDE DRONES', icon: 'ðŸš', duration: 15, type: 'timed' },
                'shield': { name: 'SHIELD BUBBLE', icon: 'ðŸ›¡ï¸', duration: 0, type: 'instant' },
                'repair': { name: 'REPAIR KIT', icon: 'â¤ï¸', duration: 0, type: 'instant' },
                'missile': { name: 'HOMING MISSILES', icon: 'ðŸš€', duration: 20, type: 'timed' },
                'split_shot': { name: 'NEON SPLIT', icon: 'âœ¦', canvasIcon: 'âœ¦', svgIcon: SPLIT_SHOT_ICON_SVG, duration: 8, type: 'timed' },
                'pierce_shot': { name: 'PHASE PIERCE', icon: 'âŸ ', canvasIcon: 'âŸ ', svgIcon: PIERCE_SHOT_ICON_SVG, duration: 8, type: 'timed', pierceBonus: 2 },
                'upgrade': { name: 'UPGRADE CORE', icon: 'âš¡', duration: 0, type: 'instant', isSpecial: true },
                'void_core': { name: 'VOID CORE', icon: 'ðŸŒ€', duration: 25, type: 'timed' },
                'cash': { name: 'CASH INFUSION', icon: 'ðŸ’°', duration: 0, type: 'instant', isSpecial: true },
                'attack_speed': { name: 'HYPER DRIVE', icon: 'âš¡', duration: 0, type: 'instant', isSpecial: true },
                'star_upgrade': { name: 'STAR CORE', icon: 'ðŸŒ ', duration: 0, type: 'instant', isSpecial: true },
                'shadow_champion_token': { name: 'CHAMPION SIGIL', icon: 'âš”ï¸', duration: 0, type: 'instant', isSpecial: true },
                'collar_fragment': { name: 'COLLAR FRAGMENT', icon: 'â›“ï¸', duration: 0, type: 'instant', isSpecial: true },
                'champion_upgrade': { name: 'CHAMPION CACHE', icon: 'ðŸ§¬', duration: 0, type: 'instant', isSpecial: true }
            };

            // --- GAME MECHANICS ---
            function spawnPowerup(x, y) {
                if (store.world.powerupCooldown > 0) return;
                const p = store.player || {};
                const baseChance = 0.04;
                const wave = store.world.wave;
                const waveReductionFactor = 0.0025;
                let finalChance = Math.max(0.015, baseChance - (wave - 1) * waveReductionFactor);
                let types = Object.keys(POWERUP_TYPES).filter(key => key !== 'void_core' && !POWERUP_TYPES[key].isSpecial);
                if (!types.length) types = ['shield', 'repair', 'missile'];

                let bonusType = null;
                let bonusDropChance = 0;

                // Check for nearby Cube Burglars - boost drop rate significantly
                const cubeBurglar = store.enemies.find(e => e.type === 'cube_burglar' && !e.dead);
                if (cubeBurglar) {
                    const dx = cubeBurglar.x - x;
                    const dy = cubeBurglar.y - y;
                    const distSq = dx * dx + dy * dy;
                    const burglarAuraRange = 300;
                    if (distSq <= burglarAuraRange * burglarAuraRange) {
                        // Still reward burglar hunts, but with a gentler multiplier
                        finalChance *= 2.2;
                    }
                }

                if (p.pilotGenome === 'beef') {
                    const roll = Math.random();
                    if (roll < 0.45) {
                        bonusType = 'shield';
                        bonusDropChance = 0.55;
                    } else if (roll < 0.8) {
                        bonusType = 'repair';
                        bonusDropChance = 0.5;
                    }
                } else if (p.pilotGenome === 'rocketman') {
                    bonusType = 'missile';
                    const missileTimer = p.powerupTimers?.missile;
                    bonusDropChance = !missileTimer || missileTimer.remaining <= 3 ? 0.85 : 0.6;
                }

                const roll = Math.random();
                let shouldDrop = roll <= finalChance;
                if (!shouldDrop && bonusType) {
                    if (Math.random() < bonusDropChance) {
                        shouldDrop = true;
                    }
                }
                if (!shouldDrop) return;

                // QUALITY WEIGHTING: Use weighted random selection based on quality score
                const qualityScore = p.luckQuality || 0;
                
                // Build weighted pool - each powerup gets weight based on its quality and player's quality score
                const weightedPool = [];
                for (const typeKey of types) {
                    const baseQuality = POWERUP_QUALITY[typeKey] || 5;
                    
                    // Calculate weight multiplier based on quality difference
                    // Higher quality items get boosted more by quality score
                    // Low quality items get slightly reduced (but never eliminated)
                    const qualityDiff = baseQuality - 5; // Difference from average (5)
                    const qualityBoost = 1 + (qualityDiff * qualityScore * 0.08); // 8% boost per quality point per score
                    
                    // Minimum weight is 0.5 (low quality items still have 50% chance)
                    // Maximum practical weight is ~2.0 (high quality items get doubled at high scores)
                    const weight = Math.max(0.5, Math.min(2.0, qualityBoost));
                    
                    // Add this powerup to pool multiple times based on weight
                    const entries = Math.max(1, Math.round(weight * 10));
                    for (let i = 0; i < entries; i++) {
                        weightedPool.push(typeKey);
                    }
                }

                let typeKey;
                if (bonusType) {
                    const preferBonus = roll <= finalChance ? Math.random() < 0.6 : true;
                    if (preferBonus) {
                        typeKey = bonusType;
                    } else {
                        typeKey = weightedPool[Math.floor(Math.random() * weightedPool.length)];
                    }
                } else {
                    typeKey = weightedPool[Math.floor(Math.random() * weightedPool.length)];
                }

                store.powerups.push({ x, y, r: 12, type: typeKey });
                store.world.powerupCooldown = 6;
            }

            function spawnVoidCoreDrop(x, y) {
                if (!store.powerups) store.powerups = [];
                store.powerups.push({ x, y, r: 14, type: 'void_core' });
            }

            const VOID_CHAMPION_REWARD_POOL = ['multishot_bundle', 'attack_speed', 'star_upgrade'];
            const VOID_CHAMPION_REWARD_MAP = {
                purple: 'attack_speed',
                crimson: 'attack_speed',
                azure: 'multishot_bundle',
                emerald: 'star_upgrade',
                golden: 'cash_bundle'
            };

            // Upgrade tier definitions for powerup drops
            const UPGRADE_TIERS = {
                midTier: [
                    'hp', 'max_shield', 'speed', 'dmg', 'crit_chance', 'luck_boost',
                    'magnet_pull', 'rear_guard', 'repair', 'nano_save'
                ],
                bossTier: [
                    'vampirism', 'grenade', 'launcher', 'star_cannon', 'ghost_hounds',
                    'iceman', 'lazarus_beam', 'gravity_well'
                ]
            };

            function spawnMultishotBundle(x, y) {
                if (!store.powerups) store.powerups = [];
                const offsets = [-36, 0, 36];
                offsets.forEach((offset, index) => {
                    store.powerups.push({
                        x: x + offset,
                        y: y - index * 6,
                        r: 12,
                        type: 'double'
                    });
                });
            }

            function spawnSpecialPowerup(type, x, y) {
                if (!store.powerups) store.powerups = [];
                store.powerups.push({ x, y, r: 14, type });
            }

            function rollChampionVariantForTier(tier) {
                if (tier === 'bossTier') {
                    const roll = Math.random();
                    if (roll > 0.85) return 'legendary';
                    if (roll > 0.45) return 'major';
                    return 'minor';
                }
                const roll = Math.random();
                if (roll > 0.8) return 'legendary';
                if (roll > 0.45) return 'major';
                return 'minor';
            }

            function spawnChampionUpgradePowerup(x, y, variant = 'minor', opts = {}) {
                if (!store.player?.championUnlocked && !opts.allowWithoutChampion) {
                    return false;
                }
                if (!store.powerups) store.powerups = [];
                const powerup = {
                    x,
                    y,
                    r: 14,
                    type: 'champion_upgrade',
                    championVariant: variant,
                    pulseOffset: opts.pulseOffset !== undefined ? opts.pulseOffset : Math.random() * Math.PI * 2,
                    fallbackTier: opts.fallbackTier || 'midTier'
                };
                if (opts.source) powerup.source = opts.source;
                if (opts.isVoidReaper) powerup.isVoidReaper = true;
                store.powerups.push(powerup);
                return true;
            }

            function spawnUpgradePowerup(x, y, tier = 'midTier', opts = {}) {
                if (!store.powerups) store.powerups = [];
                const options = opts || {};
                const championEligible = store.player?.championUnlocked;
                const allowChampion = options.allowChampion !== undefined ? !!options.allowChampion : tier === 'midTier';
                const forcedChampion = options.forceChampion === true;
                const baseChance = options.championChance !== undefined ? options.championChance : (tier === 'midTier' ? 0.28 : 0);
                const championChance = forcedChampion ? 1 : Math.max(0, Math.min(1, baseChance));
                const shouldConvertToChampion = !options.forceStandard && championEligible && allowChampion && championChance > 0 && Math.random() < championChance;
                if (shouldConvertToChampion || forcedChampion) {
                    const variant = options.championVariant || rollChampionVariantForTier(tier);
                    const championOptions = { ...options, fallbackTier: options.fallbackTier || tier };
                    if (spawnChampionUpgradePowerup(x, y, variant, championOptions)) {
                        return;
                    }
                }
                store.powerups.push({
                    x,
                    y,
                    r: 14,
                    type: 'upgrade',
                    upgradeTier: tier
                });
            }

            function spawnCashBundle(x, y) {
                if (!store.powerups) store.powerups = [];
                const offsets = [-30, 0, 30];
                offsets.forEach((offset, index) => {
                    store.powerups.push({
                        x: x + offset,
                        y: y - index * 8,
                        r: 14,
                        type: 'cash'
                    });
                });
            }

            function spawnVoidReaperLootPowerup(x, y, { championChance = 0.45, variant = null, pulseOffset = 0 } = {}) {
                const championEligible = store.player?.championUnlocked;
                const chance = clamp(championChance, 0, 1);
                let droppedChampion = false;
                if (championEligible) {
                    const shouldChampion = variant ? true : Math.random() < chance;
                    if (shouldChampion) {
                        const pickedVariant = variant || rollChampionVariantForTier('bossTier');
                        droppedChampion = spawnChampionUpgradePowerup(x, y, pickedVariant, {
                            isVoidReaper: true,
                            fallbackTier: 'bossTier',
                            source: 'void_reaper',
                            pulseOffset
                        });
                    }
                }

                if (!droppedChampion) {
                    if (!store.powerups) store.powerups = [];
                    store.powerups.push({
                        x,
                        y,
                        r: 14,
                        type: 'cash',
                        isVoidReaper: true,
                        pulseOffset
                    });
                }
            }

            function getChampionUpgradeRewardPools(state = ensureChampionUpgradeState()) {
                const pools = {
                    attack: [],
                    cadence: [],
                    protocol: [],
                    skin: []
                };
                if (!store.player?.championUnlocked) {
                    return pools;
                }

                const attackCatalogue = getChampionAttackCatalogue(state);
                attackCatalogue.forEach(mod => {
                    if (!mod.unlocked) {
                        pools.attack.push({
                            type: 'attack',
                            id: mod.id,
                            name: mod.name,
                            icon: mod.icon || 'âš”ï¸',
                            desc: mod.desc,
                            apply: () => {
                                state.unlockedAttacks[mod.id] = true;
                                state.attackModule = mod.id;
                                notifyChampionLoadoutChanged({ refreshMinions: true });
                                announce(`Champion module secured: ${mod.name}!`);
                                playSound('epicHorn');
                            }
                        });
                    }
                });

                const cadenceNext = getNextChampionCadenceUpgrade(state);
                if (cadenceNext && cadenceNext.option) {
                    const next = cadenceNext.option;
                    pools.cadence.push({
                        type: 'cadence',
                        level: next.level,
                        name: next.name,
                        icon: 'ðŸŽµ',
                        desc: next.desc || 'Improves guardian firing rhythm.',
                        apply: () => {
                            state.cadenceLevel = next.level;
                            notifyChampionLoadoutChanged({ refreshMinions: true });
                            announce(`Champion cadence aligned: ${next.name}!`);
                            playSound('epicHorn');
                        }
                    });
                }

                const protocolNext = getNextChampionProtocolUpgrade(state);
                if (protocolNext && protocolNext.option) {
                    const next = protocolNext.option;
                    pools.protocol.push({
                        type: 'protocol',
                        level: next.level,
                        name: next.name,
                        icon: 'ðŸ›°ï¸',
                        desc: next.desc || 'Enhances escort minion behavior.',
                        apply: () => {
                            state.minionProtocols = next.level;
                            notifyChampionLoadoutChanged({ refreshMinions: true });
                            announce(`Minion protocols upgraded: ${next.name}!`);
                            playSound('epicHorn');
                        }
                    });
                }

                const skinNext = getNextChampionSkinUnlock(state);
                if (skinNext && skinNext.option) {
                    const option = skinNext.option;
                    pools.skin.push({
                        type: 'skin',
                        id: option.id,
                        name: option.name,
                        icon: option.icon || 'ðŸŽ¨',
                        desc: option.desc || 'New guardian plating unlocked.',
                        apply: () => {
                            state.unlockedSkins[option.id] = true;
                            state.skin = option.id;
                            notifyChampionLoadoutChanged({ refreshMinions: true });
                            announce(`Champion plating unlocked: ${option.name}!`);
                            playSound('epicHorn');
                        }
                    });
                }

                return pools;
            }

            function pickChampionUpgradeReward(variant, pools) {
                const sequences = {
                    minor: [pools.cadence, pools.protocol, pools.attack, pools.skin],
                    major: [pools.attack, pools.cadence, pools.protocol, pools.skin],
                    legendary: [pools.skin, pools.attack, pools.cadence, pools.protocol]
                };
                const sequence = sequences[variant] || sequences.major;
                for (const pool of sequence) {
                    if (Array.isArray(pool) && pool.length > 0) {
                        return pool[Math.floor(Math.random() * pool.length)];
                    }
                }
                const fallback = [];
                ['attack', 'cadence', 'protocol', 'skin'].forEach(key => {
                    if (Array.isArray(pools[key])) {
                        fallback.push(...pools[key]);
                    }
                });
                if (fallback.length === 0) return null;
                return fallback[Math.floor(Math.random() * fallback.length)];
            }

            function grantChampionUpgradeReward(variant = 'minor', { fallbackTier = null, source = 'powerup', skipPopup = false } = {}) {
                if (!store.player?.championUnlocked) {
                    if (fallbackTier) {
                        applyRandomUpgrade(fallbackTier, { skipChampionChance: true });
                        return true;
                    }
                    return false;
                }

                const state = ensureChampionUpgradeState();
                const pools = getChampionUpgradeRewardPools(state);
                const reward = pickChampionUpgradeReward(variant, pools);
                if (!reward) {
                    if (fallbackTier) {
                        applyRandomUpgrade(fallbackTier, { skipChampionChance: true });
                        return true;
                    }
                    return false;
                }

                reward.apply();

                const championUpgradeCount = (state.primaryPicked || 0) + (state.defensePicked || 0) + (state.utilityPicked || 0);
                const upgradeDesc = reward.desc || 'Guardian systems enhanced.';
                const leadIn = (!skipPopup && championUpgradeCount === 0)
                    ? 'PRIME GUARDIAN UPGRADE'
                    : 'Guardian systems upgraded';
                announce(`${reward.icon || 'ðŸ§¬'} ${leadIn}: ${reward.name} â€” ${upgradeDesc}`);

                return true;
            }

            function handleVoidChampionReward(enemy) {
                if (!enemy || enemy.voidChampionRewardGranted) return;
                const scheme = getVoidChampionColorScheme(enemy);
                const colorKey = enemy.colorScheme || 'purple';
                if (!enemy.voidChampionRewardKey) {
                    let rewardKey = VOID_CHAMPION_REWARD_MAP[colorKey] || 'attack_speed';
                    if (rewardKey === 'random_high_tier') {
                        rewardKey = VOID_CHAMPION_REWARD_POOL[Math.floor(Math.random() * VOID_CHAMPION_REWARD_POOL.length)];
                    }
                    enemy.voidChampionRewardKey = rewardKey;
                }

                enemy.voidChampionRewardGranted = true;
                const rewardKey = enemy.voidChampionRewardKey;
                const dropX = enemy.x;
                const dropY = enemy.y - 12;

                switch (rewardKey) {
                    case 'multishot_bundle':
                        spawnMultishotBundle(dropX, dropY);
                        announce(`${scheme.name} shattered! Triple scatter caches deployed!`);
                        break;
                    case 'attack_speed':
                        spawnSpecialPowerup('attack_speed', dropX, dropY);
                        announce(`${scheme.name} dismantled! Hyper drive matrix recovered!`);
                        break;
                    case 'star_upgrade':
                        spawnSpecialPowerup('star_upgrade', dropX, dropY);
                        announce(`${scheme.name} defeated! Star core schematics salvaged!`);
                        break;
                    case 'cash_bundle':
                        spawnCashBundle(dropX, dropY);
                        announce(`${scheme.name} destroyed! Triple cash infusion secured!`);
                        break;
                    default:
                        spawnSpecialPowerup('attack_speed', dropX, dropY);
                        announce(`${scheme.name} neutralized! Hyper drive cache secured!`);
                        break;
                }
            }

            function applyPowerup(typeKey, x, y) {
                const p = store.player;
                const powerup = POWERUP_TYPES[typeKey];
                const hasCoords = typeof x === 'number' && typeof y === 'number';
                
                if (typeKey === 'shadow_champion_token') {
                    grantChampionCompanion();
                    return;
                }
                if (typeKey === 'champion_upgrade') {
                    const pending = store.pendingChampionUpgrade || {};
                    delete store.pendingChampionUpgrade;
                    const variant = pending.variant || pending.championVariant || 'minor';
                    const fallbackTier = pending.fallbackTier || 'midTier';
                    const source = pending.source || 'powerup';
                    if (hasCoords) {
                        addFloatingText(x, y, powerup.name, { color: '#FF1493', fontSize: 18 });
                    } else {
                        announce(powerup.name);
                    }
                    grantChampionUpgradeReward(variant, { fallbackTier, source });
                    return;
                }
                if (typeKey === 'missile') {
                    const duration = powerup.duration || 20;
                    const timer = p.powerupTimers[typeKey];
                    if (timer) {
                        timer.remaining += duration;
                    } else {
                        p.powerupTimers[typeKey] = { remaining: duration, max: duration };
                    }

                    if (p.pilotGenome === 'rocketman') {
                        const currentVolley = Number.isFinite(p.missileVolley) ? p.missileVolley : 2;
                        p.missileVolley = Math.min(5, currentVolley + 2);
                    } else {
                        p.missileVolley = Math.max(2, p.missileVolley || 0);
                    }

                    if (hasCoords) {
                        addFloatingText(x, y, 'ðŸš€ MISSILES', { color: '#FF6B35', fontSize: 14 });
                    } else {
                        announce(powerup.name);
                    }
                    return;
                }
                if (typeKey === 'collar_fragment') {
                    const collarGain = 1.75;
                    scheduleCollarIncrease(collarGain);
                    if (!store.activeEffects) {
                        store.activeEffects = [];
                    }
                    store.activeEffects.push(createEffect('spawnTeleport', p.x, p.y, 36, {
                        color: '#5df4d6',
                        duration: 0.55
                    }));
                    announce(`Collar lattice reinforced +${collarGain.toFixed(1)} stacks!`);
                    return;
                }
                if (typeKey === 'cash') {
                    const baseGoldValue = 8;
                    const waveScaling = Math.max(1, store.world.wave * 1.5);
                    const goldAmount = Math.floor(baseGoldValue * waveScaling);
                    if (goldAmount > 0) {
                        addWorldGold(goldAmount);
                        announce(`ðŸ’° CASH INFUSION +${goldAmount} GOLD! ðŸ’°`);
                        playSound('coinPickup'); // Play the new coin_pickup.wav
                    }
                    return;
                }
                if (typeKey === 'attack_speed') {
                    const newStacks = (p.attackSpeedStacks || 0) + 1;
                    p.attackSpeedStacks = newStacks;
                    p.fireRate = Math.max(p.fireRate * 0.88, 0.045);
                    announce(`HYPER DRIVE +12% (${newStacks} stack${newStacks === 1 ? '' : 's'})`);
                    return;
                }
                if (typeKey === 'split_shot') {
                    const duration = powerup.duration || 8;
                    const timer = p.powerupTimers[typeKey];
                    if (timer) {
                        timer.remaining += duration;
                        timer.max = (timer.max || duration) + duration;
                    } else {
                        p.powerupTimers[typeKey] = { remaining: duration, max: duration };
                    }
                    p.splitShotActive = true;
                    if (hasCoords) {
                        addFloatingText(x, y, powerup.name, { color: '#ff6bd6', fontSize: 14 });
                    } else {
                        announce(powerup.name);
                    }
                    return;
                }
                if (typeKey === 'pierce_shot') {
                    const duration = powerup.duration || 8;
                    const bonus = Number.isFinite(powerup.pierceBonus) ? powerup.pierceBonus : 2;
                    const timer = p.powerupTimers[typeKey];
                    if (timer) {
                        timer.remaining += duration;
                        timer.max = (timer.max || duration) + duration;
                    } else {
                        p.powerupTimers[typeKey] = { remaining: duration, max: duration };
                        p.piercing = (p.piercing || 0) + bonus;
                        p.piercingPowerupBonus = bonus;
                    }
                    p.piercingPowerupActive = true;
                    if (hasCoords) {
                        addFloatingText(x, y, powerup.name, { color: '#ff4fa3', fontSize: 14 });
                    } else {
                        announce(powerup.name);
                    }
                    return;
                }
                if (typeKey === 'star_upgrade') {
                    const upgrade = SHOP_UPGRADES && SHOP_UPGRADES.star_cannon;
                    if (upgrade) {
                        const currentLevel = p.upgradeLevels.star_cannon || 0;
                        const maxLevel = upgrade.maxLevel ?? 3;
                        if (currentLevel < maxLevel) {
                            upgrade.effect(currentLevel);
                            p.upgradeLevels.star_cannon = currentLevel + 1;
                            announce('STAR CANNON BLUEPRINT ACQUIRED (FREE)!');
                        } else {
                            announce('Star core surplus! Converting to hyper drive.');
                            applyPowerup('attack_speed', x, y);
                        }
                    }
                    return;
                }
                if (typeKey === 'void_core') {
                    const timer = p.powerupTimers[typeKey];
                    const prevStacks = timer ? (timer.stacks || 0) : 0;
                    const newStacks = Math.min(3, prevStacks + 1);
                    const prevDmgMult = p.voidCoreDmgMult || 1;
                    const prevFireRateMult = p.voidCoreFireRateMult || 1;
                    const newDmgMult = 1 + newStacks * 0.3;
                    const newFireRateMult = 1 + newStacks * 0.2;

                    p.dmgMult = (p.dmgMult / prevDmgMult) * newDmgMult;
                    p.fireRate = (p.fireRate * prevFireRateMult) / newFireRateMult;
                    p.fireRate = Math.max(p.fireRate, 0.05);

                    p.voidCoreStacks = newStacks;
                    p.voidCoreDmgMult = newDmgMult;
                    p.voidCoreFireRateMult = newFireRateMult;

                    if (timer) {
                        timer.remaining = powerup.duration;
                        timer.max = powerup.duration;
                        timer.stacks = newStacks;
                    } else {
                        p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration, stacks: newStacks };
                    }

                    announce(`VOID CORE RESONANCE x${newStacks}`);
                    announce(powerup.name);
                    return;
                }
                if (typeKey === 'upgrade') {
                    // Handle upgrade powerup collection - need to find the tier from the powerup being collected
                    // This will be passed through the collection system
                    applyRandomUpgrade(store.currentUpgradeTier || 'midTier');
                    delete store.currentUpgradeTier; // Clean up
                    delete store.pendingChampionUpgrade;
                    return;
                }
                if (powerup.type === 'timed') {
                    if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
                    else {
                        if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                        p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
                    }
                } else if (powerup.type === 'instant') {
                    if (typeKey === 'shield') {
                        p.shieldBubbleCount = (p.shieldBubbleCount || 0) + 1;
                        p.hasShieldBubble = true;
                    }
                    if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
                    if (typeKey === 'double') {
                        const p = store.player;
                        if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                        if (hasCoords) {
                            addFloatingText(x, y, 'SCATTER SHOT', { color: '#00FFFF', fontSize: 14 });
                        } else {
                            announce('SCATTER SHOT!');
                        }
                        return;
                    }
                }
                
                // Use floating text for basic powerups (shield, repair, drones), announcements for special ones
                if (hasCoords && (typeKey === 'shield' || typeKey === 'repair' || typeKey === 'drones')) {
                    const colors = { shield: '#4169E1', repair: '#FF1493', drones: '#32CD32' };
                    addFloatingText(x, y, powerup.name, { color: colors[typeKey] || '#FFD700', fontSize: 14 });
                } else if (!hasCoords || typeKey === 'void_core' || typeKey === 'upgrade') {
                    // Keep announcements for special powerups and when coordinates aren't available
                    announce(powerup.name);
                }
            }

            function applyRandomUpgrade(forcedTier = null, options = {}) {
                const tier = forcedTier || 'midTier';
                const opts = options || {};
                const championEligible = store.player?.championUnlocked;

                if (!opts.skipChampionChance) {
                    const forcedVariant = opts.forceChampionVariant || (store.pendingChampionUpgrade && store.pendingChampionUpgrade.variant);
                    if (forcedVariant && championEligible) {
                        delete store.pendingChampionUpgrade;
                        if (grantChampionUpgradeReward(forcedVariant, { fallbackTier: tier, source: opts.source || 'powerup', skipPopup: opts.skipChampionPopup === true })) {
                            return;
                        }
                    } else if (championEligible && tier === 'midTier') {
                        const chance = opts.championChance ?? 0.22;
                        if (Math.random() < chance) {
                            const variant = opts.championVariant || rollChampionVariantForTier(tier);
                            if (grantChampionUpgradeReward(variant, { fallbackTier: tier, source: opts.source || 'powerup', skipPopup: opts.skipChampionPopup === true })) {
                                return;
                            }
                        }
                    }
                }

                const availableUpgrades = UPGRADE_TIERS[tier] || UPGRADE_TIERS.midTier;

                const eligibleUpgrades = availableUpgrades.filter(key => {
                    const upgrade = SHOP_UPGRADES[key];
                    if (!upgrade) return false;

                    const info = getNextUpgradeCost(key);
                    return info && Number.isFinite(info.cost);
                });

                if (eligibleUpgrades.length === 0) {
                    const goldAmount = tier === 'bossTier' ? 200 : 100;
                    addWorldGold(goldAmount);
                    showUpgradePopup({
                        name: 'GOLD CACHE',
                        icon: 'ðŸ’°',
                        desc: `+${goldAmount} Gold (No upgrades available)`,
                        tier: tier
                    });
                    return;
                }

                const selectedKey = eligibleUpgrades[Math.floor(Math.random() * eligibleUpgrades.length)];
                const upgrade = SHOP_UPGRADES[selectedKey];
                const miniAbilityKeys = ['gravity_well', 'lazarus_beam', 'ghost_hounds', 'launcher', 'grenade'];

                let result;
                if (selectedKey === 'iceman' && tier === 'bossTier') {
                    if (!store.escortDrones) store.escortDrones = [];
                    const droneIndex = store.escortDrones.length;
                    const side = droneIndex % 2 === 0 ? 'left' : 'right';
                    store.escortDrones.push({
                        x: store.player.x,
                        y: store.player.y,
                        side: side,
                        offset: droneIndex,
                        fireT: Math.random() * 0.3
                    });
                    result = { success: true, cost: 0, key: selectedKey };
                } else {
                    result = attemptPurchaseUpgrade(selectedKey, { silent: true, free: true });

                    if (result.success && tier === 'bossTier') {
                        if (!store.player.miniAbilities) store.player.miniAbilities = new Set();
                        if (miniAbilityKeys.includes(selectedKey)) {
                            store.player.miniAbilities.add(selectedKey);
                        }
                    }
                }

                if (result.success) {
                    const level = (store.player?.upgradeLevels && store.player.upgradeLevels[selectedKey]) || 0;
                    const name = typeof upgrade.getName === 'function' ? upgrade.getName(null, level - 1) : upgrade.name;
                    const desc = typeof upgrade.desc === 'function' ? upgrade.desc(level - 1) : upgrade.desc;
                    const isMiniUnlock = tier === 'bossTier' && miniAbilityKeys.includes(selectedKey);

                    if (isMiniUnlock) {
                        announce(`${upgrade.icon || 'âš¡'} MINI-PROTOCOL ONLINE: ${name} â€” ${desc}`);
                    } else {
                        showUpgradePopup({
                            name: name,
                            icon: upgrade.icon || 'âš¡',
                            desc: desc,
                            tier: tier
                        });
                    }
                } else {
                    const goldAmount = tier === 'bossTier' ? 150 : 75;
                    addWorldGold(goldAmount);
                    showUpgradePopup({
                        name: 'COMPENSATION CACHE',
                        icon: 'ðŸ’°',
                        desc: `+${goldAmount} Gold (Upgrade failed)`
                    });
                }
            }

            function sanitizeCollarStacks() {
                if (!Number.isFinite(store.world.collarStacks)) {
                    store.world.collarStacks = 0;
                }
                if (!Number.isFinite(store.world.collarTargetStacks)) {
                    store.world.collarTargetStacks = store.world.collarStacks;
                }
                return store.world.collarStacks;
            }
            
            // NO UPPER LIMIT - Collar can scale infinitely to handle any broken build
            const COLLAR_TARGET_GAIN_MULTIPLIER = 1.6;

            function calculateCollarBonus(stacks) {
                // STEEPER SCALING: Increased by 1% per tier to create meaningful challenge
                const safeStacks = Math.max(0, Number.isFinite(stacks) ? stacks : 0);
                
                // Progressive tiered scaling - matches player power growth more closely
                const tierOneLimit = 5;   // First 5 stacks: 5% each
                const tierTwoLimit = 10;  // Next 5 stacks: 6% each
                const tierThreeLimit = 20; // Next 10 stacks: 7% each
                const tierFourLimit = 40;  // Next 20 stacks: 9% each
                const tierFiveLimit = 70;  // Next 30 stacks: 11% each
                
                const tierOne = Math.min(safeStacks, tierOneLimit);
                const tierTwo = Math.min(Math.max(safeStacks - tierOneLimit, 0), tierTwoLimit - tierOneLimit);
                const tierThree = Math.min(Math.max(safeStacks - tierTwoLimit, 0), tierThreeLimit - tierTwoLimit);
                const tierFour = Math.min(Math.max(safeStacks - tierThreeLimit, 0), tierFourLimit - tierThreeLimit);
                const tierFive = Math.min(Math.max(safeStacks - tierFourLimit, 0), tierFiveLimit - tierFourLimit);
                const tierSix = Math.max(safeStacks - tierFiveLimit, 0); // Beyond 70: 13% each
                
                const bonus = 
                    tierOne * 0.05 +    // 0-5: 5% per stack (increased from 4%)
                    tierTwo * 0.06 +    // 5-10: 6% per stack (increased from 5%)
                    tierThree * 0.07 +  // 10-20: 7% per stack (increased from 6%)
                    tierFour * 0.09 +   // 20-40: 9% per stack (increased from 8%)
                    tierFive * 0.11 +   // 40-70: 11% per stack (increased from 10%)
                    tierSix * 0.13;     // 70+: 13% per stack (increased from 12%)
                
                return 1 + bonus;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CONTINUOUS SPAWN SYSTEM - Dynamic Movement Behaviors
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const MOVEMENT_BEHAVIORS = Object.freeze({
                STRAIGHT: 'straight',       // Move straight down
                ZIGZAG: 'zigzag',          // Sinusoidal weaving
                FOLLOW: 'follow',          // Track player position
                STRAFE: 'strafe',          // Horizontal movement + slow descent
                CIRCLE: 'circle',          // Circular orbit pattern
                DIVE: 'dive',              // Rapid diagonal dives
                RETREAT: 'retreat',        // Move up if player gets close
                SWARM: 'swarm'             // Aggressive homing
            });

            // Pursuit AI booster: burst past the player occasionally so dodging requires repositioning
            function maybeHandleChaseOvershoot(enemy, dt, speedMultiplier = 1, baseSpeedOverride, overrides) {
                if (!enemy || enemy.dead || !store?.player) return false;

                const config = Object.assign({
                    triggerRange: 260,
                    cooldownMin: 1.6,
                    cooldownMax: 3.4,
                    durationMin: 0.32,
                    durationMax: 0.58,
                    speedBoostMin: 1.35,
                    speedBoostMax: 1.85,
                    angleJitter: 0.5,
                    overshootBias: 140,
                    downwardBias: 0,
                    recheckDelay: 0.35
                }, overrides || {});

                const player = store.player;
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < 4) return false;
                const dist = Math.sqrt(distSq);

                let state = enemy.pursuitOvershootState;
                if (!state) {
                    state = enemy.pursuitOvershootState = {
                        cooldown: randRange(config.cooldownMin, config.cooldownMax),
                        active: false,
                        duration: 0,
                        speedBoost: 1.5,
                        angle: 0
                    };
                }

                const baseSpeed = Number.isFinite(baseSpeedOverride) ? baseSpeedOverride : (enemy.v || 60);

                const applyOvershootStep = () => {
                    const speed = baseSpeed * (state.speedBoost || 1.5);
                    enemy.x += Math.cos(state.angle) * speed * speedMultiplier * dt;
                    enemy.y += Math.sin(state.angle) * speed * speedMultiplier * dt;
                    if (config.downwardBias) {
                        enemy.y += baseSpeed * config.downwardBias * speedMultiplier * dt;
                    }
                };

                if (state.active) {
                    state.duration -= dt;
                    applyOvershootStep();
                    if (state.duration <= 0) {
                        state.active = false;
                        state.cooldown = randRange(config.cooldownMin, config.cooldownMax);
                    }
                    return true;
                }

                state.cooldown -= dt;
                if (state.cooldown > 0) {
                    return false;
                }

                if (dist > config.triggerRange) {
                    state.cooldown = config.recheckDelay;
                    return false;
                }

                const baseAngle = Math.atan2(dy, dx);
                const overshootTargetX = player.x + Math.cos(baseAngle) * config.overshootBias;
                const overshootTargetY = player.y + Math.sin(baseAngle) * config.overshootBias;
                const angleOffset = (Math.random() - 0.5) * config.angleJitter;

                state.angle = Math.atan2(overshootTargetY - enemy.y, overshootTargetX - enemy.x) + angleOffset;
                state.speedBoost = randRange(config.speedBoostMin, config.speedBoostMax);
                state.duration = randRange(config.durationMin, config.durationMax);
                state.active = true;
                state.cooldown = randRange(config.cooldownMin, config.cooldownMax);

                state.duration -= dt;
                applyOvershootStep();
                if (state.duration <= 0) {
                    state.active = false;
                    state.cooldown = randRange(config.cooldownMin, config.cooldownMax);
                }

                return true;
            }

            // Apply movement behavior to enemy
            function applyMovementBehavior(enemy, dt) {
                if (!enemy || enemy.dead || enemy.spawnPhase === 'teleport') return;
                if (enemy.type === 'cube_burglar' || enemy.isVoidReaper || enemy.type === 'shadow_champion' || enemy.type === 'void_champion') {
                    return; // Skip special enemies with custom movement
                }

                const behavior = enemy.movementBehavior || MOVEMENT_BEHAVIORS.STRAIGHT;
                const speedMult = enemy.speedMultiplier || 1;
                const baseSpeed = enemy.v || 60;
                
                enemy.behaviorTime = (enemy.behaviorTime || 0) + dt;

                switch (behavior) {
                    case MOVEMENT_BEHAVIORS.ZIGZAG:
                        {
                            const zigzagSpeed = 120;
                            const zigzagFreq = 2.5;
                            const horizontalMove = Math.sin(enemy.behaviorTime * zigzagFreq) * zigzagSpeed;
                            enemy.x += horizontalMove * speedMult * dt;
                            enemy.y += baseSpeed * 0.7 * speedMult * dt;
                        }
                        break;

                    case MOVEMENT_BEHAVIORS.FOLLOW:
                        {
                            const followSpeed = baseSpeed * 1.2;
                            if (maybeHandleChaseOvershoot(enemy, dt, speedMult, followSpeed, {
                                triggerRange: 300,
                                cooldownMin: 1.5,
                                cooldownMax: 3.2,
                                durationMin: 0.3,
                                durationMax: 0.55,
                                speedBoostMin: 1.35,
                                speedBoostMax: 1.75,
                                angleJitter: 0.42,
                                overshootBias: 170
                            })) {
                                break;
                            }

                            const dx = store.player.x - enemy.x;
                            const dy = store.player.y - enemy.y;
                            const dist = Math.max(1, Math.hypot(dx, dy));
                            enemy.x += (dx / dist) * followSpeed * speedMult * dt;
                            enemy.y += (dy / dist) * followSpeed * speedMult * dt;
                        }
                        break;

                    case MOVEMENT_BEHAVIORS.STRAFE:
                        {
                            if (enemy.strafeDir === undefined) {
                                enemy.strafeDir = Math.random() < 0.5 ? -1 : 1;
                            }
                            const strafeSpeed = 90;
                            enemy.x += enemy.strafeDir * strafeSpeed * speedMult * dt;
                            enemy.y += baseSpeed * 0.5 * speedMult * dt;
                            
                            if (enemy.x < enemy.r + 20 || enemy.x > W - enemy.r - 20) {
                                enemy.strafeDir *= -1;
                            }
                        }
                        break;

                    case MOVEMENT_BEHAVIORS.CIRCLE:
                        {
                            if (enemy.orbitAngle === undefined) {
                                enemy.orbitAngle = Math.atan2(enemy.y - H/2, enemy.x - W/2);
                                enemy.orbitRadius = Math.hypot(enemy.x - W/2, enemy.y - H/2);
                            }
                            enemy.orbitAngle += 1.5 * dt;
                            enemy.orbitRadius = Math.max(100, enemy.orbitRadius - 15 * dt);
                            enemy.x = W/2 + Math.cos(enemy.orbitAngle) * enemy.orbitRadius;
                            enemy.y = H/2 + Math.sin(enemy.orbitAngle) * enemy.orbitRadius;
                        }
                        break;

                    case MOVEMENT_BEHAVIORS.DIVE:
                        {
                            if (enemy.diveTimer === undefined) {
                                enemy.diveTimer = 1.5 + Math.random();
                                enemy.diving = false;
                            }

                            if (!enemy.diving) {
                                enemy.diveTimer -= dt;
                                const dx = store.player.x - enemy.x;
                                enemy.x += Math.sign(dx) * Math.min(Math.abs(dx), 80 * dt);
                                enemy.y += baseSpeed * 0.3 * speedMult * dt;

                                if (enemy.diveTimer <= 0) {
                                    enemy.diving = true;
                                    const angle = Math.atan2(store.player.y - enemy.y, store.player.x - enemy.x);
                                    enemy.diveVX = Math.cos(angle) * baseSpeed * 2.5;
                                    enemy.diveVY = Math.sin(angle) * baseSpeed * 2.5;
                                }
                            } else {
                                enemy.x += enemy.diveVX * speedMult * dt;
                                enemy.y += enemy.diveVY * speedMult * dt;
                            }
                        }
                        break;

                    case MOVEMENT_BEHAVIORS.RETREAT:
                        {
                            const dx = store.player.x - enemy.x;
                            const dy = store.player.y - enemy.y;
                            const distToPlayer = Math.hypot(dx, dy);
                            const retreatThreshold = 150;

                            if (distToPlayer < retreatThreshold) {
                                const angle = Math.atan2(dy, dx) + Math.PI;
                                const retreatSpeed = baseSpeed * 1.5;
                                enemy.x += Math.cos(angle) * retreatSpeed * speedMult * dt;
                                enemy.y += Math.sin(angle) * retreatSpeed * 0.5 * speedMult * dt;
                            } else {
                                enemy.y += baseSpeed * speedMult * dt;
                            }
                        }
                        break;

                    case MOVEMENT_BEHAVIORS.SWARM:
                        {
                            const swarmSpeed = baseSpeed * 1.4;
                            if (maybeHandleChaseOvershoot(enemy, dt, speedMult, swarmSpeed, {
                                triggerRange: 260,
                                cooldownMin: 1.2,
                                cooldownMax: 2.6,
                                durationMin: 0.26,
                                durationMax: 0.5,
                                speedBoostMin: 1.45,
                                speedBoostMax: 1.95,
                                angleJitter: 0.55,
                                overshootBias: 150,
                                downwardBias: 0.18
                            })) {
                                break;
                            }

                            const dx = store.player.x - enemy.x;
                            const dy = store.player.y - enemy.y;
                            const dist = Math.max(1, Math.hypot(dx, dy));
                            const weave = Math.sin(enemy.behaviorTime * 4) * 30;
                            enemy.x += (dx / dist) * swarmSpeed * speedMult * dt + weave * dt;
                            enemy.y += (dy / dist) * swarmSpeed * speedMult * dt;
                        }
                        break;

                    case MOVEMENT_BEHAVIORS.STRAIGHT:
                    default:
                        enemy.y += baseSpeed * speedMult * dt;
                        break;
                }

                enemy.x = Math.max(enemy.r + 5, Math.min(W - enemy.r - 5, enemy.x));
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HUNTER GANG SYSTEM - Coordinated Color Schemes
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const HUNTER_GANGS = Object.freeze({
                CRIMSON: {
                    name: 'Crimson Vipers',
                    bodyColor: '#cc3344',
                    bodyStroke: '#7a1b24',
                    headColor: '#e47777',
                    headbandColor: '#8B0000',
                    eyeColor: '#250b0b',
                    ability: 'lunge', // Aggressive lunge attack when damaged
                    key: 'CRIMSON'
                },
                PURPLE: {
                    name: 'Purple Serpents',
                    bodyColor: '#7B3FB2',
                    bodyStroke: '#4B0082',
                    headColor: '#B388EB',
                    headbandColor: '#6A0DAD',
                    eyeColor: '#1a0a2e',
                    ability: 'formation', // Fly in V-formation
                    key: 'PURPLE'
                },
                EMERALD: {
                    name: 'Emerald Fangs',
                    bodyColor: '#2d8a4e',
                    bodyStroke: '#1a5c34',
                    headColor: '#4dbd74',
                    headbandColor: '#0F7C3E',
                    eyeColor: '#0a2817',
                    ability: 'flee', // Flee to corners when threatened
                    key: 'EMERALD'
                },
                AZURE: {
                    name: 'Azure Strikers',
                    bodyColor: '#2874A6',
                    bodyStroke: '#1B4F72',
                    headColor: '#5DADE2',
                    headbandColor: '#1565C0',
                    eyeColor: '#0a1929',
                    ability: 'lightning', // Lightning chain between gang members
                    key: 'AZURE'
                },
                AMBER: {
                    name: 'Amber Predators',
                    bodyColor: '#D68910',
                    bodyStroke: '#935116',
                    headColor: '#F39C12',
                    headbandColor: '#CA6F1E',
                    eyeColor: '#2e1a0f',
                    ability: 'swarm', // Tight swarm formation
                    key: 'AMBER'
                },
                OBSIDIAN: {
                    name: 'Obsidian Reapers',
                    bodyColor: '#2C3E50',
                    bodyStroke: '#17202A',
                    headColor: '#566573',
                    headbandColor: '#1C2833',
                    eyeColor: '#0B0C0D',
                    ability: 'stealth', // Phase in and out
                    key: 'OBSIDIAN'
                }
            });

            const HUNTER_GANG_LIST = ['CRIMSON', 'PURPLE', 'EMERALD', 'AZURE', 'AMBER', 'OBSIDIAN'];

            // Track gang members globally
            const hunterGangMembers = new Map(); // gangKey -> Set of enemy IDs

            // Assign gang to hunter
            function assignHunterGang(enemy) {
                if (enemy.type !== 'hunter') return;
                
                // Pick random gang if not already assigned
                if (!enemy.gang) {
                    const gangKey = HUNTER_GANG_LIST[Math.floor(Math.random() * HUNTER_GANG_LIST.length)];
                    enemy.gang = HUNTER_GANGS[gangKey];
                }
                
                // Track this hunter in their gang
                if (enemy.gang && enemy.gang.key) {
                    if (!hunterGangMembers.has(enemy.gang.key)) {
                        hunterGangMembers.set(enemy.gang.key, new Set());
                    }
                    hunterGangMembers.get(enemy.gang.key).add(enemy.id || enemy);
                }
                
                // Initialize ability-specific properties
                if (enemy.gang && enemy.gang.ability) {
                    switch (enemy.gang.ability) {
                        case 'lunge':
                            enemy.lungeCooldown = 0;
                            enemy.isLunging = false;
                            enemy.lungeTargetX = 0;
                            enemy.lungeTargetY = 0;
                            break;
                        case 'flee':
                            enemy.isFleeing = false;
                            enemy.fleeTargetX = 0;
                            enemy.fleeTargetY = 0;
                            break;
                        case 'formation':
                            enemy.formationIndex = 0;
                            enemy.formationOffset = { x: 0, y: 0 };
                            break;
                        case 'lightning':
                            enemy.lightningTimer = 0;
                            break;
                        case 'stealth':
                            enemy.stealthTimer = 0;
                            enemy.isStealthed = false;
                            break;
                    }
                }
            }
            
            // Clean up dead gang members
            function cleanupDeadGangMembers() {
                const aliveEnemyIds = new Set(store.enemies.map(e => e.id || e));
                
                for (const [gangKey, members] of hunterGangMembers.entries()) {
                    const deadMembers = [];
                    for (const memberId of members) {
                        if (!aliveEnemyIds.has(memberId)) {
                            deadMembers.push(memberId);
                        }
                    }
                    deadMembers.forEach(id => members.delete(id));
                    
                    if (members.size === 0) {
                        hunterGangMembers.delete(gangKey);
                    }
                }
            }
            
            // Get all alive gang members
            function getGangMembers(gangKey) {
                const members = hunterGangMembers.get(gangKey);
                if (!members) return [];
                
                return store.enemies.filter(e => 
                    e.type === 'hunter' && 
                    e.gang && 
                    e.gang.key === gangKey && 
                    !e.dead && 
                    e.hp > 0 &&
                    members.has(e.id || e)
                );
            }
            
            // Update hunter gang-specific abilities
            function updateHunterGangAbility(hunter, dt, speedMultiplier) {
                if (!hunter.gang || !hunter.gang.ability) return;
                
                switch (hunter.gang.ability) {
                    case 'lunge':
                        updateCrimsonLunge(hunter, dt, speedMultiplier);
                        break;
                    case 'formation':
                        updatePurpleFormation(hunter, dt, speedMultiplier);
                        break;
                    case 'flee':
                        updateEmeraldFlee(hunter, dt, speedMultiplier);
                        break;
                    case 'lightning':
                        updateAzureLightning(hunter, dt);
                        break;
                    case 'swarm':
                        updateAmberSwarm(hunter, dt, speedMultiplier);
                        break;
                    case 'stealth':
                        updateObsidianStealth(hunter, dt);
                        break;
                }
            }
            
            // CRIMSON VIPERS: Lunge attack when hit
            function updateCrimsonLunge(hunter, dt, speedMultiplier) {
                hunter.lungeCooldown = Math.max(0, (hunter.lungeCooldown || 0) - dt);
                
                // Trigger lunge when damaged
                if (hunter.wasJustHit && hunter.lungeCooldown <= 0) {
                    hunter.isLunging = true;
                    hunter.lungeTimer = 0.4; // Fast lunge duration
                    hunter.lungeTargetX = store.player.x;
                    hunter.lungeTargetY = store.player.y;
                    hunter.lungeStartX = hunter.x;
                    hunter.lungeStartY = hunter.y;
                    hunter.lungeCooldown = 3.0;
                    hunter.wasJustHit = false;
                }
                
                if (hunter.isLunging) {
                    hunter.lungeTimer = Math.max(0, (hunter.lungeTimer || 0) - dt);
                    const progress = 1 - (hunter.lungeTimer / 0.4);
                    const easeProgress = Math.pow(progress, 0.5); // Ease out
                    
                    hunter.x = hunter.lungeStartX + (hunter.lungeTargetX - hunter.lungeStartX) * easeProgress;
                    hunter.y = hunter.lungeStartY + (hunter.lungeTargetY - hunter.lungeStartY) * easeProgress;
                    
                    if (hunter.lungeTimer <= 0) {
                        hunter.isLunging = false;
                    }
                }
            }
            
            // PURPLE SERPENTS: V-formation flight
            function updatePurpleFormation(hunter, dt, speedMultiplier) {
                const gangMembers = getGangMembers('PURPLE');
                if (gangMembers.length === 0) return;
                
                // Sort by spawn order to determine formation positions
                gangMembers.sort((a, b) => (a.spawnTime || 0) - (b.spawnTime || 0));
                const hunterIndex = gangMembers.indexOf(hunter);
                if (hunterIndex === -1) return;
                
                hunter.formationLocked = true;
                
                // Leader flies straight down the middle
                if (hunterIndex === 0) {
                    hunter.formationTargetX = W / 2;
                } else {
                    // Others form V behind leader
                    const side = hunterIndex % 2 === 1 ? 1 : -1;
                    const row = Math.floor((hunterIndex + 1) / 2);
                    const spacing = 50;
                    hunter.formationTargetX = W / 2 + side * row * spacing;
                }
                
                // Move toward formation position
                const dx = hunter.formationTargetX - hunter.x;
                if (Math.abs(dx) > 5) {
                    hunter.x += Math.sign(dx) * hunter.v * 0.8 * speedMultiplier * dt;
                }
                hunter.y += hunter.v * speedMultiplier * dt;
            }
            
            // EMERALD FANGS: Flee to corners when low HP
            function updateEmeraldFlee(hunter, dt, speedMultiplier) {
                const hpRatio = hunter.hp / hunter.hpMax;
                
                if (hpRatio < 0.5 && !hunter.isFleeing) {
                    hunter.isFleeing = true;
                    // Pick random corner
                    const corners = [
                        { x: 50, y: 50 },
                        { x: W - 50, y: 50 },
                        { x: 50, y: H - 50 },
                        { x: W - 50, y: H - 50 }
                    ];
                    const corner = corners[Math.floor(Math.random() * corners.length)];
                    hunter.fleeTargetX = corner.x;
                    hunter.fleeTargetY = corner.y;
                }
                
                if (hunter.isFleeing) {
                    const dx = hunter.fleeTargetX - hunter.x;
                    const dy = hunter.fleeTargetY - hunter.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 20) {
                        const fleeSpeed = hunter.v * 1.5; // Flee faster!
                        hunter.x += (dx / dist) * fleeSpeed * speedMultiplier * dt;
                        hunter.y += (dy / dist) * fleeSpeed * speedMultiplier * dt;
                    }
                }
            }
            
            // AZURE STRIKERS: Lightning chains between members
            function updateAzureLightning(hunter, dt) {
                hunter.lightningTimer = (hunter.lightningTimer || 0) + dt;
                
                if (hunter.lightningTimer >= 0.5) {
                    hunter.lightningTimer = 0;
                    
                    const gangMembers = getGangMembers('AZURE');
                    if (gangMembers.length < 2) return;
                    
                    // Create lightning chains between nearby gang members
                    for (let i = 0; i < gangMembers.length; i++) {
                        for (let j = i + 1; j < gangMembers.length; j++) {
                            const a = gangMembers[i];
                            const b = gangMembers[j];
                            const dx = b.x - a.x;
                            const dy = b.y - a.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < 200) { // Chain within 200 units
                                store.hunterLightningChains.push({
                                    x1: a.x,
                                    y1: a.y,
                                    x2: b.x,
                                    y2: b.y,
                                    life: 0.3,
                                    damage: 15,
                                    gang: 'AZURE'
                                });
                            }
                        }
                    }
                }
            }
            
            // AMBER PREDATORS: Tight swarm formation
            function updateAmberSwarm(hunter, dt, speedMultiplier) {
                const gangMembers = getGangMembers('AMBER');
                if (gangMembers.length === 0) return;
                
                // Calculate swarm center
                let centerX = 0, centerY = 0;
                for (const member of gangMembers) {
                    centerX += member.x;
                    centerY += member.y;
                }
                centerX /= gangMembers.length;
                centerY /= gangMembers.length;
                
                // Move toward player while maintaining swarm cohesion
                const toPlayerX = store.player.x - centerX;
                const toPlayerY = store.player.y - centerY;
                const toPlayerDist = Math.sqrt(toPlayerX * toPlayerX + toPlayerY * toPlayerY);
                
                if (toPlayerDist > 1) {
                    const targetX = centerX + (toPlayerX / toPlayerDist) * 100;
                    const targetY = centerY + (toPlayerY / toPlayerDist) * 100;
                    
                    // Each member moves toward their position around the swarm center
                    const dx = targetX - hunter.x;
                    const dy = targetY - hunter.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 30) {
                        hunter.x += (dx / dist) * hunter.v * 0.7 * speedMultiplier * dt;
                        hunter.y += (dy / dist) * hunter.v * 0.7 * speedMultiplier * dt;
                    }
                } else {
                    hunter.y += hunter.v * speedMultiplier * dt;
                }
            }
            
            // OBSIDIAN REAPERS: Phase in and out
            function updateObsidianStealth(hunter, dt) {
                hunter.stealthTimer = (hunter.stealthTimer || 0) + dt;
                
                const cycle = hunter.stealthTimer % 4; // 4 second cycle
                if (cycle < 2) {
                    // Visible phase
                    hunter.isStealthed = false;
                    hunter.stealthAlpha = 1;
                } else {
                    // Stealth phase
                    hunter.isStealthed = true;
                    hunter.stealthAlpha = 0.3;
                }
            }

            // Assign random movement behavior based on enemy type and sector theme
            function assignMovementBehavior(enemy, sectorTheme) {
                if (enemy.type === 'phantom') {
                    enemy.movementBehavior = MOVEMENT_BEHAVIORS.ZIGZAG;
                    return;
                }
                if (enemy.type === 'hunter') {
                    enemy.movementBehavior = MOVEMENT_BEHAVIORS.FOLLOW;
                    return;
                }
                if (enemy.type === 'manta') {
                    enemy.movementBehavior = MOVEMENT_BEHAVIORS.ZIGZAG;
                    return;
                }

                const rand = Math.random();
                
                switch (sectorTheme) {
                    case 'SWARM_HELL':
                        enemy.movementBehavior = rand < 0.6 ? MOVEMENT_BEHAVIORS.SWARM : MOVEMENT_BEHAVIORS.FOLLOW;
                        break;
                    case 'DODGE_HELL':
                        enemy.movementBehavior = rand < 0.5 ? MOVEMENT_BEHAVIORS.ZIGZAG : MOVEMENT_BEHAVIORS.STRAFE;
                        break;
                    case 'TANK_RUSH':
                        enemy.movementBehavior = rand < 0.7 ? MOVEMENT_BEHAVIORS.STRAIGHT : MOVEMENT_BEHAVIORS.FOLLOW;
                        break;
                    case 'ELITE_ASSAULT':
                        enemy.movementBehavior = rand < 0.4 ? MOVEMENT_BEHAVIORS.DIVE : MOVEMENT_BEHAVIORS.FOLLOW;
                        break;
                    case 'PRECISION_TEST':
                        enemy.movementBehavior = rand < 0.6 ? MOVEMENT_BEHAVIORS.STRAFE : MOVEMENT_BEHAVIORS.CIRCLE;
                        break;
                    default:
                        const behaviors = [
                            MOVEMENT_BEHAVIORS.STRAIGHT,
                            MOVEMENT_BEHAVIORS.ZIGZAG,
                            MOVEMENT_BEHAVIORS.FOLLOW,
                            MOVEMENT_BEHAVIORS.STRAFE
                        ];
                        enemy.movementBehavior = behaviors[Math.floor(Math.random() * behaviors.length)];
                }
            }

            /**
             * XP DIMINISHING RETURNS SYSTEM
             * 
             * Purpose: Prevents excessive XP farming from collar-accelerated spawn rates while still rewarding skilled play.
             * 
             * How it works:
             * 1. Each wave establishes a "base XP pool" = base spawn count (without collar bonus) Ã— avg XP per enemy (5)
             * 2. Track actual XP earned during the wave
             * 3. When earned XP exceeds 120% of base pool, apply exponential diminishing returns
             * 4. At exactly 120% threshold, excess XP is reduced by ~95%
             * 
             * Example:
             * - Wave spawns 10 enemies base, collar gives 1.5x = 15 enemies total
             * - Base XP pool = 10 Ã— 5 = 50 XP
             * - Threshold = 50 Ã— 1.2 = 60 XP
             * - First 60 XP earned = full value
             * - XP beyond 60 = exponentially diminished (e^(-20 Ã— percentOver))
             * 
             * Result: High collar stacks still feel rewarding but can't infinitely farm XP
             */
            function calculateXpDiminishingReturns(rawXp) {
                if (!store.world || !store.world.waveBaseXpPool) {
                    return rawXp; // No diminishing returns if base pool not established
                }

                const basePool = store.world.waveBaseXpPool;
                const currentWaveXp = store.world.waveXpEarned || 0;
                const projectedTotal = currentWaveXp + rawXp;

                // Threshold: 20% over base pool (1.2x multiplier)
                const threshold = basePool * 1.2;

                if (projectedTotal <= threshold) {
                    // Under threshold - full XP awarded
                    return rawXp;
                }

                // Calculate how much XP is "over budget"
                const excessXp = projectedTotal - threshold;
                const safeXp = rawXp - excessXp;

                // Steep exponential decay for excess XP: each additional percent over threshold gives exponentially less
                // At 120% of base (threshold), multiplier is ~0.05 (95% diminished)
                // Formula: multiplier = e^(-20 * percentOverThreshold)
                const percentOver = excessXp / basePool;
                const diminishingMultiplier = Math.exp(-20 * percentOver);

                const diminishedExcessXp = excessXp * diminishingMultiplier;
                const finalXp = safeXp + diminishedExcessXp;

                // Optional: Log when significant diminishing returns kick in
                if (diminishingMultiplier < 0.5 && rawXp > 0) {
                    // console.log(`XP Diminishing: ${rawXp.toFixed(1)} â†’ ${finalXp.toFixed(1)} (${(diminishingMultiplier * 100).toFixed(1)}% of excess)`);
                }

                return Math.max(0, finalXp);
            }

            // Award XP with diminishing returns applied
            function awardXp(amount) {
                if (!amount || amount <= 0) return 0;

                const scaledAmount = amount > 0 ? amount * XP_REWARD_MULTIPLIER : amount;
                const finalXp = calculateXpDiminishingReturns(scaledAmount);
                store.world.xp += finalXp;
                store.world.waveXpEarned = (store.world.waveXpEarned || 0) + finalXp;
                
                return finalXp;
            }

            // Initialize wave XP tracking - call at start of each wave
            function initializeWaveXpTracking(baseSpawnCount, avgXpPerEnemy = 5) {
                const baseXpPool = baseSpawnCount * avgXpPerEnemy;
                store.world.waveBaseXpPool = baseXpPool;
                store.world.waveXpEarned = 0;
                // console.log(`Wave ${store.world.wave} Base XP Pool: ${baseXpPool} (${baseSpawnCount} enemies Ã— ${avgXpPerEnemy} XP)`);
            }

            function setCollarStacks(value) {
                const clamped = Math.max(0, ensureFiniteNumber(value, 0)); // No upper limit
                store.world.collarStacks = clamped;
                store.world.collarTargetStacks = clamped;
                return clamped;
            }

            function approachCollarTarget() {
                const currentStacks = sanitizeCollarStacks();
                if (!Number.isFinite(store.world.collarTargetStacks)) {
                    store.world.collarTargetStacks = currentStacks;
                }
                const targetStacks = store.world.collarTargetStacks; // No cap
                const stackGap = targetStacks - currentStacks;
                if (stackGap > 0) {
                    const maxIncrease = 1 + Math.min(2, currentStacks * 0.05);
                    const appliedIncrease = Math.min(stackGap, maxIncrease);
                    store.world.collarStacks = currentStacks + appliedIncrease; // No cap
                } else if (stackGap < 0) {
                    setCollarStacks(targetStacks);
                }
            }

            function scheduleCollarIncrease(amount) {
                const delta = ensureFiniteNumber(amount, 0);
                if (delta <= 0) {
                    approachCollarTarget();
                    return;
                }

                const currentStacks = sanitizeCollarStacks();
                if (!Number.isFinite(store.world.collarTargetStacks)) {
                    store.world.collarTargetStacks = currentStacks;
                }
                const boostedDelta = delta * COLLAR_TARGET_GAIN_MULTIPLIER;
                store.world.collarTargetStacks = store.world.collarTargetStacks + boostedDelta; // No cap
                approachCollarTarget();
            }

            function ensureFiniteNumber(value, fallback = 0) {
                return Number.isFinite(value) ? value : fallback;
            }

            function pad(value, digits = 2) {
                const num = Number.isFinite(value) ? value : 0;
                const negative = num < 0;
                const abs = Math.abs(Math.floor(num));
                const padded = abs.toString().padStart(digits, '0');
                return negative ? `-${padded}` : padded;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ENHANCED WAVE SYSTEM: Themed Tactical Challenges
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Defined globally so it can be accessed by spawn functions
            
            // Helper function to get wave profile - must be defined globally
            function getSpawnProfileForWave(wave) {
                if (!window.WAVE_SPAWN_PROFILES) return null;
                for (let i = 0; i < window.WAVE_SPAWN_PROFILES.length; i++) {
                    const profile = window.WAVE_SPAWN_PROFILES[i];
                    if (wave >= profile.minWave) {
                        return profile;
                    }
                }
                return window.WAVE_SPAWN_PROFILES[window.WAVE_SPAWN_PROFILES.length - 1];
            }

            function initWave() {
                if (store.goldenOrbs) {
                    store.goldenOrbs.length = 0;
                }
                if (store.world) {
                    store.world.voidReaperSpawnedThisWave = false;
                    if (store.world.voidReaperCooldown && store.world.voidReaperCooldown > 0) {
                        store.world.voidReaperCooldown = Math.max(0, store.world.voidReaperCooldown - 1);
                    }
                }
                const isBossWave = store.world.wave % 5 === 0;
                const isPreBossWave = !isBossWave && store.world.wave % 5 === 4;

                if (isPreBossWave) {
                    const upcomingWave = store.world.wave + 1;
                    const upcomingCycle = Math.floor((upcomingWave - 5) / 5);
                    const upcomingBossDef = getBossDefinitionByCycle(upcomingCycle);
                    const upcomingThemeKey = upcomingBossDef ? ensureValidThemeKey(upcomingBossDef.key) : DEFAULT_MAP_THEME_KEY;
                    queueMapThemeTransition(upcomingThemeKey, { force: true });
                }

                const teleportAuraByType = {
                    drone: '#7fd5ff', //small alien drone
                    hunter: '#ff6e84', //snake
                    phantom: '#d9a7ff', //
                    mech: '#4ef0ff',
                    angler: '#8cf8f8',
                    manta: '#7acbff',
                    construct_gold: '#ffc35c',
                    avian_hatchling: '#c297ff',
                    void_champion: '#a864ff',
                    void_reaper: '#5a1b80'
                };
                const spawnDurationByType = {
                    phantom: 0.7,
                    mech: 0.8,
                    angler: 0.7,
                    manta: 0.85,
                    construct_gold: 0.65,
                    avian_hatchling: 0.62,
                    void_champion: 1.05,
                    void_reaper: 0
                };
                const dropDistanceByType = {
                    mech: 200,
                    angler: 170,
                    manta: 180,
                    construct_gold: 140,
                    avian_hatchling: 130,
                    void_champion: 220,
                    void_reaper: 0
                };
                const BOSS_CHAMPION_LOOP = 6;

                // Make spawn constants globally accessible
                if (!window.teleportAuraByType) {
                    window.teleportAuraByType = teleportAuraByType;
                }
                if (!window.spawnDurationByType) {
                    window.spawnDurationByType = spawnDurationByType;
                }
                if (!window.dropDistanceByType) {
                    window.dropDistanceByType = dropDistanceByType;
                }
                if (!window.BOSS_CHAMPION_LOOP) {
                    window.BOSS_CHAMPION_LOOP = BOSS_CHAMPION_LOOP;
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ENHANCED WAVE SYSTEM: Themed Tactical Challenges
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Each wave presents a unique tactical scenario designed to reward specific
                // playstyles and challenge different ability sets:
                //
                // PLAYSTYLE TESTS:
                // â€¢ AOE Damage (E-bullets, Multishot) â†’ Excels in SWARM_HELL waves
                // â€¢ Single-Target DPS (Phase Striker) â†’ Critical in TANK_RUSH/ELITE_ASSAULT
                // â€¢ Multi-Target (Chain Lightning, Railgunner) â†’ Shines in PRECISION_TEST
                // â€¢ Melee/Close Range (Flamethrower) â†’ Effective vs SWARM_HELL
                //
                // VULNERABILITY SYSTEM:
                // â€¢ Juggernaut (fire/explosive) â†’ Bonus vs Mech
                // â€¢ Marauder (kinetic/concussive) â†’ Bonus vs Manta
                // â€¢ Railgunner (kinetic/explosive) â†’ Bonus vs Phantom
                // â€¢ Demolitioner (fire/explosive) â†’ Bonus vs Void Champion Orb
                // â€¢ Phasestriker (void/magic) â†’ Bonus vs Void Champion
                // â€¢ Stormbringer (lightning/magic) â†’ Bonus vs Angler
                //
                // WAVE THEMES PROGRESSION:
                // Waves 1-2:   TUTORIAL - Basic mechanics
                // Waves 3-5:   MIXED_BASICS - Enemy variety introduction
                // Waves 6-8:   TANK_INTRO - First tanky enemies
                // Waves 9-12:  SWARM_HELL - Mass targets for AOE builds
                // Waves 13-15: PRECISION_TEST - Spread formations for multi-target
                // Waves 16-19: TANK_RUSH - High HP enemies for sustained DPS
                // Waves 20-24: MIXED_TACTICS - Adaptability test
                // Waves 25-29: VULNERABILITY_TEST - Class synergy critical
                // Waves 30-34: DODGE_HELL - Evasive enemies stress tracking
                // Waves 35-39: ELITE_ASSAULT - Heavy hitters with support
                // Waves 40+:   ULTIMATE_CHAOS - All systems engaged
                //
                // MOVEMENT PROTOCOLS:
                // â€¢ SWARM: Fast homing (construct_gold, avian_hatchling)
                // â€¢ PURSUIT: Aggressive tracking (hunter)
                // â€¢ BASIC: Simple downward with light tracking (drone)
                // â€¢ TANK: Slow, steady, horizontal tracking (angler, mech)
                // â€¢ WEAVE: Sinusoidal patterns (manta)
                // â€¢ DODGE: Unpredictable phase-shift (phantom)
                // â€¢ CHARGE: Periodic dash attacks (void_champion)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Store profiles globally for access from spawn functions
                const WAVE_SPAWN_PROFILES = window.WAVE_SPAWN_PROFILES || [
                    // WAVES 40+: ULTIMATE GAUNTLET - All systems tested simultaneously
                    {
                        minWave: 40,
                        theme: 'ULTIMATE_CHAOS',
                        description: 'All enemy types, maximum chaos',
                        forced: ['manta', 'angler', 'mech', 'phantom'],
                        weights: {
                            manta: 3.2,
                            angler: 3.0,
                            mech: 2.6,
                            phantom: 2.0,
                            hunter: 1.8,
                            avian_hatchling: 1.4,
                            construct_gold: 1.4,
                            drone: 1.0
                        },
                        special: [
                            { interval: 4, offset: 0, types: ['manta', 'angler'] },
                            { interval: 5, offset: 2, types: ['phantom', 'mech'] },
                            { interval: 6, offset: 1, types: ['avian_hatchling', 'construct_gold'] }
                        ]
                    },
                    
                    // WAVES 35-39: ELITE ASSAULT - Heavy hitters dominate
                    {
                        minWave: 35,
                        theme: 'ELITE_ASSAULT',
                        description: 'Tanky elites with support swarms - tests single-target DPS',
                        forced: ['manta', 'manta', 'angler', 'mech'],
                        weights: {
                            manta: 3.0,      // Dodge tanks (Marauder weak)
                            angler: 2.8,      // Slow tanks (Stormbringer weak)
                            mech: 2.4,        // Heavy tanks (Juggernaut weak)
                            phantom: 1.4,     // Phase dodgers (Railgunner weak)
                            construct_gold: 1.2,
                            avian_hatchling: 1.0,
                            hunter: 0.7,
                            drone: 0.4
                        },
                        special: [
                            { interval: 5, offset: 1, types: ['construct_gold', 'avian_hatchling'] },
                            { interval: 6, offset: 0, types: ['manta', 'angler'] }
                        ]
                    },
                    
                    // WAVES 30-34: DODGE GAUNTLET - Evasive enemies stress tracking
                    {
                        minWave: 30,
                        theme: 'DODGE_HELL',
                        description: 'Evasive enemies that dodge attacks - rewards AOE and prediction',
                        forced: ['manta', 'phantom', 'phantom'],
                        weights: {
                            manta: 2.8,       // Sinusoidal dodge
                            phantom: 2.6,     // Phase shift
                            avian_hatchling: 2.0,  // Erratic fast
                            hunter: 1.4,
                            construct_gold: 1.2,
                            mech: 0.8,
                            drone: 0.6,
                            angler: 0.4
                        },
                        special: [
                            { interval: 4, offset: 1, types: ['phantom'] },
                            { interval: 5, offset: 3, types: ['manta'] }
                        ]
                    },
                    
                    // WAVES 25-29: VULNERABILITY MASTERS - Class synergy critical
                    {
                        minWave: 25,
                        theme: 'VULNERABILITY_TEST',
                        description: 'Mixed enemies with vulnerability focus - rewards class-specific builds',
                        forced: ['angler', 'mech', 'phantom'],
                        weights: {
                            angler: 2.2,      // Stormbringer target
                            mech: 2.0,        // Juggernaut target
                            phantom: 1.8,     // Railgunner target
                            manta: 1.6,       // Marauder target
                            hunter: 1.2,
                            construct_gold: 1.0,
                            avian_hatchling: 0.9,
                            drone: 0.5
                        },
                        special: [
                            { interval: 5, offset: 0, types: ['angler', 'mech'] },
                            { interval: 6, offset: 3, types: ['phantom', 'manta'] }
                        ]
                    },
                    
                    // WAVES 20-24: MIXED TACTICS - Balanced challenge
                    {
                        minWave: 20,
                        theme: 'MIXED_TACTICS',
                        description: 'Balanced mix - tests adaptability',
                        forced: ['angler', 'mech', 'phantom'],
                        weights: {
                            manta: 2.0,
                            angler: 1.8,
                            mech: 1.6,
                            phantom: 1.5,
                            hunter: 1.2,
                            construct_gold: 1.0,
                            avian_hatchling: 0.9,
                            drone: 0.5
                        },
                        special: [
                            { interval: 6, offset: 3, types: ['construct_gold', 'avian_hatchling'] },
                            { interval: 5, offset: 0, types: ['mech', 'angler'] }
                        ]
                    },
                    
                    // WAVES 16-19: TANK RUSH - High HP enemies test sustained DPS
                    {
                        minWave: 16,
                        theme: 'TANK_RUSH',
                        description: 'Fewer but tankier enemies - tests single-target damage',
                        forced: ['mech', 'mech'],
                        weights: {
                            mech: 2.4,        // Slow, tanky, high damage
                            angler: 1.6,      // Very tanky
                            phantom: 1.4,     // Medium tank
                            hunter: 1.0,
                            manta: 0.6,
                            construct_gold: 0.5,
                            avian_hatchling: 0.4,
                            drone: 0.3
                        },
                        special: [
                            { interval: 4, offset: 1, types: ['mech'] },
                            { interval: 7, offset: 3, types: ['angler'] }
                        ]
                    },
                    
                    // WAVES 13-15: PRECISION TEST - Spaced targets reward accuracy
                    {
                        minWave: 13,
                        theme: 'PRECISION_TEST',
                        description: 'Spread formation - tests multi-target abilities',
                        forced: ['phantom', 'hunter'],
                        weights: {
                            phantom: 2.0,     // Phase enemies spread out
                            hunter: 1.8,      // Fast, spread targeting
                            mech: 1.2,
                            avian_hatchling: 0.8,
                            construct_gold: 0.7,
                            drone: 0.6
                        },
                        special: [
                            { interval: 5, offset: 2, types: ['phantom'] },
                            { interval: 6, offset: 0, types: ['hunter'] }
                        ]
                    },
                    
                    // WAVES 9-12: SWARM HELL - Many weak enemies test AOE damage
                    {
                        minWave: 9,
                        theme: 'SWARM_HELL',
                        description: 'Many weak, fast enemies - AOE abilities shine',
                        forced: ['construct_gold', 'avian_hatchling'],
                        weights: {
                            construct_gold: 2.2,  // Fast homing
                            avian_hatchling: 2.0, // Very fast homing
                            drone: 1.8,           // Basic swarm
                            hunter: 1.4,          // Fast tracking
                            phantom: 0.8,
                            mech: 0.3
                        },
                        special: [
                            { interval: 3, offset: 0, types: ['construct_gold', 'avian_hatchling'] },
                            { interval: 4, offset: 2, types: ['drone', 'hunter'] }
                        ]
                    },
                    
                    // WAVES 6-8: INTRODUCTION TO TANKS - First tanky enemy
                    {
                        minWave: 6,
                        theme: 'TANK_INTRO',
                        description: 'Introducing tanky mechs mixed with basic enemies',
                        forced: ['mech'],
                        weights: {
                            mech: 1.4,        // First tank enemy
                            hunter: 1.6,
                            drone: 1.8,
                            phantom: 0.6
                        },
                        special: [
                            { interval: 5, offset: 2, types: ['mech'] }
                        ]
                    },
                    
                    // WAVES 3-5: MIXED BASICS - Learning enemy variety
                    {
                        minWave: 3,
                        theme: 'MIXED_BASICS',
                        description: 'Introduction to enemy variety',
                        forced: ['hunter'],
                        weights: {
                            drone: 2.0,
                            hunter: 1.6,
                            phantom: 0.4
                        },
                        special: [
                            { interval: 4, offset: 1, types: ['hunter'] }
                        ]
                    },
                    
                    // WAVES 1-2: TUTORIAL - Pure basics
                    {
                        minWave: 1,
                        theme: 'TUTORIAL',
                        description: 'Basic drones only - learning the ropes',
                        forced: [],
                        weights: {
                            drone: 3.0,
                            hunter: 0.8
                        },
                        special: []
                    }
                ];
                
                // Make profiles globally accessible
                if (!window.WAVE_SPAWN_PROFILES) {
                    window.WAVE_SPAWN_PROFILES = WAVE_SPAWN_PROFILES;
                }

                const WAVE_TRANSMISSION_LIBRARY = window.WAVE_TRANSMISSION_LIBRARY || {
                    DEFAULT: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... signal's drifting.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Static.`
                    ],
                    TUTORIAL: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Quiet.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... nothing yet.`
                    ],
                    MIXED_BASICS: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Something out there.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Movement detected.`
                    ],
                    TANK_INTRO: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... heavy readings.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Big ones incoming.`
                    ],
                    SWARM_HELL: [
                        ({ wave }) => `ï¿½ Sector ${wave}... sensor's overloading.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Too many.`
                    ],
                    PRECISION_TEST: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Spread formation.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... make them count.`
                    ],
                    TANK_RUSH: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Armor inbound.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... gonna be a slog.`
                    ],
                    MIXED_TACTICS: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. All types.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Mixed bag.`
                    ],
                    VULNERABILITY_TEST: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... reading variances.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Find their weak spots.`
                    ],
                    DODGE_HELL: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Fast movers.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... they're erratic.`
                    ],
                    ELITE_ASSAULT: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}. Trouble.`,
                        ({ wave }) => `ðŸ“¡ ${wave}... serious contacts.`
                    ],
                    ULTIMATE_CHAOS: [
                        ({ wave }) => `ðŸ“¡ Sector ${wave}... everything.`,
                        ({ wave }) => `ðŸ“¡ ${wave}. Just survive.`
                    ]
                };

                if (!window.WAVE_TRANSMISSION_LIBRARY) {
                    window.WAVE_TRANSMISSION_LIBRARY = WAVE_TRANSMISSION_LIBRARY;
                }

                function pickTransmission(entries, context) {
                    if (!entries || !entries.length) return null;
                    const idx = Math.floor(Math.random() * entries.length);
                    const choice = entries[idx];
                    if (typeof choice === 'function') {
                        try {
                            return choice(context) || null;
                        } catch (err) {
                            console.error('Transmission composer failed', err);
                            return null;
                        }
                    }
                    if (typeof choice === 'string') {
                        return choice.replace('{wave}', context.wave);
                    }
                    return null;
                }

                function composeWaveTransmission(theme, wave) {
                    const context = { wave, theme };
                    const themed = theme && WAVE_TRANSMISSION_LIBRARY[theme];
                    const entries = themed && themed.length ? themed : WAVE_TRANSMISSION_LIBRARY.DEFAULT;
                    return pickTransmission(entries, context) || pickTransmission(WAVE_TRANSMISSION_LIBRARY.DEFAULT, context);
                }

                function broadcastTransmission(message, delay = 0) {
                    if (!message) return;
                    if (delay > 0) {
                        setTimeout(() => announce(message), delay);
                    } else {
                        announce(message);
                    }
                }

                function getSpawnProfileForWave(wave) {
                    for (let i = 0; i < WAVE_SPAWN_PROFILES.length; i++) {
                        const profile = WAVE_SPAWN_PROFILES[i];
                        if (wave >= profile.minWave) {
                            return profile;
                        }
                    }
                    return WAVE_SPAWN_PROFILES[WAVE_SPAWN_PROFILES.length - 1];
                }

                function pickWeightedType(weights) {
                    const entries = Object.entries(weights || {}).filter(([, weight]) => ensureFiniteNumber(weight, 0) > 0);
                    if (!entries.length) {
                        return 'drone';
                    }
                    const totalWeight = entries.reduce((sum, [, weight]) => sum + weight, 0);
                    if (totalWeight <= 0 || !Number.isFinite(totalWeight)) {
                        return entries[0][0];
                    }
                    let roll = Math.random() * totalWeight;
                    for (const [type, weight] of entries) {
                        roll -= weight;
                        if (roll <= 0) {
                            return type;
                        }
                    }
                    return entries[entries.length - 1][0];
                }

                function createSpawnSpec(type, threatScale, lateGameScaling) {
                    return {
                        type,
                        props: { hpScale: threatScale, damageMult: threatScale },
                        lateGameScaling,
                        spawnDuration: spawnDurationByType[type],
                        spawnDropDistance: dropDistanceByType[type],
                        effectColor: teleportAuraByType[type] || teleportAuraByType.drone
                    };
                }

                function ensureHunterGangPresence(specs, wave, threatScale, lateGameScaling) {
                    if (!Array.isArray(specs) || !specs.length) return specs;
                    if (wave < 6 || wave % 5 === 0) return specs;

                    const total = specs.length;
                    const baseDesired = Math.max(2, Math.ceil(total * 0.2));
                    const waveBonus = wave >= 30 ? 3 : wave >= 22 ? 2 : wave >= 14 ? 1 : 0;
                    const desiredHunters = Math.min(Math.ceil(total * 0.45), baseDesired + waveBonus);

                    if (desiredHunters <= 0) return specs;

                    const currentHunters = specs.reduce((count, spec) => count + (spec.type === 'hunter' ? 1 : 0), 0);
                    if (currentHunters >= desiredHunters) return specs;

                    const needed = desiredHunters - currentHunters;
                    const exclusion = new Set(['hunter', 'void_reaper', 'void_champion', 'shadow_champion', 'cube_burglar']);
                    const preferredReplacements = ['drone', 'construct_gold', 'avian_hatchling'];

                    const candidateIndices = [];
                    const fallbackIndices = [];

                    for (let i = specs.length - 1; i >= 0; i--) {
                        const spec = specs[i];
                        if (!spec || exclusion.has(spec.type)) continue;
                        if (preferredReplacements.includes(spec.type)) {
                            candidateIndices.push(i);
                        } else {
                            fallbackIndices.push(i);
                        }
                    }

                    const replacementOrder = candidateIndices.concat(fallbackIndices);
                    const injections = Math.min(needed, replacementOrder.length);

                    for (let n = 0; n < injections; n++) {
                        const idx = replacementOrder[n];
                        const original = specs[idx];
                        const gangScale = threatScale * (1 + Math.min(0.3, 0.08 * n));
                        const hunterSpec = createSpawnSpec('hunter', gangScale, lateGameScaling);
                        if (original && original.progressIndex !== undefined) {
                            hunterSpec.progressIndex = original.progressIndex;
                        }
                        hunterSpec.injectedHunterGang = true;
                        specs[idx] = hunterSpec;
                    }

                    return specs;
                }

                function shuffleInPlace(list) {
                    for (let i = list.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        const tmp = list[i];
                        list[i] = list[j];
                        list[j] = tmp;
                    }
                }

                function buildWaveSpawnSpecs(wave, spawnCount, threatScale, lateGameScaling) {
                    const profile = getSpawnProfileForWave(wave);
                    const specs = [];
                    const forced = Array.isArray(profile.forced) ? profile.forced.slice(0, Math.max(0, spawnCount)) : [];

                    forced.forEach(type => {
                        specs.push(createSpawnSpec(type, threatScale, lateGameScaling));
                    });

                    while (specs.length < spawnCount) {
                        const slotIndex = specs.length;
                        let type = pickWeightedType(profile.weights);
                        if (Array.isArray(profile.special)) {
                            for (const routine of profile.special) {
                                if (!routine || !routine.interval || !Array.isArray(routine.types) || !routine.types.length) continue;
                                const interval = Math.max(1, Math.floor(routine.interval));
                                const offset = Math.floor(routine.offset || 0);
                                if ((slotIndex + offset) % interval === 0) {
                                    const index = Math.floor(Math.random() * routine.types.length);
                                    type = routine.types[index];
                                    break;
                                }
                            }
                        }
                        specs.push(createSpawnSpec(type, threatScale, lateGameScaling));
                    }

                        ensureHunterGangPresence(specs, wave, threatScale, lateGameScaling);
                        shuffleInPlace(specs);
                    return specs;
                }

                // Make spawn helper functions globally accessible
                if (!window.buildWaveSpawnSpecs) {
                    window.buildWaveSpawnSpecs = buildWaveSpawnSpecs;
                }
                if (!window.pickWeightedType) {
                    window.pickWeightedType = pickWeightedType;
                }
                if (!window.createSpawnSpec) {
                    window.createSpawnSpec = createSpawnSpec;
                }
                if (!window.shuffleInPlace) {
                    window.shuffleInPlace = shuffleInPlace;
                }

                const VOID_REAPER_CONFIG = Object.freeze({
                    warningDuration: 2.0,
                    emergeDuration: 0.55,
                    lungeSpeed: 640,
                    lungePadding: 260,
                    scytheArc: Math.PI * 0.95,
                    scytheReach: 150,
                    minWaveGap: 3,
                    preemptiveGoldBonus: 0.6,
                    bonusScoreRatio: 0.5,
                    bonusXpRatio: 0.45
                });

                // Make VOID_REAPER_CONFIG globally accessible
                if (!window.VOID_REAPER_CONFIG) {
                    window.VOID_REAPER_CONFIG = VOID_REAPER_CONFIG;
                }

                function chooseVoidReaperSpawnPosition(player) {
                    // Spawn from far corners/edges to maximize travel distance
                    const corners = [
                        { name: 'top-left', x: 50, y: 50 },
                        { name: 'top-right', x: W - 50, y: 50 },
                        { name: 'bottom-left', x: 50, y: H - 50 },
                        { name: 'bottom-right', x: W - 50, y: H - 50 }
                    ];
                    
                    // Calculate which corner is farthest from player for maximum dramatic effect
                    let farthestCorner = corners[0];
                    let maxDist = 0;
                    
                    corners.forEach(corner => {
                        const dx = corner.x - player.x;
                        const dy = corner.y - player.y;
                        const dist = dx * dx + dy * dy;
                        if (dist > maxDist) {
                            maxDist = dist;
                            farthestCorner = corner;
                        }
                    });
                    
                    // Add slight randomness so it's not always exactly the same spot
                    const jitterX = (Math.random() - 0.5) * 80;
                    const jitterY = (Math.random() - 0.5) * 80;
                    
                    return { 
                        edge: farthestCorner.name, 
                        x: clamp(farthestCorner.x + jitterX, 30, W - 30), 
                        y: clamp(farthestCorner.y + jitterY, 30, H - 30)
                    };
                }

                function spawnVoidReaper({ hpScale = 1, damageMult = 1, lateGameScaling = 1 } = {}) {
                    // Cache-busting fix for undefined function error
                    if (!store || !store.player) return null;
                    const player = store.player;
                    const pos = chooseVoidReaperSpawnPosition(player);
                    const heading = Math.atan2(player.y - pos.y, player.x - pos.x);
                    const enemy = spawnEnemy('void_reaper', {
                        x: pos.x,
                        y: pos.y,
                        hpScale,
                        damageMult,
                        spawnEdge: pos.edge,
                        entryAngle: heading,
                        warningTimer: VOID_REAPER_CONFIG.warningDuration,
                        lungeSpeed: VOID_REAPER_CONFIG.lungeSpeed,
                        lungePadding: VOID_REAPER_CONFIG.lungePadding,
                        scytheArc: VOID_REAPER_CONFIG.scytheArc,
                        scytheReach: VOID_REAPER_CONFIG.scytheReach
                    });
                    if (!enemy) return null;

                    applySpawnSpecToEnemy(enemy, { lateGameScaling });

                    enemy.warningDuration = VOID_REAPER_CONFIG.warningDuration;
                    enemy.emergeDuration = VOID_REAPER_CONFIG.emergeDuration;
                    enemy.phase = 'warning';
                    enemy.isInvulnerable = true;
                    enemy.heading = heading;
                    enemy.riftSeed = Math.random() * Math.PI * 2;

                    store.activeEffects.push(createEffect('voidReaperRift', enemy.x, enemy.y, (enemy.r || 24) * 2.6, {
                        duration: enemy.warningDuration,
                        edge: pos.edge
                    }));

                    store.enemies.push(enemy);
                    store.world.voidReaperSpawnedThisWave = true;
                    store.world.lastVoidReaperWave = store.world.wave;
                    store.world.voidReaperCooldown = Math.max(VOID_REAPER_CONFIG.minWaveGap || 3, 1);

                    return enemy;
                }

                // Make spawnVoidReaper globally accessible
                if (!window.spawnVoidReaper) {
                    window.spawnVoidReaper = spawnVoidReaper;
                }

                function finalizeVoidReaperDefeat(enemy, { preemptive = false, suppressRewards = false } = {}) {
                    if (!enemy || enemy.reaperDefeated) return;
                    enemy.reaperDefeated = true;
                    enemy.dead = true;
                    enemy.hp = 0;

                    if (!store || !store.world) return;

                    if (suppressRewards) {
                        store.activeEffects.push(createEffect('voidReaperDissolve', enemy.x, enemy.y, (enemy.r || 24) * 2.2));
                        return;
                    }

                    if (preemptive) {
                        const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                        const baseGold = Number.isFinite(enemy.gold) ? enemy.gold : 0;
                        const bonusGold = Math.max(2, Math.floor(baseGold * VOID_REAPER_CONFIG.preemptiveGoldBonus * collarBonus)); // Further reduced to 2 for balance
                        const bonusScore = Math.floor((enemy.score || 0) * VOID_REAPER_CONFIG.bonusScoreRatio);
                        const bonusXp = Math.floor((enemy.xp || 0) * VOID_REAPER_CONFIG.bonusXpRatio);
                        if (bonusGold) addWorldGold(bonusGold);
                        if (bonusScore) store.world.score += bonusScore;
                        if (bonusXp) awardXp(bonusXp); // Apply XP diminishing returns
                        announce('â­ VOID REAPER DEFEATED! STAR POWER ACTIVATED! â­');
                        store.activeEffects.push(createEffect('voidReaperReward', enemy.x, enemy.y, (enemy.r || 24) * 3.2, { gold: bonusGold }));
                        
                        // Grant 5 seconds of invincibility star effect (like Mario/Mario Kart)
                        store.player.isInvincible = true;
                        store.player.starPowerEndTime = performance.now() + 5000; // 5 seconds
                        screenFlash(2, 250, 'rgba(255, 215, 0, 0.3)'); // Golden flash
                        playSound('powerup');
                        
                        // Spawn purple & gold coins (New Orleans style) to make loot visible
                        if (!store.powerups) store.powerups = [];
                        const numCoins = Math.min(8, Math.floor(bonusGold / 4)); // 1 coin per 8 gold, max 8 coins (increased from 5)
                        for (let i = 0; i < numCoins; i++) {
                            const angle = (i / numCoins) * Math.PI * 2;
                            const dist = 30 + Math.random() * 30;
                            const coinX = enemy.x + Math.cos(angle) * dist;
                            const coinY = enemy.y + Math.sin(angle) * dist;
                            spawnVoidReaperLootPowerup(coinX, coinY, {
                                championChance: 0.5,
                                pulseOffset: i * 0.5
                            });
                        }
                        
                        // GUARANTEED REWARD: Elite tier upgrade, boss tier upgrade + money, OR large money
                        const rewardRoll = Math.random();
                        if (rewardRoll < 0.40) {
                            // 40% chance: Elite tier upgrade (iceman, lazarus, gravity well, etc)
                            spawnUpgradePowerup(enemy.x, enemy.y - 20, 'bossTier', { championChance: 0.6, allowChampion: true });
                            announce('ðŸŒŸ Elite Upgrade Acquired!');
                        } else if (rewardRoll < 0.70) {
                            // 30% chance: Boss tier upgrade + bonus money
                            spawnUpgradePowerup(enemy.x - 25, enemy.y - 20, 'bossTier', { championChance: 0.65, allowChampion: true });
                            const extraGold = 1;
                            addWorldGold(extraGold);
                            // Spawn extra gold coins
                            for (let i = 0; i < 3; i++) {
                                const angle = (Math.PI / 3) * i + Math.PI / 6;
                                const dist = 45;
                                spawnVoidReaperLootPowerup(
                                    enemy.x + Math.cos(angle) * dist,
                                    enemy.y + Math.sin(angle) * dist,
                                    {
                                        championChance: 0.55,
                                        pulseOffset: i * 0.3
                                    }
                                );
                            }
                        } else {
                            // 30% chance: Large money reward (no upgrade)
                            const largeGoldBonus = 2;
                            addWorldGold(largeGoldBonus);
                            announce('ðŸ’° Major Gold Cache Secured!');
                            // Spawn extra gold powerups in a circle
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const dist = 50;
                                spawnVoidReaperLootPowerup(
                                    enemy.x + Math.cos(angle) * dist,
                                    enemy.y + Math.sin(angle) * dist,
                                    {
                                        championChance: 0.4,
                                        pulseOffset: i * 0.4
                                    }
                                );
                            }
                        }
                    } else {
                        // Non-preemptive defeat - still give a reward to ensure reaper always drops something
                        store.activeEffects.push(createEffect('voidReaperDissolve', enemy.x, enemy.y, (enemy.r || 24) * 2.2));
                        
                        // Guaranteed reward even for non-preemptive defeat
                        const consolationGold = 1;
                        addWorldGold(consolationGold);
                        spawnUpgradePowerup(enemy.x, enemy.y, 'midTier', { championChance: 0.3, allowChampion: true });
                        announce('Void Reaper banished - Consolation reward acquired!');
                        
                        // Spawn a few coins
                        for (let i = 0; i < 3; i++) {
                            const angle = (i / 3) * Math.PI * 2;
                            const dist = 35;
                            spawnVoidReaperLootPowerup(
                                enemy.x + Math.cos(angle) * dist,
                                enemy.y + Math.sin(angle) * dist,
                                {
                                    championChance: 0.3,
                                    pulseOffset: i * 0.3
                                }
                            );
                        }
                    }
                }

                function updateVoidReaper(enemy, dt) {
                    if (!enemy || enemy.dead) return;

                    if (enemy.hitPulseTimer && enemy.hitPulseTimer > 0) {
                        enemy.hitPulseTimer = Math.max(0, enemy.hitPulseTimer - dt);
                    }
                    if (enemy.hitShakeTimer && enemy.hitShakeTimer > 0) {
                        enemy.hitShakeTimer = Math.max(0, enemy.hitShakeTimer - dt);
                        if (enemy.hitShakeTimer <= 0) {
                            enemy.hitShakeIntensity = 0;
                        }
                    }

                    if (enemy.hp <= 0 && !enemy.reaperDefeated) {
                        finalizeVoidReaperDefeat(enemy, { preemptive: !enemy.lungeStarted });
                        return;
                    }

                    const warningDuration = enemy.warningDuration || VOID_REAPER_CONFIG.warningDuration;
                    const emergeDuration = enemy.emergeDuration || VOID_REAPER_CONFIG.emergeDuration;
                    enemy.isInvulnerable = enemy.phase === 'warning';

                    switch (enemy.phase) {
                        case 'warning': {
                            enemy.warningTimer = (enemy.warningTimer ?? warningDuration) - dt;
                            enemy.riftPulse = (enemy.riftPulse || 0) + dt;
                            enemy.riftProgress = Math.min(1, 1 - Math.max(0, enemy.warningTimer) / Math.max(0.001, warningDuration));
                            if (enemy.warningTimer <= 0) {
                                enemy.phase = 'emerging';
                                enemy.isInvulnerable = false;
                                enemy.emergeTimer = emergeDuration;
                                enemy.emergeProgress = 0;
                                enemy.lockedTarget = { x: store.player.x, y: store.player.y };
                                enemy.heading = Math.atan2(enemy.lockedTarget.y - enemy.y, enemy.lockedTarget.x - enemy.x);
                                store.activeEffects.push(createEffect('voidReaperStrike', enemy.x, enemy.y, (enemy.r || 24) * 1.45, {
                                    heading: enemy.heading,
                                    duration: emergeDuration,
                                    warmup: true
                                }));
                            }
                            break;
                        }
                        case 'emerging': {
                            enemy.emergeTimer = (enemy.emergeTimer ?? emergeDuration) - dt;
                            const current = Math.max(0, enemy.emergeTimer);
                            enemy.emergeProgress = Math.min(1, 1 - current / Math.max(0.001, emergeDuration));
                            if (enemy.emergeTimer <= 0) {
                                enemy.phase = 'lunge';
                                enemy.lungeStarted = true;
                                const target = enemy.lockedTarget || { x: store.player.x, y: store.player.y };
                                const dx = target.x - enemy.x;
                                const dy = target.y - enemy.y;
                                const dist = Math.max(60, Math.sqrt(dx * dx + dy * dy));
                                enemy.lungeDirX = dx / dist;
                                enemy.lungeDirY = dy / dist;
                                enemy.heading = Math.atan2(enemy.lungeDirY, enemy.lungeDirX);
                                enemy.totalLungeDistance = dist + (enemy.lungePadding || VOID_REAPER_CONFIG.lungePadding);
                                enemy.lungeDistanceTravelled = 0;
                                enemy.lungeSpeed = enemy.lungeSpeed || VOID_REAPER_CONFIG.lungeSpeed;
                                store.activeEffects.push(createEffect('voidReaperStrike', enemy.x, enemy.y, (enemy.r || 24) * 1.35, {
                                    heading: enemy.heading,
                                    duration: 0.32
                                }));
                                playSound('horn');
                            }
                            break;
                        }
                        case 'lunge': {
                            enemy.hitSlowTimer = 0;
                            enemy.slowTimer = 0;
                            const speed = enemy.lungeSpeed || VOID_REAPER_CONFIG.lungeSpeed;
                            
                            // Use locked-in direction from emerging phase - NO trajectory changes!
                            const dirX = enemy.lungeDirX || Math.cos(enemy.heading || 0);
                            const dirY = enemy.lungeDirY || Math.sin(enemy.heading || 0);
                            enemy.x += dirX * speed * dt;
                            enemy.y += dirY * speed * dt;
                            enemy.lungeDistanceTravelled = (enemy.lungeDistanceTravelled || 0) + speed * dt;
                            const total = Math.max(1, enemy.totalLungeDistance || 1);
                            enemy.lungeProgress = Math.min(1.15, enemy.lungeDistanceTravelled / total);

                            const player = store.player;
                            if (player && !player.isInvincible && !playerIsInvulnerable()) {
                                const px = player.x - enemy.x;
                                const py = player.y - enemy.y;
                                const dist = Math.sqrt(px * px + py * py);
                                const playerRadius = player.r || 15;
                                const reaperRadius = enemy.r || 24;
                                const reach = playerRadius + reaperRadius + 8; // Direct collision distance
                                
                                // Only damage on DIRECT COLLISION - no distance checks
                                if (dist <= reach) {
                                    // Check for Shield Pulse (EMP) protection
                                    if (store.empCharges && store.empCharges.length > 0) {
                                        // Shield Pulse blocks the reaper!
                                        const charge = store.empCharges[0];
                                        triggerEmpBurst(charge.x, charge.y);
                                        charge.cooldown = EMP_BURST_CONFIG.chargeCooldown;
                                        store.empGlobalCooldown = Math.max(store.empGlobalCooldown || 0, EMP_BURST_CONFIG.globalCooldown || 0);
                                        announce('âš¡ SHIELD PULSE STOPPED THE REAPER! âš¡');
                                        screenFlash(1, 200, 'rgba(100, 200, 255, 0.4)');
                                        // Stun the reaper without dealing direct damage
                                        enemy.stunTimer = 3.5;
                                        enemy.phase = 'recovering';
                                        enemy.hitSlowFactor = 0.3;
                                        enemy.hitSlowTimer = 4;
                                        store.activeEffects.push(createEffect('empShockwave', enemy.x, enemy.y, 280));
                                        return;
                                    }
                                    // Check for Aft Flank Shield protection (if reaper is behind player)
                                    const reaperAngleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                    const playerFacingAngle = player.heading || 0;
                                    let facingDiff = reaperAngleToPlayer - playerFacingAngle;
                                    if (facingDiff > Math.PI) facingDiff -= Math.PI * 2;
                                    if (facingDiff < -Math.PI) facingDiff += Math.PI * 2;
                                    const isFromBehind = Math.abs(facingDiff) > Math.PI * 0.5; // Behind if angle > 90 degrees
                                    
                                    if (player.hasRearGuard && player.rearGuardReady && isFromBehind) {
                                        // Aft Flank Shield blocks the reaper from behind!
                                        player.rearGuardReady = false;
                                        player.rearGuardCooldown = 8;
                                        announce('ðŸ›¡ï¸ AFT FLANKSHIELD STOPPED THE REAPER! ðŸ›¡ï¸');
                                        playSound('stargun');
                                        screenFlash(1, 200, 'rgba(255, 215, 0, 0.4)');
                                        store.activeEffects.push(createEffect("rearGuardBlock"));
                                        // Stun and damage the reaper
                                        enemy.hp -= 60;
                                        enemy.stunTimer = 2.5;
                                        enemy.phase = 'recovering';
                                        enemy.hitSlowFactor = 0.4;
                                        enemy.hitSlowTimer = 3;
                                        return;
                                    }
                                    
                                    // Direct hit kills the player (instant)
                                    takeDamage(player.hp + player.shield + player.hpMax + 999);
                                }
                            }

                            if (
                                enemy.lungeDistanceTravelled >= total ||
                                enemy.x < -220 || enemy.x > W + 220 ||
                                enemy.y < -220 || enemy.y > H + 220
                            ) {
                                enemy.phase = 'finished';
                                enemy.dead = true;
                                store.activeEffects.push(createEffect('voidReaperDissolve', enemy.x, enemy.y, (enemy.r || 24) * 1.8));
                            }
                            break;
                        }
                        default:
                            enemy.dead = true;
                    }
                }

                // Make void reaper functions globally accessible
                if (!window.updateVoidReaper) {
                    window.updateVoidReaper = updateVoidReaper;
                }
                if (!window.finalizeVoidReaperDefeat) {
                    window.finalizeVoidReaperDefeat = finalizeVoidReaperDefeat;
                }

                function spawnVoidChampion({
                    hpScale = 1,
                    damageMult = 1,
                    lateGameScaling = 1,
                    entryTargetYBase = 110,
                    entryYOffset = 0
                } = {}) {
                    const playerState = typeof getChampionUpgradeState === 'function' ? getChampionUpgradeState() : null;
                    const attackModule = (store?.playerChampion?.attackModule) || (playerState?.attackModule) || 'default';
                    const champion = spawnEnemy('void_champion', { hpScale, damageMult, attackModule });
                    if (!champion) return null;

                    applySpawnSpecToEnemy(champion, { lateGameScaling });
                    const entryDrop = dropDistanceByType.void_champion || 220;
                    const entryTargetY = entryTargetYBase + entryYOffset + Math.random() * 50;
                    champion.spawnTargetY = entryTargetY;
                    champion.y = entryTargetY - entryDrop;
                    champion.x = Math.max(120, Math.min(W - 120, champion.x));

                    activateSpawnIntro(champion, {
                        duration: spawnDurationByType.void_champion,
                        dropDistance: entryDrop,
                        targetY: entryTargetY,
                        clusterIndex: -1,
                        effectColor: teleportAuraByType.void_champion,
                        topClampBuffer: 1.2,
                        fireDelayBuffer: 0.6
                    });

                    store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.spawnTargetY ?? champion.y, champion.r || 28, {
                        duration: (champion.spawnDuration || 1) + 0.35,
                        color: teleportAuraByType.void_champion,
                        clusterIndex: -1,
                        isChampion: true
                    }));
                    store.enemies.push(champion);
                    return champion;
                }

                function spawnBossLoopChampions(loopCount, bossHpScale) {
                    if (loopCount < 1 || !Number.isFinite(loopCount)) return 0;
                    const championsToSpawn = Math.min(2, Math.max(0, loopCount));
                    let spawned = 0;
                    for (let i = 0; i < championsToSpawn; i++) {
                        const champion = spawnVoidChampion({
                            hpScale: bossHpScale * 0.6, // 60% of boss HP scaling (reduced from 100%)
                            damageMult: bossHpScale * 0.5, // 50% of boss damage scaling (reduced from 100%)
                            lateGameScaling: bossHpScale * 0.6,
                            entryTargetYBase: 100,
                            entryYOffset: i * 40
                        });
                        if (champion) spawned += 1;
                    }
                    return spawned;
                }

                // Make champion spawn functions globally accessible
                if (!window.spawnVoidChampion) {
                    window.spawnVoidChampion = spawnVoidChampion;
                }
                if (!window.spawnBossLoopChampions) {
                    window.spawnBossLoopChampions = spawnBossLoopChampions;
                }
                // Debug: Spawn zombie helper
                if (!window.spawnZombie) {
                    window.spawnZombie = function(x, y) {
                        const zombie = spawnEnemy('zombie', { 
                            x: x !== undefined ? x : store.player.x, 
                            y: y !== undefined ? y : store.player.y - 100 
                        });
                        if (zombie) {
                            store.enemies.push(zombie);
                            console.log('ðŸ§Ÿ Zombie spawned!', zombie);
                        }
                        return zombie;
                    };
                }
                
                // Debug: Spawn tombstone helper
                if (!window.spawnTombstone) {
                    window.spawnTombstone = function(x, y) {
                        // If x/y not provided, spawn near edges at random position
                        let spawnX, spawnY;
                        if (x !== undefined && y !== undefined) {
                            spawnX = x;
                            spawnY = y;
                        } else {
                            // Choose random edge: 0=top, 1=right, 2=bottom, 3=left
                            const edge = Math.floor(Math.random() * 4);
                            const edgeMargin = 80; // Distance from edge
                            const edgeVariation = 0.6; // Use 60% of screen dimension for placement
                            
                            switch(edge) {
                                case 0: // Top edge
                                    spawnX = W * (0.2 + Math.random() * edgeVariation);
                                    spawnY = edgeMargin;
                                    break;
                                case 1: // Right edge
                                    spawnX = W - edgeMargin;
                                    spawnY = H * (0.2 + Math.random() * edgeVariation);
                                    break;
                                case 2: // Bottom edge
                                    spawnX = W * (0.2 + Math.random() * edgeVariation);
                                    spawnY = H - edgeMargin;
                                    break;
                                case 3: // Left edge
                                    spawnX = edgeMargin;
                                    spawnY = H * (0.2 + Math.random() * edgeVariation);
                                    break;
                            }
                        }
                        
                        const tombstone = {
                            id: Date.now() + Math.random(),
                            x: spawnX,
                            y: spawnY,
                            r: 20,
                            hp: 300,
                            hpMax: 300,
                            spawnTimer: 0,
                            spawnInterval: 3.0, // Spawn zombie every 3 seconds
                            color: '#8b4789',
                            dead: false
                        };
                        store.tombstones.push(tombstone);
                        console.log('ðŸª¦ Tombstone spawned!', tombstone);
                        return tombstone;
                    };
                }


                // Clear poison puddles at start of each wave for clean slate
                if (store.poisonPuddles) {
                    store.poisonPuddles = [];
                }
                if (store.geminiSlowFields) {
                    store.geminiSlowFields = [];
                }

                if (isBossWave) {
                    // Preserve Cube Burglar across boss waves for continuity
                    const burglarToKeep = store.enemies.find(e => e && e.type === 'cube_burglar' && !e.dead);
                    store.enemies = burglarToKeep ? [burglarToKeep] : [];
                    store.world.pendingVoidReaper = null;
                    store.world.voidReaperWarningIssued = false;

                    // Boss scaling with higher ceiling for late game challenge
                    let bossHpScale;
                    if (store.world.wave <= 5) {
                        bossHpScale = 1; // No scaling for early bosses
                    } else if (store.world.wave <= 15) {
                        bossHpScale = 1 + (store.world.wave - 5) * 0.3; // +30% per wave 6-15
                    } else if (store.world.wave <= 30) {
                        bossHpScale = 1 + 10 * 0.3 + (store.world.wave - 15) * 0.25; // +25% per wave 16-30
                    } else {
                        bossHpScale = 1 + 10 * 0.3 + 15 * 0.25 + (store.world.wave - 30) * 0.2; // +20% per wave after 30
                    }

                    store.boss = createBoss(bossHpScale);
                    applyBossTheme(store.boss);
                    
                    // Add theatrical entrance effect for smoother transition
                    screenFlash(2, 200, 'rgba(111, 242, 255, 0.2)');
                    
                    if (store.world) {
                        if (!store.world.completedBossTokens || typeof store.world.completedBossTokens !== 'object') {
                            store.world.completedBossTokens = Object.create(null);
                        }
                        store.world.activeBossToken = (store.boss && store.boss.instanceId) || null;
                        store.world.activeBossWave = store.world.wave;
                        store.world.lastBossAwardToken = null;
                    }
                    store.lastBossSnapshot = null;
                    store.lastBossDefeatId = null;
                    store.world.bossSpawnTime = performance.now();
                    store.world.lastPlannedSpawnCount = 0;
                    store.world.lastSpawnCount = 0;
                    store.world.lastSpawnOverflow = 0;
                    store.world.lastThreatScale = 1;
                    store.world.lastSpawnFallback = false;
                    if (store.boss.name === 'VOID SENTINEL' && !store.boss.trapSoundPlayed) {
                        playSound('trap');
                        store.boss.trapSoundPlayed = true; // Only play once per boss spawn
                    }
                    // Horn removed from boss spawns - only for class selection
                    announce(`ðŸ“¡ [Command Relay] "Sector ${store.world.wave}: Guardian signature ${store.boss.name}. That's your mark."`);
                    if (!store.world.firstBossOrbsGifted && store.world.bosses === 0 && store.boss.name === 'VOID SENTINEL') {
                        spawnGoldenSentinelOrbs(3);
                        store.world.firstBossOrbsGifted = true;
                        setTimeout(() => announce('ðŸ“¡ [Command Relay] "Collect GOLDEN ORBS to shatter the guardian!"'), 750);
                    }

                    const bossesDefeated = ensureFiniteNumber(store.world.bosses, 0);
                    const bossLoopCount = Math.floor(bossesDefeated / BOSS_CHAMPION_LOOP);
                    if (bossLoopCount > 0) {
                        spawnBossLoopChampions(bossLoopCount, bossHpScale);
                    }
                } else {
                    // Preserve Cube Burglar across wave transitions - it persists independently
                    const burglarToKeep = store.enemies.find(e => e && e.type === 'cube_burglar' && !e.dead);
                    store.enemies = burglarToKeep ? [burglarToKeep] : [];
                    store.waveSpawnQueue = [];
                    store.pendingSpawnCount = 0;

                    // NEW SCALING SYSTEM: After wave 35, stop increasing spawn count and increase enemy stats instead
                    // ENHANCED: Wave themes modify spawn counts for tactical variety
                    let baseSpawnCount, spawnCount, lateGameScaling = 1;

                    if (store.world.wave <= 35) {
                        // Normal scaling: increase spawn count with waves
                        baseSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                        spawnCount = baseSpawnCount;
                    } else {
                        // Wave 35+: Cap spawn count, scale enemy stats instead
                        baseSpawnCount = Math.floor((7 + Math.floor(35 * 1.8)) * store.world.enemyDensityBonus);
                        spawnCount = Math.max(1, Math.floor(baseSpawnCount * 0.8)); // Slightly fewer enemies for performance

                        // Calculate what the spawn count WOULD have been, use that as scaling factor
                        const theoreticalSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                        lateGameScaling = theoreticalSpawnCount / baseSpawnCount; // This becomes our health/damage multiplier
                    }

                    // WAVE THEME MODIFIERS: Adjust spawn count and enemy stats based on wave archetype
                    const currentWaveProfile = getSpawnProfileForWave(store.world.wave);
                    if (currentWaveProfile && currentWaveProfile.theme) {
                        switch (currentWaveProfile.theme) {
                            case 'SWARM_HELL':
                                // More enemies, but each slightly weaker
                                spawnCount = Math.floor(spawnCount * 1.4);
                                lateGameScaling *= 0.85;
                                break;
                            case 'TANK_RUSH':
                            case 'ELITE_ASSAULT':
                                // Fewer enemies, but each significantly stronger
                                spawnCount = Math.floor(spawnCount * 0.65);
                                lateGameScaling *= 1.45;
                                break;
                            case 'DODGE_HELL':
                                // Normal count, enemies have more evasion (handled in movement)
                                spawnCount = Math.floor(spawnCount * 0.9);
                                break;
                            case 'PRECISION_TEST':
                                // Moderate count, spread formation
                                spawnCount = Math.floor(spawnCount * 1.1);
                                lateGameScaling *= 0.95;
                                break;
                            case 'VULNERABILITY_TEST':
                                // Balanced count, rewards class builds
                                lateGameScaling *= 1.1;
                                break;
                        }
                    }

                    // Store late-game scaling factor globally for damage calculations
                    store.world.lateGameDamageScaling = lateGameScaling;

                    // Apply collar bonus to spawn count with MORE AGGRESSIVE scaling
                    const collarStacks = sanitizeCollarStacks();
                    let spawnCollarMultiplier = 1;
                    
                    // NEW: Collar increases spawn density after 2nd boss (steeper than HP/damage scaling)
                    if (store.world.bosses > 2) {
                        const collarBonus = calculateCollarBonus(collarStacks);
                        // 85% effectiveness for spawn density - higher than HP scaling to increase challenge
                        spawnCollarMultiplier = 1 + ((collarBonus - 1) * 0.85);
                    }
                    
                    const plannedSpawnCountRaw = spawnCount * spawnCollarMultiplier;
                    const plannedSpawnCount = Math.max(0, ensureFiniteNumber(Math.floor(plannedSpawnCountRaw), 0));

                    const rawEnemyCap = ensureFiniteNumber(store.world.enemyCap, 43);
                    const enemyCap = rawEnemyCap > 0 ? rawEnemyCap : 43;

                    let cappedSpawnCount = Math.min(enemyCap, plannedSpawnCount);
                    if (!Number.isFinite(cappedSpawnCount) || cappedSpawnCount <= 0) {
                        cappedSpawnCount = 1;
                        store.world.lastSpawnFallback = true;
                    } else {
                        store.world.lastSpawnFallback = false;
                    }

                    const spawnIterations = Math.max(1, Math.floor(cappedSpawnCount));
                    const threatScaleRaw = spawnIterations > 0 && plannedSpawnCount > 0 ? plannedSpawnCount / spawnIterations : 1;
                    const threatScale = ensureFiniteNumber(threatScaleRaw, 1);

                    store.world.lastThreatScale = threatScale;
                    store.world.lastSpawnOverflow = Math.max(0, plannedSpawnCount - spawnIterations);
                    store.world.lastPlannedSpawnCount = plannedSpawnCount;
                    store.world.lastSpawnCount = 0;
                    
                    console.log(`ðŸ”¢ Spawn Density Debug | Wave: ${store.world.wave} | BaseCount: ${spawnCount} | CollarStacks: ${collarStacks.toFixed(1)} | CollarMult: ${spawnCollarMultiplier.toFixed(2)} | FinalCount: ${spawnIterations} | ThreatScale: ${threatScale.toFixed(2)}`);

                    spawnCount = spawnIterations;

                    if (store.world.wave > 8) {
                        const championChance = Math.min(0.4, 0.12 + (store.world.wave - 8) * 0.025);
                        if (Math.random() < championChance) {
                            // Cap champion scaling to prevent absurd HP values
                            const maxChampionScale = 3.0; // Max 3x scaling instead of unlimited
                            const cappedHpScale = Math.min(maxChampionScale, threatScale);
                            const cappedLateGameScaling = Math.min(maxChampionScale, lateGameScaling);

                            const champion = spawnVoidChampion({
                                hpScale: cappedHpScale,
                                damageMult: Math.min(2.0, threatScale), // Cap damage scaling at 2x
                                lateGameScaling: cappedLateGameScaling
                            });
                            if (champion) {
                                spawnCount = Math.max(1, spawnCount - 1);
                            }
                        }
                    }
                    if (store.world.wave % 5 !== 0) {
                        trySpawnCubeBurglar({
                            hpScale: Math.min(2.6, threatScale * 1.1),
                            lateGameScaling,
                            damageMult: Math.min(2.1, threatScale * 0.9)
                        });
                    }
                    const spawnSpecs = buildWaveSpawnSpecs(store.world.wave, spawnCount, threatScale, lateGameScaling);

                    if (spawnSpecs.length === 0) {
                        spawnSpecs.push({
                            type: 'drone',
                            props: { hpScale: threatScale, damageMult: threatScale },
                            lateGameScaling,
                            spawnDuration: 0.6,
                            spawnDropDistance: 120,
                            effectColor: teleportAuraByType.drone
                        });
                        store.world.lastSpawnFallback = true;
                    }

                    const plannedClusters = Math.max(1, Math.ceil(spawnSpecs.length / 4));
                    const clusterCount = Math.min(6, plannedClusters);
                    const spawnTempo = Math.max(0.2, 0.55 - Math.min(store.world.wave, 25) * 0.015);

                    store.pendingSpawnCount = spawnSpecs.length;
                    store.world.lastSpawnQueueLength = spawnSpecs.length;
                    store.world.lastSpawnTempo = spawnTempo;
                    store.world.lastSpawnCount = store.enemies.length;

                    scheduleWaveSpawnClusters(spawnSpecs, {
                        clusterCount,
                        baseDelay: spawnTempo,
                        jitter: spawnTempo * 0.6
                    });

                    // Spawn tombstones naturally in waves (starting wave 10)
                    if (store.world.wave >= 10 && store.world.wave % 5 !== 0) { // Not on boss waves
                        const tombstoneChance = Math.min(0.65, 0.15 + (store.world.wave - 10) * 0.02); // 15% base, +2% per wave
                        const maxTombstones = Math.min(3, 1 + Math.floor((store.world.wave - 10) / 10)); // 1-3 tombstones
                        
                        if (Math.random() < tombstoneChance) {
                            const tombstoneCount = Math.random() < 0.7 ? 1 : maxTombstones; // 70% chance for 1, 30% for max
                            
                            for (let t = 0; t < tombstoneCount; t++) {
                                // Spawn with delay to stagger them
                                setTimeout(() => {
                                    if (!window.spawnTombstone) return;
                                    spawnTombstone(); // Uses random edge position
                                }, 2000 + t * 1500); // Spawn at 2s, 3.5s, 5s intervals
                            }
                        }
                    }

                    const cooldownReady = !store.world.voidReaperCooldown || store.world.voidReaperCooldown <= 0;
                    const recentWaveGap = store.world.lastVoidReaperWave ? (store.world.wave - store.world.lastVoidReaperWave) : Infinity;
                    const eligibleForVoidReaper = store.world.wave >= 12 && cooldownReady && recentWaveGap >= (VOID_REAPER_CONFIG.minWaveGap || 3) && !store.world.voidReaperSpawnedThisWave;
                    if (eligibleForVoidReaper) {
                        const baseChance = 0.14;
                        const waveBonus = Math.min(0.18, Math.max(0, store.world.wave - 12) * 0.012);
                        const loopBonus = Math.min(0.12, (store.world.loop || 0) * 0.02);
                        const spawnChance = Math.min(0.42, baseChance + waveBonus + loopBonus);
                        if (Math.random() < spawnChance) {
                            const spawnDelay = 4.5 + Math.random() * 5.5;
                            const hpScale = Math.min(3.2, threatScale * (0.88 + Math.random() * 0.25));
                            const damageMult = Math.min(2.4, threatScale * (1 + Math.random() * 0.2));
                            store.world.pendingVoidReaper = {
                                timer: spawnDelay,
                                hpScale,
                                damageMult,
                                lateGameScaling
                            };
                            store.world.voidReaperWarningIssued = false;
                        } else {
                            store.world.pendingVoidReaper = null;
                            store.world.voidReaperWarningIssued = false;
                        }
                    } else {
                        store.world.pendingVoidReaper = null;
                        store.world.voidReaperWarningIssued = false;
                    }

                    store.world.waveStartTime = performance.now();
                    const waveProfile = currentWaveProfile || getSpawnProfileForWave(store.world.wave);
                    const openingTransmission = composeWaveTransmission(waveProfile?.theme, store.world.wave);
                    broadcastTransmission(openingTransmission);
                }
            }

            function getBossDefinitionByCycle(cycle) {
                const total = BOSS_DEFINITIONS.length;
                if (total === 0) return null;
                const idx = ((cycle % total) + total) % total;
                return BOSS_DEFINITIONS[idx];
            }

            function createBoss(scale) {
                const cycleRaw = Math.floor((store.world.wave - 5) / 5);
                const def = getBossDefinitionByCycle(cycleRaw) || BOSS_DEFINITIONS[0];
                
                // Only apply bossHealthBonus and collar scaling AFTER 2nd boss is defeated
                let hp = def.baseHp * scale;
                let collarBonus = 1;
                if (store.world.bosses >= 2) {
                    // Apply both the adaptation bonus AND collar bonus for 3rd boss onward
                    const adaptationBonus = store.world.bossHealthBonus || 1;
                    hp *= adaptationBonus;
                    collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                    hp *= collarBonus;
                }

                const boss = {
                    ...def,
                    themeKey: def.key,
                    x: W / 2,
                    y: -80,
                    isBoss: true,
                    hpMax: hp,
                    hp,
                    t: 0,
                    fireT: 0,
                    moveT: 0,
                    vx: 100,
                    vy: 30,
                    patternPhase: 0,
                    isEnraged: false,
                    attackPhase: 0,
                    phaseTimer: 0,
                    dashTimer: 0,
                    dashTrailCooldown: 0,
                    rainEvent: null,
                    phase: def.phase ?? 0,
                    isLaughing: def.isLaughing ?? false,
                    laughStartTime: def.laughStartTime ?? 0,
                    visible: def.visible ?? true
                };

                const waveIndex = store && store.world ? store.world.wave : 0;
                const instanceSuffix = Math.random().toString(36).slice(2, 8);
                boss.instanceId = `boss-${waveIndex}-${Date.now().toString(36)}-${instanceSuffix}`;
                boss._instanceId = boss.instanceId;
                boss.spawnWave = waveIndex;
                boss.spawnedAt = performance.now();

                console.log(`ðŸ† Boss Created: ${boss.name} | Wave: ${store.world.wave} | HP: ${hp.toFixed(0)} | Scale: ${scale} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x`);

                // Create Boss class instance for DEATH ENGINE
                if (boss.name === 'DEATH ENGINE') {
                    boss.skullRenderer = new Boss(ctx, boss.x, boss.y, boss.color);
                    // Store collar stacks before Death Engine fight to restore them after
                    store.world.deathEngineCollarStacks = store.world.collarStacks;
                    store.world.deathEngineCollarTargetStacks = store.world.collarTargetStacks;
                }

                return boss;
            }

            function spawnEnemy(type = 'drone', props = {}) {
                const cfgs = {
                    drone: { r: 10, v: 80, vx: 0, hp: 30, color: '#C0C0C0', xp: 5, score: 50, gold: 2, fireRateChance: 0.004, contactDamage: 8 },
                    hunter: { r: 20, v: 100, vx: 0, hp: 26, color: '#DC143C', xp: 8, score: 80, gold: 3, fireRateChance: 0.005, contactDamage: 10 },
                    zombie: { r: 12, v: 35, vx: 0, hp: 50, color: '#00ff88', xp: 3, score: 30, gold: 1, fireRateChance: 0, contactDamage: 8, tracksPlayer: true },
                    trap_king_add: { r: 6, v: 90, vx: 0, hp: 12, color: '#ffc83d', damage: 5, xp: 2, score: 10, gold: 1, contactDamage: 6 },
                    phantom: { r: 14, v: 90, vx: 0, hp: 48, color: '#FFFFFF', xp: 10, score: 100, gold: 3, fireRateChance: 0.006, fireCooldown: 1.5, contactDamage: 10 },
                    mech: { r: 18, v: 40, vx: 0, hp: 60, color: '#FF8500', xp: 15, score: 150, gold: 6, fireRateChance: 0.007, attackPhase: 0, contactDamage: 12 },
                    mech_elite: { r: 18, v: 40, vx: 0, hp: 120, color: '#9d00ff', color2: '#ff0044', xp: 35, score: 400, gold: 18, fireRateChance: 0.008, attackPhase: 0, contactDamage: 16, isElite: true },
                    construct_gold: { r: 10, v: 120, vx: 0, hp: 24, color: '#e03434', xp: 3, score: 30, gold: 1, contactDamage: 9 },
                    avian_hatchling: { r: 8, v: 150, vx: 0, hp: 30, color: '#9370DB', xp: 4, score: 40, gold: 1, contactDamage: 8 },
                    angler: { r: 22, v: 30, vx: 0, hp: 210, color: '#00008b', xp: 18, score: 180, gold: 4, fireRateChance: 0.008, contactDamage: 12 },
                    manta: { r: 26, v: 50, vx: 0, hp: 245, color: '#53B6FF', xp: 22, score: 220, gold: 5, fireRateChance: 0.009, contactDamage: 12 },
                    shadow_champion: { r: 18, v: 70, vx: 0, hp: 860, color: '#cbd4ff', xp: 60, score: 480, gold: 25, fireRateChance: 1, fireCooldown: 1.45, contactDamage: 16 },
                    void_champion: { r: 16, v: 48, vx: 0, hp: 265, color: '#5A28D8', xp: 32, score: 325, gold: 2, fireRateChance: 0.75, fireCooldown: 1.65, contactDamage: 12 },
                    void_champion_orb: { r: 6, v: 0, vx: 0, hp: 30, color: '#FF7DEB', xp: 2, score: 24, gold: 1, fireRateChance: 0.55, fireCooldown: 1.25, contactDamage: 5 },
                    void_reaper: { r: 20, v: 0, vx: 0, hp: 230, color: '#9f74ff', xp: 55, score: 520, gold: 50, contactDamage: 13 }
                };
                const baseCfg = cfgs[type];
                if (!baseCfg) {
                    return null;
                }
                let c = { ...baseCfg }; const wave = store.world.wave;

                // FIXED: Much gentler health scaling to prevent unkillable enemies
                // Old: Math.pow(1.075, wave) - exponential growth was too aggressive
                // New: Linear growth with soft cap - REDUCED for better balance
                let waveMultiplier;
                if (wave <= 10) {
                    waveMultiplier = 1 + (wave - 1) * 0.10; // +10% per wave early game (reduced from 15%)
                } else {
                    waveMultiplier = 1 + 9 * 0.10 + (wave - 10) * 0.03; // +3% per wave after wave 10 (reduced from 5%)
                }

                c.hp *= waveMultiplier * store.world.enemyHealthBonus;
                
                // Apply collar scaling ONLY AFTER 2nd boss is defeated (not based on wave number)
                let enemyCollarMultiplier = 1;
                let enemyCollarDamageMultiplier = 1;
                if (store.world.bosses > 2) {
                    const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Steeper scaling now
                    // Increased collar effect on regular enemies (75% effectiveness) for better challenge scaling
                    enemyCollarMultiplier = 1 + ((collarBonus - 1) * 0.75);
                    c.hp *= enemyCollarMultiplier;
                    
                    // NEW: Collar also scales enemy damage (60% effectiveness to prevent one-shots)
                    enemyCollarDamageMultiplier = 1 + ((collarBonus - 1) * 0.6);
                }

                console.log(`ðŸ” Enemy Health Debug | Type: ${type} | Base: ${cfgs[type].hp} | Wave: ${wave} | WaveMult: ${waveMultiplier.toFixed(2)} | EnemyBonus: ${store.world.enemyHealthBonus.toFixed(2)} | BossesDefeated: ${store.world.bosses} | CollarActive: ${store.world.bosses > 2} | EnemyCollarMult: ${enemyCollarMultiplier.toFixed(2)} | DamageMult: ${enemyCollarDamageMultiplier.toFixed(2)} | Final HP: ${c.hp.toFixed(1)}`);
                
                // ORGANIC SPAWN POSITIONING: Add more natural clustering and variance
                let spawnX, spawnY;
                if (props.x !== undefined) {
                    spawnX = props.x;
                } else {
                    // Clustered spawn zones instead of uniform distribution
                    const useClusteredSpawn = Math.random() < 0.7; // 70% chance of clustering
                    if (useClusteredSpawn) {
                        // Pick a random cluster center (left, center, or right third)
                        const clusterZone = Math.floor(Math.random() * 3);
                        const clusterCenterX = (clusterZone * W / 3) + (W / 6);
                        const clusterSpread = W / 4;
                        spawnX = clusterCenterX + (Math.random() - 0.5) * clusterSpread;
                    } else {
                        // Full-width spawn with edge bias
                        spawnX = 20 + Math.random() * (W - 40);
                    }
                    spawnX = Math.max(20, Math.min(W - 20, spawnX));
                }
                
                if (props.y !== undefined) {
                    spawnY = props.y;
                } else {
                    // More varied vertical spawn with clustering
                    const depthVariance = Math.random() * Math.random(); // Bias toward closer spawns
                    spawnY = -50 - depthVariance * 300;
                }
                const spawnTimestamp = performance.now();
                const e = {
                    ...c,
                    type,
                    id: Date.now() + Math.random(),
                    x: spawnX,
                    y: spawnY,
                    hpMax: c.hp,
                    phase: type === 'phantom',
                    t: 0,
                    fireT: props.fireT !== undefined ? props.fireT : (c.fireCooldown || 0),
                    isBursting: false,
                    burstTimer: 0,
                    stunTimer: 0,
                    knockback: null,
                    hitPulseTimer: 0,
                    hitPulseDuration: props.hitPulseDuration || 0.22,
                    spawnedAt: spawnTimestamp,
                    spawnX,
                    spawnY,
                    hitCount: 0
                };

                if (props.hpScale && props.hpScale !== 1) {
                    e.hp *= props.hpScale;
                    e.hpMax *= props.hpScale;
                }

                e.damageMult = props.damageMult !== undefined ? props.damageMult : 1;
                e.baseContactDamage = props.baseContactDamage || c.contactDamage || 8;
                
                // Apply collar damage multiplier
                if (store.world.bosses > 2) {
                    e.damageMult *= enemyCollarDamageMultiplier;
                }
                
                e.contactDamage = e.baseContactDamage * e.damageMult;

                if (!props.damageMult && props.hpScale && props.hpScale !== 1) {
                    e.damageMult = props.hpScale;
                    if (store.world.bosses > 2) {
                        e.damageMult *= enemyCollarDamageMultiplier;
                    }
                    e.contactDamage = e.baseContactDamage * e.damageMult;
                }

                if (e.type === 'manta') {
                    e.startX = e.x;
                    e.amplitude = 150 + Math.random() * 100;
                    e.frequency = 0.5 + Math.random() * 0.5;
                    e.dodgeCooldown = 0;
                    e.isDodging = false;
                }
                if (e.type === 'void_champion') {
                    e.attackModule = props.attackModule || e.attackModule || 'default';
                    if (typeof getChampionMinionAbilityTheme === 'function') {
                        e.abilityTheme = props.abilityTheme || getChampionMinionAbilityTheme(e.attackModule);
                    }
                    if (!props.colorScheme && !e.colorScheme && typeof VOID_CHAMPION_SCHEME_BY_MODULE !== 'undefined') {
                        e.colorScheme = VOID_CHAMPION_SCHEME_BY_MODULE[e.attackModule] || VOID_CHAMPION_SCHEME_BY_MODULE.default;
                    }
                    e.fireCooldown = c.fireCooldown || 1.8;
                    e.fireT = e.fireCooldown * (0.4 + Math.random() * 0.6);
                    e.vx = (Math.random() < 0.5 ? -1 : 1) * (40 + Math.random() * 30);
                    e.dashTimer = 2 + Math.random() * 2;
                    e.dashCooldown = 4 + Math.random() * 3;
                    e.minionIds = [];
                    e.nextPattern = 'beam';
                    if (store && store.player) {
                        const pStats = store.player;
                        const dmgFactor = Math.min(3, Math.max(1, pStats.dmgMult || 1));
                        const multishotFactor = 1 + Math.max(0, (pStats.multishot || 1) - 1) * 0.2 + (pStats.rearMultishot || 0) * 0.1;
                        const fireRateBaseline = 0.45;
                        const fireRateFactor = Math.min(2.5, Math.max(1, fireRateBaseline / Math.max(pStats.fireRate || 0.45, 0.18)));
                        const shieldFactor = Math.pow(Math.max(1, (pStats.shieldMax || 0) / 60), 0.2);
                        const healthFactor = Math.pow(Math.max(1, (pStats.hpMax || 100) / 120), 0.2);
                        const playerScaling = Math.min(3.5, Math.max(1, dmgFactor * multishotFactor * fireRateFactor * Math.max(shieldFactor, healthFactor)));
                        e.hp *= playerScaling;
                        e.hpMax *= playerScaling;
                        e.damageMult *= playerScaling;
                        e.contactDamage = e.baseContactDamage * e.damageMult;
                        e.playerScaling = playerScaling;
                    }
                    if (store && store.world && !store.world.seenVoidChampion) {
                        store.world.seenVoidChampion = true;
                        announce('ðŸ“¡ [Command Relay] "Intercepted: Void champion signature just came online."');
                    }
                    if (store && store.enemies) {
                        const minionCount = 3;
                        for (let i = 0; i < minionCount; i++) {
                            const angle = (i / minionCount) * Math.PI * 2;
                            const ringRadius = 42;
                            const minionAbilityTheme = e.abilityTheme || (typeof getChampionMinionAbilityTheme === 'function' ? getChampionMinionAbilityTheme(e.attackModule) : null);
                            const minionTrailColor = minionAbilityTheme?.trail || e.color;
                            const minion = spawnEnemy('void_champion_orb', {
                                x: e.x + Math.cos(angle) * ringRadius,
                                y: e.y + Math.sin(angle) * ringRadius,
                                orbitTargetId: e.id,
                                orbitAngle: angle,
                                orbitRadius: ringRadius,
                                orbitSpeed: 1.3 + i * 0.12,
                                parentColor: minionTrailColor,
                                fireT: Math.random() * 0.6,
                                damageMult: Math.max(1, (e.damageMult || 1) * 0.65),
                                hpScale: Math.max(1, (e.damageMult || 1) * 0.7),
                                attackModule: e.attackModule,
                                abilityTheme: minionAbilityTheme
                            });
                            if (minion) {
                                const minionDrop = 140;
                                const minionTargetY = (e.spawnTargetY ?? e.y + minionDrop) + Math.sin(angle) * 26;
                                minion.spawnTargetY = minionTargetY;
                                activateSpawnIntro(minion, {
                                    duration: 0.55 + Math.random() * 0.1,
                                    dropDistance: minionDrop,
                                    targetY: minionTargetY,
                                    clusterIndex: -1,
                                    effectColor: '#ff7deb',
                                    topClampBuffer: 0.6,
                                    fireDelayBuffer: 0.4
                                });
                                e.minionIds.push(minion.id);
                                store.enemies.push(minion);
                            }
                        }
                    }
                }
                if (e.type === 'shadow_champion') {
                    e.baseV = e.v;
                    e.guardRadius = props.guardRadius || 120;
                    e.guardAngle = props.guardAngle ?? Math.random() * Math.PI * 2;
                    e.angularSpeed = props.angularSpeed || (0.75 + Math.random() * 0.25);
                    e.anchorOffsetY = props.anchorOffsetY ?? 80;
                    e.fireCooldown = props.fireCooldown || e.fireCooldown || 1.45;
                    e.fireT = props.fireT !== undefined ? props.fireT : e.fireCooldown * (0.4 + Math.random() * 0.3);
                    e.momentum = props.momentum || 3.4;
                    e.enrageThreshold = props.enrageThreshold || 0.45;
                    e.state = null;
                    e.dashTimer = 0;
                    e.dashVX = 0;
                    e.dashVY = 0;
                    e.bossLinkId = props.bossLinkId || null;
                    e.guardAnchor = props.guardAnchor || null;
                    e.isShadowChampion = true;
                }
                if (e.type === 'void_champion_orb') {
                    e.isOrbiter = true;
                    e.orbitRadius = props.orbitRadius || 42;
                    e.orbitSpeed = props.orbitSpeed || 1.45;
                    e.orbitAngle = props.orbitAngle ?? Math.random() * Math.PI * 2;
                    e.orbitTargetId = props.orbitTargetId || null;
                    const centerX = props.orbitCenterX !== undefined ? props.orbitCenterX : e.x;
                    const centerY = props.orbitCenterY !== undefined ? props.orbitCenterY : e.y;
                    e.orbitCenter = { x: centerX, y: centerY };
                    if (props.parentColor) {
                        e.color = props.parentColor;
                    }
                    e.attackModule = props.attackModule || e.attackModule || 'default';
                    if (props.abilityTheme) {
                        e.abilityTheme = props.abilityTheme;
                    } else if (!e.abilityTheme && typeof getChampionMinionAbilityTheme === 'function') {
                        e.abilityTheme = getChampionMinionAbilityTheme(e.attackModule);
                    }
                    e.trailColor = e.color || e.abilityTheme?.trail || '#ff7deb';
                    e.fireCooldown = c.fireCooldown || 1.15;
                    e.fireT = props.fireT !== undefined ? props.fireT : e.fireCooldown;
                    e.v = 0;
                }
                if (e.type === 'void_reaper') {
                    e.isVoidReaper = true;
                    e.hp = Math.max(40, e.hp * 0.85);
                    e.hpMax = e.hp;
                    e.v = 0;
                    e.vx = 0;
                    e.contactDamage = Math.max(e.contactDamage || 1, 28);
                    e.gold = Math.max(12, e.gold || 12);
                    e.score = Math.max(420, e.score || 420);
                    e.xp = Math.max(40, e.xp || 40);
                    e.fireRateChance = 0;
                    e.fireT = Infinity;
                    e.hitPulseDuration = props.hitPulseDuration || 0.18;
                    e.hitPulseTimer = 0;
                    e.cannotBeFrozen = true;
                    e.cannotBeKnocked = true;
                    e.knockback = null;
                    e.stunTimer = 0;
                    e.topClampDelay = 0;
                    e.alphaPulseSeed = Math.random() * Math.PI * 2;
                    e.spawnTargetY = props.y !== undefined ? props.y : e.y;
                    e.spawnEdge = props.spawnEdge || 'top';
                    e.entryAngle = props.entryAngle || 0;
                }
                return e;
            }

            function scheduleWaveSpawnClusters(spawnSpecs, options = {}) {
                if (!Array.isArray(spawnSpecs) || spawnSpecs.length === 0) return;

                const sortedSpecs = spawnSpecs.slice().sort((a, b) => {
                    if (a.progressIndex !== undefined && b.progressIndex !== undefined) {
                        return a.progressIndex - b.progressIndex;
                    }
                    return (a.difficultyScore ?? 0) - (b.difficultyScore ?? 0);
                });

                const clustersRequested = options.clusterCount ?? 4; // Increased from 3 for more frequent spawns
                const clusterCount = Math.max(1, Math.min(clustersRequested, sortedSpecs.length));
                const totalSpecs = sortedSpecs.length;
                const progressionStrength = Math.min(1.05, 0.35 + totalSpecs * 0.02);
                const weights = Array.from({ length: clusterCount }, (_, idx) => 1 + idx * progressionStrength);
                const weightSum = weights.reduce((sum, w) => sum + w, 0);

                const clusters = [];
                let cursor = 0;
                let remaining = totalSpecs;
                let lastSize = 0;

                for (let idx = 0; idx < clusterCount; idx++) {
                    const clustersLeft = clusterCount - idx;
                    const remainingAfter = clustersLeft - 1;
                    let target = idx === clusterCount - 1
                        ? remaining
                        : Math.max(1, Math.round((weights[idx] / weightSum) * totalSpecs));

                    const minReserve = Math.max(0, remainingAfter);
                    if (target > remaining - minReserve) {
                        target = Math.max(1, remaining - minReserve);
                    }

                    if (target < lastSize) {
                        target = Math.max(lastSize, Math.min(remaining - minReserve, target + (lastSize - target)));
                    }

                    if (target <= 0) target = Math.max(1, remaining);
                    if (clustersLeft > 1 && target > remaining - (clustersLeft - 1)) {
                        target = remaining - (clustersLeft - 1);
                    }

                    const end = Math.min(totalSpecs, cursor + target);
                    const slice = sortedSpecs.slice(cursor, end);

                    if (!slice.length && remaining > 0) {
                        slice.push(sortedSpecs[cursor]);
                        cursor += 1;
                    } else {
                        cursor = end;
                    }

                    remaining = Math.max(0, totalSpecs - cursor);
                    lastSize = slice.length || lastSize;
                    clusters.push(slice);
                }

                if (cursor < totalSpecs && clusters.length) {
                    clusters[clusters.length - 1].push(...sortedSpecs.slice(cursor));
                }

                const baseDelay = options.baseDelay ?? (0.25 * WAVE_DURATION_SCALE);
                const jitterAmplitude = options.jitter ?? Math.max(0.02, baseDelay * 0.3);
                const queue = store.waveSpawnQueue;

                clusters.forEach((cluster, idx) => {
                    if (!cluster || !cluster.length) return;
                    const stagger = idx === 0 ? 0 : (Math.random() - 0.5) * jitterAmplitude;
                    const timer = Math.max(0, idx * baseDelay + stagger);
                    const difficultyProgress = clusterCount > 1 ? idx / (clusterCount - 1) : 0;
                    queue.push({
                        timer,
                        enemies: cluster,
                        clusterIndex: idx,
                        clusterSize: cluster.length,
                        totalClusters: clusterCount,
                        baseDelay,
                        difficultyProgress,
                        progressionStrength
                    });
                });
            }

            function processWaveSpawnQueue(dt) {
                if (!store.waveSpawnQueue.length) return;
                for (let i = store.waveSpawnQueue.length - 1; i >= 0; i--) {
                    const evt = store.waveSpawnQueue[i];
                    evt.timer -= dt;
                    if (evt.timer <= 0) {
                        spawnClusterEnemies(evt);
                        store.waveSpawnQueue.splice(i, 1);
                    }
                }
            }

            function spawnClusterEnemies(event) {
                const clusterSize = event.enemies.length;
                const centerX = Math.max(80, Math.min(W - 80, 80 + Math.random() * (W - 160)));
                const difficultyProgress = typeof clamp === 'function'
                    ? clamp(event.difficultyProgress ?? ((event.clusterIndex + 1) / Math.max(1, event.totalClusters)), 0, 1)
                    : Math.max(0, Math.min(1, event.difficultyProgress ?? ((event.clusterIndex + 1) / Math.max(1, event.totalClusters))));
                const intensityMultiplier = 1 + difficultyProgress * 0.5;
                
                // THEMED SPAWN FORMATIONS based on current wave profile
                const waveProfile = getSpawnProfileForWave(store.world.wave);
                let spacing = Math.max(40, 140 - clusterSize * 10);
                spacing *= Math.max(0.45, 1 - difficultyProgress * 0.35);
                let formationStyle = 'line'; // default: horizontal line
                
                // HUNTER GANG COORDINATION: Pick a gang for this cluster
                const hunterCount = event.enemies.filter(spec => spec.type === 'hunter').length;
                const hunterGangForCluster = hunterCount > 0 
                    ? HUNTER_GANGS[HUNTER_GANG_LIST[Math.floor(Math.random() * HUNTER_GANG_LIST.length)]]
                    : null;
                
                // If spawning hunters, use tighter formation
                if (hunterCount > 0) {
                    spacing = Math.max(30, 80 - clusterSize * 8); // Tighter spacing for gangs
                    formationStyle = 'cluster';
                }
                
                if (waveProfile && waveProfile.theme) {
                    switch (waveProfile.theme) {
                        case 'SWARM_HELL':
                            // Tight clusters for overwhelming swarms
                            spacing *= 0.6;
                            formationStyle = 'cluster';
                            break;
                        case 'TANK_RUSH':
                        case 'ELITE_ASSAULT':
                            // Wide spread for tanky enemies
                            spacing *= 1.4;
                            formationStyle = 'spread';
                            break;
                        case 'PRECISION_TEST':
                            // Maximum spread to test multi-target
                            spacing *= 1.8;
                            formationStyle = 'spread';
                            break;
                        case 'DODGE_HELL':
                            // Staggered formation
                            formationStyle = 'stagger';
                            break;
                    }
                }
                
                let spawnedThisCluster = 0;
                
                // ORGANIC SPAWN PATTERNS: Use circular/natural clustering instead of grid
                const circularBias = 0.45 + difficultyProgress * 0.4;
                const useCircularPattern = Math.random() < circularBias; // Later clusters favor circular strikes
                const baseClusterRadius = hunterCount > 0 ? 40 : 70;
                const clusterRadius = Math.max(30, baseClusterRadius * Math.max(0.55, 1 - difficultyProgress * 0.4)); // Higher difficulty = tighter focus fire
                const angleOffset = Math.random() * Math.PI * 2; // Random rotation

                event.enemies.forEach((spec, idx) => {
                    let lateralOffset, spawnY;
                    
                    if (useCircularPattern && clusterSize > 2) {
                        // CIRCULAR/ORGANIC PATTERN: Distribute around a circle with variance
                        const angle = (idx / clusterSize) * Math.PI * 2 + angleOffset;
                        const radiusVariance = 0.5 + Math.random() * 0.7; // 50%-120% of radius
                        const actualRadius = clusterRadius * radiusVariance;
                        
                        lateralOffset = Math.cos(angle) * actualRadius;
                        const depthOffset = Math.sin(angle) * actualRadius * 0.5; // Less vertical spread
                        const depthBase = -140 - Math.random() * 60 - depthOffset;
                        const aggressionFactor = Math.max(0.45, 1 - difficultyProgress * 0.4);
                        spawnY = depthBase * aggressionFactor;
                        
                        // Add some noise to break perfect circles
                        lateralOffset += (Math.random() - 0.5) * 25;
                        spawnY += (Math.random() - 0.5) * 30;
                    } else {
                        // IRREGULAR LINE/CLUSTER: Varied spacing with natural randomness
                        const baseOffset = (idx - (clusterSize - 1) / 2) * spacing;
                        
                        switch (formationStyle) {
                            case 'cluster':
                                // Tight cluster with organic variation
                                if (hunterCount > 0) {
                                    lateralOffset = baseOffset + (Math.random() - 0.5) * 45;
                                    const depthBase = -140 - Math.random() * 50;
                                    spawnY = depthBase * Math.max(0.5, 1 - difficultyProgress * 0.35);
                                } else {
                                    lateralOffset = baseOffset + (Math.random() - 0.5) * 80;
                                    const depthBase = -140 - Math.random() * 100;
                                    spawnY = depthBase * Math.max(0.5, 1 - difficultyProgress * 0.35);
                                }
                                break;
                            case 'spread':
                                // Wide spread with natural variance
                                lateralOffset = baseOffset * (0.8 + Math.random() * 0.4) + (Math.random() - 0.5) * 40;
                                const depthBaseSpread = -180 - Math.random() * 120;
                                spawnY = depthBaseSpread * Math.max(0.55, 1 - difficultyProgress * 0.25);
                                break;
                            case 'stagger':
                                // Organic stagger with depth variation
                                lateralOffset = baseOffset + (Math.random() - 0.5) * 60;
                                const staggerDepth = -140 - (Math.random() * 100) - (idx % 2 === 0 ? 0 : 60);
                                spawnY = staggerDepth * Math.max(0.52, 1 - difficultyProgress * 0.3);
                                break;
                            default: // 'line'
                                // Natural line with varying gaps
                                const gapVariance = 0.7 + Math.random() * 0.6; // 70%-130% spacing
                                lateralOffset = baseOffset * gapVariance + (Math.random() - 0.5) * 50;
                                const depthBaseLine = -160 - Math.random() * 140;
                                spawnY = depthBaseLine * Math.max(0.5, 1 - difficultyProgress * 0.35);
                        }
                    }
                    
                    const spawnX = Math.max(40, Math.min(W - 40, centerX + lateralOffset));
                    const props = { ...(spec.props || {}), x: spawnX, y: spawnY };
                    const enemy = spawnEnemy(spec.type, props);
                    store.pendingSpawnCount = Math.max(0, (store.pendingSpawnCount || 0) - 1);
                    if (!enemy) {
                        store.world.lastSpawnFallback = true;
                        return;
                    }

                    applySpawnSpecToEnemy(enemy, spec);

                    const aggressionBonus = intensityMultiplier;
                    if (Number.isFinite(enemy.v) && enemy.v > 0) {
                        enemy.v *= aggressionBonus;
                    }
                    if (Number.isFinite(enemy.vx) && enemy.vx !== 0) {
                        enemy.vx *= aggressionBonus;
                    }
                    if (Number.isFinite(enemy.fireCooldown) && enemy.fireCooldown > 0 && enemy.fireCooldown < Infinity) {
                        enemy.fireCooldown = Math.max(0.18, enemy.fireCooldown / Math.max(1, 0.9 + difficultyProgress * 0.6));
                    }
                    if (Number.isFinite(enemy.fireRateChance) && enemy.fireRateChance > 0) {
                        enemy.fireRateChance = Math.min(0.98, enemy.fireRateChance * (1 + difficultyProgress * 0.5));
                    }
                    enemy.clusterDifficulty = difficultyProgress;
                    
                    // Assign hunter gang (same gang for all hunters in this cluster)
                    if (enemy.type === 'hunter' && hunterGangForCluster) {
                        enemy.gang = hunterGangForCluster;
                    }
                    
                    // Assign movement behavior based on sector theme
                    const currentTheme = waveProfile?.theme || 'MIXED_BASICS';
                    assignMovementBehavior(enemy, currentTheme);
                    
                    activateSpawnIntro(enemy, {
                        duration: spec.spawnDuration,
                        dropDistance: spec.spawnDropDistance,
                        clusterIndex: event.clusterIndex,
                        effectColor: spec.effectColor,
                        topClampBuffer: Math.max(0.35, 0.75 - difficultyProgress * 0.3),
                        clusterSize
                    });

                    store.enemies.push(enemy);
                    store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
                    spawnedThisCluster++;

                    store.activeEffects.push(createEffect('spawnTeleport', enemy.x, enemy.spawnTargetY ?? enemy.y, enemy.r || 18, {
                        duration: (enemy.spawnDuration || 0.6) + 0.25,
                        color: spec.effectColor,
                        clusterIndex: event.clusterIndex,
                        clusterSize
                    }));
                });

                if (spawnedThisCluster === 0) {
                    const fallback = spawnEnemy('drone', { x: centerX, y: -140 });
                    if (fallback) {
                        applySpawnSpecToEnemy(fallback, { lateGameScaling: 1 });
                        activateSpawnIntro(fallback, {
                            duration: 0.6,
                            dropDistance: 110,
                            clusterIndex: event.clusterIndex,
                            effectColor: '#7fd5ff',
                            topClampBuffer: 0.75,
                            clusterSize
                        });
                        store.enemies.push(fallback);
                        store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
                        store.world.lastSpawnFallback = true;
                        store.activeEffects.push(createEffect('spawnTeleport', fallback.x, fallback.spawnTargetY ?? fallback.y, fallback.r || 14, {
                            duration: (fallback.spawnDuration || 0.6) + 0.25,
                            color: '#7fd5ff',
                            clusterIndex: event.clusterIndex,
                            clusterSize,
                            fallback: true
                        }));
                    }
                }
            }

            function applySpawnSpecToEnemy(enemy, spec) {
                if (spec.lateGameScaling && spec.lateGameScaling > 1) {
                    enemy.hp *= spec.lateGameScaling;
                    enemy.hpMax *= spec.lateGameScaling;
                    enemy.damageMult = (enemy.damageMult || 1) * spec.lateGameScaling;
                }
                if (spec.props && spec.props.damageMult !== undefined) {
                    enemy.damageMult = spec.props.damageMult;
                }
                enemy.baseContactDamage = spec.baseContactDamage ?? enemy.baseContactDamage ?? enemy.contactDamage ?? 8;
                enemy.contactDamage = enemy.baseContactDamage * (enemy.damageMult || 1);
                if (typeof spec.onSpawn === 'function') {
                    try {
                        spec.onSpawn(enemy);
                    } catch (err) {
                        // Spawn spec hook error silenced
                    }
                }
            }

            function activateSpawnIntro(enemy, opts = {}) {
                const duration = opts.duration ?? enemy.spawnDuration ?? (0.6 + Math.random() * 0.2);
                const dropDistance = opts.dropDistance ?? enemy.spawnDropDistance ?? (80 + Math.random() * 70);
                const existingTarget = enemy.spawnTargetY !== undefined ? enemy.spawnTargetY : enemy.y;
                const targetY = opts.targetY ?? (enemy.spawnTargetY !== undefined ? existingTarget : existingTarget + dropDistance);
                const startY = targetY - dropDistance;

                enemy.spawnPhase = 'teleport';
                enemy.spawnDuration = duration;
                enemy.spawnTimer = duration;
                enemy.spawnTargetY = targetY;
                enemy.spawnStartY = startY;
                enemy.spawnOpacity = 0;
                enemy.spawnEffectColor = opts.effectColor ?? enemy.spawnEffectColor;
                enemy.spawnClusterIndex = opts.clusterIndex ?? enemy.spawnClusterIndex ?? 0;
                enemy.spawnClusterSize = opts.clusterSize ?? enemy.spawnClusterSize ?? 1;
                enemy.spawnIntroGlow = opts.glowStrength ?? enemy.spawnIntroGlow ?? 1;
                enemy.topClampDelay = Math.max(enemy.topClampDelay || 0, duration + (opts.topClampBuffer ?? 0.5));
                enemy.fireT = Math.max(enemy.fireT || 0, duration + (opts.fireDelayBuffer ?? 0.25));
                enemy.y = startY;
            }

            function registerEnemyHit(enemy, impact = {}) {
                if (!enemy || enemy.dead) return;

                const duration = impact.duration ?? enemy.hitPulseDuration ?? 0.22;
                enemy.hitPulseDuration = duration;
                enemy.hitPulseTimer = duration;

                const shakeIntensity = impact.shakeIntensity ?? 0;
                if (shakeIntensity > 0) {
                    const shakeDuration = Math.max(impact.shakeDuration ?? 0.16, 0);
                    enemy.hitShakeDuration = Math.max(enemy.hitShakeDuration || 0, shakeDuration);
                    enemy.hitShakeTimer = Math.max(enemy.hitShakeTimer || 0, shakeDuration);
                    enemy.hitShakeIntensity = Math.max(enemy.hitShakeIntensity || 0, shakeIntensity);
                }

                if (impact.slowFactor !== undefined && impact.slowFactor < 1) {
                    const slowDuration = Math.max(impact.slowDuration ?? 0.12, 0);
                    if (slowDuration > 0) {
                        enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, impact.slowFactor);
                        enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
                    }
                }

                const strength = impact.knockbackStrength ?? 140;
                if (strength > 0) {
                    const angle = impact.angle ?? 0;
                    const vx = Math.cos(angle) * strength;
                    const vy = Math.sin(angle) * strength;
                    const knockDuration = impact.knockbackDuration ?? 0.1;

                    if (!enemy.knockback || enemy.knockback.type === 'hitReaction') {
                        enemy.knockback = {
                            vx,
                            vy,
                            duration: knockDuration,
                            type: 'hitReaction'
                        };
                    } else if (enemy.knockback && enemy.knockback.vx !== undefined && enemy.knockback.type !== 'maraLaunch' && enemy.knockback.type !== 'jugCharge') {
                        enemy.knockback.vx += vx * 0.35;
                        enemy.knockback.vy += vy * 0.35;
                        enemy.knockback.duration = Math.max(enemy.knockback.duration || 0, knockDuration * 0.8);
                    }
                } else if (strength === 0 && enemy.knockback && enemy.knockback.type === 'hitReaction') {
                    enemy.knockback = null;
                }

                if (impact.effect !== false) {
                    store.activeEffects.push(createEffect('hitSpark', enemy.x, enemy.y, enemy.r || 16, {
                        angle: impact.angle ?? 0,
                        strength,
                        crit: impact.crit || false
                    }));
                }
            }

            function getChargeUpgradeDamageBonus(p) {
                // Calculate upgrade-based damage bonus for standard enemies
                let bonus = 0;
                
                // Base charge unlocked: starts at 30% (no bonus)
                
                // Enhanced charge: +15%
                if (p.beefChargeDamageMultiplier && p.beefChargeDamageMultiplier >= 1.5) {
                    bonus += 0.15;
                }
                
                // Juggernaut skills: +10%
                if (p.skillTree && p.skillTree.juggernaut) {
                    bonus += 0.10;
                }
                
                // Enhanced juggernaut: +15%
                if (p.skillTree && p.skillTree.juggernaut_enhanced) {
                    bonus += 0.15;
                }
                
                // Multi-charge (marauder): +5%
                if (p.beefMaxCharges && p.beefMaxCharges >= 3) {
                    bonus += 0.05;
                }
                
                // Chain assault (marauder): +10%
                if (p.beefChainMode) {
                    bonus += 0.10;
                }
                
                return bonus;
            }

            function getChargeUpgradeBossDamageBonus(p) {
                // Calculate upgrade-based damage bonus for bosses (only with Demolitioner)
                if (p.subclass !== 'demolitioner') return 0;
                
                let bonus = 0;
                
                // Enhanced charge: +0.5%
                if (p.beefChargeDamageMultiplier && p.beefChargeDamageMultiplier >= 1.5) {
                    bonus += 0.005;
                }
                
                // Demolitioner skills provide incremental boss damage
                if (p.skillTree && p.skillTree.demolitioner_bigger_clusters) {
                    bonus += 0.008;
                }
                
                if (p.skillTree && p.skillTree.demolitioner_cluster_mastery) {
                    bonus += 0.012;
                }
                
                return bonus;
            }

            function calculatePercentageBasedChargeDamage(p, enemy, basePercentage, upgradeBonus) {
                const isBoss = enemy === store.boss || enemy.type === 'void_champion' || enemy.type === 'shadow_champion';
                
                if (!isBoss) {
                    // Standard enemy: 30% base, scales to 85% max with upgrades
                    let damagePercentage = basePercentage;
                    damagePercentage += upgradeBonus;
                    damagePercentage = Math.min(damagePercentage, 0.85);
                    return enemy.hpMax * damagePercentage;
                } else {
                    // Boss: 4% base, scales to 6.5% max with Demolitioner upgrades
                    let damagePercentage = 0.04;
                    
                    if (p.subclass === 'demolitioner') {
                        const bossBonus = getChargeUpgradeBossDamageBonus(p);
                        damagePercentage += bossBonus;
                        damagePercentage = Math.min(damagePercentage, 0.065);
                    }
                    
                    return enemy.hpMax * damagePercentage;
                }
            }

            function computeBeefChargeContext(p) {
                let impactRadius = 80;
                if (p.skillTree && p.skillTree.juggernaut) impactRadius = 120;
                if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) impactRadius = 160;
                if (p.beefExplosionRadius) impactRadius *= p.beefExplosionRadius;
                if (p.subclass === 'juggernaut') impactRadius = Math.max(impactRadius, 120);

                // NOTE: baseDamage is now used as a fallback only - actual damage is percentage-based
                let baseDamage = 35;
                if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) baseDamage = 65;
                if (p.beefChargeDamage) baseDamage *= p.beefChargeDamage;
                if (p.beefExplosionDamage) baseDamage *= p.beefExplosionDamage;
                if (p.beefChargeDamageMultiplier) baseDamage *= p.beefChargeDamageMultiplier;

                const damageTags = p.subclass === 'juggernaut' ? ['fire', 'explosive'] : ['kinetic', 'concussive'];

                const hasJuggernautSkills = (p.skillTree && p.skillTree.juggernaut) || p.subclass === 'juggernaut' ||
                    (p.skillTree && (p.skillTree.juggernaut_charge_power || p.skillTree.juggernaut_charge_mastery ||
                        p.skillTree.juggernaut_heavy_armor || p.skillTree.juggernaut_unstoppable || p.skillTree.juggernaut_enhanced));

                const chainDamageBonus = p.beefChainDamageBonus || (p.beefChainMode ? 1.25 : 1);
                const chainRadiusScale = p.beefChainMode ? 0.85 : 1;

                return {
                    impactRadius,
                    baseDamage,
                    damageTags,
                    hasJuggernautSkills,
                    explosionSound: hasJuggernautSkills ? 'charge' : 'beefCharge',
                    knockbackBase: 250,
                    doubleHitMultiplier: p.marauderDoubleHitBonus || 2.0,
                    chainDamageBonus,
                    chainRadiusScale
                };
            }

            function getBeefChargeTargetPosition(segment) {
                if (!segment) return { x: 0, y: 0 };
                if (segment.enemy && !segment.enemy.dead) {
                    segment.fallbackX = segment.enemy.x;
                    segment.fallbackY = segment.enemy.y;
                }
                const targetX = segment.fallbackX !== undefined ? segment.fallbackX : (segment.startX ?? 0);
                const targetY = segment.fallbackY !== undefined ? segment.fallbackY : (segment.startY ?? 0);
                return { x: targetX, y: targetY };
            }

            function findClosestEnemyInRange(origin, enemies, rangeSq, used = new Set()) {
                if (!origin || !enemies || enemies.length === 0) return null;
                const ox = origin.x ?? 0;
                const oy = origin.y ?? 0;
                let best = null;
                let bestDistSq = Infinity;
                enemies.forEach(enemy => {
                    if (!enemy || enemy.dead || enemy.stunTimer > 0) return;
                    if (used && used.has(enemy)) return;
                    const dx = enemy.x - ox;
                    const dy = enemy.y - oy;
                    const distSq = dx * dx + dy * dy;
                    if (rangeSq !== undefined && distSq > rangeSq) return;
                    if (!best || distSq < bestDistSq) {
                        best = enemy;
                        bestDistSq = distSq;
                    }
                });
                return best;
            }

            function buildBeefChargePlan(p, primaryEnemy, potentialTargets = []) {
                if (!p || !primaryEnemy) return null;

                const context = computeBeefChargeContext(p);
                const origin = { x: p.x, y: p.y };
                const rangeMultiplier = p.beefChargeRange || 1;
                const baseRange = 240;
                const effectiveRange = baseRange * rangeMultiplier;
                const rangeSq = effectiveRange * effectiveRange;
                const segments = [];
                const used = new Set();

                const pushEnemySegment = (enemy, label) => {
                    if (!enemy || enemy.dead || used.has(enemy)) return;
                    segments.push({
                        enemy,
                        fallbackX: enemy.x,
                        fallbackY: enemy.y,
                        doImpact: true,
                        label
                    });
                    used.add(enemy);
                };

                pushEnemySegment(primaryEnemy, 'primary');

                if (p.beefChainMode && p.beefMaxCharges > 1) {
                    let anchor = primaryEnemy;
                    const maxChains = Math.min(p.beefMaxCharges - 1, potentialTargets.length);
                    for (let i = 0; i < maxChains; i++) {
                        const reference = (anchor && !anchor.dead)
                            ? { x: anchor.x, y: anchor.y }
                            : (segments.length
                                ? { x: segments[segments.length - 1].fallbackX, y: segments[segments.length - 1].fallbackY }
                                : origin);
                        const nextEnemy = findClosestEnemyInRange(reference, potentialTargets, rangeSq, used);
                        if (!nextEnemy) break;
                        pushEnemySegment(nextEnemy, 'chain');
                        anchor = nextEnemy;
                    }
                }

                if (segments.length === 0) return null;

                const returnToOrigin = !p.beefChainMode && p.subclass !== 'marauder';
                if (returnToOrigin) {
                    segments.push({
                        enemy: null,
                        fallbackX: origin.x,
                        fallbackY: origin.y,
                        doImpact: false,
                        label: 'return'
                    });
                }

                // Factor in player speed upgrades to make beef charge faster with speed upgrades
                const baseChargeSpeed = p.beefChargeSpeed || 1.35;
                const speedUpgradeMultiplier = Math.max(1.0, (p.speed || 2.5) / 2.5); // Speed upgrades make charge faster
                const effectiveChargeSpeed = baseChargeSpeed * speedUpgradeMultiplier;
                
                return {
                    context,
                    origin,
                    segments,
                    chainDelay: p.beefChainMode ? 0.08 : 0,
                    recoveryDelay: returnToOrigin ? 0.1 : 0.12,
                    segmentDuration: 0.24 / Math.max(effectiveChargeSpeed, 0.6),
                    returnToOrigin
                };
            }

            function spawnBeefChargeTrail(startX, startY, targetX, targetY, options = {}) {
                store.activeEffects.push(createEffect('beefCharge', { x: startX, y: startY }, { x: targetX, y: targetY }, undefined, options));
            }

            function resolveBeefChargeImpact(p, context, impactX, impactY, options = {}) {
                const segment = options.segment || null;
                const segmentLabel = segment ? segment.label : 'primary';
                const segmentIndex = options.index ?? 0;
                let impactRadius = context.impactRadius;
                if (segmentLabel === 'chain' && context.chainRadiusScale) {
                    impactRadius *= context.chainRadiusScale;
                }

                if (context.hasJuggernautSkills) {
                    playSound(context.explosionSound);
                    explode(impactX, impactY, false, true);
                } else {
                    playSound(context.explosionSound);
                }

                store.activeEffects.push(createEffect('marauderImpact', impactX, impactY, impactRadius, {
                    subclass: p.subclass,
                    segmentLabel,
                    segmentIndex
                }));

                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                if (!p.marauderHitTargets) p.marauderHitTargets = new Set();

                let lastEnemyHit = null;
                const radiusSq = impactRadius * impactRadius;

                potentialTargets.forEach(e => {
                    if (!e || e.dead) return;
                    const dx = e.x - impactX;
                    const dy = e.y - impactY;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > radiusSq) return;

                    let damageMultiplier = 1;
                    if (segmentLabel === 'chain') {
                        if (context.chainDamageBonus) damageMultiplier *= context.chainDamageBonus;
                        if (p.beefChainBonus) damageMultiplier *= p.beefChainBonus;
                    }
                    
                    // Calculate percentage-based damage
                    const upgradeBonus = getChargeUpgradeDamageBonus(p);
                    let chargeDmg = calculatePercentageBasedChargeDamage(p, e, 0.30, upgradeBonus);
                    chargeDmg *= damageMultiplier * p.dmgMult;
                    
                    const enemyId = e.id || `${e.x}_${e.y}_${e.type}`;
                    let isDoubleHit = false;

                    if (p.subclass === 'marauder') {
                        if (p.marauderHitTargets.has(enemyId)) {
                            isDoubleHit = true;
                            const multiplier = context.doubleHitMultiplier || 2.0;
                            if (e === store.boss || e.type === 'void_champion') {
                                chargeDmg *= multiplier * 1.5;
                                e.stunTimer = 8.0;
                                e.marauderMarked = true;
                                announce('CHAMPION DEVASTATION!');
                            } else {
                                // Apply temporary flatten effect (3 second duration, not permanent)
                                e.isFlattened = true;
                                e.flattenedTime = performance.now();
                                e.flattenDuration = 3.0; // Flatten lasts 3 seconds, then recovers
                                e.v = 0;
                                e.vx = 0;
                                e.vy = 0;
                                e.hp = Math.min(e.hp, 1);
                                e.stunTimer = 3.0; // Match flatten duration (not infinite!)
                                e.fireRateChance = 0;
                                e.flattenScale = { x: 2.0, y: 0.1 };
                                const bonusText = multiplier >= 3.0 ? 'ELITE FLATTEN!' : 'MARAUDER FLATTEN!';
                                announce(bonusText);
                            }
                            setTimeout(() => p.marauderHitTargets.delete(enemyId), 100);
                        } else {
                            p.marauderHitTargets.add(enemyId);
                            setTimeout(() => p.marauderHitTargets.delete(enemyId), 3000);
                        }
                    }

                    const knockbackAngle = Math.atan2(e.y - impactY, e.x - impactX);
                    const vulnResult = applySubclassVulnerability(e, chargeDmg, {
                        player: p,
                        subclass: p.subclass,
                        damageTags: context.damageTags,
                        source: 'beefCharge',
                        knockbackAngle,
                        baseDamage: chargeDmg
                    });
                    chargeDmg = vulnResult.damage;

                    e.hp -= chargeDmg;
                    if (!isDoubleHit) {
                        e.stunTimer = Math.max(e.stunTimer || 0, 2.5);
                    }

                    if (p.vampirism > 0) {
                        let healAmount = chargeDmg * p.vampirism;
                        healAmount = Math.max(healAmount, 1);
                        healAmount = Math.min(healAmount, 8);
                        p.hp = Math.min(p.hpMax, p.hp + healAmount);
                    }

                    let knockbackForce = context.knockbackBase * (segmentLabel === 'chain' ? Math.max(0.85, damageMultiplier) : 1);
                    if (p.beefChargeKnockback) {
                        knockbackForce *= p.beefChargeKnockback;
                    }
                    if (!e.knockback || e.knockback.type !== 'maraLaunch') {
                        e.knockback = {
                            vx: Math.cos(knockbackAngle) * knockbackForce,
                            vy: Math.sin(knockbackAngle) * knockbackForce,
                            duration: 0.3,
                            type: 'maraLaunch'
                        };
                    }

                    lastEnemyHit = e;
                });

                return {
                    x: impactX,
                    y: impactY,
                    enemy: lastEnemyHit
                };
            }

            function stepPlayer(dt) {
                const p = store.player;
                if (!p) return;
                ensurePlayerMultishotIntegrity(p);
                if (p.collisionDamageCooldown && p.collisionDamageCooldown > 0) {
                    p.collisionDamageCooldown = Math.max(0, p.collisionDamageCooldown - dt);
                }
                
                // Check if star power invincibility should expire
                if (p.isInvincible && p.starPowerEndTime && performance.now() >= p.starPowerEndTime) {
                    p.isInvincible = false;
                    p.starPowerEndTime = null;
                    announce('â­ Star Power Expired');
                }
                
                if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0 && p.beefChargeState !== 'ready') {
                    const plan = p.beefChargePlan;
                    if (!plan || !plan.segments || plan.segments.length === 0) {
                        p.beefChargeState = 'ready';
                        p.beefChargePlan = null;
                        p.beefChargeT = 0;
                        p.beefImpactDelay = 0;
                        p.isInvincible = false;
                    } else if (p.beefChargeState === 'charging') {
                        const segmentIndex = Math.min(p.beefChargeSegmentIndex, plan.segments.length - 1);
                        const segment = plan.segments[segmentIndex];
                        if (!segment) {
                            p.beefChargeState = 'ready';
                            p.beefChargePlan = null;
                            p.beefChargeT = 0;
                            p.isInvincible = false;
                        } else {
                            if (segment.startX === undefined) {
                                segment.startX = p.x;
                                segment.startY = p.y;
                            }
                            const targetPos = getBeefChargeTargetPosition(segment);
                            const startX = segment.startX;
                            const startY = segment.startY;
                            const progress = Math.min((p.beefChargeT + dt) / plan.segmentDuration, 1);
                            const eased = 1 - Math.pow(1 - progress, 3);
                            p.x = startX + (targetPos.x - startX) * eased;
                            p.y = startY + (targetPos.y - startY) * eased;
                            p.beefChargeT += dt;
                            p.isInvincible = true;
                            const distSq = (targetPos.x - p.x) * (targetPos.x - p.x) + (targetPos.y - p.y) * (targetPos.y - p.y);
                            if (progress >= 1 || distSq < 9) {
                                p.x = targetPos.x;
                                p.y = targetPos.y;
                                const impactResult = segment.doImpact
                                    ? resolveBeefChargeImpact(p, plan.context, targetPos.x, targetPos.y, {
                                        segment,
                                        index: p.beefChargeSegmentIndex
                                    })
                                    : { x: targetPos.x, y: targetPos.y, enemy: null };
                                if (segment.doImpact || !p.beefLastImpact) {
                                    p.beefLastImpact = impactResult;
                                }
                                p.beefChargeSegmentIndex++;
                                p.beefChargeT = 0;
                                if (p.beefChargeSegmentIndex < plan.segments.length) {
                                    p.beefImpactDelay = plan.chainDelay;
                                    if (plan.chainDelay > 0) {
                                        p.beefChargeState = 'impactPause';
                                    } else {
                                        const nextSegment = plan.segments[p.beefChargeSegmentIndex];
                                        nextSegment.startX = p.x;
                                        nextSegment.startY = p.y;
                                        const nextTarget = getBeefChargeTargetPosition(nextSegment);
                                        p.beefChargeOrigin = { x: p.x, y: p.y };
                                        p.beefChargeTarget = { x: nextTarget.x, y: nextTarget.y };
                                        spawnBeefChargeTrail(p.x, p.y, nextTarget.x, nextTarget.y, {
                                            subclass: p.subclass,
                                            segmentIndex: p.beefChargeSegmentIndex,
                                            segmentLabel: nextSegment.label,
                                            rangeOverride: plan.context.impactRadius
                                        });
                                    }
                                } else {
                                    p.beefImpactDelay = plan.recoveryDelay;
                                    p.beefChargeState = 'recovering';
                                    p.beefChargePlan = null;
                                    p.isInvincible = false;
                                }
                            }
                        }
                    } else if (p.beefChargeState === 'impactPause') {
                        p.beefImpactDelay -= dt;
                        p.isInvincible = true;
                        if (p.beefImpactDelay <= 0) {
                            if (plan && p.beefChargeSegmentIndex < plan.segments.length) {
                                const nextSegment = plan.segments[p.beefChargeSegmentIndex];
                                nextSegment.startX = p.x;
                                nextSegment.startY = p.y;
                                const nextTarget = getBeefChargeTargetPosition(nextSegment);
                                p.beefChargeOrigin = { x: p.x, y: p.y };
                                p.beefChargeTarget = { x: nextTarget.x, y: nextTarget.y };
                                spawnBeefChargeTrail(p.x, p.y, nextTarget.x, nextTarget.y, {
                                    subclass: p.subclass,
                                    segmentIndex: p.beefChargeSegmentIndex,
                                    segmentLabel: nextSegment.label,
                                    rangeOverride: plan.context.impactRadius
                                });
                                p.beefChargeState = 'charging';
                                p.beefChargeT = 0;
                            } else {
                                p.beefChargeState = 'recovering';
                                p.beefImpactDelay = plan ? plan.recoveryDelay : 0.12;
                                p.isInvincible = false;
                            }
                        }
                    } else if (p.beefChargeState === 'recovering') {
                        p.beefImpactDelay -= dt;
                        if (p.beefImpactDelay <= 0) {
                            p.beefChargeState = 'ready';
                            p.beefChargePlan = null;
                            p.beefChargeT = 0;
                            p.beefImpactDelay = 0;
                            p.isInvincible = false;
                        }
                    }
                } else {
                    let slowMultiplier = computeGeminiSlowMultiplier(p);
                    if (p.vibeThreadSlowTimer && p.vibeThreadSlowTimer > 0) {
                        p.vibeThreadSlowTimer = Math.max(0, p.vibeThreadSlowTimer - dt);
                        const vibeSlow = clamp(p.vibeThreadSlowStrength || 1, 0.15, 1);
                        slowMultiplier *= vibeSlow;
                        if (p.vibeThreadSlowTimer <= 0) {
                            p.vibeThreadSlowStrength = 1;
                        }
                    }
                    p.geminiSlowMultiplier = slowMultiplier;
                    // MOVEMENT LOGIC
                    if (document.body.classList.contains('mobile-controls-active')) {
                        // Joystick Movement
                        const moveSpeed = p.speed * slowMultiplier;
                        p.x += joystickState.input.x * moveSpeed * dt;
                        p.y += joystickState.input.y * moveSpeed * dt;
                        p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
                    } else {
                        const vx = mouse.x - p.x, vy = mouse.y - p.y;
                        const dist = Math.sqrt(vx * vx + vy * vy);
                        if (dist < 15) {
                            p.x = mouse.x;
                            p.y = mouse.y;
                        } else {
                            const accelFactor = 0.0125 * slowMultiplier;
                            p.x += vx * p.speed * dt * accelFactor;
                            p.y += vy * p.speed * dt * accelFactor;
                        }
                        p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
                    }
                }
                if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0) {
                    if (p.beefCharges < p.beefMaxCharges) {
                        if (p.beefChargeCooldown > 0) {
                            p.beefChargeCooldown = Math.max(0, p.beefChargeCooldown - dt);
                        }
                        if (p.beefChargeCooldown <= 0) {
                            p.beefCharges++;
                            if (p.beefCharges < p.beefMaxCharges) {
                                p.beefChargeCooldown = 8;
                            }
                        }
                    }

                    const shouldCharge = p.isRequestingCharge || !document.body.classList.contains('mobile-controls-active');

                    if (p.beefChargeState === 'ready' && p.beefCharges > 0 && shouldCharge) {
                        p.isRequestingCharge = false;
                        const chargeRadius = 120;
                        let closestEnemy = null;
                        let closestDistSq = chargeRadius * chargeRadius;
                        const potentialTargets = store.boss ? [...store.enemies, store.boss] : [...store.enemies];
                        potentialTargets.forEach(enemy => {
                            if (!enemy || enemy.dead || enemy.stunTimer > 0) return;
                            const dx = enemy.x - p.x;
                            const dy = enemy.y - p.y;
                            const distSq = dx * dx + dy * dy;
                            if (distSq < closestDistSq) {
                                closestDistSq = distSq;
                                closestEnemy = enemy;
                            }
                        });

                        if (closestEnemy) {
                            if (p.beefCharges === p.beefMaxCharges) {
                                p.beefChargeCooldown = 8;
                            }
                            p.beefCharges = Math.max(0, p.beefCharges - 1);

                            const plan = buildBeefChargePlan(p, closestEnemy, potentialTargets);
                            if (plan) {
                                plan.primaryEnemy = closestEnemy;
                                p.beefChargePlan = plan;
                                p.beefChargeSegmentIndex = 0;
                                p.beefChargeState = 'charging';
                                p.beefChargeT = 0;
                                p.beefImpactDelay = 0;
                                p.isInvincible = true;
                                p.beefLastImpact = null;

                                const firstSegment = plan.segments[0];
                                firstSegment.startX = p.x;
                                firstSegment.startY = p.y;
                                const firstTarget = getBeefChargeTargetPosition(firstSegment);
                                p.beefChargeOrigin = { x: p.x, y: p.y };
                                p.beefChargeTarget = { x: firstTarget.x, y: firstTarget.y };
                                spawnBeefChargeTrail(p.x, p.y, firstTarget.x, firstTarget.y, {
                                    subclass: p.subclass,
                                    segmentIndex: p.beefChargeSegmentIndex,
                                    segmentLabel: firstSegment.label,
                                    rangeOverride: plan.context.impactRadius
                                });

                                if ((p.beefDoubleCharge || (p.skillTree && p.skillTree.combo_charge)) && p.beefCharges > 0) {
                                    p.beefQueuedCharge = {
                                        delay: 0.4,
                                        fallback: { x: firstTarget.x, y: firstTarget.y },
                                        targetEnemy: closestEnemy
                                    };
                                } else {
                                    p.beefQueuedCharge = null;
                                }
                            } else {
                                p.beefChargeState = 'ready';
                                p.isInvincible = false;
                            }
                        }
                    } else if (p.beefChargeState !== 'ready') {
                        p.isRequestingCharge = false;
                    }

                    if (p.beefQueuedCharge) {
                        p.beefQueuedCharge.delay -= dt;
                        if (p.beefQueuedCharge.delay <= 0) {
                            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                                const potentialTargets = store.boss ? [...store.enemies, store.boss] : [...store.enemies];
                                let comboEnemy = p.beefQueuedCharge.targetEnemy;
                                if (!comboEnemy || comboEnemy.dead) {
                                    comboEnemy = findClosestEnemyInRange(p.beefQueuedCharge.fallback, potentialTargets, 180 * 180);
                                }
                                if (comboEnemy) {
                                    if (p.beefCharges === p.beefMaxCharges) {
                                        p.beefChargeCooldown = 8;
                                    }
                                    p.beefCharges = Math.max(0, p.beefCharges - 1);
                                    const comboPlan = buildBeefChargePlan(p, comboEnemy, potentialTargets);
                                    if (comboPlan) {
                                        comboPlan.primaryEnemy = comboEnemy;
                                        p.beefChargePlan = comboPlan;
                                        p.beefChargeSegmentIndex = 0;
                                        p.beefChargeState = 'charging';
                                        p.beefChargeT = 0;
                                        p.beefImpactDelay = 0;
                                        p.isInvincible = true;
                                        p.beefLastImpact = null;

                                        const firstSegment = comboPlan.segments[0];
                                        firstSegment.startX = p.x;
                                        firstSegment.startY = p.y;
                                        const firstTarget = getBeefChargeTargetPosition(firstSegment);
                                        p.beefChargeOrigin = { x: p.x, y: p.y };
                                        p.beefChargeTarget = { x: firstTarget.x, y: firstTarget.y };
                                        spawnBeefChargeTrail(p.x, p.y, firstTarget.x, firstTarget.y, {
                                            subclass: p.subclass,
                                            segmentIndex: p.beefChargeSegmentIndex,
                                            segmentLabel: firstSegment.label,
                                            rangeOverride: comboPlan.context ? comboPlan.context.impactRadius : undefined
                                        });
                                        p.beefQueuedCharge = null;
                                    }
                                }
                            }

                            if (p.beefQueuedCharge) {
                                p.beefQueuedCharge.delay = 0.08;
                            }
                        }
                    }
                } else if (p.pilotGenome === 'rocketman' && p.hasFirewall) {
                    // Rocketman Flame Pulse system
                    if (!p.flamePulseInitialized) {
                        const baseCooldown = p.firewallCooldown || 8; // 8 second cooldown
                        p.flamePulseCooldownMax = baseCooldown;
                        const immediateCast = Math.random() < 0.5;
                        p.flamePulseCooldown = immediateCast ? 0 : baseCooldown;
                        p.flamePulseCharge = immediateCast ? 1 : 0;
                        p.flamePulseInitialized = true;
                    }

                    const cooldownMax = p.flamePulseCooldownMax || 8;

                    if (p.flamePulseCooldown > 0) {
                        p.flamePulseCooldown = Math.max(0, p.flamePulseCooldown - dt);
                    }

                    const cooldownProgress = cooldownMax > 0 ? 1 - (p.flamePulseCooldown / cooldownMax) : 1;
                    p.flamePulseCharge = cooldownProgress;

                    // Release flame pulse when ready
                    if (p.flamePulseCooldown <= 0) {
                        // Create expanding fire ring
                        store.flamePulses.push({
                            x: p.x,
                            y: p.y,
                            radius: 20, // Start small
                            maxRadius: 200, // Expand to 200 pixels
                            speed: 250, // Expansion speed
                            life: 2.0, // Lasts 2 seconds
                            damage: 0.6, // Damage per frame
                            knockback: 300, // Knockback strength
                            dead: false
                        });
                        
                        p.flamePulseCooldown = cooldownMax;
                        p.flamePulseCharge = 0;
                        playSound('explosion'); // Sound effect
                    }
                } else if (p.pilotGenome === 'voidmancer') {
                    if (p.hasChainLightning || p.hasHybridVoid) {
                        p.chainLightningCooldown -= dt;
                        if (p.chainLightningCooldown <= 0) {
                            fireChainLightning();
                            // Set cooldown based on stormstriker level - more bolts = faster alternation
                            if (p.stormstrikerLevel >= 3) {
                                p.chainLightningCooldown = 0.375; // 4-bolt rotation: quadruple fire rate
                            } else if (p.stormstrikerLevel >= 2) {
                                p.chainLightningCooldown = 0.75; // Alternating bolts: double fire rate
                            } else {
                                p.chainLightningCooldown = 3.0; // Single bolt: slow powerful rate (half speed, 2.25x damage)
                            }
                        }
                    }

                    // Voidmancer base laser beam system
                    if (p.hasVoidLaser) {
                        stepVoidLaser(dt); // Regular seeking lasers for Phasestriker
                    }

                    // Wiper lasers work for both Phasestriker and Stormbringer
                    if (p.wiperLasers) {
                        stepWiperLasers(dt); // Ultimate ability for both subclasses
                    }
                }
                if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
                
                // Update escort drones
                if (store.escortDrones && store.escortDrones.length > 0) {
                    stepEscortDrones(dt);
                }
                
                if (p.hasBeefClone) {
                    if (store.beefClone && store.beefClone.mode === 'juggernaut_bomber') {
                        updateJuggernautClone(dt);
                    } else {
                        updateMirrorClone(dt);
                    }
                }
                if (p.timeShardTimer > 0) {
                    p.timeShardTimer = Math.max(0, p.timeShardTimer - dt);
                    if (p.timeShardTimer <= 0) {
                        p.timeShardStacks = 0;
                        p.timeShardMultiplier = 1;
                    }
                }
                p.fireT -= dt;
                const timeShardRate = p.timeShardMultiplier && p.timeShardMultiplier > 0 ? p.timeShardMultiplier : 1;
                if (p.fireT <= 0 && !p.empDisabled) { firePlayer(); p.fireT = p.fireRate * timeShardRate; }

                // Iceman has independent fire rate (level 2+: 50% faster)
                if (p.hasIceman && store.iceman && !p.empDisabled) {
                    // Ensure timer is initialized
                    if (typeof p.icemanFireT !== 'number' || isNaN(p.icemanFireT)) {
                        p.icemanFireT = 0;
                    }
                    
                    const icemanLevel = store.iceman.level || 1;
                    const icemanFireRate = icemanLevel >= 2 ? p.fireRate * 0.67 : p.fireRate; // 50% faster at level 2+
                    p.icemanFireT -= dt;
                    if (p.icemanFireT <= 0) {
                        fireIcemanShot();
                        p.icemanFireT = icemanFireRate * timeShardRate;
                    }
                } else if (p.hasIceman && !store.iceman) {
                    // Iceman missing error silenced
                } else if (p.hasIceman && p.empDisabled) {
                    // Iceman disabled by EMP
                }

                // Separate flamethrower system (unaffected by overclock)
                if (p.flamethrowerLevel > 0 && !p.empDisabled) {
                    p.flamethrowerT -= dt;
                    if (p.flamethrowerT <= 0) {
                        fireFlamethrower();
                        p.flamethrowerT = 0.18; // Fixed fire rate for lava blades
                    }
                }

                if (p.starCannonLevel > 0 && !p.empDisabled) {
                    p.starCannonTimer -= dt;
                    if (p.starCannonTimer <= 0) {
                        fireStarCannon();
                        p.starCannonTimer += getStarCannonCooldown(p.starCannonLevel);
                    }
                }

                // Homing Missile system (from powerup)
                if (p.powerupTimers['missile'] && !p.empDisabled) {
                    p.missileFireT -= dt;
                    if (p.missileFireT <= 0) {
                        p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                        let closest = null, closestDist = Infinity;
                        const playfieldMargin = 50;
                        const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                        potentialTargets.forEach(e => {
                            if (e.dead || e.hp <= 0 || e.y < 0) return;
                            // Don't target enemies outside playfield
                            if (e.x < -playfieldMargin || e.x > W + playfieldMargin || 
                                e.y < -playfieldMargin || e.y > H + playfieldMargin) return;
                            const dist = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                            if (dist < closestDist) { closest = e; closestDist = dist; }
                        });
                        if (closest) {
                            const isRocketman = p.pilotGenome === 'rocketman';
                            let baseMissileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                            let baseSpeed = 200;

                            // Apply stealth rocket upgrades
                            if (p.stealthRockets) {
                                baseMissileDmg *= (p.stealthRocketDamage || 1.25);
                                baseSpeed *= (p.stealthRocketSpeed || 1.5);
                            }

                            const volleySize = p.missileVolley || 2;

                            for (let i = 0; i < volleySize; i++) {
                                const spreadAngle = (i - (volleySize - 1) / 2) * 0.2;
                                const dx = closest.x - p.x;
                                const dy = closest.y - p.y;
                                const baseAngle = Math.atan2(dy, dx);
                                const finalAngle = baseAngle + spreadAngle;

                                const missile = {
                                    x: p.x, y: p.y - 10,
                                    vx: Math.cos(finalAngle) * baseSpeed,
                                    vy: Math.sin(finalAngle) * baseSpeed,
                                    speed: baseSpeed, turnRate: 4.5,
                                    target: closest, life: 0,
                                    dmg: baseMissileDmg,
                                    cluster: isRocketman && p.missileCluster,
                                    pierce: isRocketman ? (p.missilePierce || 0) : 0,
                                    isIceman: false,
                                    isStealth: p.stealthRockets || false,
                                    startX: p.x,
                                    startY: p.y - 10,
                                    travelDistance: 0
                                };
                                store.missiles.push(missile);
                            }
                        }
                    }
                }

                // Shield recharge system with damage delay
                if (p.shieldMax > 0 && p.shield < p.shieldMax) {
                    if (p.shieldRechargeDelay > 0) {
                        // Still in delay period, count down
                        p.shieldRechargeDelay -= dt;
                        p.shieldRecharging = false;
                    } else {
                        // Delay period over, start/continue recharging
                        p.shieldRecharging = true;
                        p.shield = Math.min(p.shieldMax, p.shield + (p.shieldMax / 6) * dt);
                    }
                } else {
                    p.shieldRecharging = false;
                }

                for (const key in p.powerupTimers) {
                    const timer = p.powerupTimers[key];
                    timer.remaining -= dt;
                    if (timer.remaining <= 0) {
                        if (key === 'drones') {
                            store.drones = [];
                        } else if (key === 'void_core') {
                            const prevDmgMult = p.voidCoreDmgMult || 1;
                            const prevFireRateMult = p.voidCoreFireRateMult || 1;
                            p.dmgMult = p.dmgMult / prevDmgMult;
                            p.fireRate = p.fireRate * prevFireRateMult;
                            p.voidCoreStacks = 0;
                            p.voidCoreDmgMult = 1;
                            p.voidCoreFireRateMult = 1;
                        } else if (key === 'split_shot') {
                            p.splitShotActive = false;
                        } else if (key === 'pierce_shot') {
                            if (p.piercingPowerupActive) {
                                p.piercing = Math.max(0, (p.piercing || 0) - (p.piercingPowerupBonus || 0));
                                p.piercingPowerupActive = false;
                                p.piercingPowerupBonus = 0;
                            }
                        }
                        delete p.powerupTimers[key];
                    }
                }
                if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
                if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { const isMini = p.miniAbilities && p.miniAbilities.has('gravity_well'); activateGravityWell(isMini ? 0.4 : 1.0); p.voidBeamCooldown = 30; } }
                if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { const isMini = p.miniAbilities && p.miniAbilities.has('lazarus_beam'); activateLazarus(isMini ? 0.5 : 1.0); p.lazarusBeamCooldown = 30 / (p.upgradeLevels.lazarus_beam > 0 ? 2 : 1); } }
                // Handle poison effects
                if (p.isPoisoned && performance.now() > p.poisonEndTime) {
                    p.isPoisoned = false;
                    p.moveSpeed = 100; // Reset to base speed
                }

                // Check poison puddle collisions
                if (store.poisonPuddles) {
                    store.poisonPuddles.forEach(puddle => {
                        const dx = p.x - puddle.x;
                        const dy = p.y - puddle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < puddle.r + p.r) {
                            // Player is in poison puddle - apply damage and effects
                            if (!p.lastPuddleDamageTime || performance.now() - p.lastPuddleDamageTime > 500) {
                                takeDamage(puddle.damage);
                                p.lastPuddleDamageTime = performance.now();

                                // Apply poison debuff
                                p.isPoisoned = true;
                                p.poisonEndTime = performance.now() + 3000; // 3 second poison from puddle
                                p.moveSpeed = Math.max(p.moveSpeed * 0.8, 60); // Slow player more
                            }
                        }
                    });
                }

                // Check mech oil/fuel puddle collisions
                if (store.mechPuddles && store.mechPuddles.length > 0) {
                    store.mechPuddles.forEach(puddle => {
                        // Calculate current radius with shrinking effect
                        const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
                        const currentRadius = puddle.r * Math.max(0.3, lifePercent);

                        const dx = p.x - puddle.x;
                        const dy = p.y - puddle.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < currentRadius + p.r) {
                            // Player is in hazardous puddle - apply damage and burning effect
                            if (!p.lastMechPuddleDamageTime || performance.now() - p.lastMechPuddleDamageTime > 400) {
                                // console.log('Player in mech puddle! Taking', puddle.damage, 'damage');
                                takeDamage(puddle.damage);
                                p.lastMechPuddleDamageTime = performance.now();

                                // Apply burning/slowing effect
                                p.isBurning = true;
                                p.burnEndTime = performance.now() + 2500; // 2.5 second burn effect

                                // Create burning particle effect
                                for (let i = 0; i < 3; i++) {
                                    store.flameParticles.push({
                                        x: p.x + (Math.random() - 0.5) * 30,
                                        y: p.y + (Math.random() - 0.5) * 30,
                                        vx: (Math.random() - 0.5) * 100,
                                        vy: -Math.random() * 150,
                                        life: 1 + Math.random() * 0.5,
                                        maxLife: 1 + Math.random() * 0.5,
                                        r: 3 + Math.random() * 4
                                    });
                                }
                            }
                        }
                    });
                }

                // Fragment Blaster auto-targeting system
                if (p.fragmentBlasters && p.fragmentBlasters.length > 0) {
                    stepFragmentBlasters(dt, p);
                }

                if (p.geminiHitSlowTimer && p.geminiHitSlowTimer > 0) {
                    p.geminiHitSlowTimer = Math.max(0, p.geminiHitSlowTimer - dt);
                    if (p.geminiHitSlowTimer <= 0) {
                        p.geminiHitSlowStrength = 1;
                    }
                }
            }
            function stepPowerups(dt) {
                const p = store.player;
                store.powerups.forEach(powerup => {
                    // Handle powerup movement (for Trap King falling powerups)
                    if (powerup.vx !== undefined || powerup.vy !== undefined) {
                        powerup.x += (powerup.vx || 0) * dt;
                        powerup.y += (powerup.vy || 0) * dt;

                        // Handle powerup lifetime
                        if (powerup.life !== undefined) {
                            powerup.life -= dt;
                            if (powerup.life <= 0) {
                                powerup.dead = true;
                                return;
                            }
                        }

                        // Remove powerups that go off screen
                        if (powerup.x < -20 || powerup.x > W + 20 || powerup.y < -20 || powerup.y > H + 20) {
                            powerup.dead = true;
                            return;
                        }
                    }

                    if (p.magnetRadius > 0) {
                        const dx = p.x - powerup.x;
                        const dy = p.y - powerup.y;
                        const distSq = dx * dx + dy * dy;
                        const dist = Math.sqrt(distSq);

                        // Auto-collect if very close to prevent vibration
                        if (dist < p.r + powerup.r + 5) {
                            powerup.dead = true;
                            if (powerup.type === 'upgrade' && powerup.upgradeTier) {
                                store.currentUpgradeTier = powerup.upgradeTier;
                            }
                            if (powerup.type === 'champion_upgrade') {
                                store.pendingChampionUpgrade = {
                                    variant: powerup.championVariant || 'minor',
                                    fallbackTier: powerup.fallbackTier || 'midTier',
                                    source: powerup.source || 'powerup'
                                };
                            }
                            applyPowerup(powerup.type, powerup.x, powerup.y);
                            return;
                        }

                        if (distSq < p.magnetRadius * p.magnetRadius) {
                            const pullSpeed = 350;
                            powerup.x += (dx / dist) * pullSpeed * dt;
                            powerup.y += (dy / dist) * pullSpeed * dt;
                        }
                    }

                    if (collide(p, powerup)) {
                        powerup.dead = true;
                        if (powerup.type === 'upgrade' && powerup.upgradeTier) {
                            store.currentUpgradeTier = powerup.upgradeTier;
                        }
                        if (powerup.type === 'champion_upgrade') {
                            store.pendingChampionUpgrade = {
                                variant: powerup.championVariant || 'minor',
                                fallbackTier: powerup.fallbackTier || 'midTier',
                                source: powerup.source || 'powerup'
                            };
                        }
                        applyPowerup(powerup.type, powerup.x, powerup.y);
                    }
                });
            }

            function detonateClusterRocket(m) {
                if (m.dead) return;
                m.dead = true;

                if (m.isStealth && !m.fireworkMini && !m.fireworkBurstTriggered) {
                    spawnRocketmanFireworkBurst({ x: m.x, y: m.y }, m);
                    m.fireworkBurstTriggered = true;
                }

                // Play cluster sound if this missile is marked for sound
                if (m.playSound) {
                    playSound('cluster');
                }
                // Play rocket hit sound on detonation
                playSound('rocketHit');

                const baseRadius = 70; // Halved from 80
                const explosionRadius = store.player.enhancedClusters ? 120 : baseRadius;
                const chainRadius = 90;
                const microExplosionCount = 5;
                let aoeDmg = m.dmg * .8;
                if (store.player.subclass === 'demolitioner') {
                    aoeDmg *= 1.5;  // OPTIONAL: Boost damage for demolitioner
                }
                for (let i = 0; i < microExplosionCount; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const dist = Math.random() * explosionRadius * 0.7;
                    const ex = m.x + Math.cos(angle) * dist;
                    const ey = m.y + Math.sin(angle) * dist;
                    store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
                }
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                targets.forEach(e => {
                    if (!e.dead) {
                        const distSq = (e.x - m.x) ** 2 + (e.y - m.y) ** 2;
                        if (distSq < explosionRadius ** 2) {
                            let pulseDmg = aoeDmg;
                            const explosionTags = store.player.subclass === 'demolitioner' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                            const vulnExplosion = applySubclassVulnerability(e, pulseDmg, {
                                subclass: store.player.subclass,
                                player: store.player,
                                damageTags: explosionTags,
                                source: 'clusterDetonation',
                                projectile: m,
                                baseDamage: pulseDmg
                            });
                            pulseDmg = vulnExplosion.damage;
                            e.hp -= pulseDmg;
                            e.hp = Math.max(1, e.hp);

                            // Apply vampirism healing for cluster damage
                            if (store.player.vampirism > 0) {
                                let healAmount = aoeDmg * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for AoE
                                healAmount = Math.min(healAmount, 2); // Cap at 2 HP for AoE
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                        }
                    }
                });
                // Remove chain detonation to prevent rockets from exploding each other
            }

            function spawnRocketmanFireworkBurst(origin, baseMissile, impactedEnemy) {
                const player = store.player;
                if (!player || player.pilotGenome !== 'rocketman' || !player.stealthRockets) {
                    return;
                }

                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                const liveTargets = potentialTargets.filter(target => !target.dead && target.hp > 0);
                const burstCount = 8; // Increased to 8 for 360-degree coverage
                if (burstCount <= 0) return;

                const baseSpeed = (baseMissile ? baseMissile.speed : 250) * 1.1;
                const baseDamage = (baseMissile ? baseMissile.dmg : 90 * player.dmgMult) * 0.45;
                
                // Calculate reference angle for knockback (direction the missile was traveling)
                const referenceAngle = baseMissile ? Math.atan2(baseMissile.vy, baseMissile.vx) : 0;
                
                // 360-degree spread instead of focused cone
                const fullCircle = Math.PI * 2;

                for (let i = 0; i < burstCount; i++) {
                    // Evenly distribute mini-rockets in 360 degrees
                    const angle = (i / burstCount) * fullCircle;
                    const launchSpeed = baseSpeed * (0.9 + Math.random() * 0.3);
                    let target = null;

                    if (liveTargets.length > 0) {
                        target = liveTargets[(i + Math.floor(Math.random() * liveTargets.length)) % liveTargets.length];
                    }

                    const miniRocket = {
                        x: origin.x,
                        y: origin.y,
                        vx: Math.cos(angle) * launchSpeed,
                        vy: Math.sin(angle) * launchSpeed,
                        speed: launchSpeed,
                        turnRate: 6.5,
                        target,
                        life: 0,
                        dmg: baseDamage * (0.85 + Math.random() * 0.3),
                        cluster: false,
                        pierce: 0,
                        isIceman: false,
                        isStealth: true,
                        fireworkMini: true,
                        maxLife: 1.8,
                        startX: origin.x,
                        startY: origin.y,
                        travelDistance: 0
                    };

                    store.missiles.push(miniRocket);
                }

                if (impactedEnemy && !impactedEnemy.dead) {
                    registerEnemyHit(impactedEnemy, {
                        angle: referenceAngle,
                        knockbackStrength: 35,
                        knockbackDuration: 0.05
                    });
                }

                store.activeEffects.push(createEffect('hitSpark', origin.x, origin.y, 28, { strength: 45 }));
            }

            function stepMissiles(dt) {
                store.missiles.forEach(m => {
                    if (m.chainDetonate && !m.dead) {
                        detonateClusterRocket(m);
                        return;
                    }
                    m.life += dt;
                    const maxLife = m.maxLife !== undefined ? m.maxLife : 6;
                    if (m.life > maxLife) { m.dead = true; return; }
                    
                    // Check if target is still valid and in playfield
                    const playfieldMargin = 50;
                    const targetOffScreen = m.target && (m.target.x < -playfieldMargin || m.target.x > W + playfieldMargin || 
                                                         m.target.y < -playfieldMargin || m.target.y > H + playfieldMargin);
                    if (targetOffScreen) {
                        m.target = null; // Lose target if it goes off screen
                    }
                    
                    if (m.target && !m.target.dead && m.target.hp > 0) {
                        const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 1) {
                            const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                            m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                        }
                    }
                    const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
                    if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }

                    // Track movement distance before updating position
                    const prevX = m.x, prevY = m.y;
                    m.x += m.vx * dt; m.y += m.vy * dt;

                    // Update travel distance if we have start position
                    if (m.startX !== undefined && m.startY !== undefined) {
                        m.travelDistance = Math.sqrt((m.x - m.startX) ** 2 + (m.y - m.startY) ** 2);
                    }

                    if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
                    const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;

                    // For cluster rockets, check proximity detonation only when they should explode
                    if (m.cluster && !m.pierce) {
                        // Original cluster behavior - explode near enemies
                        const proxRadiusSq = 15 * 15;
                        for (const e of targets) {
                            if (!e.dead && ((m.x - e.x) ** 2 + (m.y - e.y) ** 2 < proxRadiusSq)) {
                                detonateClusterRocket(m);
                                return;
                            }
                        }
                    }

                    // Handle collision with enemies
                    for (const e of targets) {
                        if (!e.dead && collide(m, e)) {
                            m.hits = (m.hits || 0) + 1;

                            if (m.cluster && m.pierce > 0) {
                                // Hybrid cluster + piercing: Deal damage, pierce, then set up for delayed explosion
                                let dmg = m.dmg;
                                if (e === store.boss) dmg *= 0.1;
                                if (Math.random() < store.player.critChance) {
                                    dmg *= store.player.critDamage;
                                    store.activeEffects.push(createEffect('critText', e.x, e.y));
                                    if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                                }
                                const missileTags = store.player.subclass === 'demolitioner' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                                const vulResPierce = applySubclassVulnerability(e, dmg, {
                                    subclass: store.player.subclass,
                                    player: store.player,
                                    damageTags: missileTags,
                                    source: 'pierceMissile',
                                    projectile: m,
                                    baseDamage: dmg
                                });
                                dmg = vulResPierce.damage;
                                e.hp -= dmg;

                                // Apply vampirism healing for missile damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = dmg * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 6); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }

                                explode(m.x, m.y, false, true);
                                m.pierce--;

                                if (m.pierce <= 0) {
                                    // No more pierces left - mark for delayed explosion
                                    m.shouldExplodeAfterTravel = true;
                                    m.minTravelTimeForExplosion = 0.5; // 0.5 seconds minimum travel time
                                    m.travelTimeAfterLastHit = 0;
                                } else {
                                    // Find next target for piercing
                                    let farthestTarget = null, maxDistSq = -1;
                                    targets.forEach(p_target => {
                                        if (p_target.dead || p_target === e) return;
                                        const distSq = (p_target.x - e.x) ** 2 + (p_target.y - e.y) ** 2;
                                        if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                                    });
                                    if (farthestTarget) {
                                        m.target = farthestTarget;
                                        const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                                    } else {
                                        // No more targets - explode immediately
                                        detonateClusterRocket(m);
                                    }
                                }
                            } else if (m.cluster) {
                                // Pure cluster rocket - explode immediately
                                detonateClusterRocket(m);
                            } else {
                                // Regular missile logic (non-cluster)
                                let dmg = m.dmg;
                                if (e === store.boss) dmg *= 0.1;
                                if (Math.random() < store.player.critChance) {
                                    dmg *= store.player.critDamage;
                                    store.activeEffects.push(createEffect('critText', e.x, e.y));
                                    if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                                }
                                const missileDamageTags = store.player.subclass === 'demolitioner' ? ['fire', 'explosive'] : ['kinetic', 'explosive'];
                                const vulRes = applySubclassVulnerability(e, dmg, {
                                    subclass: store.player.subclass,
                                    player: store.player,
                                    damageTags: missileDamageTags,
                                    source: m.cluster ? 'clusterMissile' : 'missileImpact',
                                    projectile: m,
                                    baseDamage: dmg
                                });
                                dmg = vulRes.damage;
                                e.hp -= dmg;

                                // Apply vampirism healing for missile damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = dmg * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }

                                explode(m.x, m.y, false, true);
                                if (m.isStealth && !m.fireworkMini && !m.fireworkBurstTriggered) {
                                    // Only trigger burst if no other rocket in this volley has triggered recently
                                    const now = performance.now();
                                    if (!store.lastFireworkBurstTime || (now - store.lastFireworkBurstTime) > 500) {
                                        spawnRocketmanFireworkBurst({ x: m.x, y: m.y }, m, e);
                                        m.fireworkBurstTriggered = true;
                                        store.lastFireworkBurstTime = now;
                                    }
                                }
                                if ((store.player.subclass === 'railgunner' || store.player.missilePierce > 0) && m.pierce > 0) {
                                    m.pierce--;
                                    let farthestTarget = null, maxDistSq = -1;
                                    targets.forEach(p_target => {
                                        if (p_target.dead || p_target === e) return;
                                        const distSq = (p_target.x - e.x) ** 2 + (p_target.y - e.y) ** 2;
                                        if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                                    });
                                    if (farthestTarget) {
                                        m.target = farthestTarget;
                                        const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                                    } else { m.dead = true; }
                                } else if (m.pierce > 0) {
                                    m.pierce--;
                                } else {
                                    m.dead = true;
                                }
                            }
                            if (m.dead) break;
                        }
                    }

                    // Handle delayed explosion for cluster + pierce missiles
                    if (m.shouldExplodeAfterTravel) {
                        m.travelTimeAfterLastHit += dt;
                        if (m.travelTimeAfterLastHit >= m.minTravelTimeForExplosion) {
                            // Check if we're near any enemies to explode
                            const explosionProximity = 60;
                            let shouldExplode = false;
                            for (const e of targets) {
                                if (!e.dead) {
                                    const distSq = (m.x - e.x) ** 2 + (m.y - e.y) ** 2;
                                    if (distSq < explosionProximity * explosionProximity) {
                                        shouldExplode = true;
                                        break;
                                    }
                                }
                            }
                            if (shouldExplode) {
                                detonateClusterRocket(m);
                            }
                        }
                    }
                });
            }

            function stepLightning(dt) {
                store.lightningBolts.forEach(bolt => {
                    bolt.life -= dt;
                    if (bolt.life <= 0) { bolt.dead = true; }
                });
            }
            
            function stepHunterLightningChains(dt) {
                // Update lightning chains between Azure Strikers
                store.hunterLightningChains.forEach(chain => {
                    chain.life -= dt;
                    if (chain.life <= 0) {
                        chain.dead = true;
                        return;
                    }
                    
                    // Check if player collides with the lightning chain
                    const p = store.player;
                    if (p.isInvincible) return;
                    
                    // Calculate closest point on line segment to player
                    const dx = chain.x2 - chain.x1;
                    const dy = chain.y2 - chain.y1;
                    const lengthSq = dx * dx + dy * dy;
                    
                    if (lengthSq < 1) return; // Degenerate chain
                    
                    const t = Math.max(0, Math.min(1, 
                        ((p.x - chain.x1) * dx + (p.y - chain.y1) * dy) / lengthSq
                    ));
                    
                    const closestX = chain.x1 + t * dx;
                    const closestY = chain.y1 + t * dy;
                    
                    const distX = p.x - closestX;
                    const distY = p.y - closestY;
                    const distSq = distX * distX + distY * distY;
                    
                    const hitRadius = p.r + 8; // Lightning chain thickness
                    if (distSq < hitRadius * hitRadius) {
                        // Player hit by lightning!
                        if (!chain.hasHitPlayer) {
                            hurtPlayer(chain.damage);
                            chain.hasHitPlayer = true; // Only hit once per chain
                            
                            // Visual feedback
                            store.activeEffects.push(createEffect('stormDischarge', p.x, p.y, 20));
                        }
                    }
                });
                
                // Clean up dead chains
                store.hunterLightningChains = store.hunterLightningChains.filter(c => !c.dead);
            }

            function stepFlamePulses(dt) {
                store.flamePulses.forEach(pulse => {
                    // Expand the pulse
                    pulse.radius += pulse.speed * dt;
                    if (pulse.radius > pulse.maxRadius) {
                        pulse.radius = pulse.maxRadius;
                    }

                    // Countdown life
                    pulse.life -= dt;
                    if (pulse.life <= 0) {
                        pulse.dead = true;
                        return;
                    }

                    // Damage and knockback enemies in the expanding ring
                    const ringThickness = 30; // Width of the damage ring
                    store.enemies.forEach(enemy => {
                        if (enemy.dead) return;
                        
                        const dx = enemy.x - pulse.x;
                        const dy = enemy.y - pulse.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check if enemy is within the ring thickness
                        if (dist >= pulse.radius - ringThickness && dist <= pulse.radius + ringThickness) {
                            // Damage enemy
                            enemy.hp -= pulse.damage;
                            if (enemy.hp <= 0) {
                                enemy.dead = true;
                            }
                            
                            // Knockback effect
                            const knockbackAngle = Math.atan2(dy, dx);
                            enemy.x += Math.cos(knockbackAngle) * pulse.knockback * dt;
                            enemy.y += Math.sin(knockbackAngle) * pulse.knockback * dt;
                        }
                    });

                    // Also affect boss
                    if (store.boss && !store.boss.dead) {
                        const dx = store.boss.x - pulse.x;
                        const dy = store.boss.y - pulse.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist >= pulse.radius - ringThickness && dist <= pulse.radius + ringThickness) {
                            store.boss.hp -= pulse.damage * 0.5; // Reduced damage to boss
                            
                            // Knockback (bosses resist more)
                            const knockbackAngle = Math.atan2(dy, dx);
                            store.boss.x += Math.cos(knockbackAngle) * pulse.knockback * 0.3 * dt;
                            store.boss.y += Math.sin(knockbackAngle) * pulse.knockback * 0.3 * dt;
                        }
                    }

                    // Spawn fire particles along the ring edge for visual effect
                    if (Math.random() < 0.3) {
                        const angle = Math.random() * Math.PI * 2;
                        const px = pulse.x + Math.cos(angle) * pulse.radius;
                        const py = pulse.y + Math.sin(angle) * pulse.radius;
                        
                        const particle = new FlameParticle(px, py, null, 0);
                        particle.vx = Math.cos(angle) * 30;
                        particle.vy = Math.sin(angle) * 30;
                        particle.life *= 0.3;
                        particle.maxLife *= 0.3;
                        particle.visualLife *= 0.3;
                        particle.maxVisualLife *= 0.3;
                        particle.isFlamethrowerParticle = false; // Use standard physics
                        store.flameParticles.push(particle);
                    }
                });
            }

            function stepEmpNovas(dt) {
                store.empNovas.forEach(nova => {
                    // Expand the nova
                    nova.radius += nova.speed * dt;
                    if (nova.radius > nova.maxRadius) {
                        nova.radius = nova.maxRadius;
                    }

                    // Countdown life
                    nova.life -= dt;
                    if (nova.life <= 0) {
                        nova.dead = true;
                        return;
                    }

                    // Check if player is within EMP range
                    const dx = store.player.x - nova.x;
                    const dy = store.player.y - nova.y;
                    const distSq = dx * dx + dy * dy;
                    const radiusSq = nova.radius * nova.radius;

                    if (distSq <= radiusSq) {
                        // Player is within EMP range - disable weapons
                        store.player.empDisabled = true;
                        store.player.empDisabledTimer = 0.5; // Sizzle effect duration
                    }
                });

                // Update player EMP disabled state
                if (store.player.empDisabledTimer > 0) {
                    store.player.empDisabledTimer -= dt;
                    if (store.player.empDisabledTimer <= 0) {
                        store.player.empDisabled = false;
                    }
                }
            }

            function stepLasers(dt) {
                store.lasers.forEach(laser => {
                    laser.life -= dt;
                    if (laser.life <= 0) { laser.dead = true; return; }
                    laser.prevX = laser.x; laser.prevY = laser.y;
                    laser.x += laser.vx * dt; laser.y += laser.vy * dt;
                    if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                        const speed = Math.sqrt(laser.vx ** 2 + laser.vy ** 2);
                        let newAngle;
                        if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                        else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                        else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                        else { newAngle = Math.PI + Math.random() * Math.PI; }
                        laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                        laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                        laser.hitEnemies.clear();
                    }
                    store.enemies.forEach(e => {
                        if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) {
                            const laserDmg = 1000 * store.player.dmgMult;
                            e.hp -= laserDmg;
                            laser.hitEnemies.add(e);

                            registerEnemyHit(e, {
                                angle: Math.atan2(e.y - laser.y, e.x - laser.x),
                                knockbackStrength: 90,
                                knockbackDuration: 0.08
                            });

                            // Track damage dealt for beef shield system
                            if (store.player.pilotGenome === 'beef') {
                                store.player.beefShieldDamageDealt += laserDmg;
                            }

                            // Apply vampirism healing for laser damage
                            if (store.player.vampirism > 0) {
                                let healAmount = laserDmg * store.player.vampirism;
                                healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                                healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                        }
                    });
                    if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) {
                        const bossLaserDmg = 500 * store.player.dmgMult;
                        const result = applyBossDamage(store.boss, bossLaserDmg, { point: { x: laser.x, y: laser.y } });
                        laser.hitEnemies.add(store.boss);

                        if (result.amount > 0 && !result.blocked && store.boss) {
                            registerEnemyHit(store.boss, {
                                angle: Math.atan2(store.boss.y - laser.y, store.boss.x - laser.x),
                                knockbackStrength: 70,
                                knockbackDuration: 0.08
                            });
                        }

                        if (store.player.pilotGenome === 'beef') {
                            store.player.beefShieldDamageDealt += result.amount;
                        }

                        if (store.player.vampirism > 0 && result.amount > 0) {
                            let healAmount = result.amount * store.player.vampirism;
                            healAmount = Math.max(healAmount, 2);
                            healAmount = Math.min(healAmount, 10);
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                    }
                });
            }

            function stepMines(dt) {
                store.mines.forEach(mine => {
                    if (mine.dead) return;
                    mine.fuse -= dt;
                    let detonate = mine.fuse <= 0;
                    if (!detonate) {
                        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                        for (const target of targets) { if (!target.dead && collide(mine, target)) { detonate = true; break; } }
                    }
                    if (detonate) { mine.dead = true; explodeMine(mine); }
                });
            }

            function stepFlameParticles(dt) {
                const activeCache = store._activeFlamesCache || (store._activeFlamesCache = []);
                activeCache.length = 0;

                for (let i = store.flameParticles.length - 1; i >= 0; i--) {
                    const p = store.flameParticles[i];
                    let alive = true;
                    if (p.attachedEnemy) {
                        if (p.attachedEnemy.dead) {
                            p.attachedEnemy = null;
                        } else {
                            p.x = p.attachedEnemy.x;
                            p.y = p.attachedEnemy.y;
                            let appliedDamage = p.damage;
                            if (p.attachedEnemy === store.boss) {
                                const result = applyBossDamage(p.attachedEnemy, p.damage, {
                                    point: { x: p.attachedEnemy.x, y: p.attachedEnemy.y },
                                    skipShield: true
                                });
                                appliedDamage = result.amount;
                            } else {
                                p.attachedEnemy.hp -= appliedDamage;
                            }

                            // Apply vampirism healing for attached flame damage
                            if (appliedDamage > 0 && store.player.vampirism > 0) {
                                let healAmount = appliedDamage * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.2); // Minimum 0.2 HP
                                healAmount = Math.min(healAmount, 1); // Cap at 1 HP
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }

                            if (appliedDamage > 0) {
                                p.attachedEnemy.slowTimer = 2.0;
                            }
                        }
                    }
                    if (p.update && !p.update(dt)) {
                        store.flameParticles.splice(i, 1);
                        alive = false;
                    } else if (!p.update) {
                        // Handle legacy flame particles without update function
                        if (p.vx !== undefined) {
                            p.x += p.vx * dt;
                            p.y += p.vy * dt;
                        }
                        p.life -= dt;
                        if (p.life <= 0) {
                            store.flameParticles.splice(i, 1);
                            alive = false;
                        }
                    }

                    if (alive) {
                        activeCache.push(p);
                    }
                }
            }




            const EMPTY_FLAME_CACHE = Object.freeze([]);

            function getHivePuddleLifetime(base, variance, options = {}) {
                const { min = 4, waveBonusPer = 0.35, maxWaveBonus = 5 } = options;
                const wave = (store && store.world && typeof store.world.wave === 'number') ? store.world.wave : 1;
                const waveBonus = Math.min(Math.max(wave - 1, 0) * waveBonusPer, maxWaveBonus);
                const randomized = variance > 0 ? Math.random() * variance : 0;
                return Math.max(min, base + randomized + waveBonus);
            }

            const GOLDEN_ORB_CONFIG = Object.freeze({
                radius: 22,
                pickupRadius: 30,
                floatAmplitude: 12,
                floatSpeed: 2.4,
                homingSpeed: 430,
                homingAcceleration: 6.5,
                maxTrail: 16,
                trailLife: 0.32
            });

            function spawnGoldenSentinelOrbs(count = 3) {
                if (!store || !store.player) return;
                if (!store.goldenOrbs) store.goldenOrbs = [];

                const spawnPositions = [
                    {
                        x: clamp(W * 0.23, 80, W - 80),
                        y: clamp(H - 170, 120, H - 110)
                    },
                    {
                        x: clamp(W * 0.5, 80, W - 80),
                        y: clamp(H - 135, 120, H - 105)
                    },
                    {
                        x: clamp(W * 0.77, 80, W - 80),
                        y: clamp(H - 190, 120, H - 115)
                    }
                ];

                for (let i = 0; i < Math.min(count, spawnPositions.length); i++) {
                    const pos = spawnPositions[i];
                    const orb = {
                        x: pos.x,
                        y: pos.y,
                        baseY: pos.y,
                        r: GOLDEN_ORB_CONFIG.radius,
                        pickupRadius: GOLDEN_ORB_CONFIG.pickupRadius,
                        state: 'idle',
                        floatPhase: Math.random() * Math.PI * 2,
                        floatSpeed: GOLDEN_ORB_CONFIG.floatSpeed * (0.85 + Math.random() * 0.3),
                        floatAmplitude: GOLDEN_ORB_CONFIG.floatAmplitude * (0.85 + Math.random() * 0.25),
                        pulseOffset: Math.random() * Math.PI * 2,
                        created: performance.now(),
                        trail: [],
                        speed: GOLDEN_ORB_CONFIG.homingSpeed
                    };
                    store.goldenOrbs.push(orb);
                    store.activeEffects.push(createEffect('goldenOrbSpawn', orb.x, orb.y, orb.r * 2.2));
                }
            }

            function stepGoldenOrbs(dt) {
                const orbs = store.goldenOrbs;
                if (!orbs || orbs.length === 0) {
                    return;
                }

                if (!store.boss) {
                    orbs.length = 0;
                    return;
                }

                const player = store.player;
                for (let i = orbs.length - 1; i >= 0; i--) {
                    const orb = orbs[i];
                    orb.floatPhase += orb.floatSpeed * dt;

                    if (orb.state === 'idle') {
                        orb.y = orb.baseY + Math.sin(orb.floatPhase) * orb.floatAmplitude;
                        const dx = player.x - orb.x;
                        const dy = player.y - orb.y;
                        if ((dx * dx + dy * dy) <= orb.pickupRadius * orb.pickupRadius) {
                            orb.state = 'homing';
                            orb.vx = 0;
                            orb.vy = 0;
                            orb.trail.length = 0;
                            orb.heading = -Math.PI / 2;
                            playSound('stargun');
                        }
                    } else if (orb.state === 'homing') {
                        const boss = store.boss;
                        if (!boss) {
                            orbs.splice(i, 1);
                            continue;
                        }

                        const dx = boss.x - orb.x;
                        const dy = boss.y - orb.y;
                        const dist = Math.max(0.001, Math.hypot(dx, dy));
                        const desiredVx = (dx / dist) * orb.speed;
                        const desiredVy = (dy / dist) * orb.speed;
                        const accel = GOLDEN_ORB_CONFIG.homingAcceleration;
                        orb.vx = (orb.vx || 0) + (desiredVx - (orb.vx || 0)) * Math.min(1, accel * dt);
                        orb.vy = (orb.vy || 0) + (desiredVy - (orb.vy || 0)) * Math.min(1, accel * dt);
                        orb.x += orb.vx * dt;
                        orb.y += orb.vy * dt;
                        orb.heading = Math.atan2(orb.vy, orb.vx);

                        if (!orb.trail) orb.trail = [];
                        orb.trail.unshift({ x: orb.x, y: orb.y, life: GOLDEN_ORB_CONFIG.trailLife });
                        if (orb.trail.length > GOLDEN_ORB_CONFIG.maxTrail) {
                            orb.trail.pop();
                        }
                        for (let t = orb.trail.length - 1; t >= 0; t--) {
                            orb.trail[t].life -= dt;
                            if (orb.trail[t].life <= 0) {
                                orb.trail.splice(t, 1);
                            }
                        }

                        if (dist <= (boss.r || 70) + 12) {
                            const damage = boss.hpMax * 0.2;
                            const result = applyBossDamage(boss, damage, { point: { x: orb.x, y: orb.y } });
                            store.activeEffects.push(createEffect('goldenOrbDetonation', orb.x, orb.y, 140));
                            playSound('explosion');
                            orbs.splice(i, 1);
                            if (boss.hp <= 0) {
                                return;
                            }
                        }
                    }
                }
            }

            function stepWorld(dt) {
                stepPlayer(dt);
                if (store.boss) {
                    stepBoss(dt);
                }

                // Check for bullet element toggle orb hover
                if (store.bulletToggleOrbs && store.player) {
                    const playerX = store.player.x;
                    const playerY = store.player.y;
                    const hoverMargin = 15;
                    const toggleDelay = 0.45;
                    if (!store.bulletToggleHoverTimers) {
                        store.bulletToggleHoverTimers = { ice: 0, poison: 0, fire: 0 };
                    }
                    const timers = store.bulletToggleHoverTimers;
                    for (const orb of store.bulletToggleOrbs) {
                        if (!orb || !orb.element) continue;
                        const key = orb.element;
                        if (!orb.active) {
                            timers[key] = 0;
                            continue;
                        }
                        const dx = playerX - orb.x;
                        const dy = playerY - orb.y;
                        const distToOrb = Math.hypot(dx, dy);
                        if (distToOrb <= orb.radius + hoverMargin) {
                            timers[key] = Math.min(timers[key] + dt, toggleDelay + 0.3);
                            if (timers[key] >= toggleDelay) {
                                toggleBulletElement(store.player, key);
                                playSound('stargun');
                                timers[key] = -0.35; // brief cooldown before another toggle
                            }
                        } else {
                            if (timers[key] > 0) {
                                timers[key] = Math.max(0, timers[key] - dt * 2);
                            } else if (timers[key] < 0) {
                                timers[key] = Math.min(0, timers[key] + dt);
                            }
                        }
                    }
                } else if (store.bulletToggleHoverTimers) {
                    store.bulletToggleHoverTimers.ice = 0;
                    store.bulletToggleHoverTimers.poison = 0;
                    store.bulletToggleHoverTimers.fire = 0;
                }

                stepPowerups(dt);
                if (CHAMPION_SYSTEM_ENABLED) {
                    stepPlayerChampion(dt);
                    stepChampionMinions(dt);
                }
                stepEmpCharges(dt);
                stepKnockbackShieldCharges(dt);
                stepHounds(dt);
                stepShadowHounds(dt);
                stepVoidRifts(dt);
                updateGibs(dt);
                updateHitParticles(dt);
                updateFloatingTexts(dt);

                stepMissiles(dt);
                stepJuggernautBombs(dt);
                stepLasers(dt);
                stepMines(dt);
                stepFlameParticles(dt);
                updateShadowEchoes(dt);
                updateTemporalEchoes(dt);
                updateTimeShards(dt);
                stepLightning(dt);
                stepHunterLightningChains(dt);
                stepEmpNovas(dt);
                stepFlamePulses(dt);
                cleanupDeadGangMembers();
                processWaveSpawnQueue(dt);
                processVulnerabilityEvents(dt);

                if (store.world.cubeBurglarCooldown > 0) {
                    store.world.cubeBurglarCooldown = Math.max(0, store.world.cubeBurglarCooldown - dt);
                }
                if (store.world.cubeBurglarActive) {
                    const activeBurglar = getCubeBurglarActiveEnemy();
                    if (!activeBurglar) {
                        store.world.cubeBurglarActive = false;
                        store.cubeBurglarId = null;
                        store.world.cubeBurglarSpawnAttempts = 0;
                        store.world.cubeBurglarLastAttemptTime = 0;
                    }
                } else if (store.world.wave >= CUBE_BURGLAR_CONFIG.minWave && store.world.cubeBurglarCooldown <= 0) {
                    store.world.cubeBurglarSpawnTimer = (store.world.cubeBurglarSpawnTimer || 0) + dt;
                    if (store.world.cubeBurglarSpawnTimer >= CUBE_BURGLAR_CONFIG.passiveSpawnInterval) {
                        const threatScale = Math.max(0.6, store.world.lastThreatScale || 1);
                        const lateGameScaling = Math.max(0.8, store.world.lateGameDamageScaling || 1);
                        const spawn = trySpawnCubeBurglar({
                            hpScale: Math.min(2.6, threatScale * 1.1),
                            lateGameScaling,
                            damageMult: Math.min(2.1, threatScale * 0.9)
                        });
                        if (spawn) {
                            store.world.cubeBurglarSpawnTimer = 0;
                        } else {
                            store.world.cubeBurglarSpawnTimer = Math.max(0, store.world.cubeBurglarSpawnTimer - CUBE_BURGLAR_CONFIG.passiveSpawnInterval * 0.5);
                        }
                    }
                } else {
                    store.world.cubeBurglarSpawnTimer = 0;
                }

                if (store.world.pendingVoidReaper) {
                    store.world.pendingVoidReaper.timer -= dt;
                    const plan = store.world.pendingVoidReaper;
                    if (!store.world.voidReaperWarningIssued && plan.timer <= 2.4) {
                        store.world.voidReaperWarningIssued = true;
                        announce('ðŸ“¡ [Encrypted Relay] "A pair of anomalies traveling at an infeasible rate was detected..."');
                        // Thunder sound removed - only for Stormbringer
                    }
                    if (plan.timer <= 0) {
                        const spawned = spawnVoidReaper({
                            hpScale: plan.hpScale,
                            damageMult: plan.damageMult,
                            lateGameScaling: plan.lateGameScaling
                        });
                        if (spawned) {
                            store.world.pendingVoidReaper = null;
                            store.world.voidReaperWarningIssued = false;
                        } else {
                            // Retry slightly later if spawn failed
                            plan.timer = 1.5;
                        }
                    }
                }

                // Update beef shield system
                updateBeefShield();

                // Update mech oil/fuel puddles
                for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
                    const puddle = store.mechPuddles[i];
                    puddle.life -= dt;
                    if (puddle.life <= 0) {
                        store.mechPuddles.splice(i, 1);
                    }
                }
                
                // Update tombstones
                if (!store.tombstones) store.tombstones = [];
                for (let i = store.tombstones.length - 1; i >= 0; i--) {
                    const tomb = store.tombstones[i];
                    if (tomb.dead || tomb.hp <= 0) {
                        store.tombstones.splice(i, 1);
                        continue;
                    }
                    
                    tomb.spawnTimer += dt;
                    if (tomb.spawnTimer >= tomb.spawnInterval) {
                        tomb.spawnTimer = 0;
                        const zombie = spawnEnemy('zombie', {
                            x: tomb.x + (Math.random() - 0.5) * 60,
                            y: tomb.y + (Math.random() - 0.5) * 60
                        });
                        if (zombie) {
                            store.enemies.push(zombie);
                        }
                    }
                }

                updateVoidStepSystems(store.enemies);
                updateImpactSystem();
                runAutoForge(dt);
                stepGoldenOrbs(dt);
                stepGeminiSlowFields(dt);

                store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
                if (store.world.powerupCooldown > 0) {
                    store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2));
                }

                let base = store.world.wave < 200 ? 1.065 : 1.04;
                // BETTER BALANCE: Even more gentle scaling
                let dmgScale;
                if (store.world.wave <= 10) {
                    // Very gentle exponential growth for early game
                    dmgScale = Math.pow(1.03, store.world.wave - 1); // Reduced from 1.05 to 1.03
                } else {
                    // Minimal linear scaling after wave 10
                    const wave10Scale = Math.pow(1.03, 9); // ~1.3x at wave 10
                    const veryGentleGrowth = (store.world.wave - 10) * 0.02; // Only +2% per wave after 10
                    dmgScale = wave10Scale * (1 + veryGentleGrowth);
                }
                // Apply collar bonus and late-game scaling to enemy damage
                const collarBonus = calculateCollarBonus(sanitizeCollarStacks()); // Diminishing scaling per collar stack
                const lateGameBonus = store.world.lateGameDamageScaling || 1;
                dmgScale *= collarBonus * lateGameBonus;
                // console.log(`Wave ${store.world.wave}: Damage scale = ${dmgScale.toFixed(2)} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x | LateGameBonus: ${lateGameBonus.toFixed(2)}x`);
                const player = store.player;
                let autoBlinkTriggeredThisFrame = false;

                store.eBullets.forEach(b => {
                    if (b.path === 'aegis_spiral') {
                        const amplitude = ensureFiniteNumber(b.amplitude, 120);
                        const frequency = ensureFiniteNumber(b.frequency, 2.9);
                        const fallSpeed = ensureFiniteNumber(b.fallSpeed, 165);
                        const baseX = b.baseX !== undefined ? b.baseX : (b.baseX = b.x);
                        const phaseOffset = ensureFiniteNumber(b.phaseOffset, 0);
                        b.t = (b.t || 0) + dt;
                        const sway = Math.sin(b.t * frequency + phaseOffset) * amplitude;
                        b.x = baseX + sway;
                        b.y += fallSpeed * dt;
                        if (b.life !== undefined) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                        if (b.baseRadius === undefined) {
                            b.baseRadius = b.r || 5.5;
                        }
                        if (!b.dead && b.pulseOffset !== undefined) {
                            const pulseScale = 1 + Math.sin(performance.now() / 220 + b.pulseOffset) * 0.12;
                            b.r = b.baseRadius * pulseScale;
                        }
                    } else if (b.path === 'aegis_gravity') {
                        const target = store.player;
                        const homingStrength = ensureFiniteNumber(b.homingStrength, 110);
                        const maxSpeed = ensureFiniteNumber(b.maxSpeed, 260);
                        const vx = ensureFiniteNumber(b.vx, 0);
                        const vy = ensureFiniteNumber(b.vy, 0);
                        const angleToPlayer = Math.atan2((target.y ?? b.y) - b.y, (target.x ?? b.x) - b.x);
                        const accelX = Math.cos(angleToPlayer) * homingStrength * dt;
                        const accelY = Math.sin(angleToPlayer) * homingStrength * dt;
                        let nextVx = vx + accelX;
                        let nextVy = vy + accelY;
                        const speed = Math.hypot(nextVx, nextVy) || 0;
                        if (speed > maxSpeed) {
                            const scale = maxSpeed / speed;
                            nextVx *= scale;
                            nextVy *= scale;
                        }
                        b.vx = nextVx;
                        b.vy = nextVy;
                        b.x += nextVx * dt;
                        b.y += nextVy * dt;
                        if (b.life) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                        if (b.pulseOffset !== undefined) {
                            b.rBase = b.rBase || b.r || 8;
                            const pulseScale = 1 + Math.sin(performance.now() / 200 + b.pulseOffset) * 0.1;
                            b.r = b.rBase * pulseScale;
                        }
                    } else if (b.path === 'vibemaster_bloop') {
                        const target = store.player;
                        const homingStrength = ensureFiniteNumber(b.homingStrength, 95);
                        const maxSpeed = ensureFiniteNumber(b.maxSpeed, 230);
                        const currentVx = ensureFiniteNumber(b.vx, 0);
                        const currentVy = ensureFiniteNumber(b.vy, 0);
                        let nextVx = currentVx;
                        let nextVy = currentVy;
                        if (target) {
                            const angle = Math.atan2(target.y - b.y, target.x - b.x);
                            nextVx += Math.cos(angle) * homingStrength * dt;
                            nextVy += Math.sin(angle) * homingStrength * dt;
                            const speed = Math.hypot(nextVx, nextVy) || 0;
                            if (speed > maxSpeed) {
                                const scale = maxSpeed / speed;
                                nextVx *= scale;
                                nextVy *= scale;
                            }
                        }
                        b.vx = nextVx;
                        b.vy = nextVy;
                        b.x += nextVx * dt;
                        b.y += nextVy * dt;
                        if (b.life !== undefined) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                        if (b.rBase === undefined) {
                            b.rBase = b.r || 6;
                        }
                        const shimmer = 1 + Math.sin((performance.now() + (b.pulseOffset || 0)) / 180) * 0.12;
                        b.r = b.rBase * shimmer;
                    } else if (b.path === 'vibemaster_shard') {
                        const accel = Math.max(0, ensureFiniteNumber(b.accel, 220));
                        const maxSpeed = ensureFiniteNumber(b.maxSpeed, 520);
                        let vx = ensureFiniteNumber(b.vx, 0);
                        let vy = ensureFiniteNumber(b.vy, 0);
                        const speed = Math.hypot(vx, vy);
                        if (speed > 0.001) {
                            const nx = vx / speed;
                            const ny = vy / speed;
                            const nextSpeed = Math.min(maxSpeed, speed + accel * dt);
                            vx = nx * nextSpeed;
                            vy = ny * nextSpeed;
                        }
                        b.vx = vx;
                        b.vy = vy;
                        b.x += vx * dt;
                        b.y += vy * dt;
                        if (b.life !== undefined) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                    } else if (b.path === 'vibemaster_guardian_beam') {
                        b.x += ensureFiniteNumber(b.vx, 0) * dt;
                        b.y += ensureFiniteNumber(b.vy, 0) * dt;
                        if (b.life !== undefined) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                        if (b.fadeRate !== undefined) {
                            b.alpha = Math.max(0, (b.alpha ?? 1) - b.fadeRate * dt);
                        }
                    } else if (b.path === 'vibemaster_implosion') {
                        const grow = Math.max(0, ensureFiniteNumber(b.growSpeed, 18));
                        const driftVx = ensureFiniteNumber(b.vx, 0);
                        const driftVy = ensureFiniteNumber(b.vy, 65);
                        b.vx = driftVx;
                        b.vy = driftVy;
                        b.x += driftVx * dt;
                        b.y += driftVy * dt;
                        b.r = Math.min(140, (b.r || 26) + grow * dt * 0.6);
                        b.coreRadius = (b.coreRadius || (b.r * 0.55)) + grow * dt * 0.35;
                        if (b.life !== undefined) {
                            b.life -= dt;
                            if (b.life <= 0) b.dead = true;
                        }
                    } else {
                        b.x += b.vx * dt;
                        b.y += b.vy * dt;
                        if (b.gravity) { b.vy += b.gravity * dt; }
                        if (b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
                    }

                    // Check if poison blob hits ground
                    if (b.type === 'poisonBlob' && b.y > H - 30) {
                        // Create poison puddle on ground impact
                        if (!store.poisonPuddles) store.poisonPuddles = [];
                        store.poisonPuddles.push({
                            x: b.x,
                            y: H - 20,
                            r: 20 + Math.random() * 10,
                            life: getHivePuddleLifetime(5.5, 4.5, { min: 4.5, maxWaveBonus: 5.5 }),
                            damage: (b.dmg || 15) * 0.5,
                            created: performance.now()
                        });
                        b.dead = true;
                    }

                    // Check if mech volley hits ground or reaches target area - create puddle
                    if (b.isMechVolley && (b.y >= b.targetY - 10 || b.y > H - 30)) {
                        // Use intended target location for puddle placement
                        const puddleX = b.targetX;
                        const puddleY = b.targetY;

                        // console.log('Mech volley landed! Creating puddle at target:', puddleX, puddleY);
                        store.mechPuddles.push({
                            x: puddleX,
                            y: puddleY,
                            r: 10, // Much smaller puddles (half of 20)
                            maxR: 10, // Store original size for shrinking effect
                            life: 1.5, // Reduced to 1.5 seconds
                            maxLife: 1.5, // Store original life for shrinking calculation
                            damage: (b.dmg || 18) * 0.4, // 40% of original damage per tick
                            sourceId: b.sourceId, // Track which mech created this puddle
                            created: performance.now(),
                            pulseOffset: Math.random() * Math.PI * 2, // For animation
                            hp: 15, // Make puddles killable with small HP
                            hpMax: 15 // Store max HP
                        });
                        b.dead = true;
                    }

                    if (!autoBlinkTriggeredThisFrame && !b.dead) {
                        if (attemptAutoBlink(player, b)) {
                            autoBlinkTriggeredThisFrame = true;
                        }
                    }

                    if (b.geminiTag === 'sol_fire' && b.homeDuration !== undefined && b.homeDuration > 0) {
                        const target = player;
                        if (target) {
                            b.homeDuration = Math.max(0, b.homeDuration - dt);
                            const speed = Math.hypot(b.vx, b.vy) || 0.0001;
                            const angle = Math.atan2(target.y - b.y, target.x - b.x);
                            const desiredVx = Math.cos(angle) * speed;
                            const desiredVy = Math.sin(angle) * speed;
                            const turnRate = clamp((b.homeStrength || 150) * dt / Math.max(speed, 60), 0, 0.25);
                            b.vx += (desiredVx - b.vx) * turnRate;
                            b.vy += (desiredVy - b.vy) * turnRate;
                        }
                    }

                    if (b.path === 'aegis_spiral') {
                        if (b.y > H + 70) {
                            b.dead = true;
                        }
                    } else if (b.path === 'aegis_gravity') {
                        if (b.x < -40 || b.x > W + 40 || b.y < -40 || b.y > H + 40) {
                            b.dead = true;
                        }
                    } else if (b.path === 'vibemaster_implosion') {
                        if (b.y < -160 || b.y > H + 220) {
                            b.dead = true;
                        }
                    } else if (b.path === 'vibemaster_bloop' || b.path === 'vibemaster_shard' || b.path === 'vibemaster_guardian_beam') {
                        if (b.x < -60 || b.x > W + 60 || b.y < -60 || b.y > H + 120) {
                            b.dead = true;
                        }
                    } else if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) {
                        b.dead = true;
                    }

                    if (collide(b, store.player)) {
                        const p = store.player;
                        if (p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                            p.rearGuardReady = false;
                            p.rearGuardCooldown = 8;
                            b.dead = true;
                            store.activeEffects.push(createEffect("rearGuardBlock"));
                        } else {
                            // Check if this is a poison blob for special effects
                            if (b.type === 'poisonBlob') {
                                // Apply poison debuff to player
                                p.isPoisoned = true;
                                p.poisonEndTime = performance.now() + 5000; // 5 second poison
                                p.moveSpeed = Math.max(p.moveSpeed * 0.7, 50); // Slow player

                                // Create poison puddle at impact location
                                if (!store.poisonPuddles) store.poisonPuddles = [];
                                store.poisonPuddles.push({
                                    x: b.x,
                                    y: b.y,
                                    r: 25,
                                    life: getHivePuddleLifetime(5, 3, { min: 4.5, maxWaveBonus: 4 }),
                                    damage: (b.dmg || 15) * 0.3,
                                    created: performance.now()
                                });
                            }

                            // Calculate fade-in damage multiplier for Death Engine bullet rain
                            let damageMultiplier = 1.0;
                            if (b.fadeInTime && b.spawnTime) {
                                const timeAlive = (performance.now() - b.spawnTime) / 1000;
                                damageMultiplier = Math.min(1.0, timeAlive / b.fadeInTime);
                            }

                            takeDamage((b.dmg || 10) * damageMultiplier);
                            if (b.geminiTag === 'ice_shard') {
                                applyGeminiHitSlow(p, b.slowFactor || 0.6, b.slowDuration || 1.5);
                            }
                            b.dead = true;
                        }
                    }
                });

                applyTemporalBeamEffects(dt, dmgScale);

                if (store.boss && store.boss.mines) {
                    store.boss.mines.forEach(mine => {
                        mine.fuse -= dt;
                        if (mine.fuse <= 0) {
                            store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                            mine.dead = true;
                        }
                        if (collide(mine, store.player)) {
                            takeDamage(50 * dmgScale);
                            mine.dead = true;
                        }
                    });
                    store.boss.mines = store.boss.mines.filter(m => !m.dead);
                }


                const activeFlames = store._activeFlamesCache && store._activeFlamesCache.length ? store._activeFlamesCache : EMPTY_FLAME_CACHE;
                const flameCount = activeFlames.length;
                const activeCubeBurglar = getCubeBurglarActiveEnemy();

                // CONSOLIDATED enemy processing - flame collision + movement in single loop for performance
                store.enemies.forEach(e => {
                    if (e.dead) return;
                    if (e.collisionDamageCooldown && e.collisionDamageCooldown > 0) {
                        e.collisionDamageCooldown = Math.max(0, e.collisionDamageCooldown - dt);
                    }

                    if (e.cubeBurglarBuffTimer !== undefined) {
                        e.cubeBurglarBuffTimer = Math.max(0, e.cubeBurglarBuffTimer - dt);
                        const sourceActive = activeCubeBurglar && activeCubeBurglar.id === e.cubeBurglarBuffSource;
                        if (e.cubeBurglarBuffTimer <= 0 || !sourceActive) {
                            // Restore base damage multiplier
                            if (e._cubeBurglarBaseDamageMult !== undefined) {
                                e.damageMult = e._cubeBurglarBaseDamageMult;
                                delete e._cubeBurglarBaseDamageMult;
                            }
                            if (e.baseContactDamage !== undefined) {
                                e.contactDamage = e.baseContactDamage * (e.damageMult || 1);
                            }
                            
                            // Restore base HP max and scale down current HP proportionally
                            if (e._cubeBurglarBaseHpMax !== undefined) {
                                const currentHpRatio = e.hp / Math.max(1, e.hpMax);
                                e.hpMax = e._cubeBurglarBaseHpMax;
                                e.hp = Math.min(e.hp, Math.floor(e.hpMax * currentHpRatio));
                                delete e._cubeBurglarBaseHpMax;
                            }
                            
                            delete e.cubeBurglarBuffTimer;
                            delete e.cubeBurglarBuffSource;
                            delete e.cubeBurglarBuffStats;
                            delete e.cubeBurglarFireRateMultiplier;
                            delete e.cubeBurglarSpeedMultiplier;
                            delete e.cubeBurglarProjectileSpeedMultiplier;
                            e.cubeBurglarAuraGlow = 0;
                        }
                    } else if (e.cubeBurglarAuraGlow) {
                        e.cubeBurglarAuraGlow = Math.max(0, e.cubeBurglarAuraGlow - dt * 2.2);
                        if (e.cubeBurglarAuraGlow <= 0) {
                            delete e.cubeBurglarAuraGlow;
                        }
                    }

                    if (e.isVoidReaper) {
                        updateVoidReaper(e, dt);
                        return;
                    }

                    if (e.hitPulseTimer && e.hitPulseTimer > 0) {
                        e.hitPulseTimer = Math.max(0, e.hitPulseTimer - dt);
                    }

                    if (e.hitShakeTimer && e.hitShakeTimer > 0) {
                        e.hitShakeTimer = Math.max(0, e.hitShakeTimer - dt);
                        if (e.hitShakeTimer <= 0) {
                            e.hitShakeIntensity = 0;
                        }
                    }

                    if (e.topClampDelay !== undefined && e.topClampDelay > 0) {
                        e.topClampDelay = Math.max(0, e.topClampDelay - dt);
                    }

                    if (e.spawnPhase === 'teleport') {
                        const duration = Math.max(0.001, e.spawnDuration || 0.6);
                        e.spawnTimer = (e.spawnTimer ?? duration) - dt;
                        const timeRemaining = Math.max(0, e.spawnTimer);
                        const progress = Math.min(1, 1 - timeRemaining / duration);
                        const eased = 1 - Math.pow(1 - progress, 3);
                        const startY = e.spawnStartY ?? (e.spawnTargetY ?? e.y);
                        const targetY = e.spawnTargetY ?? e.y;
                        e.y = startY + (targetY - startY) * eased;
                        e.spawnOpacity = Math.min(1, Math.max(e.spawnOpacity ?? 0, eased * 1.1));
                        e.vulnLastKnownPos = { x: e.x, y: e.y };
                        if (e.spawnTimer <= 0) {
                            e.spawnPhase = null;
                            e.spawnOpacity = 1;
                            e.y = targetY;
                        } else {
                            return;
                        }
                    } else {
                        e.vulnLastKnownPos = { x: e.x, y: e.y };
                        if (e.spawnOpacity !== undefined && e.spawnOpacity < 1) {
                            e.spawnOpacity = Math.min(1, e.spawnOpacity + dt * 2.2);
                        }
                    }

                    if (e.jugPulseTimer) e.jugPulseTimer = Math.max(0, e.jugPulseTimer - dt);
                    if (e.jugFearTimer) e.jugFearTimer = Math.max(0, e.jugFearTimer - dt);
                    if (e.jugBurnTimer) {
                        e.jugBurnTimer = Math.max(0, e.jugBurnTimer - dt);
                        e.jugBurnTick = (e.jugBurnTick || 0) - dt;
                        if (e.jugBurnTimer > 0 && e.jugBurnTick <= 0) {
                            const burnDamage = 10 * (store.player?.dmgMult || 1);
                            const lethalFloor = (e === store.boss) ? 0 : 1;
                            const appliedBurn = Math.min(burnDamage, Math.max(0, e.hp - lethalFloor));
                            e.hp -= appliedBurn;
                            e.jugBurnTick = 0.45;
                            store.activeEffects.push(createEffect('jugFearEmber', e.x, e.y, e.r || 20));
                            spawnDotDamageText(e, appliedBurn, {
                                color: '#ff995c',
                                jitter: 4,
                                riseSpeed: 30,
                                scale: 0.9
                            });
                        }
                    }

                    // Handle poison DoT with stacking support
                    if (e.poisonStacks && e.poisonStacks > 0) {
                        e.poisonStackTimer -= dt;
                        e.poisonLastTick -= dt;
                        
                        // Decay poison stacks if timer expired
                        if (e.poisonStackTimer <= 0) {
                            e.poisonStacks = 0;
                            delete e.poisonStackTimer;
                            delete e.poisonLastTick;
                            delete e.poisonDamagePerStack;
                        }
                        
                        // Apply poison damage on tick
                        if (e.poisonLastTick <= 0 && e.poisonStacks > 0) {
                            const poisonDamage = (e.poisonDamagePerStack || 0) * e.poisonStacks;
                            const lethalFloor = (e === store.boss) ? 0 : 1;
                            const appliedPoison = Math.min(poisonDamage, Math.max(0, e.hp - lethalFloor));
                            e.hp -= appliedPoison;
                            if (!Array.isArray(store.activeEffects)) {
                                store.activeEffects = [];
                            }
                            store.activeEffects.push(createEffect('poisonCloud', e.x, e.y, e.r || 16));
                            if (appliedPoison > 0) {
                                recordStackElementHit(e, 'poison');
                                playSound('poisonSplash'); // Play poison splash sound on damage tick
                            }
                            e.poisonLastTick = e.poisonTickInterval || 0.1;
                            spawnDotDamageText(e, appliedPoison, {
                                color: '#48ff9a',
                                jitter: 5,
                                riseSpeed: 26,
                                scale: 0.85
                            });
                        }
                    }

                    // Handle old poison DoT (for backwards compatibility)
                    if (e.poisonDot && e.poisonDot.duration > 0) {
                        e.poisonDot.duration -= dt;
                        e.poisonDot.lastTick = (e.poisonDot.lastTick || 0) - dt;
                        if (e.poisonDot.lastTick <= 0) {
                            const poisonDamage = e.poisonDot.damage || 5;
                            const lethalFloor = (e === store.boss) ? 0 : 1;
                            const appliedPoison = Math.min(poisonDamage, Math.max(0, e.hp - lethalFloor));
                            e.hp -= appliedPoison;
                            if (!Array.isArray(store.activeEffects)) {
                                store.activeEffects = [];
                            }
                            store.activeEffects.push(createEffect('poisonCloud', e.x, e.y, e.r || 16));
                            if (appliedPoison > 0) {
                                recordStackElementHit(e, 'poison');
                            }
                            e.poisonDot.lastTick = e.poisonDot.tickInterval || 0.15;
                            spawnDotDamageText(e, appliedPoison, {
                                color: '#48ff9a',
                                jitter: 5,
                                riseSpeed: 24,
                                scale: 0.8
                            });
                        }
                        if (e.poisonDot.duration <= 0) {
                            delete e.poisonDot;
                        }
                    }

                    // Fire spreading mechanic - burning enemies spread fire on contact
                    if (e.fireStacks && e.fireStacks > 0) {
                        // Initialize fire spread cooldown if not present
                        if (!e.fireSpreadCooldown) {
                            e.fireSpreadCooldown = 0;
                        }
                        
                        e.fireSpreadCooldown -= dt;
                        
                        // Check for nearby enemies to spread fire to
                        if (e.fireSpreadCooldown <= 0) {
                            const spreadRadius = (e.r || 16) * 2.5; // Detection radius for spreading
                            
                            for (const other of store.enemies) {
                                if (other === e || other.dead) continue;
                                
                                const dx = other.x - e.x;
                                const dy = other.y - e.y;
                                const distSq = dx * dx + dy * dy;
                                const maxDistSq = spreadRadius * spreadRadius;
                                
                                if (distSq < maxDistSq) {
                                    // Enemies are touching - spread fire (1 stack)
                                    if (!other.fireStacks || other.fireStacks === 0) {
                                        other.fireStacks = 1;
                                        other.fireStackTimer = 3.0;
                                        other.fireAutoStackTimer = 0;
                                        if (!Array.isArray(store.activeEffects)) {
                                            store.activeEffects = [];
                                        }
                                        store.activeEffects.push(createEffect('fireSpread', other.x, other.y, other.r || 16));
                                        
                                        // Set cooldown to prevent immediate re-spread
                                        e.fireSpreadCooldown = 0.5;
                                        break; // Only spread to one enemy per check
                                    }
                                }
                            }
                        }
                    }

                    tickChampionBurn(e, dt);
                    if (Array.isArray(e.fireBurns) && e.fireBurns.length > 0) {
                        for (let i = e.fireBurns.length - 1; i >= 0; i--) {
                            const burn = e.fireBurns[i];
                            burn.effectTimer = (burn.effectTimer || 0) - dt;
                            burn.elapsed = Math.min(burn.duration, burn.elapsed + dt);
                            const duration = Math.max(0.001, burn.duration);
                            const progress = burn.elapsed / duration;
                            const targetDamage = burn.totalDamage * progress * progress;
                            let delta = targetDamage - burn.appliedDamage;
                            if (delta > 0) {
                                const lethalFloor = burn.lethalFloor ?? (e === store.boss ? 0 : 1);
                                delta = Math.min(delta, Math.max(0, e.hp - lethalFloor));
                                if (delta > 0) {
                                    e.hp -= delta;
                                    recordStackElementHit(e, 'fire');
                                    burn.appliedDamage += delta;
                                    spawnDotDamageText(e, delta, {
                                        color: '#ff7a45',
                                        jitter: 5,
                                        riseSpeed: 34,
                                        scale: 0.95
                                    });
                                    if (burn.effectTimer <= 0) {
                                        spawnLocalizedFireBurn(e, progress);
                                        burn.effectTimer = 0.4; // Increased from 0.15 to 0.4 for more readable damage numbers
                                    }
                                }
                            }
                            if (burn.elapsed >= duration || burn.appliedDamage >= burn.totalDamage - 1e-4) {
                                e.fireBurns.splice(i, 1);
                            }
                        }
                        if (!e.fireBurns.length) {
                            delete e.fireBurns;
                        }
                    }
                    tickChampionVoidMarks(e, dt);
                    tickChampionStormGrid(e, dt);
                    if (e.railgunArmorTimer) e.railgunArmorTimer = Math.max(0, e.railgunArmorTimer - dt);
                    if (e.phaseLockTimer) e.phaseLockTimer = Math.max(0, e.phaseLockTimer - dt);
                    if (e.stormShockTimer) e.stormShockTimer = Math.max(0, e.stormShockTimer - dt);
                    if (e.demolitionPulseWarmup) e.demolitionPulseWarmup = Math.max(0, e.demolitionPulseWarmup - dt);
                    if (e.maraLaunchTimer) e.maraLaunchTimer = Math.max(0, e.maraLaunchTimer - dt);
                    if (e.vulnerabilityPulseStrength) {
                        e.vulnerabilityPulseStrength = Math.max(0, e.vulnerabilityPulseStrength - dt * 0.7);
                    }

                    // OPTIMIZED FLAME PARTICLE COLLISION - batch processing with early exit
                    if (flameCount > 0) {
                        for (let f = 0; f < flameCount; f++) {
                            const flame = activeFlames[f];

                            const dx = flame.x - e.x;
                            const dy = flame.y - e.y;

                            // Early distance culling - skip expensive collision if too far (increased threshold)
                            if (Math.abs(dx) > 120 || Math.abs(dy) > 120) continue;

                            const distSq = dx * dx + dy * dy; // Skip sqrt - use squared distance
                            const collisionRadius = Math.max(5, flame.size + e.r - 50);
                            const collisionRadiusSq = collisionRadius * collisionRadius;

                            if (distSq < collisionRadiusSq) {
                                e.stunTimer = Math.max(e.stunTimer || 0, 0.5);
                                let appliedFlameDamage = flame.damage;
                                if (e.type === 'cube_burglar') {
                                    const flameResult = applyCubeBurglarHit(e, { x: flame.x, y: flame.y }, flame.damage);
                                    appliedFlameDamage = flameResult.damageApplied || 0;
                                } else {
                                    e.hp -= flame.damage;
                                }

                                // Track fire stacks for panicked behavior
                                e.fireStacks = Math.min(5, (e.fireStacks || 0) + 1); // Increased to 5 stacks max
                                e.fireStackTimer = 3; // 3 seconds duration
                                recordStackElementHit(e, 'fire');
                                
                                // Trigger panic behavior at 5 stacks
                                if (e.fireStacks >= 5 && !e.fireParnicActive) {
                                    e.firePanicActive = true;
                                    e.firePanicTimer = 1.5; // 1.5 second burst of panicked movement
                                    e.firePanicPhase = 'burst'; // Start with burst phase
                                }

                                // Apply vampirism healing for flamethrower damage
                                if (store.player.vampirism > 0 && appliedFlameDamage > 0) {
                                    let healAmount = appliedFlameDamage * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                                    healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }

                                e.isBurning = true;
                                setTimeout(() => { if (e) e.isBurning = false; }, 100);
                                break; // Exit early on first collision for performance
                            }
                        }
                    }

                    if (e.type === 'cube_burglar') {
                        updateCubeBurglar(e, dt);
                        return;
                    }

                    // MOVEMENT AND AI UPDATES
                    if (e.knockback) {
                        // Handle different knockback formats
                        if (e.knockback.vx !== undefined && e.knockback.vy !== undefined) {
                            // Beef charge knockback format
                            e.x += e.knockback.vx * dt;
                            e.y += e.knockback.vy * dt;
                            e.knockback.duration -= dt;
                            if (e.knockback.duration <= 0) e.knockback = null;
                        } else if (e.knockback.x !== undefined && e.knockback.y !== undefined) {
                            // Blink ability knockback format
                            e.x += e.knockback.x * dt;
                            e.y += e.knockback.y * dt;
                            e.knockback.duration -= dt;
                            if (e.knockback.duration <= 0) e.knockback = null;
                        }

                        // Clamp enemies to screen boundaries so they don't get pushed off-screen
                        const margin = e.r || 15; // Use enemy radius for margin, default to 15
                        e.x = Math.max(margin, Math.min(W - margin, e.x));
                        e.y = Math.max(margin, Math.min(H - margin, e.y));
                        if (e.knockback && e.knockback.type === 'maraLaunch' && !e.maraImpactTriggered) {
                            if (e.x <= margin + 1 || e.x >= W - margin - 1 || e.y <= margin + 1 || e.y >= H - margin - 1) {
                                e.maraImpactTriggered = true;
                                store.activeEffects.push(createEffect('maraImpactShockwave', e.x, e.y, (e.r || 20) * 1.8));
                            }
                        }
                    } else if (e.stunTimer && e.stunTimer > 0) {
                        e.stunTimer -= dt;
                        
                        // Recover from flatten effect as stun timer expires
                        if (e.isFlattened && e.flattenDuration) {
                            e.flattenDuration -= dt;
                            // Gradually recover scale as flatten wears off
                            const remainingRatio = Math.max(0, e.flattenDuration / 3.0);
                            e.flattenScale = { 
                                x: 1 + remainingRatio, // Scale from 2.0 back to 1.0
                                y: 0.1 + remainingRatio * 0.9 // Scale from 0.1 back to 1.0
                            };
                            
                            // When flatten expires completely, remove the effect
                            if (e.flattenDuration <= 0) {
                                e.isFlattened = false;
                                e.flattenScale = null;
                                e.hp = Math.max(1, e.hp); // Restore at least 1 HP so they don't die from the effect
                            }
                        }
                    } else {
                        let speedMultiplier = (e.slowTimer > 0) ? 0.3 : 1.0;
                        
                        // Handle fire stack decay and panic behavior
                        if (e.fireStackTimer && e.fireStackTimer > 0) {
                            e.fireStackTimer -= dt;
                            
                            // Auto-escalation: enemies with at least 1 fire stack gain 1 additional stack per second
                            if (e.fireStacks && e.fireStacks > 0 && e.fireStacks < 5) {
                                e.fireAutoStackTimer = (e.fireAutoStackTimer || 0) + dt;
                                if (e.fireAutoStackTimer >= 1.0) {
                                    e.fireStacks = Math.min(5, e.fireStacks + 1);
                                    e.fireAutoStackTimer = 0;
                                    e.fireStackTimer = 3.0; // Refresh timer
                                }
                            }
                            
                            if (e.fireStackTimer <= 0) {
                                e.fireStacks = 0;
                                e.firePanicActive = false;
                                e.firePanicTimer = 0;
                                delete e.fireAutoStackTimer;
                            }
                        }
                        
                        // Update fire panic timer
                        if (e.firePanicActive && e.firePanicTimer > 0) {
                            e.firePanicTimer -= dt;
                            if (e.firePanicTimer <= 0) {
                                e.firePanicActive = false;
                                e.firePanicPhase = null;
                            }
                        }
                        
                        // Apply ice bullet slow effect
                        if (e.speedMultiplier !== undefined && e.speedMultiplier < 1) {
                            speedMultiplier *= e.speedMultiplier;
                        }
                        
                        if (e.hitSlowTimer && e.hitSlowTimer > 0) {
                            const slowFactor = e.hitSlowFactor !== undefined ? e.hitSlowFactor : 0.85;
                            speedMultiplier *= Math.max(0.3, Math.min(1, slowFactor));
                            e.hitSlowTimer = Math.max(0, e.hitSlowTimer - dt);
                            if (e.hitSlowTimer <= 0) {
                                e.hitSlowFactor = 1;
                            }
                        } else if (e.hitSlowFactor && e.hitSlowFactor !== 1 && (!e.hitSlowTimer || e.hitSlowTimer <= 0)) {
                            e.hitSlowFactor = 1;
                        }
                        
                        // Fragment blast slow effect
                        if (e.fragmentBlastSlowTimer && e.fragmentBlastSlowTimer > 0) {
                            const slowFactor = e.fragmentBlastSlowFactor !== undefined ? e.fragmentBlastSlowFactor : 0.65;
                            speedMultiplier *= Math.max(0.3, Math.min(1, slowFactor));
                            e.fragmentBlastSlowTimer = Math.max(0, e.fragmentBlastSlowTimer - dt);
                            if (e.fragmentBlastSlowTimer <= 0) {
                                e.fragmentBlastGoldTint = false;
                            }
                        }
                        
                        if (e.slowTimer > 0) e.slowTimer -= dt;
                        
                        // Handle ice stacks - decay timer and maintain freeze state
                        if (e.iceStacks && e.iceStacks > 0) {
                            e.iceStackTimer = Math.max(0, (e.iceStackTimer || 0) - dt);
                            
                            // Handle Cube Burglar freeze timer (2 second freeze at 9 stacks)
                            const isCubeBurglar = e.type === 'cube_burglar';
                            if (isCubeBurglar && e.burglarFreezeTimer !== undefined) {
                                e.burglarFreezeTimer = Math.max(0, e.burglarFreezeTimer - dt);
                                if (e.burglarFreezeTimer <= 0) {
                                    // Freeze ended - reset to 0 stacks, must rebuild to 9 again
                                    e.iceStacks = 0;
                                    delete e.burglarFreezeTimer;
                                    delete e.iceStackTimer;
                                    delete e.speedMultiplier;
                                    delete e.iceDamageMultiplier;
                                    delete e.isFrozen;
                                }
                            }
                            
                            if (e.iceStackTimer <= 0) {
                                e.iceStacks = 0;
                                delete e.iceStackTimer;
                                delete e.speedMultiplier;
                                delete e.iceDamageMultiplier;
                                if (e.isFrozen) delete e.isFrozen;
                                if (e.burglarFreezeTimer !== undefined) delete e.burglarFreezeTimer;
                            } else {
                                const isBoss = e === store.boss || e.isBoss;
                                const freezeThreshold = isCubeBurglar ? 9 : 3;
                                const activeStacks = isBoss ? Math.min(3, e.iceStacks) : Math.min(freezeThreshold, e.iceStacks);
                                
                                // Damage multiplier only uses first 3 stacks (10% per stack = 30% max at 3+ stacks)
                                const damageStacks = Math.min(3, e.iceStacks);
                                const iceDamageMultiplier = 1 + (0.1 * damageStacks);
                                e.iceDamageMultiplier = iceDamageMultiplier;

                                // Bosses never freeze, only slow (max 3 stacks)
                                if (isBoss) {
                                    const slowStacks = Math.min(3, activeStacks);
                                    const targetSpeed = ICE_SPEED_BY_STACK[slowStacks] ?? 0;
                                    if (e.speedMultiplier === undefined) {
                                        e.speedMultiplier = targetSpeed;
                                    } else {
                                        e.speedMultiplier = Math.min(e.speedMultiplier, targetSpeed);
                                    }
                                    // Never freeze bosses
                                    if (e.isFrozen) delete e.isFrozen;
                                } else if (isCubeBurglar) {
                                    // Cube Burglar freezes at 9 stacks, slows below that
                                    if (activeStacks >= 9 && e.burglarFreezeTimer !== undefined && e.burglarFreezeTimer > 0) {
                                        e.isFrozen = true;
                                        e.speedMultiplier = 0;
                                    } else {
                                        // Apply slow based on first 3 stacks
                                        const slowStacks = Math.min(3, activeStacks);
                                        const targetSpeed = ICE_SPEED_BY_STACK[slowStacks] ?? 0;
                                        if (e.speedMultiplier === undefined) {
                                            e.speedMultiplier = targetSpeed;
                                        } else {
                                            e.speedMultiplier = Math.min(e.speedMultiplier, targetSpeed);
                                        }
                                        if (e.isFrozen) delete e.isFrozen;
                                    }
                                } else {
                                    // Regular enemies freeze at 3 stacks
                                    const targetSpeed = ICE_SPEED_BY_STACK[activeStacks] ?? 0;
                                    if (e.speedMultiplier === undefined) {
                                        e.speedMultiplier = targetSpeed;
                                    } else {
                                        e.speedMultiplier = Math.min(e.speedMultiplier, targetSpeed);
                                    }

                                    if (activeStacks >= 3) {
                                        e.isFrozen = true;
                                        e.speedMultiplier = 0;
                                    } else if (e.isFrozen) {
                                        delete e.isFrozen;
                                    }
                                }
                            }
                        } else {
                            if (e.isFrozen) delete e.isFrozen;
                            if (e.speedMultiplier === 0) delete e.speedMultiplier;
                            if (e.iceDamageMultiplier !== undefined) delete e.iceDamageMultiplier;
                            if (e.burglarFreezeTimer !== undefined) delete e.burglarFreezeTimer;
                        }
                        
                        if (e.phaseLockTimer > 0) {
                            speedMultiplier *= e.phaseLockSlowFactor || 0.4;
                        }
                        if (e.stormShockTimer > 0) {
                            speedMultiplier *= 0.6;
                        }

                        if (e.cubeBurglarSpeedMultiplier && e.cubeBurglarSpeedMultiplier !== 1) {
                            speedMultiplier *= e.cubeBurglarSpeedMultiplier;
                        }

                        const freezeLocked = e.isFrozen && (
                            (e.type === 'cube_burglar' && e.iceStacks >= 9 && e.burglarFreezeTimer > 0) ||
                            (e.type !== 'cube_burglar' && e !== store.boss && !e.isBoss && e.iceStacks >= 3)
                        ) && (e.iceStackTimer || 0) > 0;

                        // VERTICAL DESCENT REDUCTION: Slow down downward movement to give more time to engage
                        // Lateral movement remains at full speedMultiplier for dynamic gameplay
                        const horizontalSpeedMultiplier = speedMultiplier; // Full speed for X movement
                        const verticalSpeedMultiplier = speedMultiplier * 0.6; // 60% speed for Y movement (slower descent)

                        // FIRE PANIC BEHAVIOR: 3 fire stacks = panicked run toward backline
                        let firePanicMovement = null;
                        if (e.firePanicActive && e.firePanicTimer > 0 && e.firePanicPhase === 'burst') {
                            // Calculate backline direction (top of screen)
                            const toBacklineX = e.x; // Keep same X position
                            const toBacklineY = -50; // Run toward top (off-screen)
                            const dx = toBacklineX - e.x;
                            const dy = toBacklineY - e.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > 1) {
                                // Erratic panicked movement - fast with random wobble
                                e.t = (e.t || 0) + dt;
                                const panicSpeed = (e.v || 100) * 2.5; // 2.5x speed burst
                                const erraticWobble = Math.sin(e.t * 18) * 40 + Math.cos(e.t * 12) * 25; // Intense wobbling
                                const perpX = -dy / dist;
                                const perpY = dx / dist;
                                
                                firePanicMovement = {
                                    x: ((dx / dist) * panicSpeed + perpX * erraticWobble) * dt,
                                    y: ((dy / dist) * panicSpeed + perpY * erraticWobble) * dt
                                };
                            }
                        }
                        
                        // POISON DRUNK BEHAVIOR: 3 poison stacks = drunken movement
                        let poisonDrunkMovement = null;
                        if (e.poisonStacks >= 3 && e.poisonStacks > 0) {
                            e.t = (e.t || 0) + dt;
                            // Drunken modifier: slow, erratic, wandering
                            e.drunkWanderAngle = (e.drunkWanderAngle || 0) + (Math.random() - 0.5) * 8 * dt;
                            const drunkSpeed = (e.v || 100) * 0.4; // Move at 40% speed
                            const wobbleIntensity = 60;
                            const wobbleX = Math.sin(e.t * 3 + e.drunkWanderAngle) * wobbleIntensity;
                            const wobbleY = Math.cos(e.t * 2.5 + e.drunkWanderAngle * 0.7) * wobbleIntensity;
                            
                            poisonDrunkMovement = {
                                x: wobbleX * dt,
                                y: wobbleY * dt
                            };
                        }

                        if (freezeLocked) {
                            firePanicMovement = null;
                            poisonDrunkMovement = null;
                            e.vx = 0;
                            e.vy = 0;
                            if (e.dashVX) e.dashVX = 0;
                            if (e.dashVY) e.dashVY = 0;
                        }

                        // ZOMBIE PROTOCOL: Slow tracking toward player
                        if (e.type === 'zombie' && e.tracksPlayer) {
                            e.t = (e.t || 0) + dt;
                            const dx = store.player.x - e.x;
                            const dy = store.player.y - e.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist > 1) {
                                // Slow shambling movement directly toward player
                                e.x += (dx / dist) * e.v * speedMultiplier * dt;
                                e.y += (dy / dist) * e.v * speedMultiplier * dt;
                            }
                        }
                        // SWARM PROTOCOL: Fast homing enemies (construct_gold, avian_hatchling)
                        else if (e.type === 'construct_gold' || e.type === 'avian_hatchling') {
                            e.t = (e.t || 0) + dt;
                            const overshootHandled = maybeHandleChaseOvershoot(e, dt, speedMultiplier, e.v * 1.25, {
                                triggerRange: 240,
                                cooldownMin: 1.1,
                                cooldownMax: 2.4,
                                durationMin: 0.28,
                                durationMax: 0.52,
                                speedBoostMin: 1.45,
                                speedBoostMax: 2.05,
                                angleJitter: 0.6,
                                overshootBias: 150,
                                downwardBias: 0.18
                            });
                            if (!overshootHandled) {
                                const dx = store.player.x - e.x;
                                const dy = store.player.y - e.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) {
                                    // Apply status effect movement overrides
                                    if (firePanicMovement) {
                                        e.x += firePanicMovement.x;
                                        e.y += firePanicMovement.y;
                                    } else if (poisonDrunkMovement) {
                                        e.x += poisonDrunkMovement.x;
                                        e.y += poisonDrunkMovement.y;
                                    } else {
                                        // Normal swarm movement: move directly toward player with slight randomness
                                        const wobble = Math.sin(e.t * 8) * 15; // Add micro-dodges
                                        const perpX = -dy / dist;
                                        const perpY = dx / dist;
                                        e.x += ((dx / dist) * e.v + perpX * wobble) * speedMultiplier * dt;
                                        e.y += ((dy / dist) * e.v + perpY * wobble) * speedMultiplier * dt;
                                    }
                                }
                            }
                        } else if (e.movementBehavior) {
                            // CONTINUOUS SPAWN SYSTEM: Use assigned movement behavior
                            applyMovementBehavior(e, dt);
                        } else if (e.type === 'drone') {
                            // DYNAMIC AI PROTOCOL: Chase â†’ Attack â†’ Dodge cycle
                            if (!e.aiState) {
                                e.aiState = 'chase';
                                e.aiTimer = 0;
                                e.aiCycleCount = 0;
                            }
                            
                            e.aiTimer += dt;
                            const dx = store.player.x - e.x;
                            const dy = store.player.y - e.y;
                            const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                            
                            if (e.aiState === 'chase') {
                                // Apply status effect movement overrides
                                if (firePanicMovement) {
                                    e.x += firePanicMovement.x;
                                    e.y += firePanicMovement.y;
                                } else if (poisonDrunkMovement) {
                                    e.x += poisonDrunkMovement.x;
                                    e.y += poisonDrunkMovement.y;
                                } else {
                                    // Normal chase toward player
                                    const chaseSpeed = 0.4;
                                    if (distToPlayer > 10) {
                                        e.x += (dx / distToPlayer) * e.v * chaseSpeed * speedMultiplier * dt;
                                        e.y += (dy / distToPlayer) * e.v * chaseSpeed * speedMultiplier * dt;
                                    }
                                }
                                // Switch to attack when close enough or after 1.5 seconds
                                if (distToPlayer < 180 || e.aiTimer > 1.5) {
                                    e.aiState = 'attack';
                                    e.aiTimer = 0;
                                }
                            } else if (e.aiState === 'attack') {
                                // Apply status effect movement overrides
                                if (firePanicMovement) {
                                    e.x += firePanicMovement.x;
                                    e.y += firePanicMovement.y;
                                } else if (poisonDrunkMovement) {
                                    e.x += poisonDrunkMovement.x;
                                    e.y += poisonDrunkMovement.y;
                                } else {
                                    // Normal attack behavior: stop and prepare to fire
                                    const stopDrift = 0.92;
                                    e.x += (dx / Math.max(1, distToPlayer)) * e.v * 0.1 * speedMultiplier * dt * stopDrift;
                                    e.y += e.v * 0.15 * verticalSpeedMultiplier * dt;
                                }
                                
                                // Fire at player if cooldown allows
                                if (e.fireT <= 0 && distToPlayer < 300) {
                                    e.fireT = e.fireCooldown || 2.5;
                                }
                                
                                // Switch to dodge after 0.8 seconds
                                if (e.aiTimer > 0.8) {
                                    e.aiState = 'dodge';
                                    e.aiTimer = 0;
                                    e.dodgeDirection = Math.random() < 0.5 ? -1 : 1;
                                }
                            } else if (e.aiState === 'dodge') {
                                // Strafe sideways to evade
                                const dodgeSpeed = 65;
                                e.x += e.dodgeDirection * dodgeSpeed * speedMultiplier * dt;
                                e.y += e.v * 0.3 * verticalSpeedMultiplier * dt;
                                
                                // Clamp to screen
                                e.x = Math.max(e.r + 10, Math.min(W - e.r - 10, e.x));
                                
                                // Switch back to chase after 0.7 seconds
                                if (e.aiTimer > 0.7) {
                                    e.aiState = 'chase';
                                    e.aiTimer = 0;
                                    e.aiCycleCount++;
                                }
                            }
                        } else if (e.type === 'hunter') {
                            // PURSUIT PROTOCOL: Aggressive tracking with gang-specific abilities
                            updateHunterGangAbility(e, dt, speedMultiplier);
                            
                            if (!e.isLunging && !e.isFleeing && !e.formationLocked) {
                                const overshootHandled = maybeHandleChaseOvershoot(e, dt, speedMultiplier, e.v, {
                                    triggerRange: 300,
                                    cooldownMin: 1.4,
                                    cooldownMax: 2.9,
                                    durationMin: 0.35,
                                    durationMax: 0.6,
                                    speedBoostMin: 1.35,
                                    speedBoostMax: 1.75,
                                    angleJitter: 0.45,
                                    overshootBias: 210,
                                    downwardBias: 0.35
                                });
                                if (!overshootHandled) {
                                    const dx = store.player.x - e.x;
                                    const dy = store.player.y - e.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist > 1) {
                                        // Apply status effect movement overrides
                                        if (firePanicMovement) {
                                            e.x += firePanicMovement.x;
                                            e.y += firePanicMovement.y;
                                        } else if (poisonDrunkMovement) {
                                            e.x += poisonDrunkMovement.x;
                                            e.y += poisonDrunkMovement.y;
                                        } else {
                                            // Normal hunters actively pursue with full 2D movement
                                            const pursueFactor = 0.6; // 60% toward player, 40% downward
                                            e.x += (dx / dist) * e.v * pursueFactor * speedMultiplier * dt;
                                            e.y += ((dy / dist) * e.v * pursueFactor + e.v * (1 - pursueFactor)) * verticalSpeedMultiplier * dt;
                                        }
                                    } else {
                                        e.y += e.v * verticalSpeedMultiplier * dt;
                                    }
                                }
                            }
                        } else if (e.type === 'angler') {
                            // TANK PROTOCOL: Slow, steady, horizontal tracking only
                            // Apply status effect movement overrides
                            if (firePanicMovement) {
                                e.x += firePanicMovement.x;
                                e.y += firePanicMovement.y;
                            } else if (poisonDrunkMovement) {
                                e.x += poisonDrunkMovement.x;
                                e.y += poisonDrunkMovement.y;
                            } else {
                                const dx = store.player.x - e.x;
                                if (Math.abs(dx) > 10) e.x += Math.sign(dx) * 30 * speedMultiplier * dt;
                                e.y += e.v * verticalSpeedMultiplier * dt;
                            }
                        } else if (e.type === 'phantom') {
                            // DYNAMIC PHASE-SHIFT PROTOCOL: Aggressive chase â†’ Burst attack â†’ Evasive weave
                            if (!e.aiState) {
                                e.aiState = 'chase';
                                e.aiTimer = 0;
                                e.phaseShiftCooldown = 0;
                            }
                            
                            e.aiTimer += dt;
                            e.phaseShiftCooldown = Math.max(0, e.phaseShiftCooldown - dt);
                            
                            const dx = store.player.x - e.x;
                            const dy = store.player.y - e.y;
                            const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                            
                            if (e.aiState === 'chase') {
                                // Aggressive pursuit
                                const chaseSpeed = 0.55;
                                if (distToPlayer > 10) {
                                    e.x += (dx / distToPlayer) * e.v * chaseSpeed * speedMultiplier * dt;
                                    e.y += (dy / distToPlayer) * e.v * chaseSpeed * speedMultiplier * dt;
                                }
                                // Switch to attack when in range
                                if (distToPlayer < 200 || e.aiTimer > 1.2) {
                                    e.aiState = 'attack';
                                    e.aiTimer = 0;
                                }
                            } else if (e.aiState === 'attack') {
                                // Hover and rapid fire
                                e.x += (dx / Math.max(1, distToPlayer)) * e.v * 0.08 * speedMultiplier * dt;
                                e.y += e.v * 0.1 * verticalSpeedMultiplier * dt;
                                
                                // Phantoms fire more frequently during attack phase
                                if (e.fireT <= 0 && distToPlayer < 320) {
                                    e.fireT = (e.fireCooldown || 2.0) * 0.7; // Faster firing
                                }
                                
                                // Switch to weave after burst
                                if (e.aiTimer > 1.0) {
                                    e.aiState = 'weave';
                                    e.aiTimer = 0;
                                    e.weaveDirection = Math.random() < 0.5 ? -1 : 1;
                                    e.weavePhase = Math.random() * Math.PI * 2;
                                }
                            } else if (e.aiState === 'weave') {
                                // Evasive serpentine movement
                                const weaveSpeed = 55;
                                const weavePattern = Math.sin(e.weavePhase + e.aiTimer * 3.5) * weaveSpeed;
                                e.x += weavePattern * speedMultiplier * dt;
                                e.y += e.v * 0.4 * verticalSpeedMultiplier * dt;
                                
                                // Clamp to screen
                                e.x = Math.max(e.r + 10, Math.min(W - e.r - 10, e.x));
                                
                                // Phase shift (quick dodge) when player is close
                                if (distToPlayer < 100 && e.phaseShiftCooldown <= 0) {
                                    const shiftDist = 60;
                                    const shiftAngle = Math.atan2(dy, dx) + (Math.random() - 0.5) * Math.PI;
                                    e.x -= Math.cos(shiftAngle) * shiftDist;
                                    e.y -= Math.sin(shiftAngle) * shiftDist * 0.5;
                                    e.phaseShiftCooldown = 2.5;
                                }
                                
                                // Switch back to chase
                                if (e.aiTimer > 1.0) {
                                    e.aiState = 'chase';
                                    e.aiTimer = 0;
                                }
                            }
                        } else if (e.type === 'mech') {
                            // HEAVY TANK PROTOCOL: Methodical advance with minimal deviation
                            // Mechs are slow and steady, tracking player horizontally
                            const dx = store.player.x - e.x;
                            const trackSpeed = 20; // Slower than angler
                            if (Math.abs(dx) > 15) {
                                e.x += Math.sign(dx) * trackSpeed * speedMultiplier * dt;
                            }
                            e.y += e.v * verticalSpeedMultiplier * dt;
                        } else if (e.type === 'manta') {
                            e.t += dt;

                            // WEAVE PROTOCOL: Sinusoidal snake movement
                            // Enhanced for dodge-focused waves
                            const wave = store.world.wave || 1;
                            let waveAmplitude = e.amplitude;
                            let waveFrequency = e.frequency;
                            
                            if (wave >= 30) {
                                // In dodge hell waves, mantas weave more aggressively
                                waveAmplitude *= 1.3;
                                waveFrequency *= 1.2;
                            }
                            
                            e.x = e.startX + waveAmplitude * Math.sin(e.t * waveFrequency);
                            e.y += e.v * verticalSpeedMultiplier * dt;
                        } else if (e.type === 'shadow_champion') {
                            const boss = store.boss && store.boss.behavior === 'shadow_clone' ? store.boss : null;
                            const enrageThreshold = e.enrageThreshold ?? 0.45;
                            const bossRatio = boss && boss.hpMax ? boss.hp / boss.hpMax : 1;
                            const isEnraged = boss ? (boss.isEnraged || bossRatio <= enrageThreshold) : true;
                            e.isEnraged = isEnraged;

                            if (e.state === 'dash') {
                                e.dashTimer -= dt;
                                e.x += (e.dashVX || 0) * speedMultiplier * dt;
                                e.y += (e.dashVY || 0) * speedMultiplier * dt;
                                addShadowEcho(e.x, e.y);
                                if (e.dashTimer <= 0) {
                                    e.state = null;
                                    e.dashVX = 0;
                                    e.dashVY = 0;
                                }
                            } else {
                                const anchorX = boss ? boss.x : store.player.x;
                                const anchorY = boss ? boss.y + (e.anchorOffsetY ?? 80) : store.player.y - 60;
                                const radius = boss ? (e.guardRadius || 120) : Math.max(80, (e.guardRadius || 120) * 0.65);
                                e.guardAngle = (e.guardAngle ?? 0) + (e.angularSpeed || 0.9) * dt * (isEnraged ? 1.35 : 1);
                                const desiredX = anchorX + Math.cos(e.guardAngle) * radius;
                                const desiredY = anchorY + Math.sin(e.guardAngle) * Math.max(radius * 0.55, 60);
                                const followSpeed = (e.momentum || 3.4) * (isEnraged ? 1.15 : 1);
                                e.x += (desiredX - e.x) * Math.min(1, followSpeed * dt);
                                e.y += (desiredY - e.y) * Math.min(1, followSpeed * 0.9 * dt);
                            }

                            store.shadowChampionLastPos = { x: e.x, y: e.y };
                        } else if (e.type === 'void_champion') {
                            e.baseV = e.baseV || e.v;
                            e.t += dt;
                            if (e.ramming) {
                                e.x += e.dashVX * speedMultiplier * dt;
                                e.y += e.dashVY * speedMultiplier * dt;
                                e.dashDuration -= dt;
                                if (e.dashDuration <= 0) {
                                    e.ramming = false;
                                    e.v = e.baseV;
                                    e.vx = (Math.random() < 0.5 ? -1 : 1) * (30 + Math.random() * 40);
                                }
                            } else {
                                e.v = e.baseV;
                                e.vx += Math.sin(e.t * 2.5) * 20 * dt;
                                e.x += (e.vx || 0) * speedMultiplier * dt;
                                // Void champion is immune to gravity - no automatic downward movement
                            }

                            if (!e.ramming) {
                                e.dashTimer -= dt;
                                if (e.dashTimer <= 0) {
                                    const dx = store.player.x - e.x;
                                    const dy = store.player.y - e.y;
                                    const dist = Math.max(60, Math.sqrt(dx * dx + dy * dy));
                                    e.dashVX = (dx / dist) * 260;
                                    e.dashVY = (dy / dist) * 260;
                                    e.dashDuration = 0.35;
                                    e.ramming = true;
                                    e.dashTimer = e.dashCooldown;
                                }
                            }

                            // Clamp void champion to playfield bounds (both horizontal and vertical)
                            if (e.x < e.r) {
                                e.x = e.r;
                                e.vx = Math.abs(e.vx || 60);
                            } else if (e.x > W - e.r) {
                                e.x = W - e.r;
                                e.vx = -Math.abs(e.vx || 60);
                            }

                            // NEW: Vertical clamping to keep void champion in playfield
                            if (e.y < e.r) {
                                e.y = e.r;
                                if (e.ramming && e.dashVY < 0) e.dashVY = Math.abs(e.dashVY);
                            } else if (e.y > H - e.r) {
                                e.y = H - e.r;
                                if (e.ramming && e.dashVY > 0) e.dashVY = -Math.abs(e.dashVY);
                            }
                        } else if (!e.isOrbiter) {
                            // Apply status effect movement overrides
                            if (firePanicMovement) {
                                e.x += firePanicMovement.x;
                                e.y += firePanicMovement.y;
                            } else if (poisonDrunkMovement) {
                                e.x += poisonDrunkMovement.x;
                                e.y += poisonDrunkMovement.y;
                            } else {
                                // Normal default movement
                                e.x += (e.vx || 0) * speedMultiplier * dt;
                                e.y += e.v * verticalSpeedMultiplier * dt;
                            }
                        } else {
                            // Smooth following behavior for orbiters instead of rigid orbital motion
                            let orbitTarget = null;
                            if (e.orbitTargetId) {
                                orbitTarget = store.enemies.find(en => en.id === e.orbitTargetId && !en.dead);
                            }
                            // Don't fall back to store.boss - orbiters should die with their parent
                            
                            if (orbitTarget) {
                                // Calculate desired position around target using angle
                                e.orbitAngle += e.orbitSpeed * speedMultiplier * dt * 0.5; // Slower rotation
                                const desiredX = orbitTarget.x + e.orbitRadius * Math.cos(e.orbitAngle);
                                const desiredY = orbitTarget.y + e.orbitRadius * Math.sin(e.orbitAngle);
                                
                                // Smoothly interpolate to desired position with damping
                                const followSpeed = 8.0; // Higher = snappier, lower = more laggy/floaty
                                const dx = desiredX - e.x;
                                const dy = desiredY - e.y;
                                
                                e.x += dx * followSpeed * dt;
                                e.y += dy * followSpeed * dt;
                            } else {
                                e.dead = true;
                            }
                        }
                        if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
                    }

                    if (e.jugFearTimer > 0) {
                        const dxFear = e.x - store.player.x;
                        const dyFear = e.y - store.player.y;
                        const distFear = Math.sqrt(dxFear * dxFear + dyFear * dyFear) || 1;
                        const fleeSpeed = Math.max(90, (e.v || 60) * 1.9);
                        e.x += (dxFear / distFear) * fleeSpeed * dt;
                        e.y += (dyFear / distFear) * fleeSpeed * dt * 0.6;
                    }

                    if (e.stormShockTimer > 0) {
                        e.x += (Math.random() - 0.5) * 35 * dt;
                        e.y += (Math.random() - 0.5) * 35 * dt;
                    }

                    const boundaryMargin = e.r || 15;
                    e.x = Math.max(boundaryMargin, Math.min(W - boundaryMargin, e.x));
                    if (!e.topClampDelay || e.topClampDelay <= 0) {
                        if (e.y < boundaryMargin) {
                            e.y = boundaryMargin;
                        }
                    }

                    const fireRateMult = e.cubeBurglarFireRateMultiplier || 1;
                    if (e.fireT > 0) e.fireT -= dt * fireRateMult;
                    const fireChance = Math.min(1, (e.fireRateChance || 0) * fireRateMult);
                    if (e.fireT <= 0 && e.y > 0 && Math.random() < fireChance) {
                        const damageMult = e.damageMult || 1;
                        switch (e.type) {
                            case 'hunter': {
                                const a = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                const bullet = getEBulletFromPool({ x: e.x, y: e.y, vx: Math.cos(a) * 180, vy: Math.sin(a) * 180, r: 3, col: e.color, dmg: 6 * dmgScale * damageMult });
                                empowerEnemyProjectile(e, bullet);
                                store.eBullets.push(bullet);
                                e.fireT = 1; break;
                            }
                            case 'phantom': {
                                const bullet = getEBulletFromPool({ x: e.x, y: e.y, vx: 0, vy: 180, r: 3, col: e.color, dmg: 5 * dmgScale * damageMult });
                                empowerEnemyProjectile(e, bullet);
                                store.eBullets.push(bullet);
                                e.fireT = e.fireCooldown; break;
                            }
                            case 'mech': {
                                e.attackPhase = (e.attackPhase || 0) + 1;
                                // Changed from 50/50 to 85% lob attacks, 15% shoulder cannons for more frequent lobs
                                if (e.attackPhase % 7 === 1) {
                                    // Shoulder cannon attack (less frequent now)
                                    const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                                    const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                                    {
                                        const bulletLeft = { x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult };
                                        empowerEnemyProjectile(e, bulletLeft);
                                        store.eBullets.push(bulletLeft);
                                    }
                                    const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                                    {
                                        const bulletRight = { x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale * damageMult };
                                        empowerEnemyProjectile(e, bulletRight);
                                        store.eBullets.push(bulletRight);
                                    }
                                } else {
                                    // Lob attack with randomized target location (more frequent now)
                                    // Limit target area to stay on screen with reasonable arc
                                    const randomOffsetX = (Math.random() - 0.5) * 300; // Reduced spread to 300 pixels
                                    const targetX = Math.max(80, Math.min(W - 80, store.player.x + randomOffsetX)); // Keep well within bounds

                                    // Limit Y coordinate to prevent extreme arcs
                                    const minY = Math.max(H * 0.5, e.y + 100); // Don't go too high above the mech
                                    const maxY = H - 80;   // Stop well above bottom
                                    const targetY = minY + Math.random() * (maxY - minY);

                                    const dx = targetX - e.x;
                                    const dy = targetY - e.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);

                                    // Much slower projectile for visibility and reasonable arc
                                    const timeToTarget = Math.max(1.5, dist / 120); // Slower speed = 120 instead of 180
                                    const gravity = 250; // Reduced gravity for gentler arc
                                    const vx = dx / timeToTarget;
                                    const vy = (dy - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;

                                    const lob = {
                                        x: e.x, y: e.y, vx: vx, vy: vy, r: 6,
                                        col: '#40e0d0', dmg: 18 * dmgScale * damageMult,
                                        gravity: gravity, isMechVolley: true, sourceId: e.id,
                                        targetX: targetX, targetY: targetY
                                    };
                                    empowerEnemyProjectile(e, lob);
                                    store.eBullets.push(lob);
                                }
                                e.fireT = 0.8; break; // Much more frequent attacks - reduced from 1.2 to 0.8
                            }
                            case 'mech_elite': {
                                e.attackPhase = (e.attackPhase || 0) + 1;
                                // Elite mech: sparkler attacks + enhanced lobs + shoulder cannons
                                if (e.attackPhase % 5 === 1) {
                                    // Sparkler burst - multi-directional spread with visual flair
                                    const sparklerCount = 12;
                                    const baseAngle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                    for (let i = 0; i < sparklerCount; i++) {
                                        const spreadAngle = (i / sparklerCount) * Math.PI * 2;
                                        const finalAngle = baseAngle + (spreadAngle - Math.PI);
                                        const speed = 140 + Math.random() * 40;
                                        const sparkler = {
                                            x: e.x,
                                            y: e.y,
                                            vx: Math.cos(finalAngle) * speed,
                                            vy: Math.sin(finalAngle) * speed,
                                            r: 3,
                                            col: '#ffff00',
                                            dmg: 14 * dmgScale * damageMult,
                                            life: 2.5,
                                            isSparkler: true
                                        };
                                        empowerEnemyProjectile(e, sparkler);
                                        store.eBullets.push(sparkler);
                                    }
                                } else if (e.attackPhase % 5 === 3) {
                                    // Enhanced shoulder cannon attack
                                    const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                                    const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                                    {
                                        const bulletLeft = { x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 180, vy: Math.sin(angleLeft) * 180, r: 5, col: '#ff0044', dmg: 16 * dmgScale * damageMult };
                                        empowerEnemyProjectile(e, bulletLeft);
                                        store.eBullets.push(bulletLeft);
                                    }
                                    const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                                    {
                                        const bulletRight = { x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 180, vy: Math.sin(angleRight) * 180, r: 5, col: '#ff0044', dmg: 16 * dmgScale * damageMult };
                                        empowerEnemyProjectile(e, bulletRight);
                                        store.eBullets.push(bulletRight);
                                    }
                                } else {
                                    // Enhanced lob attack
                                    const randomOffsetX = (Math.random() - 0.5) * 300;
                                    const targetX = Math.max(80, Math.min(W - 80, store.player.x + randomOffsetX));
                                    const minY = Math.max(H * 0.5, e.y + 100);
                                    const maxY = H - 80;
                                    const targetY = minY + Math.random() * (maxY - minY);
                                    const dx = targetX - e.x;
                                    const dy = targetY - e.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const timeToTarget = Math.max(1.5, dist / 120);
                                    const gravity = 250;
                                    const vx = dx / timeToTarget;
                                    const vy = (dy - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;
                                    const lob = {
                                        x: e.x, y: e.y, vx: vx, vy: vy, r: 7,
                                        col: '#9d00ff', dmg: 22 * dmgScale * damageMult,
                                        gravity: gravity, isMechVolley: true, sourceId: e.id,
                                        targetX: targetX, targetY: targetY
                                    };
                                    empowerEnemyProjectile(e, lob);
                                    store.eBullets.push(lob);
                                }
                                e.fireT = 0.7; break; // Faster than normal mech
                            }
                            case 'angler': {
                                const a = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                const bullet = { x: e.x, y: e.y, vx: Math.cos(a) * 120, vy: Math.sin(a) * 120, r: 4, col: e.color, dmg: 15 * dmgScale * damageMult, life: 5 };
                                empowerEnemyProjectile(e, bullet);
                                store.eBullets.push(bullet);
                                e.fireT = 2.5; break;
                            }
                            case 'manta': {
                                for (let i = -1; i <= 1; i++) {
                                    const angle = (90 + i * 30) * Math.PI / 180;
                                    const bolt = { x: e.x, y: e.y, vx: Math.cos(angle) * 150, vy: Math.sin(angle) * 150, r: 3, col: e.color, dmg: 12 * dmgScale * damageMult };
                                    empowerEnemyProjectile(e, bolt);
                                    store.eBullets.push(bolt);
                                }
                                e.fireT = 2.8; break;
                            }
                            case 'shadow_champion': {
                                const boss = store.boss && store.boss.behavior === 'shadow_clone' ? store.boss : null;
                                const enrageThreshold = e.enrageThreshold ?? 0.45;
                                const bossRatio = boss && boss.hpMax ? boss.hp / boss.hpMax : 1;
                                const isEnraged = boss ? (boss.isEnraged || bossRatio <= enrageThreshold) : true;
                                const attackMult = (e.damageMult || 1) * (isEnraged ? 1.2 : 1);
                                const angle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                if (Math.random() < 0.45) {
                                    const volley = isEnraged ? 6 : 4;
                                    const spread = isEnraged ? 0.18 : 0.14;
                                    for (let i = 0; i < volley; i++) {
                                        const offset = (i - (volley - 1) / 2) * spread;
                                        const speed = 320 + (isEnraged ? 90 : 60);
                                        const shard = getEBulletFromPool({
                                            x: e.x + Math.cos(angle) * (e.r * 0.3),
                                            y: e.y + Math.sin(angle) * (e.r * 0.3),
                                            vx: Math.cos(angle + offset) * speed,
                                            vy: Math.sin(angle + offset) * speed,
                                            r: isEnraged ? 6 : 5,
                                            col: isEnraged ? '#a89fff' : '#d6dbff',
                                            dmg: 16 * attackMult,
                                            life: 1.6
                                        });
                                        empowerEnemyProjectile(e, shard);
                                        store.eBullets.push(shard);
                                    }
                                    e.fireT = isEnraged ? 1.05 : 1.35;
                                } else {
                                    e.state = 'dash';
                                    const dashSpeed = isEnraged ? 520 : 440;
                                    e.dashVX = Math.cos(angle) * dashSpeed;
                                    e.dashVY = Math.sin(angle) * dashSpeed;
                                    e.dashTimer = 0.32;
                                    addShadowEcho(e.x, e.y);
                                    e.fireT = isEnraged ? 1.25 : 1.55;
                                }
                                break;
                            }
                            case 'void_champion': {
                                if (e.nextPattern === 'beam') {
                                    const baseAngle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                    const spreads = [-0.25, 0, 0.25];
                                    spreads.forEach((offset, idx) => {
                                        const finalAngle = baseAngle + offset;
                                        const speed = 210 + idx * 25;
                                        const beam = {
                                            x: e.x,
                                            y: e.y,
                                            vx: Math.cos(finalAngle) * speed,
                                            vy: Math.sin(finalAngle) * speed,
                                            r: 6,
                                            col: '#ffb3ff',
                                            dmg: 18 * dmgScale * damageMult,
                                            life: 5
                                        };
                                        empowerEnemyProjectile(e, beam);
                                        store.eBullets.push(beam);
                                    });
                                    e.nextPattern = 'burst';
                                } else {
                                    const bolts = 8;
                                    for (let i = 0; i < bolts; i++) {
                                        const angle = (i / bolts) * Math.PI * 2;
                                        const bolt = {
                                            x: e.x,
                                            y: e.y,
                                            vx: Math.cos(angle) * 150,
                                            vy: Math.sin(angle) * 150,
                                            r: 5,
                                            col: '#de6cff',
                                            dmg: 12 * dmgScale * damageMult,
                                            life: 4
                                        };
                                        empowerEnemyProjectile(e, bolt);
                                        store.eBullets.push(bolt);
                                    }
                                    e.nextPattern = 'beam';
                                    // Trigger orbiting shards to fire immediately
                                    store.enemies.forEach(minion => {
                                        if (minion.orbitTargetId === e.id && !minion.dead) {
                                            minion.fireT = Math.min(minion.fireT || 0, 0.1);
                                        }
                                    });
                                }
                                e.fireT = e.fireCooldown || 1.8;
                                break;
                            }
                            case 'void_champion_orb': {
                                const angle = Math.atan2(store.player.y - e.y, store.player.x - e.x);
                                const speed = 220;
                                const module = e.attackModule || 'default';
                                const abilityTheme = e.abilityTheme || getChampionMinionAbilityTheme(module);
                                const projectileColor = abilityTheme?.trail || abilityTheme?.ring || e.color || '#ff6ad5';
                                const orb = {
                                    x: e.x,
                                    y: e.y,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    r: 4,
                                    col: projectileColor,
                                    dmg: 6 * dmgScale * damageMult,
                                    life: 4
                                };
                                empowerEnemyProjectile(e, orb);
                                store.eBullets.push(orb);
                                e.fireT = e.fireCooldown || 1.1;
                                break;
                            }
                            default: {
                                const bullet = { x: e.x, y: e.y, vx: 0, vy: 150, r: 3, col: e.color, dmg: 5 * dmgScale * damageMult };
                                empowerEnemyProjectile(e, bullet);
                                store.eBullets.push(bullet);
                                e.fireT = .5;
                            }
                        }
                    }

                    if (e.y > H + 30 || e.x < -30 || e.x > W + 30) {
                        if (e.type !== 'cube_burglar') {
                            e.dead = true;
                        } else {
                            // Cube Burglar: clamp back to screen instead of dying
                            e.x = clamp(e.x, e.r + 10, W - e.r - 10);
                            e.y = clamp(e.y, e.r + 10, H - e.r - 10);
                        }
                    }
                    if (!store.isDamageOff && collide(e, store.player)) {
                        resolvePlayerEnemyCollision(e, { separationForce: 20 });
                    }
                });

                // BOSS flame collision (reuse pre-filtered active flames)
                if (store.boss && !store.boss.dead && flameCount > 0) {
                    for (let f = 0; f < flameCount; f++) {
                        const flame = activeFlames[f];

                        const dx = flame.x - store.boss.x;
                        const dy = flame.y - store.boss.y;

                        // Early culling for boss collision
                        if (Math.abs(dx) > 150 || Math.abs(dy) > 150) continue;

                        const distSq = dx * dx + dy * dy;
                        const collisionRadius = Math.max(10, flame.size + store.boss.r - 50);
                        const collisionRadiusSq = collisionRadius * collisionRadius;

                        if (distSq < collisionRadiusSq) {
                            store.boss.stunTimer = Math.max(store.boss.stunTimer || 0, 0.3);
                            const bossFlameDmg = flame.damage * 0.5;
                            const result = applyBossDamage(store.boss, bossFlameDmg, { point: { x: flame.x, y: flame.y } });

                            if (store.player.vampirism > 0 && result.amount > 0) {
                                let healAmount = result.amount * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.3);
                                healAmount = Math.min(healAmount, 2);
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }

                            store.boss.isBurning = true;
                            setTimeout(() => { if (store.boss) store.boss.isBurning = false; }, 100);
                            break; // Exit early after first collision
                        }
                    }
                }

                rebuildEnemySpatialIndex();
                const bossTarget = store.boss && !store.boss.dead ? store.boss : null;
                const bulletStepState = { autoBlinkTriggered: false };

                for (let bi = 0; bi < store.bullets.length; bi++) {
                    updatePlayerProjectile(store.bullets[bi], dt, bossTarget, bulletStepState);
                }

                if (store.fragmentProjectiles && store.fragmentProjectiles.length) {
                    for (let fi = 0; fi < store.fragmentProjectiles.length; fi++) {
                        updatePlayerProjectile(store.fragmentProjectiles[fi], dt, bossTarget, bulletStepState);
                    }
                }

                updateStarProjectiles(dt);

                const p = store.player;
                const healthRatio = p.hp / p.hpMax;
                const lowHealthThreshold = 0.35;

                if (healthRatio < lowHealthThreshold) {
                    if (!store.world.isLowHealth) {
                        store.world.isLowHealth = true;
                        store.heartbeatT = 5.0;
                        // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                        store.activeEffects.push(createEffect("heartbeatPulse"));
                    } else {
                        if (store.heartbeatT > 0) {
                            store.heartbeatT -= dt;
                        } else {
                            store.heartbeatT = 5.0;
                            // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                            store.activeEffects.push(createEffect("heartbeatPulse"));
                        }
                    }
                } else if (store.world.isLowHealth) {
                    store.world.isLowHealth = false;
                }

                // Optimized cleanup with object pooling
                removeDeadObjects(store.bullets, bullet => bulletPool.release(bullet));
                removeDeadObjects(store.fragmentProjectiles);
                removeDeadObjects(store.eBullets, bullet => returnEBulletToPool(bullet));

                // Efficient removal for other arrays
                removeDeadObjects(store.enemies, enemy => {
                    // Clean up PixiJS graphics for mechs
                    if (enemy.pixiGraphics) {
                        enemy.pixiGraphics.destroy();
                        enemy.pixiGraphics = null;
                    }
                });
                removeDeadObjects(store.shadowHounds);
                if (store.championMinions && store.championMinions.length) {
                    removeDeadObjects(store.championMinions);
                }
                removeDeadObjects(store.powerups);
                removeDeadObjects(store.mines);
                removeDeadObjects(store.missiles);
                removeDeadObjects(store.lasers);
                removeDeadObjects(store.flameParticles);
                removeDeadObjects(store.lightningBolts);
                removeDeadObjects(store.empNovas);
                removeDeadObjects(store.flamePulses);
                removeDeadObjects(store.shadowEchoes);
                removeDeadObjects(store.timeShards);
                if (store.playerChampion && store.playerChampion.dead) {
                    store.playerChampion = null;
                }

                // Handle active effects separately (different property name)
                compactInactiveEffects(store.activeEffects);
                
                // Cap active effects to prevent overdraw/performance issues (especially with dense enemy clusters)
                const MAX_ACTIVE_EFFECTS = 120;
                if (store.activeEffects.length > MAX_ACTIVE_EFFECTS) {
                    // Keep most recent effects, drop oldest ones
                    store.activeEffects.splice(0, store.activeEffects.length - MAX_ACTIVE_EFFECTS);
                }

                const hasNonBurglarEnemies = store.enemies.some(enemy => enemy && !enemy.dead && enemy.type !== 'cube_burglar');
                // NOTE: Cube Burglar does NOT block progression - it persists across waves and bosses
                if (!store.boss && !hasNonBurglarEnemies) {
                    // Add some delay before starting next wave to prevent rapid cycling
                    if (!store.world.waveTransitionTimer) {
                        store.world.waveTransitionTimer = performance.now();
                        return;
                    }

                    // Wait at least 0.5 seconds before progressing to next wave
                    if (performance.now() - store.world.waveTransitionTimer < 500) {
                        return;
                    }

                    // console.log(`Wave ${store.world.wave} completed, transitioning to wave ${store.world.wave + 1}`);

                    if (store.world.waveStartTime > 0 && store.world.wave > 1) {
                        const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;

                        // Guaranteed minimum collar stacks for any reasonable clear
                        let collarStacksToAdd = 0;
                        sanitizeCollarStacks();

                        if (waveClearTime < 2) {
                            // Ultra-instant clear: +9 collar stacks (addresses missing 9 stack issue)
                            collarStacksToAdd = 9;
                            store.world.enemyDensityBonus *= 1.15;
                            store.world.xpMultiplier *= 1.1;
                            announce("ðŸ’¥ ULTRA-INSTANT CLEAR! COLLAR CRUSHES +9 ðŸ’¥");
                        } else if (waveClearTime < 4) {
                            // Instant clear: +6 collar stacks
                            collarStacksToAdd = 6;
                            store.world.enemyDensityBonus *= 1.1;
                            store.world.xpMultiplier *= 1.07;
                            announce("âš¡ INSTANT WAVE CLEAR! COLLAR TIGHTENS +6 âš¡");
                        } else if (waveClearTime < 8) {
                            // Fast clear: +3 collar stacks
                            collarStacksToAdd = 3;
                            store.world.enemyDensityBonus *= 1.05;
                            store.world.xpMultiplier *= 1.03;
                            announce("âš¡ FAST WAVE CLEAR! COLLAR TIGHTENS +3 âš¡");
                        } else if (waveClearTime < 12) {
                            // Normal clear: +1 collar stack
                            collarStacksToAdd = 1;
                            announce("âš¡ COLLAR TIGHTENS +1 âš¡");
                        } else if (waveClearTime > 20) {
                            // Very slow clear: reset collar stacks (except during Death Engine fight)
                            const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
                            if (!isDeathEngineFight) {
                                const loosenedStacks = Math.max(0, sanitizeCollarStacks() - 2);
                                setCollarStacks(loosenedStacks);
                                announce("ðŸŒ SLOW CLEAR - COLLAR LOOSENS");
                            } else {
                                announce("THE DEATH ENGINE'S CURSE MAINTAINS THE COLLAR!");
                            }
                        }

                        // Add collar stacks only after 2nd boss is defeated - let first two bosses play normally
                        collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
                        if (store.world.bosses >= 2) {
                            if (collarStacksToAdd > 0) {
                                scheduleCollarIncrease(collarStacksToAdd);
                            } else {
                                approachCollarTarget();
                            }
                        }
                    }

                    store.world.wave++;
                    store.world.waveTransitionTimer = null; // Reset timer

                    const hpBonus = 1;
                    store.player.hpMax += hpBonus;
                    store.player.hp += hpBonus;
                    initWave();
                } else {
                    // Reset wave transition timer if there are still enemies or boss
                    store.world.waveTransitionTimer = null;
                }

                let xpNeeded = Math.floor(store.world.level * 100 * store.world.xpMultiplier * (store.world.level >= 8 ? 1.3 : store.world.level >= 4 ? 1.1 : 1) * (store.world.wave > 10 ? 1.3 : 1));
                if (store.world.xp >= xpNeeded) {
                    store.world.xp -= xpNeeded;
                    store.world.level++;
                    levelUp();
                }

                // Collar decay system - prevent infinite stacking
                if (!store.world.collarDecayTimer) {
                    store.world.collarDecayTimer = 0;
                }
                store.world.collarDecayTimer += dt;

                // Apply gradual collar decay every 10 seconds if stacks are high (only after 2nd boss, except during Death Engine fight)
                if (store.world.collarDecayTimer >= 10 && store.world.bosses >= 2) {
                    store.world.collarDecayTimer = 0;

                    // Don't decay collar stacks during Death Engine fight due to its intermission phases
                    const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';

                    if (!isDeathEngineFight) {
                        const currentStacks = sanitizeCollarStacks();
                        if (currentStacks > 20) {
                            // Decay faster when collar stacks are very high
                            const decay = Math.max(0.5, currentStacks * 0.02);
                            const newStacks = Math.max(0, currentStacks - decay);
                            setCollarStacks(newStacks);
                            // High collar stacks decay applied
                        } else if (currentStacks > 5) {
                            // Gentle decay for moderate stacks
                            const newStacks = Math.max(0, currentStacks - 0.3);
                            setCollarStacks(newStacks);
                        }
                    }
                }

                if (store.player.hp <= 0) {
                    // Check for nano charge before death
                    if (!triggerNanoSaveCharge()) {
                        handleGameOver();
                    }
                }
            }





            // PERFORMANCE: Efficient dead object removal (300-500% faster than filter)
            function removeDeadObjects(array, disposer) {
                let writeIndex = 0;
                for (let readIndex = 0; readIndex < array.length; readIndex++) {
                    const item = array[readIndex];
                    if (!item || item.dead) {
                        if (item && disposer) {
                            disposer(item);
                        }
                        continue;
                    }

                    if (writeIndex !== readIndex) {
                        array[writeIndex] = item;
                    }
                    writeIndex++;
                }

                if (writeIndex < array.length) {
                    array.length = writeIndex;
                }
            }

            function compactInactiveEffects(effects) {
                let writeIndex = 0;
                for (let readIndex = 0; readIndex < effects.length; readIndex++) {
                    const effect = effects[readIndex];
                    if (effect && effect.isActive !== false) {
                        if (writeIndex !== readIndex) {
                            effects[writeIndex] = effect;
                        }
                        writeIndex++;
                    }
                }

                if (writeIndex < effects.length) {
                    effects.length = writeIndex;
                }
            }

            function ensureSkillTrackingLists() {
                const p = store.player;
                if (!p) return;

                if (!Array.isArray(p.learnedSkills)) {
                    if (p.learnedSkills && typeof p.learnedSkills === 'object') {
                        const legacyKeys = Object.keys(p.learnedSkills).filter(key => p.learnedSkills[key]);
                        p.learnedSkills = legacyKeys;
                    } else {
                        p.learnedSkills = [];
                    }
                }
            }

            // Helper function to ensure progression tracking is initialized
            function initializeProgressionTracking() {
                const p = store.player;
                if (!p) return;

                if (typeof p.totalProgressionPoints !== 'number') p.totalProgressionPoints = 0;
                if (typeof p.unspentProgressionPoints !== 'number') p.unspentProgressionPoints = 0;
                if (typeof p.skillPointsSpent !== 'number') p.skillPointsSpent = 0;
                if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
                    p.signatureAbilities = {};
                }
                p.signatureAbility = Object.keys(p.signatureAbilities).length > 0;

                ensureSkillTrackingLists();

                // Ensure player always has skill points available for purchases (controlled by progression logic)
                if (typeof p.skillPoints !== 'number' || p.skillPoints <= 0) {
                    p.skillPoints = 10; // Generous skill point pool, but availability controlled by progression
                }
            }

            // Helper function to spend progression points when abilities are successfully added
            function spendProgressionPoint() {
                initializeProgressionTracking();
                if (store.player.unspentProgressionPoints > 0) {
                    store.player.unspentProgressionPoints -= 1;
                    return true;
                }
                return false;
            }

            // Helper function for progression logic (used by both boss defeat and upgrade hangar button)
            function checkProgressionLogic(awardPoint = false) {
                // Initialize progression tracking
                initializeProgressionTracking();

                // Award progression point if this is from boss defeat
                if (awardPoint) {
                    store.player.totalProgressionPoints += 1;
                    store.player.unspentProgressionPoints += 1;
                }

                const playerTotalPts = store.player.totalProgressionPoints;
                const playerUnspentPts = store.player.unspentProgressionPoints;
                const currentSpec = store.player.pilotGenome;
                const currentSubclass = store.player.subclass;

                // Progression logic following Python pattern
                if (playerTotalPts === 1 && playerUnspentPts > 0) {
                    // First boss - open class select
                    if (awardPoint) store.player.pilotGenome = 'pending';
                    setTimeout(showPilotSelect, awardPoint ? 1000 : 0);
                    return true;
                } else if (playerTotalPts > 1 && currentSpec && currentSpec !== 'pending' && !currentSubclass && playerUnspentPts > 0) {
                    // Second+ boss with class selected but no subclass - open subclass select
                    setTimeout(showSubclassSelect, awardPoint ? 1500 : 0);
                    return true;
                } else if (playerTotalPts > 2 && currentSpec && currentSpec !== 'pending' && currentSubclass && playerUnspentPts > 0) {
                    // Third+ boss with class and subclass - open skill tree
                    setTimeout(showSkillTreeModal, awardPoint ? 1500 : 0);
                    return true;
                }

                return false; // No progression available
            }

            function applyRapidEnemyAdaptation(enemy, now = performance.now()) {
                const world = store.world;
                if (!world || !enemy) return;

                const spawnAt = ensureFiniteNumber(enemy.spawnedAt, now);
                const killTime = ensureFiniteNumber((now - spawnAt) / 1000, 0);
                if (!Number.isFinite(killTime) || killTime <= 0 || killTime > 2.5) return;

                const hits = ensureFiniteNumber(enemy.hitCount, 0);
                const oneShot = hits <= 1;
                const originX = ensureFiniteNumber(enemy.spawnX, enemy.x);
                const originY = ensureFiniteNumber(enemy.spawnY, enemy.y);
                const dx = ensureFiniteNumber(enemy.x, originX) - originX;
                const dy = ensureFiniteNumber(enemy.y, originY) - originY;
                const traveled = Math.hypot(dx, dy);
                const travelThreshold = Math.max(100, (enemy.r || 12) * 4);

                if (!oneShot) return;
                if (traveled >= travelThreshold) return;
                if ((store.world?.wave || 1) < 3) return;

                const rawMultiplier = Math.min(12, Math.max(1.2, 6 / (Math.max(0.18, killTime) * 1.25)));
                const appliedMultiplier = 1 + (rawMultiplier - 1) * 0.45; // Apply damping so scaling is gentler
                const healthBaseline = ensureFiniteNumber(world.enemyHealthBonus, 1);
                const densityBaseline = normalizeEnemyDensityBonus(world.enemyDensityBonus);
                const bossCount = ensureFiniteNumber(world.bosses, 0);
                const waveIndex = ensureFiniteNumber(world.wave, 1);

                let dynamicCap;
                if (bossCount <= 1) {
                    dynamicCap = 1.6;
                } else if (bossCount === 2) {
                    dynamicCap = 1.9;
                } else if (bossCount === 3) {
                    dynamicCap = 2.2;
                } else {
                    dynamicCap = Math.min(3.0, 2.2 + (bossCount - 3) * 0.25);
                }
                dynamicCap += Math.min(0.5, Math.max(0, waveIndex - 12) * 0.02);
                dynamicCap = Math.min(3.0, Math.max(1.2, dynamicCap));

                const increaseTargetLinear = healthBaseline + Math.max(0, (appliedMultiplier - 1) * 0.28);
                const increaseTargetScaled = healthBaseline * (1 + Math.max(0, (appliedMultiplier - 1) * 0.35));
                const desiredUpper = Math.min(dynamicCap, Math.min(increaseTargetLinear, increaseTargetScaled));
                const desiredLower = Math.min(dynamicCap, Math.max(1, desiredUpper));
                const growthTarget = ensureFiniteNumber(desiredLower, healthBaseline);

                let newHealthBonus = healthBaseline;
                if (healthBaseline > growthTarget + 0.01) {
                    const overshoot = healthBaseline - growthTarget;
                    const dropStep = Math.max(0.04, Math.min(0.35, overshoot * 0.6));
                    newHealthBonus = Math.max(growthTarget, healthBaseline - dropStep);
                } else if (growthTarget > healthBaseline + 0.01) {
                    const gain = growthTarget - healthBaseline;
                    const riseStep = Math.max(0.02, Math.min(0.3, gain * 0.5));
                    newHealthBonus = Math.min(dynamicCap, healthBaseline + riseStep);
                }

                newHealthBonus = Math.max(1, Math.min(dynamicCap, ensureFiniteNumber(newHealthBonus, healthBaseline)));

                const currentDensity = densityBaseline;
                let densityCap;
                if (bossCount <= 1) {
                    densityCap = 1.35;
                } else if (bossCount === 2) {
                    densityCap = 1.55;
                } else if (bossCount === 3) {
                    densityCap = 1.75;
                } else {
                    densityCap = 1.75 + (bossCount - 3) * 0.2;
                }
                densityCap += Math.min(0.35, Math.max(0, waveIndex - 15) * 0.02);
                densityCap = Math.min(2.5, Math.max(1.2, densityCap));

                const densityFloorBase = bossCount > 2 ? 0.95 : 0.85;
                const densityFloor = Math.max(
                    MIN_ENEMY_DENSITY_BONUS,
                    Math.min(densityFloorBase, densityCap - 0.25)
                );

                const rawDensityGain = Math.max(0, appliedMultiplier - 1);
                const densityGain = Math.min(0.45, rawDensityGain * 0.08);
                let desiredDensity = Math.min(densityCap, currentDensity + densityGain);

                if (newHealthBonus < healthBaseline - 0.01) {
                    const healthDrop = Math.min(0.8, healthBaseline - newHealthBonus);
                    const densityDropTarget = currentDensity - Math.max(0.05, healthDrop * 0.3);
                    desiredDensity = Math.min(desiredDensity, densityDropTarget);
                }

                desiredDensity = Math.max(densityFloor, desiredDensity);

                let newDensity = currentDensity;
                if (desiredDensity > currentDensity + 0.01) {
                    const riseStep = Math.max(0.015, Math.min(0.16, (desiredDensity - currentDensity) * 0.5));
                    newDensity = Math.min(densityCap, currentDensity + riseStep);
                } else if (desiredDensity < currentDensity - 0.01) {
                    const dropStep = Math.max(0.02, Math.min(0.2, (currentDensity - desiredDensity) * 0.55));
                    newDensity = Math.max(densityFloor, currentDensity - dropStep);
                }

                world.enemyHealthBonus = newHealthBonus;
                world.enemyDensityBonus = normalizeEnemyDensityBonus(newDensity);
                world.lastThreatScale = Math.max(world.lastThreatScale || 1, world.enemyHealthBonus);

                if (now - world.lastEnemyOverdriveAnnounce > 1800) {
                    announce(`âš ï¸ ENEMY OVERDRIVE x${appliedMultiplier.toFixed(2)} âš ï¸`);
                    world.lastEnemyOverdriveAnnounce = now;
                }
            }

            function handleBossDefeat() {
                const activeBoss = store.boss;
                const snapshot = activeBoss || store.lastBossSnapshot;
                if (!snapshot) {
                    return;
                }

                const world = store.world || {};
                const completedTokens = world.completedBossTokens || (world.completedBossTokens = Object.create(null));
                const activeToken = world.activeBossToken || null;
                const snapshotToken = snapshot.instanceId || snapshot.id || snapshot._instanceId || null;
                const fallbackToken = snapshot.behavior || snapshot.name || null;
                const awardToken = snapshotToken || activeToken || fallbackToken || `legacy-${world.wave || 0}-${world.bosses || 0}`;

                if (completedTokens[awardToken]) {
                    return;
                }

                if (activeToken && awardToken !== activeToken) {
                    return;
                }

                const bossId = snapshotToken || fallbackToken || snapshot.name || 'UNKNOWN';

                const playerRef = store.player || {};
                const fallbackX = Number.isFinite(playerRef.x) ? playerRef.x : W / 2;
                const fallbackY = Number.isFinite(playerRef.y) ? playerRef.y : H / 2;
                const bossX = ensureFiniteNumber(snapshot.x, fallbackX);
                const bossY = ensureFiniteNumber(snapshot.y, fallbackY);
                const bossName = snapshot.name || 'UNKNOWN';

                store.lastBossSnapshot = { x: bossX, y: bossY, name: bossName, id: bossId, instanceId: awardToken };
                store.lastBossDefeatId = awardToken;
                completedTokens[awardToken] = true;
                world.activeBossToken = null;
                world.lastBossAwardToken = awardToken;
                
                // Check boss status effects and spawn appropriate death visuals
                if (activeBoss) {
                    const bossDeathType = getStackDeathType(activeBoss, {
                        fallbackElement: activeBoss.lastStackHitElement || null
                    });
                    
                    // Spawn status effect death visuals before marking dead
                    if (bossDeathType === 'ice') {
                        spawnIceShards(bossX, bossY, {
                            enemyRadius: activeBoss.r || 40
                        });
                    } else if (bossDeathType === 'fire') {
                        spawnFireWipeDeath(bossX, bossY, {
                            enemyRadius: activeBoss.r || 40,
                            baseColor: activeBoss.color || '#ff7c2e'
                        });
                    } else if (bossDeathType === 'poison') {
                        spawnPoisonDeath(bossX, bossY, {
                            enemyRadius: activeBoss.r || 40,
                            baseColor: activeBoss.color
                        });
                    }
                    
                    activeBoss.dead = true;
                    // Clean up PixiJS resources for Vibemaster
                    if (activeBoss.pixiContainer) {
                        activeBoss.pixiContainer.destroy({ children: true });
                        activeBoss.pixiContainer = null;
                    }
                }

                const now = performance.now();
                const bossSpawnTime = ensureFiniteNumber(store.world.bossSpawnTime, now);
                const fightDuration = ensureFiniteNumber((now - bossSpawnTime) / 1000, 0);
                const rawRapidKillMultiplier = fightDuration > 0 && fightDuration <= 2 ? Math.min(30, Math.max(1.4, 10 / (Math.max(0.1, fightDuration) * 1.25))) : 1;
                const bossOverdrive = rawRapidKillMultiplier > 1 ? 1 + (rawRapidKillMultiplier - 1) * 0.5 : 1;
                store.world.lastBossRapidKillMultiplier = bossOverdrive;

                // Use progression logic with point award
                checkProgressionLogic(true);

                const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                const scoreBonus = Math.floor(2000 * collarBonus);
                const goldBonus = Math.floor(25 * collarBonus);
                const xpBonus = Math.floor(100 * collarBonus);
                if (scoreBonus) store.world.score += scoreBonus;
                if (goldBonus) addWorldGold(goldBonus);
                if (xpBonus) awardXp(xpBonus); // Apply XP diminishing returns (bosses bypass wave limits)
                store.world.bosses++;
                if (store.goldenOrbs) {
                    store.goldenOrbs.length = 0;
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // COMPREHENSIVE BOSS CLEANUP: Clear all boss-related projectiles, effects, and hazards
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Clear poison puddles and slow fields (HIVE SOVEREIGN, GEMINI systems)
                if (store.poisonPuddles) {
                    store.poisonPuddles = [];
                }
                if (store.geminiSlowFields) {
                    store.geminiSlowFields = [];
                }
                
                // Clear all VIBEMASTER systems (rings, threads, guardians, distortion field, vacuum)
                store.vibemasterRings = [];
                store.vibemasterThreads = [];
                store.vibemasterGuardians = [];
                store.vibemasterDistortion = null;
                store.vibemasterVacuum = null;
                
                // Clear all boss projectiles: poison blobs, EMP novas, lightning bolts, flame pulses
                store.bullets = store.bullets.filter(b => {
                    if (b.type === 'poisonBlob') {
                        if (bulletPool) bulletPool.release(b);
                        return false;
                    }
                    return true;
                });
                
                // Clear all enemy bullets/attacks that originated from the boss
                store.eBullets = store.eBullets.filter(b => {
                    if (b && (b.enemySource === store.boss || (b.bossBullet && b.type))) {
                        if (store.eBulletPool && store.eBulletPool.push) {
                            store.eBulletPool.push(b);
                        }
                        return false;
                    }
                    return true;
                });
                
                // Clear EMP effects from boss attacks (esp. DEATH ENGINE)
                store.empNovas = [];
                
                // Clear lightning chains/bolts from boss attacks (esp. DEATH ENGINE)
                store.lightningBolts = [];
                
                // Clear flame pulses and related hazards
                store.flamePulses = [];
                store.mechPuddles = [];
                
                // Clear any lingering visual effects tied to boss
                store.activeEffects = store.activeEffects.filter(e => {
                    // Keep general effects, but clear boss-specific ones
                    if (e && e.bossBullet) return false;
                    return true;
                });

                store.boss = null;
                announce('âš¡ GUARDIAN DEFEATED âš¡');
                explode(bossX, bossY, true);

                if (bossName === 'SHADOW MIRROR') {
                    finalizeShadowChampionAfterBoss(bossX, bossY);
                }

                let healthBonusMultiplier = 1.0, announcedAdaptation = false;
                // Calculate collar stacks to add based on boss kill speed (more generous)
                let collarStacksToAdd = 0;
                sanitizeCollarStacks();

                if (fightDuration <= 2) {
                    const world = store.world;
                    const overdrive = Math.max(bossOverdrive, 1.35);
                    collarStacksToAdd = Math.min(120, Math.max(10, Math.ceil(overdrive * 3.5)));
                    announcedAdaptation = true;
                    if (world) {
                        const bossBaseline = ensureFiniteNumber(world.bossHealthBonus, 1);
                        const enemyBaseline = ensureFiniteNumber(world.enemyHealthBonus, 1);
                        const densityBaseline = normalizeEnemyDensityBonus(world.enemyDensityBonus);
                        world.bossHealthBonus = Math.min(5.0, bossBaseline * overdrive); // Cap at 5x multiplier
                        world.enemyHealthBonus = Math.min(2.5, enemyBaseline * (1 + (overdrive - 1) * 0.45)); // Cap at 2.5x multiplier
                        world.enemyDensityBonus = normalizeEnemyDensityBonus(densityBaseline * (1 + (overdrive - 1) * 0.22));
                    }
                    if (world && world.wave >= 15) {
                        world.consecutiveFastKills++;
                        if (world.consecutiveFastKills === 1) { world.fastKillBonus = 0.20; } else { world.fastKillBonus *= 2; }
                        healthBonusMultiplier = Math.max(1.4, 1.2 + (overdrive - 1) * 0.25 + world.fastKillBonus);
                        announce(`STREAK x${world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
                    } else {
                        healthBonusMultiplier = Math.max(1.4, 1.2 + (overdrive - 1) * 0.25);
                        announce("GUARDIANS ADAPTING RAPIDLY!");
                    }
                    announce(`ðŸ’¥ COLLAR CRUSHES +${collarStacksToAdd} | NEXT GUARDIAN x${overdrive.toFixed(1)} ðŸ’¥`);
                } else if (fightDuration <= 5) {
                    // Fast boss kill
                    collarStacksToAdd = Math.max(8, Math.floor(12 - (fightDuration * 1.5)));
                    announcedAdaptation = true;
                    if (store.world.wave >= 15) {
                        store.world.consecutiveFastKills++;
                        if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                        healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                        announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
                    } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
                    announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
                } else if (fightDuration < 8) {
                    // Decent boss kill
                    collarStacksToAdd = Math.max(3, Math.floor(10 - fightDuration));
                    announcedAdaptation = true;
                    healthBonusMultiplier = 1.15;
                    store.world.consecutiveFastKills = 0;
                    store.world.fastKillBonus = 0;
                    announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
                } else if (fightDuration <= 10) {
                    // Slow boss kill: minimal collar bonus
                    collarStacksToAdd = 1;
                    announcedAdaptation = true;
                    healthBonusMultiplier = 1.05;
                    store.world.consecutiveFastKills = 0;
                    store.world.fastKillBonus = 0;
                    announce(`âš¡ COLLAR TIGHTENS +${collarStacksToAdd} âš¡`);
                } else {
                    // Very slow kill: reset collar stacks and boss adaptation (except for DEATH ENGINE)
                    if (bossName !== 'DEATH ENGINE') {
                        setCollarStacks(0);
                        store.world.collarTargetStacks = 0;
                        store.world.bossHealthBonus = 1;
                        store.world.lastBossRapidKillMultiplier = 1;
                        store.world.enemyHealthBonus = Math.max(1, store.world.enemyHealthBonus * 0.85);
                        store.world.enemyDensityBonus = normalizeEnemyDensityBonus(store.world.enemyDensityBonus * 0.85);
                        store.world.lastEnemyOverdriveAnnounce = 0;
                        announce("ðŸ¢ BOSS STALEMATE - COLLAR RESET");
                    } else {
                        announce("THE DEATH ENGINE'S CURSE PERSISTS!");
                    }
                    store.world.consecutiveFastKills = 0;
                    store.world.fastKillBonus = 0;
                    healthBonusMultiplier = 1.0;
                }

                // Special handling for Death Engine - restore preserved collar stacks
                if (bossName === 'DEATH ENGINE' && store.world.deathEngineCollarStacks !== undefined) {
                    const originalStacks = ensureFiniteNumber(store.world.deathEngineCollarStacks, sanitizeCollarStacks());
                    const originalTarget = ensureFiniteNumber(store.world.deathEngineCollarTargetStacks, originalStacks);
                    setCollarStacks(Math.max(0, originalStacks));
                    store.world.collarTargetStacks = Math.max(store.world.collarStacks, originalTarget); // No cap
                    const addAfterRestore = ensureFiniteNumber(collarStacksToAdd, 0);
                    if (addAfterRestore > 0) {
                        scheduleCollarIncrease(addAfterRestore);
                    } else {
                        approachCollarTarget();
                    }
                    delete store.world.deathEngineCollarStacks; // Clean up
                    delete store.world.deathEngineCollarTargetStacks;
                } else {
                    // Add collar stacks ONLY AFTER 2nd boss is defeated - collar tracking starts with 3rd boss
                    collarStacksToAdd = ensureFiniteNumber(collarStacksToAdd, 0);
                    if (store.world.bosses > 2) {
                        if (collarStacksToAdd > 0) {
                            scheduleCollarIncrease(collarStacksToAdd);
                        } else {
                            approachCollarTarget();
                        }
                    }
                }
                // FIXED: Don't permanently modify health bonuses - collar handles this dynamically
                // Instead, only apply temporary density and XP bonuses based on performance
                // Only apply density scaling after first boss is defeated
                if (announcedAdaptation && store.world.bosses >= 1) {
                    // Only apply density bonuses, not permanent health increases
                    if (healthBonusMultiplier > 1.3) {
                        store.world.enemyDensityBonus = normalizeEnemyDensityBonus(store.world.enemyDensityBonus * 1.15);
                    } else if (healthBonusMultiplier > 1.1) {
                        store.world.enemyDensityBonus = normalizeEnemyDensityBonus(store.world.enemyDensityBonus * 1.10);
                    } else if (healthBonusMultiplier > 1.0) {
                        store.world.enemyDensityBonus = normalizeEnemyDensityBonus(store.world.enemyDensityBonus * 1.05);
                    }
                    setTimeout(() => announce("GUARDIAN DEFEATED!"), 1000);
                }
            }

            function explode(x, y, isBoss = false, isSmall = false) {
                playSound('explosion');
                if (isBoss) {
                    // Spawn regular powerups
                    for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
                    
                    // Guaranteed boss-tier upgrade drop with delay
                    setTimeout(() => {
                        spawnUpgradePowerup(x + Math.random() * 60 - 30, y + Math.random() * 60 - 30, 'bossTier');
                        
                        // Luck gives small chance for bonus drop (33% of normal luck effectiveness)
                        const luckBonus = (store.player.luckBoost || 0) * 0.33;
                        if (Math.random() < luckBonus) {
                            setTimeout(() => {
                                spawnUpgradePowerup(x + Math.random() * 80 - 40, y + Math.random() * 80 - 40, Math.random() < 0.5 ? 'midTier' : 'bossTier');
                            }, 800);
                        }
                    }, 1500);
                }
                if (isSmall) {
                    const radius = 60;
                    const dmg = 25 * store.player.dmgMult;
                    const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                    targets.forEach(e => {
                        if (!e.dead) {
                            const distSq = (e.x - x) ** 2 + (e.y - y) ** 2;
                            if (distSq < radius ** 2) {
                                e.hp -= dmg;
                                store.world.totalDamage += dmg;

                                // Track damage dealt for beef shield system
                                if (store.player.pilotGenome === 'beef') {
                                    store.player.beefShieldDamageDealt += dmg;
                                }

                                // Apply vampirism healing for explosion damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = dmg * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP
                                    healAmount = Math.min(healAmount, 2); // Cap at 2 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }
                            }
                        }
                    });
                    store.activeEffects.push(createEffect("grenadeExplosion", x, y, radius));
                }
            }

            function levelUp() {
                announce(`LEVEL UP! âš¡ CHOOSE YOUR AUGMENTATION!`);
                pauseGame();

                // Natural health growth: 10% per level
                const healthGrowth = store.player.hpMax * 0.1;
                store.player.hpMax += healthGrowth;
                store.player.hp += healthGrowth;

                store.player.isInvincible = true;
                const speedBoost = store.player.speed * 0.75;
                const fireRateBoost = store.player.fireRate * 0.5;
                store.player.speed += speedBoost;
                store.player.fireRate -= fireRateBoost;

                const levelUpPulse = () => {
                    const p = store.player;
                    const numBullets = 36;
                    for (let i = 0; i < numBullets; i++) {
                        const angle = (i / numBullets) * 2 * Math.PI;
                        const bulletSpeed = 300;
                        spawnBullet({
                            x: p.x,
                            y: p.y,
                            vx: Math.cos(angle) * bulletSpeed,
                            vy: Math.sin(angle) * bulletSpeed,
                            r: 4,
                            col: '#ffddff',
                            dmg: 30 * p.dmgMult,
                            pierce: true,
                            life: 1.5,
                            isLevelUpPulse: true
                        });
                    }
                };

                levelUpPulse();
                setTimeout(levelUpPulse, 250);

                // Store timeout ID to prevent multiple level-ups causing permanent bonuses
                if (store.levelUpTimeoutId) {
                    clearTimeout(store.levelUpTimeoutId);
                }

                store.levelUpTimeoutId = setTimeout(() => {
                    store.player.isInvincible = false;
                    store.player.speed -= speedBoost;
                    store.player.fireRate += fireRateBoost;
                    store.levelUpTimeoutId = null;
                }, 3000);

                const panel = q('levelPanel'), grid = q('skillsGrid');
                const availableUpgrades = LEVEL_UPGRADES.filter(u => {
                    if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
                    // Check if upgrade has availability function
                    if (u.available && typeof u.available === 'function') return u.available();
                    return true;
                });

                for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; }
                const choices = availableUpgrades.slice(0, 3);
                grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');

                const cards = grid.querySelectorAll('.skill-card');
                const clickHandler = (e) => {
                    const card = e.currentTarget;
                    const id = card.dataset.id;
                    const upgrade = LEVEL_UPGRADES.find(s => s.id === id);
                    if (upgrade) upgrade.apply();
                    panel.classList.add('hide');
                    resumeGame(true);  // Force resume to avoid panel visibility race condition
                    // Clean up event listeners to prevent UI freeze
                    cards.forEach(c => c.removeEventListener('click', clickHandler));
                };

                cards.forEach(card => {
                    card.addEventListener('click', clickHandler);
                });

                panel.classList.remove('hide');
                enterPanel('subclassPanel');
            }

            function handleGameOver() {
                if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score);
                announce('â—¢ NEXUS BREACH - PILOT LOST â—£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide');
            }

            function resetGame() {
                console.log('ðŸ”„ RESET GAME initiated');
                store.player = JSON.parse(JSON.stringify(player_initial_state));
                const prevAutoForge = (store.world && typeof store.world.autoForgeEnabled === 'boolean') ? store.world.autoForgeEnabled : storedAutoForgeEnabled;

                // Ensure dmgMult is initialized
                if (!store.player.dmgMult) store.player.dmgMult = 1;

                const now = performance.now();
                store.world = {
                    wave: 1,
                    score: 0,
                    gold: 0,
                    xp: 0,
                    level: 1,
                    kills: 0,
                    bosses: 0,
                    bossesAtPilotSelection: null,
                    lowHealthTutorialShown: false,
                    mechForgeGoldTriggered: false,
                    mechForgePulseTimeout: null,
                    bossSpawnTime: 0,
                    waveStartTime: 0,
                    activeBossToken: null,
                    activeBossWave: null,
                    completedBossTokens: Object.create(null),
                    lastBossAwardToken: null,
                    enemyHealthBonus: 1.0,
                    bossHealthBonus: 1.0,
                    enemyDensityBonus: BASE_ENEMY_DENSITY_BONUS,
                    lastBossRapidKillMultiplier: 1,
                    lastEnemyOverdriveAnnounce: 0,
                    powerupCooldown: 0,
                    xpMultiplier: 1.0,
                    collarStacks: 0,
                    lateGameDamageScaling: 1,
                    consecutiveFastKills: 0,
                    fastKillBonus: 0,
                    totalDamage: 0,
                    damageStartTime: performance.now(),
                    lastThreatScale: 1,
                    lastSpawnOverflow: 0,
                    lastPlannedSpawnCount: 0,
                    lastSpawnCount: 0,
                    lastSpawnFallback: false,
                    lastSpawnQueueLength: 0,
                    lastSpawnTempo: 0,
                    firstBossOrbsGifted: false,
                    mechForgePromptActive: false,
                    mechForgePromptInterval: 250,
                    nextMechForgePrompt: 135,
                    mechForgePromptCount: 0,
                    autoForgeEnabled: prevAutoForge,
                    autoForgeReserve: 0,
                    autoForgeDecisionTimer: null,
                    autoForgeAnnounceCooldown: 0,
                    totalForgeSpend: 0,
                    autoForgeTutorialShown: false,
                    shopTutorialShown: false,
                    shopSpotlightDismissed: false,
                    currentThemeKey: DEFAULT_MAP_THEME_KEY,
                    targetThemeKey: DEFAULT_MAP_THEME_KEY,
                    themeTransitionProgress: 1,
                    themeTransitionActive: false,
                    gameStartTime: now,
                    autoForgeProfileId: store.settings.autoForgeProfile,
                    cubeBurglarCooldown: 0,
                    cubeBurglarActive: false,
                    cubeBurglarLastSpawnWave: 0,
                    cubeBurglarLastSpawnTime: 0,
                    cubeBurglarSpawnTimer: 0,
                    cubeBurglarSpawnAttempts: 0,
                    cubeBurglarLastAttemptTime: 0,
                    cubeBurglarDefeated: 0
                };

                if (store.bullets && store.bullets.length) {
                    console.log(`ðŸ§¹ Clearing ${store.bullets.length} bullets during game reset`);
                    store.bullets.forEach(bullet => bulletPool.release(bullet));
                }
                if (store.eBullets && store.eBullets.length) {
                    store.eBullets.forEach(returnEBulletToPool);
                }
                store.boss = null; store.bullets = []; store.fragmentProjectiles = []; store.eBullets = []; store.enemies = []; store.powerups = []; store.starProjectiles = []; store.pendingStarSalvos = []; store.pendingStarClones = []; store.juggernautBombs = [];
                store.lastBossSnapshot = null;
                store.lastBossDefeatId = null;
                store.drones = []; store.hounds = []; store.shadowHounds = []; store.voidRifts = []; store.missiles = []; store.lasers = []; store.mines = []; store.activeEffects = []; store.flameParticles = [];
                store.lightningBolts = []; store.empNovas = []; store.flamePulses = []; store.poisonPuddles = []; store.goldenOrbs = []; store.shadowEchoes = [];
                store.championMinions = [];
                store.pendingChampionUpgrade = null;
                powerSoundPlayedTargets.clear(); // Clear power sound tracking for new wave
                store.empCharges = [];
                store.knockbackCharges = [];
                store.empGlobalCooldown = 0;
                store.knockbackGlobalCooldown = 0;
                if (store.player) {
                    store.player.grenades = 0;
                    store.player.knockbackShields = 0;
                }
                store.playerChampion = null;
                store.shadowChampionId = null;
                store.shadowChampionDefeated = false;
                store.shadowChampionTokenDropped = false;
                store.shadowChampionLastPos = null;
                store.iceman = null;
                store.beefClone = null;
                store.escortDrones = [];
                store.waveSpawnQueue = [];
                store.pendingSpawnCount = 0;
                store._startTs = performance.now(); store.isGameOver = false;
                store.cheatsUsed = false;
                store.cheatInvincibilityCooldown = 0;
                store.cheatDogHealCooldown = 0;
                store.cheatChampionCooldown = 0;
                store.ui.shopSpotlightActive = false;
                store.ui.shopSpotlightMessage = 'Upgrade Hangar online. Deploy credits as needed.';
                shopItemOrder = [...SHOP_DISPLAY_ORDER];
                q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide');
                q('subclassPanel').classList.add('hide');
                const mechForgeBtn = q('shopBtn');
                if (mechForgeBtn) {
                    mechForgeBtn.classList.remove('forge-highlight');
                    mechForgeBtn.classList.remove('mech-forge-pulse');
                    if (mechForgeBtn._forgePulseTimeout) {
                        clearTimeout(mechForgeBtn._forgePulseTimeout);
                        mechForgeBtn._forgePulseTimeout = null;
                    }
                }
                setMapThemeImmediate(DEFAULT_MAP_THEME_KEY);
                ensureName();
            }

            // --- RENDER & DRAW FUNCTIONS ---
            const TAU = Math.PI * 2;
            const THEME_TRANSITION_DURATION = 3.3;

            const CUBE_BURGLAR_CONFIG = Object.freeze({
                cubeSize: 4.5,
                detailCubeScale: 0.55,
                easeFactor: 6.5,
                damageFlashDuration: 0.32,
                baseCubeHealth: 93.5, // Reduced by 15% from 110
                baseDetailHealth: 29.75, // Reduced by 15% from 35
                baseAuraDamageBonus: 0.22,
                stackDamageBonus: 0.08,
                auraDuration: 1.3,
                auraRange: 260,
                vacuumRange: 340,
                vacuumStrength: 260,
                captureRadius: 36,
                spawnCooldown: 42,
                passiveSpawnInterval: 18,
                minRespawnDelay: 28,
                forcedSpawnAttempts: 4,
                minAttemptGap: 0.35,
                minWave: 10,
                minWaveGap: 4,
                spawnChanceBase: 0.08,
                spawnChancePerWave: 0.004,
                maxStacks: 6,
                perCubeGold: 0,
                perCubeXp: 6,
                lootGold: 3,
                lootXp: 220,
                lootScore: 800
            });

            const CUBE_BURGLAR_SHAPE = [
                { type: 'head', data: [0, 0, 1, 1, 0, 0] },
                { type: 'head', data: [0, 1, 1, 1, 1, 0] },
                { type: 'arms', data: [1, 1, 1, 1, 1, 1] },
                { type: 'torso', data: [0, 0, 1, 1, 0, 0] },
                { type: 'torso', data: [0, 0, 1, 1, 0, 0] },
                { type: 'legs', data: [0, 1, 0, 1, 0, 0] },
                { type: 'legs', data: [0, 1, 0, 0, 1, 0] },
                {
                    type: 'knapsack',
                    shape: [
                        [0, 1, 1, 1, 0],
                        [1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1],
                        [0, 1, 1, 1, 0]
                    ],
                    offsetX: -0.5,
                    offsetY: -2,
                    offsetZ: -3
                }
            ];

            class CubeBurglarCube {
                constructor(index, targetX, targetY, targetZ, size, partType = 'body', partIdentifier = '', opts = {}) {
                    this.id = index;
                    this.targetX = targetX;
                    this.targetY = targetY;
                    this.targetZ = targetZ;
                    this.animX = targetX;
                    this.animY = targetY;
                    this.animZ = targetZ;
                    this.size = size;
                    this.partType = partType;
                    this.partIdentifier = partIdentifier;
                    this.isDetail = opts.isDetail === true;
                    this.stripeIndex = Number.isFinite(opts.stripeIndex) ? opts.stripeIndex : 0;
                    
                    // Color scheme: knapsack = translucent red, body = black/white prison stripes
                    if (partType === 'knapsack') {
                        // Red knapsack (translucent handled in draw)
                        this.baseColor = `hsl(0, 85%, 45%)`;
                        this.isKnapsack = true;
                    } else {
                        const stripeParity = Math.abs(this.stripeIndex) % 2;
                        const stripePalette = ['#101010', '#f2f2f2'];
                        let baseColor = stripePalette[stripeParity];

                        if (this.isDetail) {
                            const detailVariance = 10 + Math.random() * 6;
                            baseColor = stripeParity === 0
                                ? lightenHsl(baseColor, detailVariance)
                                : darkenHsl(baseColor, detailVariance);
                        } else {
                            const bodyVariance = 2 + Math.random() * 5;
                            baseColor = stripeParity === 0
                                ? lightenHsl(baseColor, bodyVariance)
                                : darkenHsl(baseColor, bodyVariance);
                        }

                        this.baseColor = baseColor;
                        this.isKnapsack = false;
                    }
                    this.color = this.baseColor;
                    const baseHp = this.isDetail ? CUBE_BURGLAR_CONFIG.baseDetailHealth : CUBE_BURGLAR_CONFIG.baseCubeHealth;
                    this.hpMax = baseHp * (opts.healthMultiplier || 1);
                    this.hp = this.hpMax;
                    this.damageTimer = 0;
                    this.destroyed = false;
                    this.pulseOffset = Math.random() * TAU;
                    this.screen = { x: 0, y: 0, z: 0 };
                }

                update(dt) {
                    const ease = Math.max(0.08, Math.min(0.35, CUBE_BURGLAR_CONFIG.easeFactor * dt));
                    this.animX += (this.targetX - this.animX) * ease;
                    this.animY += (this.targetY - this.animY) * ease;
                    this.animZ += (this.targetZ - this.animZ) * ease;
                    if (this.damageTimer > 0) {
                        this.damageTimer = Math.max(0, this.damageTimer - dt);
                        const ratio = Math.max(0, Math.min(1, this.damageTimer / CUBE_BURGLAR_CONFIG.damageFlashDuration));
                        const l = 70 - ratio * 22;
                        this.color = `hsl(0, 80%, ${l}%)`;
                    } else {
                        this.color = this.baseColor;
                    }
                }

                takeDamage(amount) {
                    if (this.destroyed) return 0;
                    const applied = Math.min(this.hp, amount);
                    this.hp -= applied;
                    this.damageTimer = CUBE_BURGLAR_CONFIG.damageFlashDuration;
                    if (this.hp <= 0.0001) {
                        this.destroyed = true;
                        this.hp = 0;
                    }
                    return applied;
                }
            }

            function degToRad(deg) {
                return deg * Math.PI / 180;
            }

            function adjustHslLightness(color, delta) {
                // Handle hex colors
                if (color.startsWith('#')) {
                    const hex = color.slice(1);
                    const r = parseInt(hex.slice(0, 2), 16);
                    const g = parseInt(hex.slice(2, 4), 16);
                    const b = parseInt(hex.slice(4, 6), 16);
                    
                    const adjust = delta / 100; // Convert to 0-1 range
                    const nr = Math.max(0, Math.min(255, r + (adjust * 255)));
                    const ng = Math.max(0, Math.min(255, g + (adjust * 255)));
                    const nb = Math.max(0, Math.min(255, b + (adjust * 255)));
                    
                    return `rgb(${Math.round(nr)}, ${Math.round(ng)}, ${Math.round(nb)})`;
                }
                
                // Handle HSL colors
                const matches = color.match(/-?\d+(?:\.\d+)?/g);
                if (!matches || matches.length < 3) return color;
                const h = parseFloat(matches[0]);
                const s = parseFloat(matches[1]);
                const l = parseFloat(matches[2]);
                if (Number.isNaN(l)) return color;
                const nextL = Math.max(0, Math.min(100, l + delta));
                return `hsl(${h.toFixed(1)}, ${s.toFixed(1)}%, ${nextL.toFixed(1)}%)`;
            }

            function lightenHsl(color, amount) {
                return adjustHslLightness(color, Math.abs(amount));
            }

            function darkenHsl(color, amount) {
                return adjustHslLightness(color, -Math.abs(amount));
            }

            function buildCubeBurglarCubes(enemy, healthMultiplier) {
                const cubes = [];
                const size = CUBE_BURGLAR_CONFIG.cubeSize;
                const spacing = size * 2.2;
                const figureRows = CUBE_BURGLAR_SHAPE.filter(def => def.data).length;
                let currentRow = 0;
                let index = 0;

                CUBE_BURGLAR_SHAPE.forEach(def => {
                    if (def.data) {
                        const row = def.data;
                        const width = row.length;
                        for (let col = 0; col < width; col++) {
                            if (!row[col]) continue;
                            let identifier = def.type;
                            if (def.type === 'arms') {
                                identifier = col < width / 2 ? 'leftArm' : 'rightArm';
                            } else if (def.type === 'legs') {
                                identifier = col < width / 2 ? 'leftLeg' : 'rightLeg';
                            }
                            const targetX = (col - width / 2) * spacing;
                            const targetY = (currentRow - figureRows / 2) * spacing;
                            const targetZ = (Math.random() - 0.5) * size * 1.6;
                            cubes.push(new CubeBurglarCube(
                                index++,
                                targetX,
                                targetY,
                                targetZ,
                                size,
                                def.type,
                                identifier,
                                {
                                    healthMultiplier,
                                    stripeIndex: currentRow
                                }
                            ));

                            const detailCount = 1;
                            for (let detail = 0; detail < detailCount; detail++) {
                                cubes.push(new CubeBurglarCube(
                                    index++,
                                    targetX + (Math.random() - 0.5) * spacing * 0.9,
                                    targetY + (Math.random() - 0.5) * spacing * 0.9,
                                    targetZ + (Math.random() - 0.5) * spacing * 1.9,
                                    size * CUBE_BURGLAR_CONFIG.detailCubeScale,
                                    def.type,
                                    identifier,
                                    {
                                        isDetail: true,
                                        healthMultiplier: healthMultiplier * 0.6,
                                        stripeIndex: currentRow
                                    }
                                ));
                            }
                        }
                        currentRow++;
                    } else if (def.type === 'knapsack') {
                        const shape = def.shape || [];
                        for (let row = 0; row < shape.length; row++) {
                            for (let col = 0; col < shape[row].length; col++) {
                                if (!shape[row][col]) continue;
                                const targetX = ((col - shape[row].length / 2) * spacing) + (def.offsetX || 0) * spacing;
                                const targetY = ((row - shape.length / 2) * spacing) + (def.offsetY || 0) * spacing;
                                const targetZ = (Math.random() - 0.5) * size * 1.2 + (def.offsetZ || 0) * spacing;
                                cubes.push(new CubeBurglarCube(
                                    index++,
                                    targetX,
                                    targetY,
                                    targetZ,
                                    size,
                                    'knapsack',
                                    'knapsack',
                                    { healthMultiplier }
                                ));
                            }
                        }
                    }
                });

                enemy.cubeDetailCount = cubes.filter(c => c.isDetail).length;
                return cubes;
            }

            function projectCubeForBurglar(enemy, cube) {
                const PROJECTION_ANGLE = 0.35;
                const time = enemy.time || 0;
                const tilt = enemy.rotationX;
                const pan = enemy.rotationY;
                const spin = enemy.rotationZ;

                let limbOffsetX = 0;
                let limbOffsetY = 0;
                let limbOffsetZ = 0;
                const armSpeed = 1.6;
                const legSpeed = 2.0;

                switch (cube.partIdentifier) {
                    case 'leftArm':
                        limbOffsetZ = Math.sin(time * armSpeed) * 18;
                        limbOffsetY = Math.cos(time * armSpeed) * 6 + 6;
                        limbOffsetX = Math.cos(time * armSpeed * 0.5) * 4;
                        break;
                    case 'rightArm':
                        limbOffsetZ = Math.sin(time * armSpeed + Math.PI) * 18;
                        limbOffsetY = Math.cos(time * armSpeed + Math.PI) * 6 + 6;
                        limbOffsetX = Math.cos(time * armSpeed * 0.5 + Math.PI) * 4;
                        break;
                    case 'leftLeg':
                        limbOffsetZ = Math.sin(time * legSpeed) * 14;
                        break;
                    case 'rightLeg':
                        limbOffsetZ = Math.sin(time * legSpeed + Math.PI) * 14;
                        break;
                }

                let currentX = cube.animX + limbOffsetX;
                let currentY = cube.animY + limbOffsetY + enemy.renderOffsetY;
                let currentZ = cube.animZ + limbOffsetZ + enemy.renderOffsetZ;

                const bob = Math.sin(time * 1.8) * 12;
                currentY += bob;

                const x1 = currentX * Math.cos(spin) + currentZ * Math.sin(spin);
                const z1 = -currentX * Math.sin(spin) + currentZ * Math.cos(spin);
                const y1 = currentY;

                const y2 = y1 * Math.cos(tilt) - z1 * Math.sin(tilt);
                const z2 = y1 * Math.sin(tilt) + z1 * Math.cos(tilt);
                const x2 = x1;

                const finalX = x2 * Math.cos(pan) + z2 * Math.sin(pan);
                const finalZ = -x2 * Math.sin(pan) + z2 * Math.cos(pan);
                const finalY = y2;

                let screenX = (finalX - finalY) * Math.cos(PROJECTION_ANGLE);
                let screenY = (finalX + finalY) * Math.sin(PROJECTION_ANGLE) - finalZ;

                cube.screen.x = screenX;
                cube.screen.y = screenY;
                cube.screen.z = finalZ;
                return cube.screen;
            }

            function getCubeBurglarActiveEnemy() {
                if (!store.cubeBurglarId) return null;
                const enemy = store.enemies.find(en => en && en.id === store.cubeBurglarId && !en.dead && en.type === 'cube_burglar');
                return enemy || null;
            }

            function createCubeBurglar(options = {}) {
                const hpScale = Math.max(0.6, options.hpScale || 1);
                const lateGameScaling = Math.max(0.8, options.lateGameScaling || 1);
                const damageMult = Math.max(1, options.damageMult || 1);
                const playerRef = store.player || { x: W / 2, y: H / 2 };
                const centerX = Number.isFinite(playerRef.x) ? playerRef.x : W / 2;
                const centerY = Number.isFinite(playerRef.y) ? playerRef.y : H / 2;
                const spawnX = options.x !== undefined ? options.x : centerX + (Math.random() - 0.5) * 220;
                const x = Math.max(120, Math.min(W - 120, spawnX));
                const y = options.y !== undefined ? options.y : -160;
                const enemy = {
                    type: 'cube_burglar',
                    id: Date.now() + Math.random(),
                    x,
                    y,
                    r: 28,
                    cubes: [],
                    time: 0,
                    rotationX: degToRad(68),
                    rotationY: degToRad(-204),
                    rotationZ: degToRad(38),
                    renderOffsetY: 0,
                    renderOffsetZ: 0,
                    moveSpeed: 70 + Math.random() * 20,
                    baseContactDamage: 18,
                    contactDamage: 18 * damageMult,
                    damageMult,
                    auraRange: CUBE_BURGLAR_CONFIG.auraRange,
                    auraDuration: CUBE_BURGLAR_CONFIG.auraDuration,
                    baseAuraDamageMult: 1 + CUBE_BURGLAR_CONFIG.baseAuraDamageBonus,
                    auraDamageMult: 1 + CUBE_BURGLAR_CONFIG.baseAuraDamageBonus,
                    buffStacks: 0,
                    stolenPowerups: [],
                    vacuumRange: CUBE_BURGLAR_CONFIG.vacuumRange,
                    vacuumStrength: CUBE_BURGLAR_CONFIG.vacuumStrength,
                    captureRadius: CUBE_BURGLAR_CONFIG.captureRadius,
                    gold: CUBE_BURGLAR_CONFIG.lootGold,
                    xp: CUBE_BURGLAR_CONFIG.lootXp,
                    score: CUBE_BURGLAR_CONFIG.lootScore,
                    spawnDuration: 0.85,
                    spawnDropDistance: 160,
                    spawnEffectColor: '#ff6ad5',
                    spawnIntroGlow: 1.2,
                    cannotBeKnocked: true,
                    cubeAliveCount: 0,
                    hp: 0,
                    hpMax: 0,
                    topClampDelay: 1.5,
                    target: null,
                    targetTimer: 0,
                    highlightTimer: 0,
                    captureCooldown: 0,
                    auraPulse: 0,
                    contactCooldown: 0,
                    shadowGround: 70,
                    dashCooldown: 0,
                    isDashing: false,
                    dashDuration: 0
                };

                let healthMultiplier = hpScale * lateGameScaling;
                
                // Apply collar scaling ONLY AFTER 2nd boss is defeated (same as enemies/bosses)
                if (store.world.bosses > 2) {
                    const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                    // Cube burglar gets 50% collar effectiveness like regular enemies
                    const cubeBurglarCollarMultiplier = 1 + ((collarBonus - 1) * 0.5);
                    healthMultiplier *= cubeBurglarCollarMultiplier;
                }
                
                enemy.cubes = buildCubeBurglarCubes(enemy, healthMultiplier);
                enemy.cubeAliveCount = enemy.cubes.filter(c => !c.isDetail).length;
                enemy.hpMax = enemy.cubes.reduce((sum, cube) => sum + cube.hpMax, 0);
                enemy.hp = enemy.hpMax;
                enemy.auraDamageMult = enemy.baseAuraDamageMult;
                recalcCubeBurglarEmpowerments(enemy);
                return enemy;
            }

            function trySpawnCubeBurglar(options = {}) {
                const world = store.world;
                if (!world) return null;
                if (world.cubeBurglarActive) return null;
                if (world.wave < CUBE_BURGLAR_CONFIG.minWave) return null;
                const waveGap = world.wave - (world.cubeBurglarLastSpawnWave || 0);
                const now = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
                const lastTime = world.cubeBurglarLastSpawnTime || 0;
                const lastAttemptTime = world.cubeBurglarLastAttemptTime || 0;
                const elapsedSeconds = lastTime > 0 ? (now - lastTime) / 1000 : Infinity;
                const elapsedSinceAttempt = lastAttemptTime > 0 ? (now - lastAttemptTime) / 1000 : Infinity;
                const readyByWave = waveGap >= CUBE_BURGLAR_CONFIG.minWaveGap;
                const readyByTime = elapsedSeconds >= CUBE_BURGLAR_CONFIG.minRespawnDelay;
                if (!readyByWave && !readyByTime) return null;
                if (elapsedSinceAttempt < (CUBE_BURGLAR_CONFIG.minAttemptGap || 0.3)) return null;
                if (world.cubeBurglarCooldown > 0) return null;
                const maxChance = Math.min(0.42, CUBE_BURGLAR_CONFIG.spawnChanceBase + Math.max(0, world.wave - CUBE_BURGLAR_CONFIG.minWave) * CUBE_BURGLAR_CONFIG.spawnChancePerWave);
                world.cubeBurglarSpawnAttempts = (world.cubeBurglarSpawnAttempts || 0) + 1;
                world.cubeBurglarLastAttemptTime = now;
                const forced = world.cubeBurglarSpawnAttempts >= (CUBE_BURGLAR_CONFIG.forcedSpawnAttempts || 4);
                if (!forced && Math.random() >= maxChance) {
                    return null;
                }

                const burglar = createCubeBurglar(options);
                store.world.cubeBurglarActive = true;
                store.world.cubeBurglarLastSpawnWave = store.world.wave;
                store.world.cubeBurglarLastSpawnTime = now;
                store.world.cubeBurglarSpawnTimer = 0;
                store.world.cubeBurglarSpawnAttempts = 0;
                store.world.cubeBurglarLastAttemptTime = now;
                store.cubeBurglarId = burglar.id;
                activateSpawnIntro(burglar, {
                    duration: burglar.spawnDuration,
                    dropDistance: burglar.spawnDropDistance,
                    effectColor: burglar.spawnEffectColor,
                    clusterIndex: -1,
                    clusterSize: 1,
                    fireDelayBuffer: 0.75
                });
                store.enemies.push(burglar);
                store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;
                store.activeEffects.push(createEffect('spawnTeleport', burglar.x, burglar.spawnTargetY ?? burglar.y, 48, {
                    color: burglar.spawnEffectColor,
                    duration: (burglar.spawnDuration || 0.8) + 0.35
                }));
                if (typeof announce === 'function') {
                    announce('âš ï¸ Cube Burglar inbound! Secure your spoils.');
                }
                // Thunder sound removed - only for Stormbringer
                return burglar;
            }

            function computeCubeBurglarEmpowerments(enemy) {
                const weights = {
                    speed: 0,
                    fire: 0,
                    damage: 0,
                    projectile: 0
                };

                const stolen = Array.isArray(enemy?.stolenPowerups) ? enemy.stolenPowerups : [];
                for (let i = 0; i < stolen.length; i++) {
                    const item = stolen[i];
                    if (!item) continue;
                    switch (item.type) {
                        case 'attack_speed':
                            weights.fire += 1.2;
                            weights.projectile += 0.5;
                            break;
                        case 'double':
                            weights.fire += 1;
                            break;
                        case 'missile':
                            weights.projectile += 1;
                            break;
                        case 'drones':
                            weights.fire += 0.6;
                            weights.speed += 0.5;
                            break;
                        case 'star_upgrade':
                            weights.damage += 1;
                            break;
                        case 'void_core':
                            weights.damage += 1;
                            weights.fire += 0.5;
                            break;
                        case 'upgrade':
                            weights.damage += 0.6;
                            break;
                        case 'cash':
                            weights.speed += 0.4;
                            break;
                        case 'collar_fragment':
                            weights.damage += 0.5;
                            break;
                        case 'champion_upgrade':
                            weights.damage += 0.8;
                            weights.fire += 0.3;
                            break;
                        case 'shadow_champion_token':
                            weights.damage += 0.6;
                            break;
                        case 'shield':
                        case 'repair':
                            weights.damage += 0.4;
                            break;
                        default:
                            weights.fire += 0.2;
                            break;
                    }
                }

                const speedMult = clamp(1 + weights.speed * 0.1, 1, 1.75);
                const fireRateMult = clamp(1 + weights.fire * 0.15, 1, 2);
                const damageMult = clamp(1 + weights.damage * 0.18, 1, 2.2);
                const projectileSpeedMult = clamp(1 + weights.projectile * 0.18, 1, 2);

                return {
                    speedMult,
                    fireRateMult,
                    damageMult,
                    projectileSpeedMult,
                    weights
                };
            }

            function recalcCubeBurglarEmpowerments(enemy) {
                if (!enemy) return {
                    speedMult: 1,
                    fireRateMult: 1,
                    damageMult: 1,
                    projectileSpeedMult: 1,
                    weights: { speed: 0, fire: 0, damage: 0, projectile: 0 }
                };
                const computed = computeCubeBurglarEmpowerments(enemy);
                enemy.cubeBurglarEmpowerments = computed;
                return computed;
            }

            function empowerEnemyProjectile(owner, projectile) {
                if (!owner || !projectile) return projectile;
                const stats = owner.cubeBurglarBuffStats || owner.cubeBurglarEmpowerments;
                const speedMult = owner.cubeBurglarProjectileSpeedMultiplier || stats?.projectileSpeedMult || 1;
                if (speedMult !== 1 && Number.isFinite(speedMult)) {
                    projectile.vx = (projectile.vx || 0) * speedMult;
                    projectile.vy = (projectile.vy || 0) * speedMult;
                }
                return projectile;
            }

            function pullPowerupsToCubeBurglar(enemy, dt) {
                if (!store.powerups || !store.powerups.length) return;
                const rangeSq = enemy.vacuumRange * enemy.vacuumRange;
                for (let i = store.powerups.length - 1; i >= 0; i--) {
                    const powerup = store.powerups[i];
                    if (!powerup) continue;
                    const dx = powerup.x - enemy.x;
                    const dy = powerup.y - enemy.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > rangeSq) continue;
                    const dist = Math.max(8, Math.sqrt(distSq));
                    const pull = enemy.vacuumStrength * (1 + enemy.buffStacks * 0.14);
                    powerup.x -= (dx / dist) * pull * dt;
                    powerup.y -= (dy / dist) * pull * dt;
                    const captureRadius = enemy.captureRadius;
                    if (dist <= captureRadius) {
                        enemy.stolenPowerups.push({
                            type: powerup.type,
                            championVariant: powerup.championVariant,
                            upgradeTier: powerup.upgradeTier,
                            pulseOffset: powerup.pulseOffset,
                            fallbackTier: powerup.fallbackTier,
                            source: powerup.source,
                            isVoidReaper: powerup.isVoidReaper,
                            r: powerup.r,
                            value: powerup.value,
                            xp: powerup.xp,
                            pulse: powerup.pulse
                        });
                        store.powerups.splice(i, 1);
                        enemy.buffStacks = Math.min(CUBE_BURGLAR_CONFIG.maxStacks, enemy.buffStacks + 1);
                        enemy.highlightTimer = 0.6;
                        enemy.auraDamageMult = enemy.baseAuraDamageMult + enemy.buffStacks * CUBE_BURGLAR_CONFIG.stackDamageBonus;
                        enemy.auraDuration = CUBE_BURGLAR_CONFIG.auraDuration + enemy.buffStacks * 0.1;
                        recalcCubeBurglarEmpowerments(enemy);
                        if (typeof announce === 'function') {
                            announce('ðŸ’Ž Cube Burglar pilfered a powerup!');
                        }
                        store.activeEffects.push(createEffect('spawnTeleport', enemy.x, enemy.y, 40 + enemy.buffStacks * 6, {
                            color: '#ff6ad5',
                            duration: 0.45
                        }));
                    }
                }
            }

            function collectCubeBurglarPlayerUnits() {
                const units = [];
                const addUnit = (unit, weight = 1) => {
                    if (!unit || unit.dead || unit.destroyed || unit.removed || unit.hp <= 0) return;
                    const ux = unit.x ?? unit.posX ?? unit.position?.x;
                    const uy = unit.y ?? unit.posY ?? unit.position?.y;
                    if (!Number.isFinite(ux) || !Number.isFinite(uy)) return;
                    units.push({ x: ux, y: uy, weight: weight || 1 });
                };

                addUnit(store.player, 1.5);
                addUnit(store.playerChampion, 1.2);

                const sources = [
                    { list: store.drones, weight: 1 },
                    { list: store.hounds, weight: 1 },
                    { list: store.shadowHounds, weight: 1 },
                    { list: store.championMinions, weight: 1 },
                    { list: store.empCharges, weight: 0.6 },
                    { list: store.knockbackCharges, weight: 0.6 }
                ];

                for (let i = 0; i < sources.length; i++) {
                    const source = sources[i];
                    if (!Array.isArray(source.list) || !source.list.length) continue;
                    const weight = source.weight || 1;
                    for (let j = 0; j < source.list.length; j++) {
                        addUnit(source.list[j], weight);
                    }
                }

                return units;
            }

            function findCubeBurglarUnitCluster() {
                const units = collectCubeBurglarPlayerUnits();
                if (!units || units.length < 3) return null;

                const radius = 150;
                const radiusSq = radius * radius;
                let bestCluster = null;

                for (let i = 0; i < units.length; i++) {
                    const anchor = units[i];
                    let weightSum = anchor.weight || 1;
                    let sumX = anchor.x * weightSum;
                    let sumY = anchor.y * weightSum;

                    for (let j = 0; j < units.length; j++) {
                        if (i === j) continue;
                        const other = units[j];
                        const dx = other.x - anchor.x;
                        const dy = other.y - anchor.y;
                        if (dx * dx + dy * dy > radiusSq) continue;
                        const weight = other.weight || 1;
                        weightSum += weight;
                        sumX += other.x * weight;
                        sumY += other.y * weight;
                    }

                    if (!bestCluster || weightSum > bestCluster.weight) {
                        bestCluster = {
                            x: sumX / weightSum,
                            y: sumY / weightSum,
                            weight: weightSum
                        };
                    }
                }

                if (bestCluster && bestCluster.weight >= 3) {
                    return bestCluster;
                }
                return null;
            }

            function findNearestPowerupForCubeBurglar(enemy) {
                if (!store.powerups || store.powerups.length === 0) return null;
                let closest = null;
                let closestDist = Infinity;
                for (let i = 0; i < store.powerups.length; i++) {
                    const powerup = store.powerups[i];
                    if (!powerup) continue;
                    const dx = powerup.x - enemy.x;
                    const dy = powerup.y - enemy.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < closestDist) {
                        closestDist = distSq;
                        closest = powerup;
                    }
                }
                if (!closest) return null;
                return {
                    x: closest.x + (closest.vx || 0) * 12,
                    y: closest.y + (closest.vy || 0) * 12
                };
            }

            function computeCubeBurglarPatrolTarget(enemy) {
                const margin = (enemy.r || 54) + 20;
                const minX = margin;
                const maxX = Math.max(minX, W - margin);
                const topBand = Math.max(margin, H * 0.08);
                const topBandMax = Math.max(topBand, H * 0.1);

                if (!Number.isFinite(enemy.patrolDirection) || enemy.patrolDirection === 0) {
                    enemy.patrolDirection = Math.random() < 0.5 ? -1 : 1;
                }

                const stride = Math.max(60, (maxX - minX) * (0.25 + Math.random() * 0.35));
                let targetX = enemy.x + enemy.patrolDirection * stride;

                if (targetX <= minX) {
                    targetX = minX;
                    enemy.patrolDirection = 1;
                } else if (targetX >= maxX) {
                    targetX = maxX;
                    enemy.patrolDirection = -1;
                }

                const jitterY = randRange(-12, 18);
                const targetY = clamp(topBandMax + jitterY, margin, Math.min(H - margin, H * 0.2));

                return { x: targetX, y: targetY };
            }

            function chooseCubeBurglarTarget(enemy) {
                const otherEnemiesPresent = store.enemies.some(candidate => candidate && !candidate.dead && candidate.type !== 'cube_burglar');
                const powerupTarget = findNearestPowerupForCubeBurglar(enemy);
                if (powerupTarget) {
                    return {
                        x: powerupTarget.x,
                        y: powerupTarget.y,
                        behavior: 'powerup',
                        reacquire: 0.4
                    };
                }

                if (otherEnemiesPresent) {
                    const cluster = findCubeBurglarUnitCluster();
                    if (cluster) {
                        return {
                            x: cluster.x,
                            y: cluster.y,
                            behavior: 'cluster',
                            reacquire: 1.1
                        };
                    }
                }

                const patrol = computeCubeBurglarPatrolTarget(enemy);
                if (patrol) {
                    return {
                        x: patrol.x,
                        y: patrol.y,
                        behavior: 'patrol',
                        reacquire: 1.6
                    };
                }

                return null;
            }

            function applyCubeBurglarAura(enemy, dt) {
                const auraRangeSq = enemy.auraRange * enemy.auraRange;
                const auraDuration = enemy.auraDuration || CUBE_BURGLAR_CONFIG.auraDuration;
                const auraMult = enemy.auraDamageMult || enemy.baseAuraDamageMult;
                const empowerment = enemy.cubeBurglarEmpowerments || recalcCubeBurglarEmpowerments(enemy);
                
                // Calculate HP multiplier based on empowerment (moderate scaling to avoid bullet sponges)
                const damageBoost = empowerment?.damageMult || 1;
                const hpMultiplier = 1 + (damageBoost - 1) * 0.4; // 40% of damage boost applied to HP
                
                for (let i = 0; i < store.enemies.length; i++) {
                    const target = store.enemies[i];
                    if (!target || target.dead || target === enemy || target.type === 'cube_burglar') continue;
                    const dx = target.x - enemy.x;
                    const dy = target.y - enemy.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > auraRangeSq) continue;
                    
                    // Track base damage multiplier
                    if (target._cubeBurglarBaseDamageMult === undefined) {
                        target._cubeBurglarBaseDamageMult = target.damageMult || 1;
                    }
                    
                    // Track base HP max when first entering aura
                    if (target._cubeBurglarBaseHpMax === undefined) {
                        target._cubeBurglarBaseHpMax = target.hpMax;
                        // Scale up HP when entering aura
                        const oldHpMax = target.hpMax;
                        target.hpMax = Math.floor(target._cubeBurglarBaseHpMax * hpMultiplier);
                        // Scale current HP proportionally
                        const hpRatio = target.hp / oldHpMax;
                        target.hp = Math.floor(target.hpMax * hpRatio);
                    }
                    
                    target.damageMult = (target._cubeBurglarBaseDamageMult || 1) * auraMult * damageBoost;
                    if (target.baseContactDamage !== undefined) {
                        target.contactDamage = target.baseContactDamage * (target.damageMult || 1);
                    }
                    target.cubeBurglarBuffTimer = auraDuration;
                    target.cubeBurglarBuffSource = enemy.id;
                    target.cubeBurglarBuffStats = empowerment;
                    target.cubeBurglarFireRateMultiplier = empowerment?.fireRateMult || 1;
                    target.cubeBurglarSpeedMultiplier = empowerment?.speedMult || 1;
                    target.cubeBurglarProjectileSpeedMultiplier = empowerment?.projectileSpeedMult || 1;
                    target.cubeBurglarAuraGlow = Math.min(1, (target.cubeBurglarAuraGlow || 0) + dt * 2.4);
                }
                enemy.auraPulse = Math.sin((enemy.time || 0) * 4) * 0.5 + 0.5;
            }

            function defeatCubeBurglar(enemy) {
                if (!enemy || enemy.dead) return;
                
                // Check cube burglar status effects and spawn appropriate death visuals
                const burglarDeathType = getStackDeathType(enemy, {
                    fallbackElement: enemy.lastStackHitElement || null
                });
                
                enemy.dead = true;
                
                // Clean up PixiJS graphics
                if (enemy.pixiGraphics && cubeBurglarContainer) {
                    cubeBurglarContainer.removeChild(enemy.pixiGraphics);
                    enemy.pixiGraphics.destroy();
                    enemy.pixiGraphics = null;
                }
                
                store.world.cubeBurglarActive = false;
                store.world.cubeBurglarCooldown = CUBE_BURGLAR_CONFIG.spawnCooldown;
                store.world.cubeBurglarDefeated = (store.world.cubeBurglarDefeated || 0) + 1;
                store.cubeBurglarId = null;
                const now = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
                store.world.cubeBurglarLastSpawnTime = now;
                store.world.cubeBurglarSpawnTimer = 0;
                store.world.cubeBurglarSpawnAttempts = 0;
                store.world.cubeBurglarLastAttemptTime = now;
                const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                const gold = Math.floor((enemy.gold || 0) * collarBonus);
                const xp = Math.floor((enemy.xp || 0) * collarBonus);
                const score = Math.floor((enemy.score || 0) * collarBonus);
                if (gold > 0) addWorldGold(gold);
                if (xp > 0) awardXp(xp); // Apply XP diminishing returns
                if (score > 0) store.world.score += score;
                store.world.kills++;
                
                // Spawn status effect death visuals
                if (burglarDeathType === 'ice') {
                    spawnIceShards(enemy.x, enemy.y, {
                        enemyRadius: enemy.r || 30
                    });
                } else if (burglarDeathType === 'fire') {
                    spawnFireWipeDeath(enemy.x, enemy.y, {
                        enemyRadius: enemy.r || 30,
                        baseColor: '#ff6ad5'
                    });
                } else if (burglarDeathType === 'poison') {
                    spawnPoisonDeath(enemy.x, enemy.y, {
                        enemyRadius: enemy.r || 30,
                        baseColor: '#ff6ad5'
                    });
                } else {
                    // Default gibs if no status effect
                    spawnGibs(enemy.x, enemy.y, '#ff6ad5');
                }
                
                store.activeEffects.push(createEffect('spawnTeleport', enemy.x, enemy.y, 64, {
                    color: '#ff6ad5',
                    duration: 0.55
                }));
                dropCubeBurglarLoot(enemy);
                if (typeof announce === 'function') {
                    announce('âœ… Cube Burglar dismantled! All loot recovered.');
                }
            }

            function dropCubeBurglarLoot(enemy) {
                const centerX = enemy.x;
                const centerY = enemy.y;
                const stolen = enemy.stolenPowerups || [];
                if (stolen.length) {
                    const radius = 45;
                    stolen.forEach((powerup, index) => {
                        const angle = (index / stolen.length) * TAU;
                        store.powerups.push({
                            ...powerup,
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius,
                            r: 14,
                            vx: (Math.random() - 0.5) * 0.25,
                            vy: -Math.random() * 0.25,
                            pulse: powerup.pulse || 0
                        });
                    });
                }

                spawnUpgradePowerup(centerX, centerY - 24, 'bossTier', {
                    championChance: 0.65,
                    fallbackTier: 'bossTier',
                    source: 'cube_burglar',
                    allowChampion: true
                });
                spawnCashBundle(centerX, centerY + 16);
            }

            function applyCubeBurglarHit(enemy, bullet, damage) {
                const localX = bullet.x - enemy.x;
                const localY = bullet.y - enemy.y;
                let bestCube = null;
                let bestDist = Infinity;
                const fallback = [];
                const distanceToCore = Math.hypot(localX, localY);
                for (let i = 0; i < enemy.cubes.length; i++) {
                    const cube = enemy.cubes[i];
                    if (!cube || cube.destroyed) continue;
                    const screen = cube.screen || projectCubeForBurglar(enemy, cube);
                    const dx = localX - screen.x;
                    const dy = localY - screen.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const baseSize = cube.size || CUBE_BURGLAR_CONFIG.cubeSize;
                    const hitRadius = baseSize * (cube.isDetail ? 2 : 2.8);
                    fallback.push({ cube, dist, hitRadius });
                    if (dist <= hitRadius && dist < bestDist) {
                        bestDist = dist;
                        bestCube = cube;
                    }
                }

                if (!bestCube && fallback.length) {
                    fallback.sort((a, b) => a.dist - b.dist);
                    const candidate = fallback[0];
                    if (candidate && candidate.dist < candidate.hitRadius * 1.3) {
                        bestCube = candidate.cube;
                    }
                }

                if (!bestCube && fallback.length) {
                    const primary = fallback.find(entry => !entry.cube.isDetail) || fallback[0];
                    const radius = (enemy.r || 40) * 1.25;
                    if (primary && distanceToCore <= radius) {
                        bestCube = primary.cube;
                    }
                }

                if (!bestCube && distanceToCore <= (enemy.r || 40) * 1.4) {
                    bestCube = enemy.cubes.find(c => c && !c.destroyed && !c.isDetail) || enemy.cubes.find(c => c && !c.destroyed) || null;
                }

                if (!bestCube) {
                    return { hit: false, damageApplied: 0 };
                }

                const applied = bestCube.takeDamage(damage);
                if (applied <= 0) {
                    return { hit: false, damageApplied: 0 };
                }
                enemy.hp = Math.max(0, enemy.hp - applied);
                enemy.highlightCubeId = bestCube.id;
                enemy.highlightTimer = 0.35;

                // Dash behind enemies when hit (if cooldown allows)
                if (enemy.dashCooldown <= 0) {
                    const nearbyEnemies = store.enemies.filter(e => 
                        e && e !== enemy && !e.dead && e.type !== 'cube_burglar' && 
                        Math.hypot(e.x - enemy.x, e.y - enemy.y) < 400
                    );
                    if (nearbyEnemies.length > 0) {
                        // Find best enemy to dash behind (furthest from player)
                        const player = store.player;
                        let bestEnemy = null;
                        let bestScore = -Infinity;
                        for (const e of nearbyEnemies) {
                            const distToPlayer = Math.hypot(e.x - player.x, e.y - player.y);
                            const distToMe = Math.hypot(e.x - enemy.x, e.y - enemy.y);
                            const score = distToPlayer - distToMe * 0.5; // Prefer far-from-player but not too far from burglar
                            if (score > bestScore) {
                                bestScore = score;
                                bestEnemy = e;
                            }
                        }
                        if (bestEnemy) {
                            // Dash to position behind the enemy (opposite from player)
                            const dx = bestEnemy.x - player.x;
                            const dy = bestEnemy.y - player.y;
                            const dist = Math.hypot(dx, dy);
                            if (dist > 0) {
                                const behindDist = 50; // Distance behind enemy
                                const targetX = bestEnemy.x + (dx / dist) * behindDist;
                                const targetY = bestEnemy.y + (dy / dist) * behindDist;
                                enemy.target = { x: targetX, y: targetY };
                                enemy.targetBehavior = 'dash';
                                enemy.targetTimer = 0.4; // Quick dash
                                enemy.isDashing = true;
                                enemy.dashDuration = 0.4;
                                enemy.dashCooldown = 3.5; // 3.5 second cooldown
                            }
                        }
                    }
                }

                if (bestCube.destroyed && !bestCube.isDetail) {
                    enemy.cubeAliveCount = Math.max(0, enemy.cubeAliveCount - 1);
                    const gold = CUBE_BURGLAR_CONFIG.perCubeGold;
                    if (gold > 0) addWorldGold(gold);
                    const xp = CUBE_BURGLAR_CONFIG.perCubeXp;
                    if (xp > 0) awardXp(xp); // Apply XP diminishing returns
                    store.activeEffects.push(createEffect('hitSpark', enemy.x + bestCube.screen.x, enemy.y + bestCube.screen.y, (bestCube.size || 8) * 2, {
                        strength: 42,
                        crit: false
                    }));
                }

                // Only defeat when ALL cubes are destroyed, not just HP reaching zero
                if (enemy.cubeAliveCount <= 0) {
                    defeatCubeBurglar(enemy);
                }

                return {
                    hit: true,
                    damageApplied: applied,
                    impactPoint: {
                        x: enemy.x + (bestCube.screen?.x || 0),
                        y: enemy.y + (bestCube.screen?.y || 0)
                    }
                };
            }

            function updateCubeBurglar(enemy, dt) {
                if (enemy && enemy.collisionDamageCooldown && enemy.collisionDamageCooldown > 0) {
                    enemy.collisionDamageCooldown = Math.max(0, enemy.collisionDamageCooldown - dt);
                }

                if (enemy.spawnPhase === 'teleport') {
                    const duration = Math.max(0.001, enemy.spawnDuration || 0.6);
                    enemy.spawnTimer = (enemy.spawnTimer ?? duration) - dt;
                    const remaining = Math.max(0, enemy.spawnTimer);
                    const progress = Math.min(1, 1 - remaining / duration);
                    const eased = 1 - Math.pow(1 - progress, 3);
                    const startY = enemy.spawnStartY ?? (enemy.spawnTargetY ?? enemy.y);
                    const targetY = enemy.spawnTargetY ?? enemy.y;
                    enemy.y = startY + (targetY - startY) * eased;
                    enemy.spawnOpacity = Math.min(1, Math.max(enemy.spawnOpacity ?? 0, eased * 1.1));
                    if (enemy.spawnTimer <= 0) {
                        enemy.spawnPhase = null;
                        enemy.spawnOpacity = 1;
                        enemy.y = targetY;
                    }
                }

                enemy.time = (enemy.time || 0) + dt;
                enemy.renderOffsetY = Math.sin(enemy.time * 1.4) * 12;
                enemy.renderOffsetZ = Math.cos(enemy.time * 1.1) * 8;
                enemy.rotationY += (degToRad(-208 + Math.sin(enemy.time * 0.6) * 22) - enemy.rotationY) * dt * 1.2;
                enemy.rotationZ += (degToRad(34 + Math.cos(enemy.time * 0.8) * 18) - enemy.rotationZ) * dt * 1.1;

                enemy.targetTimer = (enemy.targetTimer || 0) - dt;
                if (enemy.targetTimer <= 0 || !enemy.target) {
                    const selection = chooseCubeBurglarTarget(enemy);
                    if (selection) {
                        enemy.target = { x: selection.x, y: selection.y };
                        enemy.targetBehavior = selection.behavior;
                        enemy.targetTimer = selection.reacquire || 0.7;
                    } else {
                        enemy.target = enemy.target || { x: enemy.x, y: enemy.y };
                        enemy.targetBehavior = null;
                        enemy.targetTimer = 0.7;
                    }
                }

                if (enemy.kiteTimer > 0) {
                    enemy.kiteTimer -= dt;
                }

                // Update dash state
                if (enemy.dashCooldown > 0) {
                    enemy.dashCooldown -= dt;
                }
                if (enemy.isDashing) {
                    enemy.dashDuration -= dt;
                    if (enemy.dashDuration <= 0) {
                        enemy.isDashing = false;
                    }
                }

                const dx = enemy.target.x - enemy.x;
                const dy = enemy.target.y - enemy.y;
                const dist = Math.max(1, Math.hypot(dx, dy));
                const baseMoveSpeed = enemy.moveSpeed + enemy.buffStacks * 12;
                const moveSpeed = enemy.isDashing ? baseMoveSpeed * 2.5 : baseMoveSpeed; // 2.5x speed during dash
                enemy.x += (dx / dist) * moveSpeed * dt;
                enemy.y += (dy / dist) * (moveSpeed * 0.85) * dt;

                const margin = enemy.r || 54;
                enemy.x = Math.max(margin, Math.min(W - margin, enemy.x));
                enemy.y = Math.max(margin, Math.min(H - margin, enemy.y));

                enemy.cubes.forEach(cube => {
                    cube.update(dt);
                    projectCubeForBurglar(enemy, cube);
                });

                applyCubeBurglarAura(enemy, dt);
                pullPowerupsToCubeBurglar(enemy, dt);

                if (enemy.highlightTimer > 0) {
                    enemy.highlightTimer = Math.max(0, enemy.highlightTimer - dt);
                }

                if (enemy.contactCooldown > 0) {
                    enemy.contactCooldown -= dt;
                }

                if (enemy.contactCooldown <= 0 && !store.isDamageOff && collide(enemy, store.player)) {
                    resolvePlayerEnemyCollision(enemy, {
                        enemyCooldown: 0.6,
                        playerCooldown: 0.35,
                        separationForce: 26
                    });
                }

                enemy.auraDamageMult = enemy.baseAuraDamageMult + enemy.buffStacks * CUBE_BURGLAR_CONFIG.stackDamageBonus;
                
                // Recalculate HP based on cube integrity
                const totalCubeDamage = enemy.cubes.reduce((sum, cube) => sum + (cube.hpMax - cube.hp), 0);
                enemy.hp = Math.max(1, enemy.hpMax - totalCubeDamage); // Never let HP reach exactly 0 from calculation
                
                // Safety check: prevent spurious defeat from HP calculation errors
                if (enemy.hp <= 0 && enemy.cubeAliveCount > 0) {
                    enemy.hp = 1; // Keep alive if cubes remain
                }
            }

            function drawCubeBurglarPixi(enemy) {
                if (!enemy || enemy.dead || !cubeBurglarContainer) return;
                
                // Create or reuse graphics object
                if (!enemy.pixiGraphics) {
                    enemy.pixiGraphics = new PIXI.Graphics();
                    cubeBurglarContainer.addChild(enemy.pixiGraphics);
                }
                
                const graphics = enemy.pixiGraphics;
                graphics.clear();
                
                // Draw aura
                const auraPulse = 1 + (enemy.auraPulse || 0) * 0.22;
                const auraRange = enemy.auraRange || 220;
                const auraAlpha = 0.28 + (enemy.buffStacks * 0.04);
                graphics.circle(enemy.x, enemy.y, auraRange * auraPulse);
                graphics.fill({ color: 0xff6ad5, alpha: auraAlpha * 0.35 });
                
                // Draw shadow
                const groundY = enemy.shadowGround ?? 70;
                graphics.ellipse(enemy.x, enemy.y + groundY, 30, 15);
                graphics.fill({ color: 0x000000, alpha: 0.18 });
                
                // Get and sort cubes by depth
                const cubes = enemy.cubes.filter(cube => cube && !cube.destroyed);
                const sorted = cubes.slice().sort((a, b) => (a.screen?.z || 0) - (b.screen?.z || 0));
                const highlightId = enemy.highlightTimer > 0 ? enemy.highlightCubeId : null;
                
                // Draw each cube
                sorted.forEach(cube => {
                    const screen = cube.screen;
                    let screenX = enemy.x + screen.x;
                    let screenY = enemy.y + screen.y;
                    
                    if (cube.damageTimer > 0) {
                        screenX += (Math.random() - 0.5) * 3;
                        screenY += (Math.random() - 0.5) * 3;
                    }
                    
                    const size = cube.size + Math.sin((enemy.time || 0) * 0.9 + cube.pulseOffset) * 0.8;
                    
                    // Isometric cube vertices
                    const points = [
                        { x: 0, y: -size },
                        { x: size, y: -size / 2 },
                        { x: size, y: size / 2 },
                        { x: 0, y: size },
                        { x: -size, y: size / 2 },
                        { x: -size, y: -size / 2 }
                    ];
                    
                    // Parse HSL color and get variants
                    const cubeAlpha = cube.isKnapsack ? 0.65 : 0.85;
                    const baseColor = parseHslToHex(cube.color);
                    const topColor = lightenColor(baseColor, 18);
                    const rightColor = darkenColor(baseColor, 18);
                    
                    // Draw top face
                    graphics.poly([
                        { x: screenX + points[0].x, y: screenY + points[0].y },
                        { x: screenX + points[1].x, y: screenY + points[1].y },
                        { x: screenX + points[2].x, y: screenY + points[2].y - size },
                        { x: screenX + points[5].x, y: screenY + points[5].y - size }
                    ]);
                    graphics.fill({ color: topColor, alpha: cubeAlpha });
                    graphics.stroke({ width: 0.6, color: darkenColor(topColor, 12), alpha: cubeAlpha });
                    
                    // Draw left face
                    graphics.poly([
                        { x: screenX + points[0].x, y: screenY + points[0].y },
                        { x: screenX + points[5].x, y: screenY + points[5].y },
                        { x: screenX + points[4].x, y: screenY + points[4].y },
                        { x: screenX + points[3].x, y: screenY + points[3].y }
                    ]);
                    graphics.fill({ color: baseColor, alpha: cubeAlpha });
                    graphics.stroke({ width: 0.6, color: darkenColor(baseColor, 12), alpha: cubeAlpha });
                    
                    // Draw right face
                    graphics.poly([
                        { x: screenX + points[0].x, y: screenY + points[0].y },
                        { x: screenX + points[1].x, y: screenY + points[1].y },
                        { x: screenX + points[2].x, y: screenY + points[2].y },
                        { x: screenX + points[3].x, y: screenY + points[3].y }
                    ]);
                    graphics.fill({ color: rightColor, alpha: cubeAlpha });
                    graphics.stroke({ width: 0.6, color: darkenColor(rightColor, 12), alpha: cubeAlpha });
                    
                    // Draw highlight if this cube was recently hit
                    if (highlightId === cube.id) {
                        const highlightAlpha = Math.max(0.2, enemy.highlightTimer);
                        graphics.ellipse(screenX, screenY, size * 1.25, size * 0.75);
                        graphics.stroke({ width: 1.2, color: 0xffdfef, alpha: highlightAlpha });
                    }
                });
            }
            
            // Helper functions for color manipulation in PixiJS
            function parseHslToHex(hslString) {
                // Parse HSL string like "hsl(120, 50%, 50%)" to hex
                const match = hslString.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (!match) return 0xffffff;
                
                const h = parseInt(match[1]) / 360;
                const s = parseInt(match[2]) / 100;
                const l = parseInt(match[3]) / 100;
                
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                const r = Math.round(hue2rgb(p, q, h + 1/3) * 255);
                const g = Math.round(hue2rgb(p, q, h) * 255);
                const b = Math.round(hue2rgb(p, q, h - 1/3) * 255);
                
                return (r << 16) | (g << 8) | b;
            }
            
            function lightenColor(hex, percent) {
                const r = (hex >> 16) & 0xff;
                const g = (hex >> 8) & 0xff;
                const b = hex & 0xff;
                
                const factor = 1 + (percent / 100);
                const nr = Math.min(255, Math.round(r * factor));
                const ng = Math.min(255, Math.round(g * factor));
                const nb = Math.min(255, Math.round(b * factor));
                
                return (nr << 16) | (ng << 8) | nb;
            }
            
            function darkenColor(hex, percent) {
                const r = (hex >> 16) & 0xff;
                const g = (hex >> 8) & 0xff;
                const b = hex & 0xff;
                
                const factor = 1 - (percent / 100);
                const nr = Math.max(0, Math.round(r * factor));
                const ng = Math.max(0, Math.round(g * factor));
                const nb = Math.max(0, Math.round(b * factor));
                
                return (nr << 16) | (ng << 8) | nb;
            }

            function drawMantaPixi(enemy) {
                if (!enemy) return;
                
                // Cleanup if dead
                if (enemy.dead) {
                    if (enemy.pixiGraphics) {
                        enemy.pixiGraphics.destroy();
                        enemy.pixiGraphics = null;
                    }
                    return;
                }
                
                // Create or reuse graphics object
                if (!enemy.pixiGraphics) {
                    enemy.pixiGraphics = new PIXI.Graphics();
                    pixiApp.stage.addChild(enemy.pixiGraphics);
                }
                
                const graphics = enemy.pixiGraphics;
                graphics.clear();
                graphics.position.set(enemy.x, enemy.y);
                
                const time = performance.now() / 1000;
                const r = enemy.r;
                
                // Futuristic drone color scheme - electric cyan and purple
                const bodyColor = 0x1a0033; // Deep purple body
                const accentColor = 0x00ffff; // Cyan accent
                const coreColor = 0xff00ff; // Magenta core
                const glowPulse = 0.7 + 0.3 * Math.sin(time * 3);
                
                // Main hexagonal body
                const hexPoints = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    hexPoints.push(Math.cos(angle) * r * 0.8, Math.sin(angle) * r * 0.8);
                }
                graphics.poly(hexPoints);
                graphics.fill(bodyColor);
                graphics.stroke({ width: 2, color: accentColor, alpha: glowPulse });
                
                // Energy core in center
                graphics.circle(0, 0, r * 0.3);
                graphics.fill({ color: coreColor, alpha: glowPulse });
                
                // Inner hexagon glow
                const innerHexPoints = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i + time * 2; // Rotating inner hex
                    innerHexPoints.push(Math.cos(angle) * r * 0.5, Math.sin(angle) * r * 0.5);
                }
                graphics.poly(innerHexPoints);
                graphics.stroke({ width: 1, color: accentColor, alpha: 0.5 });
                
                // Four drone arms extending from corners
                const armLength = r * 1.2;
                const armWidth = r * 0.15;
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI / 2) * i + Math.PI / 4;
                    const baseX = Math.cos(angle) * r * 0.6;
                    const baseY = Math.sin(angle) * r * 0.6;
                    const endX = Math.cos(angle) * armLength;
                    const endY = Math.sin(angle) * armLength;
                    
                    // Arm beam
                    graphics.moveTo(baseX, baseY);
                    graphics.lineTo(endX, endY);
                    graphics.stroke({ width: 3, color: bodyColor });
                    graphics.moveTo(baseX, baseY);
                    graphics.lineTo(endX, endY);
                    graphics.stroke({ width: 1, color: accentColor });
                    
                    // Energy tip on arm
                    graphics.circle(endX, endY, armWidth);
                    graphics.fill({ color: coreColor, alpha: glowPulse });
                }
            }

            function drawMechPixi(enemy) {
                if (!enemy) return;
                
                // Cleanup if dead
                if (enemy.dead) {
                    if (enemy.pixiGraphics) {
                        enemy.pixiGraphics.destroy();
                        enemy.pixiGraphics = null;
                    }
                    return;
                }
                
                // Create or reuse graphics object
                if (!enemy.pixiGraphics) {
                    enemy.pixiGraphics = new PIXI.Graphics();
                    pixiApp.stage.addChild(enemy.pixiGraphics);
                }
                
                const graphics = enemy.pixiGraphics;
                graphics.clear();
                
                const isElite = enemy.isElite || enemy.type === 'mech_elite';
                const time = performance.now() / 1000;
                const pulseFactor = 1 + 0.05 * Math.sin(time * 4);
                
                // Color schemes
                let mainColor, accentColor, metalColor, glowColor, highlightColor, chassisGradientColors;
                
                if (isElite) {
                    // Purple and red gradient elite variant
                    mainColor = 0x4a0080;
                    accentColor = 0xff0044;
                    metalColor = 0x8800aa;
                    glowColor = 0xff44ff;
                    highlightColor = 0xff6699;
                    chassisGradientColors = [0xff0044, 0x7700aa, 0x4a0080];
                } else {
                    // Normal aqua blue theme
                    mainColor = 0x0e4b5c;
                    accentColor = 0x20b2aa;
                    metalColor = 0x2e8b8b;
                    glowColor = 0x00ffff;
                    highlightColor = 0x40e0d0;
                    chassisGradientColors = [0x40e0d0, 0x0e4b5c, 0x051e28];
                }
                
                const r = enemy.r;
                
                // Main chassis
                graphics.poly([
                    -r * 1.2, -r * 1.0,
                    r * 1.2, -r * 1.0,
                    r * 0.7, r * 0.6,
                    -r * 0.7, r * 0.6
                ]);
                graphics.fill(chassisGradientColors[1]);
                graphics.stroke({ width: 2, color: accentColor });
                
                // Top highlight layer
                graphics.poly([
                    -r * 1.1, -r * 0.95,
                    r * 1.1, -r * 0.95,
                    r * 0.8, -r * 0.2,
                    -r * 0.8, -r * 0.2
                ]);
                graphics.fill({ color: chassisGradientColors[0], alpha: 0.3 });
                
                // Armor plating lines
                graphics.lineStyle(1, metalColor);
                for (let i = -2; i <= 2; i++) {
                    graphics.moveTo(i * r * 0.2, -r * 0.8);
                    graphics.lineTo(i * r * 0.15, r * 0.4);
                }
                
                // Rivets
                const rivetColor = isElite ? 0xff0088 : 0x5f9ea0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        graphics.circle(i * r * 0.3, j * r * 0.3, r * 0.08);
                        graphics.fill(rivetColor);
                    }
                }
                
                // Left turret
                graphics.rect(-r * 1.6, -r * 0.9, r * 0.7, r * 1.8);
                graphics.fill(mainColor);
                graphics.stroke({ width: 3, color: accentColor });
                
                // Left cannon barrel
                graphics.rect(-r * 1.3 - r * 0.5, -r * 0.1, r * 0.8, r * 0.2);
                graphics.fill(metalColor);
                graphics.stroke({ width: 3, color: accentColor });
                
                // Right turret
                graphics.rect(r * 0.9, -r * 0.9, r * 0.7, r * 1.8);
                graphics.fill(mainColor);
                graphics.stroke({ width: 3, color: accentColor });
                
                // Right cannon barrel
                graphics.rect(r * 1.3, -r * 0.1, r * 0.8, r * 0.2);
                graphics.fill(metalColor);
                graphics.stroke({ width: 3, color: accentColor });
                
                // Eyes/sensors with glow
                graphics.circle(-r * 0.3, -r * 0.4, r * 0.12 * pulseFactor);
                graphics.fill({ color: glowColor, alpha: 0.9 });
                graphics.circle(r * 0.3, -r * 0.4, r * 0.12 * pulseFactor);
                graphics.fill({ color: glowColor, alpha: 0.9 });
                
                // Outer glow for eyes
                graphics.circle(-r * 0.3, -r * 0.4, r * 0.18 * pulseFactor);
                graphics.fill({ color: glowColor, alpha: 0.3 });
                graphics.circle(r * 0.3, -r * 0.4, r * 0.18 * pulseFactor);
                graphics.fill({ color: glowColor, alpha: 0.3 });
                
                // Left tread
                graphics.circle(-r * 1.3, r * 1.2, r * 0.6);
                graphics.fill(0x1c4e4e);
                graphics.stroke({ width: 2, color: metalColor });
                
                // Left tread segments
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time * 2;
                    const x = -r * 1.3 + Math.cos(angle) * r * 0.4;
                    const y = r * 1.2 + Math.sin(angle) * r * 0.4;
                    graphics.rect(x - r * 0.1, y - r * 0.05, r * 0.2, r * 0.1);
                    graphics.fill(0x4682b4);
                }
                
                // Right tread
                graphics.circle(r * 1.3, r * 1.2, r * 0.6);
                graphics.fill(0x1c4e4e);
                graphics.stroke({ width: 2, color: metalColor });
                
                // Right tread segments
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time * 2;
                    const x = r * 1.3 + Math.cos(angle) * r * 0.4;
                    const y = r * 1.2 + Math.sin(angle) * r * 0.4;
                    graphics.rect(x - r * 0.1, y - r * 0.05, r * 0.2, r * 0.1);
                    graphics.fill(0x4682b4);
                }
                
                // Command cockpit
                graphics.rect(-r * 0.4, -r * 1.4, r * 0.8, r * 0.5);
                graphics.fill({ color: accentColor, alpha: 0.6 });
                graphics.stroke({ width: 2, color: highlightColor });
                
                // Cockpit window
                graphics.rect(-r * 0.3, -r * 1.3, r * 0.6, r * 0.3);
                graphics.fill({ color: glowColor, alpha: 0.4 });
                
                // Elite sparkle effects
                if (isElite) {
                    const sparkleCount = 6;
                    for (let i = 0; i < sparkleCount; i++) {
                        const angle = (i / sparkleCount) * Math.PI * 2 + time * 3;
                        const dist = r * 1.5;
                        const sx = Math.cos(angle) * dist;
                        const sy = Math.sin(angle) * dist;
                        const sparkleSize = r * 0.08 * (1 + 0.5 * Math.sin(time * 5 + i));
                        graphics.star(sx, sy, 4, sparkleSize, sparkleSize * 0.5);
                        graphics.fill({ color: 0xffff00, alpha: 0.7 });
                    }
                }
                
                // FROZEN VISUAL OVERLAY - Render ice effect on PixiJS layer so it's visible over mech sprite
                if (enemy.isFrozen && enemy.iceStacks >= 3) {
                    // Bright blue ice shell with reduced opacity
                    graphics.circle(0, 0, r * 1.4);
                    graphics.fill({ color: 0x80d0ff, alpha: 0.35 });
                    
                    // Thick white frosty border (multiple rings for emphasis)
                    graphics.circle(0, 0, r * 1.3);
                    graphics.stroke({ width: Math.max(4, r * 0.2), color: 0xffffff, alpha: 0.7 });
                    
                    // Secondary frost ring with pulse
                    const frostPulse = 0.85 + 0.15 * Math.sin(time * 3);
                    graphics.circle(0, 0, r * 1.38);
                    graphics.stroke({ width: Math.max(2, r * 0.12), color: 0xe0f0ff, alpha: 0.5 * frostPulse });
                }
                
                // Position graphics
                graphics.x = enemy.x;
                graphics.y = enemy.y;
            }

            function drawCubeBurglar(enemy) {
                if (!enemy || enemy.dead) return;
                
                // Use PixiJS rendering if available
                if (pixiApp && cubeBurglarContainer) {
                    drawCubeBurglarPixi(enemy);
                    return;
                }
                
                // Fallback to canvas rendering
                const auraPulse = 1 + (enemy.auraPulse || 0) * 0.22;
                const auraRange = enemy.auraRange || 220;
                ctx.save();
                ctx.globalAlpha *= 0.28 + (enemy.buffStacks * 0.04);
                ctx.fillStyle = 'rgba(255,106,213,0.35)';
                ctx.beginPath();
                ctx.arc(0, 0, auraRange * auraPulse, 0, TAU);
                ctx.fill();
                ctx.restore();

                const cubes = enemy.cubes.filter(cube => cube && !cube.destroyed);
                const sorted = cubes.slice().sort((a, b) => (a.screen?.z || 0) - (b.screen?.z || 0));
                const highlightId = enemy.highlightTimer > 0 ? enemy.highlightCubeId : null;

                const groundY = enemy.shadowGround ?? 70;
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.18)';
                ctx.filter = 'blur(6px)';
                ctx.beginPath();
                ctx.ellipse(0, groundY, 30, 15, 0, 0, TAU);
                ctx.fill();
                ctx.filter = 'none';
                ctx.restore();

                sorted.forEach(cube => {
                    const screen = cube.screen;
                    let screenX = screen.x;
                    let screenY = screen.y;
                    if (cube.damageTimer > 0) {
                        screenX += (Math.random() - 0.5) * 3;
                        screenY += (Math.random() - 0.5) * 3;
                    }
                    const size = cube.size + Math.sin((enemy.time || 0) * 0.9 + cube.pulseOffset) * 0.8;
                    const points = [
                        { x: 0, y: -size },
                        { x: size, y: -size / 2 },
                        { x: size, y: size / 2 },
                        { x: 0, y: size },
                        { x: -size, y: size / 2 },
                        { x: -size, y: -size / 2 }
                    ];

                    ctx.save();
                    ctx.translate(screenX, screenY);
                    
                    // Apply translucency for better depth perception
                    if (cube.isKnapsack) {
                        ctx.globalAlpha = 0.65; // Translucent red knapsack
                    } else {
                        ctx.globalAlpha = 0.85; // Slightly translucent body for depth
                    }
                    
                    const topColor = lightenHsl(cube.color, 18);
                    const leftColor = cube.color;
                    const rightColor = darkenHsl(cube.color, 18);
                    ctx.lineWidth = 0.6;

                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.lineTo(points[2].x, points[2].y - size);
                    ctx.lineTo(points[5].x, points[5].y - size);
                    ctx.closePath();
                    ctx.fillStyle = topColor;
                    ctx.strokeStyle = darkenHsl(topColor, 12);
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[5].x, points[5].y);
                    ctx.lineTo(points[4].x, points[4].y);
                    ctx.lineTo(points[3].x, points[3].y);
                    ctx.closePath();
                    ctx.fillStyle = leftColor;
                    ctx.strokeStyle = darkenHsl(leftColor, 12);
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.lineTo(points[2].x, points[2].y);
                    ctx.lineTo(points[3].x, points[3].y);
                    ctx.closePath();
                    ctx.fillStyle = rightColor;
                    ctx.strokeStyle = darkenHsl(rightColor, 12);
                    ctx.fill();
                    ctx.stroke();

                    if (highlightId === cube.id) {
                        ctx.globalAlpha = Math.max(0.2, enemy.highlightTimer);
                        ctx.strokeStyle = '#ffdfef';
                        ctx.lineWidth = 1.2;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, size * 1.25, size * 0.75, 0, 0, TAU);
                        ctx.stroke();
                    }
                    ctx.restore();
                });

                const stolen = enemy.stolenPowerups;
                if (Array.isArray(stolen) && stolen.length) {
                    const torsoCubes = enemy.cubes.filter(cube => cube && !cube.destroyed && !cube.isDetail && cube.partType === 'torso');
                    const basis = torsoCubes.length ? torsoCubes : enemy.cubes.filter(cube => cube && !cube.destroyed && !cube.isDetail);
                    let bellyX = 0;
                    let bellyY = 0;
                    if (basis.length) {
                        for (let i = 0; i < basis.length; i++) {
                            const screen = basis[i].screen || { x: 0, y: 0 };
                            bellyX += screen.x;
                            bellyY += screen.y;
                        }
                        bellyX /= basis.length;
                        bellyY /= basis.length;
                    }
                    const displayPowerup = stolen[stolen.length - 1] || null;
                    const iconDef = displayPowerup && POWERUP_TYPES[displayPowerup.type];
                    const icon = iconDef ? (iconDef.canvasIcon || iconDef.icon || '?') : '?';
                    const bubbleRadius = Math.max(8, CUBE_BURGLAR_CONFIG.cubeSize * 2.2);
                    ctx.save();
                    ctx.translate(bellyX, bellyY + 2);
                    const pulse = 0.92 + Math.sin((enemy.time || 0) * 5.2) * 0.08;
                    ctx.scale(pulse, pulse);
                    ctx.globalAlpha = 0.9;
                    const glow = ctx.createRadialGradient(0, 0, bubbleRadius * 0.3, 0, 0, bubbleRadius);
                    glow.addColorStop(0, 'rgba(255, 220, 150, 0.95)');
                    glow.addColorStop(1, 'rgba(255, 106, 213, 0.18)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(0, 0, bubbleRadius, 0, TAU);
                    ctx.fill();
                    ctx.lineWidth = 1.2;
                    ctx.strokeStyle = 'rgba(255, 106, 213, 0.85)';
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#1f0b16';
                    ctx.font = 'bold 11px Orbitron, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(icon, 0, -1);
                    if (stolen.length > 1) {
                        ctx.font = 'bold 8px Orbitron, sans-serif';
                        ctx.fillStyle = '#ffe6ff';
                        ctx.textBaseline = 'top';
                        ctx.fillText(`x${stolen.length}`, 0, bubbleRadius + 7);
                    }
                    ctx.restore();
                }
            }

            let activeMapThemeState = null;
            let transitioningMapThemeState = null;
            let themeTransitionTimer = 0;

            function ensureValidThemeKey(themeKey) {
                if (themeKey && MAP_THEME_DEFS[themeKey]) return themeKey;
                return DEFAULT_MAP_THEME_KEY;
            }

            function randRange(min, max) {
                return min + Math.random() * (max - min);
            }

            function instantiateMapThemeState(themeKey) {
                const key = ensureValidThemeKey(themeKey);
                const def = MAP_THEME_DEFS[key] || MAP_THEME_DEFS[DEFAULT_MAP_THEME_KEY];
                return {
                    key,
                    def,
                    starLayers: (def.starLayers || []).map(layer => ({
                        config: layer,
                        stars: Array.from({ length: layer.count || 0 }, () => ({
                            x: Math.random() * W,
                            y: Math.random() * H,
                            radius: randRange(layer.minRadius || 0.25, layer.maxRadius || 1.4),
                            twinkleSeed: Math.random() * TAU
                        }))
                    })),
                    auroraBands: def.auroraBands ? def.auroraBands.map(band => ({
                        config: band,
                        phase: Math.random() * TAU
                    })) : null
                };
            }

            function createThemeGradient(def) {
                if (!def || !def.stops || def.stops.length === 0) return null;
                if (def.type === 'radial') {
                    const radius = Math.min(W, H) * (def.radius !== undefined ? def.radius : 1);
                    const cx = W * (def.x !== undefined ? def.x : 0.5);
                    const cy = H * (def.y !== undefined ? def.y : 0.5);
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
                    def.stops.forEach(stop => gradient.addColorStop(stop.offset, stop.color));
                    return gradient;
                }
                const angle = def.angle !== undefined ? def.angle : 0;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const half = Math.max(W, H);
                const cx = W / 2;
                const cy = H / 2;
                const gradient = ctx.createLinearGradient(cx - cos * half, cy - sin * half, cx + cos * half, cy + sin * half);
                def.stops.forEach(stop => gradient.addColorStop(stop.offset, stop.color));
                return gradient;
            }

            function renderThemeStarLayers(state, dt, alpha) {
                if (!state || !state.starLayers || state.starLayers.length === 0 || alpha <= 0) return;
                const alphaClamp = Math.max(0, Math.min(1, alpha));
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (let l = 0; l < state.starLayers.length; l++) {
                    const layer = state.starLayers[l];
                    const cfg = layer.config || {};
                    const stars = layer.stars;
                    const speed = cfg.speed || 28;
                    const driftX = cfg.driftX || 0;
                    const twinkleSpeed = cfg.twinkleSpeed || 1.4;
                    const twinkleAmp = cfg.twinkleAmplitude || 0.45;
                    const baseAlpha = alphaClamp * (cfg.baseAlpha !== undefined ? cfg.baseAlpha : 1);
                    const baseColor = cfg.color || 'rgba(255,255,255,0.7)';
                    const pulseColor = cfg.pulseColor || baseColor;
                    for (let i = 0; i < stars.length; i++) {
                        const star = stars[i];
                        star.y += speed * dt;
                        star.x += driftX * dt;
                        if (star.y > H + 20) star.y -= (H + 40);
                        if (star.y < -20) star.y += (H + 40);
                        if (star.x > W + 20) star.x -= (W + 40);
                        if (star.x < -20) star.x += (W + 40);
                        const twinkle = Math.sin(frameTime * twinkleSpeed + star.twinkleSeed);
                        const radius = Math.max(0.05, star.radius * (1 + Math.abs(twinkle) * twinkleAmp));
                        const glowAlpha = baseAlpha * (0.7 + Math.abs(twinkle) * 0.3);
                        ctx.globalAlpha = glowAlpha;
                        ctx.fillStyle = twinkle >= 0 ? pulseColor : baseColor;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, radius, 0, TAU);
                        ctx.fill();
                    }
                }
                ctx.restore();
            }

            function renderThemeAurora(state, dt, alpha) {
                if (!state || !state.auroraBands || state.auroraBands.length === 0 || alpha <= 0) return;
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                for (let i = 0; i < state.auroraBands.length; i++) {
                    const band = state.auroraBands[i];
                    const cfg = band.config || {};
                    const stops = cfg.colorStops || [];
                    if (stops.length === 0) continue;
                    band.phase += (cfg.waveSpeed || 0) * dt;
                    const bandAlpha = (cfg.alpha !== undefined ? cfg.alpha : 0.4) * alpha;
                    if (bandAlpha <= 0) continue;
                    const baseY = (cfg.y !== undefined ? cfg.y : 0.5) * H;
                    const waveOffset = Math.sin(band.phase) * (cfg.waveAmplitude || 0) * H;
                    const thickness = Math.max(6, (cfg.thickness || 0.16) * H);
                    const gradient = ctx.createLinearGradient(0, 0, W, 0);
                    if (stops.length === 1) {
                        gradient.addColorStop(0, stops[0]);
                        gradient.addColorStop(1, stops[0]);
                    } else {
                        for (let s = 0; s < stops.length; s++) {
                            gradient.addColorStop(stops.length === 1 ? 0.5 : s / (stops.length - 1), stops[s]);
                        }
                    }
                    ctx.save();
                    ctx.translate(W * 0.5, baseY + waveOffset);
                    if (cfg.rotation) ctx.rotate(cfg.rotation);
                    ctx.globalAlpha = bandAlpha;
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-W * 0.8, -thickness * 0.5, W * 1.6, thickness);
                    ctx.restore();
                }
                ctx.restore();
            }

            function renderMapThemeState(state, dt, alpha) {
                if (!state || alpha <= 0) return;
                const def = state.def || {};
                const gradient = createThemeGradient(def.gradient);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = gradient || def.baseFill || '#050008';
                ctx.fillRect(0, 0, W, H);
                ctx.restore();
                renderThemeStarLayers(state, dt, alpha);
                renderThemeAurora(state, dt, alpha);
            }

            function setMapThemeImmediate(themeKey) {
                const key = ensureValidThemeKey(themeKey);
                activeMapThemeState = instantiateMapThemeState(key);
                transitioningMapThemeState = null;
                themeTransitionTimer = THEME_TRANSITION_DURATION;
                if (store && store.world) {
                    store.world.currentThemeKey = key;
                    store.world.targetThemeKey = key;
                    store.world.themeTransitionProgress = 1;
                    store.world.themeTransitionActive = false;
                }
            }

            function finalizeMapThemeTransition() {
                if (!transitioningMapThemeState) return;
                activeMapThemeState = transitioningMapThemeState;
                transitioningMapThemeState = null;
                themeTransitionTimer = THEME_TRANSITION_DURATION;
                if (store && store.world) {
                    store.world.currentThemeKey = activeMapThemeState.key;
                    store.world.themeTransitionActive = false;
                    store.world.themeTransitionProgress = 1;
                }
            }

            function transitionMapTheme(themeKey, options = {}) {
                const { immediate = false, force = false } = options;
                const key = ensureValidThemeKey(themeKey);
                if (immediate || !activeMapThemeState) {
                    setMapThemeImmediate(key);
                    return;
                }
                if (!force && activeMapThemeState && activeMapThemeState.key === key && !transitioningMapThemeState) {
                    return;
                }
                transitioningMapThemeState = instantiateMapThemeState(key);
                themeTransitionTimer = 0;
                if (store && store.world) {
                    store.world.targetThemeKey = key;
                    store.world.themeTransitionActive = true;
                    store.world.themeTransitionProgress = 0;
                }
            }

            function queueMapThemeTransition(themeKey, options) {
                transitionMapTheme(themeKey, options);
            }

            function ensureActiveTheme() {
                const desiredKey = ensureValidThemeKey(store?.world?.currentThemeKey);
                if (!activeMapThemeState) {
                    setMapThemeImmediate(desiredKey);
                } else if (activeMapThemeState.key !== desiredKey && !transitioningMapThemeState) {
                    transitionMapTheme(desiredKey, { immediate: true, force: true });
                }
            }

            function advanceMapTheme(dt) {
                ensureActiveTheme();
                if (transitioningMapThemeState) {
                    themeTransitionTimer = Math.min(THEME_TRANSITION_DURATION, themeTransitionTimer + dt);
                    const progress = Math.min(1, themeTransitionTimer / THEME_TRANSITION_DURATION);
                    const fadeOutAlpha = Math.max(0, 1 - progress);
                    if (fadeOutAlpha > 0 && activeMapThemeState) {
                        renderMapThemeState(activeMapThemeState, dt, fadeOutAlpha);
                    }
                    renderMapThemeState(transitioningMapThemeState, dt, progress);
                    if (store && store.world) {
                        store.world.themeTransitionProgress = progress;
                    }
                    if (progress >= 1) {
                        finalizeMapThemeTransition();
                    }
                } else if (activeMapThemeState) {
                    renderMapThemeState(activeMapThemeState, dt, 1);
                } else {
                    ctx.fillStyle = MAP_THEME_DEFS[DEFAULT_MAP_THEME_KEY]?.baseFill || '#050008';
                    ctx.fillRect(0, 0, W, H);
                }
            }

            function getActiveMapThemeKey() {
                if (transitioningMapThemeState) {
                    return transitioningMapThemeState.key;
                }
                if (activeMapThemeState) {
                    return activeMapThemeState.key;
                }
                return ensureValidThemeKey(store?.world?.currentThemeKey);
            }

            function getBossThemeKey(boss) {
                if (!boss) return DEFAULT_MAP_THEME_KEY;
                if (boss.themeKey && MAP_THEME_DEFS[boss.themeKey]) {
                    return boss.themeKey;
                }
                if (boss.name && BOSS_THEME_MAP[boss.name]) {
                    return ensureValidThemeKey(BOSS_THEME_MAP[boss.name]);
                }
                return DEFAULT_MAP_THEME_KEY;
            }

            function applyBossTheme(boss, options = {}) {
                const themeKey = getBossThemeKey(boss);
                const mergedOptions = { force: true, ...options };
                queueMapThemeTransition(themeKey, mergedOptions);
            }

            // Cache for gradient objects to avoid recreation
            let poisonGradientCache = new Map();
            let mechGradientCache = new Map();
            let frameTime = 0;
            let frameCount = 0;

            // Clear caches periodically to prevent memory buildup
            function clearGradientCaches() {
                if (frameCount % 1000 === 0) { // Clear every ~17 seconds at 60fps
                    poisonGradientCache.clear();
                    mechGradientCache.clear();
                }
            }

            function render(dt) {
                frameCount++;
                clearGradientCaches();

                ctx.setTransform(canvasScaleX, 0, 0, canvasScaleY, 0, 0);
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                ctx.imageSmoothingEnabled = false;

                // Performance optimization: Use faster fill method and cache time calculation
                ctx.fillStyle = '#050008';
                ctx.fillRect(0, 0, W, H);
                frameTime = performance.now() / 1000;

                // Render boss-themed background with transitions
                advanceMapTheme(dt);



                const closeBullets = [];
                const farBullets = [];
                const proximityThreshold = 110;
                const playerPos = store.player;

                store.eBullets.forEach(b => {
                    const distSq = (b.x - playerPos.x) ** 2 + (b.y - playerPos.y) ** 2;
                    if (distSq < proximityThreshold ** 2) {
                        closeBullets.push({ bullet: b, dist: Math.sqrt(distSq) });
                    } else {
                        farBullets.push(b);
                    }
                });

                store.powerups.forEach(p => drawPowerup(p));
                drawTimeShards();
                drawGoldenOrbs();
                if (store.tombstones) store.tombstones.forEach(t => drawTombstone(t));
                store.missiles.forEach(m => drawMissile(m));
                store.lightningBolts.forEach(l => drawLightningBolt(l));
                store.hunterLightningChains.forEach(c => drawHunterLightningChain(c));
                store.empNovas.forEach(n => drawEmpNova(n));
                store.flamePulses.forEach(p => drawFlamePulse(p));
                drawStarProjectiles();


                // Optimized far bullets rendering with batched operations
                for (let i = 0; i < farBullets.length; i++) {
                    const b = farBullets[i];

                    // Apply visual fade-in for Death Engine bullet rain
                    let alpha = 1.0;
                    if (b.fadeInTime && b.spawnTime) {
                        const timeAlive = (performance.now() - b.spawnTime) / 1000;
                        alpha = Math.min(1.0, timeAlive / b.fadeInTime);
                    }

                    if (alpha < 1.0) {
                        ctx.save();
                        ctx.globalAlpha = alpha;
                    }

                    if (b.geminiTag === 'ice_shard') {
                        ctx.save();
                        ctx.translate(b.x, b.y);
                        ctx.rotate(Math.atan2(b.vy || 0, b.vx || 1) + Math.PI / 2);
                        const baseRadius = Math.max(4, (b.r || 7) * 0.9);
                        const shardLength = baseRadius * 3.5;
                        const gradient = ctx.createLinearGradient(0, -shardLength, 0, shardLength * 0.4);
                        gradient.addColorStop(0, 'rgba(200, 255, 255, 0.95)');
                        gradient.addColorStop(0.5, 'rgba(120, 220, 255, 0.65)');
                        gradient.addColorStop(1, 'rgba(80, 180, 255, 0.15)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(0, -shardLength);
                        ctx.lineTo(baseRadius, shardLength * 0.25);
                        ctx.lineTo(0, shardLength * 0.5);
                        ctx.lineTo(-baseRadius, shardLength * 0.25);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    } else if (b.geminiTag === 'sol_fire' || b.geminiTag === 'solar_wave') {
                        ctx.save();
                        ctx.translate(b.x, b.y);
                        const radius = (b.r || 8) * 1.4;
                        const gradient = ctx.createRadialGradient(0, 0, radius * 0.25, 0, 0, radius);
                        gradient.addColorStop(0, 'rgba(255, 255, 220, 0.95)');
                        gradient.addColorStop(0.45, b.geminiTag === 'solar_wave' ? 'rgba(255, 170, 70, 0.85)' : 'rgba(255, 190, 90, 0.9)');
                        gradient.addColorStop(1, 'rgba(255, 120, 40, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } else {
                        ctx.fillStyle = b.col;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.r, 0, 6.283185307179586); // Use constant
                        ctx.fill();
                    }

                    if (alpha < 1.0) {
                        ctx.restore();
                    }
                }

                if (store.fragmentProjectiles && store.fragmentProjectiles.length) {
                    // Simple gold fragment rendering - small and fast
                    const maxVisibleFragments = 50;
                    const startIndex = Math.max(0, store.fragmentProjectiles.length - maxVisibleFragments);
                    
                    for (let i = startIndex; i < store.fragmentProjectiles.length; i++) {
                        const frag = store.fragmentProjectiles[i];
                        if (!frag) continue;
                        
                        ctx.save();
                        ctx.translate(frag.x, frag.y);
                        
                        // Fade out over lifetime
                        const maxLifetime = Math.max(0.05, frag.maxLifetime || 0.35);
                        const elapsed = Math.min(maxLifetime, Math.max(0, frag.lifetime || 0));
                        const lifeRatio = 1 - (elapsed / maxLifetime);
                        ctx.globalAlpha = lifeRatio;
                        
                        // Simple solid gold color, small size
                        ctx.fillStyle = frag.col || '#FFD700';
                        ctx.beginPath();
                        ctx.arc(0, 0, frag.r || 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }

                // ============================================================================
                // PIXI BULLET RENDERING - Performance optimized version
                // ============================================================================
                const USE_PIXI_BULLETS = pixiApp && bulletTextures.normal; // Auto-enable when ready
                
                // Log once when Pixi takes over
                if (USE_PIXI_BULLETS && !window._pixiBulletsActive) {
                    window._pixiBulletsActive = true;
                    console.log('ðŸš€ PixiJS bullet rendering ACTIVE - Performance boost engaged!');
                    console.log('ðŸ“Š Texture info:', {
                        normal: bulletTextures.normal?.width + 'x' + bulletTextures.normal?.height,
                        ice: bulletTextures.ice?.width + 'x' + bulletTextures.ice?.height,
                        poison: bulletTextures.poison?.width + 'x' + bulletTextures.poison?.height,
                        fire: bulletTextures.fire?.width + 'x' + bulletTextures.fire?.height,
                        void: bulletTextures.void?.width + 'x' + bulletTextures.void?.height
                    });
                }
                
                if (USE_PIXI_BULLETS) {
                    // Sync Pixi sprites with bullet data
                    const currentBullets = new Set();
                    
                    store.bullets.forEach(b => {
                        if (b.dead) return;
                        
                        // Skip only flame bullets that need Canvas rendering (not lava blades!)
                        if (b.isFlame && !b.isLavaBlade) {
                            currentBullets.add(b);
                            return;
                        }
                        
                        currentBullets.add(b);
                        
                        // Get or create sprite
                        let sprite = activeBulletSprites.get(b);
                        if (!sprite) {
                            sprite = getBulletSprite(b);
                            if (!sprite) return;
                        }
                        
                        // Update sprite position
                        sprite.x = b.x;
                        sprite.y = b.y;
                        
                        // Calculate rotation from velocity (all bullets need this)
                        const angle = Math.atan2(b.vy, b.vx);
                        sprite.rotation = angle + Math.PI / 2;
                        
                        // Update lava blade scale and alpha based on distance from spawn
                        if (b.isLavaBlade) {
                            const distanceFromBirth = Math.hypot(
                                b.x - (b.lavaBladeBirthX || b.x),
                                b.y - (b.lavaBladeBirthY || b.y)
                            );
                            
                            // Match damage dropoff curve: 3x at 0-125px, sharp drop 125-200px
                            let sizeScale = 1;
                            let alphaScale = 1;
                            
                            if (distanceFromBirth <= 125) {
                                // Full size/alpha up to 125px
                                sizeScale = 1;
                                alphaScale = 1;
                            } else if (distanceFromBirth <= 200) {
                                // Sharp falloff from 125-200px: 1.0 down to 0.1
                                const falloffFactor = (200 - distanceFromBirth) / 75;
                                sizeScale = 0.1 + (falloffFactor * 0.9); // 0.1 to 1.0
                                alphaScale = 0.1 + (falloffFactor * 0.9); // 0.1 to 1.0
                            } else {
                                // Beyond 200px: nearly invisible
                                sizeScale = 0.05;
                                alphaScale = 0.05;
                            }
                            
                            sprite.scale.set(1.2 * sizeScale); // Smaller, sharper blades
                            sprite.alpha = alphaScale;
                        } else {
                            // Regular bullets: keep full alpha (no fade)
                            sprite.alpha = 1.0;
                        }
                        
                        // Update particles
                        if (b.particles && b.particles.length > 0) {
                            b.particles.forEach(p => {
                                let pSprite = activeParticleSprites.get(p);
                                if (!pSprite) {
                                    pSprite = getParticleSprite(p, b.element);
                                    if (!pSprite) return;
                                }
                                
                                const t = Math.max(0, Math.min(1, p.life / p.maxLife));
                                pSprite.x = b.x + p.x;
                                pSprite.y = b.y + p.y;
                                pSprite.alpha = 0.75 * t;
                                pSprite.scale.set(p.r * t / 8);
                            });
                        }
                    });
                    
                    // Clean up removed bullets
                    activeBulletSprites.forEach((sprite, bullet) => {
                        if (!currentBullets.has(bullet)) {
                            releaseBulletSprite(bullet);
                        }
                    });
                    
                    // Clean up removed particles
                    const activeParticles = new Set();
                    store.bullets.forEach(b => {
                        if (b.particles) {
                            b.particles.forEach(p => activeParticles.add(p));
                        }
                    });
                    
                    activeParticleSprites.forEach((sprite, particle) => {
                        if (!activeParticles.has(particle)) {
                            releaseParticleSprite(particle);
                        }
                    });
                }
                // ============================================================================

                // Canvas fallback rendering (for special bullets or when Pixi not ready)
                store.bullets.forEach(b => {
                    // Skip bullets if Pixi is handling them (skip lava blades AND flames)
                    if (USE_PIXI_BULLETS && (!b.isFlame || b.isLavaBlade)) {
                        return;
                    }
                    
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.fillStyle = b.col;
                    ctx.beginPath();

                    const r = b.r * 1.5;

                    // Lava blades are rendered by PixiJS - no canvas fallback needed
                    
                    if (b.isFlame) {
                        ctx.fillStyle = `rgba(255, 150, 50, ${0.3 * (b.life / 50)})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, b.r * 0.5, 0, 2 * Math.PI);
                        ctx.fill();
                        b.particles.forEach(p => {
                            const t = p.life / p.maxLife;
                            const r_particle = p.r * t;
                            // Pink particles for lava shards
                            const r_val = 255;
                            const g = Math.floor(105 + 150 * t); // Pink range: 105-255
                            const b_val = Math.floor(180 + 75 * t); // Pink range: 180-255
                            ctx.fillStyle = `rgba(${r_val}, ${g}, ${b_val}, ${0.8 * t})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, r_particle, 0, 2 * Math.PI);
                            ctx.fill();
                        });
                    } else if (b.element === 'ice') {
                        // Ice bullet: blue-purple icy line with dense misty trail
                        ctx.strokeStyle = 'rgba(140, 180, 255, 0.95)'; // Ice blue with purple tint like iceman
                        ctx.lineWidth = r * 0.8;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        // Calculate bullet velocity direction
                        const vx = b.vx || 0;
                        const vy = b.vy || 1;
                        const speed = Math.sqrt(vx * vx + vy * vy);
                        const nx = speed > 0 ? vx / speed : 0;
                        const ny = speed > 0 ? vy / speed : 1;
                        const lineLength = r * 1.8;
                        ctx.moveTo(-nx * lineLength * 0.5, -ny * lineLength * 0.5);
                        ctx.lineTo(nx * lineLength * 0.5, ny * lineLength * 0.5);
                        ctx.stroke();
                        
                        // Dense misty particles trailing the bullet
                        if (b.particles && b.particles.length > 0) {
                            b.particles.forEach(p => {
                                const t = Math.max(0, Math.min(1, p.life / p.maxLife));
                                const particleR = p.r * t;
                                // White misty particles with high opacity for density
                                ctx.fillStyle = `rgba(255, 255, 255, ${0.75 * t})`;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                                ctx.fill();
                                
                                // Add extra glow around each particle for misty effect
                                ctx.fillStyle = `rgba(200, 220, 255, ${0.35 * t})`;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, particleR * 1.8, 0, 2 * Math.PI);
                                ctx.fill();
                            });
                        }
                        
                        ctx.restore();
                        return;
                    } else if (b.element === 'poison') {
                        // Poison bullet: green line with bubbling effect
                        ctx.strokeStyle = 'rgba(50, 255, 50, 0.95)';
                        ctx.lineWidth = r * 0.8;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        // Calculate bullet velocity direction
                        const vx = b.vx || 0;
                        const vy = b.vy || 1;
                        const speed = Math.sqrt(vx * vx + vy * vy);
                        const nx = speed > 0 ? vx / speed : 0;
                        const ny = speed > 0 ? vy / speed : 1;
                        const lineLength = r * 1.8;
                        ctx.moveTo(-nx * lineLength * 0.5, -ny * lineLength * 0.5);
                        ctx.lineTo(nx * lineLength * 0.5, ny * lineLength * 0.5);
                        ctx.stroke();
                        
                        // Poison bubbles trailing the bullet
                        if (b.particles && b.particles.length > 0) {
                            b.particles.forEach(p => {
                                const t = Math.max(0, Math.min(1, p.life / p.maxLife));
                                const particleR = p.r * t;
                                ctx.fillStyle = `rgba(100, 255, 100, ${0.5 * t})`;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                                ctx.fill();
                                // Bubble outline
                                ctx.strokeStyle = `rgba(150, 255, 150, ${0.6 * t})`;
                                ctx.lineWidth = Math.max(0.5, particleR * 0.3);
                                ctx.stroke();
                            });
                        }
                        
                        ctx.restore();
                        return;
                    } else if (b.element === 'fire') {
                        // Fire bullet: ember streak with small flame flickers
                        ctx.strokeStyle = 'rgba(255, 120, 70, 0.95)';
                        ctx.lineWidth = r * 0.8;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        const vx = b.vx || 0;
                        const vy = b.vy || 1;
                        const speed = Math.sqrt(vx * vx + vy * vy);
                        const nx = speed > 0 ? vx / speed : 0;
                        const ny = speed > 0 ? vy / speed : 1;
                        const lineLength = r * 1.9;
                        ctx.moveTo(-nx * lineLength * 0.5, -ny * lineLength * 0.5);
                        ctx.lineTo(nx * lineLength * 0.5, ny * lineLength * 0.5);
                        ctx.stroke();

                        const glowRadius = r * 1.4;
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                        gradient.addColorStop(0, 'rgba(255, 230, 180, 0.6)');
                        gradient.addColorStop(0.6, 'rgba(255, 140, 60, 0.35)');
                        gradient.addColorStop(1, 'rgba(120, 30, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, glowRadius, 0, 2 * Math.PI);
                        ctx.fill();

                        if (b.particles && b.particles.length > 0) {
                            b.particles.forEach(p => {
                                const t = Math.max(0, Math.min(1, p.life / p.maxLife));
                                const particleR = p.r * (0.8 + t * 0.6);
                                ctx.fillStyle = `rgba(255, ${120 + Math.floor(80 * t)}, ${60 + Math.floor(40 * t)}, ${0.55 * t})`;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                                ctx.fill();
                            });
                        }

                        ctx.restore();
                        return;
                    } else if (b.element === 'void') {
                        ctx.strokeStyle = 'rgba(70, 40, 120, 0.9)';
                        ctx.lineWidth = r * 0.85;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        const vx = b.vx || 0;
                        const vy = b.vy || 1;
                        const speed = Math.sqrt(vx * vx + vy * vy);
                        const nx = speed > 0 ? vx / speed : 0;
                        const ny = speed > 0 ? vy / speed : 1;
                        const lineLength = r * 1.9;
                        ctx.beginPath();
                        ctx.moveTo(-nx * lineLength * 0.5, -ny * lineLength * 0.5);
                        ctx.lineTo(nx * lineLength * 0.5, ny * lineLength * 0.5);
                        ctx.stroke();

                        const glowRadius = r * 1.6;
                        const gradient = ctx.createRadialGradient(0, 0, glowRadius * 0.15, 0, 0, glowRadius);
                        gradient.addColorStop(0, 'rgba(210, 195, 255, 0.55)');
                        gradient.addColorStop(0.6, 'rgba(90, 55, 140, 0.4)');
                        gradient.addColorStop(1, 'rgba(5, 0, 15, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                        ctx.fill();

                        if (b.particles && b.particles.length > 0) {
                            b.particles.forEach(p => {
                                const t = Math.max(0, Math.min(1, p.life / p.maxLife));
                                const particleR = p.r * t;
                                ctx.fillStyle = `rgba(150, 120, 230, ${0.45 * t})`;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, particleR, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.strokeStyle = `rgba(20, 8, 35, ${0.35 * t})`;
                                ctx.lineWidth = Math.max(0.4, particleR * 0.4);
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, particleR * 1.6, 0, Math.PI * 2);
                                ctx.stroke();
                            });
                        }

                        ctx.restore();
                        return;
                    } else if (b.isSwirl || b.explosive) {
                        ctx.arc(0, 0, b.r, 0, 2 * Math.PI);
                    } else if (b.isIceman) {
                        ctx.moveTo(0, r); ctx.lineTo(r * 0.8, -r * 0.8); ctx.lineTo(-r * 0.8, -r * 0.8);
                    } else {
                        ctx.moveTo(0, -r); ctx.lineTo(r * 0.8, r * 0.8); ctx.lineTo(-r * 0.8, r * 0.8);
                    }

                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                });

                store.lasers.forEach(l => drawLaser(l));
                store.mines.forEach(m => drawMine(m));
                drawJuggernautBombs();
                if (store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(frameTime * 5)})`; ctx.fill(); ctx.restore(); });

                // Draw poison puddles - optimized
                if (store.poisonPuddles) {
                    store.poisonPuddles.forEach(puddle => {
                        const age = (frameTime * 1000 - puddle.created) / 1000;
                        const maxAge = puddle.life + (15 - puddle.life); // Total possible age

                        ctx.save();
                        ctx.translate(puddle.x, puddle.y);

                        // Animate puddle bubbling - cache sin calculation
                        const bubbleOffset = Math.sin(frameTime * 3 + puddle.x * 0.01) * 2;

                        // Create toxic glow effect - cache gradient by radius
                        const glowRadius = puddle.r * 1.5;
                        const radiusKey = Math.round(glowRadius);
                        let gradient = poisonGradientCache.get(radiusKey);
                        if (!gradient) {
                            gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                            gradient.addColorStop(0, 'rgba(124, 252, 0, 1)');
                            gradient.addColorStop(0.7, 'rgba(173, 255, 47, 0.5)');
                            gradient.addColorStop(1, 'rgba(124, 252, 0, 0)');
                            poisonGradientCache.set(radiusKey, gradient);
                        }

                        const glowAlpha = 0.3 * (puddle.life / 15) + 0.2 * Math.sin(frameTime * 4);
                        ctx.globalAlpha = glowAlpha;
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, bubbleOffset, glowRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        // Draw the puddle itself
                        const puddleAlpha = Math.max(0.4, puddle.life / 15);
                        ctx.fillStyle = `rgba(45, 80, 22, ${puddleAlpha})`;
                        ctx.beginPath();
                        ctx.arc(0, bubbleOffset, puddle.r, 0, Math.PI * 2);
                        ctx.fill();

                        // Add surface texture/ripples
                        ctx.strokeStyle = `rgba(124, 252, 0, ${puddleAlpha * 0.8})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let i = 0; i < 3; i++) {
                            const rippleRadius = puddle.r * (0.3 + i * 0.3) + Math.sin(frameTime * 2 + i) * 3;
                            const rippleAlpha = puddleAlpha * (0.8 - i * 0.2);
                            ctx.globalAlpha = rippleAlpha;
                            ctx.arc(0, bubbleOffset, rippleRadius, 0, Math.PI * 2);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;

                        // Add occasional toxic bubbles - use time-based approach to reduce randomness
                        if (Math.sin(frameTime * 8 + puddle.x * 0.1) > 0.8) {
                            const bubbleX = Math.sin(frameTime * 3 + puddle.x) * puddle.r * 0.3;
                            const bubbleY = Math.cos(frameTime * 2.5 + puddle.y) * puddle.r * 0.3 + bubbleOffset;
                            const bubbleSize = 2 + Math.abs(Math.sin(frameTime * 4 + puddle.x)) * 3;

                            const bubbleAlpha = 0.6 + Math.abs(Math.cos(frameTime * 5 + puddle.y)) * 0.4;
                            ctx.fillStyle = `rgba(124, 252, 0, ${bubbleAlpha})`;
                            ctx.beginPath();
                            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    });
                }

                // Draw mech oil/fuel puddles with aqua color scheme - optimized
                if (store.mechPuddles) {
                    store.mechPuddles.forEach(puddle => {
                        ctx.save();
                        ctx.translate(puddle.x, puddle.y);

                        // Create flickering aqua energy effect - use cached time
                        const flicker = 0.8 + Math.sin(frameTime * 6) * 0.2;
                        const pulseOffset = Math.sin(frameTime * 4 + puddle.x * 0.02) * 1.5;

                        // Calculate shrinking effect as puddle disappears
                        const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
                        const currentRadius = puddle.r * Math.max(0.3, lifePercent); // Shrink to 30% min size

                        // Create aqua hazardous glow effect - cache gradient by radius
                        const glowRadius = currentRadius * 1.4;
                        const radiusKey = Math.round(glowRadius);
                        let gradient = mechGradientCache.get(radiusKey);
                        if (!gradient) {
                            gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                            gradient.addColorStop(0, 'rgba(0, 255, 255, 1)'); // Bright cyan
                            gradient.addColorStop(0.6, 'rgba(32, 178, 170, 0.7)'); // Light sea green
                            gradient.addColorStop(1, 'rgba(0, 139, 139, 0)'); // Dark cyan fade
                            mechGradientCache.set(radiusKey, gradient);
                        }

                        const glowAlpha = 0.4 * lifePercent * flicker;
                        ctx.globalAlpha = glowAlpha;

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, pulseOffset, glowRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw the puddle base (dark aqua/teal liquid) with shrinking
                        const puddleAlpha = Math.max(0.6, lifePercent);
                        ctx.fillStyle = `rgba(14, 75, 92, ${puddleAlpha})`; // Dark aqua blue base
                        ctx.beginPath();
                        ctx.arc(0, pulseOffset, currentRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Add aqua energy surface effects with shrinking
                        ctx.strokeStyle = `rgba(64, 224, 208, ${puddleAlpha * 0.9})`; // Turquoise ripples
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        for (let i = 0; i < 2; i++) {
                            const energyRadius = Math.max(0.1, currentRadius * (0.4 + i * 0.3) + Math.sin(frameTime * 3 + i * 2) * 2);
                            const energyAlpha = puddleAlpha * (0.7 - i * 0.3) * flicker;
                            ctx.globalAlpha = energyAlpha;
                            ctx.arc(0, pulseOffset, energyRadius, 0, Math.PI * 2);
                        }
                        ctx.stroke();
                        ctx.globalAlpha = 1;

                        // Add occasional aqua energy bubbles (only if puddle is large enough)
                        if (currentRadius > 5 && Math.random() < 0.15) {
                            const bubbleX = (Math.random() - 0.5) * currentRadius * 0.8;
                            const bubbleY = (Math.random() - 0.5) * currentRadius * 0.8 + pulseOffset;
                            const bubbleSize = 1 + Math.random() * 2;

                            ctx.fillStyle = `rgba(0, 255, 255, ${0.8 + Math.random() * 0.2})`; // Bright cyan bubbles
                            ctx.beginPath();
                            ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    });
                }

                store.enemies.forEach(e => drawEnemy(e));
                drawHitParticles(ctx);
                drawGibs(ctx); // <-- ADD THIS LINE TO DRAW THE GIBS
                drawFloatingTexts(ctx);
                drawTemporalEchoes();
                drawShadowEchoes();
                drawTemporalBeam();
                drawGeminiSlowFields();
                if (store.boss && store.boss.visible !== false) drawBoss(store.boss);
                store.flameParticles.forEach(p => {
                    if (p.draw) p.draw(ctx);
                    else if (p.color) {
                        ctx.save();
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size || 2, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                });
                store.drones.forEach(d => drawDrone(d));
                if (store.shadowHounds) store.shadowHounds.forEach(h => drawShadowHound(h));
                if (store.voidRifts) store.voidRifts.forEach(rift => drawVoidRift(rift));
                store.hounds.forEach(h => drawHound(h));
                if (CHAMPION_SYSTEM_ENABLED) {
                    const champion = store.playerChampion;
                    if (champion && !champion.dead) {
                        const minions = store.championMinions || [];
                        if (minions.length) {
                            ctx.save();
                            minions.forEach(minion => {
                                if (!minion || minion.dead) return;
                                const abilityModule = minion.abilityModule || champion.attackModule || getChampionUpgradeState().attackModule || 'default';
                                const abilityTheme = minion.abilityTheme || getChampionMinionAbilityTheme(abilityModule);
                                const trailColor = abilityTheme?.trail || '#b4c3ff';
                                const ringColor = abilityTheme?.ring || trailColor;
                                const gradient = ctx.createLinearGradient(champion.x, champion.y, minion.x, minion.y);
                                gradient.addColorStop(0, withAlpha(trailColor, 0.55));
                                gradient.addColorStop(1, withAlpha(ringColor, 0.18));
                                ctx.strokeStyle = gradient;
                                ctx.lineWidth = 1.4;
                                ctx.globalAlpha = 0.4 + Math.min(0.35, (champion.level || 1) * 0.05);
                                ctx.beginPath();
                                ctx.moveTo(champion.x, champion.y);
                                ctx.lineTo(minion.x, minion.y);
                                ctx.stroke();
                            });
                            ctx.restore();

                            minions.forEach(minion => {
                                if (!minion || minion.dead) return;
                                drawChampionMinion(minion, champion);
                            });
                        }

                        drawPlayerChampion(champion);
                    }
                }

                // Draw EMP charges
                if (store.empCharges && store.empCharges.length > 0) {
                    ctx.save();
                    store.empCharges.forEach(charge => {
                        if (!charge || charge.dead) return;
                        
                        const chargeCooldown = EMP_BURST_CONFIG?.chargeCooldown ?? 30;
                        const cooldownRemaining = Math.max(0, charge.cooldown || 0);
                        const cooldownRatio = chargeCooldown > 0 ? Math.min(1, cooldownRemaining / chargeCooldown) : 0;
                        const isRecharging = cooldownRatio > 0;
                        
                        // Draw tether to player - dim significantly when recharging
                        ctx.globalAlpha = isRecharging ? 0.12 : 0.35;
                        const gradient = ctx.createLinearGradient(store.player.x, store.player.y, charge.x, charge.y);
                        if (isRecharging) {
                            gradient.addColorStop(0, 'rgba(60, 80, 120, 0.25)');
                            gradient.addColorStop(1, 'rgba(50, 70, 100, 0.08)');
                        } else {
                            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.4)');
                            gradient.addColorStop(1, 'rgba(150, 220, 255, 0.15)');
                        }
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 1.8;
                        ctx.beginPath();
                        ctx.moveTo(store.player.x, store.player.y);
                        ctx.lineTo(charge.x, charge.y);
                        ctx.stroke();
                    });
                    ctx.restore();

                    store.empCharges.forEach(charge => {
                        if (!charge || charge.dead) return;

                        const chargeCooldown = EMP_BURST_CONFIG?.chargeCooldown ?? 30;
                        const cooldownRemaining = Math.max(0, charge.cooldown || 0);
                        const cooldownRatio = chargeCooldown > 0 ? Math.min(1, cooldownRemaining / chargeCooldown) : 0;
                        const readiness = Math.max(0, 1 - cooldownRatio);

                        const globalCooldown = EMP_BURST_CONFIG?.globalCooldown ?? 0;
                        const globalRemaining = Math.max(0, store.empGlobalCooldown || 0);
                        const globalRatio = globalCooldown > 0 ? Math.min(1, globalRemaining / globalCooldown) : (globalRemaining > 0 ? 1 : 0);
                        const globalFactor = globalRatio > 0 ? Math.max(0.35, 1 - globalRatio * 0.9) : 1;
                        const availability = Math.min(1, readiness * globalFactor);
                        
                        const isRecharging = cooldownRatio > 0;

                        const pulseStrength = isRecharging ? 0.02 : 0.15 * (0.35 + 0.65 * availability);
                        const baseRadius = 8;
                        const pulseScale = 1 + Math.sin(charge.pulsePhase) * pulseStrength;
                        const radius = baseRadius * pulseScale;

                        ctx.save();
                        ctx.translate(charge.x, charge.y);

                        if (isRecharging) {
                            // Deactivated/recharging appearance - very dim and grey
                            ctx.globalAlpha = 0.15;
                            const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2.1);
                            outerGlow.addColorStop(0, 'rgba(60, 80, 120, 0.4)');
                            outerGlow.addColorStop(0.55, 'rgba(50, 70, 100, 0.2)');
                            outerGlow.addColorStop(1, 'rgba(40, 60, 90, 0)');
                            ctx.fillStyle = outerGlow;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius * 2.1, 0, Math.PI * 2);
                            ctx.fill();

                            // Dim grey core when recharging
                            ctx.globalAlpha = 0.25;
                            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                            coreGradient.addColorStop(0, '#8899BB');
                            coreGradient.addColorStop(0.4, '#556688');
                            coreGradient.addColorStop(1, '#334466');
                            ctx.fillStyle = coreGradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Active appearance - bright and pulsing
                            ctx.globalAlpha = 0.18 + 0.42 * availability;
                            const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2.1);
                            outerGlow.addColorStop(0, 'rgba(100, 200, 255, 0.7)');
                            outerGlow.addColorStop(0.55, 'rgba(80, 180, 255, 0.32)');
                            outerGlow.addColorStop(1, 'rgba(60, 160, 255, 0)');
                            ctx.fillStyle = outerGlow;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius * 2.1, 0, Math.PI * 2);
                            ctx.fill();

                            // Core charge brightness tracks readiness
                            ctx.globalAlpha = 0.65 + 0.35 * availability;
                            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                            coreGradient.addColorStop(0, '#FFFFFF');
                            coreGradient.addColorStop(0.4, '#A0E0FF');
                            coreGradient.addColorStop(1, '#4080FF');
                            ctx.fillStyle = coreGradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Cooldown progress ring
                        if (cooldownRatio > 0) {
                            const recoveredRatio = 1 - cooldownRatio;
                            ctx.globalAlpha = 0.8;
                            ctx.strokeStyle = 'rgba(90, 150, 255, 0.85)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius + 3, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * recoveredRatio, false);
                            ctx.stroke();

                            ctx.globalAlpha = 0.25;
                            ctx.fillStyle = 'rgba(40, 90, 180, 0.35)';
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.arc(0, 0, radius + 3, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * recoveredRatio, false);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Highlight global cooldown if charge is ready but ability is globally gated
                        if (cooldownRatio === 0 && globalRatio > 0) {
                            ctx.globalAlpha = 0.85;
                            ctx.strokeStyle = 'rgba(255, 180, 80, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([4, 3]);
                            ctx.beginPath();
                            ctx.arc(0, 0, radius + 6, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * (1 - globalRatio), false);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }

                        // Electric arcs remain but fade with availability
                        ctx.globalAlpha = 0.35 + 0.45 * availability;
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 3; i++) {
                            const angle = (charge.pulsePhase * 2 + i * Math.PI * 2 / 3);
                            const arcRadius = radius * 0.6;
                            ctx.beginPath();
                            ctx.arc(0, 0, arcRadius, angle, angle + Math.PI * 0.3);
                            ctx.stroke();
                        }

                        ctx.restore();
                    });
                }

                drawKnockbackShieldCharges();

                if (store.iceman) drawIceman(store.iceman);
                drawEscortDrones();
                if (store.beefClone) drawBeefClone(store.beefClone);
                drawShip(store.player.x, store.player.y, store.player);

                // Draw EMP disabled effect on player
                if (store.player.empDisabled) {
                    const sizzleIntensity = 0.5 + 0.5 * Math.sin(frameTime * 15);

                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);

                    // Electric sparks around player
                    ctx.strokeStyle = `rgba(255, 140, 0, ${sizzleIntensity})`;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#FF8C00';
                    ctx.shadowBlur = 8;

                    for (let i = 0; i < 8; i++) {
                        if (Math.random() < 0.7) {
                            const angle = (i / 8) * Math.PI * 2 + frameTime * 5;
                            const radius = store.player.r + 5;
                            const x1 = Math.cos(angle) * radius;
                            const y1 = Math.sin(angle) * radius;
                            const x2 = x1 + (Math.random() - 0.5) * 15;
                            const y2 = y1 + (Math.random() - 0.5) * 15;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    }

                    // Purple inner glow
                    ctx.fillStyle = `rgba(138, 43, 226, ${sizzleIntensity * 0.3})`;
                    ctx.shadowColor = '#8A2BE2';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(0, 0, store.player.r * 1.2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Draw poison effect on player
                if (store.player.isPoisoned) {
                    const poisonAlpha = 0.3 + 0.2 * Math.sin(frameTime * 8);

                    ctx.save();
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = `rgba(0, 255, 0, ${poisonAlpha})`;
                    ctx.beginPath();
                    ctx.arc(store.player.x, store.player.y, store.player.r + 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // Add poison particle effect around player
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    for (let i = 0; i < 6; i++) {
                        const angle = frameTime * 2 + i * Math.PI / 3;
                        const x = Math.cos(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
                        const y = Math.sin(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);

                        ctx.fillStyle = `rgba(124, 252, 0, ${0.4 + 0.3 * Math.sin(frameTime * 6 + i)})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 2 + Math.sin(frameTime * 5 + i), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }

                // Draw voidmancer laser beam (Phasestriker only)
                if (store.player.hasVoidLaser && store.player.voidLaserTarget && !store.player.voidLaserTarget.dead) {
                    const p = store.player;
                    const target = p.voidLaserTarget;

                    // Determine laser color based on player ship color
                    let laserColor = '#b266ff'; // Default purple
                    switch (p.subclass) {
                        case 'juggernaut':
                            laserColor = '#ff3333';
                            break;
                        case 'marauder':
                            laserColor = '#33cc33';
                            break;
                        case 'railgunner':
                            laserColor = '#ff6600';
                            break;
                        case 'demolitioner':
                            laserColor = '#ff4500';
                            break;
                        case 'phasestriker':
                            laserColor = '#9900ff';
                            break;
                        case 'stormbringer':
                            laserColor = '#00ccff';
                            break;
                    }

                    const time = performance.now() / 1000;
                    const pulseAlpha = 0.6 + 0.4 * Math.sin(time * 12);

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    // Calculate ramping size for level 2 phasestriker
                    let baseLineWidth = 3;
                    let glowLineWidth = 6;

                    if (p.phasestRikerLevel >= 2) {
                        const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // Same ramp as damage
                        const sizeMultiplier = Math.min(rampMultiplier, 3.0); // Cap at 3x size
                        baseLineWidth *= sizeMultiplier;
                        glowLineWidth *= sizeMultiplier;
                    }

                    // Draw laser beam(s) - double beam for level 4 phasestriker
                    const beamCount = (p.phasestRikerLevel >= 4 && p.doubleBeam) ? 2 : 1;
                    const beamOffsets = beamCount === 2 ? [-8, 8] : [0]; // Parallel beams offset left and right

                    for (let i = 0; i < beamCount; i++) {
                        const offsetX = beamOffsets[i];

                        // Draw main laser beam
                        ctx.strokeStyle = laserColor;
                        ctx.globalAlpha = pulseAlpha;
                        ctx.lineWidth = baseLineWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + offsetX, p.y - 12);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();

                        // Draw laser glow effect - create gradient here
                        const gradient = ctx.createLinearGradient(p.x + offsetX, p.y - 12, target.x, target.y);
                        gradient.addColorStop(0, laserColor + '40');
                        gradient.addColorStop(1, laserColor + '80');

                        ctx.strokeStyle = gradient;
                        ctx.globalAlpha = pulseAlpha * 0.5;
                        ctx.lineWidth = glowLineWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + offsetX, p.y - 12);
                        ctx.lineTo(target.x, target.y);
                        ctx.stroke();
                    }

                    // Add impact effect at target
                    ctx.fillStyle = laserColor;
                    ctx.globalAlpha = pulseAlpha;
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, 4 + Math.sin(time * 8) * 2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Draw wiper lasers (for both Phasestriker and Stormbringer ultimate)
                if (store.player.wiperLasers) {
                    const p = store.player;

                    // Determine laser color based on player ship color
                    let laserColor = '#b266ff'; // Default purple
                    switch (p.subclass) {
                        case 'juggernaut':
                            laserColor = '#ff3333';
                            break;
                        case 'marauder':
                            laserColor = '#33cc33';
                            break;
                        case 'railgunner':
                            laserColor = '#ff6600';
                            break;
                        case 'demolitioner':
                            laserColor = '#ff4500';
                            break;
                        case 'phasestriker':
                            laserColor = '#9900ff';
                            break;
                        case 'stormbringer':
                            laserColor = '#00ccff';
                            break;
                    }

                    const time = performance.now() / 1000;
                    const isSlashing = p.isBlinkSlashing;
                    const basePulseAlpha = 0.8 + 0.2 * Math.sin(time * 10);
                    const pulseAlpha = isSlashing ? basePulseAlpha * 1.3 : basePulseAlpha; // Brighter during slash
                    const laserLength = 180; // Shorter, just long enough to hit boss from safe zone

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';

                    // Draw motion blur trail first (behind main lasers)
                    if (p.wiperLaserBlurTrail && p.wiperLaserBlurTrail.length > 0) {
                        for (const trail of p.wiperLaserBlurTrail) {
                            const trailAlpha = (trail.life / 0.15) * trail.intensity;
                            if (trailAlpha > 0.05) {
                                const trailLasers = [
                                    { angle: trail.angle1, offset: -8 },
                                    { angle: trail.angle2, offset: 8 }
                                ];

                                trailLasers.forEach(trailLaser => {
                                    const trailEndX = p.x + Math.cos(trailLaser.angle) * laserLength;
                                    const trailEndY = p.y + Math.sin(trailLaser.angle) * laserLength;

                                    // Draw blur trail effect
                                    ctx.strokeStyle = laserColor + Math.floor(trailAlpha * 100).toString(16).padStart(2, '0');
                                    ctx.globalAlpha = trailAlpha * 0.6;
                                    ctx.lineWidth = isSlashing ? 8 : 4;
                                    ctx.beginPath();
                                    ctx.moveTo(p.x + trailLaser.offset, p.y - 12);
                                    ctx.lineTo(trailEndX, trailEndY);
                                    ctx.stroke();
                                });
                            }
                        }
                    }

                    // Draw two main wiper lasers
                    const lasers = [
                        { angle: p.wiperLaser1Angle, offset: -8 },
                        { angle: p.wiperLaser2Angle, offset: 8 }
                    ];

                    lasers.forEach(laser => {
                        const endX = p.x + Math.cos(laser.angle) * laserLength;
                        const endY = p.y + Math.sin(laser.angle) * laserLength;

                        // Enhanced visuals during blink slash
                        const coreWidth = isSlashing ? 3 : 2;
                        const mainWidth = isSlashing ? 7 : 5;
                        const glowWidth = isSlashing ? 14 : 10;

                        // Draw lightsaber core (bright white center)
                        ctx.strokeStyle = isSlashing ? '#ffffee' : '#ffffff';
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 1.0 : 0.9);
                        ctx.lineWidth = coreWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw main laser beam (colored)
                        const mainColor = isSlashing ? laserColor + 'ee' : laserColor;
                        ctx.strokeStyle = mainColor;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.9 : 0.8);
                        ctx.lineWidth = mainWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw inner glow
                        const gradient = ctx.createLinearGradient(p.x + laser.offset, p.y - 12, endX, endY);
                        const glowIntensity = isSlashing ? '90' : '80';
                        gradient.addColorStop(0, laserColor + glowIntensity);
                        gradient.addColorStop(0.5, laserColor + (isSlashing ? '70' : '60'));
                        gradient.addColorStop(1, laserColor + (isSlashing ? '40' : '30'));

                        ctx.strokeStyle = gradient;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.7 : 0.6);
                        ctx.lineWidth = glowWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Add outer glow effect
                        const outerGlow = isSlashing ? laserColor + '60' : laserColor + '40';
                        const outerWidth = isSlashing ? 20 : 16;
                        ctx.strokeStyle = outerGlow;
                        ctx.globalAlpha = isSlashing ? 0.5 : 0.4;
                        ctx.lineWidth = outerWidth;
                        ctx.beginPath();
                        ctx.moveTo(p.x + laser.offset, p.y - 12);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Add sweeping motion trail (skip during slash mode - we have blur trail instead)
                        if (!isSlashing) {
                            const trailAngle = laser.angle - (p.wiperLaserSpeed * 0.3);
                            const trailEndX = p.x + Math.cos(trailAngle) * laserLength * 0.8;
                            const trailEndY = p.y + Math.sin(trailAngle) * laserLength * 0.8;

                            ctx.strokeStyle = laserColor + '20';
                            ctx.globalAlpha = 0.2;
                            ctx.lineWidth = 8;
                            ctx.beginPath();
                            ctx.moveTo(p.x + laser.offset, p.y - 12);
                            ctx.lineTo(trailEndX, trailEndY);
                            ctx.stroke();
                        }

                        // Add polished circular cap at the end of the laser
                        const capRadius = isSlashing ? 10 : 8;

                        // Bright glowing core of the cap
                        ctx.fillStyle = isSlashing ? '#ffffee' : '#ffffff';
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 1.0 : 0.9);
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Main colored cap
                        ctx.fillStyle = isSlashing ? laserColor + 'ee' : laserColor;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.9 : 0.8);
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius * 0.7, 0, Math.PI * 2);
                        ctx.fill();

                        // Outer glow cap
                        const capGradient = ctx.createRadialGradient(endX, endY, 0, endX, endY, capRadius);
                        const capGlowIntensity = isSlashing ? '90' : '80';
                        capGradient.addColorStop(0, laserColor + capGlowIntensity);
                        capGradient.addColorStop(0.5, laserColor + (isSlashing ? '70' : '60'));
                        capGradient.addColorStop(1, laserColor + (isSlashing ? '30' : '20'));

                        ctx.fillStyle = capGradient;
                        ctx.globalAlpha = pulseAlpha * (isSlashing ? 0.7 : 0.6);
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Pulsing rim effect
                        const rimIntensity = isSlashing ? '60' : '40';
                        ctx.strokeStyle = laserColor + rimIntensity;
                        const rimPulse = isSlashing ? 0.5 + 0.4 * Math.sin(time * 20) : 0.4 + 0.3 * Math.sin(time * 15);
                        ctx.globalAlpha = rimPulse;
                        ctx.lineWidth = isSlashing ? 3 : 2;
                        ctx.beginPath();
                        ctx.arc(endX, endY, capRadius * (isSlashing ? 1.3 : 1.2), 0, Math.PI * 2);
                        ctx.stroke();
                    });

                    ctx.restore();
                }


                closeBullets.forEach(item => {
                    const b = item.bullet;
                    const dist = item.dist;

                    // Apply fade-in for Death Engine bullet rain
                    let fadeAlpha = 1.0;
                    if (b.fadeInTime && b.spawnTime) {
                        const timeAlive = (performance.now() - b.spawnTime) / 1000;
                        fadeAlpha = Math.min(1.0, timeAlive / b.fadeInTime);
                    }

                    const proxFactor = 1.0 - (dist / proximityThreshold);

                    const isGeminiIce = b.geminiTag === 'ice_shard';
                    const isGeminiSolar = b.geminiTag === 'sol_fire' || b.geminiTag === 'solar_wave';

                    if (isGeminiIce || isGeminiSolar) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = (proxFactor * 0.8 + 0.2) * fadeAlpha;
                        const glowRadius = (b.r || 7) * (isGeminiIce ? 3 : 3.2);
                        const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
                        if (isGeminiIce) {
                            gradient.addColorStop(0, 'rgba(200, 255, 255, 0.9)');
                            gradient.addColorStop(0.6, 'rgba(110, 210, 255, 0.5)');
                            gradient.addColorStop(1, 'rgba(80, 150, 255, 0)');
                        } else {
                            gradient.addColorStop(0, 'rgba(255, 255, 210, 0.95)');
                            gradient.addColorStop(0.5, isGeminiSolar && b.geminiTag === 'solar_wave' ? 'rgba(255, 160, 70, 0.65)' : 'rgba(255, 190, 90, 0.7)');
                            gradient.addColorStop(1, 'rgba(255, 120, 40, 0)');
                        }
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        ctx.save();
                        ctx.globalAlpha = fadeAlpha;
                        ctx.translate(b.x, b.y);
                        if (isGeminiIce) {
                            ctx.rotate(Math.atan2(b.vy || 0, b.vx || 1) + Math.PI / 2);
                            const baseRadius = Math.max(4, (b.r || 7) * 1);
                            const shardLength = baseRadius * 3.6;
                            ctx.fillStyle = 'rgba(210, 255, 255, 0.9)';
                            ctx.beginPath();
                            ctx.moveTo(0, -shardLength);
                            ctx.lineTo(baseRadius, shardLength * 0.28);
                            ctx.lineTo(0, shardLength * 0.52);
                            ctx.lineTo(-baseRadius, shardLength * 0.28);
                            ctx.closePath();
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(120, 220, 255, 0.8)';
                            ctx.lineWidth = 1.2;
                            ctx.stroke();
                        } else {
                            const radius = (b.r || 8) * 1.6;
                            const coreGradient = ctx.createRadialGradient(0, 0, radius * 0.2, 0, 0, radius);
                            coreGradient.addColorStop(0, 'rgba(255, 255, 230, 1)');
                            coreGradient.addColorStop(0.45, b.geminiTag === 'solar_wave' ? 'rgba(255, 180, 90, 0.9)' : 'rgba(255, 200, 120, 0.95)');
                            coreGradient.addColorStop(1, 'rgba(255, 130, 40, 0.05)');
                            ctx.fillStyle = coreGradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    } else {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = proxFactor * fadeAlpha;
                        const glowRadius = b.r * 2;
                        const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
                        gradient.addColorStop(0.3, b.col);
                        gradient.addColorStop(1, b.col + '00');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        ctx.save();
                        ctx.globalAlpha = fadeAlpha;
                        ctx.fillStyle = b.col;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = `rgba(255, 255, 255, ${proxFactor * 0.8 * fadeAlpha})`;
                        ctx.beginPath();
                        ctx.arc(b.x, b.y, b.r * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                });

                store.activeEffects.forEach(e => e.draw && e.draw());
                renderVoidStepSystems(ctx);
                renderImpactSystem(ctx);

                // Draw element toggle orb
                drawBulletElementToggle();

                // Throttle HUD updates to avoid layout thrashing on every frame
                if (!window.lastHudUpdate || Date.now() - window.lastHudUpdate > 16) { // ~60fps
                    updateHUD();
                    window.lastHudUpdate = Date.now();
                }
            }

            function drawBulletElementToggle() {
                const p = store.player;
                if (!p) {
                    store.bulletToggleOrbs = null;
                    return;
                }
                if (!p.hasIceBullets && !p.hasPoisonBullets && !p.hasFireBullets) {
                    store.bulletToggleOrbs = null;
                    return;
                }

                ensureBulletElementState(p);
                const toggles = p.bulletElementToggles;

                const orbRadius = 17;
                const spacing = 46;
                const baseX = 70;
                const orbY = H - 58;

                const entries = [
                    {
                        element: 'ice',
                        unlocked: p.hasIceBullets,
                        colorOn: 'rgba(110, 190, 255, 0.92)',
                        colorOff: 'rgba(160, 190, 220, 0.45)',
                        glowOn: 'rgba(100, 210, 255, 0.5)',
                        glowOff: 'rgba(200, 210, 230, 0.24)',
                        label: 'â„ï¸'
                    },
                    {
                        element: 'poison',
                        unlocked: p.hasPoisonBullets,
                        colorOn: 'rgba(120, 255, 140, 0.92)',
                        colorOff: 'rgba(170, 210, 170, 0.45)',
                        glowOn: 'rgba(140, 255, 170, 0.5)',
                        glowOff: 'rgba(210, 230, 210, 0.24)',
                        label: 'â˜ ï¸'
                    },
                    {
                        element: 'fire',
                        unlocked: p.hasFireBullets,
                        colorOn: 'rgba(255, 150, 90, 0.92)',
                        colorOff: 'rgba(215, 170, 150, 0.45)',
                        glowOn: 'rgba(255, 160, 120, 0.5)',
                        glowOff: 'rgba(220, 200, 190, 0.24)',
                        label: 'ðŸ”¥'
                    }
                ];

                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const orbsForHover = [];
                let unlockedCount = 0;

                entries.forEach((entry, idx) => {
                    const x = baseX + idx * spacing;
                    const unlocked = entry.unlocked;
                    const active = unlocked && !!toggles[entry.element];
                    const glowColor = active ? entry.glowOn : entry.glowOff;
                    const fillColor = active ? entry.colorOn : entry.colorOff;

                    if (unlocked) unlockedCount++;

                    // Glow halo
                    ctx.fillStyle = glowColor;
                    ctx.beginPath();
                    ctx.arc(x, orbY, orbRadius + 7, 0, Math.PI * 2);
                    ctx.fill();

                    // Orb body
                    const gradient = ctx.createRadialGradient(x - 4, orbY - 5, 0, x, orbY, orbRadius);
                    gradient.addColorStop(0, active ? 'rgba(255, 255, 255, 0.75)' : 'rgba(240, 240, 240, 0.5)');
                    gradient.addColorStop(1, fillColor);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, orbY, orbRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Outline
                    ctx.strokeStyle = active ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.35)';
                    ctx.lineWidth = active ? 2.4 : 1.6;
                    ctx.beginPath();
                    ctx.arc(x, orbY, orbRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Label/icon
                    ctx.font = unlocked ? 'bold 15px Arial' : 'bold 13px Arial';
                    ctx.fillStyle = unlocked ? 'rgba(255, 255, 255, 0.92)' : 'rgba(210, 210, 210, 0.75)';
                    const label = unlocked ? entry.label : 'ðŸ”’';
                    ctx.fillText(label, x, orbY);

                    if (!unlocked) {
                        ctx.font = 'bold 8px Arial';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.fillText('LOCKED', x, orbY + orbRadius + 8);
                    }

                    orbsForHover.push({ element: entry.element, x, y: orbY, radius: orbRadius, active: unlocked });
                });

                ctx.font = 'bold 9px Arial';
                ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                const tipY = orbY + orbRadius + 16;
                if (unlockedCount > 0) {
                    const tip = 'Hover each orb to toggle your elemental mix';
                    ctx.fillText(tip, baseX + spacing, tipY);
                }
                if (!toggles.ice && !toggles.poison && !toggles.fire) {
                    ctx.fillStyle = 'rgba(220, 220, 220, 0.85)';
                    ctx.fillText('All off = default ballistics', baseX + spacing, tipY + 12);
                }

                ctx.restore();

                store.bulletToggleOrbs = orbsForHover;
            }


            function takeDamage(dmg) {
                if (store.player.isInvincible || playerIsInvulnerable()) return;
                // Removed boss invincibility check here - that was preventing ALL damage incorrectly

                if (store.player.hasShieldBubble && store.player.shieldBubbleCount > 0) {
                    store.player.shieldBubbleCount--;
                    if (store.player.shieldBubbleCount <= 0) {
                        store.player.hasShieldBubble = false;
                        store.player.shieldBubbleCount = 0;
                    }
                    store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
                    return;
                }
                const p = store.player;

                // Beef shield takes damage first if pilot is beef
                if (p.pilotGenome === 'beef' && p.beefShield > 0 && p.beefShieldCooldown <= 0) {
                    const beefAbsorbed = Math.min(p.beefShield, dmg);
                    p.beefShield -= beefAbsorbed;
                    dmg -= beefAbsorbed;
                    p.beefShieldDamageTaken += beefAbsorbed;

                    // Reset shield recharge delay when beef shield takes damage
                    if (beefAbsorbed > 0) {
                        p.shieldRechargeDelay = p.shieldRechargeDelayMax;
                        p.shieldRecharging = false;
                    }

                    // If beef shield was depleted, start cooldown
                    if (p.beefShield <= 0) {
                        p.beefShieldCooldown = 2.0; // 2 second cooldown before shield can absorb again
                    }

                    if (dmg <= 0) return; // All damage absorbed by beef shield
                }

                const a = Math.min(p.shield, dmg);
                if (a < dmg) playSound('hit');
                p.shield -= a;
                dmg -= a;

                // Reset shield recharge delay whenever any damage is taken
                if (a > 0 || dmg > 0) {
                    p.shieldRechargeDelay = p.shieldRechargeDelayMax;
                    p.shieldRecharging = false;
                }

                // Old nano save logic removed - now handled in main game loop before death
                p.hp -= dmg;

                if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
                    store.world.lowHealthTutorialShown = true;
                    showShopWithHighlight();
                }
            }

            function resolveEnemyDeath(enemy, options = {}) {
                if (!enemy || enemy.deathProcessed) return;
                const {
                    allowRewards = true,
                    impactTime = performance.now(),
                    cause = 'projectile',
                    fallbackElement = null
                } = options;

                const deathType = getStackDeathType(enemy, {
                    fallbackElement: fallbackElement || enemy.lastStackHitElement || null
                });

                enemy.dead = true;
                enemy.hp = 0;
                enemy.deathProcessed = true;
                enemy.deathElement = deathType;
                if (cause === 'collision') {
                    enemy.killedByCollision = true;
                }

                if (enemy.type === 'void_champion') {
                    store.enemies.forEach(minion => {
                        if (!minion || minion.dead || minion.orbitTargetId !== enemy.id) return;
                        spawnGibs(minion.x, minion.y, minion.color);
                        minion.dead = true;
                    });
                    if (allowRewards) {
                        handleVoidChampionReward(enemy);
                    }
                }

                if (enemy.type === 'shadow_champion') {
                    store.shadowChampionDefeated = true;
                    store.shadowChampionLastPos = { x: enemy.x, y: enemy.y };
                    store.shadowChampionId = null;
                    if (!store.shadowChampionTokenDropped) {
                        addShadowEcho(enemy.x, enemy.y);
                        if (allowRewards) {
                            announce('Champion sigil destabilized!');
                        }
                    }
                }

                const isVoidReaper = enemy.type === 'void_reaper';
                if (isVoidReaper) {
                    finalizeVoidReaperDefeat(enemy, {
                        preemptive: !enemy.lungeStarted,
                        suppressRewards: !allowRewards
                    });
                } else {
                    if (deathType === 'ice') {
                        spawnIceShards(enemy.x, enemy.y, {
                            enemyRadius: enemy.r || 18
                        });
                    } else if (deathType === 'fire') {
                        spawnFireWipeDeath(enemy.x, enemy.y, {
                            enemyRadius: enemy.r || 18,
                            baseColor: enemy.color
                        });
                    } else {
                        spawnGibs(enemy.x, enemy.y, enemy.color);
                    }
                }

                if (allowRewards) {
                    const collarBonus = calculateCollarBonus(sanitizeCollarStacks());
                    const scoreGain = Math.floor((Number.isFinite(enemy.score) ? enemy.score : 0) * collarBonus);
                    const goldGain = Math.floor((Number.isFinite(enemy.gold) ? enemy.gold : 0) * collarBonus);
                    const xpGain = Math.floor((Number.isFinite(enemy.xp) ? enemy.xp : 0) * collarBonus);
                    if (scoreGain) store.world.score += scoreGain;
                    if (goldGain) addWorldGold(goldGain);
                    if (xpGain) awardXp(xpGain);
                    store.world.kills++;
                    if (enemy.type !== 'shadow_champion') {
                        spawnPowerup(enemy.x, enemy.y);
                    }
                }

                explode(enemy.x, enemy.y);

                applyRapidEnemyAdaptation(enemy, impactTime);
            }

            function resolvePlayerEnemyCollision(enemy, options = {}) {
                if (!enemy || enemy.dead || store.isDamageOff) return false;
                const player = store.player;
                if (!player) return false;

                const enemyCooldown = Math.max(ensureFiniteNumber(options.enemyCooldown, 0.45), 0.05);
                const playerCooldown = Math.max(ensureFiniteNumber(options.playerCooldown, 0.25), 0.05);
                const skipEnemyDeathResolution = options.skipEnemyDeathResolution === true;

                if (player.collisionDamageCooldown && player.collisionDamageCooldown > 0) {
                    return false;
                }
                if (enemy.collisionDamageCooldown && enemy.collisionDamageCooldown > 0) {
                    return false;
                }

                player.collisionDamageCooldown = playerCooldown;
                enemy.collisionDamageCooldown = enemyCooldown;
                if (enemy.contactCooldown !== undefined) {
                    enemy.contactCooldown = Math.max(enemy.contactCooldown || 0, enemyCooldown);
                }

                const now = performance.now ? performance.now() : Date.now();

                const playerHp = Math.max(0, Number.isFinite(player.hp) ? player.hp : 0);
                const enemyHp = Math.max(0, Number.isFinite(enemy.hp) ? enemy.hp : 0);
                const playerDamage = playerHp > 0 ? Math.max(playerHp * 0.25, Math.min(1, playerHp)) : 0;
                const enemyDamage = enemyHp > 0 ? Math.max(enemyHp * 0.25, Math.min(1, enemyHp)) : 0;
                const playerInvulnerable = player.isInvincible || (typeof playerIsInvulnerable === 'function' && playerIsInvulnerable());
                const enemyInvulnerable = enemy.isInvulnerable;

                if (!playerInvulnerable && playerDamage > 0) {
                    if (player.hasShieldBubble && player.shieldBubbleCount > 0) {
                        // Shield bubble blocks all damage
                        player.shieldBubbleCount--;
                        if (player.shieldBubbleCount <= 0) {
                            player.hasShieldBubble = false;
                            player.shieldBubbleCount = 0;
                        }
                        store.activeEffects.push(createEffect('shieldBreak', player.x, player.y));
                    } else {
                        // No shield, apply damage normally
                        player.hp = Math.max(0, playerHp - playerDamage);
                        if (player.beefShieldDamageTaken !== undefined) {
                            player.beefShieldDamageTaken += playerDamage;
                        }
                        if (player.shieldRechargeDelayMax !== undefined) {
                            player.shieldRechargeDelay = player.shieldRechargeDelayMax;
                            player.shieldRecharging = false;
                        }
                        const hpMax = Number.isFinite(player.hpMax) ? player.hpMax : 0;
                        if (hpMax > 0 && player.hp < hpMax / 2 && store.world && !store.world.lowHealthTutorialShown) {
                            store.world.lowHealthTutorialShown = true;
                            showShopWithHighlight();
                        }
                    }
                }

                if (!enemyInvulnerable && enemyDamage > 0) {
                    enemy.hp = Math.max(0, enemyHp - enemyDamage);
                }

                if (Number.isFinite(player.x) && Number.isFinite(player.y) && Number.isFinite(enemy.x) && Number.isFinite(enemy.y)) {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const dist = Math.max(1, Math.hypot(dx, dy));
                    const separation = ensureFiniteNumber(options.separationForce, 18);
                    if (separation > 0) {
                        const push = separation / dist;
                        enemy.x += dx * push * 0.35;
                        enemy.y += dy * push * 0.35;
                        player.x -= dx * push * 0.2;
                        player.y -= dy * push * 0.2;
                    }
                }

                if (!skipEnemyDeathResolution && !enemyInvulnerable && enemy.hp <= 0) {
                    resolveEnemyDeath(enemy, {
                        allowRewards: false,
                        cause: 'collision',
                        impactTime: now
                    });
                } else if (enemy.type === 'shadow_champion') {
                    enemy.stunTimer = Math.max(enemy.stunTimer || 0, 0.35);
                    enemy.state = null;
                    enemy.dashTimer = 0;
                    enemy.dashVX = 0;
                    enemy.dashVY = 0;
                    enemy.fireT = Math.max(enemy.fireT || 0, 0.8);
                }

                return true;
            }

            function recomputeBeefShieldCapacity(player, options = {}) {
                if (!player || player.pilotGenome !== 'beef') return;
                const tierValue = Number.isFinite(player.beefShieldTier) ? player.beefShieldTier : 1;
                const tier = Math.min(3, Math.max(1, tierValue));
                const config = BEEF_SHIELD_TIERS[tier] || BEEF_SHIELD_TIERS[1];
                const hpMax = Math.max(0, Number.isFinite(player.hpMax) ? player.hpMax : 0);
                const wave = store.world && Number.isFinite(store.world.wave) ? Math.max(1, store.world.wave) : 1;
                const ratioValue = (config.ratio || 0) * hpMax;
                const waveBonus = (config.waveBonus || 0) * (wave - 1);
                const computedMax = Math.max(config.min || 0, Math.round(ratioValue + waveBonus));
                const safeMax = Math.max(0, computedMax);
                const prevMax = Number.isFinite(player.beefShieldMax) ? player.beefShieldMax : 0;
                const prevValue = Number.isFinite(player.beefShield) ? player.beefShield : 0;

                player.beefShieldMax = safeMax;
                if (options.refill || prevMax <= 0) {
                    player.beefShield = safeMax;
                } else {
                    const preservedRatio = prevMax > 0 ? prevValue / prevMax : 0;
                    const nextValue = Math.round(safeMax * preservedRatio);
                    player.beefShield = Math.max(0, Math.min(safeMax, nextValue));
                }

                player.beefShieldLastHpMax = hpMax;
                player.beefShieldLastWave = wave;
                player.beefShieldLastTier = tier;

                if (config.regenRate !== undefined) player.beefShieldRegenRate = config.regenRate;
                if (config.regenDelay !== undefined) player.beefShieldRegenDelay = config.regenDelay;
                if (config.reflect) player.beefShieldReflect = true;
            }

            function resetBeefShieldState(player) {
                if (!player) return;
                if (player.beefShield || player.beefShieldMax || player.beefShieldDamageDealt || player.beefShieldDamageTaken || player.beefShieldCooldown) {
                    player.beefShield = 0;
                    player.beefShieldMax = 0;
                    player.beefShieldDamageDealt = 0;
                    player.beefShieldDamageTaken = 0;
                    player.beefShieldCooldown = 0;
                    player.beefShieldTier = 0;
                    player.beefShieldLastHpMax = 0;
                    player.beefShieldLastWave = 0;
                    player.beefShieldLastTier = 0;
                    player.hasBeefShield = false;
                }
            }

            function updateBeefShield() {
                const p = store.player;
                if (!p) return;

                if (p.pilotGenome !== 'beef') {
                    resetBeefShieldState(p);
                    return;
                }

                if (!Number.isFinite(p.beefShield) || p.beefShield < 0) p.beefShield = Math.max(0, Number.isFinite(p.beefShield) ? p.beefShield : 0);
                if (!Number.isFinite(p.beefShieldMax) || p.beefShieldMax < 0) p.beefShieldMax = Math.max(0, Number.isFinite(p.beefShieldMax) ? p.beefShieldMax : 0);
                if (p.beefShieldMax > 0 && p.beefShield > p.beefShieldMax) p.beefShield = p.beefShieldMax;

                const currentTier = Number.isFinite(p.beefShieldTier) ? p.beefShieldTier : 0;
                const wave = store.world && Number.isFinite(store.world.wave) ? Math.max(1, store.world.wave) : 1;
                if (currentTier > 0) {
                    const tier = Math.min(3, Math.max(1, currentTier));
                    const needsRefresh = !Number.isFinite(p.beefShieldMax) || p.beefShieldMax <= 0 || p.beefShieldLastHpMax !== p.hpMax || p.beefShieldLastWave !== wave || p.beefShieldLastTier !== tier;
                    if (needsRefresh) {
                        recomputeBeefShieldCapacity(p, { refill: !Number.isFinite(p.beefShield) || p.beefShield <= 0 });
                    }
                }

                if (!Number.isFinite(p.beefShieldDamageDealt)) p.beefShieldDamageDealt = 0;
                if (!Number.isFinite(p.beefShieldDamageTaken)) p.beefShieldDamageTaken = 0;
                const damageDealt = p.beefShieldDamageDealt;
                const damageTaken = p.beefShieldDamageTaken;

                // Skip if no damage events
                if (damageDealt === 0 && damageTaken === 0) return;

                // Update cooldown
                if (p.beefShieldCooldown > 0) {
                    p.beefShieldCooldown -= 0.016; // Decrease by ~1/60 (assuming 60 FPS)
                    if (p.beefShieldCooldown < 0) p.beefShieldCooldown = 0;
                }

                // Growth rate: 1 shield per 50 damage dealt, shrinkage rate: 1 shield per 30 damage taken
                // Made more responsive for better gameplay feel
                const shieldChange = (damageDealt * 0.02) - (damageTaken * 0.033);

                if (shieldChange > 0) {
                    // Shield grows
                    p.beefShield = Math.min(p.beefShieldMax, p.beefShield + shieldChange);
                } else if (shieldChange < 0) {
                    // Shield shrinks (but not below 0)
                    p.beefShield = Math.max(0, p.beefShield + shieldChange);
                }

                // Reset damage tracking counters
                p.beefShieldDamageDealt = 0;
                p.beefShieldDamageTaken = 0;


            }

            function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
            function announce(text) {
                if (typeof text !== 'string' || !/sector/i.test(text)) {
                    return;
                }
                const el = q('announce');
                if (!el) return;
                el.textContent = text;
                el.classList.remove('hide');
                clearTimeout(el._t);
                el._t = setTimeout(() => el.classList.add('hide'), 2500);
            }
            
            // Floating text system for powerup pickups
            function addFloatingText(x, y, text, options = {}) {
                if (!store.floatingTexts) store.floatingTexts = [];
                store.floatingTexts.push({
                    x, y,
                    text,
                    vx: (Math.random() - 0.5) * 20,
                    vy: options.vy || -80,
                    life: options.life || 1.5,
                    maxLife: options.life || 1.5,
                    color: options.color || '#FFD700',
                    fontSize: options.fontSize || 16,
                    fadeDelay: options.fadeDelay || 0.3
                });
            }

            function updateFloatingTexts(dt) {
                if (!store.floatingTexts) return;
                for (let i = store.floatingTexts.length - 1; i >= 0; i--) {
                    const ft = store.floatingTexts[i];
                    ft.x += ft.vx * dt;
                    ft.y += ft.vy * dt;
                    ft.vy += 60 * dt; // Slight gravity
                    ft.life -= dt;
                    if (ft.life <= 0) {
                        store.floatingTexts.splice(i, 1);
                    }
                }
            }

            function drawFloatingTexts(ctx) {
                if (!store.floatingTexts) return;
                store.floatingTexts.forEach(ft => {
                    const fadeTime = ft.maxLife - ft.fadeDelay;
                    const alpha = ft.life < fadeTime ? ft.life / fadeTime : 1;
                    ctx.save();
                    ctx.font = `bold ${ft.fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = ft.color;
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeText(ft.text, ft.x, ft.y);
                    ctx.fillText(ft.text, ft.x, ft.y);
                    ctx.restore();
                });
            }

            function updateHUD() {
                const player = store.player;
                if (!player) return;

                const pilotTitle = q("pilotTitle");
                const scoreNum = q("scoreNum");
                const goldNum = q("goldNum");
                const hpBarFill = q("hpBarFill");
                const hpText = q("hpText");
                const beefShieldBar = q("beefShieldBar");
                const beefShieldBarFill = q("beefShieldBarFill");
                const beefShieldText = q("beefShieldText");
                const shieldBar = q("shieldBar");
                const shieldBarFill = q("shieldBarFill");
                const shieldTextEl = q("shieldText");
                const xpBarFill = q("xpBarFill");
                const xpText = q("xpText");
                const waveNum = q("waveNum");
                const killsNum = q("killsNum");
                const levelNum = q("levelNum");
                const bossContent = q("hudBossContent");
                const bossTitle = q("bossTitle");
                const bossBarFill = q("bossBarFill");
                const powerupEl = q("hudPowerup");
                const powerupList = q("powerupList");
                const equipEl = q("hudEquipment");
                const equipmentList = q("equipmentList");
                const grenadeBtn = q('grenadeBtnUI');
                const fpsEl = q('fps');

                if (!pilotTitle || !scoreNum || !goldNum || !hpBarFill || !hpText || !shieldBar || !shieldBarFill || !shieldTextEl) {
                    return;
                }

                const hpMaxSafe = Math.max(1, Number.isFinite(player.hpMax) ? player.hpMax : 1);
                const hpValueSafe = Number.isFinite(player.hp) ? player.hp : 0;
                const shieldMaxSafe = Number.isFinite(player.shieldMax) && player.shieldMax > 0 ? player.shieldMax : 0;
                const shieldValueSafe = Number.isFinite(player.shield) ? Math.max(0, player.shield) : 0;
                const beefShieldMaxSafe = Number.isFinite(player.beefShieldMax) && player.beefShieldMax > 0 ? player.beefShieldMax : 0;
                const beefShieldValueSafe = Number.isFinite(player.beefShield) ? Math.max(0, player.beefShield) : 0;

                const hpPercent = Math.round((hpValueSafe / hpMaxSafe) * 100);
                const shieldPercent = shieldMaxSafe > 0 ? Math.round((shieldValueSafe / shieldMaxSafe) * 100) : 0;
                const beefShieldPercent = player.pilotGenome === 'beef' && beefShieldMaxSafe > 0 ? Math.round((beefShieldValueSafe / beefShieldMaxSafe) * 100) : 0;

                pilotTitle.textContent = store.name ? `â—¢ ${store.name} â—£` : "â—¢ UNIDENTIFIED â—£";
                scoreNum.textContent = store.world.score;
                const worldGold = getWorldGold();
                goldNum.textContent = worldGold;
                const mechForgeBtn = q('shopBtn');
                if (mechForgeBtn) {
                    const label = store.world.autoForgeEnabled ? 'UPGRADE HANGAR (AUTO)' : 'UPGRADE HANGAR';
                    if (mechForgeBtn.textContent !== label) {
                        mechForgeBtn.textContent = label;
                    }
                }
                const nextForgePrompt = store.world.nextMechForgePrompt ?? 135;
                if (worldGold >= nextForgePrompt && !store.world.mechForgePromptActive) {
                    triggerMechForgeGoldMilestone();
                }

                hpBarFill.style.width = `${hpPercent}%`;
                hpText.textContent = `HP: ${Math.round(hpValueSafe)} / ${hpMaxSafe}`;

                if (beefShieldBar && beefShieldText && beefShieldBarFill) {
                    if (player.pilotGenome === 'beef' && beefShieldMaxSafe > 0) {
                        beefShieldBar.style.display = "block";
                        beefShieldBarFill.style.width = `${beefShieldPercent}%`;
                        beefShieldText.textContent = `BEEF SHIELD: ${Math.round(beefShieldValueSafe)} / ${Math.round(beefShieldMaxSafe)}`;
                    } else {
                        beefShieldBar.style.display = "none";
                        beefShieldText.textContent = "";
                    }
                }

                shieldBar.style.display = "block";
                shieldBarFill.style.width = `${shieldPercent}%`;
                shieldTextEl.textContent = shieldMaxSafe > 0
                    ? `SHIELD: ${Math.round(shieldValueSafe)} / ${shieldMaxSafe}`
                    : 'SHIELD: 0 / 0';

                if (xpBarFill && xpText && store.world) {
                    const level = Number.isFinite(store.world.level) ? Math.max(1, store.world.level) : 1;
                    const xpMultiplier = Number.isFinite(store.world.xpMultiplier) ? Math.max(0.01, store.world.xpMultiplier) : 1;
                    const wave = Number.isFinite(store.world.wave) ? Math.max(1, store.world.wave) : 1;
                    const xpCurrent = Number.isFinite(store.world.xp) ? Math.max(0, store.world.xp) : 0;
                    const levelFactor = level >= 8 ? 1.3 : level >= 4 ? 1.1 : 1;
                    const waveFactor = wave > 10 ? 1.3 : 1;
                    const xpNeededRaw = level * 100 * xpMultiplier * levelFactor * waveFactor;
                    const xpNeeded = Math.max(1, Math.floor(xpNeededRaw));
                    const xpPercent = Math.max(0, Math.min(100, Math.round((xpCurrent / xpNeeded) * 100)));
                    xpBarFill.style.width = `${xpPercent}%`;
                    xpText.textContent = `XP: ${Math.floor(xpCurrent)} / ${xpNeeded}`;
                }

                if (waveNum) waveNum.textContent = store.world.wave;
                if (killsNum) killsNum.textContent = store.world.kills;
                if (levelNum) levelNum.textContent = store.world.level;

                if (bossContent && bossTitle && bossBarFill) {
                    if (store.boss) {
                        bossContent.classList.remove("hide");
                        bossTitle.textContent = `âš¡ ${store.boss.name} âš¡`;
                        bossBarFill.style.width = `${Math.round((store.boss.hp / store.boss.hpMax) * 100)}%`;
                    } else {
                        bossContent.classList.add("hide");
                    }
                }

                if (powerupEl && powerupList) {
                    const timedPowerups = Object.keys(player.powerupTimers || {});
                    if (timedPowerups.length > 0) {
                        let timedContent = '';
                        timedPowerups.forEach(key => {
                            const timer = player.powerupTimers[key];
                            if (!timer || !POWERUP_TYPES[key]) return;
                            const percent = Math.round((timer.remaining / timer.max) * 100);
                            timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`;
                        });
                        powerupList.innerHTML = timedContent;
                        powerupEl.classList.remove('hide');
                    } else {
                        powerupEl.classList.add('hide');
                    }
                }

                if (equipEl && equipmentList) {
                    const hasEquipment = player.hasLauncher || player.hasHounds || player.nanoSaves > 0;
                    if (hasEquipment) {
                        let content = '';
                        if (player.nanoSaves > 0) content += `<div>NANO SAVE [${player.nanoSaves}]</div>`;
                        if (player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`;
                        if (player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`;
                        equipmentList.innerHTML = content;
                        equipEl.classList.remove('hide');
                    } else {
                        equipEl.classList.add('hide');
                    }
                }

                // EMP charges now orbit automatically, no button needed
                if (grenadeBtn) {
                    grenadeBtn.classList.add('hide');
                }

                if (!store.fpsLastTime) {
                    store.fpsLastTime = performance.now();
                    store.fpsFrameCount = 0;
                }
                store.fpsFrameCount++;
                const now = performance.now();
                if (fpsEl && now - store.fpsLastTime >= 1000) {
                    const fps = Math.round((store.fpsFrameCount * 1000) / (now - store.fpsLastTime));
                    fpsEl.textContent = fps;

                    // COMMENTED OUT: Enhanced collar display with better feedback
                    /*
                    const collarStacks = sanitizeCollarStacks();
                    const collarBonus = calculateCollarBonus(collarStacks);
                    const collarPercent = (collarBonus - 1) * 100;
                    const collarStatus = collarStacks === 0 ? 'LOOSE' : 
                                        collarStacks < 25 ? 'CRUSHING' : 'MAXIMUM';
                    q('collar').textContent = `${collarStacks.toFixed(1)} (${collarPercent.toFixed(0)}%) ${collarStatus}`;
                    */

                    // COMMENTED OUT: Calculate damage per bullet and average enemy HP
                    /*
                    const baseDamage = 15; // Updated from 20 to 15 (75% of original)
                    const actualDamage = baseDamage * store.player.dmgMult;
                    q('damagePerBullet').textContent = `${actualDamage.toFixed(1)}`;
                    
                    // Calculate average enemy HP across all enemy types
                    const enemyTypes = [
                    ];
                    const avgBaseHp = enemyTypes.reduce((sum, type) => sum + type.hp, 0) / enemyTypes.length;
                    const waveMultiplier = Math.pow(1.03, store.world.wave - 1);
                    const avgCurrentHp = avgBaseHp * waveMultiplier * collarBonus;
                    q('avgEnemyHp').textContent = `${avgCurrentHp.toFixed(0)}`;
                    */

                    const spawnDebugEl = q('spawnDebug');
                    if (spawnDebugEl) {
                        // Spawn debug info can stay if needed for development
                    }

                    store.fpsFrameCount = 0;
                    store.fpsLastTime = now;

                    // COMMENTED OUT: Update health table
                    /*
                    if (store.enemies.length > 0) {
                        const enemy = store.enemies[0]; // Get first enemy for reference
                        q('enemyCurrentHp').textContent = Math.round(enemy.hp);
                    } else {
                        q('enemyCurrentHp').textContent = '0';
                    }
                    if (store.boss) {
                        q('bossCurrentHp').textContent = Math.round(store.boss.hp);
                        q('bossBaseHp').textContent = Math.round(store.boss.hpMax);
                    } else {
                        q('bossCurrentHp').textContent = '0';
                        q('bossBaseHp').textContent = '0';
                    }
                    */
                }
            }
            function normalizeLeaderboardEntries(source) {
                if (!source) return null;

                if (Array.isArray(source)) {
                    return source;
                }

                if (Array.isArray(source.entries)) {
                    return source.entries;
                }

                if (Array.isArray(source.top50)) {
                    return source.top50;
                }

                if (Array.isArray(source.top10)) {
                    return source.top10;
                }

                if (source.top50 && Array.isArray(source.top50.entries)) {
                    return source.top50.entries;
                }

                if (source.top10 && Array.isArray(source.top10.entries)) {
                    return source.top10.entries;
                }

                if (Array.isArray(source.data)) {
                    return source.data;
                }

                if (source.data && Array.isArray(source.data.entries)) {
                    return source.data.entries;
                }

                return null;
            }

            function updateLeaderboard(leaderboardData) {
                const fallbackData = [
                    { name: "ACE PILOT", score: 50000, waves: 10 },
                    { name: "VOID RUNNER", score: 35000, waves: 8 },
                    { name: "STAR HUNTER", score: 25000, waves: 6 },
                    { name: "NOVA STRIKER", score: 18000, waves: 5 },
                    { name: "COSMIC GUARD", score: 12000, waves: 4 }
                ];

                const entries = normalizeLeaderboardEntries(leaderboardData) ?? fallbackData;

                const safeEntries = entries.filter(entry => entry && typeof entry === "object");

                const listHtml = safeEntries.map(s => `<li>${escapeHtml(s.name ?? "UNKNOWN PILOT")} â€” ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");
                const popupHtml = safeEntries.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name ?? "UNKNOWN PILOT")} â€” ${s.score ?? 0} (Wave ${s.waves ?? "?"})</li>`).join("");

                const hsList = q("hsList");
                const hsListPopup = q("hsListPopup");
                if (hsList) hsList.innerHTML = listHtml;
                if (hsListPopup) hsListPopup.innerHTML = popupHtml;
            }

            async function refreshScoreList() {
                try {
                    const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 });
                    if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    const data = await res.json();
                    // data.entries contains up to 50 players
                    updateLeaderboard(data);
                } catch (err) {
                    updateLeaderboard(null);
                }
            }
            async function addScore(score) {
                if (store.cheatsUsed) {
                    announce("Score not submitted: Cheats used");
                    return;
                }
                const name = (store.name || "ROGUE").slice(0, 16);
                try {
                    const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 });
                    if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`);
                    const { nonce } = await nonceRes.json();
                    const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce };
                    const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 });
                    if (!res.ok) throw new Error(`Submit failed: ${res.status}`);
                    const data = await res.json();
                    if (data.ok) {
                        updateLeaderboard(data);
                    } else {
                        announce(`Score rejected: ${data.err}`);
                        refreshScoreList();
                    }
                } catch (err) {
                    // Score submission error silenced
                }
            }
            function fireBullet(x, y, vx, vy, props = {}) {
                const p = store.player;
                // Beef/Marauder should NEVER have swirl shots - they use charge attacks, not circular bullets
                const isBeefPilot = p.pilotGenome === 'beef' || p.subclass === 'marauder' || p.subclass === 'juggernaut';
                const swirlFlag = isBeefPilot ? false : (props.isSwirl !== undefined ? props.isSwirl : !!p.swirlShots);
                return spawnBullet({
                    x, y, vx, vy,
                    r: p.explosive ? 5 : 3,
                    col: p.explosive ? "#ED2F32" : "#b266ff",
                    dmg: 15 * p.dmgMult,
                    pierce: p.piercing,
                    explosive: p.explosive,
                    ...props,
                    isSwirl: swirlFlag
                });
            }
            function fireIcemanShot() {
                const p = store.player;
                if (!p.hasIceman) {
                    return;
                }
                if (!store.iceman) {
                    return;
                }
                
                const icemanLevel = store.iceman.level || 1;
                const icemanDamageMult = icemanLevel >= 3 ? 1.5 : 1.0; // Level 3: +50% damage
                // Iceman damage scaling: 35% of player damage
                const icemanDamageCoefficient = 0.35;
                
                // STANDARD FIRING: Match player's multishot exactly
                const baseBulletSpeed = 420;
                const baseMultishot = Number.isFinite(p.multishot) ? p.multishot : 2;
                const cheatMultishot = Number.isFinite(p.cheatMultishotBonus) ? p.cheatMultishotBonus : 0;
                const totalMultishot = Math.max(1, baseMultishot + cheatMultishot);
                const angleSpread = 10; // Match player's angle spread
                
                // Fire regular bullets - matches player count exactly
                for (let i = 0; i < totalMultishot; i++) {
                    const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                    spawnBullet({
                        x: store.iceman.x + 10 * Math.sin(angle),
                        y: store.iceman.y - 12,
                        vx: Math.sin(angle) * baseBulletSpeed,
                        vy: -Math.cos(angle) * baseBulletSpeed,
                        r: p.explosive ? 5 : 3,
                        col: "#66aaff",
                        dmg: 15 * p.dmgMult * icemanDamageCoefficient * icemanDamageMult,
                        pierce: p.piercing || false,
                        explosive: p.explosive || false,
                        isIceman: true,
                        isSwirl: p.swirlShots || false
                    });
                }
                
            }
            function firePlayer() {
                const p = store.player;
                if (p.beefChargeState && p.beefChargeState !== 'ready') return;
                
                // STANDARD MULTISHOT FIRING
                const activeElements = getActiveBulletElements(p);
                const fireOnly = activeElements.length === 1 && activeElements[0] === 'fire';
                const baseBulletSpeed = 420;
                const bulletSpeed = baseBulletSpeed;
                const baseMultishot = Number.isFinite(p.multishot) ? p.multishot : 2;
                const cheatMultishot = Number.isFinite(p.cheatMultishotBonus) ? p.cheatMultishotBonus : 0;
                const totalMultishot = Math.max(1, baseMultishot + cheatMultishot);
                let angleSpread = 10;
                if (fireOnly) {
                    angleSpread = 6;
                }
                const bulletColor = fireOnly ? '#ff5533' : getBulletColorForSubclass();
                for (let i = 0; i < totalMultishot; i++) {
                    const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                    spawnBullet({
                        x: p.x + 10 * Math.sin(angle),
                        y: p.y - 12,
                        vx: Math.sin(angle) * bulletSpeed,
                        vy: -Math.cos(angle) * bulletSpeed,
                        r: p.explosive ? 5 : 3,
                        col: bulletColor,
                        dmg: 15 * p.dmgMult,
                        pierce: p.piercing,
                        explosive: p.explosive,
                        isSwirl: p.swirlShots
                    });
                }
                if (p.hasBeefClone && store.beefClone && store.beefClone.mode !== 'juggernaut_bomber') {
                    for (let i = 0; i < totalMultishot; i++) {
                        const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180;
                        spawnBullet({
                            x: store.beefClone.x + 10 * Math.sin(angle),
                            y: store.beefClone.y - 12,
                            vx: Math.sin(angle) * bulletSpeed,
                            vy: -Math.cos(angle) * bulletSpeed,
                            r: p.explosive ? 5 : 3,
                            col: "#66ff66", // Green color for beef clone
                            dmg: 15 * p.dmgMult * 0.35,
                            pierce: p.piercing,
                            explosive: p.explosive,
                            isBeefClone: true,
                            isSwirl: p.swirlShots
                        });
                    }
                }
                const rearMultishotCount = Math.max(0, Number.isFinite(p.rearMultishot) ? p.rearMultishot : 0);
                if (rearMultishotCount > 0) {
                    const rearAngleSpread = 15;
                    for (let i = 0; i < rearMultishotCount; i++) {
                        const angle = (i - (rearMultishotCount - 1) / 2) * rearAngleSpread;
                        const radAngle = angle * Math.PI / 180;
                        spawnBullet({
                            x: p.x + 10 * Math.sin(radAngle),
                            y: p.y + 12,
                            vx: Math.sin(radAngle) * bulletSpeed,
                            vy: Math.cos(radAngle) * bulletSpeed,
                            r: 3,
                            col: "#ffddff",
                            dmg: 11.25 * p.dmgMult,
                            pierce: p.piercing > 0 ? p.piercing - 1 : 0,
                            isSwirl: p.swirlShots
                        });
                    }
                }
                store.drones.forEach(drone => spawnBullet({
                    x: p.x + drone.offset,
                    y: p.y + 20,
                    vx: 0,
                    vy: -bulletSpeed,
                    r: 3,
                    col: "#66aaff",
                    dmg: 15 * p.dmgMult * 0.4,
                    isDrone: true,
                    isSwirl: p.swirlShots
                }));
                if (p.hasLauncher) {
                    const speed = 350;
                    const isMini = p.miniAbilities && p.miniAbilities.has('launcher');
                    const fragmentRadius = isMini ? 2.5 : 4; // Mini fragments are smaller
                    const numPairs = store.player.upgradeLevels.launcher || 1;
                    for (let i = 0; i < numPairs; i++) {
                        const spread = 15 + i * 10;
                        const vx_offset = 50 + i * 20;
                        spawnBullet({ x: p.x - spread, y: p.y, vx: -vx_offset, vy: -speed, r: fragmentRadius, col: '#ffaa00', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                        spawnBullet({ x: p.x + spread, y: p.y, vx: vx_offset, vy: -speed, r: fragmentRadius, col: '#ffaa00', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                        if (p.hasIceman && store.iceman) {
                            spawnBullet({ x: store.iceman.x - spread, y: store.iceman.y, vx: -vx_offset, vy: -speed, r: fragmentRadius, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                            spawnBullet({ x: store.iceman.x + spread, y: store.iceman.y, vx: vx_offset, vy: -speed, r: fragmentRadius, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                        }
                        if (p.hasBeefClone && store.beefClone && store.beefClone.mode !== 'juggernaut_bomber') {
                            spawnBullet({ x: store.beefClone.x - spread, y: store.beefClone.y, vx: -vx_offset, vy: -speed, r: fragmentRadius, col: '#66ff66', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isBeefClone: true });
                            spawnBullet({ x: store.beefClone.x + spread, y: store.beefClone.y, vx: vx_offset, vy: -speed, r: 4, col: '#66ff66', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isBeefClone: true });
                        }
                    }
                }
            }

            function fireFlamethrower() {
                const p = store.player;
                if (p.beefChargeState && p.beefChargeState !== 'ready') return;

                // Cap range at 200px
                const maxRange = 200;
                let numFlames, angleRange, speed, life;
                switch (p.flamethrowerLevel) {
                    case 1: numFlames = 4; angleRange = 40; speed = 250; life = maxRange / speed; break;    // ~0.8s to reach 200px
                    case 2: numFlames = 6; angleRange = 70; speed = 280; life = maxRange / speed; break;     // ~0.71s to reach 200px
                    default: numFlames = 8; angleRange = 90; speed = 320; life = maxRange / speed; break;    // ~0.625s to reach 200px
                }

                for (let i = 0; i < numFlames; i++) {
                    const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                    const currentSpeed = speed + Math.random() * 40;
                    const sideOffset = (i % 2 === 0) ? -15 : 15;
                    const spawnX = p.x + sideOffset;
                    const spawnY = p.y + 5;
                    spawnBullet({
                        x: spawnX,
                        y: spawnY,
                        vx: Math.sin(angle) * currentSpeed + (sideOffset * 2),
                        vy: -Math.cos(angle) * currentSpeed,
                        r: 4 + Math.random() * 3,
                        col: `rgba(255, ${20 + Math.random() * 40}, ${190 + Math.random() * 45}, 0.98)`,
                        dmg: 2 * p.dmgMult,
                        life: life,
                        isFlame: true,
                        isLavaBlade: true,
                        lavaBladeBirthX: spawnX,
                        lavaBladeBirthY: spawnY,
                        particles: [],
                        particleSpawnT: 0
                    });
                }

                if (p.hasIceman && store.iceman) {
                    for (let i = 0; i < numFlames; i++) {
                        const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                        const currentSpeed = speed + Math.random() * 40;
                        const sideOffset = (i % 2 === 0) ? -15 : 15;
                        const spawnX = store.iceman.x + sideOffset;
                        const spawnY = store.iceman.y + 5;
                        spawnBullet({
                            x: spawnX,
                            y: spawnY,
                            vx: Math.sin(angle) * currentSpeed + (sideOffset * 2),
                            vy: -Math.cos(angle) * currentSpeed,
                            r: 4 + Math.random() * 2,
                            col: `rgba(250, ${40 + Math.random() * 40}, 255, 0.9)`,
                            dmg: 2 * p.dmgMult * 0.35,
                            life,
                            isFlame: true,
                            isIceman: true,
                            isLavaBlade: true,
                            lavaBladeBirthX: spawnX,
                            lavaBladeBirthY: spawnY,
                            particles: [],
                            particleSpawnT: 0
                        });
                    }
                }
            }

            function launchStarProjectile(originX, originY, angle, options = {}) {
                const speedMultiplier = options.speedMultiplier ?? 1;
                const sizeScale = options.sizeScale ?? 1;
                const trailScale = options.trailLengthScale ?? sizeScale;
                const projectile = {
                    x: originX,
                    y: originY,
                    vx: Math.sin(angle) * STAR_CANNON_SPEED * speedMultiplier,
                    vy: -Math.cos(angle) * STAR_CANNON_SPEED * speedMultiplier,
                    size: STAR_CANNON_SIZE * sizeScale,
                    rotation: 0,
                    trail: [],
                    maxTrailLength: Math.max(12, Math.round(28 * trailScale)),
                    hitIds: new Set(),
                    damageScale: options.damageScale ?? 1,
                    isIceman: options.isIceman || false,
                    hitboxScale: options.hitboxScale ?? STAR_CANNON_HITBOX_SCALE,
                    trailColor: options.trailColor || null,
                    primaryColor: options.primaryColor || null,
                    coreColor: options.coreColor || null,
                    shadowColor: options.shadowColor || null,
                    isEnemy: options.isEnemy || false,
                    enemyDamage: options.enemyDamage ?? 0,
                    variant: options.variant || null
                };
                store.starProjectiles.push(projectile);
            }

            function fireStarCannon() {
                const p = store.player;
                const level = p.starCannonLevel || 0;
                if (level <= 0) return;

                const alternating = level >= 2;
                const bursts = Math.max(1, getStarCannonBurstCount(level));
                const delayStep = Math.max(0.08, STAR_CANNON_ALTERNATE_DELAY - 0.01 * Math.max(0, level - 2));
                let nextSide = alternating ? (p.starCannonNextSide || 'left') : 'left';
                const speedMultiplier = 1 + Math.min(0.25, Math.max(0, level - 1) * 0.015);

                for (let i = 0; i < bursts; i++) {
                    store.pendingStarSalvos.push({
                        delay: i * delayStep,
                        side: nextSide,
                        damageScale: 1,
                        speedMultiplier,
                        playSound: i === 0,
                        sourceLevel: level,
                        sequenceIndex: i
                    });

                    if (alternating) {
                        nextSide = nextSide === 'left' ? 'right' : 'left';
                    }
                }

                p.starCannonNextSide = alternating ? nextSide : 'left';
            }

            function updateStarProjectiles(dt) {
                if (store.pendingStarSalvos.length) {
                    const p = store.player;
                    const originY = p.y - 12;
                    const lateralOffset = 26;
                    for (let i = store.pendingStarSalvos.length - 1; i >= 0; i--) {
                        const salvo = store.pendingStarSalvos[i];
                        salvo.delay -= dt;
                        if (salvo.delay <= 0) {
                            const isRight = salvo.side === 'right';
                            const offset = isRight ? lateralOffset : -lateralOffset;
                            const angle = isRight ? Math.PI / 6 : -Math.PI / 6;
                            const originX = p.x + offset;
                            launchStarProjectile(originX, originY, angle, {
                                hitboxScale: STAR_CANNON_HITBOX_SCALE,
                                damageScale: salvo.damageScale,
                                speedMultiplier: salvo.speedMultiplier,
                                variant: 'player'
                            });
                            if (salvo.playSound) {
                                playSound('stargun');
                            }

                            if (p.hasIceman && store.iceman) {
                                const hasSupport = !!p.starCannonIcemanSupport;
                                const cloneVariant = hasSupport ? 'iceman-main' : 'iceman-mini';
                                const cloneDamageScale = hasSupport ? STAR_CANNON_ICEMAN_DAMAGE_SCALE : STAR_CANNON_MINI_DAMAGE_SCALE;
                                const cloneDelayBase = hasSupport ? STAR_CANNON_CLONE_DELAY : STAR_CANNON_MINI_CLONE_DELAY;
                                const cloneDelayExtra = hasSupport ? 0 : (salvo.sequenceIndex || 0) * STAR_CANNON_MINI_STAGGER;
                                const cloneOffsetMultiplier = hasSupport ? 1 : 0.75;
                                const cloneSpeedMultiplier = (salvo.speedMultiplier ?? 1) * (hasSupport ? 1 : STAR_CANNON_MINI_SPEED_SCALE);
                                const cloneSizeScale = hasSupport ? 1 : STAR_CANNON_MINI_SIZE_SCALE;
                                store.pendingStarClones.push({
                                    delay: cloneDelayBase + cloneDelayExtra,
                                    originX: store.iceman.x + offset * cloneOffsetMultiplier,
                                    originY: store.iceman.y - 12,
                                    angle,
                                    damageScale: cloneDamageScale,
                                    playSound: hasSupport && salvo.playSound,
                                    isIceman: true,
                                    sizeScale: cloneSizeScale,
                                    speedMultiplier: cloneSpeedMultiplier,
                                    variant: cloneVariant,
                                    hitboxScale: STAR_CANNON_HITBOX_SCALE
                                });
                            }

                            if (p.starCannonIcemanSupport && p.hasBeefClone && store.beefClone && store.beefClone.mode !== 'juggernaut_bomber') {
                                store.pendingStarClones.push({
                                    delay: STAR_CANNON_CLONE_DELAY,
                                    originX: store.beefClone.x + offset,
                                    originY: store.beefClone.y - 12,
                                    angle,
                                    damageScale: STAR_CANNON_ICEMAN_DAMAGE_SCALE,
                                    playSound: salvo.playSound,
                                    variant: 'iceman-main',
                                    hitboxScale: STAR_CANNON_HITBOX_SCALE,
                                    speedMultiplier: salvo.speedMultiplier ?? 1,
                                    sizeScale: 1
                                });
                            }

                            store.pendingStarSalvos.splice(i, 1);
                        }
                    }
                }

                if (store.pendingStarClones.length) {
                    for (let i = store.pendingStarClones.length - 1; i >= 0; i--) {
                        const pending = store.pendingStarClones[i];
                        pending.delay -= dt;
                        if (pending.delay <= 0) {
                            launchStarProjectile(pending.originX, pending.originY, pending.angle, {
                                damageScale: pending.damageScale,
                                isIceman: pending.isIceman || false,
                                hitboxScale: pending.hitboxScale ?? STAR_CANNON_HITBOX_SCALE,
                                speedMultiplier: pending.speedMultiplier ?? 1,
                                sizeScale: pending.sizeScale ?? 1,
                                variant: pending.variant,
                                trailColor: pending.trailColor,
                                primaryColor: pending.primaryColor,
                                coreColor: pending.coreColor,
                                shadowColor: pending.shadowColor
                            });
                            if (pending.playSound) {
                                playSound('stargun');
                            }
                            store.pendingStarClones.splice(i, 1);
                        }
                    }
                }

                if (!store.starProjectiles.length) return;
                const p = store.player;
                const baseDamage = STAR_CANNON_DAMAGE * p.dmgMult;
                const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;

                for (let i = store.starProjectiles.length - 1; i >= 0; i--) {
                    const star = store.starProjectiles[i];
                    star.x += star.vx * dt;
                    star.y += star.vy * dt;
                    star.rotation += dt * 2.4;

                    star.trail.push({ x: star.x, y: star.y, life: 1, size: star.size * 0.55 });
                    if (star.trail.length > star.maxTrailLength) star.trail.shift();
                    for (let t = star.trail.length - 1; t >= 0; t--) {
                        const particle = star.trail[t];
                        particle.life -= dt * 2.6;
                        particle.size *= 1 - dt * 1.6;
                        if (particle.life <= 0 || particle.size <= 0.2) star.trail.splice(t, 1);
                    }

                    const hitRadius = star.size * (star.hitboxScale || STAR_CANNON_HITBOX_SCALE);
                    if (star.isEnemy) {
                        const player = store.player;
                        const playerRadius = player.r || 18;
                        const dx = star.x - player.x;
                        const dy = star.y - player.y;
                        const combined = hitRadius + playerRadius;
                        if (dx * dx + dy * dy <= combined * combined) {
                            if (star.enemyDamage > 0) {
                                takeDamage(star.enemyDamage);
                            }
                            store.starProjectiles.splice(i, 1);
                            continue;
                        }

                        if (store.iceman) {
                            const icemanRadius = 18;
                            const iDx = star.x - store.iceman.x;
                            const iDy = star.y - store.iceman.y;
                            const iCombined = hitRadius + icemanRadius;
                            if (iDx * iDx + iDy * iDy <= iCombined * iCombined) {
                                store.starProjectiles.splice(i, 1);
                                continue;
                            }
                        }

                        if (store.beefClone) {
                            const cloneRadius = 18;
                            const cDx = star.x - store.beefClone.x;
                            const cDy = star.y - store.beefClone.y;
                            const cCombined = hitRadius + cloneRadius;
                            if (cDx * cDx + cDy * cDy <= cCombined * cCombined) {
                                store.starProjectiles.splice(i, 1);
                                continue;
                            }
                        }

                        // Check escort drones
                        if (store.escortDrones && store.escortDrones.length > 0) {
                            const droneRadius = 8;
                            let droneHit = false;
                            for (let d = store.escortDrones.length - 1; d >= 0; d--) {
                                const drone = store.escortDrones[d];
                                const dDx = star.x - drone.x;
                                const dDy = star.y - drone.y;
                                const dCombined = hitRadius + droneRadius;
                                if (dDx * dDx + dDy * dDy <= dCombined * dCombined) {
                                    // Drone is destroyed
                                    store.escortDrones.splice(d, 1);
                                    droneHit = true;
                                    break;
                                }
                            }
                            if (droneHit) {
                                store.starProjectiles.splice(i, 1);
                                continue;
                            }
                        }
                    } else {
                        for (const target of targets) {
                            if (!target || target.dead || target.hp <= 0) continue;
                            if (target === store.boss && target.isInvincible) continue;
                            if (target.isHeatDeath) continue;

                            const targetRadius = target.r || target.radius || 18;
                            const dx = star.x - target.x;
                            const dy = star.y - target.y;
                            const combined = hitRadius + targetRadius;
                            if (dx * dx + dy * dy <= combined * combined) {
                                const id = target.id || target.__starId || target;
                                if (!star.hitIds.has(id)) {
                                    const starDamage = baseDamage * (star.damageScale ?? 1);
                                    applyStarDamage(target, starDamage);
                                    star.hitIds.add(id);
                                }
                            }
                        }
                    }

                    if (star.x < -80 || star.x > W + 80 || star.y < -120 || star.y > H + 120) {
                        store.starProjectiles.splice(i, 1);
                    }
                }
            }

            function applyStarDamage(target, dmg) {
                const p = store.player;
                let damage = dmg;

                if (Math.random() < p.critChance) {
                    damage *= p.critDamage;
                    store.activeEffects.push(createEffect('critText', target.x, target.y));
                    if (Math.random() < 0.05) spawnPowerup(target.x, target.y);
                }

                if (target === store.boss) playSound('hit');
                target.hp -= damage;
                store.world.totalDamage = (store.world.totalDamage || 0) + damage;

                if (p.pilotGenome === 'beef') {
                    p.beefShieldDamageDealt = (p.beefShieldDamageDealt || 0) + damage;
                }

                if (p.vampirism > 0) {
                    let healAmount = damage * p.vampirism;
                    healAmount = Math.max(healAmount, 1);
                    healAmount = Math.min(healAmount, 5);
                    p.hp = Math.min(p.hpMax, p.hp + healAmount);
                }

                if (target.hp <= 0) {
                    target.dead = true;
                    if (target.type === 'void_champion') {
                        store.enemies.forEach(minion => {
                            if (minion.orbitTargetId === target.id && !minion.dead) {
                                spawnGibs(minion.x, minion.y, minion.color);
                                minion.dead = true;
                            }
                        });
                        handleVoidChampionReward(target);
                    }

                    if (target === store.boss) {
                        handleBossDefeat();
                    } else {
                        spawnGibs(target.x, target.y, target.color);
                        store.world.score += target.score;
                        addWorldGold(target.gold);
                        awardXp(target.xp); // Apply XP diminishing returns
                        store.world.kills++;

                        spawnPowerup(target.x, target.y);
                        explode(target.x, target.y);
                    }
                }
            }

            function drawStarProjectiles() {
                if (!store.starProjectiles.length) return;
                for (const star of store.starProjectiles) {
                    const isEnemyStar = !!star.isEnemy;
                    const paletteKey = isEnemyStar
                        ? 'enemy'
                        : (star.variant || (star.isIceman ? 'iceman-main' : 'player'));
                    const palette = STAR_VARIANT_PALETTES[paletteKey] || STAR_VARIANT_PALETTES.player;
                    const trailFillBase = star.trailColor || palette.trailFillBase;
                    const trailShadowBase = palette.trailShadowBase;
                    for (const particle of star.trail) {
                        const trailAlpha = Math.max(0, Math.min(1, particle.life * 0.6));
                        const shadowAlpha = Math.max(0, Math.min(1, particle.life));
                        ctx.fillStyle = `${trailFillBase}${trailAlpha})`;
                        ctx.shadowColor = `${trailShadowBase}${shadowAlpha})`;
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.save();
                    ctx.translate(star.x, star.y);
                    ctx.rotate(star.rotation);

                    ctx.fillStyle = star.primaryColor || palette.primaryFill;
                    ctx.shadowColor = star.shadowColor || palette.shadowFill;
                    ctx.shadowBlur = 24;
                    drawStarShape(ctx, 0, 0, 5, star.size, star.size * 0.45);
                    ctx.fill();

                    ctx.fillStyle = star.coreColor || palette.coreFill;
                    ctx.shadowBlur = 12;
                    drawStarShape(ctx, 0, 0, 5, star.size * 0.65, star.size * 0.28);
                    ctx.fill();

                    ctx.restore();
                    ctx.shadowBlur = 0;
                }
            }

            const BEEF_CLONE_SORTIE_COOLDOWN = 12;

            function rollBeefCloneSortieCooldown() {
                return BEEF_CLONE_SORTIE_COOLDOWN;
            }

            function createMirrorClone(player, existingClone = null) {
                const margin = 60;
                const clone = existingClone && existingClone.mode === 'mirror' ? { ...existingClone } : {};
                clone.mode = 'mirror';
                clone.state = 'tether';
                clone.backlineDistance = clone.backlineDistance ?? 140;
                clone.minBacklineDistance = clone.minBacklineDistance ?? 80;
                clone.followEase = clone.followEase ?? 7.2;
                clone.horizontalEase = clone.horizontalEase ?? 6.3;
                clone.topBoundary = clone.topBoundary ?? 60;
                clone.visualScale = clone.visualScale || 0.82;
                clone.shotDamageScale = clone.shotDamageScale ?? 0.35;
                clone.fireRate = clone.fireRate || 0.28;
                clone.fireCooldown = clone.fireCooldown ?? (Math.random() * clone.fireRate);
                clone.bobPhase = typeof clone.bobPhase === 'number' ? clone.bobPhase : Math.random() * Math.PI * 2;
                clone.bobSpeed = clone.bobSpeed || 1.6;
                clone.direction = clone.direction || 1;
                clone.bombCooldown = clone.bombCooldown ?? rollBeefCloneSortieCooldown();
                clone.pendingBombs = clone.pendingBombs ?? 0;
                clone.bombInterval = clone.bombInterval || 0.28;
                clone.bombDamageScale = clone.bombDamageScale ?? 0.45;
                clone.bombRadiusScale = clone.bombRadiusScale ?? 0.65;
                clone.bombSpeedScale = clone.bombSpeedScale ?? 1.05;
                clone.bombSeekStrength = clone.bombSeekStrength ?? 520;
                clone.bombMaxSpeed = clone.bombMaxSpeed ?? 520;
                const clampX = clamp(player.x, margin, W - margin);
                const backline = clone.backlineDistance;
                const initialY = Math.max(clone.topBoundary, player.y - backline);
                clone.x = clamp(clone.x ?? clampX, margin, W - margin);
                clone.y = clamp(clone.y ?? initialY, clone.topBoundary, H * 0.82);
                return clone;
            }

            function fireMirrorCloneShot(clone, player) {
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                if (!potentialTargets || potentialTargets.length === 0) return false;

                let best = null;
                let bestDistSq = Infinity;
                for (const enemy of potentialTargets) {
                    if (!enemy || enemy.dead || enemy.hp <= 0) continue;
                    const dx = enemy.x - clone.x;
                    const dy = enemy.y - clone.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < bestDistSq) {
                        bestDistSq = distSq;
                        best = enemy;
                    }
                }

                if (!best) return false;

                const angle = Math.atan2(best.y - clone.y, best.x - clone.x);
                const bulletSpeed = 620;
                const damageScale = clone.shotDamageScale ?? 0.35;
                const baseDamage = 15 * (player?.dmgMult || 1) * damageScale;
                const startOffset = 12;

                spawnBullet({
                    x: clone.x + Math.cos(angle) * startOffset,
                    y: clone.y + Math.sin(angle) * startOffset,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 2,
                    col: '#6be48e',
                    dmg: baseDamage,
                    pierce: Math.max(0, (player?.piercing || 0) - 1),
                    explosive: false,
                    isBeefClone: true,
                    isSwirl: false
                });

                if (Math.abs(Math.cos(angle)) > 0.15) {
                    clone.direction = Math.cos(angle) >= 0 ? 1 : -1;
                }

                return true;
            }

            function selectMirrorCloneBombTarget(clone) {
                const threats = [];
                if (store.boss && !store.boss.dead && store.boss.hp > 0) {
                    threats.push(store.boss);
                }
                if (Array.isArray(store.enemies)) {
                    for (const enemy of store.enemies) {
                        if (!enemy || enemy.dead || enemy.hp <= 0) continue;
                        threats.push(enemy);
                    }
                }
                if (!threats.length) return null;
                let best = null;
                let bestDistSq = Infinity;
                for (const threat of threats) {
                    const dx = (threat.x ?? clone.x) - clone.x;
                    const dy = (threat.y ?? clone.y) - clone.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < bestDistSq) {
                        bestDistSq = distSq;
                        best = threat;
                    }
                }
                return best;
            }

            function updateMirrorClone(dt) {
                const player = store.player;
                if (!player || player.dead) return;
                if (!store.beefClone || store.beefClone.mode !== 'mirror') {
                    store.beefClone = createMirrorClone(player, store.beefClone);
                }
                const clone = store.beefClone;
                if (!clone || clone.mode !== 'mirror') return;

                const margin = 60;
                const topBoundary = clone.topBoundary ?? 60;
                const followEase = clone.followEase ?? 7.2;
                const horizontalEase = clone.horizontalEase ?? followEase;
                const bobSpeed = clone.bobSpeed || 1.6;
                clone.bobPhase = (clone.bobPhase || 0) + dt * bobSpeed;
                const bobOffset = Math.sin(clone.bobPhase) * 8;

                const targetX = clamp(player.x, margin, W - margin);
                const midfield = H * 0.5;
                const backlineDistance = clone.backlineDistance ?? 140;
                const minBacklineDistance = clone.minBacklineDistance ?? 80;

                let dynamicDistance = backlineDistance;
                if (player.y < midfield) {
                    const blendStart = midfield;
                    const blendEnd = topBoundary + 40;
                    const denom = Math.max(1, blendStart - blendEnd);
                    const t = clamp((blendStart - player.y) / denom, 0, 1);
                    dynamicDistance = backlineDistance - (backlineDistance - minBacklineDistance) * t;
                }

                let desiredY = player.y - dynamicDistance;
                if (desiredY < topBoundary) desiredY = topBoundary;
                const maxAnchor = Math.min(player.y - 30, H * 0.88);
                const adjustedY = clamp(desiredY + bobOffset, topBoundary, maxAnchor);

                const horizontalFactor = 1 - Math.exp(-dt * horizontalEase);
                clone.x += (targetX - clone.x) * horizontalFactor;

                const verticalFactor = 1 - Math.exp(-dt * followEase);
                clone.y += (adjustedY - clone.y) * verticalFactor;

                clone.x = clamp(clone.x, margin, W - margin);
                clone.y = clamp(clone.y, topBoundary, H * 0.9);

                clone.direction = clone.x <= targetX ? 1 : -1;

                clone.fireRate = clone.fireRate || 0.28;
                clone.fireCooldown = Math.max(0, (clone.fireCooldown ?? 0) - dt);
                if (clone.fireCooldown <= 0) {
                    const fired = fireMirrorCloneShot(clone, player);
                    const baseRate = clone.fireRate;
                    const jitter = Math.min(0.1, baseRate * 0.35);
                    clone.fireCooldown = baseRate + (Math.random() - 0.5) * jitter;
                    if (!fired) {
                        clone.fireCooldown = Math.min(baseRate, 0.18);
                    }
                }

                clone.bombCooldown = (clone.bombCooldown ?? rollBeefCloneSortieCooldown()) - dt;
                if (clone.pendingBombs > 0) {
                    clone.bombTimer = (clone.bombTimer ?? 0) - dt;
                    if (clone.bombTimer <= 0) {
                        const target = selectMirrorCloneBombTarget(clone);
                        if (target) {
                            spawnJuggernautBomb(clone, player, {
                                damageScale: clone.bombDamageScale,
                                radiusScale: clone.bombRadiusScale,
                                speedScale: clone.bombSpeedScale,
                                target,
                                seekStrength: clone.bombSeekStrength,
                                maxSpeed: clone.bombMaxSpeed
                            });
                            clone.pendingBombs--;
                            clone.bombTimer = clone.pendingBombs > 0 ? (clone.bombInterval || 0.28) : 0;
                        } else {
                            clone.pendingBombs = 0;
                            clone.bombCooldown = Math.max(clone.bombCooldown, 0.35);
                        }
                    }
                } else if (clone.bombCooldown <= 0 && ((Array.isArray(store.enemies) && store.enemies.some(e => e && !e.dead && e.hp > 0)) || (store.boss && !store.boss.dead && store.boss.hp > 0))) {
                    clone.pendingBombs = 3;
                    clone.bombTimer = 0;
                    clone.bombCooldown = rollBeefCloneSortieCooldown();
                }
            }

            function activateJuggernautClone(p) {
                const margin = 60;
                const clone = store.beefClone && store.beefClone.mode === 'juggernaut_bomber'
                    ? store.beefClone
                    : {};

                store.juggernautBombs = [];

                clone.mode = 'juggernaut_bomber';
                clone.visualScale = clone.visualScale || 0.95;
                clone.backlineDistance = clone.backlineDistance ?? 170;
                clone.minBacklineDistance = clone.minBacklineDistance ?? 110;
                clone.followEase = clone.followEase ?? 7.2;
                clone.horizontalEase = clone.horizontalEase ?? 5.6;
                clone.topBoundary = clone.topBoundary ?? 60;
                clone.bobSpeed = clone.bobSpeed || 1.7;
                clone.bobPhase = typeof clone.bobPhase === 'number' ? clone.bobPhase : Math.random() * Math.PI * 2;
                clone.bombDamageScale = clone.bombDamageScale ?? 1;
                clone.bombRadiusScale = clone.bombRadiusScale ?? 1;
                clone.bombSpeedScale = clone.bombSpeedScale ?? 1.08;
                clone.bombSeekStrength = clone.bombSeekStrength ?? 640;
                clone.bombMaxSpeed = clone.bombMaxSpeed ?? 620;
                clone.baseInterval = p.beefUnstoppableForce ? 0.45 : (clone.baseInterval || 0.6);
                clone.dropTimer = 0;
                clone.direction = clone.direction || 1;
                clone.x = clamp(p.x, margin, W - margin);
                const initialY = clamp(p.y - clone.backlineDistance, clone.topBoundary, H * 0.88);
                clone.y = clamp(clone.y ?? initialY, clone.topBoundary, H * 0.88);

                store.beefClone = clone;
            }

            function updateJuggernautClone(dt) {
                const clone = store.beefClone;
                if (!clone || clone.mode !== 'juggernaut_bomber') return;
                const p = store.player;
                if (!p || p.dead) return;

                const margin = 60;
                const topBoundary = clone.topBoundary ?? 60;
                const followEase = clone.followEase ?? 7.2;
                const horizontalEase = clone.horizontalEase ?? followEase;
                const backlineDistance = clone.backlineDistance ?? 170;
                const minBacklineDistance = clone.minBacklineDistance ?? 110;
                const midfield = H * 0.5;

                const bobSpeed = clone.bobSpeed || 1.7;
                clone.bobPhase = (clone.bobPhase || 0) + dt * bobSpeed;
                const bobBase = 14 + Math.min(12, (p.beefExplosionDamage || 0) * 8);
                const bobOffset = Math.sin(clone.bobPhase) * bobBase;

                const targetX = clamp(p.x, margin, W - margin);

                let dynamicDistance = backlineDistance;
                if (p.y < midfield) {
                    const blendStart = midfield;
                    const blendEnd = topBoundary + 40;
                    const denom = Math.max(1, blendStart - blendEnd);
                    const t = clamp((blendStart - p.y) / denom, 0, 1);
                    dynamicDistance = backlineDistance - (backlineDistance - minBacklineDistance) * t;
                }

                let desiredY = p.y - dynamicDistance;
                if (desiredY < topBoundary) desiredY = topBoundary;
                const maxAnchor = Math.min(p.y - 30, H * 0.88);
                const adjustedY = clamp(desiredY + bobOffset, topBoundary, maxAnchor);

                const horizontalFactor = 1 - Math.exp(-dt * horizontalEase);
                clone.x += (targetX - clone.x) * horizontalFactor;

                const verticalFactor = 1 - Math.exp(-dt * followEase);
                clone.y += (adjustedY - clone.y) * verticalFactor;

                clone.x = clamp(clone.x, margin, W - margin);
                clone.y = clamp(clone.y, topBoundary, H * 0.9);

                clone.direction = clone.x <= targetX ? 1 : -1;

                const unstoppableBonus = p.beefUnstoppableForce ? 0.12 : 0;
                const eliteBonus = p.beefEliteCombat ? 0.08 : 0;
                const intervalBase = clone.baseInterval || 0.6;
                const interval = Math.max(0.24, intervalBase - unstoppableBonus - eliteBonus);
                clone.dropTimer = (clone.dropTimer || 0) - dt;
                if (clone.dropTimer <= 0) {
                    const target = selectMirrorCloneBombTarget(clone);
                    if (target) {
                        spawnJuggernautBomb(clone, p, {
                            damageScale: clone.bombDamageScale,
                            radiusScale: clone.bombRadiusScale,
                            speedScale: clone.bombSpeedScale,
                            target,
                            seekStrength: clone.bombSeekStrength,
                            maxSpeed: clone.bombMaxSpeed
                        });
                        clone.dropTimer = interval;
                    } else {
                        clone.dropTimer = Math.min(interval, 0.35);
                    }
                }
            }

            function spawnJuggernautBomb(clone, player, options = null) {
                const unstoppableBonus = player.beefUnstoppableForce ? 1.4 : 1;
                const eliteBonus = player.beefEliteCombat ? 1.15 : 1;
                const opts = options || {};
                const damageScale = opts.damageScale ?? 1;
                const radiusScale = opts.radiusScale ?? 1;
                const speedScale = opts.speedScale ?? 1;
                const gravityScale = opts.gravityScale ?? 1;
                const target = opts.target || null;
                const seekStrength = opts.seekStrength ?? (target ? 480 : 0);
                const maxSpeed = opts.maxSpeed ?? (target ? 520 : 360);
                const damage = 180 * player.dmgMult * unstoppableBonus * eliteBonus * damageScale;
                const radius = (100 + (player.beefExplosionRadius ? 35 : 0)) * radiusScale;
                if (!Array.isArray(store.juggernautBombs)) store.juggernautBombs = [];

                const spawnX = clone.x;
                const spawnY = clone.y + 18;
                let vx = (clone.direction || 1) * 45 * speedScale;
                let vy = 30;
                let gravity = 520 * gravityScale;

                if (target) {
                    const tx = target.x ?? spawnX;
                    const ty = target.y ?? spawnY;
                    const dx = tx - spawnX;
                    const dy = ty - spawnY;
                    const dist = Math.hypot(dx, dy) || 1;
                    const initialSpeed = maxSpeed;
                    vx = (dx / dist) * initialSpeed;
                    vy = (dy / dist) * initialSpeed;
                    gravity = 0;
                }

                const bomb = {
                    x: spawnX,
                    y: spawnY,
                    vx,
                    vy,
                    gravity,
                    radius,
                    damage,
                    bossDamageScale: 0.48,
                    life: 3.5,
                    rotation: 0,
                    rotationSpeed: (clone.direction || 1) * 5,
                    trailTimer: 0.05,
                    target: target || null,
                    targetX: target ? target.x : undefined,
                    targetY: target ? target.y : undefined,
                    seek: !!target,
                    seekStrength,
                    maxSpeed
                };
                store.juggernautBombs.push(bomb);
                store.activeEffects.push(createEffect('hitSpark', clone.x, clone.y, 24, { strength: 35 }));
            }

            function stepJuggernautBombs(dt) {
                if (!store.juggernautBombs.length) return;
                const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
                const approachValue = (current, target, maxDelta) => {
                    if (current < target) {
                        return Math.min(target, current + maxDelta);
                    }
                    return Math.max(target, current - maxDelta);
                };
                for (let i = store.juggernautBombs.length - 1; i >= 0; i--) {
                    const bomb = store.juggernautBombs[i];
                    bomb.life -= dt;
                    if (bomb.seek) {
                        if (bomb.target && !bomb.target.dead && bomb.target.hp > 0) {
                            bomb.targetX = bomb.target.x;
                            bomb.targetY = bomb.target.y;
                        }
                        if (bomb.targetX !== undefined && bomb.targetY !== undefined) {
                            const dx = bomb.targetX - bomb.x;
                            const dy = bomb.targetY - bomb.y;
                            const dist = Math.hypot(dx, dy) || 1;
                            const desiredSpeed = bomb.maxSpeed || 480;
                            const desiredVx = (dx / dist) * desiredSpeed;
                            const desiredVy = (dy / dist) * desiredSpeed;
                            const steer = (bomb.seekStrength || 420) * dt;
                            bomb.vx = approachValue(bomb.vx, desiredVx, steer);
                            bomb.vy = approachValue(bomb.vy, desiredVy, steer);
                            if (dist <= (bomb.radius || 90) * 0.5) {
                                detonateJuggernautBomb(bomb);
                                store.juggernautBombs.splice(i, 1);
                                continue;
                            }
                        }
                    }
                    if (bomb.gravity) {
                        bomb.vy += bomb.gravity * dt;
                    }
                    bomb.x += bomb.vx * dt;
                    bomb.y += bomb.vy * dt;
                    bomb.rotation = (bomb.rotation || 0) + (bomb.rotationSpeed || 0) * dt;
                    bomb.trailTimer -= dt;
                    if (bomb.trailTimer <= 0) {
                        bomb.trailTimer = 0.1;
                        store.activeEffects.push(createEffect('jugFearEmber', bomb.x, bomb.y, 18));
                    }

                    if ((!bomb.seek && bomb.y >= H - 40) || bomb.life <= 0) {
                        detonateJuggernautBomb(bomb);
                        store.juggernautBombs.splice(i, 1);
                        continue;
                    }

                    let detonated = false;
                    for (const target of targets) {
                        if (!target || target.dead || target.hp <= 0) continue;
                        const targetRadius = target.r || target.radius || 18;
                        const dx = bomb.x - target.x;
                        const dy = bomb.y - target.y;
                        if (dx * dx + dy * dy <= (targetRadius + 12) * (targetRadius + 12)) {
                            detonateJuggernautBomb(bomb);
                            store.juggernautBombs.splice(i, 1);
                            detonated = true;
                            break;
                        }
                    }
                    if (detonated) continue;
                }
            }

            function detonateJuggernautBomb(bomb) {
                if (!bomb || bomb.dead) return;
                bomb.dead = true;
                playSound('explosion');
                const radius = bomb.radius || 90;
                store.activeEffects.push(createEffect('grenadeExplosion', bomb.x, bomb.y, radius));
                const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
                for (const target of targets) {
                    if (!target || target.dead || target.hp <= 0) continue;
                    const targetRadius = target.r || target.radius || 18;
                    const dx = bomb.x - target.x;
                    const dy = bomb.y - target.y;
                    if (dx * dx + dy * dy > (radius + targetRadius) * (radius + targetRadius)) continue;
                    let dmg = bomb.damage;
                    if (target === store.boss) {
                        dmg *= bomb.bossDamageScale || 0.5;
                    }
                    applyStarDamage(target, dmg);
                    registerEnemyHit(target, {
                        angle: Math.atan2(target.y - bomb.y, target.x - bomb.x),
                        knockbackStrength: 120,
                        knockbackDuration: 0.18
                    });
                }
            }

            function drawJuggernautBombs() {
                if (!store.juggernautBombs.length) return;
                ctx.save();
                for (const bomb of store.juggernautBombs) {
                    ctx.save();
                    ctx.translate(bomb.x, bomb.y);
                    ctx.rotate(bomb.rotation || 0);
                    const radius = 12;
                    const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, radius * 1.2);
                    gradient.addColorStop(0, 'rgba(255, 240, 180, 0.95)');
                    gradient.addColorStop(0.5, 'rgba(255, 150, 60, 0.8)');
                    gradient.addColorStop(1, 'rgba(80, 20, 20, 0.2)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radius, radius * 1.35, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 200, 120, 0.85)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, radius * 0.7, radius * 0.9, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(255, 130, 80, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-radius * 0.6, radius * 1.2);
                    ctx.lineTo(0, radius * 1.9);
                    ctx.lineTo(radius * 0.6, radius * 1.2);
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.restore();
            }

            function drawShadowEchoes() {
                if (!store.shadowEchoes || !store.shadowEchoes.length) return;
                ctx.save();
                for (const echo of store.shadowEchoes) {
                    const lifeRatio = echo.maxLife ? Math.max(0, Math.min(1, echo.life / echo.maxLife)) : 1;
                    if (lifeRatio <= 0) continue;
                    ctx.globalAlpha = 0.35 * lifeRatio;
                    ctx.fillStyle = `rgba(150, 160, 255, ${0.25 + lifeRatio * 0.35})`;
                    ctx.beginPath();
                    ctx.ellipse(echo.x, echo.y, 24 * lifeRatio, 16 * lifeRatio, echo.rotation || 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            function drawTemporalEchoes() {
                const echoes = store.temporalEchoes;
                if (!Array.isArray(echoes) || echoes.length === 0) return;
                const time = performance.now() / 1000;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const echo of echoes) {
                    if (!echo || echo.dead) continue;
                    const lifeRatio = echo.maxLife ? Math.max(0, Math.min(1, echo.life / echo.maxLife)) : 1;
                    if (lifeRatio <= 0) continue;

                    const baseRadius = echo.radius || 18;
                    const pulse = 1 + Math.sin(time * 5.2 + (echo.pulseOffset || 0)) * 0.08;
                    const auraRadius = baseRadius * (1.7 + (echo.stage === 'dash' ? 0.28 : 0));
                    const coreColor = echo.color || '#8cf5ff';
                    const trailColor = echo.trailColor || '#2a9dff';

                    const auraGradient = ctx.createRadialGradient(echo.x, echo.y, 0, echo.x, echo.y, auraRadius * pulse);
                    auraGradient.addColorStop(0, addAlpha(coreColor, 0.72 * lifeRatio));
                    auraGradient.addColorStop(0.55, addAlpha(coreColor, 0.32 * lifeRatio));
                    auraGradient.addColorStop(1, addAlpha(coreColor, 0));
                    ctx.fillStyle = auraGradient;
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, auraRadius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.lineWidth = 2.2;
                    ctx.strokeStyle = addAlpha(trailColor, 0.55 * lifeRatio);
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, baseRadius * (1.05 + pulse * 0.2), 0, Math.PI * 2);
                    ctx.stroke();

                    if (echo.stage === 'dash') {
                        const vx = echo.vx || 0;
                        const vy = echo.vy || 0;
                        const speed = Math.hypot(vx, vy) || 0;
                        if (speed > 0) {
                            const tailLength = Math.min(120, Math.max(55, speed * 0.24));
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = addAlpha(trailColor, 0.4 * lifeRatio);
                            ctx.beginPath();
                            ctx.moveTo(echo.x, echo.y);
                            ctx.lineTo(echo.x - (vx / speed) * tailLength, echo.y - (vy / speed) * tailLength);
                            ctx.stroke();
                        }
                    }
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            function drawStarShape(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;

                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(cx, cy - outerRadius);
                ctx.closePath();
            }

            function drawGoldenOrbs() {
                if (!store.goldenOrbs || store.goldenOrbs.length === 0) {
                    return;
                }
                const time = performance.now() / 1000;

                for (const orb of store.goldenOrbs) {
                    if (orb.trail && orb.trail.length) {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        for (const node of orb.trail) {
                            const lifeRatio = Math.max(0, node.life / GOLDEN_ORB_CONFIG.trailLife);
                            if (lifeRatio <= 0) continue;
                            ctx.globalAlpha = lifeRatio * 0.45;
                            ctx.fillStyle = `rgba(255, 210, 120, ${lifeRatio * 0.5})`;
                            ctx.beginPath();
                            ctx.arc(node.x, node.y, 9 * lifeRatio, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    }

                    ctx.save();
                    ctx.translate(orb.x, orb.y);
                    if (orb.state === 'homing') {
                        ctx.rotate(orb.heading || 0);
                    }
                    ctx.globalCompositeOperation = 'lighter';

                    const pulse = 0.85 + Math.sin(time * 6 + (orb.pulseOffset || 0)) * 0.15;
                    const outerGlowRadius = orb.r * (1.4 + pulse * 0.25);
                    const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, outerGlowRadius);
                    glowGradient.addColorStop(0, 'rgba(255, 255, 220, 0.18)');
                    glowGradient.addColorStop(0.5, 'rgba(255, 210, 100, 0.4)');
                    glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(0, 0, outerGlowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    const ringOuter = orb.r * (0.95 + pulse * 0.12);
                    const ringInner = ringOuter * 0.55;
                    const ringGradient = ctx.createRadialGradient(0, 0, ringInner * 0.75, 0, 0, ringOuter);
                    ringGradient.addColorStop(0, 'rgba(255, 250, 210, 0.85)');
                    ringGradient.addColorStop(0.45, 'rgba(255, 210, 90, 0.75)');
                    ringGradient.addColorStop(0.9, 'rgba(255, 130, 20, 0.35)');
                    ringGradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
                    ctx.fillStyle = ringGradient;
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 225, 140, 0.95)';
                    ctx.lineWidth = Math.max(3, orb.r * 0.18);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(255, 255, 220, 0.5)';
                    ctx.lineWidth = Math.max(2, orb.r * 0.12);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringInner, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.6 + 0.3 * Math.sin(time * 8 + (orb.pulseOffset || 0));
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                    ctx.beginPath();
                    ctx.arc(0, 0, ringInner * 0.45, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }

            function drawTimeShards() {
                const shards = store.timeShards;
                if (!Array.isArray(shards) || shards.length === 0) return;
                const time = performance.now() / 1000;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (const shard of shards) {
                    if (!shard || shard.dead) continue;
                    const lifeRatio = shard.maxLife ? Math.max(0, Math.min(1, shard.life / shard.maxLife)) : 1;
                    if (lifeRatio <= 0) continue;

                    const baseRadius = shard.r || 14;
                    const pulse = 1 + Math.sin(time * 4.3 + (shard.sparkle || 0)) * 0.08 + (shard.hitPulse || 0) * 0.35;
                    const glowRadius = baseRadius * (1.9 + (shard.hitPulse || 0) * 0.6);

                    const glowGradient = ctx.createRadialGradient(shard.x, shard.y, 0, shard.x, shard.y, glowRadius * pulse);
                    glowGradient.addColorStop(0, `rgba(157, 247, 255, ${0.55 * lifeRatio})`);
                    glowGradient.addColorStop(0.65, `rgba(122, 231, 255, ${0.28 * lifeRatio})`);
                    glowGradient.addColorStop(1, 'rgba(122, 231, 255, 0)');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(shard.x, shard.y, glowRadius * pulse, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.save();
                    ctx.translate(shard.x, shard.y);
                    ctx.rotate(time * 1.9 + (shard.sparkle || 0));
                    ctx.globalAlpha = 0.92 * lifeRatio;
                    ctx.fillStyle = `rgba(102, 206, 255, ${0.9 * lifeRatio})`;
                    const w = baseRadius * 0.9 * pulse;
                    const h = baseRadius * 1.35 * pulse;
                    ctx.beginPath();
                    ctx.moveTo(0, -h);
                    ctx.lineTo(w, 0);
                    ctx.lineTo(0, h);
                    ctx.lineTo(-w, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();

                    ctx.save();
                    ctx.fillStyle = `rgba(240, 255, 255, ${0.85 * lifeRatio})`;
                    ctx.font = 'bold 12px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.translate(shard.x, shard.y - baseRadius * 1.25);
                    ctx.scale(1, 0.9);
                    ctx.fillText(`x${shard.buffStacks || 1}`, 0, 0);
                    ctx.restore();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }

            function ensureShadowCloneInit(b) {
                if (b.shadowInitialized) return;
                b.shadowInitialized = true;
                b.shadowAbilityCooldown = 26;
                b.shadowAbilityTimers = {
                    star: 5 + Math.random() * 2,
                    lightning: 10 + Math.random() * 2,
                    hounds: 15 + Math.random() * 2,
                    charge: 20 + Math.random() * 2,
                    pulseWave: 8 + Math.random() * 2,
                    voidRift: 18 + Math.random() * 2
                };
                b.shadowAbilityOrder = ['star', 'pulseWave', 'lightning', 'hounds', 'voidRift', 'charge'];
                b.shadowAbilityIndex = 0;
                b.multishotTimer = 0.9;
                b.shadowChargeVX = 0;
                b.shadowChargeVY = 0;
                b.shadowChargeTrailCooldown = 0;
                b.shadowChargeHit = false;
                b.shadowTelegraph = null;
                b.shadowTelegraphTarget = null;
                spawnShadowChampionEscort(b);
            }

            function getActiveShadowChampion() {
                if (!store.shadowChampionId) return null;
                return store.enemies.find(e => e.id === store.shadowChampionId && !e.dead) || null;
            }

            function spawnShadowChampionEscort(boss) {
                if (!store || !store.enemies) return null;
                if (store.shadowChampionDefeated) return null;
                const existing = getActiveShadowChampion();
                if (existing) {
                    store.shadowChampionLastPos = { x: existing.x, y: existing.y };
                    return existing;
                }

                const guardRadius = 130;
                const spawnAngle = Math.random() * Math.PI * 2;
                const offsetX = Math.cos(spawnAngle) * guardRadius;
                const offsetY = Math.sin(spawnAngle) * Math.max(guardRadius * 0.55, 60);
                const targetY = clamp(boss.y + 90, 120, H * 0.78);
                const spawnX = clamp(boss.x + offsetX, 60, W - 60);
                const spawnProps = {
                    x: spawnX,
                    y: targetY,
                    hpScale: Math.max(1.1, boss.hpMax ? boss.hpMax / 4500 : 1.1),
                    damageMult: 1 + Math.max(0, store.world.wave - 8) * 0.025,
                    guardRadius,
                    guardAngle: spawnAngle,
                    angularSpeed: 0.7 + Math.random() * 0.25,
                    anchorOffsetY: 90,
                    bossLinkId: boss._instanceId || (boss._instanceId = performance.now() + Math.random()),
                    fireCooldown: boss.isEnraged ? 1.1 : 1.35,
                    momentum: 3.6
                };

                const champion = spawnEnemy('shadow_champion', spawnProps);
                if (!champion) return null;

                champion.x = spawnX;
                champion.y = targetY;
                store.enemies.push(champion);
                store.shadowChampionId = champion.id;
                store.shadowChampionDefeated = false;
                store.shadowChampionTokenDropped = false;
                store.shadowChampionLastPos = { x: champion.x, y: champion.y };

                activateSpawnIntro(champion, {
                    duration: 0.75,
                    dropDistance: 200,
                    targetY,
                    effectColor: '#8f9bff',
                    topClampBuffer: 0.7,
                    fireDelayBuffer: 0.6,
                    clusterIndex: -1
                });

                store.activeEffects.push(createEffect('spawnTeleport', champion.x, targetY, champion.r || 22, {
                    duration: 1.1,
                    color: '#8f9bff',
                    clusterIndex: -1,
                    isChampion: true
                }));

                announce('Shadow champion joins the mirror!');
                return champion;
            }

            function dropShadowChampionToken(x, y) {
                if (store.shadowChampionTokenDropped) return;
                if (!store.powerups) store.powerups = [];
                const dropX = clamp(x, 20, W - 20);
                const dropY = clamp(y, 40, H - 40);
                store.powerups.push({ x: dropX, y: dropY, r: 16, type: 'shadow_champion_token' });
                store.shadowChampionTokenDropped = true;
                announce('Champion sigil recovered! Summon secured.');
            }

            function finalizeShadowChampionAfterBoss(bossX, bossY) {
                if (store.shadowChampionTokenDropped) return;
                let dropPos = { x: bossX, y: bossY };
                const champion = getActiveShadowChampion();
                if (champion) {
                    dropPos = { x: champion.x, y: champion.y - 18 };
                    champion.dead = true;
                    spawnGibs(champion.x, champion.y, champion.color);
                } else if (store.shadowChampionLastPos) {
                    dropPos = { x: store.shadowChampionLastPos.x, y: store.shadowChampionLastPos.y - 18 };
                }
                store.shadowChampionId = null;
                store.shadowChampionDefeated = true;
                store.shadowChampionLastPos = { x: dropPos.x, y: dropPos.y };
                dropShadowChampionToken(dropPos.x, dropPos.y);
            }

            const PLAYER_CHAMPION_CONFIG = Object.freeze({
                baseGuardRadius: 110,
                baseAngularSpeed: 1.35,
                baseFireCooldown: 1.25,
                baseDashCooldown: 2.8,
                maxLevel: 5,
                maxMinions: 3
            });

            const CHAMPION_ATTACK_MODULES = Object.freeze([
                // KINETIC MODULES - Physical/Ballistic Damage
                {
                    id: 'precision_strike',
                    name: 'PRECISION STRIKE',
                    icon: ' ',
                    cost: 180,
                    damageType: 'kinetic',
                    attackSpeed: 'slow',
                    targetType: 'single',
                    tradeOff: 'Very slow, devastating single shots',
                    desc: 'Slow-charging railgun shots that deal massive single-target damage. Effective against heavily armored enemies and bosses.',
                    flavor: 'Capacitor-charged tungsten penetrators for maximum impact.',
                    fireRateMult: 0.5, // Very slow
                    damageMult: 2.2,   // Very high damage
                    specialEffect: 'armor_pierce'
                },
                {
                    id: 'kinetic_swarm',
                    name: 'KINETIC SWARM',
                    icon: 'ðŸŒªï¸',
                    cost: 160,
                    damageType: 'kinetic',
                    attackSpeed: 'very_fast',
                    targetType: 'single',
                    tradeOff: 'Rapid-fire, low individual damage',
                    desc: 'Ultra-high rate of fire with small projectiles. Excellent for overwhelming weak enemies and applying constant pressure.',
                    flavor: 'Micro-slug autoloader system for sustained fire.',
                    fireRateMult: 0.4, // Very fast (lower cooldown = faster)
                    damageMult: 0.7,   // Low damage per shot
                    specialEffect: 'rapid_fire'
                },

                // FIRE MODULES - Thermal/Burn Damage
                {
                    id: 'inferno_burst',
                    name: 'INFERNO BURST',
                    icon: 'ðŸ’¥',
                    cost: 220,
                    damageType: 'fire',
                    attackSpeed: 'slow',
                    targetType: 'area',
                    tradeOff: 'Slow charge-up, explosive area damage',
                    desc: 'Charges up explosive plasma bursts that deal heavy area damage and ignite multiple enemies. Perfect for crowd control.',
                    flavor: 'Compressed plasma chambers with magnetic containment.',
                    fireRateMult: 0.7, // Slow
                    damageMult: 1.6,   // High damage
                    specialEffect: 'area_burn'
                },
                {
                    id: 'plasma_stream',
                    name: 'PLASMA STREAM',
                    icon: 'ðŸŒž',
                    cost: 200,
                    damageType: 'fire',
                    attackSpeed: 'medium',
                    targetType: 'single',
                    tradeOff: 'Balanced fire rate with burn over time',
                    desc: 'Sustained plasma bolts that ignite targets for damage over time. Balanced option effective against most enemy types.',
                    flavor: 'Sustained fusion core with thermal dispersal matrix.',
                    fireRateMult: 1.0, // Medium speed
                    damageMult: 1.2,   // Medium damage
                    specialEffect: 'burn_dot'
                },

                // LASER MODULES - Energy/Piercing Damage
                {
                    id: 'focus_beam',
                    name: 'FOCUS BEAM',
                    icon: 'ðŸ”´',
                    cost: 240,
                    damageType: 'laser',
                    attackSpeed: 'slow',
                    targetType: 'single',
                    tradeOff: 'Charge-up required, pierces all armor',
                    desc: 'Concentrated laser beam that charges briefly then pierces through armor and shields. Devastating against heavily protected targets.',
                    flavor: 'Coherent photon lance with quantum focusing array.',
                    fireRateMult: 0.6, // Slow with charge
                    damageMult: 2.0,   // High damage
                    specialEffect: 'armor_ignore'
                },
                {
                    id: 'scatter_array',
                    name: 'SCATTER ARRAY',
                    icon: 'ðŸ’«',
                    cost: 190,
                    damageType: 'laser',
                    attackSpeed: 'fast',
                    targetType: 'multi',
                    tradeOff: 'Fast multi-target, moderate damage each',
                    desc: 'Multiple laser emitters fire simultaneously at different targets. Great for clearing groups of weaker enemies.',
                    flavor: 'Distributed aperture system with target acquisition matrix.',
                    fireRateMult: 0.8, // Fast
                    damageMult: 1.0,   // Moderate damage per beam
                    specialEffect: 'multi_target'
                },

                // LIGHTNING MODULES - Electric/Chain Damage
                {
                    id: 'arc_cannon',
                    name: 'ARC CANNON',
                    icon: 'âš¡',
                    cost: 210,
                    damageType: 'lightning',
                    attackSpeed: 'medium',
                    targetType: 'single_chain',
                    tradeOff: 'High single damage plus chain potential',
                    desc: 'Powerful electrical discharge that hits primary target hard and chains to nearby enemies. Effective against clustered foes.',
                    flavor: 'Tesla coil array with conductive targeting protocols.',
                    fireRateMult: 0.9, // Medium-slow
                    damageMult: 1.5,   // High primary damage
                    specialEffect: 'chain_lightning'
                },
                {
                    id: 'storm_grid',
                    name: 'STORM GRID',
                    icon: 'ðŸŒ©ï¸',
                    cost: 230,
                    damageType: 'lightning',
                    attackSpeed: 'fast',
                    targetType: 'area_control',
                    tradeOff: 'Continuous area damage, lower per-hit',
                    desc: 'Creates persistent electrical fields that continuously damage enemies in the area. Excellent for zone control and area denial.',
                    flavor: 'Ionospheric manipulation with sustained discharge fields.',
                    fireRateMult: 0.75, // Fast
                    damageMult: 0.9,   // Lower individual damage
                    specialEffect: 'continuous_area'
                }
            ]);

            const CHAMPION_ATTACK_MODULE_MAP = Object.freeze(Object.fromEntries(CHAMPION_ATTACK_MODULES.map(mod => [mod.id, mod])));

            const CHAMPION_CADENCE_LEVELS = Object.freeze([
                { level: 0, name: 'BASELINE CADENCE', cost: 0, fireRateMult: 1.0, dashCooldownMult: 1.0, specialCooldownMult: 1.0, desc: 'Standard guardian timing.' },
                { level: 1, name: 'PULSE SYNC', cost: 140, fireRateMult: 0.9, dashCooldownMult: 0.92, specialCooldownMult: 0.94, desc: '-10% firing delay, -8% dash cooldown. Specials rotate 6% faster.' },
                { level: 2, name: 'NOVA RHYTHM', cost: 210, fireRateMult: 0.8, dashCooldownMult: 0.86, specialCooldownMult: 0.9, desc: '-20% firing delay, -14% dash cooldown. Specials rotate 10% faster.' },
                { level: 3, name: 'TEMPORAL WARP', cost: 290, fireRateMult: 0.7, dashCooldownMult: 0.8, specialCooldownMult: 0.85, desc: '-30% firing delay, -20% dash cooldown. Specials rotate 15% faster.' }
            ]);

            const CHAMPION_MINION_PROTOCOL_LEVELS = Object.freeze([
                { level: 0, name: 'ESCORT DRONES', cost: 0, fireRateMult: 1.0, damageMult: 1.0, minionCount: 2, desc: 'Standard escort pattern.' },
                { level: 1, name: 'FLUX SENTINELS', cost: 160, fireRateMult: 0.85, damageMult: 1.12, slowFactor: 0.78, minionCount: 3, desc: 'Minions fire faster and slow targets on hit.' },
                { level: 2, name: 'SINGULARITY LANCES', cost: 230, fireRateMult: 0.75, damageMult: 1.22, novaDamageScale: 0.45, minionCount: 3, desc: 'Minion hits collapse into micro novas dealing splash damage.' }
            ]);

            const CHAMPION_MINION_ABILITY_THEMES = Object.freeze({
                default: {
                    aura: {
                        inner: 'rgba(150, 200, 255, 0.8)',
                        mid: 'rgba(80, 140, 220, 0.55)',
                        outer: 'rgba(20, 40, 80, 0)'
                    },
                    tail: {
                        start: 'rgba(25, 28, 52, 0)',
                        mid: 'rgba(70, 80, 150, 0.28)',
                        end: 'rgba(150, 160, 245, 0.72)'
                    },
                    ring: 'rgba(150, 160, 240, 0.9)',
                    swirlPrimary: 'rgba(100, 160, 255, 0.8)',
                    swirlSecondary: 'rgba(60, 120, 200, 0.65)',
                    highlight: 'rgba(140, 190, 255, 0.92)',
                    core: {
                        inner: '#f2f6ff',
                        mid: '#96b8ff',
                        outer: '#2a3c6f',
                        edge: '#162138'
                    },
                    thruster: {
                        inner: 'rgba(120, 180, 255, 0.85)',
                        outer: 'rgba(40, 80, 160, 0)'
                    },
                    trail: '#4362a8',
                    spark: '#c7d3ff'
                },
                ember: {
                    aura: {
                        inner: 'rgba(255, 190, 120, 0.82)',
                        mid: 'rgba(255, 110, 40, 0.6)',
                        outer: 'rgba(60, 18, 0, 0)'
                    },
                    tail: {
                        start: 'rgba(75, 18, 0, 0)',
                        mid: 'rgba(255, 120, 45, 0.35)',
                        end: 'rgba(255, 215, 140, 0.82)'
                    },
                    ring: 'rgba(255, 205, 135, 0.92)',
                    swirlPrimary: 'rgba(255, 170, 90, 0.82)',
                    swirlSecondary: 'rgba(255, 120, 40, 0.66)',
                    highlight: 'rgba(255, 200, 120, 0.94)',
                    core: {
                        inner: '#fff3c4',
                        mid: '#ffb347',
                        outer: '#5a1b0a',
                        edge: '#3a0d05'
                    },
                    thruster: {
                        inner: 'rgba(255, 185, 105, 0.88)',
                        outer: 'rgba(90, 20, 0, 0)'
                    },
                    trail: '#b6451a',
                    spark: '#ffe2b2'
                },
                tempest: {
                    aura: {
                        inner: 'rgba(120, 235, 255, 0.8)',
                        mid: 'rgba(45, 160, 220, 0.58)',
                        outer: 'rgba(5, 35, 60, 0)'
                    },
                    tail: {
                        start: 'rgba(8, 30, 52, 0)',
                        mid: 'rgba(60, 185, 240, 0.36)',
                        end: 'rgba(180, 250, 255, 0.84)'
                    },
                    ring: 'rgba(120, 210, 255, 0.9)',
                    swirlPrimary: 'rgba(90, 220, 255, 0.82)',
                    swirlSecondary: 'rgba(60, 160, 220, 0.64)',
                    highlight: 'rgba(150, 240, 255, 0.92)',
                    core: {
                        inner: '#e3feff',
                        mid: '#6ed8ff',
                        outer: '#0f344a',
                        edge: '#082330'
                    },
                    thruster: {
                        inner: 'rgba(115, 230, 255, 0.9)',
                        outer: 'rgba(10, 80, 120, 0)'
                    },
                    trail: '#1b6a92',
                    spark: '#d6faff'
                },
                void: {
                    aura: {
                        inner: 'rgba(205, 165, 255, 0.8)',
                        mid: 'rgba(120, 60, 200, 0.58)',
                        outer: 'rgba(25, 5, 45, 0)'
                    },
                    tail: {
                        start: 'rgba(22, 6, 40, 0)',
                        mid: 'rgba(140, 70, 220, 0.32)',
                        end: 'rgba(230, 190, 255, 0.85)'
                    },
                    ring: 'rgba(210, 170, 255, 0.94)',
                    swirlPrimary: 'rgba(190, 120, 255, 0.84)',
                    swirlSecondary: 'rgba(140, 80, 220, 0.68)',
                    highlight: 'rgba(215, 185, 255, 0.93)',
                    core: {
                        inner: '#f2e8ff',
                        mid: '#b088ff',
                        outer: '#2c1546',
                        edge: '#1b0a2d'
                    },
                    thruster: {
                        inner: 'rgba(200, 140, 255, 0.9)',
                        outer: 'rgba(40, 10, 70, 0)'
                    },
                    trail: '#4e2c7a',
                    spark: '#f0daff'
                }
            });

            const CHAMPION_SKIN_THEMES = Object.freeze({
                default: {
                    key: 'default',
                    label: 'Void Vanguard',
                    body: {
                        top: '#2a3560',
                        mid: '#1e2845',
                        bottom: '#3c4f78',
                        outline: '#6090d0',
                        interior: '#1a2440',
                        accent: '#6090d0'
                    },
                    visor: {
                        left: 'rgba(80, 150, 255, 0.85)',
                        center: 'rgba(120, 180, 255, 0.95)',
                        right: 'rgba(60, 120, 200, 0.8)'
                    },
                    aura: {
                        inner: 'rgba(120, 180, 255, 0.25)',
                        mid: 'rgba(45, 85, 160, 0.5)',
                        outer: 'rgba(15, 25, 65, 0)'
                    },
                    trail: '#78b4ff',
                    bullet: 'rgba(162, 170, 255, 0.94)',
                    bulletPierce: 'rgba(205, 210, 255, 0.96)',
                    minion: {
                        core: '#bcd4ff',
                        aura: '#82a7ff',
                        trail: '#4362a8'
                    }
                },
                solstice: {
                    key: 'solstice',
                    label: 'Solstice Radiant',
                    body: {
                        top: '#6f2c0e',
                        mid: '#b34913',
                        bottom: '#ffb347',
                        outline: '#ffd37f',
                        interior: '#532913',
                        accent: '#ffcc7a'
                    },
                    visor: {
                        left: 'rgba(255, 220, 125, 0.9)',
                        center: 'rgba(255, 244, 190, 0.96)',
                        right: 'rgba(255, 196, 110, 0.85)'
                    },
                    aura: {
                        inner: 'rgba(255, 185, 120, 0.3)',
                        mid: 'rgba(255, 135, 60, 0.55)',
                        outer: 'rgba(80, 30, 0, 0)'
                    },
                    trail: '#ffbd63',
                    bullet: 'rgba(255, 176, 88, 0.96)',
                    bulletPierce: 'rgba(255, 214, 140, 0.98)',
                    minion: {
                        core: '#ffd37f',
                        aura: '#ff9f54',
                        trail: '#c86b1c'
                    }
                },
                tempest: {
                    key: 'tempest',
                    label: 'Tempest Breaker',
                    body: {
                        top: '#10506d',
                        mid: '#0c3b53',
                        bottom: '#1a7794',
                        outline: '#6ad1ff',
                        interior: '#082c3f',
                        accent: '#42c6ff'
                    },
                    visor: {
                        left: 'rgba(150, 240, 255, 0.9)',
                        center: 'rgba(210, 255, 255, 0.96)',
                        right: 'rgba(110, 210, 255, 0.88)'
                    },
                    aura: {
                        inner: 'rgba(90, 200, 255, 0.3)',
                        mid: 'rgba(35, 120, 200, 0.55)',
                        outer: 'rgba(8, 30, 60, 0)'
                    },
                    trail: '#54d8ff',
                    bullet: 'rgba(140, 230, 255, 0.96)',
                    bulletPierce: 'rgba(200, 250, 255, 0.98)',
                    minion: {
                        core: '#aef0ff',
                        aura: '#5cd4ff',
                        trail: '#1b6a92'
                    }
                },
                aurora: {
                    key: 'aurora',
                    label: 'Aurora Helix',
                    body: {
                        top: '#1d2c66',
                        mid: '#243a85',
                        bottom: '#3b64b8',
                        outline: '#9fdfff',
                        interior: '#142046',
                        accent: '#8ff4ff'
                    },
                    visor: {
                        left: 'rgba(120, 220, 255, 0.9)',
                        center: 'rgba(200, 240, 255, 0.96)',
                        right: 'rgba(255, 180, 240, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(120, 220, 255, 0.28)',
                        mid: 'rgba(180, 140, 255, 0.45)',
                        outer: 'rgba(30, 40, 90, 0)'
                    },
                    trail: '#8fe7ff',
                    bullet: 'rgba(180, 235, 255, 0.96)',
                    bulletPierce: 'rgba(225, 250, 255, 0.98)',
                    minion: {
                        core: '#d0f6ff',
                        aura: '#8ec2ff',
                        trail: '#3d6fb4'
                    }
                },
                bastion: {
                    key: 'bastion',
                    label: 'Obsidian Bastion',
                    body: {
                        top: '#1b1f2a',
                        mid: '#141720',
                        bottom: '#343746',
                        outline: '#ff9160',
                        interior: '#0a0d16',
                        accent: '#ffb27a'
                    },
                    visor: {
                        left: 'rgba(255, 150, 90, 0.92)',
                        center: 'rgba(255, 190, 130, 0.95)',
                        right: 'rgba(255, 120, 80, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(255, 150, 90, 0.26)',
                        mid: 'rgba(255, 100, 70, 0.38)',
                        outer: 'rgba(40, 20, 10, 0)'
                    },
                    trail: '#ff8654',
                    bullet: 'rgba(255, 168, 120, 0.96)',
                    bulletPierce: 'rgba(255, 210, 180, 0.98)',
                    minion: {
                        core: '#ffd0b5',
                        aura: '#ff976a',
                        trail: '#703a24'
                    }
                },
                umbra: {
                    key: 'umbra',
                    label: 'Umbral Regent',
                    body: {
                        top: '#301554',
                        mid: '#1f0f37',
                        bottom: '#5b2f8f',
                        outline: '#c29bff',
                        interior: '#160b25',
                        accent: '#a378ff'
                    },
                    visor: {
                        left: 'rgba(200, 160, 255, 0.92)',
                        center: 'rgba(235, 210, 255, 0.97)',
                        right: 'rgba(160, 110, 255, 0.88)'
                    },
                    aura: {
                        inner: 'rgba(190, 150, 255, 0.32)',
                        mid: 'rgba(120, 60, 200, 0.58)',
                        outer: 'rgba(40, 10, 90, 0)'
                    },
                    trail: '#b080ff',
                    bullet: 'rgba(200, 160, 255, 0.96)',
                    bulletPierce: 'rgba(235, 210, 255, 0.98)',
                    minion: {
                        core: '#d5c0ff',
                        aura: '#a070ff',
                        trail: '#4e2c7a'
                    }
                },
                blackgold: {
                    key: 'blackgold',
                    label: 'Black Gold Dynasty',
                    body: {
                        top: '#0a0a0c',
                        mid: '#121214',
                        bottom: '#1a1a1c',
                        outline: '#d4af37',
                        interior: '#060608',
                        accent: '#ffd700'
                    },
                    visor: {
                        left: 'rgba(255, 215, 0, 0.95)',
                        center: 'rgba(255, 235, 100, 0.98)',
                        right: 'rgba(212, 175, 55, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(255, 215, 0, 0.35)',
                        mid: 'rgba(180, 130, 30, 0.65)',
                        outer: 'rgba(30, 25, 5, 0)'
                    },
                    trail: '#ffd700',
                    bullet: 'rgba(255, 215, 0, 0.97)',
                    bulletPierce: 'rgba(255, 240, 120, 0.99)',
                    minion: {
                        core: '#ffe87c',
                        aura: '#d4af37',
                        trail: '#8b7355'
                    }
                },
                crimsonhex: {
                    key: 'crimsonhex',
                    label: 'Crimson Hex Protocol',
                    body: {
                        top: '#8b0000',
                        mid: '#5c0000',
                        bottom: '#b71c1c',
                        outline: '#ff1744',
                        interior: '#3d0000',
                        accent: '#ff5252'
                    },
                    visor: {
                        left: 'rgba(255, 23, 68, 0.94)',
                        center: 'rgba(255, 82, 82, 0.98)',
                        right: 'rgba(198, 40, 40, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(255, 23, 68, 0.38)',
                        mid: 'rgba(183, 28, 28, 0.68)',
                        outer: 'rgba(40, 0, 0, 0)'
                    },
                    trail: '#ff1744',
                    bullet: 'rgba(255, 23, 68, 0.97)',
                    bulletPierce: 'rgba(255, 82, 82, 0.99)',
                    minion: {
                        core: '#ff5252',
                        aura: '#ff1744',
                        trail: '#7f0000'
                    }
                },
                prismrift: {
                    key: 'prismrift',
                    label: 'Prismatic Rift Walker',
                    body: {
                        top: '#00d4ff',
                        mid: '#00bfa5',
                        bottom: '#69f0ae',
                        outline: '#b2ff59',
                        interior: '#004d40',
                        accent: '#64ffda'
                    },
                    visor: {
                        left: 'rgba(0, 191, 165, 0.94)',
                        center: 'rgba(100, 255, 218, 0.98)',
                        right: 'rgba(178, 255, 89, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(0, 212, 255, 0.36)',
                        mid: 'rgba(0, 191, 165, 0.62)',
                        outer: 'rgba(0, 40, 35, 0)'
                    },
                    trail: '#64ffda',
                    bullet: 'rgba(100, 255, 218, 0.97)',
                    bulletPierce: 'rgba(178, 255, 89, 0.99)',
                    minion: {
                        core: '#b2ff59',
                        aura: '#64ffda',
                        trail: '#00897b'
                    }
                },
                ghostflame: {
                    key: 'ghostflame',
                    label: 'Ghost Flame Specter',
                    body: {
                        top: '#1de9b6',
                        mid: '#00c9a7',
                        bottom: '#69f0ae',
                        outline: '#00e5ff',
                        interior: '#004d40',
                        accent: '#18ffff'
                    },
                    visor: {
                        left: 'rgba(0, 229, 255, 0.95)',
                        center: 'rgba(29, 233, 182, 0.98)',
                        right: 'rgba(24, 255, 255, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(29, 233, 182, 0.42)',
                        mid: 'rgba(0, 229, 255, 0.7)',
                        outer: 'rgba(0, 60, 50, 0)'
                    },
                    trail: '#18ffff',
                    bullet: 'rgba(24, 255, 255, 0.97)',
                    bulletPierce: 'rgba(29, 233, 182, 0.99)',
                    minion: {
                        core: '#00e5ff',
                        aura: '#1de9b6',
                        trail: '#00695c'
                    }
                },
                voidcrystal: {
                    key: 'voidcrystal',
                    label: 'Void Crystal Architect',
                    body: {
                        top: '#4a148c',
                        mid: '#6a1b9a',
                        bottom: '#8e24aa',
                        outline: '#e040fb',
                        interior: '#311b92',
                        accent: '#d500f9'
                    },
                    visor: {
                        left: 'rgba(213, 0, 249, 0.94)',
                        center: 'rgba(224, 64, 251, 0.98)',
                        right: 'rgba(170, 0, 255, 0.9)'
                    },
                    aura: {
                        inner: 'rgba(224, 64, 251, 0.4)',
                        mid: 'rgba(142, 36, 170, 0.72)',
                        outer: 'rgba(40, 10, 70, 0)'
                    },
                    trail: '#e040fb',
                    bullet: 'rgba(224, 64, 251, 0.97)',
                    bulletPierce: 'rgba(213, 0, 249, 0.99)',
                    minion: {
                        core: '#e1bee7',
                        aura: '#d500f9',
                        trail: '#4a148c'
                    }
                },
                chromestrike: {
                    key: 'chromestrike',
                    label: 'Chrome Strike Edition',
                    body: {
                        top: '#b0bec5',
                        mid: '#90a4ae',
                        bottom: '#cfd8dc',
                        outline: '#00e5ff',
                        interior: '#607d8b',
                        accent: '#80d8ff'
                    },
                    visor: {
                        left: 'rgba(0, 229, 255, 0.96)',
                        center: 'rgba(128, 216, 255, 0.98)',
                        right: 'rgba(224, 247, 250, 0.94)'
                    },
                    aura: {
                        inner: 'rgba(176, 190, 197, 0.38)',
                        mid: 'rgba(96, 125, 139, 0.65)',
                        outer: 'rgba(30, 40, 50, 0)'
                    },
                    trail: '#80d8ff',
                    bullet: 'rgba(128, 216, 255, 0.97)',
                    bulletPierce: 'rgba(224, 247, 250, 0.99)',
                    minion: {
                        core: '#e0f7fa',
                        aura: '#80d8ff',
                        trail: '#455a64'
                    }
                },
                infernalcore: {
                    key: 'infernalcore',
                    label: 'Infernal Core Juggernaut',
                    body: {
                        top: '#ff3d00',
                        mid: '#bf360c',
                        bottom: '#ff6e40',
                        outline: '#ffab40',
                        interior: '#6d1b00',
                        accent: '#ff9e80'
                    },
                    visor: {
                        left: 'rgba(255, 171, 64, 0.95)',
                        center: 'rgba(255, 158, 128, 0.98)',
                        right: 'rgba(255, 61, 0, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(255, 61, 0, 0.44)',
                        mid: 'rgba(191, 54, 12, 0.76)',
                        outer: 'rgba(60, 15, 0, 0)'
                    },
                    trail: '#ff6e40',
                    bullet: 'rgba(255, 158, 128, 0.97)',
                    bulletPierce: 'rgba(255, 171, 64, 0.99)',
                    minion: {
                        core: '#ffccbc',
                        aura: '#ff6e40',
                        trail: '#bf360c'
                    }
                },
                glacialwarden: {
                    key: 'glacialwarden',
                    label: 'Glacial Warden Sovereign',
                    body: {
                        top: '#0277bd',
                        mid: '#01579b',
                        bottom: '#039be5',
                        outline: '#00b8d4',
                        interior: '#004d73',
                        accent: '#00e5ff'
                    },
                    visor: {
                        left: 'rgba(0, 184, 212, 0.95)',
                        center: 'rgba(0, 229, 255, 0.98)',
                        right: 'rgba(129, 212, 250, 0.92)'
                    },
                    aura: {
                        inner: 'rgba(0, 229, 255, 0.4)',
                        mid: 'rgba(2, 119, 189, 0.7)',
                        outer: 'rgba(0, 30, 60, 0)'
                    },
                    trail: '#00b8d4',
                    bullet: 'rgba(0, 229, 255, 0.97)',
                    bulletPierce: 'rgba(129, 212, 250, 0.99)',
                    minion: {
                        core: '#b3e5fc',
                        aura: '#00b8d4',
                        trail: '#01579b'
                    }
                }
            });

            const CHAMPION_PREVIEW_PROFILES = Object.freeze({
                default: {
                    title: 'Shadow Guardian',
                    classLabel: 'Adaptive Void Sentinel',
                    signature: 'Void harmonics auto-adjust to pilot focus.',
                    icon: 'ðŸ’ ',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Fires a staggered spray of plasma bolts that home on the championâ€™s focus target.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Marks a priority enemy, searing them over time while exposing weak points.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Detonates a short-lived gravity bloom that batters clustered threats.' },
                        { id: 'crescent_ricochet', name: 'Crescent Ricochet', icon: 'ðŸŒ€', description: 'Arcing lances ricochet between up to three close targets.' },
                        { id: 'dash', name: 'Shadow Dash', icon: 'ðŸ’¨', description: 'Short-range blink that phases through threats.' }
                    ],
                    previewEffects: {
                        attack: 'core-flare',
                        special: 'void-rings'
                    }
                },
                beef: {
                    title: 'Shadow Guardian',
                    classLabel: 'Titan Vanguard',
                    signature: 'Armored spearhead that mirrors Juggernaut aggression.',
                    icon: 'ðŸ›¡ï¸',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Heavy plasma bolts stagger foes at medium range.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Marks armored targets to soften them for the next charge.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Blast wave that thins out packs before the titan dives in.' },
                        { id: 'charge', name: 'Titan Charge', icon: 'ðŸ’¥', description: 'Accelerates and slams through clustered targets.' }
                    ],
                    previewEffects: {
                        attack: 'shockwave',
                        special: 'overdrive'
                    }
                },
                rocketman: {
                    title: 'Shadow Guardian',
                    classLabel: 'Aerial Artillery',
                    signature: 'Guided ordnance suite pairs with stealth rocket arrays.',
                    icon: 'ðŸš€',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Rotating salvo keeps targets painted between missile strikes.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Sustained burn keeps high-value targets lit for follow-up rockets.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Area blast softens clustered enemies for stealth rockets.' },
                        { id: 'crescent_ricochet', name: 'Crescent Ricochet', icon: 'ðŸŒ€', description: 'Guided arcs pick off stragglers during reload cycles.' }
                    ],
                    previewEffects: {
                        attack: 'rocket-trail',
                        special: 'missile-burst'
                    }
                },
                voidmancer: {
                    title: 'Shadow Guardian',
                    classLabel: 'Void Arcanist',
                    signature: 'Conducts stormlight and void lasers in alternating cadence.',
                    icon: 'âš¡',
                    abilityHighlights: [
                        { id: 'starfall_salvo', name: 'Starfall Salvo', icon: 'âœ¨', description: 'Void-aligned bolts extend the pilotâ€™s pressure window.' },
                        { id: 'solar_brand', name: 'Solar Brand', icon: 'â˜€ï¸', description: 'Infuses enemies with stormlight for damage over time.' },
                        { id: 'nebula_bloom', name: 'Nebula Bloom', icon: 'ðŸŒŒ', description: 'Micro-singularity tears through clustered foes.' },
                        { id: 'crescent_ricochet', name: 'Crescent Ricochet', icon: 'ðŸŒ€', description: 'Half-cycle pulses chain through nearby targets.' },
                        { id: 'dash', name: 'Shadow Dash', icon: 'ðŸ’¨', description: 'Blink strike shreds armor during phase transitions.' }
                    ],
                    previewEffects: {
                        attack: 'lightning-arc',
                        special: 'laser-sweep'
                    }
                }
            });

            const CHAMPION_COMBAT_BLUEPRINT = Object.freeze({
                primary: Object.freeze({
                    id: 'starfall_salvo',
                    name: 'Starfall Salvo',
                    icon: 'âœ¨',
                    cadence: 'steady',
                    targeting: 'single',
                    description: 'A quick three-to-five bolt spray that stays on the championâ€™s current target.',
                    baseCooldown: 0.7,
                    jitter: [0.06, 0.12],
                    execute: championFireStarfallSalvo
                }),
                specials: Object.freeze([
                    Object.freeze({
                        id: 'solar_brand',
                        name: 'Solar Brand',
                        icon: 'â˜€ï¸',
                        cadence: 'damage-over-time',
                        targeting: 'single',
                        baseCooldown: 7.5,
                        initialDelay: 2.5,
                        priority: 4,
                        minTargets: 1,
                        vulnerabilities: { default: 1, boss: 1.12, armored: 1.15, swarm: 0.9 },
                        execute: championExecuteSolarBrand
                    }),
                    Object.freeze({
                        id: 'nebula_bloom',
                        name: 'Nebula Bloom',
                        icon: 'ðŸŒŒ',
                        cadence: 'burst',
                        targeting: 'aoe',
                        baseCooldown: 11,
                        initialDelay: 4.8,
                        priority: 5,
                        minNearby: 3,
                        radius: 165,
                        vulnerabilities: { default: 1, swarm: 1.2, nimble: 1.08, armored: 0.9 },
                        execute: championExecuteNebulaBloom
                    }),
                    Object.freeze({
                        id: 'crescent_ricochet',
                        name: 'Crescent Ricochet',
                        icon: 'ðŸŒ€',
                        cadence: 'half-cycle',
                        targeting: 'multi',
                        baseCooldown: 4.6,
                        initialDelay: 1.8,
                        priority: 3,
                        maxTargets: 3,
                        searchRadius: 240,
                        vulnerabilities: { default: 1, nimble: 1.12, swarm: 1.05, boss: 0.95 },
                        execute: championExecuteCrescentRicochet
                    })
                ])
            });

            const CHAMPION_COMBAT_SUMMARY = Object.freeze([
                {
                    id: 'starfall_salvo',
                    name: 'Starfall Salvo',
                    icon: 'âœ¨',
                    cadence: 'Steady primary attack',
                    targeting: 'Single target',
                    description: 'Fires a staggered spray of plasma bolts that track the championâ€™s focus.'
                },
                {
                    id: 'solar_brand',
                    name: 'Solar Brand',
                    icon: 'â˜€ï¸',
                    cadence: 'Timed burn',
                    targeting: 'Single target',
                    description: 'Brands an enemy with radiant fire, dealing a burst of damage followed by damage over time. Strong against armored units.'
                },
                {
                    id: 'nebula_bloom',
                    name: 'Nebula Bloom',
                    icon: 'ðŸŒŒ',
                    cadence: 'Burst detonation',
                    targeting: 'Area of effect',
                    description: 'Collapses a gravity bloom that batters clustered enemies. Excels at clearing swarms.'
                },
                {
                    id: 'crescent_ricochet',
                    name: 'Crescent Ricochet',
                    icon: 'ðŸŒ€',
                    cadence: 'Half-cycle strike',
                    targeting: 'Capped multi-target (3)',
                    description: 'Arc blades ricochet between up to three nearby foes, prioritising nimble threats.'
                }
            ]);

            function cloneChampionAbility(ability) {
                if (!ability) return null;
                return {
                    ...ability,
                    _baseCooldown: ability.baseCooldown,
                    timer: ability.initialDelay != null ? ability.initialDelay : ability.baseCooldown
                };
            }

            function createChampionCombatProfile(overrides = {}) {
                const primaryBlueprint = CHAMPION_COMBAT_BLUEPRINT.primary || {};
                const primary = {
                    ...primaryBlueprint,
                    _baseCooldown: primaryBlueprint.baseCooldown
                };
                const specials = (CHAMPION_COMBAT_BLUEPRINT.specials || []).map(cloneChampionAbility);
                return {
                    primary,
                    specials,
                    specialCooldownMult: overrides.specialCooldownMult ?? 1,
                    lastAbilityId: null
                };
            }

            function ensureChampionCombatProfile(champion, overrides = {}) {
                if (!champion) return null;
                if (!champion.combatProfile) {
                    champion.combatProfile = createChampionCombatProfile(overrides);
                }
                return champion.combatProfile;
            }

            function configureChampionCombatProfile(champion, cadenceOption = null) {
                const profile = ensureChampionCombatProfile(champion);
                if (!profile) return null;

                const cadenceMult = cadenceOption?.specialCooldownMult ?? profile.specialCooldownMult ?? 1;
                const previousMult = profile.specialCooldownMult ?? 1;
                profile.specialCooldownMult = cadenceMult;

                if (profile.primary) {
                    const base = champion.fireCooldown ?? profile.primary.baseCooldown ?? profile.primary._baseCooldown ?? PLAYER_CHAMPION_CONFIG.baseFireCooldown;
                    profile.primary.baseCooldown = base;
                }

                if (Array.isArray(profile.specials)) {
                    profile.specials.forEach(special => {
                        if (!special) return;
                        const base = special._baseCooldown ?? special.baseCooldown ?? 1;
                        special.baseCooldown = base;
                        if (special.timer != null) {
                            if (previousMult !== cadenceMult && special.timer > 0) {
                                const normalized = special.timer / Math.max(0.0001, previousMult);
                                special.timer = Math.min(normalized * cadenceMult, base * cadenceMult);
                            } else {
                                special.timer = Math.min(special.timer, base * cadenceMult);
                            }
                        } else {
                            special.timer = base * cadenceMult;
                        }
                    });
                }

                return profile;
            }

            function classifyEnemyForChampionVulnerabilities(enemy) {
                const tags = new Set();
                if (!enemy) return tags;

                const hpMax = ensureFiniteNumber(enemy.hpMax ?? enemy.maxHp ?? enemy.hp ?? 0, 0);
                const radius = ensureFiniteNumber(enemy.r ?? enemy.radius ?? 0, 0);
                const shield = ensureFiniteNumber(enemy.shield ?? enemy.shieldHp ?? 0, 0);
                const speed = ensureFiniteNumber(enemy.speed ?? enemy.baseSpeed ?? enemy.moveSpeed ?? 0, 0);

                if (enemy === store.boss) {
                    tags.add('boss');
                    tags.add('armored');
                }

                if (hpMax >= 900 || radius >= 34) tags.add('behemoth');
                if (hpMax >= 600 || radius >= 28) tags.add('armored');
                else if (hpMax >= 280 || radius >= 22) tags.add('elite');
                if (hpMax <= 120 || radius <= 14) tags.add('swarm');

                const vx = ensureFiniteNumber(enemy.vx ?? enemy.hvx ?? 0, 0);
                const vy = ensureFiniteNumber(enemy.vy ?? enemy.hvy ?? 0, 0);
                if (speed >= 260 || (vx * vx + vy * vy) > 260 * 260) tags.add('nimble');
                if (shield > 0 || enemy.shielded) tags.add('shielded');
                if (enemy.spawnGroupSize >= 4) tags.add('pack');
                if (enemy.isFlying || enemy.flying || enemy.flight) tags.add('air');

                return tags;
            }

            function applyChampionVulnerabilityScaling(baseDamage, enemy, profile) {
                if (!CHAMPION_SYSTEM_ENABLED) return baseDamage;
                if (!profile || baseDamage <= 0) return baseDamage;
                const tags = classifyEnemyForChampionVulnerabilities(enemy);
                const map = profile.tags || profile;
                let multiplier = typeof map.default === 'number' ? map.default : 1;

                tags.forEach(tag => {
                    if (typeof map[tag] === 'number') {
                        multiplier *= map[tag];
                    }
                });

                let result = baseDamage * multiplier;
                if (typeof profile.floor === 'number') {
                    result = Math.max(profile.floor, result);
                }
                if (typeof profile.ceiling === 'number') {
                    result = Math.min(profile.ceiling, result);
                }
                return result;
            }

            function countEnemiesAround(x, y, radius, { includeBoss = true } = {}) {
                let count = 0;
                forEachEnemyNearby(x, y, radius, enemy => {
                    if (!enemy || enemy.dead || enemy.hp <= 0) return false;
                    count++;
                    return false;
                });

                if (includeBoss && store.boss && !store.boss.dead) {
                    const boss = store.boss;
                    const dx = boss.x - x;
                    const dy = boss.y - y;
                    const bossRadius = radius + (boss.r || 60);
                    if (dx * dx + dy * dy <= bossRadius * bossRadius) {
                        count++;
                    }
                }

                return count;
            }

            function selectChampionSpecialAbility(champion, target, context = {}) {
                if (!champion || !champion.combatProfile) return null;
                const { combatProfile } = champion;
                if (!combatProfile.specials || combatProfile.specials.length === 0) return null;

                const targetTraits = context.targetTraits || classifyEnemyForChampionVulnerabilities(target);
                const nearbyCount = context.nearbyCount ?? (target ? countEnemiesAround(target.x, target.y, context.scanRadius || 220) : 0);
                let best = null;
                let bestScore = -Infinity;

                combatProfile.specials.forEach(special => {
                    if (!special || special.timer > 0) return;
                    if (special.targeting === 'single' && !target) return;

                    const minTargets = special.minTargets ?? 0;
                    if (minTargets > 0 && nearbyCount < minTargets) return;

                    let score = special.priority ?? 0;

                    if (special.targeting === 'aoe') {
                        const required = special.minNearby ?? 3;
                        const densityBonus = Math.max(0, nearbyCount - required + 1);
                        score += densityBonus * 1.2;
                    } else if (special.targeting === 'multi') {
                        const hits = Math.min(special.maxTargets ?? 3, Math.max(nearbyCount, target ? 1 : 0));
                        score += hits * 0.9;
                    } else if (special.targeting === 'single') {
                        if (targetTraits.has('boss') || targetTraits.has('armored')) score += 2.8;
                        if (targetTraits.has('nimble')) score += 0.6;
                    }

                    if (combatProfile.lastAbilityId && combatProfile.lastAbilityId === special.id) {
                        score -= 0.5; // discourage repeating the same special immediately
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        best = special;
                    }
                });

                return best;
            }

            function executeChampionAbility(champion, ability, context = {}) {
                if (!champion || !ability || typeof ability.execute !== 'function') return null;
                const profile = ensureChampionCombatProfile(champion);
                const cadenceMult = profile?.specialCooldownMult ?? 1;
                const baseCooldown = ability._baseCooldown ?? ability.baseCooldown ?? 1.2;

                const result = ability.execute(champion, {
                    ...context,
                    ability,
                    vulnerabilityProfile: ability.vulnerabilities || null,
                    cadenceMult
                }) || {};

                const cooldown = (typeof result.cooldown === 'number' ? result.cooldown : baseCooldown) * cadenceMult;
                ability.timer = cooldown;
                profile.lastAbilityId = ability.id;

                const baseDelay = typeof result.fireTimer === 'number' ? result.fireTimer : (ability.postFireDelay ?? champion.fireCooldown ?? baseCooldown);
                const jitterRange = result.jitterRange || ability.jitter || [0.05, 0.11];
                let jitter = 0;
                if (typeof result.jitter === 'number') {
                    jitter = result.jitter;
                } else if (Array.isArray(jitterRange)) {
                    const [min = 0, max = 0] = jitterRange;
                    jitter = min + Math.random() * Math.max(0, max - min);
                } else if (typeof jitterRange === 'number') {
                    jitter = jitterRange;
                }

                champion.fireTimer = Math.max(0.2, baseDelay + jitter);
                return result;
            }

            function executeChampionPrimary(champion, target, context = {}) {
                if (!champion) return null;
                const profile = ensureChampionCombatProfile(champion);
                if (!profile || !profile.primary || typeof profile.primary.execute !== 'function') return null;

                const primary = profile.primary;
                const baseDelay = champion.fireCooldown ?? primary.baseCooldown ?? PLAYER_CHAMPION_CONFIG.baseFireCooldown;
                const result = primary.execute(champion, {
                    ...context,
                    target,
                    ability: primary,
                    vulnerabilityProfile: primary.vulnerabilities || null
                }) || {};

                const jitterRange = result.jitterRange || primary.jitter || [0.06, 0.12];
                let jitter = 0;
                if (typeof result.jitter === 'number') {
                    jitter = result.jitter;
                } else if (Array.isArray(jitterRange)) {
                    const [min = 0, max = 0] = jitterRange;
                    jitter = min + Math.random() * Math.max(0, max - min);
                } else if (typeof jitterRange === 'number') {
                    jitter = jitterRange;
                }

                const nextDelay = typeof result.fireTimer === 'number' ? result.fireTimer : baseDelay;
                champion.fireTimer = Math.max(0.2, nextDelay + jitter);
                profile.lastAbilityId = primary.id;
                return result;
            }

            const CHAMPION_SKIN_OPTIONS = Object.freeze([
                { id: 'default', name: 'Void Vanguard', icon: 'ðŸ’ ', cost: 0, desc: 'Baseline guardian plating.', theme: 'default' },
                { id: 'solstice', name: 'Solstice Radiant', icon: 'ðŸŒž', cost: 120, desc: 'Gilded solar alloys with ember trails.', theme: 'solstice' },
                { id: 'tempest', name: 'Tempest Breaker', icon: 'ðŸŒ©ï¸', cost: 120, desc: 'Ionized teal plating that crackles with stormlight.', theme: 'tempest' },
                { id: 'aurora', name: 'Aurora Helix', icon: 'ðŸŒŒ', cost: 140, desc: 'Prismatic plating braided from polar light flows.', theme: 'aurora' },
                { id: 'bastion', name: 'Obsidian Bastion', icon: 'ðŸ›¡ï¸', cost: 180, desc: 'Heavy dusk armor with molten core vents.', theme: 'bastion' },
                { id: 'umbra', name: 'Umbral Regent', icon: 'ðŸŒ‘', cost: 150, desc: 'Abyssal crystal armor forged from void echoes.', theme: 'umbra' },
                { id: 'blackgold', name: 'Black Gold Dynasty', icon: 'ðŸ‘‘', cost: 250, desc: 'Obsidian chassis inlaid with 24K quantum gold tracery.', theme: 'blackgold' },
                { id: 'crimsonhex', name: 'Crimson Hex Protocol', icon: 'â¬¢', cost: 200, desc: 'Crimson war-forged armor with hexagonal energy matrices.', theme: 'crimsonhex' },
                { id: 'prismrift', name: 'Prismatic Rift Walker', icon: 'ðŸŒˆ', cost: 220, desc: 'Reality-bending chrome that shifts through the spectrum.', theme: 'prismrift' },
                { id: 'ghostflame', name: 'Ghost Flame Specter', icon: 'ðŸ‘»', cost: 240, desc: 'Spectral cyan plating wreathed in ethereal ghost fire.', theme: 'ghostflame' },
                { id: 'voidcrystal', name: 'Void Crystal Architect', icon: 'ðŸ’Ž', cost: 260, desc: 'Crystalline void lattice forged from dimensional fractures.', theme: 'voidcrystal' },
                { id: 'chromestrike', name: 'Chrome Strike Edition', icon: 'âš¡', cost: 280, desc: 'Mirror-finish chromium with electric cyan highlights.', theme: 'chromestrike' },
                { id: 'infernalcore', name: 'Infernal Core Juggernaut', icon: 'ðŸ”¥', cost: 300, desc: 'Molten core reactor armor bleeding thermal death glow.', theme: 'infernalcore' },
                { id: 'glacialwarden', name: 'Glacial Warden Sovereign', icon: 'â„ï¸', cost: 220, desc: 'Frost-forged adamant plates radiating absolute zero.', theme: 'glacialwarden' }
            ]);

            const CHAMPION_SKIN_OPTION_MAP = Object.freeze(Object.fromEntries(CHAMPION_SKIN_OPTIONS.map(s => [s.id, s])));

            const CHAMPION_PRESET_SCHEMA_VERSION = 1;
            const CHAMPION_PRESET_MODULE_IDS = Object.freeze([
                'precision_strike',
                'kinetic_swarm',
                'inferno_burst',
                'plasma_stream',
                'focus_beam',
                'scatter_array',
                'arc_cannon',
                'storm_grid',
                'ember',
                'tempest',
                'void'
            ]);
            const CHAMPION_PRESET_MODULE_CHOICES = Object.freeze(['default', ...CHAMPION_PRESET_MODULE_IDS]);
            const CHAMPION_PRESET_SKIN_IDS = Object.freeze(CHAMPION_SKIN_OPTIONS.map(opt => opt.id));
            const CHAMPION_PRESET_UPGRADE_KEYS = Object.freeze([
                'champion_health',
                'champion_damage',
                'champion_speed',
                'champion_shield',
                'champion_regen'
            ]);

            function captureChampionPreset(player = store.player) {
                if (!player) return null;
                const upgrades = ensureChampionUpgradeState(player);
                const upgradeLevels = player.upgradeLevels || {};
                const champion = store.playerChampion && !store.playerChampion.dead ? store.playerChampion : null;

                const unlockedModules = CHAMPION_PRESET_MODULE_IDS.filter(id => upgrades?.unlockedAttacks && upgrades.unlockedAttacks[id]);
                const unlockedSkins = CHAMPION_PRESET_SKIN_IDS.filter(id => upgrades?.unlockedSkins && upgrades.unlockedSkins[id]);
                if (!unlockedSkins.includes('default')) unlockedSkins.push('default');

                const levelSnapshot = {};
                CHAMPION_PRESET_UPGRADE_KEYS.forEach(key => {
                    const value = upgradeLevels[key] || 0;
                    if (value > 0) {
                        levelSnapshot[key] = value;
                    }
                });

                return {
                    version: CHAMPION_PRESET_SCHEMA_VERSION,
                    championUnlocked: !!player.championUnlocked,
                    attackModule: upgrades.attackModule || 'default',
                    cadenceLevel: upgrades.cadenceLevel || 0,
                    minionProtocols: upgrades.minionProtocols || 0,
                    skin: upgrades.skin || 'default',
                    unlockedAttacks: unlockedModules,
                    unlockedSkins,
                    upgradeLevels: levelSnapshot,
                    championLevel: champion?.level || player.championPresetLevel || 1,
                    championXp: champion?.xp || player.championPresetXp || 0
                };
            }

            function encodeChampionPresetCode(preset) {
                if (!preset) return null;

                const modulesSet = new Set(Array.isArray(preset.unlockedAttacks) ? preset.unlockedAttacks : (preset.unlockedModules || []));
                const skinsSet = new Set(Array.isArray(preset.unlockedSkins) ? preset.unlockedSkins : []);
                if (preset.attackModule && preset.attackModule !== 'default') {
                    modulesSet.add(preset.attackModule);
                }
                if (preset.skin) {
                    skinsSet.add(preset.skin);
                }
                skinsSet.add('default');

                const encodeIndex = (value, list, fallbackIndex = 0) => {
                    const idx = list.indexOf(value);
                    return idx >= 0 ? idx : fallbackIndex;
                };
                const encodeBitset = (list, activeSet) => {
                    let mask = 0;
                    list.forEach((id, idx) => {
                        if (activeSet.has(id)) {
                            mask |= (1 << idx);
                        }
                    });
                    return mask.toString(36).toUpperCase();
                };

                const moduleIndex = encodeIndex(preset.attackModule, CHAMPION_PRESET_MODULE_CHOICES, 0);
                const cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, Math.floor(preset.cadenceLevel || 0)));
                const protocolLevel = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, Math.floor(preset.minionProtocols || 0)));
                const skinIndex = encodeIndex(preset.skin, CHAMPION_PRESET_SKIN_IDS, 0);
                const championLevel = Math.max(1, Math.floor(preset.championLevel || 1));
                const championXp = Math.max(0, Math.floor(preset.championXp || 0));

                const upgradeSegments = CHAMPION_PRESET_UPGRADE_KEYS.map(key => {
                    const val = Math.max(0, Math.floor((preset.upgradeLevels && preset.upgradeLevels[key]) || 0));
                    return val.toString(36).toUpperCase();
                }).join('.');

                const parts = [
                    `VN${CHAMPION_PRESET_SCHEMA_VERSION.toString(36).toUpperCase()}`,
                    `AM${moduleIndex.toString(36).toUpperCase()}`,
                    `UM${encodeBitset(CHAMPION_PRESET_MODULE_IDS, modulesSet)}`,
                    `CD${cadenceLevel.toString(36).toUpperCase()}`,
                    `PR${protocolLevel.toString(36).toUpperCase()}`,
                    `SK${skinIndex.toString(36).toUpperCase()}`,
                    `US${encodeBitset(CHAMPION_PRESET_SKIN_IDS, skinsSet)}`,
                    `CU${preset.championUnlocked ? '1' : '0'}`,
                    `LV${championLevel.toString(36).toUpperCase()}`,
                    `XP${championXp.toString(36).toUpperCase()}`,
                    `UG${upgradeSegments}`
                ];
                return parts.join('-');
            }

            function decodeChampionPresetCode(code) {
                if (typeof code !== 'string') return null;
                const trimmed = code.trim();
                if (!trimmed) return null;
                const segments = trimmed.split('-');

                const data = {
                    version: CHAMPION_PRESET_SCHEMA_VERSION,
                    championUnlocked: false,
                    attackModule: 'default',
                    cadenceLevel: 0,
                    minionProtocols: 0,
                    skin: 'default',
                    unlockedAttacks: [],
                    unlockedSkins: ['default'],
                    upgradeLevels: {},
                    championLevel: 1,
                    championXp: 0
                };

                const decodeIndex = (value, list, fallbackValue) => {
                    const idx = parseInt(value || '0', 36);
                    if (!Number.isFinite(idx) || idx < 0) return fallbackValue;
                    return list[idx] || fallbackValue;
                };

                const decodeBitset = (value, list) => {
                    const mask = parseInt(value || '0', 36);
                    if (!Number.isFinite(mask) || mask <= 0) return [];
                    const result = [];
                    list.forEach((id, idx) => {
                        if (mask & (1 << idx)) {
                            result.push(id);
                        }
                    });
                    return result;
                };

                let version = CHAMPION_PRESET_SCHEMA_VERSION;
                for (const segment of segments) {
                    if (!segment) continue;
                    const key = segment.slice(0, 2);
                    const payload = segment.slice(2);
                    switch (key) {
                        case 'VN':
                            version = parseInt(payload || '1', 36);
                            break;
                        case 'AM':
                            data.attackModule = decodeIndex(payload, CHAMPION_PRESET_MODULE_CHOICES, 'default');
                            break;
                        case 'UM':
                            data.unlockedAttacks = decodeBitset(payload, CHAMPION_PRESET_MODULE_IDS);
                            break;
                        case 'CD':
                            data.cadenceLevel = Math.max(0, parseInt(payload || '0', 36) || 0);
                            break;
                        case 'PR':
                            data.minionProtocols = Math.max(0, parseInt(payload || '0', 36) || 0);
                            break;
                        case 'SK':
                            data.skin = decodeIndex(payload, CHAMPION_PRESET_SKIN_IDS, 'default');
                            break;
                        case 'US':
                            data.unlockedSkins = decodeBitset(payload, CHAMPION_PRESET_SKIN_IDS);
                            break;
                        case 'CU':
                            data.championUnlocked = payload === '1';
                            break;
                        case 'LV':
                            data.championLevel = Math.max(1, parseInt(payload || '1', 36) || 1);
                            break;
                        case 'XP':
                            data.championXp = Math.max(0, parseInt(payload || '0', 36) || 0);
                            break;
                        case 'UG': {
                            const values = payload.split('.');
                            const upgrades = {};
                            CHAMPION_PRESET_UPGRADE_KEYS.forEach((keyName, idx) => {
                                const raw = values[idx] || '0';
                                const level = Math.max(0, parseInt(raw || '0', 36) || 0);
                                if (level > 0) {
                                    upgrades[keyName] = level;
                                }
                            });
                            data.upgradeLevels = upgrades;
                            break;
                        }
                        default:
                            break;
                    }
                }

                if (!Number.isFinite(version) || version < 1 || version > CHAMPION_PRESET_SCHEMA_VERSION) {
                    return null;
                }

                if (!Array.isArray(data.unlockedAttacks)) data.unlockedAttacks = [];
                if (!Array.isArray(data.unlockedSkins)) data.unlockedSkins = ['default'];
                if (!data.unlockedSkins.includes('default')) data.unlockedSkins.push('default');

                data.unlockedAttacks = Array.from(new Set(data.unlockedAttacks));
                data.unlockedSkins = Array.from(new Set(data.unlockedSkins));
                data.attackModule = CHAMPION_PRESET_MODULE_CHOICES.includes(data.attackModule) ? data.attackModule : 'default';
                if (!CHAMPION_PRESET_SKIN_IDS.includes(data.skin)) data.skin = 'default';
                data.cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, data.cadenceLevel));
                data.minionProtocols = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, data.minionProtocols));
                data.championLevel = Math.max(1, data.championLevel);
                data.championXp = Math.max(0, data.championXp);
                return data;
            }

            function applyChampionPresetToPlayer(preset, { player = store.player, applyChampion = true } = {}) {
                if (!CHAMPION_SYSTEM_ENABLED) return false;
                if (!preset || !player) return false;

                const upgrades = ensureChampionUpgradeState(player);
                const modulesSet = new Set(Array.isArray(preset.unlockedAttacks) ? preset.unlockedAttacks : []);
                const skinsSet = new Set(Array.isArray(preset.unlockedSkins) ? preset.unlockedSkins : []);
                if (preset.attackModule && preset.attackModule !== 'default') {
                    modulesSet.add(preset.attackModule);
                }
                if (preset.skin) {
                    skinsSet.add(preset.skin);
                }
                skinsSet.add('default');

                if (!upgrades.unlockedAttacks || typeof upgrades.unlockedAttacks !== 'object') {
                    upgrades.unlockedAttacks = {};
                }
                CHAMPION_PRESET_MODULE_IDS.forEach(id => {
                    upgrades.unlockedAttacks[id] = modulesSet.has(id);
                });

                upgrades.attackModule = CHAMPION_PRESET_MODULE_CHOICES.includes(preset.attackModule) && (preset.attackModule === 'default' || modulesSet.has(preset.attackModule))
                    ? preset.attackModule
                    : 'default';
                upgrades.cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, Math.floor(preset.cadenceLevel || 0)));
                upgrades.minionProtocols = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, Math.floor(preset.minionProtocols || 0)));

                if (!upgrades.unlockedSkins || typeof upgrades.unlockedSkins !== 'object') {
                    upgrades.unlockedSkins = { default: true };
                }
                CHAMPION_PRESET_SKIN_IDS.forEach(id => {
                    upgrades.unlockedSkins[id] = skinsSet.has(id);
                });
                upgrades.skin = CHAMPION_PRESET_SKIN_IDS.includes(preset.skin) ? preset.skin : 'default';
                if (!upgrades.unlockedSkins[upgrades.skin]) {
                    upgrades.skin = 'default';
                }

                player.championUnlocked = preset.championUnlocked || player.championUnlocked;
                player.upgradeLevels = player.upgradeLevels || {};
                CHAMPION_PRESET_UPGRADE_KEYS.forEach(key => {
                    const value = Math.max(0, Math.floor((preset.upgradeLevels && preset.upgradeLevels[key]) || 0));
                    player.upgradeLevels[key] = value;
                });

                player.championPresetLevel = Math.max(1, Math.floor(preset.championLevel || player.championPresetLevel || 1));
                player.championPresetXp = Math.max(0, Math.floor(preset.championXp || player.championPresetXp || 0));

                store.championPresetCache = {
                    version: preset.version || CHAMPION_PRESET_SCHEMA_VERSION,
                    championUnlocked: player.championUnlocked,
                    attackModule: upgrades.attackModule,
                    cadenceLevel: upgrades.cadenceLevel,
                    minionProtocols: upgrades.minionProtocols,
                    skin: upgrades.skin,
                    unlockedAttacks: Array.from(modulesSet),
                    unlockedSkins: Array.from(skinsSet),
                    upgradeLevels: { ...player.upgradeLevels },
                    championLevel: player.championPresetLevel,
                    championXp: player.championPresetXp
                };

                if (applyChampion && store.playerChampion && !store.playerChampion.dead) {
                    const champion = store.playerChampion;
                    champion.level = player.championPresetLevel;
                    champion.xp = player.championPresetXp;
                    champion.damageScale = 1 + (champion.level - 1) * 0.25;
                    champion.fireCooldownBase = Math.max(0.6, PLAYER_CHAMPION_CONFIG.baseFireCooldown * Math.pow(0.9, champion.level - 1));
                    champion.dashCooldownBase = Math.max(1.5, PLAYER_CHAMPION_CONFIG.baseDashCooldown * Math.pow(0.92, champion.level - 1));
                    champion.momentumBase = Math.min(6.2, 4.1 + 0.25 * (champion.level - 1));
                    champion.momentum = champion.momentumBase;
                    champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + champion.level * 6;
                    champion.guardRadius = champion.guardRadiusBase;
                    champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (champion.level - 1) * 0.08;
                    champion.angularSpeed = champion.angularSpeedBase;
                    champion.volleySize = Math.min(7, 4 + champion.level);
                    champion.volleySpread = Math.min(0.22, 0.16 + (champion.level - 1) * 0.015);
                    champion.roamTimer = 0;
                }

                notifyChampionLoadoutChanged({ refreshMinions: true });
                if (applyChampion && store.playerChampion && !store.playerChampion.dead) {
                    refreshChampionMinionsFromState(store.playerChampion);
                }
                return true;
            }

            function getChampionAttackCatalogue(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const unlockedAttacks = state?.unlockedAttacks || {};
                return CHAMPION_ATTACK_MODULES.map(mod => ({
                    ...mod,
                    unlocked: !!unlockedAttacks[mod.id],
                    active: state.attackModule === mod.id
                }));
            }

            function getNextChampionAttackUnlock(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const modules = getChampionAttackCatalogue(state);
                const nextModule = modules.find(mod => !mod.unlocked);
                if (!nextModule) return null;
                return {
                    module: nextModule,
                    modules,
                    unlockedCount: modules.filter(mod => mod.unlocked).length,
                    total: modules.length,
                    cost: nextModule.cost
                };
            }

            function getChampionCadenceOptions(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                return CHAMPION_CADENCE_LEVELS.map(option => ({
                    ...option,
                    owned: state.cadenceLevel >= option.level,
                    active: state.cadenceLevel === option.level
                }));
            }

            function getNextChampionCadenceUpgrade(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const options = getChampionCadenceOptions(state);
                const next = options.find(option => option.level > state.cadenceLevel);
                if (!next) return null;
                const current = options.find(option => option.level === state.cadenceLevel) || options[0];
                return { option: next, options, current };
            }

            function getChampionProtocolOptions(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                return CHAMPION_MINION_PROTOCOL_LEVELS.map(option => ({
                    ...option,
                    owned: state.minionProtocols >= option.level,
                    active: state.minionProtocols === option.level
                }));
            }

            function getNextChampionProtocolUpgrade(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const options = getChampionProtocolOptions(state);
                const next = options.find(option => option.level > state.minionProtocols);
                if (!next) return null;
                const current = options.find(option => option.level === state.minionProtocols) || options[0];
                return { option: next, options, current };
            }

            function getChampionSkinCatalogue(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const unlockedSkins = state.unlockedSkins || {};
                return CHAMPION_SKIN_OPTIONS.map(option => ({
                    ...option,
                    unlocked: !!unlockedSkins[option.id],
                    active: state.skin === option.id
                }));
            }

            function getNextChampionSkinUnlock(state = getChampionUpgradeState()) {
                if (!state) state = getChampionUpgradeState();
                const catalogue = getChampionSkinCatalogue(state);
                const next = catalogue.find(option => !option.unlocked);
                if (!next) return null;
                const active = catalogue.find(option => option.active) || catalogue[0];
                return { option: next, catalogue, active };
            }

            function notifyChampionLoadoutChanged({ refreshMinions = true } = {}) {
                if (!CHAMPION_SYSTEM_ENABLED) {
                    return;
                }
                if (store.playerChampion && !store.playerChampion.dead) {
                    applyChampionUpgradeLoadout(store.playerChampion, { refreshMinions });
                }
                updateChampionQuickStatus();
            }

            function updateChampionQuickStatus() {
                const container = typeof document !== 'undefined' ? q('championQuickStatus') : null;
                if (!container) return;

                if (!CHAMPION_SYSTEM_ENABLED) {
                    container.classList.add('locked');
                    container.innerHTML = '<div><strong>Champion:</strong> Systems offline.</div>';
                    return;
                }

                if (!store.player?.championUnlocked) {
                    container.classList.add('locked');
                    container.innerHTML = '<div><strong>Champion:</strong> Secure the Shadow Sigil to bind a guardian.</div>';
                    return;
                }

                const state = getChampionUpgradeState();
                const modules = getChampionAttackCatalogue(state);
                const attack = CHAMPION_ATTACK_MODULE_MAP[state.attackModule] || { name: 'Base Volley' };
                const cadence = CHAMPION_CADENCE_LEVELS[state.cadenceLevel] || CHAMPION_CADENCE_LEVELS[0];
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[state.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const unlockedCount = modules.filter(mod => mod.unlocked).length;

                container.classList.remove('locked');
                container.innerHTML = [
                    `<div><strong>Module:</strong> ${escapeHtml(attack.name || 'Base Volley')} <span style="opacity:0.7;">(${unlockedCount}/${modules.length} unlocked)</span></div>`,
                    `<div><strong>Cadence:</strong> ${escapeHtml(cadence.name)} <span style="opacity:0.7;">(Lv ${cadence.level})</span></div>`,
                    `<div><strong>Protocols:</strong> ${escapeHtml(protocol.name)} <span style="opacity:0.7;">(Lv ${protocol.level})</span></div>`
                ].join('');
            }

            function createDefaultChampionUpgradeState() {
                return {
                    attackModule: 'default',
                    unlockedAttacks: {
                        // Legacy modules (for backwards compatibility)
                        ember: false, tempest: false, void: false,
                        // New attack modules - some available for testing
                        precision_strike: true, kinetic_swarm: true,
                        inferno_burst: true, plasma_stream: true,
                        focus_beam: false, scatter_array: false,
                        arc_cannon: true, storm_grid: false
                    },
                    cadenceLevel: 0,
                    minionProtocols: 0,
                    skin: 'default',
                    unlockedSkins: { default: true }
                };
            }

            function ensureChampionUpgradeState(player = store.player) {
                if (!player) return createDefaultChampionUpgradeState();
                if (!player.championUpgrades || typeof player.championUpgrades !== 'object') {
                    player.championUpgrades = createDefaultChampionUpgradeState();
                }
                const state = player.championUpgrades;
                if (!state.unlockedAttacks) {
                    state.unlockedAttacks = {
                        ember: false, tempest: false, void: false,
                        precision_strike: true, kinetic_swarm: true,
                        inferno_burst: true, plasma_stream: true,
                        focus_beam: false, scatter_array: false,
                        arc_cannon: true, storm_grid: false
                    };
                } else {
                    // Migrate existing saves and ensure new modules have defaults
                    state.unlockedAttacks.ember = !!state.unlockedAttacks.ember;
                    state.unlockedAttacks.tempest = !!state.unlockedAttacks.tempest;
                    state.unlockedAttacks.void = !!state.unlockedAttacks.void;
                    // Add new modules with default availability for testing
                    if (state.unlockedAttacks.precision_strike === undefined) state.unlockedAttacks.precision_strike = true;
                    if (state.unlockedAttacks.kinetic_swarm === undefined) state.unlockedAttacks.kinetic_swarm = true;
                    if (state.unlockedAttacks.inferno_burst === undefined) state.unlockedAttacks.inferno_burst = true;
                    if (state.unlockedAttacks.plasma_stream === undefined) state.unlockedAttacks.plasma_stream = true;
                    if (state.unlockedAttacks.focus_beam === undefined) state.unlockedAttacks.focus_beam = false;
                    if (state.unlockedAttacks.scatter_array === undefined) state.unlockedAttacks.scatter_array = false;
                    if (state.unlockedAttacks.arc_cannon === undefined) state.unlockedAttacks.arc_cannon = true;
                    if (state.unlockedAttacks.storm_grid === undefined) state.unlockedAttacks.storm_grid = false;
                }
                if (typeof state.attackModule !== 'string' || !CHAMPION_ATTACK_MODULE_MAP[state.attackModule]) {
                    state.attackModule = 'default';
                }
                if (typeof state.cadenceLevel !== 'number' || Number.isNaN(state.cadenceLevel)) {
                    state.cadenceLevel = 0;
                }
                state.cadenceLevel = Math.max(0, Math.min(CHAMPION_CADENCE_LEVELS.length - 1, Math.floor(state.cadenceLevel)));
                if (typeof state.minionProtocols !== 'number' || Number.isNaN(state.minionProtocols)) {
                    state.minionProtocols = 0;
                }
                state.minionProtocols = Math.max(0, Math.min(CHAMPION_MINION_PROTOCOL_LEVELS.length - 1, Math.floor(state.minionProtocols)));
                if (!state.unlockedSkins || typeof state.unlockedSkins !== 'object') {
                    state.unlockedSkins = { default: true };
                } else {
                    state.unlockedSkins.default = true;
                }
                if (typeof state.skin !== 'string' || !CHAMPION_SKIN_OPTION_MAP[state.skin]) {
                    state.skin = 'default';
                }
                return state;
            }

            function getChampionUpgradeState(player = store.player) {
                return ensureChampionUpgradeState(player);
            }

            function getChampionSkinTheme(key) {
                return CHAMPION_SKIN_THEMES[key] || CHAMPION_SKIN_THEMES.default;
            }

            function getChampionMinionAbilityTheme(moduleId) {
                const key = (moduleId && CHAMPION_MINION_ABILITY_THEMES[moduleId]) ? moduleId : 'default';
                return CHAMPION_MINION_ABILITY_THEMES[key] || CHAMPION_MINION_ABILITY_THEMES.default;
            }

            function refreshChampionMinionsFromState(owner, tuning = null) {
                if (!owner || !Array.isArray(store.championMinions) || !store.championMinions.length) {
                    return;
                }
                const state = getChampionUpgradeState();
                const protocol = tuning || (CHAMPION_MINION_PROTOCOL_LEVELS[state.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0]);
                const abilityModule = owner.attackModule || state.attackModule || 'default';
                const abilityTheme = getChampionMinionAbilityTheme(abilityModule);
                const theme = owner.skinTheme ? owner.skinTheme.minion : getChampionSkinTheme(state.skin || 'default').minion;
                const ownerLevel = owner.level || 1;
                const baseCooldown = Math.max(0.9, 1.4 - ownerLevel * 0.12);
                const baseDamageScale = 1 + Math.max(0, ownerLevel - 1) * 0.18;

                for (let i = store.championMinions.length - 1; i >= 0; i--) {
                    const minion = store.championMinions[i];
                    if (!minion || minion.dead) continue;
                    minion.fireCooldownBase = baseCooldown;
                    minion.fireCooldown = Math.max(0.24, minion.fireCooldownBase * (protocol.fireRateMult || 1));
                    minion.damageScaleBase = baseDamageScale;
                    minion.damageScale = minion.damageScaleBase * (protocol.damageMult || 1);
                    minion.protocolLevel = protocol.level || 0;
                    minion.protocolSlowFactor = protocol.slowFactor || null;
                    minion.protocolNovaDamageScale = protocol.novaDamageScale || 0;
                    minion.skinTheme = theme;
                    minion.abilityModule = abilityModule;
                    minion.abilityTheme = abilityTheme;
                }
            }

            function applyChampionUpgradeLoadout(champion, { refreshMinions = true } = {}) {
                if (!CHAMPION_SYSTEM_ENABLED) return;
                if (!champion) return;
                const state = getChampionUpgradeState();
                const cadence = CHAMPION_CADENCE_LEVELS[state.cadenceLevel] || CHAMPION_CADENCE_LEVELS[0];
                const minionProtocol = CHAMPION_MINION_PROTOCOL_LEVELS[state.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const attack = CHAMPION_ATTACK_MODULE_MAP[state.attackModule] || null;
                const skinOption = CHAMPION_SKIN_OPTION_MAP[state.skin] || CHAMPION_SKIN_OPTION_MAP.default;
                const skinTheme = getChampionSkinTheme(skinOption.theme || skinOption.id || 'default');

                champion.fireCooldownBase = Math.max(0.35, champion.fireCooldownBase || champion.fireCooldown || PLAYER_CHAMPION_CONFIG.baseFireCooldown);
                champion.dashCooldownBase = Math.max(0.8, champion.dashCooldownBase || champion.dashCooldown || PLAYER_CHAMPION_CONFIG.baseDashCooldown);
                champion.momentumBase = champion.momentumBase || champion.momentum || 4.1;
                champion.guardRadiusBase = champion.guardRadiusBase || champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius;
                champion.angularSpeedBase = champion.angularSpeedBase || champion.angularSpeed || PLAYER_CHAMPION_CONFIG.baseAngularSpeed;

                // Apply cadence multipliers first
                let finalFireRateMult = cadence.fireRateMult || 1;
                let finalDamageMult = 1;

                // Apply attack module modifiers
                if (attack && attack.fireRateMult) {
                    finalFireRateMult *= attack.fireRateMult;
                }
                if (attack && attack.damageMult) {
                    finalDamageMult = attack.damageMult;
                }

                champion.fireCooldown = Math.max(0.24, champion.fireCooldownBase * finalFireRateMult);
                champion.dashCooldown = Math.max(0.6, champion.dashCooldownBase * (cadence.dashCooldownMult || 1));
                champion.momentum = champion.momentumBase;
                champion.guardRadius = champion.guardRadiusBase;
                champion.angularSpeed = champion.angularSpeedBase;
                champion.attackDamageMultiplier = finalDamageMult; // Store for bullet damage calculation

                champion.attackModule = attack ? attack.id : 'default';
                champion.cadenceLevel = state.cadenceLevel;
                champion.minionProtocols = state.minionProtocols;
                champion.skinKey = skinOption.id;
                champion.skinTheme = skinTheme;
                champion.bulletPrimary = skinTheme.bullet;
                champion.bulletPiercing = skinTheme.bulletPierce || skinTheme.bullet;

                if (refreshMinions) {
                    refreshChampionMinionsFromState(champion, minionProtocol);
                }

                configureChampionCombatProfile(champion, cadence);
            }

            function ensureChampionCollections() {
                if (!store.championMinions) store.championMinions = [];
            }

            function spawnChampionMinion(owner) {
                if (!CHAMPION_SYSTEM_ENABLED) return null;
                ensureChampionCollections();
                if (!owner) return null;
                const level = owner.level || 1;
                const minionCount = store.championMinions.length;
                if (minionCount >= PLAYER_CHAMPION_CONFIG.maxMinions) return null;
                const id = performance.now() + Math.random();

                // Position minions in a triangle formation (120 degrees apart)
                const baseAngle = (minionCount * Math.PI * 2) / 3; // 120 degrees apart
                const orbitRadius = 58 + minionCount * 8; // Slight radius variation

                const minion = {
                    id,
                    ownerId: owner.id,
                    orbitRadius: orbitRadius,
                    orbitAngle: baseAngle + Math.random() * 0.2 - 0.1, // Small random offset
                    orbitSpeed: 1.65 + minionCount * 0.15, // Slight speed variation
                    pulsePhase: Math.random() * Math.PI * 2,
                    swirlPhase: Math.random() * Math.PI * 2,
                    fireCooldown: Math.max(0.9, 1.4 - level * 0.12),
                    fireTimer: 0.35 + Math.random() * 0.4,
                    damageScale: 1 + (level - 1) * 0.18,
                    dead: false
                };
                const anchorX = owner.x + Math.cos(minion.orbitAngle) * minion.orbitRadius;
                const anchorY = owner.y + Math.sin(minion.orbitAngle) * minion.orbitRadius * 0.55;
                minion.x = anchorX;
                minion.y = anchorY;
                minion.fireCooldownBase = minion.fireCooldown;
                minion.damageScaleBase = minion.damageScale;

                const upgrades = getChampionUpgradeState();
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[upgrades.minionProtocols] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const abilityModule = owner.attackModule || upgrades.attackModule || 'default';
                const abilityTheme = getChampionMinionAbilityTheme(abilityModule);
                minion.fireCooldown = Math.max(0.24, minion.fireCooldownBase * (protocol.fireRateMult || 1));
                minion.damageScale = minion.damageScaleBase * (protocol.damageMult || 1);
                minion.protocolLevel = protocol.level || 0;
                minion.protocolSlowFactor = protocol.slowFactor || null;
                minion.protocolNovaDamageScale = protocol.novaDamageScale || 0;
                const minionTheme = owner?.skinTheme ? owner.skinTheme.minion : getChampionSkinTheme(upgrades.skin).minion;
                minion.skinTheme = minionTheme;
                minion.abilityModule = abilityModule;
                minion.abilityTheme = abilityTheme;
                store.championMinions.push(minion);
                store.activeEffects.push(createEffect('spawnTeleport', owner.x, owner.y, owner.r * 1.6, {
                    duration: 0.6,
                    color: owner?.skinTheme ? owner.skinTheme.trail : '#e7e9ff',
                    clusterIndex: -1,
                    isChampion: true
                }));
                return minion;
            }

            function grantChampionCompanion() {
                if (!CHAMPION_SYSTEM_ENABLED) return null;
                ensureChampionCollections();
                ensureChampionUpgradeState();
                const now = performance.now();
                if (!store.playerChampion || store.playerChampion.dead) {
                    const champion = {
                        id: now + Math.random(),
                        x: clamp(store.player.x, 60, W - 60),
                        y: clamp(store.player.y - 90, 80, H - 120),
                        r: 20,
                        guardRadius: PLAYER_CHAMPION_CONFIG.baseGuardRadius,
                        guardAngle: Math.random() * Math.PI * 2,
                        angularSpeed: PLAYER_CHAMPION_CONFIG.baseAngularSpeed,
                        anchorOffsetY: -80,
                        fireCooldown: PLAYER_CHAMPION_CONFIG.baseFireCooldown,
                        fireTimer: 0.45,
                        dashCooldown: PLAYER_CHAMPION_CONFIG.baseDashCooldown,
                        dashTimer: 0,
                        dashDuration: 0,
                        dashVX: 0,
                        dashVY: 0,
                        dashCooldownTimer: 1.4,
                        state: null,
                        level: 1,
                        damageScale: 1,
                        volleySpread: 0.16,
                        volleySize: 4,
                        momentum: 4.1,
                        auraPulse: Math.random() * Math.PI * 2,
                        swirlPhase: Math.random() * Math.PI * 2,
                        roamAnchor: null,
                        roamTimer: 0,
                        roamMode: 'idle',
                        echoCooldown: 0,
                        dead: false,
                        isPlayerChampion: true,
                        fireCooldownBase: PLAYER_CHAMPION_CONFIG.baseFireCooldown,
                        dashCooldownBase: PLAYER_CHAMPION_CONFIG.baseDashCooldown,
                        guardRadiusBase: PLAYER_CHAMPION_CONFIG.baseGuardRadius,
                        angularSpeedBase: PLAYER_CHAMPION_CONFIG.baseAngularSpeed,
                        momentumBase: 4.1
                    };
                    store.playerChampion = champion;
                    store.player.championUnlocked = true;
                    store.championMinions.length = 0;

                    const presetLevel = Math.max(1, store.player?.championPresetLevel || 1);
                    const presetXp = Math.max(0, store.player?.championPresetXp || 0);
                    if (presetLevel > 1) {
                        champion.level = presetLevel;
                        champion.damageScale = 1 + (champion.level - 1) * 0.25;
                        champion.fireCooldownBase = Math.max(0.6, champion.fireCooldownBase * Math.pow(0.9, champion.level - 1));
                        champion.dashCooldownBase = Math.max(1.5, champion.dashCooldownBase * Math.pow(0.92, champion.level - 1));
                        champion.momentumBase = Math.min(6.2, champion.momentumBase + 0.25 * (champion.level - 1));
                        champion.momentum = champion.momentumBase;
                        champion.volleySize = Math.min(7, 4 + champion.level);
                        champion.volleySpread = Math.min(0.22, 0.16 + (champion.level - 1) * 0.015);
                        champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + champion.level * 6;
                        champion.guardRadius = champion.guardRadiusBase;
                        champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (champion.level - 1) * 0.08;
                        champion.angularSpeed = champion.angularSpeedBase;
                    }
                    champion.xp = presetXp;

                    applyChampionUpgradeLoadout(champion, { refreshMinions: false });
                    // Spawn 3 minions immediately for better visual formation
                    for (let i = 0; i < 3; i++) {
                        spawnChampionMinion(champion);
                    }
                    refreshChampionMinionsFromState(champion);
                    store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.y, champion.r * 2.1, {
                        duration: 1.05,
                        color: champion.skinTheme ? champion.skinTheme.trail : '#cbd4ff',
                        clusterIndex: -1,
                        isChampion: true
                    }));
                    updateChampionQuickStatus();
                    announce('âš”ï¸ Champion sigil aligned! Guardian bound to you.');
                    playSound('epicHorn');
                    return;
                }

                const champion = store.playerChampion;
                if (champion.dead) {
                    store.playerChampion = null;
                    grantChampionCompanion();
                    return;
                }

                store.player.championUnlocked = true;

                const nextLevel = Math.min((champion.level || 1) + 1, PLAYER_CHAMPION_CONFIG.maxLevel);
                const levelDelta = nextLevel - (champion.level || 1);
                champion.level = nextLevel;
                champion.damageScale = 1 + (champion.level - 1) * 0.25;
                champion.fireCooldownBase = Math.max(0.6, champion.fireCooldownBase * (levelDelta > 0 ? 0.9 : 1));
                champion.dashCooldownBase = Math.max(1.5, champion.dashCooldownBase * (levelDelta > 0 ? 0.92 : 1));
                champion.momentumBase = Math.min(6.2, champion.momentumBase + 0.25 * levelDelta);
                champion.volleySize = Math.min(7, 4 + champion.level);
                champion.volleySpread = Math.min(0.22, 0.16 + (champion.level - 1) * 0.015);
                champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + champion.level * 6;
                champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (champion.level - 1) * 0.08;
                champion.roamTimer = 0;

                applyChampionUpgradeLoadout(champion, { refreshMinions: true });

                store.activeEffects.push(createEffect('spawnTeleport', champion.x, champion.y, champion.r * 2.4, {
                    duration: 0.7,
                    color: champion.skinTheme ? champion.skinTheme.trail : '#f4f0ff',
                    clusterIndex: -1,
                    isChampion: true
                }));
                updateChampionQuickStatus();
                announce(`Champion ascends to rank ${champion.level}!`);
                playSound('epicHorn');
            }

            function startShadowAbility(b, ability) {
                b.currentAbility = ability;
                b.abilityStage = 'windup';
                b.shadowTelegraph = { type: ability, progress: 0 };
                b.shadowTelegraphTarget = { x: store.player.x, y: store.player.y };
                let windupBase;
                switch (ability) {
                    case 'star': windupBase = b.isEnraged ? 0.6 : 0.8; break;
                    case 'lightning': windupBase = b.isEnraged ? 0.65 : 0.85; break;
                    case 'hounds': windupBase = b.isEnraged ? 0.7 : 0.9; break;
                    case 'charge': windupBase = b.isEnraged ? 0.9 : 1.1; break;
                    case 'pulseWave': windupBase = b.isEnraged ? 0.5 : 0.7; break;
                    case 'voidRift': windupBase = b.isEnraged ? 0.75 : 0.95; break;
                    default: windupBase = 0.8; break;
                }
                b.abilityWindupTotal = windupBase;
                b.abilityTimer = windupBase;
            }

            function finishShadowAbility(b) {
                b.currentAbility = null;
                b.abilityStage = null;
                b.abilityTimer = 0;
                b.abilityWindupTotal = 0;
                b.shadowTelegraph = null;
                b.shadowTelegraphTarget = null;
                b.shadowChargeVX = 0;
                b.shadowChargeVY = 0;
                b.shadowChargeTrailCooldown = 0;
                b.shadowChargeHit = false;
            }

            function shadowClonePulseWave(b, dmgScale) {
                // Create expanding ring of bullets
                const bulletCount = b.isEnraged ? 18 : 14;
                const speed = b.isEnraged ? 240 : 200;
                for (let i = 0; i < bulletCount; i++) {
                    const angle = (i / bulletCount) * Math.PI * 2;
                    const bullet = getEBulletFromPool({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: 5,
                        col: '#b0b8ff',
                        dmg: 18 * dmgScale,
                        life: 3.5
                    });
                    store.eBullets.push(bullet);
                }
                store.activeEffects.push(createEffect('explosion', b.x, b.y, 30));
                playSound('explosion');
            }

            function shadowCloneVoidRift(b, dmgScale) {
                // Spawn void rifts at player location that deal damage over time
                if (!store.voidRifts) store.voidRifts = [];
                const riftCount = b.isEnraged ? 3 : 2;
                for (let i = 0; i < riftCount; i++) {
                    const spread = 80;
                    const offsetX = (Math.random() - 0.5) * spread;
                    const offsetY = (Math.random() - 0.5) * spread;
                    store.voidRifts.push({
                        x: store.player.x + offsetX,
                        y: store.player.y + offsetY,
                        r: 28,
                        life: 4.5,
                        maxLife: 4.5,
                        damageTimer: 0,
                        damage: 8 * dmgScale,
                        dead: false
                    });
                }
                playSound('warp');
            }

            function shadowCloneFireMultishot(b, dmgScale) {
                const volley = b.isEnraged ? 7 : 5;
                const spread = Math.PI / 6;
                const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                const bulletSpeed = 320 + (b.isEnraged ? 40 : 0);
                for (let i = 0; i < volley; i++) {
                    const offset = i - (volley - 1) / 2;
                    const angle = baseAngle + offset * (spread / Math.max(1, volley - 1));
                    const bullet = getEBulletFromPool({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * bulletSpeed,
                        vy: Math.sin(angle) * bulletSpeed,
                        r: 4,
                        col: '#aab0ff',
                        dmg: 14 * dmgScale,
                        life: 3.2
                    });
                    store.eBullets.push(bullet);
                }
            }

            function shadowCloneFireStarVolley(b, dmgScale) {
                const player = store.player;
                const baseAngle = Math.atan2(player.y - b.y, player.x - b.x);
                const starCount = b.isEnraged ? 5 : 3;
                const angleStep = 0.16;
                const radialOffset = 28;
                for (let i = 0; i < starCount; i++) {
                    const offsetIdx = i - (starCount - 1) / 2;
                    const angle = baseAngle + offsetIdx * angleStep;
                    // Fire from boss center towards player (removed perpendicular offset)
                    const originX = b.x + Math.cos(angle) * radialOffset;
                    const originY = b.y + Math.sin(angle) * radialOffset;
                    launchStarProjectile(originX, originY, angle, {
                        isEnemy: true,
                        enemyDamage: 20 * dmgScale * (b.isEnraged ? 1.2 : 1),
                        speedMultiplier: b.isEnraged ? 1.05 : 0.92,
                        trailColor: 'rgba(170, 180, 255, ',
                        primaryColor: '#e0e4ff',
                        coreColor: '#545b99',
                        shadowColor: '#2c2f58'
                    });
                }
                playSound('stargun');
            }

            function generateShadowLightningPath(start, end, segments) {
                segments = segments || 5;
                const points = [{ x: start.x, y: start.y }];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const length = Math.sqrt(dx * dx + dy * dy) || 1;
                const nx = -dy / length;
                const ny = dx / length;
                for (let i = 1; i < segments; i++) {
                    const t = i / segments;
                    const jitterScale = 1 - Math.abs(0.5 - t) * 1.4;
                    const jitter = (Math.random() - 0.5) * 90 * jitterScale;
                    points.push({
                        x: start.x + dx * t + nx * jitter,
                        y: start.y + dy * t + ny * jitter
                    });
                }
                points.push({ x: end.x, y: end.y });
                return points;
            }

            function shadowCloneCastLightning(b, dmgScale) {
                const start = { x: b.x, y: b.y - b.r * 0.25 };
                const targets = [{ type: 'player', x: store.player.x, y: store.player.y }];
                if (store.iceman) targets.push({ type: 'iceman', x: store.iceman.x, y: store.iceman.y });
                if (store.beefClone) targets.push({ type: 'beefClone', x: store.beefClone.x, y: store.beefClone.y });
                const maxTargets = b.isEnraged ? 3 : 2;
                while (targets.length > maxTargets) targets.pop();
                for (let i = 0; i < targets.length; i++) {
                    const target = targets[i];
                    const endPoint = { x: target.x, y: target.y };
                    const points = generateShadowLightningPath(start, endPoint, 5);
                    store.lightningBolts.push({
                        points,
                        life: 0.45,
                        maxLife: 0.45,
                        dead: false,
                        isEnemy: true,
                        color: '#d7dcff',
                        glowColor: '#4a58c7'
                    });
                    store.activeEffects.push(createEffect('lightningFlash', endPoint.x, endPoint.y));
                    if (target.type === 'player') {
                        takeDamage(24 * dmgScale * (b.isEnraged ? 1.2 : 1));
                    }
                };
            }

            function spawnShadowHoundsFromBoss(b, count, dmgScale) {
                if (!store.shadowHounds) store.shadowHounds = [];
                count = count || 3;
                for (let i = 0; i < count; i++) {
                    const offsetIdx = i - (count - 1) / 2;
                    const lifespan = 11 + (b.isEnraged ? 4 : 0);
                    store.shadowHounds.push({
                        x: b.x + offsetIdx * 24,
                        y: b.y + 24 + Math.abs(offsetIdx) * 6,
                        vx: 0,
                        vy: 0,
                        speed: (b.isEnraged ? 260 : 220),
                        damage: 8 * dmgScale * (b.isEnraged ? 1.2 : 1),
                        life: lifespan,
                        maxLife: lifespan,
                        hp: 4,
                        hpMax: 4,
                        attackCooldown: 0.4,
                        wobble: Math.random() * Math.PI * 2,
                        dead: false,
                        collisionDamageCooldown: 0
                    });
                }
                playSound('dogs');
            }

            function addShadowEcho(x, y) {
                if (!store.shadowEchoes) store.shadowEchoes = [];
                store.shadowEchoes.push({
                    x,
                    y,
                    life: 0.4,
                    maxLife: 0.4,
                    rotation: Math.random() * Math.PI * 2,
                    dead: false
                });
            }

            function updateShadowEchoes(dt) {
                if (!store.shadowEchoes || !store.shadowEchoes.length) return;
                for (let i = store.shadowEchoes.length - 1; i >= 0; i--) {
                    const echo = store.shadowEchoes[i];
                    echo.life -= dt;
                    if (echo.life <= 0) {
                        store.shadowEchoes.splice(i, 1);
                    }
                }
            }

            function normalizeAngle(angle) {
                if (!Number.isFinite(angle)) return 0;
                return Math.atan2(Math.sin(angle), Math.cos(angle));
            }

            function ensureTemporalSystems() {
                if (!Array.isArray(store.temporalEchoes)) {
                    store.temporalEchoes = [];
                }
                if (!Array.isArray(store.timeShards)) {
                    store.timeShards = [];
                }
                if (!store.temporalBeam) {
                    store.temporalBeam = {
                        anchorBossId: null,
                        angle: 0,
                        width: 32,
                        telegraph: 0,
                        skipPulse: 0,
                        rotationSpeed: 0,
                        length: Math.max(W, H),
                        originOffset: 1,
                        active: false
                    };
                }
            }

            function ensureAsynchronosState(b) {
                if (b.asynchronosState) {
                    return b.asynchronosState;
                }

                const state = {
                    phase: 1,
                    motionSamples: [],
                    motionSampleInterval: 0.14,
                    motionSampleTimer: 0.05,
                    bossHistory: [],
                    bossSampleInterval: 0.08,
                    bossSampleTimer: 0.08,
                    historyDurationMs: 6000,
                    echoTimer: 2.4,
                    baseEchoCooldown: 3.8,
                    phaseEchoCooldown: 2.5,
                    echoSensitivity: 0.3,
                    rewindTimer: 9.5,
                    baseRewindInterval: 9.5,
                    phaseRewindInterval: 6.4,
                    rewindLookback: 2.7,
                    phaseRewindLookback: 2.0,
                    rewinding: false,
                    rewindDuration: 0.65,
                    rewindElapsed: 0,
                    rewindPath: null,
                    beamAngle: -Math.PI / 2,
                    baseBeamRotationSpeed: 0.55,
                    phaseBeamRotationSpeed: 0.82,
                    beamRotationSpeed: 0.55,
                    beamSkipTimer: 3.4,
                    baseBeamSkipInterval: 3.4,
                    phaseBeamSkipInterval: 2.3,
                    beamTelegraphWindow: 0.75,
                    beamTelegraphActive: false,
                    beamSkipAngle: Math.PI / 4,
                    skipPulseTimer: 0,
                    skipPulseDuration: 0.45,
                    burstTimer: 2.4,
                    baseBurstInterval: 2.6,
                    phaseBurstInterval: 1.8,
                    movePhase: 0,
                    lastPlayerSample: null,
                    lastPlayerDirection: 0
                };

                b.asynchronosState = state;
                return state;
            }

            function recordAsynchronosSamples(b, state, dt) {
                const now = performance.now();

                state.motionSampleTimer -= dt;
                if (state.motionSampleTimer <= 0) {
                    state.motionSampleTimer += state.motionSampleInterval;
                    const player = store.player;
                    if (player) {
                        const last = state.lastPlayerSample;
                        const sample = { x: player.x, y: player.y, t: now };
                        if (last) {
                            const dtMs = Math.max(16, now - last.t);
                            const dtSeconds = dtMs / 1000;
                            const dx = player.x - last.x;
                            const dy = player.y - last.y;
                            const dist = Math.hypot(dx, dy);
                            const speed = dtSeconds > 0 ? dist / dtSeconds : 0;
                            const dir = dist > 2 ? Math.atan2(dy, dx) : state.lastPlayerDirection;
                            state.motionSamples.push({ pos: { x: player.x, y: player.y }, dir, speed, t: now });
                            state.lastPlayerDirection = dir;
                            while (state.motionSamples.length > 24) {
                                state.motionSamples.shift();
                            }
                        }
                        state.lastPlayerSample = sample;
                    }
                }

                state.bossSampleTimer -= dt;
                if (state.bossSampleTimer <= 0) {
                    state.bossSampleTimer += state.bossSampleInterval;
                    state.bossHistory.push({ x: b.x, y: b.y, t: now });
                }

                while (state.bossHistory.length && now - state.bossHistory[0].t > state.historyDurationMs) {
                    state.bossHistory.shift();
                }

                while (state.motionSamples.length && now - state.motionSamples[0].t > state.historyDurationMs) {
                    state.motionSamples.shift();
                }
            }

            function evaluateAsynchronosEcho(state) {
                if (state.echoTimer > 0 || state.motionSamples.length < 6) {
                    return null;
                }

                const recent = state.motionSamples.slice(-6);
                const active = recent.filter(sample => sample.speed > 40);
                if (active.length < 5) {
                    return null;
                }

                let totalDrift = 0;
                let maxSpeed = active[0].speed;
                let minSpeed = active[0].speed;
                for (let i = 1; i < active.length; i++) {
                    const prev = active[i - 1];
                    const curr = active[i];
                    const delta = Math.atan2(Math.sin(curr.dir - prev.dir), Math.cos(curr.dir - prev.dir));
                    totalDrift += Math.abs(delta);
                    maxSpeed = Math.max(maxSpeed, curr.speed);
                    minSpeed = Math.min(minSpeed, curr.speed);
                }

                const avgDrift = totalDrift / (active.length - 1);
                const avgSpeed = active.reduce((sum, sample) => sum + sample.speed, 0) / active.length;
                const speedEnvelope = avgSpeed > 0 ? (maxSpeed - minSpeed) / avgSpeed : 1;
                const driftThreshold = state.phase === 2 ? 0.22 : 0.3;
                const speedThreshold = state.phase === 2 ? 0.5 : 0.65;

                if (avgDrift <= driftThreshold && speedEnvelope <= speedThreshold) {
                    const originIndex = Math.max(0, state.motionSamples.length - (state.phase === 2 ? 9 : 11));
                    const originSample = state.motionSamples[originIndex];
                    const last = active[active.length - 1];
                    if (originSample && originSample.pos && last) {
                        return {
                            position: { x: originSample.pos.x, y: originSample.pos.y },
                            dir: last.dir,
                            speed: avgSpeed
                        };
                    }
                }

                return null;
            }

            function spawnTemporalEcho(b, state, trigger, dmgScale) {
                if (!trigger || !trigger.position) {
                    return;
                }

                ensureTemporalSystems();
                const dashSpeed = clamp(trigger.speed * 0.9, 220, state.phase === 2 ? 520 : 460);
                const life = 1.2;
                const distance = dashSpeed * (life * 0.68);

                store.temporalEchoes.push({
                    bossId: b.instanceId,
                    x: trigger.position.x,
                    y: trigger.position.y,
                    vx: Math.cos(trigger.dir) * dashSpeed,
                    vy: Math.sin(trigger.dir) * dashSpeed,
                    distance,
                    traveled: 0,
                    radius: 18,
                    damage: 22 * dmgScale * (state.phase === 2 ? 1.35 : 1),
                    life,
                    maxLife: life,
                    phase: state.phase,
                    trailTimer: 0,
                    trailInterval: 0.08,
                    linger: 0.55,
                    stage: 'dash',
                    color: '#8cf5ff',
                    trailColor: '#2a9dff'
                });

                store.activeEffects.push(createEffect('spawnTeleport', trigger.position.x, trigger.position.y, 42, {
                    color: '#8cf5ff',
                    duration: 0.4
                }));
                // Sound removed - no temporal echo sound spam
            }

            function dropTimeShardsAlongPath(path, b, state) {
                ensureTemporalSystems();
                if (!path || path.length < 2) {
                    return;
                }

                const shardCount = state.phase === 2 ? 5 : 4;
                const segmentCount = path.length - 1;
                for (let i = 1; i <= shardCount; i++) {
                    const t = i / (shardCount + 1);
                    const position = t * segmentCount;
                    const index = Math.floor(position);
                    const frac = position - index;
                    const start = path[index];
                    const end = path[Math.min(segmentCount, index + 1)];
                    if (!start || !end) {
                        continue;
                    }

                    const shardX = start.x + (end.x - start.x) * frac;
                    const shardY = start.y + (end.y - start.y) * frac;

                    store.timeShards.push({
                        bossId: b.instanceId,
                        x: shardX,
                        y: shardY,
                        baseY: shardY,
                        r: 14,
                        pickupRadius: 24,
                        hp: 12,
                        maxHp: 12,
                        life: 8,
                        maxLife: 8,
                        buffStacks: 1,
                        sparkle: Math.random() * Math.PI * 2,
                        floatPhase: Math.random() * Math.PI * 2,
                        floatSpeed: 2.6,
                        dead: false
                    });

                    store.activeEffects.push(createEffect('spawnTeleport', shardX, shardY, 30, {
                        color: '#9df7ff',
                        duration: 0.45
                    }));
                }
            }

            function beginAsynchronosRewind(b, state) {
                const now = performance.now();
                const lookbackMs = (state.phase === 2 ? state.phaseRewindLookback : state.rewindLookback) * 1000;
                const targetTime = now - lookbackMs;
                const path = [{ x: b.x, y: b.y }];

                for (let i = state.bossHistory.length - 1; i >= 0; i--) {
                    const sample = state.bossHistory[i];
                    path.push({ x: sample.x, y: sample.y });
                    if (sample.t <= targetTime) {
                        break;
                    }
                }

                if (path.length < 3) {
                    state.rewindTimer = (state.phase === 2 ? state.phaseRewindInterval : state.baseRewindInterval) * 0.6;
                    return false;
                }

                state.rewindPath = path;
                state.rewindDuration = state.phase === 2 ? 0.5 : 0.65;
                state.rewindElapsed = 0;
                state.rewinding = true;
                state.rewindTimer = state.phase === 2 ? state.phaseRewindInterval : state.baseRewindInterval;
                b.isInvincible = true;

                dropTimeShardsAlongPath(path, b, state);
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(50, (b.r || 40) + 28), {
                    color: '#6ff2ff',
                    duration: 0.4
                }));
                // Thunder sound removed - only for Stormbringer
                return true;
            }

            function updateAsynchronosRewind(b, state, dt) {
                if (!state.rewinding || !state.rewindPath || state.rewindPath.length < 2) {
                    return;
                }

                state.rewindElapsed += dt;
                const duration = Math.max(0.001, state.rewindDuration);
                const progress = clamp(state.rewindElapsed / duration, 0, 1);
                const segments = state.rewindPath.length - 1;
                const position = progress * segments;
                const index = Math.floor(position);
                const frac = position - index;
                const start = state.rewindPath[index];
                const end = state.rewindPath[Math.min(segments, index + 1)];

                if (start && end) {
                    b.x = start.x + (end.x - start.x) * frac;
                    b.y = start.y + (end.y - start.y) * frac;
                }

                if (progress >= 1) {
                    state.rewinding = false;
                    state.rewindPath = null;
                    b.isInvincible = false;
                    store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(50, (b.r || 40) + 34), {
                        color: '#6ff2ff',
                        duration: 0.5
                    }));
                }
            }

            function updateAsynchronosBeam(b, state, dt) {
                ensureTemporalSystems();

                state.beamAngle = normalizeAngle(state.beamAngle + state.beamRotationSpeed * dt);
                state.beamSkipTimer -= dt;

                if (!state.beamTelegraphActive && state.beamSkipTimer <= state.beamTelegraphWindow) {
                    state.beamTelegraphActive = true;
                    store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(40, (b.r || 40) + 18), {
                        color: '#8cf5ff',
                        duration: state.beamTelegraphWindow
                    }));
                    // Sound removed - no telegraph sound spam
                }

                if (state.beamSkipTimer <= 0) {
                    state.beamAngle = normalizeAngle(state.beamAngle + state.beamSkipAngle);
                    state.beamSkipTimer += state.phase === 2 ? state.phaseBeamSkipInterval : state.baseBeamSkipInterval;
                    state.beamTelegraphActive = false;
                    state.skipPulseTimer = state.skipPulseDuration;
                    store.activeEffects.push(createEffect('spawnTeleport', b.x + Math.cos(state.beamAngle) * 60, b.y + Math.sin(state.beamAngle) * 60, 48, {
                        color: '#6ff2ff',
                        duration: 0.4
                    }));
                    // Sound removed - no beam skip sound spam
                }

                if (state.skipPulseTimer > 0) {
                    state.skipPulseTimer = Math.max(0, state.skipPulseTimer - dt);
                }

                const beam = store.temporalBeam;
                beam.anchorBossId = b.instanceId;
                beam.active = true;
                beam.angle = state.beamAngle;
                beam.width = state.phase === 2 ? 38 : 32;
                beam.telegraph = state.beamTelegraphActive ? clamp(1 - Math.max(0, state.beamSkipTimer) / state.beamTelegraphWindow, 0, 1) : 0;
                beam.skipPulse = state.skipPulseTimer > 0 ? state.skipPulseTimer / state.skipPulseDuration : 0;
                beam.rotationSpeed = state.beamRotationSpeed;
                beam.length = Math.max(W, H) + 120;
                beam.originOffset = state.rewinding ? 0.85 : 1;
            }

            function fireAsynchronosVolley(b, dmgScale, state) {
                const count = state.phase === 2 ? 12 : 8; // More projectiles
                const speed = state.phase === 2 ? 280 : 240; // Faster projectiles
                const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                const spread = state.phase === 2 ? 0.5 : 0.35; // Wider spread

                // Create warning indicator
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, Math.max(50, (b.r || 40) + 25), {
                    color: state.phase === 2 ? '#ff66aa' : '#66eaff',
                    duration: 0.4
                }));

                for (let i = 0; i < count; i++) {
                    const t = count > 1 ? i / (count - 1) : 0.5;
                    const offset = (t - 0.5) * spread;
                    const angle = baseAngle + offset;
                    const bullet = getEBulletFromPool({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: state.phase === 2 ? 5 : 4.5,
                        col: state.phase === 2 ? '#ff66ff' : '#66eaff',
                        dmg: 15 * dmgScale * (state.phase === 2 ? 1.3 : 1),
                        life: 4.5,
                        type: 'temporal_spear'
                    });
                    bullet.spin = (i - (count - 1) / 2) * 0.7;
                    store.eBullets.push(bullet);
                }
                
                // Phase 2: Add secondary radial burst
                if (state.phase === 2) {
                    const radialCount = 8;
                    const radialSpeed = 180;
                    for (let i = 0; i < radialCount; i++) {
                        const angle = (i / radialCount) * Math.PI * 2;
                        const bullet = getEBulletFromPool({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * radialSpeed,
                            vy: Math.sin(angle) * radialSpeed,
                            r: 3.5,
                            col: '#aa66ff',
                            dmg: 12 * dmgScale,
                            life: 3,
                            type: 'temporal_spear'
                        });
                        bullet.spin = i * 0.5;
                        store.eBullets.push(bullet);
                    }
                }
            }

            function performAsynchronosDash(b, state, dmgScale) {
                // Asynchronos teleports behind the player and dashes through them
                const player = store.player;
                if (!player) return;
                
                // Calculate position behind player
                const angleToPlayer = Math.atan2(player.y - b.y, player.x - b.x);
                const behindDistance = 280;
                const targetX = player.x - Math.cos(angleToPlayer) * behindDistance;
                const targetY = player.y - Math.sin(angleToPlayer) * behindDistance;
                
                // Clamp to screen bounds with padding
                const clampedX = clamp(targetX, 80, W - 80);
                const clampedY = clamp(targetY, 80, H - 200);
                
                // Teleport effect at current position
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, b.r * 1.8, {
                    color: '#6ff2ff',
                    duration: 0.5
                }));
                
                // Teleport boss
                b.x = clampedX;
                b.y = clampedY;
                
                // Arrival effect
                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, b.r * 2.2, {
                    color: '#ff6f6f',
                    duration: 0.6
                }));
                
                // Launch 3 waves of temporal spears in rapid succession toward player
                for (let wave = 0; wave < 3; wave++) {
                    setTimeout(() => {
                        if (!b || b.dead) return;
                        const count = 5;
                        const speed = 320;
                        const baseAngle = Math.atan2(player.y - b.y, player.x - b.x);
                        const spread = 0.6;
                        
                        for (let i = 0; i < count; i++) {
                            const t = count > 1 ? i / (count - 1) : 0.5;
                            const offset = (t - 0.5) * spread;
                            const angle = baseAngle + offset;
                            const bullet = getEBulletFromPool({
                                x: b.x,
                                y: b.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                r: 5,
                                col: wave === 0 ? '#ff6f6f' : wave === 1 ? '#ffaa6f' : '#ffff6f',
                                dmg: 14 * dmgScale,
                                life: 4,
                                type: 'temporal_spear'
                            });
                            bullet.spin = (i - (count - 1) / 2) * 0.8;
                            store.eBullets.push(bullet);
                        }
                    }, wave * 250);
                }
                
                announce('âš¡ ASYNCHRONOS WARPS BEHIND YOU!');
            }

            const GEMINI_CONFIG = Object.freeze({
                entryDuration: 1.65,
                sol: {
                    baseSpeed: 190,
                    enragedSpeed: 245,
                    radius: 56,
                    primaryCooldown: { base: 1.55, enraged: 1.05 },
                    waveCooldown: { base: 3.6, enraged: 2.4 },
                    spreadAngle: 0.28
                },
                luna: {
                    baseSpeed: 150,
                    retreatSpeed: 210,
                    radius: 50,
                    primaryCooldown: { base: 1.8, enraged: 1.25 },
                    shieldCooldown: { base: 12.5, enraged: 9.5 },
                    slowFieldCooldown: { base: 6.2, enraged: 4.4 }
                },
                shared: {
                    separation: 180,
                    minY: 105,
                    maxY: () => H * 0.55
                }
            });

            function ensureGeminiState(boss) {
                if (!boss) return null;
                if (boss.geminiState) {
                    return boss.geminiState;
                }

                const totalHp = Math.max(1, boss.hpMax || boss.baseHp || 8000);
                const solHpMax = totalHp * 0.55;
                const lunaHpMax = totalHp - solHpMax;
                const state = {
                    entry: {
                        duration: GEMINI_CONFIG.entryDuration,
                        progress: 0,
                        startY: -160,
                        targetSolY: 120,
                        targetLunaY: 110,
                        announced: false,
                        complete: false
                    },
                    sol: {
                        id: 'sol',
                        label: 'SOL',
                        x: W * 0.35,
                        y: -200,
                        hp: solHpMax,
                        hpMax: solHpMax,
                        radius: GEMINI_CONFIG.sol.radius,
                        fireTimer: GEMINI_CONFIG.sol.primaryCooldown.base,
                        waveTimer: GEMINI_CONFIG.sol.waveCooldown.base,
                        enraged: false,
                        shieldActive: false,
                        shieldTimer: 0,
                        shieldHp: 0,
                        defeated: false
                    },
                    luna: {
                        id: 'luna',
                        label: 'LUNA',
                        x: W * 0.65,
                        y: -220,
                        hp: lunaHpMax,
                        hpMax: lunaHpMax,
                        radius: GEMINI_CONFIG.luna.radius,
                        fireTimer: GEMINI_CONFIG.luna.primaryCooldown.base,
                        shieldCooldown: GEMINI_CONFIG.luna.shieldCooldown.base,
                        slowFieldCooldown: GEMINI_CONFIG.luna.slowFieldCooldown.base,
                        enraged: false,
                        defeated: false
                    },
                    timers: {
                        shared: 0,
                        announcementSol: false,
                        announcementLuna: false,
                        dualCallout: false
                    }
                };

                boss.geminiState = state;
                boss.hpMax = solHpMax + lunaHpMax;
                boss.hp = boss.hpMax;
                boss.r = Math.max(GEMINI_CONFIG.sol.radius, GEMINI_CONFIG.luna.radius) + 42;
                boss.isInvincible = true;
                boss.isEnraged = false;
                boss.x = (state.sol.x + state.luna.x) * 0.5;
                boss.y = (state.sol.y + state.luna.y) * 0.5;
                return state;
            }

            function geminiUpdateCenter(boss, state) {
                if (!boss || !state) return;
                boss.x = (state.sol.x + state.luna.x) * 0.5;
                boss.y = (state.sol.y + state.luna.y) * 0.5;
                boss.hp = Math.max(0, Math.max(0, state.sol.hp) + Math.max(0, state.luna.hp));
                boss.hpMax = Math.max(1, Math.max(0, state.sol.hpMax) + Math.max(0, state.luna.hpMax));
                boss.isEnraged = (!!state.sol.enraged && state.sol.hp > 0) || (!!state.luna.enraged && state.luna.hp > 0);
            }

            function getGeminiHitInfo(boss, point, padding = 0) {
                if (!boss || boss.behavior !== 'gemini' || !point) {
                    return null;
                }
                const state = ensureGeminiState(boss);
                if (!state || !state.entry.complete) {
                    return null;
                }

                let best = null;
                const subs = [state.sol, state.luna];
                for (let i = 0; i < subs.length; i++) {
                    const sub = subs[i];
                    if (!sub || sub.hp <= 0) continue;
                    const radius = Math.max(12, (sub.radius || 50) + padding);
                    const dx = point.x - sub.x;
                    const dy = point.y - sub.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= radius * radius) {
                        if (!best || distSq < best.distSq) {
                            best = { id: sub.id, x: sub.x, y: sub.y, radius, distSq };
                        }
                    }
                }
                return best;
            }

            const VIBEMASTER_CONFIG = Object.freeze({
                ring: { thickness: 18, speed: 90, damage: 20, segments: 12, cooldown: { 1: 6.2, 2: 5.1, 3: 3.6 } },
                astral: {
                    homingStrength: 110,
                    maxSpeed: 240,
                    shardAccel: 240,
                    shardMaxSpeed: 560,
                    shardLife: 6,
                    cooldown: { 1: 4.2, 2: 3.0, 3: 2.0 },
                    volley: { 1: 3, 2: 4, 3: 5 }
                },
                barrier: { cooldown: 12.5, duration: 8, hpPercent: 0.12, rotationSpeed: 1.1 },
                threads: { cooldown: 14, life: 7.5, width: 26, slowStrength: 0.45, count: 4 },
                distortion: { cooldown: 17, duration: 4.4 },
                guardians: { cooldown: 18, hp: 420, fireCooldown: 1.6, contactDamage: 22 },
                ritual: { cooldown: 23, duration: 6, healPerSecond: 0.034, shieldPercent: 0.14, beamWidth: 0.32 },
                vacuum: { duration: 4.5, strength: 320, threshold: 0.12, sphereSpeed: 72 },
                beam: { damage: 24 }
            });

            function ensureVibemasterState(boss) {
                if (!boss) return null;
                if (boss.vibeState) return boss.vibeState;

                const state = {
                    phase: 1,
                    timers: {
                        chakra: 3.0,
                        astral: 2.8,
                        barrier: 5.5,
                        threads: 8,
                        distortion: 11,
                        guardians: 6,
                        ritual: 18
                    },
                    rings: [],
                    threads: [],
                    guardians: [],
                    barrier: null,
                    distortion: null,
                    ritual: null,
                    vacuum: null,
                    nextRingPattern: 0,
                    implosionTriggered: false,
                    phaseAnnouncements: { 2: false, 3: false }
                };

                state.rings = state.rings;
                state.threads = state.threads;
                state.guardians = state.guardians;

                store.vibemasterRings = state.rings;
                store.vibemasterThreads = state.threads;
                store.vibemasterGuardians = state.guardians;
                store.vibemasterDistortion = null;
                store.vibemasterVacuum = null;

                boss.vibeState = state;
                return state;
            }

            function vibemasterRingCooldown(phase) {
                return VIBEMASTER_CONFIG.ring.cooldown[phase] || VIBEMASTER_CONFIG.ring.cooldown[1];
            }

            function vibemasterAstralCooldown(phase) {
                return VIBEMASTER_CONFIG.astral.cooldown[phase] || VIBEMASTER_CONFIG.astral.cooldown[1];
            }

            function vibemasterAstralVolleySize(phase) {
                return VIBEMASTER_CONFIG.astral.volley[phase] || VIBEMASTER_CONFIG.astral.volley[1];
            }

            function spawnVibemasterRing(boss, state) {
                const ring = {
                    x: boss.x,
                    y: boss.y,
                    radius: Math.max(30, boss.r * 0.7),
                    speed: VIBEMASTER_CONFIG.ring.speed,
                    thickness: VIBEMASTER_CONFIG.ring.thickness,
                    life: 10,
                    maxLife: 10,
                    pattern: state.nextRingPattern || 0,
                    segmentCount: VIBEMASTER_CONFIG.ring.segments,
                    hitCooldown: 0,
                    pulse: Math.random() * Math.PI * 2
                };
                state.nextRingPattern = (ring.pattern + 1) % 2;
                state.rings.push(ring);
                store.vibemasterRings = state.rings;
                
                // Body pulse when spawning ring (chest expansion)
                if (!state.chakraChargeActive) {
                    state.chakraChargeActive = true;
                    setTimeout(() => { state.chakraChargeActive = false; }, 600);
                }
                
                store.activeEffects.push(createEffect('spawnTeleport', boss.x, boss.y, boss.r + 30, { color: '#b8c7ff', duration: 0.4 }));
            }

            function updateVibemasterRings(dt, boss, state, dmgScale) {
                const rings = state.rings;
                if (!rings || !rings.length) return;
                const player = store.player;
                for (let i = rings.length - 1; i >= 0; i--) {
                    const ring = rings[i];
                    ring.radius += ring.speed * dt;
                    ring.life -= dt;
                    ring.hitCooldown = Math.max(0, ring.hitCooldown - dt);
                    ring.pulse += dt * 2.4;
                    if (player) {
                        const dx = player.x - ring.x;
                        const dy = player.y - ring.y;
                        const dist = Math.hypot(dx, dy);
                        const thickness = ring.thickness;
                        if (dist >= ring.radius - thickness * 0.5 && dist <= ring.radius + thickness * 0.5) {
                            const angle = Math.atan2(dy, dx);
                            const segmentAngle = (Math.PI * 2) / Math.max(1, ring.segmentCount);
                            let idx = Math.floor((angle < 0 ? angle + Math.PI * 2 : angle) / segmentAngle);
                            idx = Math.max(0, idx);
                            const isSolid = ((idx + ring.pattern) % 2) === 0;
                            if (isSolid && ring.hitCooldown <= 0) {
                                takeDamage(VIBEMASTER_CONFIG.ring.damage * dmgScale);
                                ring.hitCooldown = 0.35;
                                store.activeEffects.push(createEffect('hurtPulse', player.x, player.y, (player.r || 16) * 1.6, { color: '#d6a9ff', duration: 0.25 }));
                            }
                        }
                    }
                    if (ring.life <= 0 || ring.radius > Math.max(W, H) * 1.2) {
                        rings.splice(i, 1);
                    }
                }
            }

            function spawnVibemasterAstralVolley(boss, state, dmgScale, options = {}) {
                const count = options.count || vibemasterAstralVolleySize(state.phase);
                const topMargin = 50;
                for (let i = 0; i < count; i++) {
                    const side = i % 2 === 0 ? -1 : 1;
                    const baseX = side < 0 ? 40 + Math.random() * 80 : W - 40 - Math.random() * 80;
                    const bullet = getEBulletFromPool({
                        x: baseX,
                        y: topMargin + Math.random() * 40,
                        vx: 0,
                        vy: 70 + Math.random() * 30,
                        r: 6,
                        col: '#a8efff',
                        dmg: 14 * dmgScale,
                        life: 7,
                        path: 'vibemaster_bloop',
                        homingStrength: VIBEMASTER_CONFIG.astral.homingStrength * (state.phase >= 3 ? 1.25 : 1),
                        maxSpeed: VIBEMASTER_CONFIG.astral.maxSpeed * (state.phase >= 3 ? 1.2 : 1),
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                    store.eBullets.push(bullet);
                }
                
                // Signal hand gesture for visual telegraph
                if (!state.astralGestureActive) {
                    state.astralGestureActive = true;
                    setTimeout(() => { state.astralGestureActive = false; }, 800);
                }
            }

            function spawnVibemasterShardBurst(boss, state, dmgScale) {
                const player = store.player;
                const baseAngle = player ? Math.atan2(player.y - boss.y, player.x - boss.x) : -Math.PI / 2;
                const count = state.phase >= 3 ? 7 : 5;
                const spread = 0.55 + state.phase * 0.1;
                for (let i = 0; i < count; i++) {
                    const t = count === 1 ? 0 : (i / (count - 1) - 0.5);
                    const angle = baseAngle + t * spread;
                    const speed = 200 + state.phase * 40;
                    const shard = getEBulletFromPool({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: 5,
                        col: '#d9f4ff',
                        dmg: 17 * dmgScale,
                        life: VIBEMASTER_CONFIG.astral.shardLife,
                        path: 'vibemaster_shard',
                        accel: VIBEMASTER_CONFIG.astral.shardAccel,
                        maxSpeed: VIBEMASTER_CONFIG.astral.shardMaxSpeed
                    });
                    store.eBullets.push(shard);
                }
            }

            function startVibemasterBarrier(boss, state) {
                const maxHp = boss.hpMax * VIBEMASTER_CONFIG.barrier.hpPercent;
                state.barrier = {
                    active: true,
                    hp: maxHp,
                    maxHp,
                    timer: VIBEMASTER_CONFIG.barrier.duration,
                    angle: 0,
                    rotationSpeed: VIBEMASTER_CONFIG.barrier.rotationSpeed,
                    hitPulse: 0
                };
                store.activeEffects.push(createEffect('spawnTeleport', boss.x, boss.y, boss.r + 40, { color: '#bca7ff', duration: 0.6 }));
                announce('The VIBEMASTER retreats behind a meditative barrier!');
            }

            function updateVibemasterBarrier(dt, boss, state) {
                const barrier = state.barrier;
                if (!barrier || !barrier.active) return;
                barrier.timer -= dt;
                barrier.angle += dt * barrier.rotationSpeed;
                if (barrier.hitPulse) barrier.hitPulse = Math.max(0, barrier.hitPulse - dt * 3.2);
                if (barrier.timer <= 0 || barrier.hp <= 0) {
                    store.activeEffects.push(createEffect('shieldBreak', boss.x, boss.y, boss.r + 42));
                    state.barrier = null;
                }
            }

            function spawnVibemasterThreads(boss, state) {
                const count = VIBEMASTER_CONFIG.threads.count + (state.phase >= 3 ? 1 : 0);
                for (let i = 0; i < count; i++) {
                    const startX = 80 + Math.random() * (W - 160);
                    const startY = H * 0.28 + Math.random() * (H * 0.32);
                    const angle = (Math.random() - 0.5) * 1.2;
                    const length = 140 + Math.random() * 200;
                    const endX = startX + Math.cos(angle) * length;
                    const endY = startY + Math.sin(angle) * length;
                    state.threads.push({
                        startX,
                        startY,
                        endX,
                        endY,
                        width: VIBEMASTER_CONFIG.threads.width,
                        life: VIBEMASTER_CONFIG.threads.life,
                        maxLife: VIBEMASTER_CONFIG.threads.life,
                        pulse: Math.random() * Math.PI * 2
                    });
                }
                store.vibemasterThreads = state.threads;
                store.activeEffects.push(createEffect('spawnTeleport', boss.x, boss.y + boss.r * 0.6, boss.r + 60, { color: '#8ff5ff', duration: 0.55 }));
                
                // Rapid hand weaving gesture
                if (!state.threadWeavingActive) {
                    state.threadWeavingActive = true;
                    setTimeout(() => { state.threadWeavingActive = false; }, 1200);
                }
                
                announce('ðŸ•¸ï¸ Cosmic threads constrict your path! ðŸ•¸ï¸');
            }

            function vibemasterDistanceToSegmentSq(px, py, x1, y1, x2, y2) {
                const vx = x2 - x1;
                const vy = y2 - y1;
                const lenSq = vx * vx + vy * vy;
                if (lenSq === 0) {
                    const dx = px - x1;
                    const dy = py - y1;
                    return dx * dx + dy * dy;
                }
                let t = ((px - x1) * vx + (py - y1) * vy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const cx = x1 + vx * t;
                const cy = y1 + vy * t;
                const dx = px - cx;
                const dy = py - cy;
                return dx * dx + dy * dy;
            }

            function updateVibemasterThreads(dt, boss, state) {
                const threads = state.threads;
                if (!threads || !threads.length) return;
                const player = store.player;
                for (let i = threads.length - 1; i >= 0; i--) {
                    const thread = threads[i];
                    thread.life -= dt;
                    thread.pulse += dt * 2.8;
                    if (thread.life <= 0) {
                        threads.splice(i, 1);
                        continue;
                    }
                    if (!player) continue;
                    const distSq = vibemasterDistanceToSegmentSq(player.x, player.y, thread.startX, thread.startY, thread.endX, thread.endY);
                    const effective = thread.width + (player.r || 16);
                    if (distSq <= effective * effective) {
                        player.vibeThreadSlowStrength = Math.min(player.vibeThreadSlowStrength || 1, VIBEMASTER_CONFIG.threads.slowStrength);
                        player.vibeThreadSlowTimer = Math.max(player.vibeThreadSlowTimer || 0, 0.32);
                    }
                }
            }

            function spawnVibemasterGuardians(boss, state, dmgScale) {
                const alive = state.guardians.filter(g => !g.dead);
                const desired = 2;
                const toSpawn = Math.max(0, desired - alive.length);
                if (toSpawn <= 0) return;
                for (let i = 0; i < toSpawn; i++) {
                    const side = (alive.length + i) % 2 === 0 ? -1 : 1;
                    const guardian = {
                        id: `vibe-guardian-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 6)}`,
                        side,
                        x: side < 0 ? 90 : W - 90,
                        y: H * 0.32 + (alive.length + i) * 40,
                        baseX: side < 0 ? 120 : W - 120,
                        baseY: H * 0.32 + (alive.length + i) * 40,
                        hp: VIBEMASTER_CONFIG.guardians.hp,
                        hpMax: VIBEMASTER_CONFIG.guardians.hp,
                        fireTimer: 0.8 + i * 0.4,
                        movePhase: Math.random() * Math.PI * 2,
                        hitPulse: 0,
                        dmgScale,
                        touchCooldown: 0,
                        color: side < 0 ? '#9de7ff' : '#ffdea8'
                    };
                    state.guardians.push(guardian);
                    store.activeEffects.push(createEffect('spawnTeleport', guardian.x, guardian.y, 38, { color: guardian.color, duration: 0.5 }));
                }
                store.vibemasterGuardians = state.guardians;
                announce('Spirit guardians join the fray!');
            }

            function updateVibemasterGuardians(dt, boss, state, dmgScale) {
                const guardians = state.guardians;
                if (!guardians || !guardians.length) return;
                const player = store.player;
                for (let i = guardians.length - 1; i >= 0; i--) {
                    const guardian = guardians[i];
                    if (!guardian || guardian.dead) {
                        guardians.splice(i, 1);
                        continue;
                    }
                    guardian.movePhase += dt * (1.8 + state.phase * 0.2);
                    const amplitude = 70 + state.phase * 10;
                    guardian.x = guardian.baseX + Math.sin(guardian.movePhase) * amplitude;
                    guardian.y = guardian.baseY + Math.cos(guardian.movePhase * 0.8) * 40;
                    if (guardian.hitPulse) guardian.hitPulse = Math.max(0, guardian.hitPulse - dt * 3.1);
                    guardian.fireTimer -= dt;
                    if (guardian.fireTimer <= 0) {
                        const speed = 250 + state.phase * 40;
                        const vy = Math.sin(guardian.movePhase * 1.5) * 60;
                        const beam = getEBulletFromPool({
                            x: guardian.x,
                            y: guardian.y,
                            vx: guardian.side * speed,
                            vy,
                            r: 5,
                            col: '#ffe7b8',
                            dmg: (VIBEMASTER_CONFIG.guardians.contactDamage || 22) * dmgScale * 0.6,
                            life: 4,
                            path: 'vibemaster_guardian_beam',
                            fadeRate: 0.22
                        });
                        beam.alpha = 1;
                        store.eBullets.push(beam);
                        guardian.fireTimer = Math.max(0.85, VIBEMASTER_CONFIG.guardians.fireCooldown - state.phase * 0.18);
                    }
                    if (guardian.touchCooldown > 0) guardian.touchCooldown = Math.max(0, guardian.touchCooldown - dt);
                    if (player && !player.isInvincible) {
                        const radius = 26;
                        const dx = player.x - guardian.x;
                        const dy = player.y - guardian.y;
                        const distSq = dx * dx + dy * dy;
                        const combined = (player.r || 16) + radius;
                        if (distSq <= combined * combined && guardian.touchCooldown <= 0) {
                            takeDamage(VIBEMASTER_CONFIG.guardians.contactDamage * dmgScale);
                            guardian.touchCooldown = 0.9;
                        }
                    }
                    for (let bi = store.bullets.length - 1; bi >= 0; bi--) {
                        const bullet = store.bullets[bi];
                        if (!bullet || bullet.dead) continue;
                        const dx = bullet.x - guardian.x;
                        const dy = bullet.y - guardian.y;
                        const distSq = dx * dx + dy * dy;
                        const hitRadius = (bullet.r || 3) + 20;
                        if (distSq <= hitRadius * hitRadius) {
                            const damage = bullet.dmg || 12;
                            guardian.hp -= damage;
                            guardian.hitPulse = 0.4;
                            if (!bullet.pierce) bullet.dead = true;
                            spawnHitParticles(guardian.x, guardian.y, guardian.color, { count: 10, scale: 0.6 });
                            if (store.player.vampirism > 0) {
                                let heal = damage * store.player.vampirism;
                                heal = Math.max(heal, 1);
                                heal = Math.min(heal, 4);
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + heal);
                            }
                            if (guardian.hp <= 0) {
                                guardian.dead = true;
                                store.activeEffects.push(createEffect('spawnTeleport', guardian.x, guardian.y, 60, { color: guardian.color, duration: 0.6 }));
                                addWorldGold(5);
                                store.world.score += 120;
                                guardians.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }

            function startVibemasterDistortion(boss, state) {
                state.distortion = {
                    active: true,
                    timer: VIBEMASTER_CONFIG.distortion.duration,
                    duration: VIBEMASTER_CONFIG.distortion.duration,
                    shardTimer: 0.4
                };
                store.vibemasterDistortion = state.distortion;
                store.activeEffects.push(createEffect('screenFlash', boss.x, boss.y, 1, 'rgba(150, 100, 255, 0.35)'));
                announce('âœ¨ The VIBEMASTER opens the Eye of Illusion! âœ¨');
                playSound('trap'); // Eye opening sound
            }

            function updateVibemasterDistortion(dt, boss, state, dmgScale) {
                const distortion = state.distortion;
                if (!distortion || !distortion.active) return;
                distortion.timer -= dt;
                distortion.shardTimer -= dt;
                if (distortion.shardTimer <= 0) {
                    spawnVibemasterShardBurst(boss, state, dmgScale);
                    distortion.shardTimer = Math.max(0.32, state.phase >= 3 ? 0.35 : 0.45);
                }
                if (distortion.timer <= 0) {
                    state.distortion = null;
                    store.vibemasterDistortion = null;
                } else {
                    store.vibemasterDistortion = distortion;
                }
            }

            function vibemasterNormalizeAngle(angle) {
                const twoPi = Math.PI * 2;
                let result = ((angle % twoPi) + twoPi) % twoPi;
                if (result > Math.PI) result -= twoPi;
                return result;
            }

            function startVibemasterRitual(boss, state) {
                const maxHp = boss.hpMax * VIBEMASTER_CONFIG.ritual.shieldPercent;
                state.ritual = {
                    active: true,
                    timer: VIBEMASTER_CONFIG.ritual.duration,
                    duration: VIBEMASTER_CONFIG.ritual.duration,
                    hp: maxHp,
                    maxHp,
                    beamAngle: -Math.PI / 2,
                    beamDir: 1,
                    damageCooldown: 0,
                    hitPulse: 0
                };
                store.activeEffects.push(createEffect('bossPhaseChange', boss.x, boss.y));
                announce('The VIBEMASTER begins a rejuvenation ritual!');
            }

            function applyVibemasterBeamDamage(boss, ritual, dmgScale) {
                const player = store.player;
                if (!player || player.isInvincible) return;
                const dx = player.x - boss.x;
                const dy = player.y - boss.y;
                const dist = Math.hypot(dx, dy);
                if (dist <= 24) return;
                const angleToPlayer = Math.atan2(dy, dx);
                const diff = Math.abs(vibemasterNormalizeAngle(angleToPlayer - ritual.beamAngle));
                const width = VIBEMASTER_CONFIG.ritual.beamWidth;
                if (diff <= width) {
                    if (ritual.damageCooldown <= 0) {
                        takeDamage(VIBEMASTER_CONFIG.beam.damage * dmgScale);
                        ritual.damageCooldown = 0.35;
                        store.activeEffects.push(createEffect('hurtPulse', player.x, player.y, (player.r || 16) * 1.9, { color: '#8fe9ff', duration: 0.3 }));
                    }
                }
            }

            function endVibemasterRitual(boss, state, options = {}) {
                if (!state.ritual || !state.ritual.active) return;
                const broken = options.broken;
                if (broken) {
                    announce('Ritual interrupted!');
                }
                store.activeEffects.push(createEffect('shieldBreak', boss.x, boss.y, boss.r + 36, { color: broken ? '#ffd2ff' : '#bffaff', duration: 0.5 }));
                state.ritual = null;
            }

            function updateVibemasterRitual(dt, boss, state, dmgScale) {
                const ritual = state.ritual;
                if (!ritual || !ritual.active) return;
                ritual.timer -= dt;
                if (ritual.hitPulse) ritual.hitPulse = Math.max(0, ritual.hitPulse - dt * 3.1);
                if (ritual.damageCooldown > 0) ritual.damageCooldown = Math.max(0, ritual.damageCooldown - dt);
                const heal = VIBEMASTER_CONFIG.ritual.healPerSecond;
                if (heal > 0 && boss.hp < boss.hpMax) {
                    boss.hp = Math.min(boss.hpMax, boss.hp + boss.hpMax * heal * dt);
                }
                const sweepSpeed = state.phase >= 3 ? 1.25 : 0.95;
                ritual.beamAngle += sweepSpeed * ritual.beamDir * dt;
                if (ritual.beamAngle > Math.PI * 0.65) {
                    ritual.beamAngle = Math.PI * 0.65;
                    ritual.beamDir = -1;
                } else if (ritual.beamAngle < -Math.PI * 0.65) {
                    ritual.beamAngle = -Math.PI * 0.65;
                    ritual.beamDir = 1;
                }
                applyVibemasterBeamDamage(boss, ritual, dmgScale);
                if (ritual.timer <= 0 || ritual.hp <= 0) {
                    endVibemasterRitual(boss, state, { broken: ritual.hp <= 0 });
                }
            }

            function triggerVibemasterImplosion(boss, state, dmgScale) {
                if (state.implosionTriggered) return;
                state.implosionTriggered = true;
                state.vacuum = {
                    active: true,
                    timer: VIBEMASTER_CONFIG.vacuum.duration,
                    duration: VIBEMASTER_CONFIG.vacuum.duration,
                    strength: VIBEMASTER_CONFIG.vacuum.strength
                };
                store.vibemasterVacuum = state.vacuum;
                const sphere = getEBulletFromPool({
                    x: boss.x,
                    y: boss.y + boss.r * 0.6,
                    vx: 0,
                    vy: VIBEMASTER_CONFIG.vacuum.sphereSpeed,
                    r: 26,
                    col: '#ffe8ff',
                    dmg: 32 * dmgScale,
                    life: VIBEMASTER_CONFIG.vacuum.duration + 2,
                    path: 'vibemaster_implosion',
                    growSpeed: 22
                });
                sphere.alpha = 0.85;
                store.eBullets.push(sphere);
                if (typeof screenFlash === 'function') {
                    screenFlash(2, 180, 'rgba(180, 120, 255, 0.45)');
                }
                announce('Grand implosion pulls everything to the center!');
            }

            function updateVibemasterVacuum(dt, boss, state) {
                const vacuum = state.vacuum;
                if (!vacuum || !vacuum.active) return;
                vacuum.timer -= dt;
                const player = store.player;
                if (player && !player.isInvincible) {
                    const dx = boss.x - player.x;
                    const dy = boss.y - player.y;
                    const dist = Math.max(30, Math.hypot(dx, dy));
                    const pull = vacuum.strength * dt / dist;
                    player.x += dx * pull;
                    player.y += dy * pull;
                    player.x = clamp(player.x, 20, W - 20);
                    player.y = clamp(player.y, 40, H - 40);
                }
                if (vacuum.timer <= 0) {
                    state.vacuum = null;
                    store.vibemasterVacuum = null;
                } else {
                    store.vibemasterVacuum = vacuum;
                }
            }

            function applyVibemasterDamage(boss, amount, options = {}) {
                const state = ensureVibemasterState(boss);
                if (!state) return { amount, blocked: false };

                if (state.barrier && state.barrier.active) {
                    state.barrier.hp = Math.max(0, state.barrier.hp - amount);
                    state.barrier.hitPulse = 0.35;
                    const impactX = options.point?.x ?? boss.x;
                    const impactY = options.point?.y ?? boss.y;
                    store.activeEffects.push(createEffect('shieldHit', impactX, impactY, boss.r + 30));
                    if (state.barrier.hp <= 0) {
                        store.activeEffects.push(createEffect('shieldBreak', boss.x, boss.y, boss.r + 42));
                        state.barrier = null;
                    }
                    return { amount: 0, blocked: true };
                }

                if (state.ritual && state.ritual.active) {
                    state.ritual.hp = Math.max(0, state.ritual.hp - amount);
                    state.ritual.hitPulse = 0.4;
                    if (state.ritual.hp <= 0) {
                        endVibemasterRitual(boss, state, { broken: true });
                    }
                    return { amount: 0, blocked: true };
                }

                return null;
            }

            function stepBossVibemaster(dt, boss, dmgScale) {
                const state = ensureVibemasterState(boss);
                if (!state) return;

                // Smooth side-to-side movement
                const time = performance.now() / 1000;
                const targetX = W / 2 + Math.sin(time * 0.6) * 180; // Glide left/right 180px
                const targetY = Math.max(110, H * 0.24);
                boss.x += (targetX - boss.x) * Math.min(1, dt * 2.4);
                boss.y += (targetY - boss.y) * Math.min(1, dt * 1.8);

                const hpRatio = boss.hpMax > 0 ? clamp(boss.hp / boss.hpMax, 0, 1) : 1;
                if (state.phase === 1 && hpRatio <= 0.7) {
                    state.phase = 2;
                    state.timers.distortion = 4.5;
                    state.timers.threads = 2.5;
                    state.timers.guardians = 3.2;
                    if (!state.phaseAnnouncements[2]) {
                        announce('The VIBEMASTER weaves chaotic cascades!');
                        state.phaseAnnouncements[2] = true;
                    }
                }
                if (state.phase < 3 && hpRatio <= 0.3) {
                    state.phase = 3;
                    boss.isEnraged = true;
                    state.timers.ritual = 5;
                    state.timers.chakra = Math.min(state.timers.chakra, 2.6);
                    state.timers.astral = Math.min(state.timers.astral, 1.8);
                    if (!state.phaseAnnouncements[3]) {
                        announce('Nirvana\'s Fury ignites!');
                        state.phaseAnnouncements[3] = true;
                    }
                }
                if (!state.implosionTriggered && hpRatio <= VIBEMASTER_CONFIG.vacuum.threshold) {
                    triggerVibemasterImplosion(boss, state, dmgScale);
                }

                state.timers.chakra -= dt;
                state.timers.astral -= dt;
                state.timers.barrier -= dt;
                state.timers.threads -= dt;
                state.timers.distortion -= dt;
                state.timers.guardians -= dt;
                if (state.phase >= 3) {
                    state.timers.ritual -= dt;
                }

                if (state.timers.chakra <= 0) {
                    spawnVibemasterRing(boss, state);
                    state.timers.chakra = vibemasterRingCooldown(state.phase);
                }

                if (state.timers.astral <= 0) {
                    spawnVibemasterAstralVolley(boss, state, dmgScale, {});
                    const baseCooldown = vibemasterAstralCooldown(state.phase);
                    state.timers.astral = state.distortion && state.distortion.active ? Math.max(1.1, baseCooldown * 0.6) : baseCooldown;
                }

                if ((!state.barrier || !state.barrier.active) && state.timers.barrier <= 0) {
                    startVibemasterBarrier(boss, state);
                    state.timers.barrier = VIBEMASTER_CONFIG.barrier.cooldown + (state.phase >= 3 ? 0 : 1.5);
                }

                if (state.phase >= 2 && state.timers.threads <= 0) {
                    spawnVibemasterThreads(boss, state);
                    state.timers.threads = VIBEMASTER_CONFIG.threads.cooldown;
                }

                if (state.phase >= 2 && state.timers.distortion <= 0 && (!state.distortion || !state.distortion.active)) {
                    startVibemasterDistortion(boss, state);
                    state.timers.distortion = VIBEMASTER_CONFIG.distortion.cooldown;
                }

                if (state.phase >= 2 && state.timers.guardians <= 0) {
                    spawnVibemasterGuardians(boss, state, dmgScale);
                    state.timers.guardians = VIBEMASTER_CONFIG.guardians.cooldown;
                }

                if (state.phase >= 3 && state.timers.ritual <= 0 && (!state.ritual || !state.ritual.active)) {
                    startVibemasterRitual(boss, state);
                    state.timers.ritual = VIBEMASTER_CONFIG.ritual.cooldown;
                }

                updateVibemasterRings(dt, boss, state, dmgScale);
                updateVibemasterBarrier(dt, boss, state);
                updateVibemasterThreads(dt, boss, state);
                updateVibemasterGuardians(dt, boss, state, dmgScale);
                updateVibemasterDistortion(dt, boss, state, dmgScale);
                updateVibemasterVacuum(dt, boss, state);
                if (state.ritual && state.ritual.active) {
                    updateVibemasterRitual(dt, boss, state, dmgScale);
                }
            }

            function applyGeminiBossDamage(boss, amount, options = {}) {
                const state = ensureGeminiState(boss);
                if (!state) {
                    return { amount: 0, blocked: true };
                }
                if (!state.entry.complete && !options.ignoreEntry) {
                    return { amount: 0, blocked: true };
                }
                let targetKey = options.subBoss || (options.point ? (getGeminiHitInfo(boss, options.point)?.id) : null) || 'sol';
                let target = targetKey === 'luna' ? state.luna : state.sol;
                if (!target || target.hp <= 0) {
                    targetKey = targetKey === 'luna' ? 'sol' : 'luna';
                    target = targetKey === 'luna' ? state.luna : state.sol;
                    if (!target || target.hp <= 0) {
                        return { amount: 0, blocked: true };
                    }
                }

                let remaining = Math.max(0, amount);
                let applied = 0;
                if (target.id === 'sol' && target.shieldActive && target.shieldHp > 0) {
                    const absorbed = Math.min(target.shieldHp, remaining);
                    target.shieldHp -= absorbed;
                    remaining -= absorbed;
                    if (target.shieldHp <= 0) {
                        target.shieldActive = false;
                        target.shieldTimer = 0;
                        store.activeEffects.push(createEffect('spawnTeleport', target.x, target.y, target.radius + 24, {
                            color: '#66f2ff',
                            duration: 0.5
                        }));
                    }
                    if (remaining <= 0) {
                        geminiUpdateCenter(boss, state);
                        return { amount: 0, blocked: true };
                    }
                }

                const hpBefore = target.hp;
                target.hp = Math.max(0, target.hp - remaining);
                applied = Math.max(0, hpBefore - target.hp);
                if (target.hp <= 0 && !target.defeated) {
                    target.defeated = true;
                    target.defeatTime = performance.now();
                    store.activeEffects.push(createEffect('bossPhaseChange', target.x, target.y));
                }

                store.world.totalDamage += applied;
                geminiUpdateCenter(boss, state);

                if (boss.hp <= 0) {
                    handleBossDefeat();
                }

                return { amount: applied, blocked: applied <= 0 };
            }

            function testGeminiBulletCollision(boss, bullet) {
                if (!bullet) return null;
                return getGeminiHitInfo(boss, { x: bullet.x, y: bullet.y }, bullet.r || 0);
            }

            function spawnGeminiSlowField({ x, y, radius, slowFactor, duration }) {
                if (!store.geminiSlowFields) {
                    store.geminiSlowFields = [];
                }
                const field = {
                    x: clamp(x, 80, W - 80),
                    y: clamp(y, 90, H - 120),
                    radius: radius,
                    maxRadius: radius,
                    slowFactor: clamp(slowFactor, 0.3, 0.9),
                    life: duration,
                    maxLife: duration,
                    pulse: Math.random() * Math.PI * 2
                };
                store.geminiSlowFields.push(field);
                store.activeEffects.push(createEffect('spawnTeleport', field.x, field.y, radius * 0.75, {
                    color: '#66f2ff',
                    duration: 0.6
                }));
                return field;
            }

            function stepGeminiSlowFields(dt) {
                const fields = store.geminiSlowFields;
                if (!fields || !fields.length) return;
                for (let i = fields.length - 1; i >= 0; i--) {
                    const field = fields[i];
                    field.life -= dt;
                    field.pulse += dt * 2.4;
                    if (field.life <= 0) {
                        fields.splice(i, 1);
                    }
                }
            }

            function drawGeminiSlowFields() {
                const fields = store.geminiSlowFields;
                if (!fields || !fields.length) return;
                const now = performance.now() / 1000;
                fields.forEach(field => {
                    const lifeRatio = clamp(field.life / field.maxLife, 0, 1);
                    const pulseScale = 1 + Math.sin(field.pulse + now * 0.8) * 0.08;
                    const radius = field.radius * pulseScale;
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.45 * lifeRatio;
                    const gradient = ctx.createRadialGradient(field.x, field.y, radius * 0.2, field.x, field.y, radius);
                    gradient.addColorStop(0, 'rgba(140, 230, 255, 0.7)');
                    gradient.addColorStop(0.6, 'rgba(120, 200, 255, 0.35)');
                    gradient.addColorStop(1, 'rgba(120, 200, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(field.x, field.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }

            function computeGeminiSlowMultiplier(player) {
                if (!player) return 1;
                let multiplier = 1;
                if (player.geminiHitSlowTimer && player.geminiHitSlowTimer > 0) {
                    const hitStrength = clamp(player.geminiHitSlowStrength || 0.6, 0.25, 0.95);
                    multiplier = Math.min(multiplier, hitStrength);
                }
                const fields = store.geminiSlowFields;
                if (fields && fields.length) {
                    for (let i = 0; i < fields.length; i++) {
                        const field = fields[i];
                        const dx = player.x - field.x;
                        const dy = player.y - field.y;
                        const distSq = dx * dx + dy * dy;
                        const radius = field.radius;
                        if (distSq <= radius * radius) {
                            const dist = Math.sqrt(distSq);
                            const ratio = clamp(dist / radius, 0, 1);
                            const factor = field.slowFactor + (1 - field.slowFactor) * ratio;
                            multiplier = Math.min(multiplier, factor);
                        }
                    }
                }
                return clamp(multiplier, 0.3, 1);
            }

            function applyGeminiHitSlow(player, strength, duration) {
                if (!player) return;
                const clampedStrength = clamp(strength, 0.25, 0.95);
                const clampedDuration = Math.max(0.3, duration);
                player.geminiHitSlowStrength = Math.min(player.geminiHitSlowStrength || 1, clampedStrength);
                player.geminiHitSlowTimer = Math.max(player.geminiHitSlowTimer || 0, clampedDuration);
            }

            function geminiFireSolPrimary(boss, state, dmgScale, angle) {
                const sol = state.sol;
                const speed = sol.enraged ? 280 : 240;
                const bullet = getEBulletFromPool({
                    x: sol.x,
                    y: sol.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    r: sol.enraged ? 9 : 7,
                    col: sol.enraged ? '#ff7b26' : '#ffc968',
                    dmg: (sol.enraged ? 26 : 22) * dmgScale,
                    life: 4.2,
                    geminiTag: 'sol_fire',
                    homeDuration: sol.enraged ? 0.75 : 0.5,
                    homeStrength: sol.enraged ? 190 : 150
                });
                store.eBullets.push(bullet);
                store.activeEffects.push(createEffect('spawnTeleport', sol.x, sol.y, sol.radius * 0.85, {
                    color: '#ffb35a',
                    duration: 0.3
                }));
            }

            function geminiFireSolWave(boss, state, dmgScale) {
                const sol = state.sol;
                const count = sol.enraged ? 12 : 8;
                const baseSpeed = sol.enraged ? 220 : 190;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const bullet = getEBulletFromPool({
                        x: sol.x,
                        y: sol.y,
                        vx: Math.cos(angle) * baseSpeed,
                        vy: Math.sin(angle) * baseSpeed,
                        r: 6,
                        col: sol.enraged ? '#ff924b' : '#ffd27a',
                        dmg: (sol.enraged ? 18 : 15) * dmgScale,
                        life: 3.6,
                        geminiTag: 'solar_wave'
                    });
                    store.eBullets.push(bullet);
                }
                store.activeEffects.push(createEffect('novaRing', sol.x, sol.y, sol.radius + 90, {
                    color: '#ffaf5a',
                    duration: 0.45
                }));
            }

            function geminiFireLunaShard(boss, state, dmgScale, angle, speedMultiplier = 1) {
                const luna = state.luna;
                const speed = (luna.enraged ? 250 : 210) * speedMultiplier;
                const shard = getEBulletFromPool({
                    x: luna.x,
                    y: luna.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    r: luna.enraged ? 8 : 7,
                    col: '#66f2ff',
                    dmg: (luna.enraged ? 22 : 18) * dmgScale,
                    life: 4.8,
                    geminiTag: 'ice_shard',
                    slowFactor: luna.enraged ? 0.45 : 0.6,
                    slowDuration: luna.enraged ? 2.2 : 1.6
                });
                store.eBullets.push(shard);
                store.activeEffects.push(createEffect('spawnTeleport', luna.x, luna.y, luna.radius * 0.75, {
                    color: '#66f2ff',
                    duration: 0.3
                }));
            }

            function geminiTriggerSolarShield(state) {
                const sol = state.sol;
                const luna = state.luna;
                if (!sol || sol.hp <= 0 || sol.shieldActive) return;
                sol.shieldActive = true;
                sol.shieldTimer = luna.enraged ? 6 : 4.6;
                sol.shieldHp = sol.hpMax * (luna.enraged ? 0.12 : 0.08);
                store.activeEffects.push(createEffect('spawnTeleport', sol.x, sol.y, sol.radius + 32, {
                    color: '#9de7ff',
                    duration: 0.6
                }));
                if (!state.timers.shieldAnnounce) {
                    announce('"Luna casts a frostguard over Sol!"');
                    state.timers.shieldAnnounce = true;
                }
            }

            function stepBossGemini(dt, boss, dmgScale) {
                const state = ensureGeminiState(boss);
                if (!state) return;

                state.timers.shared += dt;

                const player = store.player;
                if (!player) return;

                const entry = state.entry;
                if (!entry.complete) {
                    entry.progress = Math.min(1, entry.progress + dt / Math.max(0.2, entry.duration));
                    const eased = 1 - Math.pow(1 - entry.progress, 3);
                    state.sol.y = entry.startY + (entry.targetSolY - entry.startY) * eased;
                    state.luna.y = entry.startY - 20 + (entry.targetLunaY - entry.startY + 20) * eased;
                    state.sol.x += (W * 0.35 - state.sol.x) * Math.min(1, dt * 3.2);
                    state.luna.x += (W * 0.65 - state.luna.x) * Math.min(1, dt * 3.2);
                    if (!entry.announced && entry.progress >= 0.65) {
                        entry.announced = true;
                        announce('"The Gemini dancers descend in tandem."');
                    }
                    if (entry.progress >= 1) {
                        entry.complete = true;
                        boss.isInvincible = false;
                    }
                    geminiUpdateCenter(boss, state);
                    return;
                }

                const sol = state.sol;
                const luna = state.luna;

                sol.enraged = (luna.hp > 0 && luna.hp / luna.hpMax <= 0.5) || luna.hp <= 0;
                luna.enraged = (sol.hp > 0 && sol.hp / sol.hpMax <= 0.5) || sol.hp <= 0;

                if (sol.enraged && !state.timers.announcementSol) {
                    state.timers.announcementSol = true;
                    announce('SOL blazes hotter as Luna falters!');
                }
                if (luna.enraged && !state.timers.announcementLuna) {
                    state.timers.announcementLuna = true;
                    announce('LUNA channels icy focus as Sol weakens!');
                }
                if (sol.enraged && luna.enraged && !state.timers.dualCallout) {
                    state.timers.dualCallout = true;
                    announce('The Gemini dancers synchronize their fury!');
                }

                if (sol.hp > 0) {
                    const dx = player.x - sol.x;
                    const dy = (player.y - 30) - sol.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    const speed = sol.enraged ? GEMINI_CONFIG.sol.enragedSpeed : GEMINI_CONFIG.sol.baseSpeed;
                    sol.x += (dx / dist) * speed * dt;
                    sol.y += (dy / dist) * speed * dt;
                    sol.x = clamp(sol.x, sol.radius + 40, W - sol.radius - 40);
                    sol.y = clamp(sol.y, GEMINI_CONFIG.shared.minY, GEMINI_CONFIG.shared.maxY());
                }

                if (luna.hp > 0) {
                    const dx = player.x - luna.x;
                    const dy = (player.y - 50) - luna.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    const desired = luna.enraged ? 340 : 300;
                    const retreatSpeed = luna.enraged ? GEMINI_CONFIG.luna.retreatSpeed : GEMINI_CONFIG.luna.retreatSpeed * 0.9;
                    const advanceSpeed = luna.enraged ? GEMINI_CONFIG.luna.baseSpeed * 1.1 : GEMINI_CONFIG.luna.baseSpeed;
                    if (dist < desired - 40) {
                        luna.x -= (dx / dist) * retreatSpeed * dt;
                        luna.y -= (dy / dist) * retreatSpeed * dt;
                    } else if (dist > desired + 60) {
                        luna.x += (dx / dist) * advanceSpeed * dt;
                        luna.y += (dy / dist) * advanceSpeed * 0.6 * dt;
                    } else {
                        const strafeAngle = Math.atan2(dy, dx) + Math.PI / 2;
                        luna.x += Math.cos(strafeAngle) * advanceSpeed * 0.55 * dt;
                        luna.y += Math.sin(strafeAngle) * advanceSpeed * 0.4 * dt;
                    }
                    luna.x = clamp(luna.x, luna.radius + 40, W - luna.radius - 40);
                    luna.y = clamp(luna.y, GEMINI_CONFIG.shared.minY - 10, GEMINI_CONFIG.shared.maxY() - 20);
                }

                // Maintain separation
                const dxPair = sol.x - luna.x;
                const dyPair = sol.y - luna.y;
                const distPair = Math.hypot(dxPair, dyPair);
                if (distPair > 0 && distPair < GEMINI_CONFIG.shared.separation) {
                    const push = (GEMINI_CONFIG.shared.separation - distPair) * 0.5;
                    const nx = dxPair / distPair;
                    const ny = dyPair / distPair;
                    sol.x += nx * push * dt * 6;
                    sol.y += ny * push * dt * 6;
                    luna.x -= nx * push * dt * 6;
                    luna.y -= ny * push * dt * 6;
                }

                geminiUpdateCenter(boss, state);

                if (sol.shieldActive) {
                    sol.shieldTimer -= dt;
                    if (sol.shieldTimer <= 0 || sol.hp <= 0) {
                        sol.shieldActive = false;
                        sol.shieldHp = 0;
                    }
                }

                if (sol.hp > 0) {
                    sol.fireTimer -= dt;
                    if (sol.fireTimer <= 0) {
                        const angle = Math.atan2(player.y - sol.y, player.x - sol.x);
                        geminiFireSolPrimary(boss, state, dmgScale, angle);
                        if (sol.enraged) {
                            for (let i = -2; i <= 2; i++) {
                                if (i === 0) continue;
                                geminiFireSolPrimary(boss, state, dmgScale, angle + i * GEMINI_CONFIG.sol.spreadAngle);
                            }
                        }
                        sol.fireTimer = sol.enraged ? GEMINI_CONFIG.sol.primaryCooldown.enraged : GEMINI_CONFIG.sol.primaryCooldown.base;
                    }

                    sol.waveTimer -= dt;
                    if (sol.waveTimer <= 0 && sol.enraged) {
                        geminiFireSolWave(boss, state, dmgScale);
                        sol.waveTimer = GEMINI_CONFIG.sol.waveCooldown.enraged;
                    } else if (sol.waveTimer <= 0) {
                        sol.waveTimer = GEMINI_CONFIG.sol.waveCooldown.base;
                    }
                }

                if (luna.hp > 0) {
                    luna.fireTimer -= dt;
                    if (luna.fireTimer <= 0) {
                        const angle = Math.atan2((player.y - 20) - luna.y, player.x - luna.x);
                        geminiFireLunaShard(boss, state, dmgScale, angle, 1);
                        if (luna.enraged) {
                            geminiFireLunaShard(boss, state, dmgScale, angle + 0.18, 0.95);
                            geminiFireLunaShard(boss, state, dmgScale, angle - 0.18, 0.95);
                        }
                        luna.fireTimer = luna.enraged ? GEMINI_CONFIG.luna.primaryCooldown.enraged : GEMINI_CONFIG.luna.primaryCooldown.base;
                    }

                    luna.slowFieldCooldown -= dt;
                    const existingFields = store.geminiSlowFields || (store.geminiSlowFields = []);
                    if (luna.slowFieldCooldown <= 0 && existingFields.length < 5) {
                        const targetX = clamp(player.x + (player.x - sol.x) * 0.12, 110, W - 110);
                        const targetY = clamp(player.y - 40, 110, H - 160);
                        spawnGeminiSlowField({
                            x: targetX,
                            y: targetY,
                            radius: luna.enraged ? 135 : 110,
                            slowFactor: luna.enraged ? 0.45 : 0.6,
                            duration: luna.enraged ? 6 : 4.8
                        });
                        luna.slowFieldCooldown = luna.enraged ? GEMINI_CONFIG.luna.slowFieldCooldown.enraged : GEMINI_CONFIG.luna.slowFieldCooldown.base;
                    }

                    luna.shieldCooldown -= dt;
                    if (luna.shieldCooldown <= 0 && sol.hp > 0 && sol.hp / sol.hpMax <= (luna.enraged ? 0.85 : 0.92)) {
                        geminiTriggerSolarShield(state);
                        luna.shieldCooldown = luna.enraged ? GEMINI_CONFIG.luna.shieldCooldown.enraged : GEMINI_CONFIG.luna.shieldCooldown.base;
                    }
                }

                if (sol.hp <= 0 && luna.hp <= 0 && boss.hp > 0) {
                    boss.hp = 0;
                    handleBossDefeat();
                }
            }

            function stepBossAsynchronos(dt, b, dmgScale) {
                const state = ensureAsynchronosState(b);
                ensureTemporalSystems();
                recordAsynchronosSamples(b, state, dt);

                const hpRatio = b.hpMax > 0 ? b.hp / b.hpMax : 1;
                if (state.phase === 1 && hpRatio <= 0.5) {
                    state.phase = 2;
                    b.isEnraged = true;
                    state.beamRotationSpeed = state.phaseBeamRotationSpeed * 1.3; // Even faster in phase 2
                    state.beamSkipTimer = Math.min(state.beamSkipTimer, state.phaseBeamSkipInterval);
                    state.rewindTimer = Math.min(state.rewindTimer, state.phaseRewindInterval);
                    state.burstTimer = Math.min(state.burstTimer, state.phaseBurstInterval);
                    state.dashAttackTimer = 4.0; // New dash attack ability
                    announce('âš¡ ASYNCHRONOS FRACTURES TIME ITSELF! âš¡');
                    playSound('epicHorn');
                    screenFlash(3, 200, 'rgba(111, 242, 255, 0.4)');
                }

                if (state.rewinding) {
                    updateAsynchronosRewind(b, state, dt);
                } else if (b.y < 110) {
                    b.y = Math.min(110, b.y + 160 * dt);
                } else {
                    // More dynamic movement patterns
                    state.movePhase += dt * (state.phase === 2 ? 1.5 : 0.85);
                    const erraticFactor = state.phase === 2 ? Math.sin(state.movePhase * 3.2) * 60 : 0;
                    const targetX = W / 2 + Math.sin(state.movePhase * 0.9) * (260 + erraticFactor) + Math.cos(state.movePhase * 1.7) * 80;
                    const targetY = 120 + Math.sin(state.movePhase * 1.4) * (state.phase === 2 ? 45 : 26) + Math.cos(state.movePhase * 2.1) * 25;
                    const moveSpeed = state.phase === 2 ? 3.5 : 2.8;
                    b.x += (targetX - b.x) * Math.min(1, moveSpeed * dt);
                    b.y += (targetY - b.y) * Math.min(1, (state.phase === 2 ? 2.2 : 1.6) * dt);
                    
                    // Phase 2: Add teleport dash attacks
                    if (state.phase === 2) {
                        state.dashAttackTimer = (state.dashAttackTimer || 5.0) - dt;
                        if (state.dashAttackTimer <= 0) {
                            performAsynchronosDash(b, state, dmgScale);
                            state.dashAttackTimer = 6.5; // Dash every 6.5 seconds in phase 2
                        }
                    }
                }

                state.echoTimer = Math.max(0, state.echoTimer - dt);
                state.rewindTimer -= dt;
                state.burstTimer -= dt;

                const echoTrigger = evaluateAsynchronosEcho(state);
                if (echoTrigger) {
                    spawnTemporalEcho(b, state, echoTrigger, dmgScale);
                    state.echoTimer = state.phase === 2 ? state.phaseEchoCooldown : state.baseEchoCooldown;
                }

                if (!state.rewinding && state.rewindTimer <= 0) {
                    beginAsynchronosRewind(b, state);
                }

                updateAsynchronosBeam(b, state, dt);

                if (state.burstTimer <= 0 && !state.rewinding) {
                    fireAsynchronosVolley(b, dmgScale, state);
                    state.burstTimer = state.phase === 2 ? state.phaseBurstInterval : state.baseBurstInterval;
                }
            }

            function applyTimeShardBuff(stacks = 1) {
                const p = store.player;
                if (!p) return;
                const additional = Math.max(1, Math.floor(stacks));
                const current = Math.max(0, p.timeShardStacks || 0);
                const newStacks = clamp(current + additional, 1, 5);
                p.timeShardStacks = newStacks;
                p.timeShardTimer = 6.5;
                p.timeShardMultiplier = Math.pow(0.88, newStacks);

                if (typeof announce === 'function') {
                    const percent = Math.round((1 - p.timeShardMultiplier) * 100);
                    announce(`Temporal surge x${newStacks}! Fire cadence +${percent}%`);
                }
            }

            function updateTemporalEchoes(dt) {
                const echoes = store.temporalEchoes;
                if (!Array.isArray(echoes) || echoes.length === 0) return;
                const player = store.player;

                for (let i = echoes.length - 1; i >= 0; i--) {
                    const echo = echoes[i];
                    if (!echo) continue;

                    echo.life -= dt;
                    if (echo.life <= 0) {
                        echo.dead = true;
                    }

                    if (echo.dead) {
                        store.activeEffects.push(createEffect('spawnTeleport', echo.x, echo.y, 26, {
                            color: '#8cf5ff',
                            duration: 0.28
                        }));
                        echoes.splice(i, 1);
                        continue;
                    }

                    if (echo.stage === 'dash') {
                        const stepX = echo.vx * dt;
                        const stepY = echo.vy * dt;
                        echo.x += stepX;
                        echo.y += stepY;
                        echo.traveled += Math.hypot(stepX, stepY);
                        echo.trailTimer -= dt;
                        if (echo.trailTimer <= 0) {
                            echo.trailTimer += echo.trailInterval || 0.10; // Slower trail spawn rate
                            const trail = getEBulletFromPool({
                                x: echo.x,
                                y: echo.y,
                                vx: 0,
                                vy: 0,
                                r: 5, // Smaller radius
                                col: echo.trailColor || '#4de0ff',
                                dmg: 0, // Trail doesn't damage - only the echo itself damages on direct hit
                                life: 0.5, // Visible longer for better telegraph
                                type: 'temporal_trail'
                            });
                            store.eBullets.push(trail);
                        }
                        if (echo.traveled >= echo.distance) {
                            echo.stage = 'linger';
                            echo.vx = 0;
                            echo.vy = 0;
                            echo.life = Math.max(echo.life, echo.linger || 0.4);
                        }
                    } else if (echo.stage === 'linger') {
                        echo.linger -= dt;
                        if (echo.linger <= 0) {
                            echo.dead = true;
                        }
                    }

                    if (player && !player.isInvincible) {
                        const radius = (player.r || 16) + (echo.radius || 18) * 0.7;
                        const dx = player.x - echo.x;
                        const dy = player.y - echo.y;
                        if (dx * dx + dy * dy <= radius * radius) {
                            takeDamage(echo.damage || 20);
                            echo.stage = 'linger';
                            echo.linger = Math.min(echo.linger || 0.5, 0.25);
                            echo.vx = 0;
                            echo.vy = 0;
                        }
                    }
                }
            }

            function updateTimeShards(dt) {
                const shards = store.timeShards;
                if (!Array.isArray(shards) || shards.length === 0) return;
                const player = store.player;
                for (let i = shards.length - 1; i >= 0; i--) {
                    const shard = shards[i];
                    if (!shard) continue;
                    shard.life -= dt;
                    shard.floatPhase = (shard.floatPhase || 0) + (shard.floatSpeed || 2.4) * dt;
                    if (shard.hitPulse) {
                        shard.hitPulse = Math.max(0, shard.hitPulse - dt);
                    }
                    if (shard.baseY !== undefined) {
                        shard.y = shard.baseY + Math.sin(shard.floatPhase) * 8;
                    }

                    if (shard.life <= 0 || shard.hp <= 0 || shard.dead) {
                        store.activeEffects.push(createEffect('spawnTeleport', shard.x, shard.y, 24, {
                            color: '#9df7ff',
                            duration: 0.3
                        }));
                        shards.splice(i, 1);
                    }
                }
            }

            function applyTemporalBeamEffects(dt, dmgScale) {
                const beam = store.temporalBeam;
                const boss = store.boss;
                if (!beam || !beam.active || !boss || boss.dead || boss.behavior !== 'asynchronos') return;

                beam.damageCooldown = Math.max(0, (beam.damageCooldown || 0) - dt);

                const player = store.player;
                if (!player || player.isInvincible) return;

                const originX = boss.x;
                const originY = boss.y;
                const ux = Math.cos(beam.angle || 0);
                const uy = Math.sin(beam.angle || 0);
                const px = player.x - originX;
                const py = player.y - originY;
                const along = px * ux + py * uy;
                if (along < -(player.r || 16)) return;

                const perpX = -uy;
                const perpY = ux;
                const dist = Math.abs(px * perpX + py * perpY);
                const effectiveWidth = (beam.width || 32) * (beam.telegraph > 0 ? (0.45 + 0.55 * (1 - beam.telegraph)) : 1);

                if (dist <= effectiveWidth) {
                    if (beam.damageCooldown <= 0) {
                        const damage = 22 * (dmgScale || 1);
                        takeDamage(damage);
                        beam.damageCooldown = 0.35;
                        store.activeEffects.push(createEffect('hurtPulse', player.x, player.y, (player.r || 16) * 1.6, {
                            color: '#9df7ff',
                            duration: 0.25
                        }));
                    }
                }
            }

            function stepBossShadowClone(dt, b, dmgScale) {
                ensureShadowCloneInit(b);
                if (!b.isEnraged && b.hp / b.hpMax <= 0.35) {
                    b.isEnraged = true;
                    b.shadowAbilityCooldown = 24;
                    playSound('horn');
                    announce('THE SHADOW MIRROR UNLEASHES ITS POWER!');
                }

                for (const key in b.shadowAbilityTimers) {
                    if (Object.prototype.hasOwnProperty.call(b.shadowAbilityTimers, key)) {
                        b.shadowAbilityTimers[key] -= dt;
                    }
                }

                if (b.currentAbility) {
                    if (b.abilityStage === 'windup') {
                        b.abilityTimer -= dt;
                        if (b.shadowTelegraph) {
                            const total = b.abilityWindupTotal || 1;
                            b.shadowTelegraph.progress = Math.min(1, Math.max(0, 1 - (b.abilityTimer / total)));
                        }
                        if (b.currentAbility === 'lightning') {
                            b.shadowTelegraphTarget = { x: store.player.x, y: store.player.y };
                        }
                        if (b.abilityTimer <= 0) {
                            switch (b.currentAbility) {
                                case 'star':
                                    shadowCloneFireStarVolley(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.55;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'lightning':
                                    shadowCloneCastLightning(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.65;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'hounds':
                                    spawnShadowHoundsFromBoss(b, b.isEnraged ? 4 : 3, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.6;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'pulseWave':
                                    shadowClonePulseWave(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.5;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'voidRift':
                                    shadowCloneVoidRift(b, dmgScale);
                                    b.abilityStage = 'recover';
                                    b.abilityTimer = 0.7;
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    break;
                                case 'charge':
                                    b.shadowTelegraph = null;
                                    b.shadowTelegraphTarget = null;
                                    b.abilityStage = 'charge';
                                    b.abilityTimer = b.isEnraged ? 0.85 : 1.05;
                                    const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    const speed = b.isEnraged ? 640 : 560;
                                    b.shadowChargeVX = Math.cos(angle) * speed;
                                    b.shadowChargeVY = Math.sin(angle) * speed;
                                    b.shadowChargeTrailCooldown = 0;
                                    b.shadowChargeHit = false;
                                    addShadowEcho(b.x, b.y);
                                    break;
                            }
                        }
                    } else if (b.abilityStage === 'charge') {
                        b.abilityTimer -= dt;
                        b.x += b.shadowChargeVX * dt;
                        b.y += b.shadowChargeVY * dt;
                        addShadowEcho(b.x, b.y);
                        b.shadowChargeTrailCooldown -= dt;
                        if (b.shadowChargeTrailCooldown <= 0) {
                            b.shadowChargeTrailCooldown = 0.08;
                            const pulse = getEBulletFromPool({
                                x: b.x,
                                y: b.y,
                                vx: 0,
                                vy: 0,
                                r: 7,
                                col: '#5460d8',
                                dmg: 10 * dmgScale,
                                life: 0.35
                            });
                            store.eBullets.push(pulse);
                        }
                        const margin = b.r;
                        if (b.x <= margin || b.x >= W - margin || b.y <= margin || b.y >= H * 0.92) {
                            b.abilityTimer = 0;
                        }
                        const player = store.player;
                        const playerRadius = player.r || 18;
                        const dx = player.x - b.x;
                        const dy = player.y - b.y;
                        if (!b.shadowChargeHit && dx * dx + dy * dy <= Math.pow(playerRadius + b.r * 0.55, 2)) {
                            takeDamage(30 * dmgScale * (b.isEnraged ? 1.25 : 1));
                            b.shadowChargeHit = true;
                        }
                        if (b.abilityTimer <= 0) {
                            b.abilityStage = 'recover';
                            b.abilityTimer = 0.55;
                            b.shadowChargeVX = 0;
                            b.shadowChargeVY = 0;
                        }
                    } else if (b.abilityStage === 'recover') {
                        b.abilityTimer -= dt;
                        if (b.abilityTimer <= 0) {
                            finishShadowAbility(b);
                        }
                    }
                } else {
                    const abilities = b.shadowAbilityOrder;
                    for (let i = 0; i < abilities.length; i++) {
                        const index = (b.shadowAbilityIndex + i) % abilities.length;
                        const abilityName = abilities[index];
                        if (b.shadowAbilityTimers[abilityName] <= 0) {
                            startShadowAbility(b, abilityName);
                            b.shadowAbilityTimers[abilityName] = b.shadowAbilityCooldown;
                            b.shadowAbilityIndex = (index + 1) % abilities.length;
                            break;
                        }
                    }
                }

                if (!b.currentAbility) {
                    b.multishotTimer -= dt;
                    if (b.multishotTimer <= 0) {
                        shadowCloneFireMultishot(b, dmgScale);
                        b.multishotTimer = b.isEnraged ? 0.45 : 0.65;
                    }
                }

                if (b.abilityStage !== 'charge') {
                    b.moveT += dt;
                    const follow = clamp(store.player.x, b.r + 40, W - b.r - 40);
                    const strafe = Math.sin(b.moveT * (b.isEnraged ? 1.4 : 1.0)) * (140 + (b.isEnraged ? 40 : 0));
                    const desiredX = clamp(follow + strafe * 0.3, b.r, W - b.r);
                    b.x += (desiredX - b.x) * dt * 3.2;
                    const targetY = 130 + Math.sin(b.moveT * 0.9) * 16;
                    b.y += (targetY - b.y) * dt * 2.6;
                }
            }

            function stepBossOmegaSentinel(dt, b, dmgScale) {
                // Movement behavior
                if (b.y >= 100) {
                    b.moveT += dt;
                    b.x += Math.sin(b.moveT * 2) * 200 * dt;
                    b.x = clamp(b.x, 100, W - 100);
                }

                // Initialize EMP nova timer if not set
                if (b.empNovaTimer === undefined) {
                    b.empNovaTimer = 8; // EMP nova every 8 seconds
                }

                // EMP Nova attack countdown
                b.empNovaTimer -= dt;
                if (b.empNovaTimer <= 0) {
                    // Create EMP nova
                    store.empNovas.push({
                        x: b.x,
                        y: b.y,
                        radius: 0,
                        maxRadius: H / 3, // 1/3 of screen height
                        speed: 80, // Slow expansion speed
                        life: 15, // Lives for 15 seconds
                        dead: false
                    });
                    b.empNovaTimer = 8; // Reset timer
                }

                // Regular attack patterns
                b.fireT -= dt;
                if (b.fireT <= 0) {
                    if (b.patternPhase % 4 === 0) {
                        // Radial burst
                        b.fireT = 1.5;
                        const n = 12;
                        for (let i = 0; i < n; i++) {
                            const a = (i * Math.PI / 6) + b.t;
                            store.eBullets.push({
                                x: b.x,
                                y: b.y,
                                vx: 150 * Math.cos(a),
                                vy: 150 * Math.sin(a),
                                r: 4,
                                col: '#4169e1',
                                dmg: 12 * dmgScale
                            });
                        }
                    } else {
                        // Aimed shot
                        b.fireT = 0.2;
                        const a = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: 250 * Math.cos(a),
                            vy: 250 * Math.sin(a),
                            r: 5,
                            col: '#add8e6',
                            dmg: 18 * dmgScale
                        });
                    }
                    b.patternPhase++;
                }
            }
            function ensureAegisArchitectState(b) {
                if (b.aegisState) {
                    return b.aegisState;
                }

                const rawCycle = Math.max(0, Math.floor((ensureFiniteNumber(b.spawnWave, store.world.wave) - 5) / 5));
                const loopIndex = Math.max(0, Math.floor(rawCycle / BOSS_DEFINITIONS.length));
                const difficultyScale = 1 + loopIndex * 0.22;
                const segmentHp = Math.max(260, b.hpMax * 0.16 * difficultyScale);
                const segmentDefs = [
                    { id: 'solar', label: 'Solar Keystone', color: '#ffb347', baseAngle: 0, arc: Math.PI * 0.58, unlock: 'solar_burst', unlockMessage: 'Solar torrents ignite the field!' },
                    { id: 'prismatic', label: 'Prismatic Keystone', color: '#7de8ff', baseAngle: (2 * Math.PI) / 3, arc: Math.PI * 0.58, unlock: 'prismatic_grid', unlockMessage: 'Prismatic lattices refract across the arena!' },
                    { id: 'gravity', label: 'Gravimetric Keystone', color: '#c5a7ff', baseAngle: (4 * Math.PI) / 3, arc: Math.PI * 0.58, unlock: 'gravity_well', unlockMessage: 'Gravity wells distort your footing!' }
                ];

                const segments = segmentDefs.map(def => ({
                    ...def,
                    hp: segmentHp,
                    maxHp: segmentHp,
                    destroyed: false,
                    hitPulse: 0,
                    lastHitTime: 0
                }));

                const state = {
                    rotationAngle: 0,
                    rotationSpeed: 0.52,
                    rotationDirection: 1,
                    shieldRadius: Math.max(90, b.r * 1.08),
                    coreRadius: Math.max(44, b.r * 0.62),
                    segments,
                    attackTimer: 1.6,
                    availablePatterns: ['baseline', 'baseline'],
                    patternIndex: -1,
                    unlocks: Object.create(null),
                    difficultyScale,
                    loopIndex,
                    corePulse: 0,
                    enraged: false,
                    coreExposed: false,
                    anchorX: W / 2,
                    anchorY: 130,
                    repositionTimer: 0,
                    repositionTarget: null
                };

                b.aegisState = state;
                return state;
            }

            function getAegisSegmentForAngle(state, angle) {
                if (!state || !state.segments) return null;
                for (const segment of state.segments) {
                    if (!segment || segment.destroyed) continue;
                    const center = state.rotationAngle + segment.baseAngle;
                    const delta = Math.atan2(Math.sin(angle - center), Math.cos(angle - center));
                    if (Math.abs(delta) <= segment.arc * 0.5) {
                        return segment;
                    }
                }
                return null;
            }

            function handleAegisSegmentDestroyed(boss, segment, state) {
                if (!boss || !segment || !state) return;

                state.rotationDirection *= -1;
                state.rotationSpeed *= 1.1;
                state.availablePatterns.push(segment.unlock);
                state.availablePatterns.push('baseline');
                state.unlocks[segment.id] = true;
                state.attackTimer = Math.min(state.attackTimer, state.enraged ? 0.9 : 1.2);

                store.activeEffects.push(createEffect('spawnTeleport', boss.x, boss.y, state.shieldRadius + 24, {
                    color: segment.color,
                    duration: 0.8
                }));

                if (typeof announce === 'function') {
                    announce(`${segment.label} shattered! ${segment.unlockMessage}`);
                }

                if (state.segments.every(seg => seg.destroyed)) {
                    if (!state.coreExposed) {
                        state.coreExposed = true;
                        state.availablePatterns.push('cataclysm');
                        if (typeof announce === 'function') {
                            announce('Architect core exposed! Cataclysm routines engaged!');
                        }
                    }
                }
            }

            function applyAegisShieldDamage(boss, damage, options = {}) {
                if (!boss || boss.behavior !== 'aegis_architect' || damage <= 0) {
                    return { blocked: false, damageApplied: 0 };
                }

                const state = options.state || ensureAegisArchitectState(boss);
                if (!state) {
                    return { blocked: false, damageApplied: 0 };
                }

                let angle = options.angle;
                if (angle === undefined && options.point) {
                    angle = Math.atan2(options.point.y - boss.y, options.point.x - boss.x);
                }
                if (angle === undefined || !Number.isFinite(angle)) {
                    return { blocked: false, damageApplied: 0 };
                }

                const segment = getAegisSegmentForAngle(state, angle);
                if (!segment) {
                    return { blocked: false, damageApplied: 0 };
                }

                const applied = Math.max(0, damage);
                segment.hp = Math.max(0, segment.hp - applied);
                segment.hitPulse = 0.22;
                segment.lastHitTime = performance.now();

                const impactRadius = Math.max(18, options.hitRadius || 18);
                const impactX = boss.x + Math.cos(angle) * state.shieldRadius;
                const impactY = boss.y + Math.sin(angle) * state.shieldRadius;

                store.activeEffects.push(createEffect('hitSpark', impactX, impactY, impactRadius, {
                    color: segment.color
                }));
                store.activeEffects.push(createEffect('spawnTeleport', impactX, impactY, impactRadius + 6, {
                    color: segment.color,
                    duration: 0.35
                }));

                store.world.totalDamage += applied;

                if (segment.hp <= 0 && !segment.destroyed) {
                    segment.destroyed = true;
                    handleAegisSegmentDestroyed(boss, segment, state);
                }

                return { blocked: true, damageApplied: applied, segment };
            }

            function tryAegisShieldInterceptBullet(boss, bullet, damage) {
                if (!boss || !bullet || damage <= 0 || boss.behavior !== 'aegis_architect') {
                    return null;
                }

                const state = ensureAegisArchitectState(boss);
                if (!state) {
                    return null;
                }

                const dx = bullet.x - boss.x;
                const dy = bullet.y - boss.y;
                const dist = Math.hypot(dx, dy);
                if (!Number.isFinite(dist) || dist < state.coreRadius * 0.72) {
                    return null;
                }

                const angle = Math.atan2(dy, dx);
                const result = applyAegisShieldDamage(boss, damage, { state, angle, hitRadius: (bullet.r || 4) + 6 });
                if (!result.blocked) {
                    return null;
                }

                if (bullet.pierce) {
                    bullet.pierceHits = (bullet.pierceHits || 0) + 1;
                    if (bullet.pierceHits >= bullet.pierce) {
                        bullet.dead = true;
                    }
                } else {
                    bullet.dead = true;
                }

                return result;
            }

            function fireAegisBaselineVolley(b, dmgScale, state) {
                const aim = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                const count = 5;
                const spread = Math.PI / 18;
                const speed = (state && state.enraged) ? 290 : 240;
                for (let i = 0; i < count; i++) {
                    const offset = (i - (count - 1) / 2) * spread;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(aim + offset) * speed,
                        vy: Math.sin(aim + offset) * speed,
                        r: 5,
                        col: '#6bd6ff',
                        dmg: 16 * dmgScale,
                        life: 4
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, 34, {
                    color: '#6bd6ff',
                    duration: 0.4
                }));
            }

            function fireAegisSolarBurst(b, dmgScale, state) {
                const baseX = b.x;
                const originY = b.y + 34;
                const count = (state && state.enraged) ? 12 : 10;
                for (let i = 0; i < count; i++) {
                    const offsetIndex = i - (count - 1) / 2;
                    const amplitude = 110 + Math.abs(offsetIndex) * 14;
                    const frequency = 2.4 + Math.random() * 0.35;
                    const fallSpeed = 160 + Math.random() * 40;
                    const phaseOffset = offsetIndex * 0.42;

                    store.eBullets.push({
                        x: baseX + offsetIndex * 18,
                        y: originY,
                        r: 6,
                        col: '#ffb347',
                        dmg: 18 * dmgScale * ((state && state.enraged) ? 1.15 : 1),
                        path: 'aegis_spiral',
                        amplitude,
                        frequency,
                        fallSpeed,
                        phaseOffset,
                        life: 7.5 + Math.random() * 1.5,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', baseX, originY, 44, {
                    color: '#ffb347',
                    duration: 0.75
                }));
            }

            function fireAegisPrismaticGrid(b, dmgScale, state) {
                const lanes = (state && state.enraged) ? 6 : 5;
                const usableWidth = W - 120;
                const baseX = 60;
                for (let i = 0; i < lanes; i++) {
                    const laneX = baseX + (i + 0.5) * (usableWidth / lanes);
                    const downwardSpeed = 240 + i * 12;
                    store.eBullets.push({
                        x: laneX,
                        y: b.y + 20,
                        vx: ((i % 2 === 0) ? -1 : 1) * 80,
                        vy: downwardSpeed,
                        r: 5,
                        col: '#90f2ff',
                        dmg: 18 * dmgScale,
                        life: 3.6
                    });
                    store.eBullets.push({
                        x: laneX,
                        y: b.y + 20,
                        vx: 0,
                        vy: downwardSpeed + 40,
                        r: 7,
                        col: '#abf5ff',
                        dmg: 22 * dmgScale,
                        life: 3.2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y + 20, 52, {
                    color: '#90f2ff',
                    duration: 0.6
                }));
            }

            function fireAegisGravityAnchors(b, dmgScale, state) {
                const orbs = (state && state.enraged) ? 3 : 2;
                const radius = state ? state.shieldRadius : b.r + 24;
                const baseAngle = Math.random() * Math.PI * 2;
                for (let i = 0; i < orbs; i++) {
                    const angle = baseAngle + (i / orbs) * Math.PI * 2;
                    const spawnX = b.x + Math.cos(angle) * radius;
                    const spawnY = b.y + Math.sin(angle) * radius;
                    const speed = 90 + Math.random() * 40;
                    store.eBullets.push({
                        x: spawnX,
                        y: spawnY,
                        vx: Math.cos(angle) * speed * 0.35,
                        vy: Math.sin(angle) * speed * 0.35,
                        r: 9,
                        col: '#c8b2ff',
                        dmg: 26 * dmgScale,
                        life: 6.5,
                        path: 'aegis_gravity',
                        homingStrength: 125 + (state ? state.difficultyScale : 1) * 15,
                        maxSpeed: 260,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, radius + 18, {
                    color: '#c8b2ff',
                    duration: 0.7
                }));
            }

            function fireAegisCataclysm(b, dmgScale, state) {
                const count = (state && state.enraged) ? 18 : 14;
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const speed = (state && state.enraged) ? 320 : 250;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: 5,
                        col: '#5dd0ff',
                        dmg: 18 * dmgScale,
                        life: 4.2
                    });
                }

                store.activeEffects.push(createEffect('spawnTeleport', b.x, b.y, (state ? state.shieldRadius : b.r + 24) + 30, {
                    color: '#5dd0ff',
                    duration: 0.8
                }));
            }

            function nextAegisPattern(state) {
                if (!state || !state.availablePatterns.length) {
                    return 'baseline';
                }
                state.patternIndex = (state.patternIndex + 1) % state.availablePatterns.length;
                return state.availablePatterns[state.patternIndex];
            }

            function getAegisPatternCooldown(pattern, state) {
                const base = state && state.enraged ? 1.4 : 2.2;
                let cooldown = base;
                switch (pattern) {
                    case 'baseline':
                        cooldown = base * 0.9;
                        break;
                    case 'solar_burst':
                        cooldown = base * 1.05;
                        break;
                    case 'prismatic_grid':
                        cooldown = base * 1.15;
                        break;
                    case 'gravity_well':
                        cooldown = base * 1.2;
                        break;
                    case 'cataclysm':
                        cooldown = Math.max(1.1, base * 0.85);
                        break;
                }
                if (state && state.enraged) {
                    cooldown *= 0.75;
                }
                return Math.max(0.7, cooldown);
            }

            function stepBossCoreAegisArchitect(dt, b, dmgScale) {
                const state = ensureAegisArchitectState(b);
                if (!state) return;

                const hpRatio = b.hpMax > 0 ? b.hp / b.hpMax : 1;
                if (hpRatio <= 0.35 && !state.enraged) {
                    state.enraged = true;
                    b.isEnraged = true;
                    state.rotationSpeed *= 1.35;
                    if (typeof announce === 'function') {
                        announce('Architect protocols enraged! Shield rotation accelerating!');
                    }
                }

                if (!Number.isFinite(b.moveT)) b.moveT = 0;
                const margin = b.r || 68;
                const baseAscendSpeed = state.enraged ? 170 : 140;
                if (b.y < state.anchorY) {
                    b.y = Math.min(state.anchorY, b.y + baseAscendSpeed * dt);
                }

                const playerInfluence = Math.min(0.18, 0.08 + (state.loopIndex || 0) * 0.015);
                const player = store.player || { x: W / 2, y: H / 2 };
                state.anchorX += (player.x - state.anchorX) * playerInfluence * dt;
                const baseAnchorY = state.enraged ? 140 : 132;
                state.anchorY += (baseAnchorY - state.anchorY) * 0.05 * dt;
                state.anchorX = clamp(state.anchorX, margin, W - margin);
                state.anchorY = clamp(state.anchorY, 120, H * 0.42);

                state.repositionTimer -= dt;
                if (state.repositionTimer <= 0 && !state.repositionTarget) {
                    state.repositionTimer = state.enraged ? 4.2 : 5.6;
                    state.repositionTarget = {
                        x: clamp(W / 2 + (Math.random() - 0.5) * 320, margin, W - margin),
                        y: clamp(125 + Math.random() * 60, 110, H * 0.46)
                    };
                }

                if (state.repositionTarget) {
                    const follow = state.enraged ? 3.6 : 2.6;
                    state.anchorX += (state.repositionTarget.x - state.anchorX) * Math.min(1, follow * dt);
                    state.anchorY += (state.repositionTarget.y - state.anchorY) * Math.min(1, follow * 0.75 * dt);
                    if (Math.hypot(state.anchorX - state.repositionTarget.x, state.anchorY - state.repositionTarget.y) < 6) {
                        state.repositionTarget = null;
                    }
                }

                b.moveT += dt * (state.enraged ? 0.78 : 0.6);
                const baseRadiusX = state.enraged ? 210 : 180;
                const baseRadiusY = state.enraged ? 74 : 54;
                const wobble = Math.sin(b.moveT * 0.45) * 65;
                const verticalWobble = Math.cos(b.moveT * 0.8) * 24;
                const oscillateX = Math.sin(b.moveT) * baseRadiusX + wobble;
                const oscillateY = Math.sin(b.moveT * 2.1) * baseRadiusY + verticalWobble;
                b.x = clamp(state.anchorX + oscillateX, margin, W - margin);
                b.y = clamp(state.anchorY + oscillateY, 100, H * 0.5);

                const spinMultiplier = state.enraged ? 1.35 : 1;
                state.rotationAngle += state.rotationSpeed * dt * state.rotationDirection * spinMultiplier;
                if (state.rotationAngle > Math.PI * 2 || state.rotationAngle < -Math.PI * 2) {
                    state.rotationAngle = Math.atan2(Math.sin(state.rotationAngle), Math.cos(state.rotationAngle));
                }

                state.corePulse += dt * (state.enraged ? 4.0 : 2.8);
                state.segments.forEach(segment => {
                    if (segment.hitPulse > 0) {
                        segment.hitPulse = Math.max(0, segment.hitPulse - dt);
                    }
                });

                state.attackTimer -= dt;
                if (state.attackTimer <= 0) {
                    const pattern = nextAegisPattern(state);
                    switch (pattern) {
                        case 'solar_burst':
                            fireAegisSolarBurst(b, dmgScale, state);
                            break;
                        case 'prismatic_grid':
                            fireAegisPrismaticGrid(b, dmgScale, state);
                            break;
                        case 'gravity_well':
                            fireAegisGravityAnchors(b, dmgScale, state);
                            break;
                        case 'cataclysm':
                            fireAegisCataclysm(b, dmgScale, state);
                            break;
                        default:
                            fireAegisBaselineVolley(b, dmgScale, state);
                            break;
                    }
                    state.attackTimer = getAegisPatternCooldown(pattern, state);
                }
            }
            function stepBossTheHex(dt, b, dmgScale) {
                // Initialize trap god state
                if (!b.trapGodInitialized) {
                    b.trapGodInitialized = true;
                    b.phase = 1;
                    b.moveT = 0;
                    b.tiltDirection = 1; // 1 or -1
                    b.attackCyclePhase = 0; // 0 or 1 (alternates between attacks)
                    b.tiltTimer = 0;
                    b.tiltActive = false;
                    b.megaSlamTimer = -1;
                    b.megaSlamActive = false;
                    b.baseColor = '#ffd700'; // Gold
                }

                // Determine phase based on HP
                const hpPercent = b.hp / b.hpMax;
                const newPhase = hpPercent > 0.5 ? 1 : 2;
                if (newPhase !== b.phase) {
                    b.phase = newPhase;
                    if (b.phase === 2) {
                        playSound('trap');
                        b.color = '#ff9500'; // Intensified gold/orange
                        announce('ðŸ† TRAPEZOID GOD enters FURY MODE!');
                    }
                }

                // ===== MOVEMENT =====
                if (b.y >= 100) {
                    b.moveT += dt;
                    const phase1Speed = 0.4;
                    const phase2Speed = 0.6;
                    const moveSpeed = b.phase === 1 ? phase1Speed : phase2Speed;
                    
                    if (b.phase === 2 && Math.random() < 0.08 * dt) {
                        // Phase 2: occasional small dips downward
                        if (!b.isDipping) {
                            b.isDipping = true;
                            b.dipStartTime = performance.now();
                        }
                    }

                    if (b.isDipping) {
                        const dipDuration = 0.3;
                        const timeSinceDip = (performance.now() - b.dipStartTime) / 1000;
                        if (timeSinceDip < dipDuration) {
                            b.y += 60 * Math.sin(Math.PI * timeSinceDip / dipDuration) * dt * 2;
                        } else {
                            b.isDipping = false;
                        }
                    }

                    const desiredX = W * 0.25 + (W * 0.5) * Math.abs(Math.sin(b.moveT * moveSpeed));
                    const followSpeed = b.phase === 1 ? 4 : 6;
                    b.x += (desiredX - b.x) * Math.min(1, followSpeed * dt);
                    b.x = clamp(b.x, b.r, W - b.r);
                }

                // ===== ATTACKS =====
                b.fireT -= dt;
                
                if (b.fireT <= 0) {
                    const phase1FireRate = 2.0;
                    const phase2FireRate = 1.3;
                    b.fireT = b.phase === 1 ? phase1FireRate : phase2FireRate;

                    // Phase 1: Standard Coinfall vs Tilt & Pour
                    if (b.phase === 1) {
                        if (b.attackCyclePhase === 0) {
                            // Standard Coinfall
                            b.rainEvent = {
                                remaining: 25,
                                interval: 0.04,
                                timer: 0,
                                powerupChance: 0.15
                            };
                            announce('ðŸ’° Coins cascade down!');
                        } else {
                            // Tilt & Pour
                            b.tiltActive = true;
                            b.tiltTimer = 2.5; // Duration of pour
                            b.tiltDirection = Math.random() < 0.5 ? 1 : -1;
                            announce('ðŸŒŠ Vault tilts!');
                        }
                        b.attackCyclePhase = (b.attackCyclePhase + 1) % 2;
                    }
                    // Phase 2: Torrential Coinfall vs Golden Wave vs Mega Slam
                    else {
                        const attack = Math.floor(Math.random() * 3);
                        if (attack === 0) {
                            // Torrential Coinfall (enhanced)
                            b.rainEvent = {
                                remaining: 40,
                                interval: 0.025,
                                timer: 0,
                                powerupChance: 0.08,
                                isTorrential: true
                            };
                            announce('â›ˆï¸ TORRENTIAL COINFALL!');
                        } else if (attack === 1) {
                            // Golden Wave
                            const waveDirection = b.x < W / 2 ? 1 : -1;
                            const waveStartX = waveDirection < 0 ? W : 0;
                            for (let i = 0; i < 15; i++) {
                                store.eBullets.push({
                                    x: waveStartX,
                                    y: H * 0.4 + (Math.random() - 0.5) * 80,
                                    vx: waveDirection * 500,
                                    vy: 0,
                                    r: 6,
                                    col: '#ffd700',
                                    dmg: 20 * dmgScale
                                });
                            }
                            announce('ðŸŒŠ Golden Wave strikes!');
                        } else {
                            // Mega Slam setup
                            b.megaSlamActive = true;
                            b.megaSlamTimer = 1.5; // Charge time
                            announce('ðŸ’¥ MEGA SLAM incoming!');
                        }
                    }
                }

                // ===== TILT & POUR ATTACK =====
                if (b.tiltActive && b.tiltTimer > 0) {
                    b.tiltTimer -= dt;
                    
                    // Spawn coins from tilted corner
                    const cornerX = b.tiltDirection > 0 ? W : 0;
                    const coinCount = Math.floor(10 * dt); // 10 coins per second
                    for (let i = 0; i < coinCount; i++) {
                        const spreadX = Math.random() * 60 - 30;
                        const powerupSpawn = Math.random() < 0.1;
                        
                        if (powerupSpawn) {
                            const shieldX = b.tiltDirection > 0 ? 100 : W - 100;
                            store.powerups.push({
                                x: shieldX + (Math.random() - 0.5) * 50,
                                y: 50,
                                vx: 0,
                                vy: 200,
                                r: 8,
                                type: 'shield',
                                life: 6
                            });
                        } else {
                            store.eBullets.push({
                                x: cornerX + spreadX,
                                y: 80,
                                vx: b.tiltDirection * 100 + (Math.random() - 0.5) * 80,
                                vy: 250 + Math.random() * 100,
                                r: 5,
                                col: '#ffc83d',
                                dmg: 15 * dmgScale
                            });
                        }
                    }

                    if (b.tiltTimer <= 0) {
                        b.tiltActive = false;
                    }
                }

                // ===== MEGA SLAM ATTACK =====
                if (b.megaSlamActive && b.megaSlamTimer >= 0) {
                    b.megaSlamTimer -= dt;
                    
                    // Spawn power-up near corner during charge
                    if (b.megaSlamTimer > 1.0 && !b.megaSlamPowerupSpawned) {
                        b.megaSlamPowerupSpawned = true;
                        const cornerX = Math.random() < 0.5 ? 100 : W - 100;
                        store.powerups.push({
                            x: cornerX + (Math.random() - 0.5) * 40,
                            y: H * 0.3,
                            vx: 0,
                            vy: 0,
                            r: 10,
                            type: 'star_upgrade',
                            life: 10
                        });
                    }

                    // Fire mega coin when charge complete
                    if (b.megaSlamTimer <= 0) {
                        b.megaSlamActive = false;
                        b.megaSlamPowerupSpawned = false;
                        
                        // Large slow-moving coin
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: 0,
                            vy: 150,
                            r: 20,
                            col: '#ffdd00',
                            dmg: 40 * dmgScale,
                            isMegaCoin: true,
                            shockwaveTimer: 0
                        });
                    }
                }

                // ===== STANDARD COINFALL =====
                if (b.rainEvent && b.rainEvent.remaining > 0) {
                    b.rainEvent.timer -= dt;
                    while (b.rainEvent.timer <= 0 && b.rainEvent.remaining > 0) {
                        b.rainEvent.timer += b.rainEvent.interval;
                        b.rainEvent.remaining--;
                        
                        // Spawn powerup occasionally
                        if (Math.random() < b.rainEvent.powerupChance) {
                            const powerupTypes = ['shield', 'missile', 'drones'];
                            const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                            
                            store.powerups.push({
                                x: Math.random() * W,
                                y: 0,
                                vx: 0,
                                vy: b.rainEvent.isTorrential ? 350 : 250,
                                r: 7,
                                type: randomType,
                                life: H / 250 + 2
                            });
                        } else {
                            // Regular coin
                            const fallSpeed = b.rainEvent.isTorrential ? 350 : 250;
                            store.eBullets.push({
                                x: Math.random() * W,
                                y: 0,
                                vx: (Math.random() - 0.5) * 40,
                                vy: fallSpeed,
                                r: 5,
                                col: '#ffc83d',
                                dmg: b.rainEvent.isTorrential ? 18 * dmgScale : 15 * dmgScale
                            });
                        }
                    }
                    
                    if (b.rainEvent.remaining <= 0) {
                        b.rainEvent = null;
                    }
                }

                // ===== MEGA COIN SHOCKWAVE EFFECT =====
                store.eBullets.forEach(bullet => {
                    if (bullet.isMegaCoin && bullet.y >= H - 20) {
                        if (!bullet.hasExploded) {
                            bullet.hasExploded = true;
                            // Create shockwave - low to ground, spreading both directions
                            for (let i = 0; i < 20; i++) {
                                const angle = (i / 20) * Math.PI * 2;
                                // Bias coins to spread horizontally at ground level
                                const spreadFactor = Math.abs(Math.cos(angle)) > 0.3 ? 1.5 : 0.3;
                                store.eBullets.push({
                                    x: bullet.x,
                                    y: H - 40,
                                    vx: Math.cos(angle) * 300 * spreadFactor,
                                    vy: Math.sin(angle) * 80 * spreadFactor + 100,
                                    r: 6,
                                    col: '#ffdd00',
                                    dmg: 22 * dmgScale,
                                    life: 1.5
                                });
                            }
                        }
                    }
                });
            }
            function stepBossGeometron(dt, b, dmgScale) {
                // Handle DEATH ENGINE specific behavior
                if (b.name === 'DEATH ENGINE') {
                    // Initialize skull ship specific properties
                    if (!b.skullPhaseInitialized) {
                        b.skullPhaseInitialized = true;
                        b.phase = 1;
                        b.disappearPhase = false;
                        b.disappearStartTime = 0;
                        b.safeZoneY = H * 0.5; // Start safe zone in middle
                        b.safeZoneChanges = 0;
                        b.maxSafeZoneChanges = 3;
                        b.hasDoneSecondDisappear = false;
                    }

                    // Phase 1: Normal attacks until 50% HP
                    if (b.phase === 1 && b.hp / b.hpMax > 0.5) {
                        // Movement
                        if (b.y >= 100) {
                            b.moveT += dt;
                            b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * 0.3);
                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }
                        }

                        // Normal attack pattern
                        b.fireT -= dt;
                        if (b.fireT <= 0) {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = 2.5;
                            switch (b.attackPhase) {
                                case 0:
                                    // Trigger Death Engine laugh
                                    b.isLaughing = true;
                                    b.laughStartTime = performance.now();
                                    if (b.skullRenderer) {
                                        b.skullRenderer.triggerAttack(true);
                                    }
                                    const n = 12;
                                    for (let i = 0; i < n; i++) {
                                        const a = (i * 2 * Math.PI / n) + b.t * 0.5;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 160 * Math.cos(a), vy: 160 * Math.sin(a), r: 4, col: '#8B0000', dmg: 18 * dmgScale });
                                    }
                                    break;
                                case 1:
                                    // Aimed shots at player
                                    const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    for (let i = 0; i < 5; i++) {
                                        const angle = angleToPlayer + (i - 2) * 0.15;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 280 * Math.cos(angle), vy: 280 * Math.sin(angle), r: 5, col: '#FF4500', dmg: 22 * dmgScale });
                                    }
                                    break;
                                case 2:
                                    // Spawn construct gold
                                    const numgold = 2 + Math.floor(store.world.wave / 10);
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (Math.random() - 0.5) * 120;
                                        gold.y = b.y + 60;
                                        gold.color = '#8B0000';
                                        store.enemies.push(gold);
                                    }
                                    break;
                                case 3:
                                    // New attack phase: Bouncing skull projectiles
                                    for (let i = 0; i < 6; i++) {
                                        const angle = (i * Math.PI / 3) + (Math.random() - 0.5) * 0.3;
                                        const speed = 150 + Math.random() * 50;
                                        store.eBullets.push({
                                            x: b.x,
                                            y: b.y,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            r: 6,
                                            col: '#DC143C',
                                            dmg: 20 * dmgScale,
                                            bounces: 2, // Special bouncing bullets
                                            life: 4.0
                                        });
                                    }
                                    break;
                            }
                        }
                    }
                    // Phase transition: Disappear and start train bullet pattern
                    else if (b.phase === 1 && b.hp / b.hpMax <= 0.5) {
                        b.phase = 2;
                        b.disappearPhase = true;
                        b.disappearStartTime = performance.now();
                        b.isInvincible = true;
                        b.visible = false; // Hide the boss

                        // Move boss offscreen below player so it can't be shot
                        b.x = W / 2;
                        b.y = H + 200; // Move well below the screen

                        // Update skull renderer position to be offscreen too
                        if (b.skullRenderer) {
                            b.skullRenderer.x = b.x;
                            b.skullRenderer.y = b.y;
                        }

                        playSound('shao_kahn'); // Skull laugh when disappearing
                        announce('THE DEATH ENGINE VANISHES INTO THE VOID!');

                        // Reset safe zone position and changes
                        b.safeZoneY = H * 0.5;
                        b.safeZoneChanges = 0;
                    }
                    // Phase 2: Disappear phase with train bullets
                    else if (b.disappearPhase) {
                        const disappearTime = (performance.now() - b.disappearStartTime) / 1000;

                        // Spawn train bullets continuously - 2 chunks moving opposite directions with safe zone in middle
                        if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                        b.trainBulletTimer -= dt;

                        if (b.trainBulletTimer <= 0) {
                            b.trainBulletTimer = 0.08; // Very frequent spawning

                            const safeZoneHeight = 120; // Safe zone in middle
                            const safeZoneY = H * 0.5; // Center of screen
                            const bulletSpeed = 280;
                            const bulletSpacing = 25;

                            // Top chunk: bullets moving right to left (from top)
                            const topBoundary = safeZoneY - safeZoneHeight / 2;
                            if (topBoundary > 30) {
                                for (let y = 0; y < topBoundary; y += bulletSpacing) {
                                    store.eBullets.push({
                                        x: -10, y: y,
                                        vx: bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }
                            }

                            // Bottom chunk: bullets moving left to right (from bottom)
                            const bottomBoundary = safeZoneY + safeZoneHeight / 2;
                            if (bottomBoundary < H - 30) {
                                for (let y = bottomBoundary; y < H; y += bulletSpacing) {
                                    store.eBullets.push({
                                        x: W + 10, y: y,
                                        vx: -bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }
                            }
                        }

                        // Return after 4 seconds (single phase)
                        if (disappearTime > 4) {
                            b.disappearPhase = false;
                            b.visible = true;
                            b.isInvincible = false;
                            b.fireT = 1.0;

                            // Reposition boss
                            b.x = W / 2;
                            b.y = 100;

                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }

                            playSound('shao_kahn'); // Another laugh as he returns
                            announce('THE DEATH ENGINE RETURNS!');
                        }
                    }
                    // Second disappear phase (enraged) - 2 fields of bullets with contact safe zone
                    else if (b.disappearPhase && b.hasDoneSecondDisappear) {
                        const disappearTime = (performance.now() - b.disappearStartTime) / 1000;

                        // Spawn train bullets continuously - 2 fields going opposite directions with contact safe zone
                        if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                        b.trainBulletTimer -= dt;

                        if (b.trainBulletTimer <= 0) {
                            b.trainBulletTimer = 0.06; // Even more frequent spawning for enraged phase

                            const safeZoneWidth = 60; // Narrower safe zone - contact without buffer
                            const safeZoneX = W * 0.5; // Center of screen
                            const bulletSpeed = 320; // Faster bullets
                            const bulletSpacing = 20;

                            // Left field: bullets moving right (from left side)
                            const leftBoundary = safeZoneX - safeZoneWidth / 2;
                            if (leftBoundary > 30) {
                                for (let x = 0; x < leftBoundary; x += bulletSpacing) {
                                    for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                        store.eBullets.push({
                                            x: x, y: y,
                                            vx: bulletSpeed, vy: 0,
                                            r: 5, col: '#FF0000',
                                            dmg: 30 * dmgScale, // Higher damage
                                            life: (W + 20) / bulletSpeed + 1,
                                            fadeInTime: 2.0, // 2 second fade-in
                                            spawnTime: performance.now()
                                        });
                                    }
                                }
                            }

                            // Right field: bullets moving left (from right side)
                            const rightBoundary = safeZoneX + safeZoneWidth / 2;
                            if (rightBoundary < W - 30) {
                                for (let x = rightBoundary; x < W; x += bulletSpacing) {
                                    for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                        store.eBullets.push({
                                            x: x, y: y,
                                            vx: -bulletSpeed, vy: 0,
                                            r: 5, col: '#FF0000',
                                            dmg: 30 * dmgScale, // Higher damage
                                            life: (W + 20) / bulletSpeed + 1,
                                            fadeInTime: 2.0, // 2 second fade-in
                                            spawnTime: performance.now()
                                        });
                                    }
                                }
                            }
                        }

                        // Return after 5 seconds (longer enraged phase)
                        if (disappearTime > 5) {
                            b.disappearPhase = false;
                            b.visible = true;
                            b.isInvincible = false;
                            b.fireT = 0.5; // Very aggressive after returning

                            // Reposition boss
                            b.x = W / 2;
                            b.y = 100;

                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }

                            playSound('shao_kahn'); // Final laugh as he returns
                            announce('THE DEATH ENGINE RETURNS FOR THE FINAL ASSAULT!');
                        }
                    }
                    // Phase 2: Normal combat after returning
                    else if (b.phase === 2 && !b.disappearPhase) {
                        // Calculate health percentage for final phase mechanics
                        const healthPercent = b.hp / b.hpMax;
                        const isFinalPhase = healthPercent <= 0.25; // Final phase at 25% health

                        // Second disappear phase when enraged (red)
                        if (isFinalPhase && !b.hasDoneSecondDisappear) {
                            b.hasDoneSecondDisappear = true;
                            b.disappearPhase = true;
                            b.disappearStartTime = performance.now();
                            b.isInvincible = true;
                            b.visible = false;

                            // Move boss offscreen
                            b.x = W / 2;
                            b.y = H + 200;

                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }

                            playSound('shao_kahn'); // Skull laugh when disappearing again
                            announce('THE DEATH ENGINE VANISHES INTO THE VOID AGAIN!');

                            // Reset bullet timer
                            b.trainBulletTimer = 0;
                        }

                        // Red coloration and faster movement in final phase
                        const moveSpeed = isFinalPhase ? 0.9 : 0.6; // Faster movement when low on health
                        if (b.y >= 100) {
                            b.moveT += dt;
                            b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed);
                            // Update skull renderer position
                            if (b.skullRenderer) {
                                b.skullRenderer.x = b.x;
                                b.skullRenderer.y = b.y;
                            }
                        }

                        // Override skull ship color to red when in final phase
                        if (isFinalPhase && b.color !== '#FF0000') {
                            b.color = '#FF0000'; // Turn red in final phase
                        }

                        // ENRAGE PHASE: Spawn 1/4 density of intermission bullets passing through play field
                        if (isFinalPhase) {
                            if (!b.enrageBulletTimer) b.enrageBulletTimer = 0;
                            b.enrageBulletTimer -= dt;

                            if (b.enrageBulletTimer <= 0) {
                                b.enrageBulletTimer = 0.32; // 1/4 density of normal intermission (0.08 * 4)

                                const bulletSpeed = 280;
                                const bulletSpacing = 25;

                                // Spawn bullets from left side moving right (top half)
                                for (let y = 0; y < H * 0.5; y += bulletSpacing * 4) { // Every 4th bullet spacing
                                    store.eBullets.push({
                                        x: -10, y: y,
                                        vx: bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }

                                // Spawn bullets from right side moving left (bottom half)
                                for (let y = H * 0.5; y < H; y += bulletSpacing * 4) { // Every 4th bullet spacing
                                    store.eBullets.push({
                                        x: W + 10, y: y,
                                        vx: -bulletSpeed, vy: 0,
                                        r: 6, col: '#FF0000',
                                        dmg: 25 * dmgScale,
                                        life: (W + 20) / bulletSpeed + 1,
                                        fadeInTime: 2.0, // 2 second fade-in
                                        spawnTime: performance.now()
                                    });
                                }
                            }
                        }

                        // More aggressive attacks, even faster in final phase
                        const fireRate = isFinalPhase ? 1.2 : 1.8; // Faster attacks in final phase
                        b.fireT -= dt;
                        if (b.fireT <= 0) {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = fireRate;
                            switch (b.attackPhase) {
                                case 0:
                                    // Trigger Death Engine laugh
                                    b.isLaughing = true;
                                    b.laughStartTime = performance.now();
                                    if (b.skullRenderer) {
                                        b.skullRenderer.triggerAttack(true);
                                    }
                                    // Dense spiral (more bullets in final phase)
                                    const n = isFinalPhase ? 20 : 16;
                                    for (let i = 0; i < n; i++) {
                                        const a = (i * 2 * Math.PI / n) + b.t * 1.2;
                                        const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 200 * Math.cos(a), vy: 200 * Math.sin(a), r: 5, col: bulletColor, dmg: 20 * dmgScale });
                                    }
                                    break;
                                case 1:
                                    // Triple aimed shots (more spread in final phase)
                                    const shotCount = isFinalPhase ? 9 : 7;
                                    const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    for (let i = 0; i < shotCount; i++) {
                                        const angle = angleToPlayer + (i - Math.floor(shotCount / 2)) * 0.12;
                                        const bulletColor = isFinalPhase ? '#FF0000' : '#FF4500';
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 320 * Math.cos(angle), vy: 320 * Math.sin(angle), r: 5, col: bulletColor, dmg: 25 * dmgScale });
                                    }
                                    break;
                                case 2:
                                    // More gold (significantly more in final phase)
                                    const basegold = 3 + Math.floor(store.world.wave / 8);
                                    const finalPhaseBonus = isFinalPhase ? Math.floor(basegold * 0.75) : 0; // 75% more adds in final phase
                                    const numgold = basegold + finalPhaseBonus;
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (Math.random() - 0.5) * 150;
                                        gold.y = b.y + 60;
                                        gold.color = isFinalPhase ? '#FF0000' : '#FF0000';
                                        gold.hp *= isFinalPhase ? 1.5 : 1.3; // Tougher adds in final phase
                                        store.enemies.push(gold);
                                    }
                                    break;
                                case 3:
                                    // Cross pattern (more layers in final phase)
                                    const layers = isFinalPhase ? 4 : 3;
                                    for (let i = 0; i < 4; i++) {
                                        const angle = i * Math.PI / 2;
                                        for (let j = 1; j <= layers; j++) {
                                            const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                            store.eBullets.push({
                                                x: b.x, y: b.y,
                                                vx: 180 * j * 0.7 * Math.cos(angle),
                                                vy: 180 * j * 0.7 * Math.sin(angle),
                                                r: 4, col: bulletColor, dmg: 18 * dmgScale
                                            });
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                } else {
                    // Original GEOMETRON logic (unchanged)
                    if (b.hp / b.hpMax < 0.5 && b.phase === 1) {
                        b.phase = 2;
                        b.isInvincible = true;
                        playSound('horn');
                        store.activeEffects.push(createEffect("bossPhaseChange", b.x, b.y));
                        b.attackPhase = 0;
                        b.fireT = 2.0;
                        setTimeout(() => { b.isInvincible = false; }, 2000);
                        announce('GEOMETRON ENRAGED!');
                    }

                    // Movement logic
                    if (b.y >= 100) {
                        b.moveT += dt;
                        const moveSpeed = (b.phase === 1) ? 0.3 : 0.7;
                        b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed);
                    }

                    // Attack logic
                    b.fireT -= dt;
                    if (b.fireT <= 0) {
                        if (b.phase === 1) {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = 2.5;
                            switch (b.attackPhase) {
                                case 0:
                                case 2:
                                    const n = 16;
                                    for (let i = 0; i < n; i++) {
                                        const a = (i * 2 * Math.PI / n) + b.t * 0.5;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale });
                                    }
                                    break;
                                case 1:
                                case 3:
                                    const numgold = 3 + Math.floor(store.world.wave / 10);
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (Math.random() - 0.5) * 100;
                                        gold.y = b.y + 50;
                                        store.enemies.push(gold);
                                    }
                                    break;
                            }
                        } else {
                            b.attackPhase = (b.attackPhase + 1) % 4;
                            b.fireT = 2.0;
                            switch (b.attackPhase) {
                                case 0:
                                case 2:
                                    const spread = 8;
                                    const numShots = 8;
                                    const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    for (let i = 0; i < numShots; i++) {
                                        const angle = angleToPlayer + (i - (numShots - 1) / 2) * (spread * Math.PI / 180) * 0.1;
                                        store.eBullets.push({ x: b.x, y: b.y, vx: 350 * Math.cos(angle), vy: 350 * Math.sin(angle), r: 4, col: '#ff4500', dmg: 22 * dmgScale, life: 2.0 });
                                    }
                                    break;
                                case 1:
                                case 3:
                                    const numgold = 2;
                                    for (let i = 0; i < numgold; i++) {
                                        const gold = spawnEnemy('construct_gold');
                                        gold.x = b.x + (i === 0 ? -50 : 50);
                                        gold.y = b.y + 50;
                                        gold.hp *= 1.5;
                                        gold.v *= 1.3;
                                        gold.color = '#ff4500';
                                        store.enemies.push(gold);
                                    }
                                    break;
                            }
                        }
                    }
                }
            }
            function stepBossVoidRaven(dt, b, dmgScale) { b.moveT += dt; if (!b.isDiving) { b.y = 100 + Math.sin(b.moveT * 2) * 20; b.x = W / 2 + Math.cos(b.moveT * 0.5) * (W / 2 - 100); } b.fireT -= dt; if (b.fireT <= 0) { b.attackPhase = (b.attackPhase + 1) % 5; switch (b.attackPhase) { case 0: case 2: b.fireT = 1.2; for (let i = 0; i < 7; i++) { const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: '#4169e1', dmg: 18 * dmgScale }); } break; case 1: case 3: b.fireT = 2.0; const numHatchlings = 2 + Math.floor(store.world.wave / 15); for (let i = 0; i < numHatchlings; i++) { const hatchling = spawnEnemy('avian_hatchling'); hatchling.x = b.x + (Math.random() - 0.5) * 80; hatchling.y = b.y + 40; store.enemies.push(hatchling); } break; case 4: b.fireT = 4.0; b.isDiving = true; b.diveTarget = { x: store.player.x, y: store.player.y }; const dx = b.diveTarget.x - b.x; const dy = b.diveTarget.y - b.y; const dist = Math.sqrt(dx * dx + dy * dy); b.vx = (dx / dist) * 400; b.vy = (dy / dist) * 400; setTimeout(() => { b.isDiving = false; b.vx = 0; b.vy = 30; }, 1500); break; } } if (b.isDiving) { b.x += b.vx * dt; b.y += b.vy * dt; } }

            function stepBossBroodlord(dt, b, dmgScale) {
                // Initialize poison puddles array if not exists
                if (!store.poisonPuddles) {
                    store.poisonPuddles = [];
                }

                // Broodlord skittering movement
                b.moveT += dt;
                if (!b.spiderInit) {
                    b.spiderInit = true;
                    b.spiderVX = (Math.random() < 0.5 ? -1 : 1) * (120 + Math.random() * 40);
                    b.spiderVY = 90 + Math.random() * 50;
                    b.webRetargetT = 1.4;
                    b.poisonTrailT = 1.2;
                }

                const speedScale = 1 + Math.min(0.75, Math.max(0, store.world.wave - 10) * 0.02);
                b.x += b.spiderVX * speedScale * dt;
                b.y += b.spiderVY * speedScale * dt;

                const minX = 90;
                const maxX = W - 90;
                const minY = 90;
                const maxY = Math.min(H - 170, H * 0.78);

                if (b.x <= minX && b.spiderVX < 0) {
                    b.x = minX;
                    b.spiderVX = Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
                    b.spiderVY += (Math.random() - 0.5) * 140;
                } else if (b.x >= maxX && b.spiderVX > 0) {
                    b.x = maxX;
                    b.spiderVX = -Math.abs(b.spiderVX) * (0.9 + Math.random() * 0.25);
                    b.spiderVY += (Math.random() - 0.5) * 140;
                }

                if (b.y <= minY && b.spiderVY < 0) {
                    b.y = minY;
                    b.spiderVY = Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
                    b.spiderVX += (Math.random() - 0.5) * 110;
                } else if (b.y >= maxY && b.spiderVY > 0) {
                    b.y = maxY;
                    b.spiderVY = -Math.abs(b.spiderVY) * (0.9 + Math.random() * 0.25);
                    b.spiderVX += (Math.random() - 0.5) * 110;
                }

                b.spiderVX = clamp(b.spiderVX, -260, 260);
                b.spiderVY = clamp(b.spiderVY, -240, 240);

                b.webRetargetT -= dt;
                if (b.webRetargetT <= 0) {
                    const player = store.player;
                    const dx = player.x - b.x;
                    const dy = (player.y - 40) - b.y;
                    const dist = Math.max(120, Math.hypot(dx, dy));
                    const chaseStrengthX = 180 + Math.random() * 60;
                    const chaseStrengthY = 170 + Math.random() * 60;
                    b.spiderVX = clamp(b.spiderVX * 0.5 + (dx / dist) * chaseStrengthX, -260, 260);
                    b.spiderVY = clamp(b.spiderVY * 0.5 + (dy / dist) * chaseStrengthY, -240, 240);
                    b.webRetargetT = 1.3 + Math.random() * 0.9;
                }

                b.poisonTrailT -= dt;
                if (b.poisonTrailT <= 0) {
                    const puddleX = clamp(b.x + (Math.random() - 0.5) * 120, 40, W - 40);
                    const puddleY = clamp(b.y + Math.random() * 120, 80, H - 80);
                    store.poisonPuddles.push({
                        x: puddleX,
                        y: puddleY,
                        r: 18 + Math.random() * 12,
                        life: getHivePuddleLifetime(4.8, 3.2, { min: 4.2, maxWaveBonus: 4.5 }),
                        damage: 10 * dmgScale,
                        created: performance.now()
                    });
                    const trailReset = 2.4 - Math.min(1.4, store.world.wave * 0.035);
                    b.poisonTrailT = Math.max(0.9, trailReset);
                }

                // Attack phases
                b.fireT -= dt;
                if (b.fireT <= 0) {
                    b.attackPhase = (b.attackPhase + 1) % 4;

                    switch (b.attackPhase) {
                        case 0:
                        case 2:
                            // Poison blob barrage - green from mouth, brown from rear
                            b.fireT = 1.8;
                            const numBlobs = 5 + Math.floor(store.world.wave / 10);
                            
                            // Decide if this attack is solo blobs or clusters
                            const useClusters = Math.random() < 0.85; // 85% clusters, 15% solo
                            
                            if (useClusters) {
                                // GREEN BLOBS FROM MOUTH - clustered
                                const clusterSize = 2 + Math.floor(Math.random() * 3); // 2-4 blobs per cluster
                                const numClusters = Math.ceil(numBlobs / clusterSize);
                                
                                for (let c = 0; c < numClusters; c++) {
                                    const clusterBlobs = c === numClusters - 1 ? numBlobs - (c * clusterSize) : clusterSize;
                                    const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    const clusterSpread = (Math.random() - 0.5) * 0.3; // Slight variance per cluster
                                    
                                    for (let i = 0; i < clusterBlobs; i++) {
                                        const spread = Math.PI * 0.25; // Tighter spread within cluster
                                        const angle = baseAngle + clusterSpread + (Math.random() - 0.5) * spread;
                                        const speed = 180 + Math.random() * 80;
                                        
                                        const mouthOffsetDistance = 70;
                                        const mouthX = b.x + Math.cos(baseAngle) * mouthOffsetDistance;
                                        const mouthY = b.y + Math.sin(baseAngle) * mouthOffsetDistance;

                                        store.eBullets.push({
                                            x: mouthX,
                                            y: mouthY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            r: 8,
                                            col: '#7cfc00',
                                            dmg: 22 * dmgScale,
                                            life: 4,
                                            type: 'poisonBlob'
                                        });
                                    }
                                }
                                
                                // BROWN BLOBS FROM REAR - clustered
                                for (let c = 0; c < numClusters; c++) {
                                    const clusterBlobs = c === numClusters - 1 ? numBlobs - (c * clusterSize) : clusterSize;
                                    const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                    const rearAngle = baseAngle + Math.PI;
                                    const clusterSpread = (Math.random() - 0.5) * 0.3; // Slight variance per cluster
                                    
                                    for (let i = 0; i < clusterBlobs; i++) {
                                        const spread = Math.PI * 0.25; // Tighter spread within cluster
                                        const angle = rearAngle + clusterSpread + (Math.random() - 0.5) * spread;
                                        const speed = 180 + Math.random() * 80;
                                        
                                        const rearOffsetDistance = 40;
                                        const rearX = b.x - Math.cos(baseAngle) * rearOffsetDistance;
                                        const rearY = b.y - Math.sin(baseAngle) * rearOffsetDistance;

                                        store.eBullets.push({
                                            x: rearX,
                                            y: rearY,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            r: 8,
                                            col: '#8B4513',
                                            dmg: 22 * dmgScale,
                                            life: 4,
                                            type: 'poisonBlob'
                                        });
                                    }
                                }
                            } else {
                                // SOLO BLOBS - spread out more
                                const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                                
                                // GREEN SOLO BLOBS FROM MOUTH
                                for (let i = 0; i < numBlobs; i++) {
                                    const spread = Math.PI * 0.8; // Wide spread for solo
                                    const angle = baseAngle + (Math.random() - 0.5) * spread;
                                    const speed = 180 + Math.random() * 80;
                                    
                                    const mouthOffsetDistance = 70;
                                    const mouthX = b.x + Math.cos(baseAngle) * mouthOffsetDistance;
                                    const mouthY = b.y + Math.sin(baseAngle) * mouthOffsetDistance;

                                    store.eBullets.push({
                                        x: mouthX,
                                        y: mouthY,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        r: 8,
                                        col: '#7cfc00',
                                        dmg: 22 * dmgScale,
                                        life: 4,
                                        type: 'poisonBlob'
                                    });
                                }
                                
                                // BROWN SOLO BLOBS FROM REAR
                                for (let i = 0; i < numBlobs; i++) {
                                    const spread = Math.PI * 0.8; // Wide spread for solo
                                    const rearAngle = baseAngle + Math.PI;
                                    const angle = rearAngle + (Math.random() - 0.5) * spread;
                                    const speed = 180 + Math.random() * 80;
                                    
                                    const rearOffsetDistance = 40;
                                    const rearX = b.x - Math.cos(baseAngle) * rearOffsetDistance;
                                    const rearY = b.y - Math.sin(baseAngle) * rearOffsetDistance;

                                    store.eBullets.push({
                                        x: rearX,
                                        y: rearY,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        r: 8,
                                        col: '#8B4513',
                                        dmg: 22 * dmgScale,
                                        life: 4,
                                        type: 'poisonBlob'
                                    });
                                }
                            }
                            break;

                        case 1:
                            // Acid spit pattern
                            b.fireT = 2.2;
                            for (let i = 0; i < 8; i++) {
                                const angle = (i * Math.PI / 4) + b.t * 0.5;
                                store.eBullets.push({
                                    x: b.x,
                                    y: b.y,
                                    vx: Math.cos(angle) * 160,
                                    vy: Math.sin(angle) * 160,
                                    r: 6,
                                    col: '#adff2f',
                                    dmg: 20 * dmgScale,
                                    life: 3,
                                    type: 'poisonBlob'
                                });
                            }
                            break;

                        case 3:
                            // Toxic ground slam - saturate arena with dangerous puddles
                            b.fireT = 2.6;
                            const playerPos = store.player;
                            const webSpots = [
                                { x: clamp(playerPos.x, 80, W - 80), y: clamp(playerPos.y + 40, 120, H - 90) },
                                { x: clamp(playerPos.x + 180, 80, W - 80), y: clamp(playerPos.y - 20, 120, H - 90) },
                                { x: clamp(playerPos.x - 180, 80, W - 80), y: clamp(playerPos.y + 80, 120, H - 90) },
                                { x: W * 0.25 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                                { x: W * 0.75 + (Math.random() - 0.5) * 120, y: H * 0.35 + Math.random() * H * 0.35 },
                                { x: W * 0.5 + (Math.random() - 0.5) * 220, y: H * 0.55 + (Math.random() - 0.5) * 140 }
                            ];
                            for (let i = 0; i < 6; i++) {
                                const node = webSpots[i % webSpots.length];
                                const puddleX = clamp(node.x + (Math.random() - 0.5) * 70, 40, W - 40);
                                const puddleY = clamp(node.y + (Math.random() - 0.5) * 70, 80, H - 70);
                                store.poisonPuddles.push({
                                    x: puddleX,
                                    y: puddleY,
                                    r: 28 + Math.random() * 18,
                                    life: getHivePuddleLifetime(7.5, 4.5, { min: 6.5, waveBonusPer: 0.4, maxWaveBonus: 6.5 }),
                                    damage: 15 * dmgScale,
                                    created: performance.now()
                                });
                            }
                            break;
                    }
                }

                const now = performance.now();
                const bossRadius = b.r || 80;
                const puddleDamageInterval = 600; // ms between damage ticks while boss is in the acid

                for (let i = store.poisonPuddles.length - 1; i >= 0; i--) {
                    const puddle = store.poisonPuddles[i];
                    puddle.life -= dt;
                    if (puddle.life <= 0) {
                        store.poisonPuddles.splice(i, 1);
                        continue;
                    }

                    const dx = b.x - puddle.x;
                    const dy = b.y - puddle.y;
                    const dist = Math.hypot(dx, dy);
                    const effectiveRadius = puddle.r + bossRadius * 0.55;

                    if (dist < effectiveRadius) {
                        // Standing in the acid slows and harms the Hive Sovereign
                        b.slowTimer = Math.max(b.slowTimer || 0, 0.45);

                        if (!b.lastPuddleDamageTime || now - b.lastPuddleDamageTime >= puddleDamageInterval) {
                            const puddleDamage = Math.max(8, puddle.damage * 0.9);
                            b.hp -= puddleDamage;
                            store.world.totalDamage += puddleDamage;
                            b.lastPuddleDamageTime = now;

                            if (b.hp <= 0) {
                                handleBossDefeat();
                                return;
                            }
                        }
                    }
                }
            }

            function stepBoss(dt) {
                const b = store.boss;
                b.t += dt;
                const dmgScale = Math.pow(1.065, store.world.wave - 1);
                tickChampionBurn(b, dt);
                tickChampionVoidMarks(b, dt);

                // BOSS IMMUNITY: Bosses are completely immune to movement-affecting debuffs
                // They can still take damage from ice/poison/fire, but movement is unaffected
                
                // Ice stacks still apply damage multiplier but NOT movement slow
                if (b.iceStacks && b.iceStacks > 0) {
                    b.iceStackTimer = Math.max(0, (b.iceStackTimer || 0) - dt);
                    if (b.iceStackTimer <= 0) {
                        b.iceStacks = 0;
                        delete b.iceStackTimer;
                        delete b.iceDamageMultiplier;
                        if (b.isFrozen) delete b.isFrozen;
                    } else {
                        const activeStacks = Math.min(b.iceStacks, 3);
                        b.iceDamageMultiplier = 1 + (0.1 * activeStacks);
                        
                        // Set visual frozen state for ice overlay only
                        if (activeStacks >= 3) {
                            b.isFrozen = true;
                        } else if (b.isFrozen) {
                            delete b.isFrozen;
                        }
                    }
                } else {
                    if (b.isFrozen) delete b.isFrozen;
                    if (b.iceDamageMultiplier !== undefined) delete b.iceDamageMultiplier;
                }

                // Clear any movement-affecting timers/multipliers - bosses ignore these
                if (b.slowTimer) delete b.slowTimer;
                if (b.speedMultiplier !== undefined) delete b.speedMultiplier;

                // Use full dt for boss behavior - no movement slowdown ever
                const behaviourDt = dt;

                if (b.y < 100) {
                    b.y += b.vy * behaviourDt;
                }

                switch (b.behavior) {
                    case 'vibemaster': stepBossVibemaster(behaviourDt, b, dmgScale); break;
                    case 'gemini': stepBossGemini(behaviourDt, b, dmgScale); break;
                    case 'sentinel': stepBossOmegaSentinel(behaviourDt, b, dmgScale); break;
                    case 'aegis_architect': stepBossCoreAegisArchitect(behaviourDt, b, dmgScale); break;
                    case 'hex': stepBossTheHex(behaviourDt, b, dmgScale); break;
                    case 'construct': stepBossGeometron(behaviourDt, b, dmgScale); break;
                    case 'shadow_clone': stepBossShadowClone(behaviourDt, b, dmgScale); break;
                    case 'avian': stepBossVoidRaven(behaviourDt, b, dmgScale); break;
                    case 'broodlord': stepBossBroodlord(behaviourDt, b, dmgScale); break;
                    case 'asynchronos': stepBossAsynchronos(behaviourDt, b, dmgScale); break;
                }
            }
            function drawMissile(m) {
                ctx.save();
                ctx.translate(m.x, m.y);
                ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2);

                if (m.isStealth) {
                    // Advanced stealth rocket design - sleeker and more futuristic
                    ctx.fillStyle = "#2a2a2a"; // Dark metallic body
                    ctx.strokeStyle = "#00ffff"; // Cyan highlights
                    ctx.lineWidth = 1;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 15;

                    // Main body - longer and sleeker
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(3, 0);
                    ctx.lineTo(2, 6);
                    ctx.lineTo(-2, 6);
                    ctx.lineTo(-3, 0);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Stealth fins
                    ctx.beginPath();
                    ctx.moveTo(-2, 2);
                    ctx.lineTo(-5, 4);
                    ctx.lineTo(-2, 6);
                    ctx.moveTo(2, 2);
                    ctx.lineTo(5, 4);
                    ctx.lineTo(2, 6);
                    ctx.stroke();

                    // Advanced plasma exhaust
                    const flameSize = 10 + 3 * Math.sin(performance.now() / 30);
                    const grad = ctx.createLinearGradient(0, 6, 0, 6 + flameSize);
                    grad.addColorStop(0, 'rgba(0, 255, 255, 0.9)');
                    grad.addColorStop(0.5, 'rgba(0, 150, 255, 0.7)');
                    grad.addColorStop(1, 'rgba(0, 100, 200, 0.3)');
                    ctx.fillStyle = grad;

                    ctx.beginPath();
                    ctx.moveTo(-2, 6);
                    ctx.lineTo(2, 6);
                    ctx.lineTo(1, 6 + flameSize * 0.7);
                    ctx.lineTo(0, 6 + flameSize);
                    ctx.lineTo(-1, 6 + flameSize * 0.7);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Regular missile design
                    ctx.fillStyle = m.isIceman ? "#a0e9ff" : "#ffddff";
                    ctx.shadowColor = m.isIceman ? '#3c9aed' : '#ff8080';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(4, 5);
                    ctx.lineTo(-4, 5);
                    ctx.closePath();
                    ctx.fill();

                    ctx.shadowBlur = 0;

                    const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
                    ctx.fillStyle = m.isIceman ? `rgba(60, 154, 237, ${0.6 + 0.4 * Math.random()})` : `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;

                    ctx.beginPath();
                    ctx.moveTo(-3, 5);
                    ctx.lineTo(3, 5);
                    ctx.lineTo(0, 5 + flameSize);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
            
            function drawTombstone(t) {
                if (t.dead || t.hp <= 0) return;
                
                ctx.save();
                ctx.translate(t.x, t.y);
                
                const time = performance.now() / 1000;
                const pulse = 0.9 + 0.1 * Math.sin(time * 2);
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(0, t.r * 1.2, t.r * 0.9, t.r * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Tombstone base/pedestal
                ctx.fillStyle = '#3a2f4a';
                ctx.strokeStyle = '#2a1f3a';
                ctx.lineWidth = 2;
                ctx.fillRect(-t.r * 0.9, t.r * 0.7, t.r * 1.8, t.r * 0.4);
                ctx.strokeRect(-t.r * 0.9, t.r * 0.7, t.r * 1.8, t.r * 0.4);
                
                // Main tombstone shape
                const grad = ctx.createLinearGradient(0, -t.r * 1.2, 0, t.r * 0.7);
                grad.addColorStop(0, '#5a4a6a');
                grad.addColorStop(0.6, t.color);
                grad.addColorStop(1, '#3a2a4a');
                ctx.fillStyle = grad;
                ctx.strokeStyle = '#2a1a3a';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(-t.r * 0.8, t.r * 0.7);
                ctx.lineTo(-t.r * 0.8, -t.r * 0.5);
                ctx.quadraticCurveTo(-t.r * 0.8, -t.r * 1.1, 0, -t.r * 1.2);
                ctx.quadraticCurveTo(t.r * 0.8, -t.r * 1.1, t.r * 0.8, -t.r * 0.5);
                ctx.lineTo(t.r * 0.8, t.r * 0.7);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Cracks
                ctx.strokeStyle = '#2a1a2a';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(-t.r * 0.3, -t.r * 0.8);
                ctx.lineTo(-t.r * 0.5, -t.r * 0.3);
                ctx.moveTo(t.r * 0.4, -t.r * 0.6);
                ctx.lineTo(t.r * 0.2, 0);
                ctx.stroke();
                
                // Glowing runes/symbols
                ctx.save();
                ctx.globalAlpha = 0.6 + 0.4 * pulse;
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#00ff88';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('â˜ ', 0, -t.r * 0.3);
                ctx.restore();
                
                // Health bar
                const barWidth = t.r * 1.6;
                const barHeight = 4;
                const barY = -t.r * 1.5;
                const hpRatio = t.hp / t.hpMax;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(-barWidth / 2, barY, barWidth, barHeight);
                
                ctx.fillStyle = hpRatio > 0.5 ? '#00ff88' : (hpRatio > 0.25 ? '#ffaa00' : '#ff4444');
                ctx.fillRect(-barWidth / 2, barY, barWidth * hpRatio, barHeight);
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(-barWidth / 2, barY, barWidth, barHeight);
                
                ctx.restore();
            }
            
            function drawPowerup(p) {
                const cfg = POWERUP_TYPES[p.type];
                ctx.save();
                ctx.translate(p.x, p.y);

                const time = performance.now();
                const pulse = 0.8 + 0.2 * Math.sin(time / 150 + (p.pulseOffset || 0));
                ctx.scale(pulse, pulse);

                let glowInner = '#FFD70099';
                let glowOuter = '#FFD70000';
                let coreFill = '#FFD70044';
                let borderColor = '#FFD700';
                let iconColor = '#FFFFFF';
                let iconFont = 'bold 16px Orbitron';

                if (p.type === 'shadow_champion_token') {
                    glowInner = 'rgba(160, 180, 255, 0.85)';
                    glowOuter = 'rgba(80, 100, 235, 0)';
                    coreFill = 'rgba(80, 100, 220, 0.5)';
                    borderColor = 'rgba(220, 230, 255, 0.95)';
                    iconColor = '#f8f9ff';
                    iconFont = 'bold 18px Orbitron';
                } else if (p.type === 'collar_fragment') {
                    glowInner = 'rgba(90, 255, 210, 0.85)';
                    glowOuter = 'rgba(30, 150, 140, 0)';
                    coreFill = 'rgba(50, 220, 190, 0.5)';
                    borderColor = 'rgba(180, 255, 235, 0.95)';
                    iconColor = '#eafff5';
                    iconFont = 'bold 18px Orbitron';
                } else if (p.type === 'champion_upgrade') {
                    if (p.isVoidReaper) {
                        glowInner = 'rgba(70, 255, 195, 0.9)';
                        glowOuter = 'rgba(190, 100, 255, 0)';
                        coreFill = 'rgba(40, 210, 160, 0.55)';
                        borderColor = 'rgba(230, 255, 245, 0.95)';
                        iconColor = '#eafff8';
                    } else {
                        glowInner = 'rgba(90, 255, 210, 0.88)';
                        glowOuter = 'rgba(30, 160, 120, 0)';
                        coreFill = 'rgba(40, 200, 150, 0.5)';
                        borderColor = 'rgba(170, 255, 230, 0.95)';
                        iconColor = '#e4fff5';
                    }
                    iconFont = 'bold 18px Orbitron';
                } else if (p.isVoidReaper && p.type === 'cash') {
                    // New Orleans style - purple & gold
                    glowInner = 'rgba(138, 43, 226, 0.85)'; // Purple
                    glowOuter = 'rgba(255, 215, 0, 0)'; // Gold fade
                    coreFill = 'rgba(138, 43, 226, 0.6)';
                    borderColor = 'rgba(255, 215, 0, 0.95)'; // Gold border
                    iconColor = '#FFD700';
                    iconFont = 'bold 18px Orbitron';
                }

                ctx.beginPath();
                ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2);
                const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3);
                glow.addColorStop(0, glowInner);
                glow.addColorStop(1, glowOuter);
                ctx.fillStyle = glow;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(0, 0, p.r, 0, Math.PI * 2);
                ctx.fillStyle = coreFill;
                ctx.fill();

                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                if (p.type === 'shadow_champion_token') {
                    const spin = (time / 480) % (Math.PI * 2);
                    ctx.save();
                    ctx.rotate(spin);
                    ctx.strokeStyle = 'rgba(245, 247, 255, 0.75)';
                    ctx.lineWidth = 1.2;
                    ctx.beginPath();
                    const runeRadius = p.r * 0.65;
                    ctx.moveTo(-runeRadius, 0);
                    ctx.lineTo(runeRadius, 0);
                    ctx.moveTo(0, -runeRadius);
                    ctx.lineTo(0, runeRadius);
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(235, 240, 255, 0.8)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, p.r * 0.45, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                } else if (p.type === 'collar_fragment') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.strokeStyle = 'rgba(160, 255, 235, 0.8)';
                    ctx.lineWidth = 1.4;
                    ctx.beginPath();
                    const ringRadius = p.r * (0.55 + 0.08 * Math.sin(time / 260 + (p.pulseOffset || 0)));
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.fillStyle = iconColor;
                ctx.font = iconFont;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const iconGlyph = cfg ? (cfg.canvasIcon || cfg.icon || '') : '';
                if (iconGlyph) {
                    ctx.fillText(iconGlyph, 0, 1);
                }
                ctx.restore();
            }
            function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }

            function drawLaser(laser) {
                ctx.save();
                const trailLength = 200;
                const angle = Math.atan2(laser.vy, laser.vx);
                const startX = laser.x - Math.cos(angle) * trailLength;
                const startY = laser.y - Math.sin(angle) * trailLength;

                const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
                grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
                grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
                grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

                ctx.strokeStyle = grad;
                ctx.lineWidth = laser.r * 1.5;
                ctx.lineCap = 'round';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 25;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(laser.x, laser.y);
                ctx.stroke();

                // Inner bright core
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = `rgba(200, 220, 255, 0.8)`;
                ctx.shadowBlur = 10;
                ctx.stroke();

                ctx.restore();
            }

            function drawTemporalBeam() {
                const beam = store.temporalBeam;
                const boss = store.boss;
                if (!beam || !beam.active || !boss || boss.dead || boss.behavior !== 'asynchronos') return;

                const angle = beam.angle || 0;
                const length = beam.length || Math.max(W, H) + 160;
                const width = beam.width || 32;
                const telegraph = clamp(beam.telegraph || 0, 0, 1);
                const skipPulse = clamp(beam.skipPulse || 0, 0, 1);
                const originOffset = beam.originOffset !== undefined ? beam.originOffset : 1;
                const now = performance.now() / 1000;

                ctx.save();
                ctx.translate(boss.x, boss.y);
                ctx.rotate(angle);
                ctx.globalCompositeOperation = 'lighter';

                const baseWidth = width * (telegraph > 0 ? (0.45 + 0.55 * (1 - telegraph)) : 1);
                const auraWidth = baseWidth * (2.5 + skipPulse * 0.6); // Wider, more visible aura
                const startOffset = -length * 0.12 * (1 - originOffset);

                // Enhanced outer glow for better visibility
                const outerGlowGradient = ctx.createLinearGradient(0, -auraWidth * 1.4, 0, auraWidth * 1.4);
                outerGlowGradient.addColorStop(0, 'rgba(111, 242, 255, 0)');
                outerGlowGradient.addColorStop(0.3, 'rgba(111, 242, 255, 0.15)');
                outerGlowGradient.addColorStop(0.7, 'rgba(111, 242, 255, 0.15)');
                outerGlowGradient.addColorStop(1, 'rgba(111, 242, 255, 0)');
                ctx.fillStyle = outerGlowGradient;
                ctx.fillRect(startOffset, -auraWidth * 1.4, length, auraWidth * 2.8);

                // Main aura - brighter and more menacing
                const auraGradient = ctx.createLinearGradient(0, -auraWidth, 0, auraWidth);
                auraGradient.addColorStop(0, 'rgba(140, 246, 255, 0)');
                auraGradient.addColorStop(0.35, 'rgba(140, 246, 255, 0.45)'); // Increased from 0.24
                auraGradient.addColorStop(0.65, 'rgba(140, 246, 255, 0.45)');
                auraGradient.addColorStop(1, 'rgba(140, 246, 255, 0)');
                ctx.fillStyle = auraGradient;
                ctx.fillRect(startOffset, -auraWidth, length, auraWidth * 2);

                // Animated energy pulses traveling along beam
                const pulseCount = 3;
                for (let i = 0; i < pulseCount; i++) {
                    const pulsePhase = (now * 2 + i * (Math.PI * 2 / pulseCount)) % (Math.PI * 2);
                    const pulsePos = (Math.sin(pulsePhase) * 0.5 + 0.5) * length * 0.8;
                    const pulseRadius = baseWidth * 0.8;
                    const pulseGradient = ctx.createRadialGradient(pulsePos, 0, 0, pulsePos, 0, pulseRadius * 2);
                    pulseGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                    pulseGradient.addColorStop(0.5, 'rgba(140, 246, 255, 0.3)');
                    pulseGradient.addColorStop(1, 'rgba(140, 246, 255, 0)');
                    ctx.fillStyle = pulseGradient;
                    ctx.beginPath();
                    ctx.arc(pulsePos, 0, pulseRadius * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Brighter core with pulsing effect
                const coreWidth = Math.max(8, baseWidth * 0.5); // Slightly thicker
                const corePulse = 0.8 + Math.sin(now * 6) * 0.2;
                const coreGradient = ctx.createLinearGradient(0, -coreWidth, 0, coreWidth);
                coreGradient.addColorStop(0, 'rgba(255,255,255,0)');
                coreGradient.addColorStop(0.5, `rgba(255, 255, 255, ${(0.85 + skipPulse * 0.45) * corePulse})`); // Brighter white core
                coreGradient.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = coreGradient;
                ctx.fillRect(startOffset, -coreWidth, length, coreWidth * 2);

                if (telegraph > 0.01) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = clamp(telegraph * 0.95, 0.3, 0.85); // More visible warning
                    ctx.lineWidth = Math.max(3, baseWidth * 0.7);
                    ctx.strokeStyle = addAlpha('#ff6666', 0.9); // Red warning color
                    const dash = baseWidth * 1.2;
                    ctx.setLineDash([dash * 0.5, dash * 0.5]);
                    ctx.beginPath();
                    ctx.moveTo(startOffset, 0);
                    ctx.lineTo(startOffset + length, 0);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Add visible edge markers to show danger zone boundaries
                const markerCount = 12;
                const markerPulse = 0.7 + Math.sin(now * 8) * 0.3;
                ctx.fillStyle = `rgba(255, 100, 100, ${0.7 * markerPulse})`;
                for (let i = 0; i < markerCount; i++) {
                    const markerX = startOffset + (i / (markerCount - 1)) * length;
                    const markerSize = telegraph > 0.01 ? 6 : 4;
                    // Top edge markers
                    ctx.beginPath();
                    ctx.arc(markerX, -baseWidth, markerSize, 0, Math.PI * 2);
                    ctx.fill();
                    // Bottom edge markers
                    ctx.beginPath();
                    ctx.arc(markerX, baseWidth, markerSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (skipPulse > 0.01) {
                    const pulseRadius = baseWidth * (1.6 + skipPulse * 1.2);
                    const pulseCenter = Math.min(length * 0.5, length - pulseRadius * 1.2);
                    const pulseGradient = ctx.createRadialGradient(pulseCenter, 0, 0, pulseCenter, 0, pulseRadius);
                    pulseGradient.addColorStop(0, `rgba(210, 255, 255, ${0.55 + skipPulse * 0.4})`);
                    pulseGradient.addColorStop(1, 'rgba(210, 255, 255, 0)');
                    ctx.fillStyle = pulseGradient;
                    ctx.beginPath();
                    ctx.arc(pulseCenter, 0, pulseRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
            // Helper: safely add alpha to a hex color (falls back if not hex)
            function addAlpha(color, alpha) {
                const a = Math.max(0, Math.min(1, alpha));
                if (typeof color === 'string' && color.startsWith('#')) {
                    let hex = color.slice(1);
                    if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
                    if (hex.length >= 6) {
                        const r = parseInt(hex.slice(0, 2), 16);
                        const g = parseInt(hex.slice(2, 4), 16);
                        const b = parseInt(hex.slice(4, 6), 16);
                        return `rgba(${r},${g},${b},${a})`;
                    }
                }
                // If it's not hex, return as-is (the caller can tweak globalAlpha if needed)
                return color;
            }

            function drawEntityShadow(x, y, radiusX, radiusY, options = {}) {
                if (!Number.isFinite(x) || !Number.isFinite(y)) return;
                if (!Number.isFinite(radiusX) || radiusX <= 0) return;
                if (!Number.isFinite(radiusY) || radiusY <= 0) return;

                const {
                    alpha = 0.3,
                    yOffset = 0,
                    color = '0,0,0',
                    rotation = 0
                } = options;

                const clampedAlpha = Math.max(0, Math.min(1, alpha));
                if (clampedAlpha <= 0) return;

                ctx.save();
                ctx.translate(x, y + yOffset);
                if (rotation) {
                    ctx.rotate(rotation);
                }
                const scaleY = radiusY / radiusX;
                ctx.scale(1, scaleY);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radiusX);
                gradient.addColorStop(0, `rgba(${color}, ${clampedAlpha})`);
                gradient.addColorStop(1, `rgba(${color}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, radiusX, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Skull Ship Drawing Functions

            /**
             * @class Boss
             * Represents the main antagonist character.
             * This class encapsulates all logic for rendering, animating, and managing the state of the boss.
             */
            class Boss {
                /**
                 * @param {CanvasRenderingContext2D} ctx The 2D rendering context for the canvas.
                 * @param {number} x The initial X position of the boss.
                 * @param {number} y The initial Y position of the boss.
                 * @param {string} skullColor The color for the skull (supports red final phase).
                 */
                constructor(ctx, x, y, skullColor = '#e54d24') {
                    this.ctx = ctx;
                    this.x = x;
                    this.y = y;
                    this.skullColor = skullColor;

                    this.width = 180;
                    this.height = 280;

                    // Animation state
                    this.isAttacking = false;
                    this.attackStartTime = 0;
                    this.bloodDrips = [];
                }

                /**
                 * Triggers the boss's attack animation (laugh and scythe swipe).
                 * This should be called from the main game logic (e.g., on a timer or player action).
                 * @param {boolean} playAudio - Whether to play the laugh sound effect.
                 */
                triggerAttack(playAudio = true) {
                    if (!this.isAttacking) {
                        this.isAttacking = true;
                        this.attackStartTime = Date.now();

                        // Play death engine laugh sound using game's sound system
                        if (playAudio && typeof playSound !== 'undefined') {
                            playSound('shao_kahn');
                        }

                        // Reset the attack state after the animation duration
                        setTimeout(() => {
                            this.isAttacking = false;
                        }, 3000);
                    }
                }

                /**
                 * Updates the boss's state. This should be called every frame in the game loop.
                 * It handles internal animations like the blood drips.
                 */
                update() {
                    this._updateBloodDrips();
                }

                /**
                 * Renders the boss on the canvas. This should be called every frame in the game loop after `update`.
                 */
                draw() {
                    this.ctx.save();
                    this.ctx.translate(this.x, this.y);
                    this._drawHorns();
                    this._drawHead();
                    this._drawFacialFeatures();
                    this._addWeathering(); // Scars
                    this._drawBloodDrips();
                    this.ctx.restore();
                }

                // --- Private Helper Methods ---

                _drawHorns() {
                    const { ctx, width: skullWidth, height: skullHeight } = this;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    let swipeAngle = 0;
                    if (this.isAttacking) {
                        const elapsedTime = Date.now() - this.attackStartTime;
                        const duration = 1000;
                        if (elapsedTime < duration) {
                            const progress = elapsedTime / duration;
                            swipeAngle = Math.sin(progress * Math.PI) * -0.3;
                        }
                    }

                    const drawHornScythe = (isFlipped) => {
                        const side = isFlipped ? -1 : 1;
                        ctx.save();

                        const handleGradient = ctx.createLinearGradient(0, -200, 0, 100);
                        handleGradient.addColorStop(0, '#111111');
                        handleGradient.addColorStop(0.5, '#333333');
                        handleGradient.addColorStop(1, '#222222');
                        ctx.fillStyle = handleGradient;
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 18;

                        ctx.beginPath();
                        ctx.moveTo(side * skullWidth * 0.35, -skullHeight * 0.4);
                        const handleEndX = side * 400;
                        const handleEndY = -skullHeight * 0.20;
                        ctx.bezierCurveTo(side * 220, -skullHeight * 0.9, side * 350, -skullHeight * 0.1, handleEndX, handleEndY);
                        ctx.bezierCurveTo(side * 360, 0, side * 230, -skullHeight * 0.55, side * skullWidth * 0.25, -skullHeight * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#4a4a4a';
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.ellipse(handleEndX - side * 10, handleEndY, 14, 20, side * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.ellipse(handleEndX - side * 35, handleEndY - 5, 12, 18, side * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        ctx.translate(handleEndX, handleEndY);
                        const baseRotation = Math.PI / 4;
                        ctx.rotate(side * baseRotation + side * swipeAngle);

                        const bladeGradient = ctx.createLinearGradient(side * 50, 0, side * 150, 300);
                        bladeGradient.addColorStop(0, '#ffffff');
                        bladeGradient.addColorStop(0.5, '#e3dac9');
                        bladeGradient.addColorStop(1, '#c1b8a8');
                        ctx.fillStyle = bladeGradient;
                        ctx.strokeStyle = '#8c8273';
                        ctx.lineWidth = 4;

                        ctx.beginPath();
                        const tipX = side * 150;
                        const tipY = 220;
                        ctx.moveTo(0, -15);
                        ctx.bezierCurveTo(side * 180, 80, side * 200, 200, tipX, tipY);
                        ctx.bezierCurveTo(side * 130, 160, side * 40, 70, 0, 15);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.save();
                        ctx.clip();
                        ctx.strokeStyle = 'rgba(80, 70, 60, 0.2)';
                        ctx.lineWidth = 1.5;
                        for (let i = 0; i < 30; i++) {
                            ctx.beginPath();
                            const startX = side * (Math.random() * 250);
                            const startY = -15 + Math.random() * 300;
                            const length = 20 + Math.random() * 30;
                            const angle = Math.random() * Math.PI * 2;
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
                            ctx.stroke();
                        }
                        ctx.restore();

                        if (this.isAttacking && Math.random() < 0.3) {
                            const dripSpawnPoint = { x: tipX / 2, y: tipY / 1.5 };
                            const rotatedPoint = {
                                x: dripSpawnPoint.x * Math.cos(side * baseRotation) - dripSpawnPoint.y * Math.sin(side * baseRotation),
                                y: dripSpawnPoint.x * Math.sin(side * baseRotation) + dripSpawnPoint.y * Math.cos(side * baseRotation)
                            };
                            this._addBloodDrip(handleEndX + rotatedPoint.x, handleEndY + rotatedPoint.y);
                        }

                        ctx.restore();
                    };

                    drawHornScythe(false);
                    drawHornScythe(true);
                }

                _drawHead() {
                    const { ctx, width: skullWidth, height: skullHeight, skullColor } = this;
                    const gradient = ctx.createRadialGradient(0, -50, skullWidth * 0.1, 0, 0, skullWidth * 1.2);

                    if (skullColor === '#FF0000') {
                        // Red final phase colors
                        gradient.addColorStop(0, '#ff6666');
                        gradient.addColorStop(0.5, '#ff0000');
                        gradient.addColorStop(1, '#660000');
                    } else {
                        // Original orange colors
                        gradient.addColorStop(0, '#ff8c66');
                        gradient.addColorStop(0.5, '#e54d24');
                        gradient.addColorStop(1, '#661a00');
                    }

                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#1a0a05';
                    ctx.lineWidth = 8;
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                    ctx.shadowBlur = 20;

                    ctx.beginPath();
                    ctx.moveTo(0, -skullHeight * 0.55);
                    ctx.bezierCurveTo(-skullWidth * 0.6, -skullHeight * 0.6, -skullWidth * 0.6, -skullHeight * 0.1, -skullWidth * 0.5, -skullHeight * 0.2);
                    ctx.bezierCurveTo(-skullWidth * 0.6, skullHeight * 0.3, -skullWidth * 0.2, skullHeight * 0.55, 0, skullHeight * 0.52);
                    ctx.bezierCurveTo(skullWidth * 0.2, skullHeight * 0.55, skullWidth * 0.6, skullHeight * 0.3, skullWidth * 0.5, -skullHeight * 0.2);
                    ctx.bezierCurveTo(skullWidth * 0.6, -skullHeight * 0.1, skullWidth * 0.6, -skullHeight * 0.6, 0, -skullHeight * 0.55);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowColor = 'transparent';
                }

                _drawFacialFeatures() {
                    const { ctx, height: skullHeight } = this;

                    const drawMirrorEye = (offsetX, isFlipped) => {
                        ctx.save();
                        ctx.translate(offsetX, -10);
                        if (isFlipped) ctx.scale(-1, 1);
                        const eyePath = new Path2D();
                        eyePath.moveTo(-30, -20); eyePath.lineTo(30, -30); eyePath.lineTo(25, 28); eyePath.lineTo(-25, 25); eyePath.closePath();
                        for (let i = 0; i < 6; i++) {
                            ctx.fillStyle = (i % 2 === 0 || i === 5) ? '#1a0a05' : '#ff3300';
                            ctx.fill(eyePath);
                            ctx.scale(0.8, 0.75);
                        }
                        ctx.restore();
                    };
                    drawMirrorEye(-35, true);
                    drawMirrorEye(35, false);

                    let mouthOpenness = 0;
                    if (this.isAttacking) {
                        const elapsedTime = Date.now() - this.attackStartTime;
                        mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 15;
                    }

                    ctx.strokeStyle = 'rgba(26, 10, 5, 0.8)';
                    ctx.lineWidth = 2;

                    for (let i = -6; i <= 6; i++) {
                        if (i === 0) continue;
                        let toothWidth = 10;
                        let toothHeight = 25 - Math.abs(i) * 1.2;
                        const isCanine = Math.abs(i) === 5 || Math.abs(i) === 6;
                        if (isCanine) {
                            toothHeight += 18;
                            toothWidth -= 2;
                        }
                        const xPos = i * 9;
                        let yPos = skullHeight * 0.53;
                        yPos -= Math.pow(i, 2) * 1.8;
                        yPos += mouthOpenness;
                        ctx.save();
                        ctx.translate(xPos, yPos);
                        ctx.beginPath();
                        ctx.moveTo(-toothWidth / 2, 0);
                        ctx.lineTo(toothWidth / 2, 0);
                        ctx.lineTo(0, toothHeight);
                        ctx.closePath();
                        ctx.fillStyle = '#e8d9a9';
                        ctx.fill();
                        ctx.stroke();
                        const tipY = toothHeight;
                        ctx.fillStyle = '#8c1803';
                        ctx.beginPath();
                        ctx.ellipse(0, tipY, toothWidth / 3, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.ellipse(0, tipY, toothWidth / 5, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }

                _addWeathering() {
                    const { ctx } = this;
                    ctx.strokeStyle = 'rgba(26, 10, 5, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(40, -30);
                    ctx.lineTo(70, 10);
                    ctx.lineTo(65, 15);
                    ctx.stroke();
                }

                _addBloodDrip(x, y) {
                    if (this.bloodDrips.length > 100) return;
                    this.bloodDrips.push({
                        x: x,
                        y: y,
                        speed: 2 + Math.random() * 3,
                        size: 2 + Math.random() * 3
                    });
                }

                _updateBloodDrips() {
                    for (let i = this.bloodDrips.length - 1; i >= 0; i--) {
                        const drip = this.bloodDrips[i];
                        drip.y += drip.speed;
                        if (drip.y > this.ctx.canvas.height) {
                            this.bloodDrips.splice(i, 1);
                        }
                    }
                }

                _drawBloodDrips() {
                    const { ctx } = this;
                    ctx.fillStyle = '#8c1803';
                    for (const drip of this.bloodDrips) {
                        ctx.beginPath();
                        ctx.arc(drip.x, drip.y, drip.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

            }

            function drawGeminiBoss(boss) {
                const state = ensureGeminiState(boss);
                if (!state) return;

                const { sol, luna } = state;
                const totalHpMax = Math.max(1, (sol.hpMax || 0) + (luna.hpMax || 0));
                const solShare = clamp((sol.hpMax || 0) / totalHpMax, 0, 1);
                const lunaShare = clamp((luna.hpMax || 0) / totalHpMax, 0, 1);
                const solRatio = sol.hpMax > 0 ? clamp(sol.hp / sol.hpMax, 0, 1) : 0;
                const lunaRatio = luna.hpMax > 0 ? clamp(luna.hp / luna.hpMax, 0, 1) : 0;
                const now = performance.now() / 1000;

                ctx.save();
                ctx.translate(boss.x, boss.y);
                const barWidth = 200;
                const barHeight = 12;
                ctx.fillStyle = 'rgba(12, 10, 18, 0.74)';
                ctx.fillRect(-barWidth / 2, -boss.r - 32, barWidth, barHeight);
                const solWidth = barWidth * solShare;
                const lunaWidth = barWidth - solWidth;
                ctx.fillStyle = 'rgba(255, 180, 100, 0.9)';
                ctx.fillRect(-barWidth / 2, -boss.r - 32, solWidth * solRatio, barHeight);
                ctx.fillStyle = 'rgba(120, 210, 255, 0.85)';
                ctx.fillRect(-barWidth / 2 + solWidth, -boss.r - 32, lunaWidth * lunaRatio, barHeight);
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = 1;
                ctx.strokeRect(-barWidth / 2, -boss.r - 32, barWidth, barHeight);
                if (solWidth > 0 && solWidth < barWidth) {
                    ctx.beginPath();
                    ctx.moveTo(-barWidth / 2 + solWidth, -boss.r - 32);
                    ctx.lineTo(-barWidth / 2 + solWidth, -boss.r - 20);
                    ctx.stroke();
                }
                ctx.font = '11px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ffe8c9';
                ctx.fillText('SOL', -barWidth / 2 + solWidth * 0.5, -boss.r - 38);
                ctx.fillStyle = '#cdefff';
                ctx.fillText('LUNA', -barWidth / 2 + solWidth + lunaWidth * 0.5, -boss.r - 38);
                ctx.restore();

                drawGeminiSol(state, now);
                drawGeminiLuna(state, now);
                drawGeminiHealthBars(state);
            }

            function drawGeminiSol(state, now) {
                const sol = state.sol;
                if (Number.isFinite(sol.x) && Number.isFinite(sol.y)) {
                    const radius = Number.isFinite(sol.radius) ? sol.radius : 40;
                    drawEntityShadow(sol.x, sol.y, Math.max(26, radius * 1.5), Math.max(10, radius * 0.6), {
                        alpha: sol.hp > 0 ? 0.28 : 0.18,
                        yOffset: Math.max(12, radius * 0.9)
                    });
                }
                ctx.save();
                ctx.translate(sol.x, sol.y);
                const alive = sol.hp > 0;
                const baseAlpha = alive ? 1 : 0.35;
                ctx.globalAlpha = baseAlpha;

                const auraPulse = 1 + 0.06 * Math.sin(now * 3.4 + sol.x * 0.012);
                const auraRadius = sol.radius * 1.85 * auraPulse;
                const aura = ctx.createRadialGradient(0, 0, sol.radius * 0.4, 0, 0, auraRadius);
                aura.addColorStop(0, sol.enraged ? 'rgba(255, 160, 60, 0.9)' : 'rgba(255, 190, 120, 0.75)');
                aura.addColorStop(1, 'rgba(255, 120, 40, 0)');
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = aura;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.save();
                ctx.rotate(now * (sol.enraged ? 1.2 : 0.7));
                const spikes = sol.enraged ? 14 : 10;
                ctx.strokeStyle = sol.enraged ? 'rgba(255, 130, 40, 0.85)' : 'rgba(255, 200, 140, 0.8)';
                ctx.lineWidth = 3;
                for (let i = 0; i < spikes; i++) {
                    const angle = (i / spikes) * Math.PI * 2;
                    const inner = sol.radius * 0.75;
                    const outer = sol.radius * (1.6 + 0.12 * Math.sin(now * 4 + i));
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * inner, Math.sin(angle) * inner);
                    ctx.lineTo(Math.cos(angle) * outer, Math.sin(angle) * outer);
                    ctx.stroke();
                }
                ctx.restore();

                const bodyGradient = ctx.createRadialGradient(0, 0, sol.radius * 0.2, 0, 0, sol.radius * 1.08);
                bodyGradient.addColorStop(0, '#fff8dd');
                bodyGradient.addColorStop(0.5, sol.enraged ? '#ffb54d' : '#ffdba2');
                bodyGradient.addColorStop(1, sol.enraged ? '#ff8430' : '#ffb86a');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.arc(0, 0, sol.radius * 1.05, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#7a2d00';
                ctx.beginPath();
                ctx.arc(-sol.radius * 0.38, -sol.radius * 0.18, sol.enraged ? 6 : 5, 0, Math.PI * 2);
                ctx.arc(sol.radius * 0.38, -sol.radius * 0.18, sol.enraged ? 6 : 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = sol.enraged ? '#ffe9c7' : '#fff3d6';
                ctx.beginPath();
                ctx.arc(0, sol.radius * 0.32, sol.radius * 0.42, 0.1, Math.PI - 0.1);
                ctx.fill();

                if (sol.shieldActive && sol.shieldHp > 0) {
                    const shieldMax = sol.hpMax * (state.luna && state.luna.enraged ? 0.12 : 0.08);
                    const shieldRatio = shieldMax > 0 ? clamp(sol.shieldHp / shieldMax, 0, 1) : 0;
                    const shieldRadius = sol.radius * (1.55 + 0.1 * Math.sin(now * 5.6));
                    ctx.strokeStyle = `rgba(120, 220, 255, ${0.35 + 0.3 * shieldRatio})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, shieldRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = `rgba(90, 170, 255, ${0.4 + 0.3 * Math.sin(now * 8)})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, shieldRadius + 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                if (!alive) {
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = 'rgba(255, 220, 180, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.arc(0, 0, sol.radius * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();
            }

            function drawGeminiLuna(state, now) {
                const luna = state.luna;
                if (Number.isFinite(luna.x) && Number.isFinite(luna.y)) {
                    const radius = Number.isFinite(luna.radius) ? luna.radius : 40;
                    drawEntityShadow(luna.x, luna.y, Math.max(26, radius * 1.45), Math.max(10, radius * 0.58), {
                        alpha: luna.hp > 0 ? 0.26 : 0.18,
                        yOffset: Math.max(12, radius * 0.9)
                    });
                }
                ctx.save();
                ctx.translate(luna.x, luna.y);
                const alive = luna.hp > 0;
                ctx.globalAlpha = alive ? 1 : 0.35;

                const auraPulse = 1 + 0.07 * Math.sin(now * 3.8 + luna.y * 0.015);
                const auraRadius = luna.radius * 1.9 * auraPulse;
                const aura = ctx.createRadialGradient(0, 0, luna.radius * 0.3, 0, 0, auraRadius);
                aura.addColorStop(0, luna.enraged ? 'rgba(140, 230, 255, 0.9)' : 'rgba(160, 245, 255, 0.75)');
                aura.addColorStop(1, 'rgba(80, 170, 255, 0)');
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = aura;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                const outerR = luna.radius * 1.1;
                const innerOffset = luna.radius * 0.5;
                ctx.fillStyle = luna.enraged ? '#73d9ff' : '#8fe6ff';
                ctx.beginPath();
                ctx.arc(0, 0, outerR, Math.PI * 0.2, Math.PI * 1.8);
                ctx.arc(innerOffset, 0, outerR * 0.85, Math.PI * 1.8, Math.PI * 0.2, true);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = luna.enraged ? 'rgba(120, 220, 255, 0.85)' : 'rgba(150, 235, 255, 0.7)';
                ctx.lineWidth = 2.4;
                ctx.stroke();

                ctx.save();
                ctx.rotate(Math.sin(now * 1.2) * 0.1);
                ctx.strokeStyle = 'rgba(180, 240, 255, 0.4)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const sweep = Math.PI * (0.45 + i * 0.22);
                    const radius = outerR * (0.9 + i * 0.18);
                    ctx.globalAlpha = 0.5 - i * 0.12;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, -sweep / 2, sweep / 2);
                    ctx.stroke();
                }
                ctx.restore();

                ctx.fillStyle = '#0f2a40';
                ctx.beginPath();
                ctx.arc(-luna.radius * 0.25, -luna.radius * 0.1, luna.enraged ? 5 : 4, 0, Math.PI * 2);
                ctx.arc(luna.radius * 0.05, -luna.radius * 0.25, luna.enraged ? 4 : 3.5, 0, Math.PI * 2);
                ctx.fill();

                const sparkleCount = luna.enraged ? 14 : 9;
                ctx.strokeStyle = 'rgba(200, 250, 255, 0.6)';
                ctx.lineWidth = 1.1;
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = now * (1.8 + i * 0.15) + i;
                    const radius = outerR * (0.85 + 0.15 * Math.sin(now * 2 + i));
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y);
                    ctx.lineTo(x + 4, y);
                    ctx.moveTo(x, y - 4);
                    ctx.lineTo(x, y + 4);
                    ctx.stroke();
                }

                if (!alive) {
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = 'rgba(120, 200, 255, 0.55)';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(0, 0, outerR * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();
            }

            function drawGeminiHealthBars(state) {
                drawGeminiIndividualBar(state.sol, '#ff9f3b');
                drawGeminiIndividualBar(state.luna, '#66d0ff');
            }

            function drawGeminiIndividualBar(dancer, color) {
                const ratio = dancer.hpMax > 0 ? clamp(dancer.hp / dancer.hpMax, 0, 1) : 0;
                const width = 140;
                const x = dancer.x;
                const y = dancer.y + dancer.radius + 14;
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.68)';
                ctx.fillRect(x - width / 2, y, width, 8);
                ctx.fillStyle = color;
                ctx.fillRect(x - width / 2, y, width * ratio, 8);
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - width / 2, y, width, 8);
                ctx.font = '12px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#fdfdfd';
                let label = dancer.label || '';
                if (dancer.hp <= 0) {
                    label += ' â€” DOWN';
                } else if (dancer.enraged) {
                    label += ' â˜…';
                }
                ctx.fillText(label, x, y + 18);
                ctx.restore();
            }

            function drawKnockbackShieldCharges() {
                // Render orbiting knockback shield charges and their cooldown effects around the player.
                if (!store.knockbackCharges || store.knockbackCharges.length === 0) {
                    return;
                }

                ctx.save();
                store.knockbackCharges.forEach(charge => {
                    if (!charge || charge.dead) return;

                    const chargeCooldown = KNOCKBACK_SHIELD_CONFIG?.chargeCooldown ?? 30;
                    const cooldownRemaining = Math.max(0, charge.cooldown || 0);
                    const cooldownRatio = chargeCooldown > 0 ? Math.min(1, cooldownRemaining / chargeCooldown) : 0;
                    const isRecharging = cooldownRatio > 0;

                    ctx.globalAlpha = isRecharging ? 0.12 : 0.26;
                    const gradient = ctx.createLinearGradient(store.player.x, store.player.y, charge.x, charge.y);
                    if (isRecharging) {
                        gradient.addColorStop(0, 'rgba(12, 12, 22, 0.55)');
                        gradient.addColorStop(1, 'rgba(2, 2, 6, 0.1)');
                    } else {
                        gradient.addColorStop(0, 'rgba(44, 42, 54, 0.65)');
                        gradient.addColorStop(1, 'rgba(12, 12, 18, 0.2)');
                    }
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 2.2;
                    ctx.beginPath();
                    ctx.moveTo(store.player.x, store.player.y);
                    ctx.lineTo(charge.x, charge.y);
                    ctx.stroke();
                });
                ctx.restore();

                store.knockbackCharges.forEach(charge => {
                    if (!charge || charge.dead) return;

                    const chargeCooldown = KNOCKBACK_SHIELD_CONFIG?.chargeCooldown ?? 30;
                    const cooldownRemaining = Math.max(0, charge.cooldown || 0);
                    const cooldownRatio = chargeCooldown > 0 ? Math.min(1, cooldownRemaining / chargeCooldown) : 0;
                    const readiness = Math.max(0, 1 - cooldownRatio);

                    const globalCooldown = KNOCKBACK_SHIELD_CONFIG?.globalCooldown ?? 0;
                    const globalRemaining = Math.max(0, store.knockbackGlobalCooldown || 0);
                    const globalRatio = globalCooldown > 0 ? Math.min(1, globalRemaining / globalCooldown) : (globalRemaining > 0 ? 1 : 0);
                    const globalFactor = globalRatio > 0 ? Math.max(0.4, 1 - globalRatio * 0.85) : 1;
                    const availability = Math.min(1, readiness * globalFactor);

                    const pulseStrength = isFinite(availability) ? 0.12 * (0.35 + 0.65 * availability) : 0.04;
                    const baseRadius = 6.5;
                    const pulseScale = 1 + Math.sin(charge.pulsePhase || 0) * pulseStrength;
                    const radius = baseRadius * pulseScale;

                    ctx.save();
                    ctx.translate(charge.x, charge.y);

                    if (cooldownRatio > 0) {
                        ctx.globalAlpha = 0.26;
                        const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2.4);
                        outerGlow.addColorStop(0, 'rgba(26, 26, 36, 0.7)');
                        outerGlow.addColorStop(0.7, 'rgba(10, 10, 16, 0.35)');
                        outerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        ctx.fillStyle = outerGlow;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius * 2.4, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.globalAlpha = 0.34;
                        const core = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                        core.addColorStop(0, '#1b1b22');
                        core.addColorStop(0.5, '#0a0b11');
                        core.addColorStop(1, '#040406');
                        ctx.fillStyle = core;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.globalAlpha = 0.34 + 0.36 * availability;
                        const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2.6);
                        outerGlow.addColorStop(0, 'rgba(40, 40, 52, 0.72)');
                        outerGlow.addColorStop(0.55, 'rgba(16, 16, 24, 0.38)');
                        outerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        ctx.fillStyle = outerGlow;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius * 2.6, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.globalAlpha = 0.72 + 0.22 * availability;
                        const core = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                        core.addColorStop(0, '#2a2a33');
                        core.addColorStop(0.45, '#0f0f14');
                        core.addColorStop(1, '#050508');
                        ctx.fillStyle = core;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.globalAlpha = 0.32 + 0.18 * availability;
                        const highlight = ctx.createRadialGradient(-radius * 0.35, -radius * 0.35, 0, -radius * 0.35, -radius * 0.35, radius * 0.9);
                        highlight.addColorStop(0, 'rgba(180, 180, 210, 0.65)');
                        highlight.addColorStop(0.5, 'rgba(90, 95, 120, 0.25)');
                        highlight.addColorStop(1, 'rgba(40, 40, 50, 0)');
                        ctx.fillStyle = highlight;
                        ctx.beginPath();
                        ctx.arc(-radius * 0.35, -radius * 0.35, radius * 0.9, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    if (cooldownRatio > 0) {
                        const recoveredRatio = 1 - cooldownRatio;
                        ctx.globalAlpha = 0.75;
                        ctx.strokeStyle = 'rgba(80, 80, 120, 0.85)';
                        ctx.lineWidth = 2.4;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius + 4, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * recoveredRatio, false);
                        ctx.stroke();

                        ctx.globalAlpha = 0.26;
                        ctx.fillStyle = 'rgba(15, 15, 25, 0.45)';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, radius + 4, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * recoveredRatio, false);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.globalAlpha = 0.24 + 0.16 * availability;
                        ctx.strokeStyle = 'rgba(120, 120, 150, 0.55)';
                        ctx.lineWidth = 1.8;
                        ctx.setLineDash([4, 6]);
                        ctx.beginPath();
                        ctx.arc(0, 0, radius + 6 + Math.sin((charge.pulsePhase || 0) * 1.7) * 1.2, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }

                    ctx.restore();
                });
            }

            function drawVibemasterThreads(threads) {
                if (!threads || !threads.length) return;
                ctx.save();
                threads.forEach(thread => {
                    if (!thread || thread.life <= 0) return;
                    const lifeRatio = clamp(thread.life / (thread.maxLife || thread.life), 0, 1);
                    const width = thread.width * (0.65 + 0.35 * Math.sin(thread.pulse));
                    const gradient = ctx.createLinearGradient(thread.startX, thread.startY, thread.endX, thread.endY);
                    gradient.addColorStop(0, 'rgba(120, 220, 255, 0)');
                    gradient.addColorStop(0.35, `rgba(168, 240, 255, ${0.45 * lifeRatio})`);
                    gradient.addColorStop(0.65, `rgba(255, 210, 255, ${0.6 * lifeRatio})`);
                    gradient.addColorStop(1, 'rgba(140, 180, 255, 0)');
                    ctx.strokeStyle = gradient;
                    ctx.globalAlpha = 0.75;
                    ctx.lineWidth = width;
                    ctx.beginPath();
                    ctx.moveTo(thread.startX, thread.startY);
                    ctx.lineTo(thread.endX, thread.endY);
                    ctx.stroke();

                    ctx.globalAlpha = 0.5 * lifeRatio;
                    ctx.lineWidth = width * 0.4;
                    ctx.strokeStyle = `rgba(40, 10, 80, ${0.4 + 0.3 * lifeRatio})`;
                    ctx.beginPath();
                    ctx.moveTo(thread.startX, thread.startY);
                    ctx.lineTo(thread.endX, thread.endY);
                    ctx.stroke();
                });
                ctx.restore();
            }

            function drawVibemasterRings(rings) {
                if (!rings || !rings.length) return;
                ctx.save();
                const circumferenceCache = new Map();
                rings.forEach(ring => {
                    if (!ring || ring.life <= 0) return;
                    const lifeRatio = clamp(ring.life / (ring.maxLife || ring.life), 0, 1);
                    const pulse = 0.25 + 0.75 * Math.sin(ring.pulse);
                    const radius = Math.max(10, ring.radius);
                    const thickness = Math.max(2, ring.thickness * (0.9 + 0.2 * pulse));
                    const circumference = circumferenceCache.get(radius) || (Math.PI * 2 * radius);
                    circumferenceCache.set(radius, circumference);
                    const dashLength = Math.max(6, circumference / Math.max(1, (ring.segmentCount || 8) * 2));
                    ctx.setLineDash([dashLength * 0.9, dashLength * 0.9]);
                    ctx.lineDashOffset = ring.pattern ? dashLength * 0.5 : 0;
                    ctx.lineWidth = thickness;
                    ctx.strokeStyle = `rgba(214, 169, 255, ${0.35 + 0.45 * lifeRatio})`;
                    ctx.globalAlpha = 0.85;
                    ctx.beginPath();
                    ctx.arc(ring.x, ring.y, radius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 0.3 * lifeRatio;
                    ctx.lineWidth = thickness * 0.45;
                    ctx.strokeStyle = 'rgba(30, 6, 60, 0.6)';
                    ctx.beginPath();
                    ctx.arc(ring.x, ring.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                });
                ctx.setLineDash([]);
                ctx.restore();
            }

            function drawVibemasterGuardians(guardians, phase) {
                if (!guardians || !guardians.length) return;
                const time = performance.now() / 1000;
                guardians.forEach(guardian => {
                    if (!guardian || guardian.dead) return;
                    ctx.save();
                    ctx.translate(guardian.x, guardian.y);
                    const pulse = Math.sin(time * 3 + guardian.movePhase) * 0.25;
                    const baseRadius = 16 + (phase >= 3 ? 4 : 0);
                    const radius = baseRadius * (1 + pulse * 0.12) + (guardian.hitPulse || 0) * 8;
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.85)');
                    gradient.addColorStop(0.45, addAlpha(guardian.color || '#9de7ff', 0.7));
                    gradient.addColorStop(1, addAlpha(guardian.color || '#9de7ff', 0));
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = 0.85;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = 0.55;
                    ctx.strokeStyle = addAlpha(guardian.color || '#9de7ff', 0.8);
                    ctx.lineWidth = 2.2;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 1.1, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                });
            }

            function drawVibemasterDistortion(boss, distortion) {
                if (!distortion || !distortion.active) return;
                const ratio = distortion.duration > 0 ? clamp(distortion.timer / distortion.duration, 0, 1) : 0;
                const outerRadius = (boss.r || 60) * (2 + (1 - ratio) * 0.8);
                const innerRadius = outerRadius * 0.35;
                const pulse = Math.sin(performance.now() / 140) * 0.2;
                ctx.save();
                ctx.globalAlpha = 0.25 + 0.25 * (1 - ratio);
                const gradient = ctx.createRadialGradient(boss.x, boss.y, innerRadius * (0.8 + pulse), boss.x, boss.y, outerRadius);
                gradient.addColorStop(0, 'rgba(200, 245, 255, 0.55)');
                gradient.addColorStop(0.35, 'rgba(140, 120, 255, 0.35)');
                gradient.addColorStop(0.65, 'rgba(60, 20, 90, 0.2)');
                gradient.addColorStop(1, 'rgba(10, 0, 20, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, outerRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            function drawVibemasterVacuum(boss, vacuum) {
                if (!vacuum || !vacuum.active) return;
                const ratio = vacuum.duration > 0 ? clamp(1 - vacuum.timer / vacuum.duration, 0, 1) : 1;
                const outerRadius = (boss.r || 60) * (2.4 + ratio * 1.6);
                ctx.save();
                ctx.globalAlpha = 0.3 + 0.3 * ratio;
                const gradient = ctx.createRadialGradient(boss.x, boss.y, 0, boss.x, boss.y, outerRadius);
                gradient.addColorStop(0, 'rgba(250, 230, 255, 0.65)');
                gradient.addColorStop(0.6, 'rgba(200, 150, 255, 0.28)');
                gradient.addColorStop(1, 'rgba(150, 90, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, outerRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            function drawVibemasterBarrier(boss, barrier) {
                if (!barrier || !barrier.active) return;
                const hpRatio = barrier.maxHp > 0 ? clamp(barrier.hp / barrier.maxHp, 0, 1) : 0;
                const radius = (boss.r || 60) + 32;
                const glow = 0.7 + (barrier.hitPulse || 0) * 0.8;
                const segmentCount = 6;
                const arcSize = Math.PI * 2 / segmentCount * 0.6;
                ctx.save();
                ctx.translate(boss.x, boss.y);
                ctx.rotate(barrier.angle);
                ctx.lineWidth = 8;
                ctx.shadowColor = 'rgba(180, 150, 255, 0.8)';
                ctx.shadowBlur = 18 + glow * 12;
                for (let i = 0; i < segmentCount; i++) {
                    const start = (i / segmentCount) * Math.PI * 2 - arcSize / 2;
                    const end = start + arcSize;
                    const alpha = 0.35 + hpRatio * 0.55;
                    ctx.strokeStyle = `rgba(188, 167, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, start, end);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.35 + 0.35 * hpRatio;
                ctx.fillStyle = 'rgba(90, 70, 150, 0.35)';
                ctx.beginPath();
                ctx.arc(0, 0, radius - 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            function drawVibemasterRitual(boss, ritual) {
                if (!ritual || !ritual.active) return;
                const ratio = ritual.duration > 0 ? clamp(ritual.timer / ritual.duration, 0, 1) : 0;
                const reach = (boss.r || 60) * 3.2;
                const width = VIBEMASTER_CONFIG.ritual.beamWidth || 0.25;
                const baseAlpha = 0.42 + (ritual.hitPulse || 0) * 0.6;
                ctx.save();
                ctx.translate(boss.x, boss.y);
                ctx.globalAlpha = baseAlpha;
                ctx.fillStyle = 'rgba(140, 245, 255, 0.45)';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, reach, ritual.beamAngle - width, ritual.beamAngle + width);
                ctx.closePath();
                ctx.fill();

                ctx.globalAlpha = 0.6 - ratio * 0.35;
                ctx.strokeStyle = 'rgba(80, 200, 255, 0.55)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, reach * 0.35, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            function drawVibemasterWingHalf(time, palette) {
                const enginePulse = Math.sin(time * 5) * 10 + 25 + (palette.enraged ? 6 : 0);
                const hue = (palette.wingHue + palette.phase * 18) % 360;
                
                // Wing flap animation - asymmetric motion for dynamic feel
                const wingFlap = Math.sin(time * 3.8 + (palette.enraged ? Math.PI / 3 : 0)) * 18;
                const wingRotation = wingFlap * 0.02;
                
                ctx.save();
                ctx.translate(80, 0);
                
                // Apply wing rotation for flapping motion
                ctx.rotate(wingRotation);

                const engineGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, enginePulse);
                engineGradient.addColorStop(0, `hsla(${hue}, 100%, ${palette.enraged ? 92 : 88}%, 1)`);
                engineGradient.addColorStop(0.3, `hsla(${(hue + 26) % 360}, 100%, 65%, 0.9)`);
                engineGradient.addColorStop(1, `hsla(${(hue + 60) % 360}, 100%, 52%, 0)`);
                ctx.fillStyle = engineGradient;
                ctx.beginPath();
                ctx.arc(0, 0, enginePulse, 0, Math.PI * 2);
                ctx.fill();

                const metallicWingGradient = ctx.createLinearGradient(0, -100, 180, 100);
                metallicWingGradient.addColorStop(0, 'rgba(240, 240, 250, 0.85)');
                metallicWingGradient.addColorStop(0.35, 'rgba(130, 130, 160, 0.72)');
                metallicWingGradient.addColorStop(1, 'rgba(45, 45, 80, 0.9)');
                ctx.fillStyle = metallicWingGradient;
                ctx.strokeStyle = palette.strokeColor;
                ctx.lineWidth = 2;
                ctx.shadowColor = `hsla(${(hue + 140) % 360}, 100%, 70%, 0.9)`;
                ctx.shadowBlur = 18 + (palette.enraged ? 10 : 0);
                
                // Upper wing
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(150 + wingFlap * 0.15, -100 + wingFlap * 0.12);
                ctx.lineTo(180 + wingFlap * 0.18, -80 + wingFlap * 0.1);
                ctx.lineTo(30, 20);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Lower wing
                ctx.beginPath();
                ctx.moveTo(20, 24);
                ctx.lineTo(160 + wingFlap * 0.12, 102 - wingFlap * 0.15);
                ctx.lineTo(140 + wingFlap * 0.14, 124 - wingFlap * 0.12);
                ctx.lineTo(0, 32);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.strokeStyle = `hsla(${(hue + 36) % 360}, 100%, 78%, 0.85)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20, 2);
                ctx.quadraticCurveTo(100 + wingFlap * 0.08, -48 + wingFlap * 0.1, 160 + wingFlap * 0.15, -88 + wingFlap * 0.12);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(10, 30);
                ctx.quadraticCurveTo(102 + wingFlap * 0.06, 74 - wingFlap * 0.12, 152 + wingFlap * 0.12, 116 - wingFlap * 0.1);
                ctx.stroke();

                ctx.restore();
            }

            function drawVibemasterPilotHalf(time, palette) {
                ctx.save();

                drawVibemasterWingHalf(time, palette);

                const baseHue = (palette.baseHue + 360) % 360;
                const exoskeletonGradient = ctx.createLinearGradient(-100, -200, 100, 200);
                exoskeletonGradient.addColorStop(0, `hsl(${baseHue}, 100%, 70%)`);
                exoskeletonGradient.addColorStop(0.5, `hsl(${(baseHue + 60) % 360}, 100%, 60%)`);
                exoskeletonGradient.addColorStop(1, `hsl(${(baseHue + 120) % 360}, 100%, 52%)`);
                ctx.strokeStyle = exoskeletonGradient;
                ctx.fillStyle = exoskeletonGradient;
                ctx.lineWidth = 4;
                ctx.shadowColor = `hsl(${baseHue}, 100%, 62%)`;
                ctx.shadowBlur = 24 + (palette.enraged ? 6 : 0);

                // Hand animation - up and down motion for gesturing
                const handBob = Math.sin(time * 2.8) * 32 + (palette.enraged ? Math.sin(time * 5.2) * 8 : 0);
                
                // Main body
                ctx.beginPath();
                ctx.moveTo(0, -90);
                ctx.lineTo(60, -48);
                ctx.lineTo(42, 104);
                ctx.lineTo(0, 126);
                ctx.closePath();
                ctx.fill();

                // Shoulder
                ctx.beginPath();
                ctx.moveTo(50, -58);
                ctx.arc(60, -58, 20, Math.PI, Math.PI * 2);
                ctx.fill();

                // Upper arm + hand with animation
                ctx.save();
                ctx.translate(60, -48);
                ctx.rotate(Math.sin(time * 2.5) * 0.3);
                ctx.beginPath();
                ctx.moveTo(16, -10);
                ctx.lineTo(44, 50 + handBob * 0.4);
                ctx.lineTo(24, 62 + handBob * 0.4);
                ctx.stroke();
                
                // Hand (glowing fingers)
                ctx.save();
                ctx.translate(24, 62 + handBob * 0.4);
                const handGlow = 8 + Math.sin(time * 3.5) * 3;
                ctx.fillStyle = `hsla(${(baseHue + 30) % 360}, 100%, 85%, 0.8)`;
                ctx.shadowColor = `hsl(${(baseHue + 30) % 360}, 100%, 75%)`;
                ctx.shadowBlur = handGlow;
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Finger tendrils
                for (let f = 0; f < 4; f++) {
                    const angle = (f / 4) * Math.PI * 2 + time * 1.8;
                    const fx = Math.cos(angle) * 20;
                    const fy = Math.sin(angle) * 20;
                    ctx.strokeStyle = `hsla(${(baseHue + 40 + f * 10) % 360}, 100%, 70%, 0.6)`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(fx, fy);
                    ctx.stroke();
                }
                ctx.restore();
                ctx.restore();

                // Lower body/legs
                ctx.beginPath();
                ctx.moveTo(42, 104);
                ctx.lineTo(62, 208);
                ctx.lineTo(40, 220);
                ctx.stroke();

                // Head with third eye
                ctx.beginPath();
                ctx.arc(0, -148, 52, Math.PI * 0.5, Math.PI, false);
                ctx.lineTo(-52, -100);
                ctx.quadraticCurveTo(-22, -94, 0, -88);
                ctx.closePath();
                ctx.fill();

                const visorHue = (palette.baseHue + palette.visorShift + Math.sin(time * 3) * 30 + 360) % 360;
                ctx.fillStyle = `hsl(${visorHue}, 100%, 80%)`;
                ctx.shadowColor = `hsl(${visorHue}, 100%, 78%)`;
                ctx.shadowBlur = 22 + (palette.enraged ? 6 : 0);
                ctx.fillRect(-46, -140, 48, 22);

                ctx.shadowBlur = 0;
                const metallicGradient = ctx.createLinearGradient(0, -80, 0, 110);
                metallicGradient.addColorStop(0, '#ffffff');
                metallicGradient.addColorStop(0.5, '#b3b3b3');
                metallicGradient.addColorStop(1, '#8a8a8a');
                ctx.strokeStyle = metallicGradient;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(12, -80);
                ctx.lineTo(40, -60);
                ctx.moveTo(6, 118);
                ctx.lineTo(36, 108);
                ctx.stroke();
                
                // THIRD EYE - glows based on phase/attacks
                const eyeGlowIntensity = palette.thirdEyeGlow || 0.3;
                const eyeSize = 10 + eyeGlowIntensity * 8;
                const eyeHue = (palette.baseHue + 200) % 360;
                ctx.save();
                ctx.translate(0, -156);
                ctx.fillStyle = `hsla(${eyeHue}, 100%, 60%, ${0.5 + eyeGlowIntensity * 0.5})`;
                ctx.shadowColor = `hsl(${eyeHue}, 100%, 70%)`;
                ctx.shadowBlur = eyeGlowIntensity * 24;
                ctx.beginPath();
                ctx.arc(0, 0, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Iris
                ctx.fillStyle = `hsla(${(eyeHue + 120) % 360}, 100%, 80%, 0.9)`;
                ctx.beginPath();
                ctx.arc(0, 0, eyeSize * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupil
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(0, 0, eyeSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }

            function drawVibemasterPilotFigureCore(time, state, boss) {
                const phase = state.phase || 1;
                const isEnraged = !!boss.isEnraged;
                const baseHue = (time * 50 + phase * 40 + (isEnraged ? 30 : 0)) % 360;
                
                // Third eye glow intensifies during distortion attack, glows brighter in phase 3
                let thirdEyeGlow = 0.3 + Math.sin(time * 2.8) * 0.2;
                if (state.distortion && state.distortion.active) {
                    thirdEyeGlow = 0.65 + Math.sin(time * 4.5) * 0.25;
                }
                if (phase >= 3) {
                    thirdEyeGlow = Math.min(0.95, thirdEyeGlow + 0.3);
                }
                if (isEnraged) {
                    thirdEyeGlow = Math.min(0.95, thirdEyeGlow + 0.15);
                }
                
                const palette = {
                    baseHue,
                    wingHue: (baseHue + 70) % 360,
                    phase,
                    strokeColor: 'rgba(192, 192, 220, 0.82)',
                    visorShift: 140 + phase * 12,
                    enraged: isEnraged,
                    thirdEyeGlow
                };

                ctx.save();
                drawVibemasterPilotHalf(time, palette);
                ctx.scale(-1, 1);
                drawVibemasterPilotHalf(time, palette);
                ctx.restore();

                ctx.save();
                const heartPulse = 16 + Math.sin(time * 4.2) * (isEnraged ? 6 : 4);
                ctx.globalAlpha = 0.75;
                ctx.fillStyle = `hsla(${(baseHue + 30) % 360}, 100%, 76%, 0.85)`;
                ctx.beginPath();
                ctx.arc(0, -40, heartPulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.save();
                const haloRadius = 138;
                ctx.globalAlpha = 0.22 + (isEnraged ? 0.12 : 0);
                ctx.strokeStyle = `hsla(${(baseHue + 80) % 360}, 100%, 70%, 0.75)`;
                ctx.lineWidth = 6;
                ctx.setLineDash([36, 18]);
                ctx.beginPath();
                ctx.arc(0, 12, haloRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }

            function drawVibemasterWingPixi(container, time, state, xBase = 80) {
                // Engine glow pulse - intensifies with attacks
                const isAttacking = state && (state.timers.astral < 0.3 || state.timers.chakra < 0.3);
                const enginePulse = Math.sin(time * 5) * 10 + 25;
                const engineHue = (time * 60) % 360;
                
                const engineColors = [
                    hslToHex(engineHue, 100, 90),
                    hslToHex((engineHue + 30) % 360, 100, 60),
                    hslToHex((engineHue + 60) % 360, 100, 50)
                ];
                
                // Engine glow (radial gradient effect with multiple circles)
                const engine = new PIXI.Graphics();
                engine.circle(xBase, 0, enginePulse);
                engine.fill({ color: engineColors[2], alpha: 0 });
                engine.circle(xBase, 0, enginePulse * 0.6);
                engine.fill({ color: engineColors[1], alpha: 0.8 });
                engine.circle(xBase, 0, enginePulse * 0.3);
                engine.fill({ color: engineColors[0], alpha: 1 });
                container.addChild(engine);
                
                // Wing structure
                const wing = new PIXI.Graphics();
                
                // Upper wing panel
                wing.poly([
                    xBase + 0, -20,
                    xBase + 150, -100,
                    xBase + 180, -80,
                    xBase + 30, 20
                ]);
                wing.fill({ color: 0x808090 });
                wing.stroke({ width: 2, color: 0xc0c0d0 });
                
                // Lower wing panel
                wing.poly([
                    xBase + 20, 25,
                    xBase + 160, 100,
                    xBase + 140, 120,
                    xBase + 0, 30
                ]);
                wing.fill({ color: 0x404050 });
                wing.stroke({ width: 2, color: 0xc0c0d0 });
                
                // Energy lines
                const wingLineHue = ((time * 80 + 30) % 360);
                const wingLineColor = hslToHex(wingLineHue, 100, 80);
                wing.moveTo(xBase + 20, 0);
                wing.quadraticCurveTo(xBase + 100, -50, xBase + 160, -90);
                wing.stroke({ width: 2, color: wingLineColor, alpha: 0.8 });
                wing.moveTo(xBase + 10, 28);
                wing.quadraticCurveTo(xBase + 100, 70, xBase + 150, 110);
                wing.stroke({ width: 2, color: wingLineColor, alpha: 0.8 });
                
                container.addChild(wing);
            }
            
            function drawVibemasterHalfPilotPixi(container, time, state) {
                // Rainbow exoskeleton colors
                const hue = (time * 50) % 360;
                const exoColor1 = hslToHex(hue, 100, 70);
                const exoColor2 = hslToHex((hue + 60) % 360, 100, 60);
                const exoColor3 = hslToHex((hue + 120) % 360, 100, 50);
                
                const body = new PIXI.Graphics();
                
                // Draw wing first
                drawVibemasterWingPixi(container, time, state, 80);
                
                // Torso
                body.poly([
                    0, -90,
                    60, -50,
                    40, 100,
                    0, 120
                ]);
                body.fill({ color: exoColor2 });
                
                // Shoulder
                body.moveTo(50, -60);
                body.arc(60, -60, 20, Math.PI, Math.PI * 2);
                body.fill({ color: exoColor1 });
                
                // Arm - with wild spinning animation
                const armSpin = time * 3;
                const armX = 75 + Math.cos(armSpin) * 25;
                const armY = -50 + Math.sin(armSpin) * 80;
                body.moveTo(75, -50);
                body.lineTo(armX, armY);
                body.lineTo(armX - 20, armY + 10);
                body.stroke({ width: 4, color: exoColor2 });
                
                // Leg - dancing
                const legKick = Math.sin(time * 4) * 20;
                body.moveTo(40, 100);
                body.lineTo(60 + legKick, 200);
                body.lineTo(40 + legKick * 0.5, 210);
                body.stroke({ width: 4, color: exoColor3 });
                
                // Helmet/Head
                body.arc(0, -150, 50, Math.PI * 0.5, Math.PI, false);
                body.lineTo(-50, -100);
                body.quadraticCurveTo(-20, -95, 0, -90);
                body.fill({ color: exoColor1 });
                
                // Visor
                const visorHue = (200 + Math.sin(time * 3) * 30) % 360;
                const visorColor = hslToHex(visorHue, 100, 80);
                body.rect(-45, -140, 45, 20);
                body.fill({ color: visorColor });
                
                // Metallic highlights
                body.moveTo(10, -80);
                body.lineTo(40, -60);
                body.stroke({ width: 1.5, color: 0xffffff, alpha: 0.7 });
                body.moveTo(5, 115);
                body.lineTo(35, 105);
                body.stroke({ width: 1.5, color: 0xaaaaaa, alpha: 0.7 });
                
                container.addChild(body);
            }
            
            function hslToHex(h, s, l) {
                l /= 100;
                const a = s * Math.min(l, 1 - l) / 100;
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color);
                };
                const r = f(0);
                const g = f(8);
                const b = f(4);
                return (r << 16) | (g << 8) | b;
            }

            function drawVibemasterPixi(boss) {
                if (!boss || !pixiApp) return;
                
                // Cleanup if dead
                if (boss.dead) {
                    if (boss.pixiContainer) {
                        boss.pixiContainer.destroy({ children: true });
                        boss.pixiContainer = null;
                    }
                    return;
                }
                
                const state = ensureVibemasterState(boss);
                if (!state) return;
                
                // Create or reuse graphics container
                if (!boss.pixiContainer) {
                    boss.pixiContainer = new PIXI.Container();
                    pixiApp.stage.addChild(boss.pixiContainer);
                }
                
                const container = boss.pixiContainer;
                container.removeChildren();
                
                const time = performance.now() / 1000;
                const baseRadius = Number.isFinite(boss.r) ? boss.r : 60;
                const hover = Math.sin(time * 0.5) * 10; // Reduced hovering effect
                
                // Scale everything down
                const scale = 0.5; // Make VIBEMASTER 50% size
                
                // Psychedelic background layers (7 rotating geometric shapes)
                for (let i = 7; i > 0; i--) {
                    const layer = new PIXI.Graphics();
                    const radius = (baseRadius * 3 / 7) * i * (Math.sin(time + i) * 0.1 + 0.9) * scale;
                    const sides = 3 + (i % 4); // Triangles, squares, pentagons, hexagons
                    const angleStep = (Math.PI * 2) / sides;
                    const pulse = Math.sin(time * 0.5 + i) * 0.05 + 1;
                    const hue = ((time * 30 + i * 30) % 360);
                    const layerColor = hslToHex(hue, 100, 70);
                    
                    const points = [];
                    for (let j = 0; j < sides; j++) {
                        const angle = j * angleStep + time * 0.1 * (i % 3 + 1);
                        points.push(Math.cos(angle) * radius * pulse, Math.sin(angle) * radius * pulse);
                    }
                    layer.poly(points);
                    layer.stroke({ width: 1, color: layerColor, alpha: 0.4 });
                    layer.rotation = time * 0.05 * i;
                    container.addChild(layer);
                }
                
                // Create a sub-container for the pilot so we can scale it
                const pilotContainer = new PIXI.Container();
                pilotContainer.scale.set(scale);
                
                // Draw right half
                const rightHalf = new PIXI.Container();
                drawVibemasterHalfPilotPixi(rightHalf, time, state);
                pilotContainer.addChild(rightHalf);
                
                // Draw left half (mirrored)
                const leftHalf = new PIXI.Container();
                leftHalf.scale.x = -1; // Mirror horizontally
                drawVibemasterHalfPilotPixi(leftHalf, time, state);
                pilotContainer.addChild(leftHalf);
                
                container.addChild(pilotContainer);
                
                // Position (moved down more)
                container.x = boss.x;
                container.y = boss.y + hover + 60; // Added 60px offset to move down
                
                // Draw effects on canvas (these are dynamic and less performance-critical)
                drawVibemasterThreads(store.vibemasterThreads || state.threads);
                drawVibemasterRings(store.vibemasterRings || state.rings);
                drawVibemasterGuardians(store.vibemasterGuardians || state.guardians, state.phase);
                
                // Draw shadow on canvas
                if (Number.isFinite(boss.x) && Number.isFinite(boss.y)) {
                    const radiusX = Math.max(30, baseRadius * 1.6);
                    const radiusY = Math.max(14, baseRadius * 0.65);
                    const alpha = Math.max(0.25, Math.min(0.55, 0.25 + baseRadius * 0.0025));
                    drawEntityShadow(boss.x, boss.y, radiusX, radiusY, { alpha, yOffset: Math.max(18, baseRadius * 0.9) });
                }
                
                // HP bar on canvas
                const activeBoss = store && store.boss;
                const sameBoss = !!(activeBoss && (activeBoss === boss || (activeBoss.instanceId && boss.instanceId && activeBoss.instanceId === boss.instanceId) || (activeBoss._instanceId && boss._instanceId && activeBoss._instanceId === boss._instanceId)));
                let bossHp = ensureFiniteNumber(boss.hp, 0);
                let bossHpMax = ensureFiniteNumber(boss.hpMax, 1);
                if (sameBoss) {
                    bossHp = ensureFiniteNumber(activeBoss.hp, bossHp);
                    bossHpMax = ensureFiniteNumber(activeBoss.hpMax, bossHpMax);
                    boss.hp = bossHp;
                    boss.hpMax = bossHpMax;
                }
                const hpRatio = bossHpMax > 0 ? clamp(bossHp / bossHpMax, 0, 1) : 0;
                
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(boss.x - 60, boss.y - (boss.r || 60) - 24, 120, 10);
                ctx.fillStyle = '#d4b8ff';
                ctx.fillRect(boss.x - 60, boss.y - (boss.r || 60) - 24, 120 * hpRatio, 10);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(boss.x - 60, boss.y - (boss.r || 60) - 24, 120, 10);
                ctx.font = '11px Orbitron, Audiowide, sans-serif';
                ctx.fillStyle = '#f9ecff';
                ctx.textAlign = 'center';
                ctx.fillText(`Phase ${state.phase}`, boss.x, boss.y - (boss.r || 60) - 30);
                ctx.restore();
            }

            function drawVibemasterBoss(boss) {
                // Use PixiJS rendering for performance
                if (pixiApp) {
                    drawVibemasterPixi(boss);
                    return;
                }
                
                // Fallback to canvas (original code for compatibility)
                const state = ensureVibemasterState(boss);
                if (!state) return;

                const activeBoss = store && store.boss;
                const sameBoss = !!(activeBoss && (activeBoss === boss || (activeBoss.instanceId && boss.instanceId && activeBoss.instanceId === boss.instanceId) || (activeBoss._instanceId && boss._instanceId && activeBoss._instanceId === boss._instanceId)));
                let bossHp = ensureFiniteNumber(boss.hp, 0);
                let bossHpMax = ensureFiniteNumber(boss.hpMax, 1);
                if (sameBoss) {
                    bossHp = ensureFiniteNumber(activeBoss.hp, bossHp);
                    bossHpMax = ensureFiniteNumber(activeBoss.hpMax, bossHpMax);
                    boss.hp = bossHp;
                    boss.hpMax = bossHpMax;
                }
                const hpRatio = bossHpMax > 0 ? clamp(bossHp / bossHpMax, 0, 1) : 0;

                drawVibemasterThreads(store.vibemasterThreads || state.threads);
                drawVibemasterVacuum(boss, store.vibemasterVacuum || state.vacuum);
                drawVibemasterDistortion(boss, store.vibemasterDistortion || state.distortion);

                if (Number.isFinite(boss.x) && Number.isFinite(boss.y)) {
                    const bossRadius = Number.isFinite(boss.r) ? boss.r : 60;
                    const radiusX = Math.max(30, bossRadius * 1.6);
                    const radiusY = Math.max(14, bossRadius * 0.65);
                    const alpha = Math.max(0.25, Math.min(0.55, 0.25 + bossRadius * 0.0025));
                    drawEntityShadow(boss.x, boss.y, radiusX, radiusY, { alpha, yOffset: Math.max(18, bossRadius * 0.9) });
                }

                const time = performance.now() / 1000;
                const baseRadius = Number.isFinite(boss.r) ? boss.r : 60;
                const hover = Math.sin(time * 1.15 + (state.phase || 0) * 0.6) * Math.min(10, baseRadius * 0.18);
                const figureScale = clamp((baseRadius * 2) / 420, 0.24, 0.5);
                const auraRadius = Math.max(60, baseRadius * 1.35);

                ctx.save();
                ctx.translate(boss.x, boss.y + hover);
                const auraGradient = ctx.createRadialGradient(0, 0, auraRadius * 0.32, 0, 0, auraRadius * 1.55);
                auraGradient.addColorStop(0, 'rgba(255, 255, 255, 0.82)');
                auraGradient.addColorStop(0.35, 'rgba(220, 180, 255, 0.5)');
                auraGradient.addColorStop(0.78, 'rgba(50, 20, 100, 0.3)');
                auraGradient.addColorStop(1, 'rgba(10, 4, 26, 0)');
                ctx.globalAlpha = 0.75;
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius * 1.55, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 0.4 + (boss.isEnraged ? 0.2 : 0);
                ctx.strokeStyle = `hsla(${(time * 35 + (state.phase || 0) * 50) % 360}, 100%, 75%, 0.6)`;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([12, 10]);
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius * 1.18, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();

                ctx.save();
                ctx.translate(boss.x, boss.y + hover);
                if (boss.isEnraged) {
                    ctx.globalAlpha = 0.84 + 0.16 * Math.sin(time * 6.5);
                }
                ctx.scale(figureScale, figureScale);
                drawVibemasterPilotFigureCore(time, state, boss);
                ctx.restore();

                drawVibemasterRitual(boss, state.ritual);
                drawVibemasterBarrier(boss, state.barrier);
                drawVibemasterRings(store.vibemasterRings || state.rings);
                drawVibemasterGuardians(store.vibemasterGuardians || state.guardians, state.phase);

                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(boss.x - 60, boss.y - (boss.r || 60) - 24, 120, 10);
                ctx.fillStyle = '#d4b8ff';
                ctx.fillRect(boss.x - 60, boss.y - (boss.r || 60) - 24, 120 * hpRatio, 10);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(boss.x - 60, boss.y - (boss.r || 60) - 24, 120, 10);

                ctx.font = '11px Orbitron, Audiowide, sans-serif';
                ctx.fillStyle = '#f9ecff';
                ctx.textAlign = 'center';
                ctx.fillText(`Phase ${state.phase}`, boss.x, boss.y - (boss.r || 60) - 30);
                ctx.restore();
            }

            function drawBoss(t) {
                // Special rendering for Heat Death of the Universe
                if (t.isHeatDeath) {
                    // Darken the top half of screen with haze effect
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(0, 0, W, H / 2);

                    // Add dark gray haze
                    ctx.fillStyle = 'rgba(32, 32, 32, 0.6)';
                    ctx.fillRect(0, 0, W, H / 2);

                    // No health bar or physical form - just the void
                    ctx.restore();
                    return;
                }

                if (t.behavior === 'gemini') {
                    drawGeminiBoss(t);
                    return;
                }

                if (t.behavior === 'vibemaster') {
                    drawVibemasterBoss(t);
                    return;
                }

                if (Number.isFinite(t.x) && Number.isFinite(t.y)) {
                    const bossRadius = Number.isFinite(t.r) ? t.r : 60;
                    const radiusX = Math.max(30, bossRadius * 1.6);
                    const radiusY = Math.max(14, bossRadius * 0.65);
                    const alpha = Math.max(0.25, Math.min(0.55, 0.25 + bossRadius * 0.0025));
                    drawEntityShadow(t.x, t.y, radiusX, radiusY, {
                        alpha,
                        yOffset: Math.max(18, bossRadius * 0.9)
                    });
                }

                ctx.save();
                ctx.translate(t.x, t.y);
                if (t.isEnraged) {
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50);
                }

                const activeBoss = (typeof store !== 'undefined' && store && store.boss) ? store.boss : null;
                const sameBoss = !!(activeBoss && (activeBoss === t || (activeBoss.instanceId && activeBoss.instanceId === t.instanceId) || (activeBoss._instanceId && activeBoss._instanceId === t._instanceId)));
                let bossHp = ensureFiniteNumber(t.hp, 0);
                let bossHpMax = ensureFiniteNumber(t.hpMax, 1);

                if (sameBoss) {
                    bossHp = ensureFiniteNumber(activeBoss.hp, bossHp);
                    bossHpMax = ensureFiniteNumber(activeBoss.hpMax, bossHpMax);
                    t.hp = bossHp;
                    t.hpMax = bossHpMax;
                }

                const hpRatio = bossHpMax > 0 ? clamp(bossHp / bossHpMax, 0, 1) : 0;

                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(-60, -t.r - 20, 120, 8);
                const healthBarColor = t.name === 'EVIL BABYMOON' ? '#ffd700' : (t.color || '#ff4444');
                ctx.fillStyle = healthBarColor;
                ctx.fillRect(-60, -t.r - 20, 120 * hpRatio, 8);
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.strokeRect(-60, -t.r - 20, 120, 8);
                if (t.behavior === "aegis_architect") {
                    const state = ensureAegisArchitectState(t);
                    const now = performance.now() / 1000;
                    const baseCoreRadius = state ? state.coreRadius : t.r * 0.6;
                    const pulse = state ? Math.sin(state.corePulse) : Math.sin(now * 2.6);
                    const coreRadius = baseCoreRadius * (1 + 0.08 * pulse);

                    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    coreGradient.addColorStop(0, addAlpha('#ffffff', 0.9));
                    coreGradient.addColorStop(0.35, addAlpha(t.color || '#5dd0ff', 0.85));
                    coreGradient.addColorStop(1, addAlpha('#042033', 0.8));
                    ctx.fillStyle = coreGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                    ctx.fill();

                    const latticeRadius = coreRadius * 0.62;
                    ctx.strokeStyle = addAlpha('#ffffff', 0.35);
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, latticeRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.save();
                    ctx.rotate(now * 0.6);
                    ctx.globalAlpha = 0.75;
                    ctx.lineWidth = 1;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-latticeRadius, 0);
                        ctx.lineTo(latticeRadius, 0);
                        ctx.stroke();
                        ctx.rotate(Math.PI / 4);
                    }
                    ctx.restore();
                    ctx.globalAlpha = 1;

                    if (state) {
                        const outerRadius = state.shieldRadius;
                        const innerRadius = Math.max(outerRadius - 18, coreRadius + 12);

                        ctx.save();
                        ctx.rotate(state.rotationAngle);
                        state.segments.forEach(segment => {
                            ctx.save();
                            ctx.rotate(segment.baseAngle);
                            const arc = segment.arc;
                            if (segment.destroyed) {
                                const flicker = 0.25 + 0.25 * Math.sin(now * 4 + segment.baseAngle);
                                ctx.globalAlpha = flicker;
                                ctx.strokeStyle = addAlpha(segment.color, 0.6);
                                ctx.lineWidth = 4;
                                ctx.beginPath();
                                ctx.arc(0, 0, outerRadius, -arc / 2, arc / 2);
                                ctx.stroke();
                            } else {
                                const pulseScale = 0.65 + (segment.hitPulse || 0);
                                ctx.globalAlpha = 0.7 + (segment.hitPulse || 0);
                                ctx.fillStyle = addAlpha(segment.color, 0.45 + (segment.hitPulse || 0) * 0.4);
                                ctx.strokeStyle = addAlpha(segment.color, 0.9);
                                ctx.lineWidth = 3 + (segment.hitPulse || 0) * 10;
                                ctx.beginPath();
                                ctx.arc(0, 0, outerRadius, -arc / 2, arc / 2);
                                ctx.arc(0, 0, innerRadius, arc / 2, -arc / 2, true);
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();

                                const hpRatio = segment.maxHp > 0 ? clamp(segment.hp / segment.maxHp, 0, 1) : 0;
                                const barWidth = innerRadius * 0.32;
                                ctx.globalAlpha = 0.92;
                                ctx.fillStyle = addAlpha('#ffffff', 0.55);
                                ctx.fillRect(-2, -outerRadius - 12, 4, 2);
                                ctx.fillStyle = addAlpha(segment.color, 0.9);
                                ctx.fillRect(-barWidth / 2, -outerRadius - 20, barWidth * hpRatio, 3);
                            }
                            ctx.restore();
                        });
                        ctx.restore();

                        ctx.globalAlpha = 0.4 + 0.2 * Math.sin(now * 3.4);
                        ctx.strokeStyle = addAlpha(t.color || '#5dd0ff', 0.6);
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, outerRadius + 8, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                } else if (t.behavior === "hex") {
                    ctx.translate(0, 30);
                    const bodyW_top = t.r * 1.5;
                    const bodyW_bottom = t.r * 2.5;
                    const bodyH = t.r * 1.5;
                    ctx.fillStyle = "#66aaff";
                    ctx.strokeStyle = "#5599e5";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-bodyW_top / 2, -bodyH / 2);
                    ctx.lineTo(bodyW_top / 2, -bodyH / 2);
                    ctx.lineTo(bodyW_bottom / 2, bodyH / 2);
                    ctx.lineTo(-bodyW_bottom / 2, bodyH / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = "#e03434";
                    ctx.strokeStyle = "#c02d2d";
                    const crownH = t.r * 0.8, crownW = bodyW_top * 0.9;
                    ctx.beginPath();
                    ctx.moveTo(-crownW / 2, -bodyH / 2);
                    ctx.lineTo(-crownW / 2 + crownW / 4, -bodyH / 2 - crownH);
                    ctx.lineTo(0, -bodyH / 2 - crownH / 2);
                    ctx.lineTo(crownW / 2 - crownW / 4, -bodyH / 2 - crownH);
                    ctx.lineTo(crownW / 2, -bodyH / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = "#000";
                    ctx.fillRect(-t.r * 0.6, -t.r * 0.3, t.r * 0.4, t.r * 0.15);
                    ctx.fillRect(t.r * 0.2, -t.r * 0.3, t.r * 0.4, t.r * 0.15);
                    ctx.fillRect(-t.r * 0.4, 0, t.r * 0.8, t.r * 0.1);
                    ctx.strokeStyle = "#ffd700";
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, t.r * 1.1, 0.5, Math.PI - 0.5);
                    ctx.stroke();
                    ctx.fillStyle = "#ffd700";
                    ctx.strokeStyle = "#daa520";
                    ctx.lineWidth = 3;
                    const medR = t.r * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, t.r * 1.1 + medR);
                    for (let i = 1; i <= 8; i++) {
                        const angle = i * (2 * Math.PI / 8);
                        ctx.lineTo(medR * Math.sin(angle), t.r * 1.1 + medR * Math.cos(angle));
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (t.behavior === "construct") {
                    // Check if this is the DEATH ENGINE boss
                    if (t.name === 'DEATH ENGINE') {
                        // Update skull renderer position and color for red final phase
                        if (t.skullRenderer) {
                            t.skullRenderer.x = 0; // Relative position since we're already translated
                            t.skullRenderer.y = 0; // Relative position since we're already translated  
                            t.skullRenderer.skullColor = t.color || '#e54d24';

                            // Handle attack animation
                            if (t.isLaughing && !t.skullRenderer.isAttacking) {
                                // Trigger attack animation with sound effect
                                t.skullRenderer.triggerAttack(true);
                            }

                            // Update and draw using Boss class
                            t.skullRenderer.update();
                            t.skullRenderer.draw();
                        } else {
                            // Fallback to original drawing if skullRenderer is missing (shouldn't happen)
                            const skullWidth = t.r * 2;
                            const skullHeight = t.r * 2.8;

                            // Calculate mouth openness for animation
                            let mouthOpenness = 0;
                            if (t.isLaughing) {
                                const elapsedTime = performance.now() - t.laughStartTime;
                                mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 7;
                            }

                            // Draw all parts of the skull ship (pass boss color for red final phase)
                            const skullColor = t.color || '#e54d24';
                            drawSkullHorns(ctx, skullWidth, skullHeight, skullColor);
                            drawSkullMain(ctx, skullWidth, skullHeight, skullColor);
                            drawSkullFace(ctx, skullWidth, skullHeight, mouthOpenness, skullColor);
                            drawSkullWeathering(ctx, skullWidth, skullHeight, skullColor);
                        }
                    } else {
                        // Original GEOMETRON drawing code
                        const phaseColor = t.phase === 1 ? (t.color || "#ff4500") : "#ff4500"; ctx.fillStyle = addAlpha(phaseColor, 0.67); ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; if (t.phase === 2) { ctx.shadowColor = phaseColor; ctx.shadowBlur = 25; } const bodyW = t.r * 1.2, bodyH = t.r * 1.5, headH = t.r * 0.7; ctx.beginPath(); ctx.moveTo(-bodyW * 0.5, bodyH * 0.5); ctx.lineTo(-bodyW * 0.6, bodyH * 0.2); ctx.lineTo(-bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(0, -bodyH * 0.5); ctx.lineTo(bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(bodyW * 0.6, bodyH * 0.2); ctx.lineTo(bodyW * 0.5, bodyH * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); const shoulderY = -bodyH * 0.3, shoulderX = bodyW * 0.4; const armW = 0.4 * t.r, armH = 0.9 * t.r; ctx.beginPath(); ctx.moveTo(-shoulderX, shoulderY); ctx.lineTo(-shoulderX - armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(-shoulderX, shoulderY + armH); ctx.lineTo(-shoulderX + armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(shoulderX + armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(shoulderX, shoulderY + armH); ctx.lineTo(shoulderX - armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); const eyeR = Math.max(1, t.r * 0.2 + 2 * Math.sin(performance.now() / 200)); ctx.fillStyle = "#ffffff"; ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -headH * 0.1, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    }
                } else if (t.behavior === "avian") { ctx.save(); ctx.rotate(-Math.PI / 2); const wingY = -t.r * 0.4; ctx.strokeStyle = "#FFFFFF"; ctx.fillStyle = t.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-t.r * 0.4, wingY); ctx.quadraticCurveTo(-t.r * 0.8, wingY - t.r * 0.6, -t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(-t.r * 0.9, wingY - t.r * 0.1, -t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(t.r * 0.4, wingY); ctx.quadraticCurveTo(t.r * 0.8, wingY - t.r * 0.6, t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(t.r * 0.9, wingY - t.r * 0.1, t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0, 0, t.r * 0.6, t.r * 0.8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); const eyeSize = t.r * 0.15; ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = "#FF6600"; ctx.beginPath(); ctx.moveTo(0, t.r * 0.1); ctx.lineTo(-t.r * 0.15, t.r * 0.3); ctx.lineTo(t.r * 0.15, t.r * 0.3); ctx.closePath(); ctx.fill(); ctx.restore(); } else if (t.behavior === "sentinel") {
                    // Cyberpunk VOID SENTINEL with purple-orange sunset gradient
                    const time = performance.now() / 1000;

                    // Create radial gradient for cyberpunk sunset effect
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
                    gradient.addColorStop(0, '#FF6B35'); // Orange center
                    gradient.addColorStop(0.4, '#FF8E53'); // Orange-purple transition
                    gradient.addColorStop(0.7, '#8B4A9C'); // Purple
                    gradient.addColorStop(1, '#2D1B69'); // Deep purple edge

                    // Main body - hexagonal cyberpunk shape
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#FF6B35';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const sides = 6;
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const x = Math.cos(angle) * t.r;
                        const y = Math.sin(angle) * t.r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Inner core with pulsing effect
                    const pulseSize = 0.6 + 0.2 * Math.sin(time * 3);
                    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 0.5);
                    coreGradient.addColorStop(0, '#FFFFFF');
                    coreGradient.addColorStop(0.3, '#FF6B35');
                    coreGradient.addColorStop(1, '#8B4A9C');

                    ctx.fillStyle = coreGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, t.r * 0.4 * pulseSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Cyberpunk energy rings
                    ctx.strokeStyle = '#FF6B35';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        const ringTime = time * (2 + i * 0.5);
                        const opacity = 0.3 + 0.4 * Math.sin(ringTime);
                        ctx.globalAlpha = opacity;

                        ctx.beginPath();
                        ctx.arc(0, 0, t.r * (0.7 + i * 0.15), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;

                    // Rotating cyberpunk elements
                    ctx.strokeStyle = '#8B4A9C';
                    ctx.fillStyle = '#FF6B35';
                    ctx.lineWidth = 2;

                    for (let i = 0; i < 8; i++) {
                        ctx.save();
                        ctx.rotate(i * Math.PI / 4 + time * 0.5);
                        ctx.translate(t.r * 0.8, 0);

                        // Small diamond-shaped elements
                        ctx.beginPath();
                        ctx.moveTo(0, -t.r * 0.08);
                        ctx.lineTo(t.r * 0.06, 0);
                        ctx.lineTo(0, t.r * 0.08);
                        ctx.lineTo(-t.r * 0.06, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Glowing eyes with cyberpunk effect
                    ctx.shadowColor = '#FF6B35';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#FFFFFF';

                    const eyeOffset = t.r * 0.25;
                    ctx.beginPath();
                    ctx.arc(-eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;

                } else if (t.behavior === "broodlord") {
                    // Draw cyberpunk HIVE SOVEREIGN - sleek and menacing
                    const time = performance.now() / 1000;
                    const pulseFactor = 1 + 0.08 * Math.sin(time * 3);

                    // Create sunset gradient for main body
                    const mainGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
                    mainGradient.addColorStop(0, '#FF6B35'); // Orange center
                    mainGradient.addColorStop(0.4, '#FF8E53'); // Orange-purple blend
                    mainGradient.addColorStop(0.7, '#8B4A9C'); // Purple
                    mainGradient.addColorStop(1, '#2D1B69'); // Deep void purple

                    // Main carapace body with cyberpunk glow
                    ctx.fillStyle = mainGradient;
                    ctx.strokeStyle = '#FF6B35';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#8B4A9C';
                    ctx.shadowBlur = 20 * pulseFactor;

                    ctx.beginPath();
                    ctx.ellipse(0, 0, t.r * 1.2 * pulseFactor, t.r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // Segmented armor plating with energy lines
                    ctx.strokeStyle = "#FF8E53";
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;

                    for (let i = -2; i <= 2; i++) {
                        const segmentPulse = 0.9 + 0.1 * Math.sin(time * 4 + i * 0.5);
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.ellipse(0, i * t.r * 0.25, t.r * 1.1 * pulseFactor * segmentPulse, t.r * 0.15, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;

                    // Cyberpunk energy claws/appendages
                    for (let side = -1; side <= 1; side += 2) {
                        for (let i = 0; i < 3; i++) {
                            ctx.save();
                            ctx.translate(side * t.r * 0.8, (i - 1) * t.r * 0.4);
                            ctx.rotate(side * (Math.PI / 6 + i * Math.PI / 12) + Math.sin(time * 2 + i) * 0.15);

                            // Energy claw with gradient
                            const clawGradient = ctx.createLinearGradient(0, 0, t.r * 0.8, 0);
                            clawGradient.addColorStop(0, '#8B4A9C');
                            clawGradient.addColorStop(0.7, '#FF6B35');
                            clawGradient.addColorStop(1, '#FFFFFF');

                            ctx.fillStyle = clawGradient;
                            ctx.strokeStyle = '#FF8E53';
                            ctx.lineWidth = 3;
                            ctx.shadowColor = '#FF6B35';
                            ctx.shadowBlur = 8;

                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(t.r * 0.6, 0);
                            ctx.lineTo(t.r * 0.7, -t.r * 0.1);
                            ctx.lineTo(t.r * 0.8, 0);
                            ctx.lineTo(t.r * 0.7, t.r * 0.1);
                            ctx.lineTo(t.r * 0.6, 0);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();

                            ctx.restore();
                        }
                    }
                    ctx.shadowBlur = 0;

                    // Cyberpunk energy eyes
                    const eyeGlow = 0.6 + 0.4 * Math.sin(time * 5);

                    for (let side = -1; side <= 1; side += 2) {
                        // Outer eye glow
                        ctx.shadowColor = '#FF6B35';
                        ctx.shadowBlur = 20 * eyeGlow;
                        ctx.fillStyle = '#FF6B35';

                        ctx.beginPath();
                        ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.18 * eyeGlow, 0, Math.PI * 2);
                        ctx.fill();

                        // Main eye
                        ctx.shadowBlur = 10;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.12, 0, Math.PI * 2);
                        ctx.fill();

                        // Energy core pupil
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#8B4A9C';
                        ctx.fillStyle = '#2D1B69';
                        ctx.beginPath();
                        ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Cyberpunk mandibles with energy effect
                    ctx.shadowBlur = 0;
                    const mandibleOffset = Math.sin(time * 3) * 0.12;

                    for (let side = -1; side <= 1; side += 2) {
                        ctx.save();
                        ctx.translate(side * t.r * 0.2, t.r * 0.2);
                        ctx.rotate(side * (Math.PI / 8 + mandibleOffset));

                        // Mandible gradient
                        const mandibleGradient = ctx.createLinearGradient(0, 0, t.r * 0.4, 0);
                        mandibleGradient.addColorStop(0, '#2D1B69');
                        mandibleGradient.addColorStop(0.6, '#8B4A9C');
                        mandibleGradient.addColorStop(1, '#FF6B35');

                        ctx.fillStyle = mandibleGradient;
                        ctx.strokeStyle = '#FF8E53';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#8B4A9C';
                        ctx.shadowBlur = 5;

                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(t.r * 0.3, -t.r * 0.1);
                        ctx.lineTo(t.r * 0.4, 0);
                        ctx.lineTo(t.r * 0.3, t.r * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.shadowBlur = 0;

                } else if (t.behavior === "shadow_clone") {
                    const player = (typeof store !== 'undefined' && store && store.player) ? store.player : {};
                    const subclass = player && player.subclass ? player.subclass : '';
                    const time = performance.now() / 1000;
                    const basePulse = 0.6 + 0.25 * Math.sin(time * 4.3);
                    let accent = '#8fa0ff';
                    switch (subclass) {
                        case 'juggernaut': accent = '#ff6b6b'; break;
                        case 'marauder': accent = '#66ff99'; break;
                        case 'demolitioner': accent = '#ffd166'; break;
                        case 'railgunner': accent = '#b794ff'; break;
                        case 'phasestriker': accent = '#ff91d2'; break;
                        case 'stormbringer': accent = '#6dd0ff'; break;
                    }
                    const glowStrength = t.isEnraged ? 1.0 : 0.7;
                    let facing = Math.atan2(((player && player.y) ? player.y : t.y) - t.y, ((player && player.x) ? player.x : t.x) - t.x) + Math.PI / 2;
                    if (t.abilityStage === 'charge' && (Math.abs(t.shadowChargeVX || 0) + Math.abs(t.shadowChargeVY || 0)) > 16) {
                        facing = Math.atan2(t.shadowChargeVY || 0, t.shadowChargeVX || 0) + Math.PI / 2;
                    }
                    const wobble = Math.sin(time * 3 + (t.moveT || 0)) * 0.05;
                    ctx.save();
                    ctx.rotate(facing + wobble);
                    const scalePulse = 1 + (t.currentAbility ? basePulse * 0.05 : 0);
                    ctx.scale(scalePulse, 1);

                    ctx.shadowColor = addAlpha(accent, glowStrength);
                    ctx.shadowBlur = t.isEnraged ? 30 : 18;

                    const bodyGradient = ctx.createLinearGradient(0, -t.r * 1.4, 0, t.r * 1.3);
                    bodyGradient.addColorStop(0, addAlpha('#f4f7ff', 0.85));
                    bodyGradient.addColorStop(0.45, addAlpha('#3b4268', 0.95));
                    bodyGradient.addColorStop(1, addAlpha('#060712', 0.95));
                    ctx.fillStyle = bodyGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, -t.r * 1.35);
                    ctx.lineTo(t.r * 0.92, t.r * 0.88);
                    ctx.lineTo(0, t.r * 1.15);
                    ctx.lineTo(-t.r * 0.92, t.r * 0.88);
                    ctx.closePath();
                    ctx.fill();
                    ctx.lineWidth = 2.4;
                    ctx.strokeStyle = addAlpha('#ccd2ef', 0.55);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(0, -t.r * 0.95);
                    ctx.lineTo(t.r * 0.55, t.r * 0.68);
                    ctx.lineTo(0, t.r * 0.9);
                    ctx.lineTo(-t.r * 0.55, t.r * 0.68);
                    ctx.closePath();
                    ctx.fillStyle = 'rgba(22, 26, 52, 0.9)';
                    ctx.fill();
                    ctx.lineWidth = 1.4;
                    ctx.strokeStyle = addAlpha(accent, 0.55 + 0.3 * basePulse);
                    ctx.stroke();

                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = addAlpha('#f7fbff', 0.85);
                    ctx.beginPath();
                    ctx.arc(0, -t.r * 0.32, t.r * 0.28, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = addAlpha(accent, 0.6 + 0.3 * Math.sin(time * 6));
                    ctx.beginPath();
                    ctx.arc(0, -t.r * 0.32, t.r * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    ctx.lineWidth = 3;
                    ctx.strokeStyle = addAlpha(accent, 0.45 + 0.35 * basePulse);
                    for (let side = -1; side <= 1; side += 2) {
                        ctx.beginPath();
                        ctx.moveTo(side * t.r * 0.65, -t.r * 0.1);
                        ctx.quadraticCurveTo(side * t.r * 1.2, t.r * 0.15, side * t.r * 0.95, t.r * 0.95);
                        ctx.stroke();
                    }

                    ctx.lineWidth = 1.2;
                    ctx.strokeStyle = addAlpha('#dde3ff', 0.4);
                    ctx.beginPath();
                    ctx.moveTo(-t.r * 0.35, -t.r * 0.2);
                    ctx.lineTo(-t.r * 0.55, t.r * 0.6);
                    ctx.moveTo(t.r * 0.35, -t.r * 0.2);
                    ctx.lineTo(t.r * 0.55, t.r * 0.6);
                    ctx.stroke();

                    const exhaustPulse = 0.6 + 0.35 * Math.sin(time * 10 + (t.isEnraged ? Math.PI / 4 : 0));
                    ctx.globalAlpha = 0.45 + 0.4 * exhaustPulse;
                    ctx.fillStyle = addAlpha(accent, 0.8);
                    ctx.beginPath();
                    ctx.ellipse(-t.r * 0.38, t.r * 1.08, t.r * 0.2, t.r * (0.45 + 0.12 * exhaustPulse), 0, 0, Math.PI * 2);
                    ctx.ellipse(t.r * 0.38, t.r * 1.08, t.r * 0.2, t.r * (0.45 + 0.12 * exhaustPulse), 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    if (t.abilityStage === 'charge') {
                        ctx.lineWidth = 2.6;
                        ctx.strokeStyle = addAlpha(accent, 0.85);
                        ctx.beginPath();
                        ctx.moveTo(-t.r * 0.5, t.r * 0.6);
                        ctx.lineTo(-t.r * 0.75, t.r * 1.4);
                        ctx.moveTo(t.r * 0.5, t.r * 0.6);
                        ctx.lineTo(t.r * 0.75, t.r * 1.4);
                        ctx.stroke();
                    }

                    ctx.shadowBlur = 0;
                    ctx.restore();

                    if (t.shadowTelegraph) {
                        const telegraph = t.shadowTelegraph;
                        const progress = Math.max(0, Math.min(1, telegraph.progress || 0));
                        if (telegraph.type === 'star') {
                            const ringRadius = t.r * (1.05 + progress * 0.65);
                            ctx.save();
                            ctx.globalAlpha = 0.4 + 0.4 * progress;
                            ctx.lineWidth = 2 + progress * 3;
                            ctx.strokeStyle = addAlpha(accent, 0.8);
                            ctx.setLineDash([5, 3]);
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.globalAlpha = 0.6;
                            const starCount = 6;
                            for (let i = 0; i < starCount; i++) {
                                ctx.save();
                                ctx.rotate(time * (t.isEnraged ? 2.1 : 1.6) + i * (Math.PI * 2 / starCount));
                                ctx.translate(0, ringRadius);
                                const size = 7 + progress * 6;
                                ctx.fillStyle = addAlpha('#f6f8ff', 0.9);
                                ctx.beginPath();
                                ctx.moveTo(0, -size);
                                ctx.lineTo(size * 0.45, 0);
                                ctx.lineTo(0, size);
                                ctx.lineTo(-size * 0.45, 0);
                                ctx.closePath();
                                ctx.fill();
                                ctx.lineWidth = 1.2;
                                ctx.strokeStyle = addAlpha(accent, 0.6);
                                ctx.stroke();
                                ctx.restore();
                            }
                            ctx.restore();
                            ctx.globalAlpha = 1;
                        } else if (telegraph.type === 'lightning' && t.shadowTelegraphTarget) {
                            const targetX = t.shadowTelegraphTarget.x - t.x;
                            const targetY = t.shadowTelegraphTarget.y - t.y;
                            const dist = Math.sqrt(targetX * targetX + targetY * targetY) || 1;
                            const segments = 7;
                            ctx.globalAlpha = 0.25 + 0.55 * progress;
                            ctx.lineWidth = 2 + progress * 2.5;
                            ctx.strokeStyle = addAlpha(accent, 0.7);
                            ctx.beginPath();
                            ctx.moveTo(0, -t.r * 0.25);
                            for (let i = 1; i <= segments; i++) {
                                const tSeg = i / segments;
                                const px = targetX * tSeg;
                                const py = targetY * tSeg;
                                const offsetScale = (1 - Math.abs(0.5 - tSeg) * 1.8);
                                const offset = Math.sin(time * 12 + i * 1.7) * offsetScale * 24 * (0.3 + progress);
                                const nx = -targetY / dist;
                                const ny = targetX / dist;
                                const jitterX = px + nx * offset;
                                const jitterY = py + ny * offset;
                                ctx.lineTo(jitterX, jitterY);
                            }
                            ctx.stroke();
                            ctx.setLineDash([10, 8]);
                            ctx.lineWidth = 1.4;
                            ctx.strokeStyle = addAlpha('#f1f3ff', 0.6);
                            ctx.beginPath();
                            ctx.moveTo(0, -t.r * 0.3);
                            ctx.lineTo(targetX, targetY);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.globalAlpha = 0.6;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(targetX, targetY, 14 + progress * 18, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        } else if (telegraph.type === 'hounds') {
                            const baseRadius = t.r * 0.9;
                            const ringRadius = baseRadius + progress * t.r * 0.6;
                            ctx.save();
                            ctx.translate(0, t.r * 1.1);
                            ctx.scale(1, 0.55);
                            ctx.globalAlpha = 0.3 + 0.4 * progress;
                            ctx.fillStyle = 'rgba(10, 12, 28, 0.9)';
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = addAlpha(accent, 0.7);
                            ctx.setLineDash([4, 3]);
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.shadowColor = addAlpha(accent, 0.6);
                            ctx.shadowBlur = 15;
                            const pawCount = 4;
                            for (let i = 0; i < pawCount; i++) {
                                const angle = time * (t.isEnraged ? 2.4 : 1.6) + i * (Math.PI * 2 / pawCount);
                                const radius = ringRadius * (0.45 + 0.25 * Math.sin(time * 3 + i));
                                const px = Math.cos(angle) * radius;
                                const py = Math.sin(angle) * radius;
                                ctx.save();
                                ctx.translate(px, py);
                                ctx.rotate(angle);
                                const size = 6 + progress * 4;
                                ctx.fillStyle = addAlpha('#f4f7ff', 0.85);
                                ctx.beginPath();
                                ctx.ellipse(0, 0, size, size * 0.6, 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            ctx.shadowBlur = 0;
                            ctx.restore();
                        } else if (telegraph.type === 'charge' && t.shadowTelegraphTarget) {
                            const targetX = t.shadowTelegraphTarget.x - t.x;
                            const targetY = t.shadowTelegraphTarget.y - t.y;
                            const dist = Math.sqrt(targetX * targetX + targetY * targetY) || 1;
                            const dirX = targetX / dist;
                            const dirY = targetY / dist;
                            const reach = Math.min(dist, t.r * (2.8 + 1.4 * progress));
                            ctx.globalAlpha = 0.4 + 0.45 * progress;
                            ctx.lineWidth = 3.2;
                            ctx.strokeStyle = addAlpha(accent, 0.8);
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(dirX * reach, dirY * reach);
                            ctx.stroke();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = addAlpha('#f3f6ff', 0.75);
                            ctx.beginPath();
                            ctx.moveTo(dirX * (reach + 12), dirY * (reach + 12));
                            ctx.lineTo(dirX * (reach - 10) - dirY * 8, dirY * (reach - 10) + dirX * 8);
                            ctx.lineTo(dirX * (reach - 10) + dirY * 8, dirY * (reach - 10) - dirX * 8);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 0.5;
                            ctx.lineWidth = 2;
                            ctx.setLineDash([6, 4]);
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(targetX, targetY);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.globalAlpha = 0.8;
                            ctx.beginPath();
                            ctx.arc(targetX, targetY, 14 + progress * 14, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.globalAlpha = 1;
                        }
                    }
                } else if (t.behavior === "asynchronos") {
                    // Chronovore boss design
                    const time = performance.now() / 1000;
                    const pulse = 0.95 + 0.05 * Math.sin(time / 0.4);
                    const coreRadius = t.r;

                    // Draw Horns
                    ctx.fillStyle = '#4c1d95'; // Deep purple
                    ctx.shadowColor = '#a78bfa';
                    ctx.shadowBlur = 20;
                    // Left Horn
                    ctx.beginPath();
                    ctx.moveTo(-coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.quadraticCurveTo(-coreRadius * 2, -coreRadius * 2, -coreRadius * 1.5, coreRadius * 1.5);
                    ctx.quadraticCurveTo(-coreRadius, 0, -coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.fill();
                    // Right Horn
                    ctx.beginPath();
                    ctx.moveTo(coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.quadraticCurveTo(coreRadius * 2, -coreRadius * 2, coreRadius * 1.5, coreRadius * 1.5);
                    ctx.quadraticCurveTo(coreRadius, 0, coreRadius * 0.8, -coreRadius * 0.5);
                    ctx.fill();

                    // Draw Dinosaur Head Shape
                    ctx.fillStyle = '#1e1b4b'; // Dark indigo
                    ctx.strokeStyle = '#818cf8';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, -coreRadius * 1.5); // Top of head
                    ctx.quadraticCurveTo(coreRadius * 1.5, -coreRadius, coreRadius, coreRadius * 1.2); // Jaw right
                    ctx.lineTo(-coreRadius, coreRadius * 1.2); // Jaw left
                    ctx.quadraticCurveTo(-coreRadius * 1.5, -coreRadius, 0, -coreRadius * 1.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Draw Temporal Eye (Core)
                    const eyeRadius = coreRadius * pulse;
                    const gradient = ctx.createRadialGradient(0, 0, eyeRadius * 0.2, 0, 0, eyeRadius);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    gradient.addColorStop(0.7, 'rgba(129, 140, 248, 0.8)');
                    gradient.addColorStop(1, 'rgba(55, 48, 163, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, eyeRadius * 1.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Clock tick marks
                    ctx.strokeStyle = '#fde047'; // Gold/Yellow
                    ctx.lineWidth = 3;
                    for(let i = 0; i < 12; i++) {
                        const angle = (i/12) * Math.PI * 2;
                        const startRadius = eyeRadius * 0.9;
                        const endRadius = eyeRadius * 1.1;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * startRadius, Math.sin(angle) * startRadius);
                        ctx.lineTo(Math.cos(angle) * endRadius, Math.sin(angle) * endRadius);
                        ctx.stroke();
                    }

                    // Draw Orbiting Clock Hands
                    ctx.shadowColor = '#fde047';
                    ctx.shadowBlur = 10;
                    const state = t.asynchronosState;
                    const beamAngle = (state && state.beam) ? state.beam.angle : time * 0.5;
                    // Hour hand
                    ctx.save();
                    ctx.rotate(beamAngle / 12);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(eyeRadius * 0.7, 0);
                    ctx.stroke();
                    ctx.restore();
                    // Minute hand
                    ctx.save();
                    ctx.rotate(beamAngle);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(eyeRadius, 0);
                    ctx.stroke();
                    ctx.restore();
                    ctx.shadowBlur = 0;

                    // Draw Evil Eye in the Center
                    const eyeHeight = eyeRadius * 0.7;
                    const eyeWidth = eyeRadius * 1.2;
                    
                    // Iris
                    ctx.fillStyle = '#facc15'; // Vivid yellow for the iris
                    ctx.shadowColor = '#f59e0b'; // Amber shadow
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.moveTo(0, -eyeHeight / 2);
                    ctx.quadraticCurveTo(eyeWidth / 2, 0, 0, eyeHeight / 2);
                    ctx.quadraticCurveTo(-eyeWidth / 2, 0, 0, -eyeHeight / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    // Pupil (vertical slit) that pulses
                    const pupilWidth = eyeRadius * 0.15;
                    const pupilHeight = eyeHeight * (0.9 * pulse);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-pupilWidth / 2, -pupilHeight / 2, pupilWidth, pupilHeight);

                } else { const time = performance.now() / 1000; ctx.fillStyle = '#2c2c54'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, t.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#706fd3'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f0932b'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.3, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 6; i++) { ctx.save(); ctx.rotate(i * Math.PI / 3 + time * 0.3); ctx.translate(t.r * 0.6, 0); ctx.fillStyle = '#ff6348'; ctx.strokeStyle = '#2f3542'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore(); } const eyeSize = t.r * 0.12; ctx.fillStyle = '#ff3838'; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 4; i++) { ctx.save(); ctx.rotate(i * Math.PI / 2 + time * -0.5); ctx.translate(t.r * 0.9, 0); ctx.fillStyle = '#3c6382'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 2; ctx.fillRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.strokeRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.restore(); } }
                
                // Draw poison status effect (sickly tint + wobble + bubbles) - DISABLED FOR BOSSES
                if (t.poisonStacks && t.poisonStacks > 0 && !t.isBoss) {
                    ctx.save();
                    const time = performance.now() / 1000;
                    const intensity = Math.min(t.poisonStacks / 3, 1);
                    const pulse = 0.85 + 0.15 * Math.sin(time * 3.1 + (t.id || 0));
                    const wobble = Math.sin(time * 4 + (t.id || 0) * 0.33) * t.r * (0.06 + intensity * 0.04);
                    const mistRadius = t.r * (1.24 + intensity * 0.38);

                    // Slight wobble so the target looks unsteady
                    ctx.translate(Math.sin(time * 2.5 + (t.id || 0)) * wobble * 0.6, Math.cos(time * 2.1 + (t.id || 0)) * wobble * 0.4);
                    ctx.rotate(Math.sin(time * 1.7 + (t.id || 0)) * 0.04 * (0.6 + intensity * 0.6));

                    // Sickly green tint hugging the body
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.globalAlpha = 0.28 + intensity * 0.32;
                    const sickTint = ctx.createRadialGradient(0, 0, t.r * 0.2, 0, 0, mistRadius * 0.85);
                    sickTint.addColorStop(0, 'rgba(120, 255, 160, 0.8)');
                    sickTint.addColorStop(0.55, 'rgba(70, 185, 90, 0.65)');
                    sickTint.addColorStop(1, 'rgba(20, 75, 30, 0)');
                    ctx.fillStyle = sickTint;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, mistRadius * (0.82 + 0.08 * pulse), mistRadius * (0.78 + 0.1 * Math.sin(time * 2.8 + pulse)), 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Pulsing poisonous mist
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.35 + intensity * 0.38;
                    const baseMist = ctx.createRadialGradient(0, 0, mistRadius * 0.2, 0, 0, mistRadius * 1.08);
                    baseMist.addColorStop(0, 'rgba(160, 255, 210, 0.9)');
                    baseMist.addColorStop(0.5, 'rgba(60, 235, 140, 0.55)');
                    baseMist.addColorStop(1, 'rgba(15, 120, 45, 0)');
                    ctx.fillStyle = baseMist;
                    ctx.beginPath();
                    ctx.arc(0, 0, mistRadius * (0.95 + 0.12 * pulse), 0, Math.PI * 2);
                    ctx.fill();

                    const swirlCount = 5 + Math.floor(intensity * 3);
                    ctx.globalAlpha = 0.22 + intensity * 0.3;
                    for (let i = 0; i < swirlCount; i++) {
                        const swirlAngle = time * (1.3 + intensity * 0.6) + i * (Math.PI * 2 / swirlCount);
                        const offset = Math.sin(time * 1.8 + i) * t.r * (0.26 + intensity * 0.14);
                        ctx.save();
                        ctx.rotate(swirlAngle);
                        const swirlLength = mistRadius * (0.55 + Math.sin(time * 2.4 + i) * 0.12);
                        const swirlWidth = mistRadius * (0.3 + intensity * 0.14);
                        ctx.translate(offset, 0);
                        ctx.beginPath();
                        ctx.ellipse(0, 0, swirlLength, swirlWidth * 0.45, 0, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(90, 255, 170, 0.85)';
                        ctx.fill();
                        ctx.restore();
                    }

                    // Green bubbles bubbling up from the target
                    const bubbleCount = 4 + Math.floor(intensity * 4);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.55;
                    for (let i = 0; i < bubbleCount; i++) {
                        const progress = (time * (0.45 + intensity * 0.45) + i * 0.37 + (t.id || 0) * 0.11) % 1;
                        const bubbleX = Math.sin(progress * Math.PI * 2 + i) * t.r * (0.35 + intensity * 0.25);
                        const bubbleY = -t.r * (0.4 + progress * (0.7 + intensity * 0.4));
                        const bubbleSize = t.r * (0.08 + intensity * 0.05 + progress * 0.04);
                        const bubbleGlow = ctx.createRadialGradient(bubbleX, bubbleY, 0, bubbleX, bubbleY, bubbleSize * 1.6);
                        bubbleGlow.addColorStop(0, 'rgba(190, 255, 210, 0.9)');
                        bubbleGlow.addColorStop(0.6, 'rgba(110, 255, 150, 0.45)');
                        bubbleGlow.addColorStop(1, 'rgba(0, 120, 40, 0)');
                        ctx.fillStyle = bubbleGlow;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize * 1.4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(190, 255, 220, 0.8)';
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    if (t.poisonStacks > 1) {
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.globalAlpha = 0.7 + intensity * 0.25;
                        ctx.fillStyle = '#7dff9b';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(t.poisonStacks, 0, mistRadius * 0.85);
                    }

                    ctx.restore();
                }
                
                // Draw ice status effect (dark blue glowing aura with snowflakes)
                if (t.iceStacks && t.iceStacks > 0) {
                    ctx.save();
                    const icePulse = 0.6 + 0.4 * Math.cos(performance.now() / 350);
                    const iceAlpha = 0.5 * icePulse;
                    
                    // Outer glow ring - THINNED
                    ctx.globalAlpha = iceAlpha * 0.4;
                    ctx.strokeStyle = '#0033ff';
                    ctx.lineWidth = 1; // Reduced from 2.5
                    ctx.beginPath();
                    ctx.arc(0, 0, t.r * (1.3 + t.iceStacks * 0.15), 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner glow ring - THINNED
                    ctx.globalAlpha = iceAlpha * 0.7;
                    ctx.strokeStyle = '#0088ff';
                    ctx.lineWidth = 0.8; // Reduced from 1.5
                    ctx.beginPath();
                    ctx.arc(0, 0, t.r * (1.1 + t.iceStacks * 0.1), 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Snow particles around boss (increases with stacks)
                    ctx.globalAlpha = 0.5;
                    const snowCount = 5 + (t.iceStacks * 2); // 5, 7, 9 snowflakes for stacks 1, 2, 3
                    const time = performance.now() / 1000;
                    for (let i = 0; i < snowCount; i++) {
                        const angle = (i / snowCount) * Math.PI * 2 + time * 0.5;
                        const radius = t.r * (1.3 + Math.sin(time * 1.5 + i) * 0.4);
                        const snowX = Math.cos(angle) * radius;
                        const snowY = Math.sin(angle) * radius;
                        const snowSize = 1.5 + Math.sin(time * 2.5 + i) * 1;
                        
                        // Draw snowflake as cross/star pattern
                        ctx.strokeStyle = 'rgba(200, 230, 255, 0.8)';
                        ctx.lineWidth = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(snowX - snowSize, snowY);
                        ctx.lineTo(snowX + snowSize, snowY);
                        ctx.moveTo(snowX, snowY - snowSize);
                        ctx.lineTo(snowX, snowY + snowSize);
                        ctx.stroke();
                    }
                    
                    if (t.isFrozen && t.iceStacks >= 3) {
                        // FROZEN VISUAL - Ice crystal encasement
                        // Subtle blue-white ice shell (more transparent)
                        ctx.globalAlpha = 0.25;
                        const frostShell = ctx.createRadialGradient(0, 0, t.r * 0.15, 0, 0, t.r * 1.5);
                        frostShell.addColorStop(0, 'rgba(220, 240, 255, 0.4)');  // Very light center
                        frostShell.addColorStop(0.4, 'rgba(180, 220, 255, 0.3)'); // Light blue
                        frostShell.addColorStop(0.7, 'rgba(140, 200, 255, 0.2)'); // Fading blue
                        frostShell.addColorStop(1, 'rgba(100, 180, 240, 0)');     // Transparent edge
                        ctx.fillStyle = frostShell;
                        ctx.beginPath();
                        ctx.arc(0, 0, t.r * 1.45, 0, Math.PI * 2);
                        ctx.fill();

                        // Thin crisp ice border (much thinner)
                        ctx.globalAlpha = 0.8;
                        ctx.strokeStyle = '#d0e8ff';
                        ctx.lineWidth = 1.5; // Much thinner than before (was 5+)
                        ctx.beginPath();
                        ctx.arc(0, 0, t.r * 1.35, 0, Math.PI * 2);
                        ctx.stroke();

                        // Inner frost details - hexagonal ice pattern
                        ctx.globalAlpha = 0.4;
                        ctx.strokeStyle = '#b0d0ff';
                        ctx.lineWidth = 0.8;
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const x1 = Math.cos(angle) * t.r * 0.6;
                            const y1 = Math.sin(angle) * t.r * 0.6;
                            const x2 = Math.cos(angle) * t.r * 1.2;
                            const y2 = Math.sin(angle) * t.r * 1.2;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }

                        // Icicle shards protruding from edges
                        const frostPulse = 0.85 + 0.15 * Math.sin(time * 3);
                        ctx.globalAlpha = 0.6 * frostPulse;
                        const icicleCount = 8;
                        for (let i = 0; i < icicleCount; i++) {
                            const angle = (i / icicleCount) * Math.PI * 2 + time * 0.5;
                            const baseX = Math.cos(angle) * t.r * 1.3;
                            const baseY = Math.sin(angle) * t.r * 1.3;
                            const tipX = Math.cos(angle) * t.r * 1.6;
                            const tipY = Math.sin(angle) * t.r * 1.6;
                            const perpAngle = angle + Math.PI / 2;
                            const width = t.r * 0.08;
                            
                            // Draw icicle as triangle
                            ctx.fillStyle = 'rgba(200, 230, 255, 0.7)';
                            ctx.beginPath();
                            ctx.moveTo(tipX, tipY);
                            ctx.lineTo(baseX + Math.cos(perpAngle) * width, baseY + Math.sin(perpAngle) * width);
                            ctx.lineTo(baseX - Math.cos(perpAngle) * width, baseY - Math.sin(perpAngle) * width);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Bright tip highlight
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.beginPath();
                            ctx.arc(tipX, tipY, width * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    ctx.restore();
                }
                
                // Add poison bubble orbit effect to bosses (green circles)
                if (t.poisonStacks && t.poisonStacks > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    const bubbleCount = 4 + (t.poisonStacks * 2);
                    const time = performance.now() / 1000;
                    for (let i = 0; i < bubbleCount; i++) {
                        const angle = (i / bubbleCount) * Math.PI * 2 + time;
                        const radius = t.r * (1.2 + Math.sin(time * 2 + i) * 0.3);
                        const bubbleX = Math.cos(angle) * radius;
                        const bubbleY = Math.sin(angle) * radius;
                        const bubbleSize = 2 + Math.sin(time * 3 + i) * 1.5;
                        ctx.fillStyle = '#00ff66';
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
                
                ctx.restore();
            }

            function drawShip(t, e, player) {
                let mainColor = '#b266ff', accentColor1 = '#7a49cc', accentColor2 = '#4d2a80',
                    wingStrokeColor = '#c49cff', engineColor = '#cc99ff';

                switch (player.subclass) {
                    case 'juggernaut':
                        mainColor = '#ff3333'; accentColor1 = '#cc0000'; accentColor2 = '#990000';
                        wingStrokeColor = '#ff6666'; engineColor = '#ffaaaa';
                        break;
                    case 'marauder':
                        mainColor = '#33cc33'; accentColor1 = '#009900'; accentColor2 = '#006600';
                        wingStrokeColor = '#66ff66'; engineColor = '#aaffaa';
                        break;
                    case 'demolitioner':
                        mainColor = '#ffcc00'; accentColor1 = '#ffaa00'; accentColor2 = '#cc8800';
                        wingStrokeColor = '#ffeeaa'; engineColor = '#ffffcc';
                        break;
                    case 'railgunner':
                        mainColor = '#9933ff'; accentColor1 = '#6600cc'; accentColor2 = '#440088';
                        wingStrokeColor = '#cc99ff'; engineColor = '#e6ccff';
                        break;
                    case 'phasestriker':
                        mainColor = '#ff69b4'; accentColor1 = '#ff1493'; accentColor2 = '#c71585';
                        wingStrokeColor = '#ffb6c1'; engineColor = '#ffc0cb';
                        break;
                    case 'stormbringer':
                        mainColor = '#00bfff'; accentColor1 = '#1e90ff'; accentColor2 = '#0000cd';
                        wingStrokeColor = '#87cefa'; engineColor = '#add8e6';
                        break;
                }

                drawEntityShadow(t, e, 22, 8, { alpha: 0.35, yOffset: 18 });

                ctx.save();
                ctx.translate(t, e);
                if (player.isInvincible || player.hasShieldBubble) {
                    ctx.beginPath(); ctx.arc(0, 0, 24, 0, 2 * Math.PI);
                    const g = ctx.createRadialGradient(0, 0, 18, 0, 0, 24);
                    g.addColorStop(0, "#9a66ff11"); g.addColorStop(1, "#9a66ff");
                    ctx.fillStyle = g; ctx.fill()
                }
                ctx.beginPath();
                ctx.moveTo(0, -20); ctx.lineTo(12, 8); ctx.lineTo(8, 14); ctx.lineTo(0, 10); ctx.lineTo(-8, 14); ctx.lineTo(-12, 8);
                ctx.closePath();
                const o = ctx.createLinearGradient(0, -20, 0, 14);
                o.addColorStop(0, mainColor); o.addColorStop(.5, accentColor1); o.addColorStop(1, accentColor2);
                ctx.fillStyle = o; ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = wingStrokeColor; ctx.stroke();
                ctx.strokeStyle = mainColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-12, 5); ctx.lineTo(-20, -2); ctx.lineTo(-18, 8); ctx.moveTo(12, 5); ctx.lineTo(20, -2); ctx.lineTo(18, 8); ctx.stroke();
                const r = performance.now() / 1e3;
                ctx.globalAlpha = .8 + .2 * Math.sin(10 * r);
                ctx.fillStyle = engineColor;
                ctx.beginPath(); ctx.ellipse(-5, 16, 3, 6, 0, 0, 2 * Math.PI); ctx.ellipse(5, 16, 3, 6, 0, 0, 2 * Math.PI); ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(0, -8, 3, 0, 2 * Math.PI); ctx.fill();

                const time = performance.now() / 1000;

                // Draw beef shield bubble if pilot is beef and shield is active
                if (player.pilotGenome === 'beef' && Number.isFinite(player.beefShield) && player.beefShield > 0 && Number.isFinite(player.beefShieldMax) && player.beefShieldMax > 0) {
                    const shieldPercent = player.beefShield / player.beefShieldMax;
                    const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 2.5);

                    // Base radius scales with shield level (8px minimum, up to 30px at full shield)
                    const baseRadius = 8 + (22 * shieldPercent); // 8px at 0%, 30px at 100%
                    // Add wobbling effect on top of the scaled base
                    const wobbleAmount = 4 * shieldPercent; // Wobble gets stronger as shield grows
                    const shieldRadius = baseRadius + wobbleAmount * Math.sin(time * 3);

                    // Create void power shield gradient (dark purple/black energy)
                    const shieldGradient = ctx.createRadialGradient(0, 0, shieldRadius * 0.2, 0, 0, shieldRadius);
                    shieldGradient.addColorStop(0, `rgba(75, 0, 130, ${0.8 * shieldPercent})`); // Dark purple core (increased opacity)
                    shieldGradient.addColorStop(0.4, `rgba(25, 25, 112, ${0.6 * shieldPercent * pulseIntensity})`); // Midnight blue (increased)
                    shieldGradient.addColorStop(0.7, `rgba(72, 61, 139, ${0.7 * shieldPercent})`); // Dark slate blue (increased)
                    shieldGradient.addColorStop(1, `rgba(138, 43, 226, ${0.5 * shieldPercent})`); // Purple edge (was black, now purple)

                    ctx.beginPath();
                    ctx.arc(0, 0, shieldRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = shieldGradient;
                    ctx.fill();

                    // Add void energy sparkles
                    ctx.strokeStyle = `rgba(138, 43, 226, ${0.9 * shieldPercent * pulseIntensity})`; // Blue violet sparkles (increased opacity)
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset line dash

                    // Add inner void energy core
                    if (shieldPercent > 0.2) {
                        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shieldRadius * 0.3);
                        coreGradient.addColorStop(0, `rgba(147, 0, 211, ${0.6 * shieldPercent})`); // Dark violet (increased)
                        coreGradient.addColorStop(1, `rgba(75, 0, 130, ${0.3 * shieldPercent})`); // (increased)
                        ctx.fillStyle = coreGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, shieldRadius * 0.3 * Math.abs(Math.sin(time * 4)), 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }

                // Draw universal health and shield meters above ship for all pilots
                const meterWidth = 55;
                const meterHeight = 3;
                const meterSpacing = 6;
                const cornerRadius = 1.5;
                let meterY = -35;

                // Helper function for rounded rectangles
                const drawRoundedRect = (x, y, width, height, radius, fill = true, stroke = false) => {
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                    if (fill) ctx.fill();
                    if (stroke) ctx.stroke();
                };

                // Health bar (always visible)
                const healthPercent = player.hp / player.hpMax;

                // Health bar background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius);

                // Health bar fill
                if (healthPercent > 0) {
                    const healthGradient = ctx.createLinearGradient(-meterWidth / 2, meterY, meterWidth / 2, meterY);
                    if (healthPercent > 0.6) {
                        healthGradient.addColorStop(0, 'rgba(50, 205, 50, 0.8)'); // Lime green
                        healthGradient.addColorStop(1, 'rgba(34, 139, 34, 0.8)'); // Forest green
                    } else if (healthPercent > 0.3) {
                        healthGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)'); // Orange
                        healthGradient.addColorStop(1, 'rgba(255, 140, 0, 0.8)'); // Dark orange
                    } else {
                        healthGradient.addColorStop(0, 'rgba(255, 69, 0, 0.8)'); // Red orange
                        healthGradient.addColorStop(1, 'rgba(178, 34, 34, 0.8)'); // Fire brick red
                    }

                    ctx.fillStyle = healthGradient;
                    drawRoundedRect(-meterWidth / 2, meterY, meterWidth * healthPercent, meterHeight, cornerRadius);
                }

                // Health bar border
                ctx.strokeStyle = healthPercent > 0.6 ? 'rgba(50, 205, 50, 0.6)' :
                    healthPercent > 0.3 ? 'rgba(255, 165, 0, 0.6)' : 'rgba(255, 69, 0, 0.6)';
                ctx.lineWidth = 0.5;
                drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius, false, true);

                // Health text
                ctx.fillStyle = healthPercent > 0.6 ? 'rgba(50, 205, 50, 0.9)' :
                    healthPercent > 0.3 ? 'rgba(255, 165, 0, 0.9)' : 'rgba(255, 69, 0, 0.9)';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                const healthText = `${Math.round(player.hp)}/${Math.round(player.hpMax)}`;
                ctx.fillText(healthText, 0, meterY - 2);

                // Shield bars (show if any shield type exists)
                const hasRegularShield = player.shieldMax > 0;
                const hasBeefShield = player.pilotGenome === 'beef' && player.beefShieldMax > 0;

                if (hasRegularShield || hasBeefShield) {
                    meterY -= meterSpacing;

                    // Regular shield bar
                    if (hasRegularShield) {
                        const shieldPercent = player.shield / player.shieldMax;

                        // Shield bar background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius);

                        // Shield bar fill
                        if (shieldPercent > 0) {
                            const shieldGradient = ctx.createLinearGradient(-meterWidth / 2, meterY, meterWidth / 2, meterY);
                            shieldGradient.addColorStop(0, 'rgba(100, 149, 237, 0.8)'); // Cornflower blue
                            shieldGradient.addColorStop(1, 'rgba(65, 105, 225, 0.8)'); // Royal blue

                            ctx.fillStyle = shieldGradient;
                            drawRoundedRect(-meterWidth / 2, meterY, meterWidth * shieldPercent, meterHeight, cornerRadius);
                        }

                        // Shield bar border
                        ctx.strokeStyle = 'rgba(100, 149, 237, 0.6)';
                        ctx.lineWidth = 0.5;
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius, false, true);

                        // Shield text
                        ctx.fillStyle = 'rgba(100, 149, 237, 0.9)';
                        ctx.font = '8px monospace';
                        ctx.textAlign = 'center';
                        const shieldText = `${Math.round(player.shield)}/${Math.round(player.shieldMax)}`;
                        ctx.fillText(shieldText, 0, meterY - 2);

                        if (hasBeefShield) meterY -= meterSpacing;
                    }

                    // Beef shield bar
                    if (hasBeefShield) {
                        const beefShieldPercent = player.beefShield / player.beefShieldMax;

                        // Beef shield bar background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius);

                        // Beef shield bar fill
                        if (beefShieldPercent > 0) {
                            const beefShieldGradient = ctx.createLinearGradient(-meterWidth / 2, meterY, meterWidth / 2, meterY);
                            beefShieldGradient.addColorStop(0, 'rgba(75, 0, 130, 0.8)'); // Dark purple
                            beefShieldGradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.8)'); // Blue violet
                            beefShieldGradient.addColorStop(1, 'rgba(147, 0, 211, 0.8)'); // Dark violet

                            ctx.fillStyle = beefShieldGradient;
                            drawRoundedRect(-meterWidth / 2, meterY, meterWidth * beefShieldPercent, meterHeight, cornerRadius);
                        }

                        // Beef shield bar border
                        ctx.strokeStyle = 'rgba(138, 43, 226, 0.6)';
                        ctx.lineWidth = 0.5;
                        drawRoundedRect(-meterWidth / 2, meterY, meterWidth, meterHeight, cornerRadius, false, true);

                        // Beef shield text
                        ctx.fillStyle = 'rgba(138, 43, 226, 0.9)';
                        ctx.font = '8px monospace';
                        ctx.textAlign = 'center';
                        const beefShieldText = `${Math.round(player.beefShield)}/${Math.round(player.beefShieldMax)}`;
                        ctx.fillText(beefShieldText, 0, meterY - 2);
                    }
                }

                if (player.pilotGenome === 'rocketman' && player.hasFirewall) {
                    const flameCharge = Math.max(0, Math.min(1, player.flameWallCharge || 0));
                    const noseY = -20;
                    const tailY = 14;
                    const band = Math.max(0.04, 0.12 - flameCharge * 0.05);
                    const boundary = Math.max(0, Math.min(1, 1 - flameCharge));
                    const waveTime = performance.now() / 1000;

                    // Show afterburner indicators when active
                    if (player.afterburnerActive) {
                        const afterburnerProgress = 1 - (player.afterburnerTimer / player.afterburnerMaxDuration);
                        const glowIntensity = 0.3 + 0.7 * Math.sin(waveTime * 8);

                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';

                        // Left and right afterburner glows
                        for (let side = -1; side <= 1; side += 2) {
                            ctx.fillStyle = `rgba(255, 140, 20, ${glowIntensity * 0.4})`;
                            ctx.beginPath();
                            ctx.ellipse(side * 12, tailY + 6, 8, 12, 0, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = `rgba(255, 200, 60, ${glowIntensity * 0.6})`;
                            ctx.beginPath();
                            ctx.ellipse(side * 12, tailY + 6, 4, 8, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        ctx.restore();
                    }

                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();
                    ctx.clip();

                    const gradient = ctx.createLinearGradient(0, noseY, 0, tailY);
                    const yellowAlpha = 0.35 + flameCharge * 0.2;
                    const orangeAlpha = 0.25 + flameCharge * 0.45;
                    const yellow = `rgba(255, 210, 80, ${yellowAlpha})`;
                    const orange = `rgba(255, 110, 0, ${orangeAlpha})`;
                    const lowerCut = Math.max(0, boundary - band);
                    const upperCut = Math.min(1, boundary + band);

                    gradient.addColorStop(0, yellow);
                    gradient.addColorStop(lowerCut, yellow);
                    gradient.addColorStop(Math.max(lowerCut, boundary), orange);
                    gradient.addColorStop(upperCut, orange);
                    gradient.addColorStop(1, orange);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(-22, noseY - 2, 44, tailY - noseY + 4);

                    const shimmerOffset = Math.sin(waveTime * 3.1) * (8 + flameCharge * 10);
                    const shimmer = ctx.createLinearGradient(-14, noseY - 10 + shimmerOffset, 14, tailY + 4 - shimmerOffset);
                    shimmer.addColorStop(0, `rgba(255, 240, 180, ${0.04 + flameCharge * 0.12})`);
                    shimmer.addColorStop(0.5, `rgba(255, 190, 120, ${0.08 + flameCharge * 0.16})`);
                    shimmer.addColorStop(1, `rgba(255, 120, 40, ${0.05 + flameCharge * 0.14})`);

                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = shimmer;
                    ctx.fillRect(-20, noseY - 8, 40, tailY - noseY + 12);

                    ctx.restore();

                    ctx.save();
                    ctx.shadowColor = `rgba(255, 120, 0, ${0.4 + flameCharge * 0.4})`;
                    ctx.shadowBlur = 12 + flameCharge * 14;
                    ctx.strokeStyle = `rgba(255, 220, 120, ${0.3 + flameCharge * 0.5})`;
                    ctx.lineWidth = 1.2 + flameCharge;
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.restore();
                }

                // Rocketman flame pulse cooldown gradient timer (hourglass fill effect)
                if (player.pilotGenome === 'rocketman' && player.hasFirewall) {
                    const cooldownProgress = player.flamePulseCharge || 0; // 0 = empty, 1 = full/ready
                    
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();
                    ctx.clip();

                    // Create gradient that fills from bottom to top like an hourglass
                    const shipHeight = 34; // From nose (-20) to tail (14)
                    const shipTop = -20;
                    const shipBottom = 14;
                    const fillHeight = shipTop + (shipHeight * (1 - cooldownProgress)); // Fill from bottom up
                    
                    const gradient = ctx.createLinearGradient(0, shipBottom, 0, shipTop);
                    
                    // Filled portion (orange/red glow)
                    if (cooldownProgress < 1) {
                        gradient.addColorStop(0, 'rgba(255, 80, 0, 0.25)'); // Bottom (filled)
                        gradient.addColorStop(Math.max(0, cooldownProgress - 0.05), 'rgba(255, 120, 20, 0.3)');
                        gradient.addColorStop(Math.min(1, cooldownProgress), 'rgba(255, 180, 60, 0.15)'); // Fill line
                        gradient.addColorStop(Math.min(1, cooldownProgress + 0.05), 'rgba(0, 0, 0, 0)'); // Fade to transparent
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Top (empty)
                    } else {
                        // Fully charged - bright glow
                        gradient.addColorStop(0, 'rgba(255, 140, 0, 0.4)');
                        gradient.addColorStop(0.5, 'rgba(255, 180, 60, 0.35)');
                        gradient.addColorStop(1, 'rgba(255, 220, 100, 0.3)');
                    }

                    ctx.fillStyle = gradient;
                    ctx.fillRect(-22, shipTop - 2, 44, shipHeight + 4);

                    // Add pulsing effect when ready
                    if (cooldownProgress >= 1) {
                        const pulse = 0.5 + 0.5 * Math.sin(time * 4);
                        ctx.globalAlpha = pulse * 0.3;
                        ctx.fillStyle = 'rgba(255, 200, 80, 1)';
                        ctx.fillRect(-22, shipTop - 2, 44, shipHeight + 4);
                    }

                    ctx.restore();
                }

                if (player.hasRearGuard && player.rearGuardReady) {
                    const pulse = 0.4 + 0.3 * Math.sin(performance.now() / 200);
                    ctx.fillStyle = `rgba(100, 255, 255, ${pulse})`;
                    ctx.beginPath();
                    ctx.arc(0, 15, 8, 0, 2 * Math.PI);
                    ctx.fill();
                }

                ctx.restore();
            }

            function drawMine(m) {
                ctx.save();
                ctx.translate(m.x, m.y);
                const time = performance.now();
                const pulse = 0.8 + 0.2 * Math.sin(time / 150);
                const fuseRatio = m.fuse / 5;
                const color = `rgb(255, ${100 * fuseRatio}, ${80 * fuseRatio})`;

                ctx.beginPath();
                ctx.arc(0, 0, m.r * 1.5 * pulse, 0, 2 * Math.PI);
                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, m.r * 1.5 * pulse);
                grad.addColorStop(0, color + '99');
                grad.addColorStop(1, color + '00');
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.fillStyle = "#333";
                ctx.beginPath();
                ctx.arc(0, 0, m.r, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = "#555";
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, 0, m.r * 0.4 * pulse, 0, 2 * Math.PI);
                ctx.fill();

                ctx.restore();
            }
            const VOID_CHAMPION_SCHEME_BY_MODULE = Object.freeze({
                default: 'purple',
                ember: 'crimson',
                tempest: 'azure',
                void: 'purple'
            });

            const VOID_CHAMPION_COLOR_SCHEMES = {
                black: {
                    name: 'Shadow Wraith',
                    shadowColor: '#555555',
                    auraColor: '#1a1a1a',
                    hullGradient: ['#2a2a2a', '#000000', '#0f0f0f'],
                    strokeColor: '#666666',
                    finColor: [80, 80, 80],
                    visorGradient: ['#4d4d4d', '#1a1a1a'],
                    eyeColor: '#ff0000',
                    coreGlow: '#333333',
                    coreColor: '#cccccc',
                    thrusterColor: '#202020'
                },
                blue: {
                    name: 'Azure Phantom',
                    shadowColor: '#4488ff',
                    auraColor: '#0044cc',
                    hullGradient: ['#1144aa', '#001122', '#002244'],
                    strokeColor: '#66aaff',
                    finColor: [100, 150, 255],
                    visorGradient: ['#ccddff', '#0066cc'],
                    eyeColor: '#00ffff',
                    coreGlow: '#88bbff',
                    coreColor: '#ffffff',
                    thrusterColor: '#0088ff'
                },
                purple: {
                    name: 'Void Wraith',
                    shadowColor: '#b56bff',
                    auraColor: '#7a34ff',
                    hullGradient: ['#5f18c4', '#1b0635', '#320a63'],
                    strokeColor: '#c6a4ff',
                    finColor: [155, 69, 255],
                    visorGradient: ['#f5d9ff', '#7d2cff'],
                    eyeColor: '#ff508f',
                    coreGlow: '#e499ff',
                    coreColor: '#ffe6ff',
                    thrusterColor: '#732bff'
                },
                darkgold: {
                    name: 'Dark Gold Harbinger',
                    shadowColor: '#9b7a3d',
                    auraColor: '#6b5000',
                    hullGradient: ['#7a5c1a', '#2a1f00', '#4a3800'],
                    strokeColor: '#b8941f',
                    finColor: [180, 140, 50],
                    visorGradient: ['#d4b876', '#8a6500'],
                    eyeColor: '#ff6600',
                    coreGlow: '#b89f5a',
                    coreColor: '#ffe4a0',
                    thrusterColor: '#8a6b1a'
                }
            };

            function getVoidChampionColorScheme(enemy) {
                if (!enemy.colorScheme) {
                    const schemes = Object.keys(VOID_CHAMPION_COLOR_SCHEMES);
                    const seed = enemy.id || (enemy.x + enemy.y * 1000);
                    const schemeIndex = Math.abs(Math.floor(seed)) % schemes.length;
                    enemy.colorScheme = schemes[schemeIndex];
                    enemy.displayName = VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme].name;
                }
                return VOID_CHAMPION_COLOR_SCHEMES[enemy.colorScheme];
            }

            function drawEnemy(e) {
                // Skip drawing dead mechs entirely - PixiJS handles their cleanup
                if (e.dead && (e.type === 'mech' || e.type === 'mech_elite')) {
                    return;
                }
                
                const { x: t, y: o, r: a, type: r, color: n, hp: l, hpMax: s, t: c } = e;
                
                ctx.save();
                let drawX = t;
                let drawY = o;
                if (e.hitShakeTimer && e.hitShakeTimer > 0 && e.hitShakeIntensity) {
                    const baseDuration = e.hitShakeDuration || 0.16;
                    const ratio = baseDuration > 0 ? Math.max(0, Math.min(1, e.hitShakeTimer / baseDuration)) : 0;
                    const intensity = e.hitShakeIntensity * Math.pow(ratio, 0.6);
                    const phaseSeed = (e.id || 0) * 13.37;
                    const time = performance.now() * 0.006 + phaseSeed;
                    drawX += Math.sin(time) * intensity;
                    drawY += Math.cos(time * 1.6) * intensity * 0.7;
                }

                let flattenScaleY = 1;
                if (e.flattenScale !== undefined) {
                    if (typeof e.flattenScale === 'number') {
                        flattenScaleY = e.flattenScale;
                    } else if (e.flattenScale && Number.isFinite(e.flattenScale.y)) {
                        flattenScaleY = e.flattenScale.y;
                    }
                }

                const shadowRadiusX = Math.max(12, a * 1.25);
                const shadowRadiusY = Math.max(6, a * 0.5 * flattenScaleY);
                const shadowAlpha = Math.max(0.18, Math.min(0.4, 0.18 + a * 0.004));
                drawEntityShadow(drawX, drawY, shadowRadiusX, shadowRadiusY, {
                    alpha: shadowAlpha,
                    yOffset: Math.max(6, a * (0.85 * flattenScaleY + 0.35))
                });

                ctx.translate(drawX, drawY);
                const spawnAlpha = e.spawnOpacity !== undefined ? Math.max(0.2, Math.min(1, e.spawnOpacity)) : 1;
                ctx.globalAlpha *= spawnAlpha;

                if (e.fragmentBlastGoldTint && e.fragmentBlastSlowTimer && e.fragmentBlastSlowTimer > 0) {
                    ctx.save();
                    const pulseSeed = (e.id || 0) * 17.23;
                    const pulseStrength = 0.5 + 0.3 * Math.sin(performance.now() / 150 + pulseSeed);
                    const auraRadius = Math.max(22, a * 1.35);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha *= 0.35 * pulseStrength;

                    const goldGradient = ctx.createRadialGradient(0, 0, auraRadius * 0.3, 0, 0, auraRadius);
                    goldGradient.addColorStop(0, 'rgba(255, 250, 205, 0.85)');
                    goldGradient.addColorStop(0.5, 'rgba(252, 246, 186, 0.5)');
                    goldGradient.addColorStop(1, 'rgba(191, 149, 63, 0)');
                    ctx.fillStyle = goldGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = 0.4 * pulseStrength;
                    ctx.strokeStyle = '#FFFACD';
                    ctx.lineWidth = Math.max(1.5, a * 0.08);
                    ctx.beginPath();
                    ctx.arc(0, 0, auraRadius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                }
                
                // Apply stealth alpha for Obsidian Reapers gang
                if (e.type === 'hunter' && e.isStealthed && e.stealthAlpha !== undefined) {
                    ctx.globalAlpha *= e.stealthAlpha;
                }
                
                if (e.spawnPhase === 'teleport') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const time = performance.now() / 200;
                    const ringRadius = (a + 8) * (0.9 + 0.05 * Math.sin(time + (e.spawnClusterIndex || 0)));
                    const ringAlpha = 0.35 + 0.25 * spawnAlpha;
                    ctx.globalAlpha = ringAlpha;
                    ctx.strokeStyle = e.spawnEffectColor || '#9ad7ff';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = ringAlpha * 0.7;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius * 0.65, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Cube Burglar empowerment visual effect
                if (e.cubeBurglarAuraGlow && e.cubeBurglarAuraGlow > 0 && e.type !== 'cube_burglar') {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    const glowTime = performance.now() / 1000;
                    const glowPulse = 0.6 + 0.4 * Math.sin(glowTime * 3.5 + (e.id || 0) * 0.1);
                    const glowIntensity = e.cubeBurglarAuraGlow * glowPulse;
                    
                    // Outer glow ring
                    ctx.globalAlpha = 0.3 * glowIntensity;
                    ctx.strokeStyle = '#ff6ad5';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner glow ring
                    ctx.globalAlpha = 0.5 * glowIntensity;
                    ctx.strokeStyle = '#ff9de5';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Filled aura
                    const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.4);
                    auraGradient.addColorStop(0, 'rgba(255, 106, 213, 0.25)');
                    auraGradient.addColorStop(0.5, 'rgba(255, 106, 213, 0.12)');
                    auraGradient.addColorStop(1, 'rgba(255, 106, 213, 0)');
                    ctx.globalAlpha = 0.6 * glowIntensity;
                    ctx.fillStyle = auraGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * 1.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // Apply flattening effect if enemy has flattenScale property
                if (e.flattenScale != null) {
                    if (typeof e.flattenScale === 'number') {
                        ctx.scale(1, e.flattenScale);
                    } else {
                        ctx.scale(e.flattenScale.x || 1, e.flattenScale.y || 1);
                    }
                }
                l < s && l > 0 && (ctx.fillStyle = 'rgba(0,0,0,0.5)', ctx.fillRect(-a, -a - 8, 2 * a, 3), ctx.fillStyle = "#b266ff", ctx.fillRect(-a, -a - 8, 2 * a * (l / s), 3)); ctx.lineWidth = 2; ctx.beginPath(); switch (r) {
                    case "cube_burglar":
                        drawCubeBurglar(e);
                        break;
                    case "avian_hatchling": ctx.fillStyle = n + "aa"; ctx.strokeStyle = n; ctx.lineWidth = 2; ctx.moveTo(0, -a * 1.2); ctx.lineTo(a, -a * 0.5); ctx.lineTo(a, a * 0.5); ctx.lineTo(0, a * 1.2); ctx.lineTo(-a, a * 0.5); ctx.lineTo(-a, -a * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); break; case "construct_gold": ctx.fillStyle = n + "aa"; ctx.strokeStyle = n; ctx.lineWidth = 2; ctx.moveTo(0, -a); ctx.lineTo(a, 0); ctx.lineTo(0, a); ctx.lineTo(-a, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); break; case "trap_king_add": case "drone": const droneGradient = ctx.createLinearGradient(-a, -a, a, a); droneGradient.addColorStop(0, "#E0E0E0"); droneGradient.addColorStop(1, "#A0A0A0"); ctx.fillStyle = droneGradient; ctx.strokeStyle = "#808080"; ctx.beginPath(); ctx.moveTo(-1.2 * a, 0); ctx.quadraticCurveTo(0, -a, 1.2 * a, 0); ctx.quadraticCurveTo(0, .6 * a, -1.2 * a, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#aaddff"; ctx.strokeStyle = "#FFFFFF"; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, -.2 * a, .6 * a, Math.PI, 0); ctx.fill(); ctx.stroke(); ctx.fillStyle = r === "trap_king_add" ? "#ffc83d" : "#32CD32"; ctx.beginPath(); ctx.ellipse(0, -.2 * a, .3 * a, .4 * a, 0, 0, 2 * Math.PI); ctx.fill(); ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.ellipse(-.1 * a, -.25 * a, .08 * a, .15 * a, -.5, 0, 2 * Math.PI); ctx.ellipse(.1 * a, -.25 * a, .08 * a, .15 * a, .5, 0, 2 * Math.PI); ctx.fill(); break;
                    case "hunter": {
                        const time = performance.now() / 1000;
                        const segments = 8;
                        const length = a * 2;
                        const amplitude = a * 0.5;

                        ctx.globalAlpha = 1;
                        ctx.shadowBlur = 0;
                        ctx.setLineDash([]);

                        // Get gang colors (default to Crimson if no gang assigned)
                        const gang = e.gang || HUNTER_GANGS.CRIMSON;
                        const bodyColor = gang.bodyColor;
                        const bodyStroke = gang.bodyStroke;
                        const headColor = gang.headColor;
                        const headbandColor = gang.headbandColor;
                        const eyeColor = gang.eyeColor;

                        const top = [];
                        const bottom = [];

                        for (let i = 0; i <= segments; i++) {
                            const progress = i / segments;
                            const width = a * Math.sin(progress * Math.PI) * 0.4;
                            const x = Math.sin(progress * 2 * Math.PI + c * 4) * amplitude;
                            const y = (progress - 0.5) * length;
                            top.push({ x: x + width, y });
                            bottom.push({ x: x - width, y });
                        }

                        // Draw body with gang colors
                        ctx.fillStyle = bodyColor;
                        ctx.strokeStyle = bodyStroke;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(top[0].x, top[0].y);
                        for (let i = 1; i < top.length; i++) ctx.lineTo(top[i].x, top[i].y);
                        for (let i = bottom.length - 1; i >= 0; i--) ctx.lineTo(bottom[i].x, bottom[i].y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        const headX = Math.sin(c * 4) * amplitude;
                        const headY = -0.5 * length;

                        // Draw head
                        ctx.fillStyle = headColor;
                        ctx.strokeStyle = bodyStroke;
                        ctx.beginPath();
                        ctx.arc(headX, headY, a * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();

                        // Draw headband
                        ctx.fillStyle = headbandColor;
                        ctx.strokeStyle = bodyStroke;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        // Headband wraps around top of head
                        ctx.ellipse(headX, headY - a * 0.15, a * 0.36, a * 0.12, 0, Math.PI, 0);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Headband knot/tail on side
                        ctx.fillStyle = headbandColor;
                        ctx.beginPath();
                        ctx.moveTo(headX + a * 0.32, headY - a * 0.15);
                        ctx.lineTo(headX + a * 0.52, headY - a * 0.2);
                        ctx.lineTo(headX + a * 0.48, headY - a * 0.1);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        // Draw eyes
                        ctx.fillStyle = eyeColor;
                        const eyeOffsetX = a * 0.12;
                        const eyeOffsetY = a * 0.05;
                        const eyeRadius = a * 0.08;
                        ctx.beginPath();
                        ctx.arc(headX - eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                        ctx.arc(headX + eyeOffsetX, headY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Draw mouth
                        ctx.strokeStyle = bodyStroke;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(headX, headY + a * 0.1);
                        ctx.lineTo(headX, headY + a * 0.4);
                        ctx.stroke();

                        break;
                    }
                    case "zombie": {
                        // Cyberpunk zombie with glowing neon effects
                        const time = performance.now() / 1000;
                        const shamble = Math.sin(c * 3) * 0.15; // Shambling animation
                        
                        // Glowing aura
                        ctx.save();
                        ctx.globalAlpha = 0.3 + 0.2 * Math.sin(time * 4);
                        const auraGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.4);
                        auraGrad.addColorStop(0, '#00ff88');
                        auraGrad.addColorStop(1, 'rgba(0, 255, 136, 0)');
                        ctx.fillStyle = auraGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                        
                        // Body - rounded rectangle with decay
                        ctx.fillStyle = '#1a4d3a';
                        ctx.strokeStyle = n;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.roundRect(-a * 0.7, -a * 0.4, a * 1.4, a * 1.6, a * 0.2);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Cybernetic implants/circuits
                        ctx.strokeStyle = n;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.5, -a * 0.2);
                        ctx.lineTo(a * 0.5, -a * 0.2);
                        ctx.moveTo(-a * 0.3, 0);
                        ctx.lineTo(a * 0.3, 0);
                        ctx.moveTo(-a * 0.4, a * 0.3);
                        ctx.lineTo(a * 0.4, a * 0.3);
                        ctx.stroke();
                        
                        // Head - slightly offset from shambling
                        ctx.save();
                        ctx.translate(shamble * a * 0.3, -a * 0.8);
                        
                        ctx.fillStyle = '#2a5d4a';
                        ctx.strokeStyle = n;
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Glowing cyber-eyes
                        ctx.fillStyle = n;
                        ctx.shadowColor = n;
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(-a * 0.2, -a * 0.1, a * 0.12, 0, Math.PI * 2);
                        ctx.arc(a * 0.2, -a * 0.1, a * 0.12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        // Stitched mouth
                        ctx.strokeStyle = n;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.25, a * 0.2);
                        ctx.lineTo(a * 0.25, a * 0.2);
                        ctx.stroke();
                        
                        // Stitches
                        ctx.lineWidth = 1;
                        for (let i = -2; i <= 2; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * a * 0.1, a * 0.15);
                            ctx.lineTo(i * a * 0.1, a * 0.25);
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                        
                        // Shambling arms
                        ctx.strokeStyle = n;
                        ctx.lineWidth = 3;
                        
                        // Left arm
                        ctx.save();
                        ctx.translate(-a * 0.7, -a * 0.2);
                        ctx.rotate(shamble + 0.3);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, a * 0.9);
                        ctx.stroke();
                        ctx.restore();
                        
                        // Right arm
                        ctx.save();
                        ctx.translate(a * 0.7, -a * 0.2);
                        ctx.rotate(-shamble - 0.3);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, a * 0.9);
                        ctx.stroke();
                        ctx.restore();
                        
                        break;
                    }
                    case "phantom":
                        ctx.globalAlpha = .6 + .4 * Math.sin(5 * c); ctx.strokeStyle = n; ctx.fillStyle = n + "99"; ctx.moveTo(0, -.8 * a); ctx.quadraticCurveTo(a, -.5 * a, .8 * a, .8 * a); ctx.quadraticCurveTo(0, .5 * a, -.8 * a, .8 * a); ctx.quadraticCurveTo(-a, -.5 * a, 0, -.8 * a); ctx.closePath(); ctx.fill(); ctx.stroke(); for (let e = -1; e <= 1; e++)ctx.beginPath(), ctx.moveTo(e * .4 * a, .6 * a), ctx.quadraticCurveTo(e * .5 * a, a, e * .3 * a + 2 * Math.sin(4 * c + e), 1.2 * a), ctx.stroke(); break;
                    case "mech":
                    case "mech_elite":
                        // Use PixiJS rendering for hardware acceleration
                        if (pixiApp) {
                            drawMechPixi(e);
                        }
                        // No canvas fallback needed - PixiJS required for this game
                        
                        // IMPORTANT: Don't break early - need to render ice/fire/poison effects on canvas
                        // The status effect rendering is at the end of drawEnemy function
                        // So we continue execution to apply overlays
                        break;
                    case "shadow_champion": {
                        const time = performance.now() / 1000;
                        const pulse = 0.8 + 0.2 * Math.sin(time * 5 + c * 3);
                        const swirl = c * 6;

                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.25 * pulse;
                        ctx.fillStyle = '#8f9bff';
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.45, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.globalCompositeOperation = 'source-over';
                        ctx.globalAlpha = 1;

                        const bodyGradient = ctx.createLinearGradient(0, -a * 1.2, 0, a * 1.1);
                        bodyGradient.addColorStop(0, '#eef1ff');
                        bodyGradient.addColorStop(0.55, '#cbd4ff');
                        bodyGradient.addColorStop(1, '#7a80d4');
                        ctx.fillStyle = bodyGradient;
                        ctx.strokeStyle = '#4f55b7';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -a * 1.05);
                        ctx.quadraticCurveTo(a * 0.95, -a * 0.05, a * 0.5, a * 0.95);
                        ctx.lineTo(-a * 0.5, a * 0.95);
                        ctx.quadraticCurveTo(-a * 0.95, -a * 0.05, 0, -a * 1.05);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#191a33';
                        ctx.beginPath();
                        ctx.ellipse(0, -a * 0.25, a * 0.52, a * 0.34, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = '#7b86ff';
                        ctx.beginPath();
                        ctx.ellipse(0, -a * 0.22, a * 0.45, a * 0.18, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.save();
                        ctx.rotate(swirl);
                        for (let i = 0; i < 4; i++) {
                            ctx.beginPath();
                            ctx.moveTo(0, a * 0.2);
                            ctx.lineTo(0, a * 1.3);
                            ctx.stroke();
                            ctx.rotate(Math.PI / 2);
                        }
                        ctx.restore();

                        ctx.fillStyle = 'rgba(139, 149, 255, 0.45)';
                        ctx.beginPath();
                        ctx.arc(0, a * 0.35, a * 0.42, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.restore();
                        break;
                    }
                    case "void_champion": {
                        const time = performance.now() / 1000;
                        const shimmer = 0.55 + 0.45 * Math.sin(time * 6 + c * 3);
                        const wingPulse = 0.8 + 0.2 * Math.sin(time * 5 + c * 2);
                        const breathe = 0.92 + 0.08 * Math.sin(time * 3);

                        // Get color scheme for this specific enemy
                        const colors = getVoidChampionColorScheme(e);
                        const scheme = e.colorScheme || 'purple';

                        ctx.save();
                        ctx.shadowColor = colors.shadowColor;
                        ctx.shadowBlur = 12 * shimmer;

                        // Outer aura/energy field
                        ctx.globalAlpha = 0.35 * shimmer;
                        ctx.fillStyle = colors.auraColor;
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;

                        // Draw based on scheme - each gets unique shape
                        if (scheme === 'crimson') {
                            // CRIMSON REAPER - Demonic berserker with horns and spikes
                            ctx.shadowBlur = 15 * shimmer;
                            
                            // Spiked armor plating
                            const plateGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.3);
                            plateGrad.addColorStop(0, colors.hullGradient[0]);
                            plateGrad.addColorStop(0.6, colors.hullGradient[1]);
                            plateGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = plateGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.5;
                            
                            // Bulky armored body
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 1.3);
                            ctx.lineTo(a * 0.95, -a * 0.2);
                            ctx.lineTo(a * 0.85, a * 0.6);
                            ctx.lineTo(a * 0.5, a * 1.15);
                            ctx.lineTo(0, a * 0.95);
                            ctx.lineTo(-a * 0.5, a * 1.15);
                            ctx.lineTo(-a * 0.85, a * 0.6);
                            ctx.lineTo(-a * 0.95, -a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Demonic horns
                            ctx.fillStyle = colors.strokeColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.5, -a * 1.1);
                            ctx.quadraticCurveTo(-a * 0.9, -a * 1.5, -a * 0.7, -a * 1.7);
                            ctx.lineTo(-a * 0.6, -a * 1.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 0.5, -a * 1.1);
                            ctx.quadraticCurveTo(a * 0.9, -a * 1.5, a * 0.7, -a * 1.7);
                            ctx.lineTo(a * 0.6, -a * 1.4);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Shoulder spikes
                            for (let spike of [[-1.1, -0.1], [1.1, -0.1], [-0.95, 0.3], [0.95, 0.3]]) {
                                ctx.fillStyle = colors.thrusterColor;
                                ctx.beginPath();
                                ctx.moveTo(a * spike[0], a * spike[1]);
                                ctx.lineTo(a * spike[0] * 1.4, a * spike[1]);
                                ctx.lineTo(a * spike[0] * 1.15, a * (spike[1] + 0.2));
                                ctx.closePath();
                                ctx.fill();
                            }
                            
                            // Glowing eyes
                            ctx.shadowBlur = 20;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.fillRect(-a * 0.35, -a * 0.65, a * 0.2, a * 0.12);
                            ctx.fillRect(a * 0.15, -a * 0.65, a * 0.2, a * 0.12);
                            
                            // Molten core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 18 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.arc(0, a * 0.25, a * 0.45 * breathe, 0, Math.PI * 2);
                            ctx.fill();
                            
                        } else if (scheme === 'azure') {
                            // AZURE PHANTOM - Sleek energy being with crystalline features
                            ctx.shadowBlur = 14 * shimmer;
                            
                            // Streamlined crystal body
                            const crystalGrad = ctx.createLinearGradient(-a, -a * 1.2, a, a * 1.2);
                            crystalGrad.addColorStop(0, colors.hullGradient[0]);
                            crystalGrad.addColorStop(0.5, colors.strokeColor);
                            crystalGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = crystalGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2;
                            
                            // Diamond-like hull
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 1.4);
                            ctx.lineTo(a * 0.65, -a * 0.3);
                            ctx.lineTo(a * 0.75, a * 0.4);
                            ctx.lineTo(a * 0.3, a * 1.2);
                            ctx.lineTo(0, a * 0.9);
                            ctx.lineTo(-a * 0.3, a * 1.2);
                            ctx.lineTo(-a * 0.75, a * 0.4);
                            ctx.lineTo(-a * 0.65, -a * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Energy wings
                            ctx.globalAlpha = 0.6 + 0.3 * wingPulse;
                            ctx.fillStyle = colors.auraColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.7, -a * 0.2);
                            ctx.quadraticCurveTo(-a * 1.6 * wingPulse, 0, -a * 0.8, a * 0.6);
                            ctx.lineTo(-a * 0.5, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 0.7, -a * 0.2);
                            ctx.quadraticCurveTo(a * 1.6 * wingPulse, 0, a * 0.8, a * 0.6);
                            ctx.lineTo(a * 0.5, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                            
                            // Visor with data streams
                            ctx.fillStyle = colors.visorGradient[0];
                            ctx.beginPath();
                            ctx.ellipse(0, -a * 0.6, a * 0.45, a * 0.25, 0, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Cyan eyes
                            ctx.shadowBlur = 16;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.beginPath();
                            ctx.arc(-a * 0.22, -a * 0.6, a * 0.1, 0, Math.PI * 2);
                            ctx.arc(a * 0.22, -a * 0.6, a * 0.1, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Pulsing energy core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 20 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.ellipse(0, a * 0.1, a * 0.35, a * 0.5 * breathe, 0, 0, Math.PI * 2);
                            ctx.fill();
                            
                        } else if (scheme === 'emerald') {
                            // EMERALD SPECTER - Bio-organic fusion with tendrils
                            ctx.shadowBlur = 13 * shimmer;
                            
                            // Organic carapace
                            const bioGrad = ctx.createRadialGradient(0, -a * 0.3, 0, 0, 0, a * 1.4);
                            bioGrad.addColorStop(0, colors.hullGradient[0]);
                            bioGrad.addColorStop(0.5, colors.hullGradient[1]);
                            bioGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = bioGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.2;
                            
                            // Segmented body
                            ctx.beginPath();
                            ctx.ellipse(0, -a * 0.5, a * 0.75, a * 0.85, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.ellipse(0, a * 0.4, a * 0.85, a * 0.8, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                            
                            // Writhing tendrils
                            ctx.lineCap = 'round';
                            ctx.lineWidth = a * 0.15;
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2;
                                const wave = Math.sin(time * 4 + i) * 0.3;
                                ctx.strokeStyle = colors.finColor[0] > 100 ? `rgba(${colors.finColor[0]}, ${colors.finColor[1]}, ${colors.finColor[2]}, 0.7)` : colors.auraColor;
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(angle) * a * 0.8, Math.sin(angle) * a * 0.6);
                                ctx.quadraticCurveTo(
                                    Math.cos(angle + wave) * a * 1.3,
                                    Math.sin(angle + wave) * a * 1,
                                    Math.cos(angle + wave * 1.5) * a * 1.6,
                                    Math.sin(angle + wave * 1.5) * a * 1.3
                                );
                                ctx.stroke();
                            }
                            ctx.lineCap = 'butt';
                            
                            // Insectoid eyes
                            ctx.shadowBlur = 14;
                            ctx.fillStyle = colors.eyeColor;
                            for (let eye of [[-0.3, -0.6], [-0.15, -0.65], [0.15, -0.65], [0.3, -0.6]]) {
                                ctx.beginPath();
                                ctx.arc(a * eye[0], a * eye[1], a * 0.08, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // Bio core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 16 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.arc(0, a * 0.05, a * 0.38 * breathe, 0, Math.PI * 2);
                            ctx.fill();
                            
                        } else if (scheme === 'golden') {
                            // GOLDEN HARBINGER - Ancient artifact with geometric patterns
                            ctx.shadowBlur = 18 * shimmer;
                            
                            // Ornate plated armor
                            const goldenGrad = ctx.createLinearGradient(0, -a * 1.4, 0, a * 1.2);
                            goldenGrad.addColorStop(0, colors.strokeColor);
                            goldenGrad.addColorStop(0.3, colors.hullGradient[0]);
                            goldenGrad.addColorStop(0.7, colors.hullGradient[1]);
                            goldenGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = goldenGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.8;
                            
                            // Hexagonal core body
                            ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                                const x = Math.cos(angle) * a * 0.9;
                                const y = Math.sin(angle) * a * 0.9;
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Ornate crown
                            ctx.fillStyle = colors.strokeColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.6, -a * 0.9);
                            ctx.lineTo(-a * 0.5, -a * 1.5);
                            ctx.lineTo(-a * 0.3, -a * 1.0);
                            ctx.lineTo(0, -a * 1.6);
                            ctx.lineTo(a * 0.3, -a * 1.0);
                            ctx.lineTo(a * 0.5, -a * 1.5);
                            ctx.lineTo(a * 0.6, -a * 0.9);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Geometric shoulders
                            ctx.fillStyle = colors.thrusterColor;
                            ctx.beginPath();
                            ctx.moveTo(-a * 1.1, -a * 0.3);
                            ctx.lineTo(-a * 1.4, -a * 0.1);
                            ctx.lineTo(-a * 1.3, a * 0.3);
                            ctx.lineTo(-a * 0.9, a * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 1.1, -a * 0.3);
                            ctx.lineTo(a * 1.4, -a * 0.1);
                            ctx.lineTo(a * 1.3, a * 0.3);
                            ctx.lineTo(a * 0.9, a * 0.4);
                            ctx.closePath();
                            ctx.fill();
                            
                            // Regal eyes
                            ctx.shadowBlur = 20;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.fillRect(-a * 0.3, -a * 0.5, a * 0.15, a * 0.2);
                            ctx.fillRect(a * 0.15, -a * 0.5, a * 0.15, a * 0.2);
                            
                            // Sacred relic core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 22 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 0.15);
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const radius = (i % 2 === 0 ? 0.5 : 0.35) * breathe;
                                ctx.lineTo(Math.cos(angle) * a * radius, Math.sin(angle) * a * radius);
                            }
                            ctx.closePath();
                            ctx.fill();
                            
                        } else {
                            // VOID WRAITH (purple/default) - Classic void champion with ethereal features
                            ctx.shadowBlur = 12 * shimmer;
                            
                            // Ethereal hull
                            const voidGrad = ctx.createLinearGradient(0, -a * 1.3, 0, a * 1.1);
                            voidGrad.addColorStop(0, colors.hullGradient[0]);
                            voidGrad.addColorStop(0.45, colors.hullGradient[1]);
                            voidGrad.addColorStop(1, colors.hullGradient[2]);
                            ctx.fillStyle = voidGrad;
                            ctx.strokeStyle = colors.strokeColor;
                            ctx.lineWidth = 2.2;
                            
                            // Wraith-like body
                            ctx.beginPath();
                            ctx.moveTo(0, -a * 1.25);
                            ctx.lineTo(a * 0.85, a * 0.25);
                            ctx.lineTo(a * 0.4, a * 1.15);
                            ctx.lineTo(0, a * 0.95);
                            ctx.lineTo(-a * 0.4, a * 1.15);
                            ctx.lineTo(-a * 0.85, a * 0.25);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            // Flowing void tendrils
                            ctx.globalAlpha = 0.5 + 0.4 * wingPulse;
                            ctx.fillStyle = `rgba(${colors.finColor[0]}, ${colors.finColor[1]}, ${colors.finColor[2]}, 0.7)`;
                            ctx.beginPath();
                            ctx.moveTo(-a * 1.05, -a * 0.05);
                            ctx.quadraticCurveTo(-a * 1.5 * wingPulse, a * 0.35, -a * 0.55, a * 0.65);
                            ctx.lineTo(-a * 0.4, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.beginPath();
                            ctx.moveTo(a * 1.05, -a * 0.05);
                            ctx.quadraticCurveTo(a * 1.5 * wingPulse, a * 0.35, a * 0.55, a * 0.65);
                            ctx.lineTo(a * 0.4, a * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.globalAlpha = 1;
                            
                            // Void visor
                            const visorGrad = ctx.createLinearGradient(0, -a * 0.8, 0, -a * 0.2);
                            visorGrad.addColorStop(0, colors.visorGradient[0]);
                            visorGrad.addColorStop(1, colors.visorGradient[1]);
                            ctx.fillStyle = visorGrad;
                            ctx.beginPath();
                            ctx.moveTo(-a * 0.5, -a * 0.5);
                            ctx.quadraticCurveTo(0, -a * 1, a * 0.5, -a * 0.5);
                            ctx.quadraticCurveTo(0, -a * 0.2, -a * 0.5, -a * 0.5);
                            ctx.fill();
                            
                            // Piercing eyes
                            ctx.shadowBlur = 16;
                            ctx.fillStyle = colors.eyeColor;
                            ctx.beginPath();
                            ctx.ellipse(-a * 0.2, -a * 0.6, a * 0.12, a * 0.09, -0.3, 0, Math.PI * 2);
                            ctx.ellipse(a * 0.2, -a * 0.6, a * 0.12, a * 0.09, 0.3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Void core
                            ctx.shadowColor = colors.coreGlow;
                            ctx.shadowBlur = 16 * breathe;
                            ctx.fillStyle = colors.coreColor;
                            ctx.beginPath();
                            ctx.arc(0, a * 0.2, a * (0.4 + 0.08 * breathe), 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Thruster flames (all variants)
                        ctx.shadowBlur = 10 * shimmer;
                        ctx.globalAlpha = 0.85;
                        ctx.fillStyle = colors.thrusterColor;
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.35, a * 1.0);
                        ctx.lineTo(0, a * (1.5 + 0.25 * shimmer));
                        ctx.lineTo(a * 0.35, a * 1.0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.globalAlpha = 1;
                        
                        ctx.restore();
                        break;
                    }
                    case "void_champion_orb": {
                        const time = performance.now() / 1000;
                        const flicker = 0.6 + 0.4 * Math.sin(time * 10 + c * 8);
                        const pulse = 0.85 + 0.15 * Math.sin(time * 7 + c * 5);
                        const radius = a * pulse;
                        
                        // Draw energy tether to parent champion
                        let orbitTarget = null;
                        if (e.orbitTargetId) {
                            orbitTarget = store.enemies.find(en => en.id === e.orbitTargetId && !en.dead);
                        }
                        if (!orbitTarget && store.boss && !store.boss.dead) {
                            orbitTarget = store.boss;
                        }
                        
                        if (orbitTarget) {
                            ctx.save();
                            ctx.globalAlpha = 0.25 + 0.15 * flicker;
                            ctx.strokeStyle = e.trailColor || e.color || '#ff7deb';
                            ctx.lineWidth = 2.5;
                            ctx.setLineDash([6, 8]);
                            ctx.lineDashOffset = -time * 20;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(orbitTarget.x - e.x, orbitTarget.y - e.y);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.restore();
                        }

                        const module = e.attackModule || 'default';
                        const abilityTheme = e.abilityTheme || getChampionMinionAbilityTheme(module);
                        const trailColor = abilityTheme?.trail || e.trailColor || e.color || '#ff7deb';
                        const ringColor = abilityTheme?.ring || e.color || '#ff7deb';

                        ctx.save();
                        
                        // Outer glow aura
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.6 * flicker;
                        const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2);
                        auraGradient.addColorStop(0, withAlpha(trailColor, 0.8));
                        auraGradient.addColorStop(0.5, withAlpha(trailColor, 0.4));
                        auraGradient.addColorStop(1, withAlpha(trailColor, 0));
                        ctx.fillStyle = auraGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius * 2.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        // Rotating energy ring
                        ctx.save();
                        ctx.rotate(time * 3);
                        ctx.strokeStyle = withAlpha(ringColor, 0.7);
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            const angle = (i / 3) * Math.PI * 2;
                            const arcStart = angle;
                            const arcEnd = angle + Math.PI * 0.4;
                            ctx.beginPath();
                            ctx.arc(0, 0, radius * 1.4, arcStart, arcEnd);
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Main orb body with layered spheres
                        const bodyGrad = ctx.createRadialGradient(radius * -0.2, radius * -0.2, 0, 0, 0, radius * 1.2);
                        bodyGrad.addColorStop(0, '#ffffff');
                        bodyGrad.addColorStop(0.4, ringColor);
                        bodyGrad.addColorStop(0.8, trailColor);
                        bodyGrad.addColorStop(1, withAlpha(trailColor, 0.5));
                        ctx.fillStyle = bodyGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Outer shell highlight
                        ctx.strokeStyle = withAlpha('#ffffff', 0.6);
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, radius * 0.95, 0, Math.PI * 2);
                        ctx.stroke();

                        // Energy core sparkle
                        ctx.save();
                        ctx.shadowBlur = 10 * flicker;
                        ctx.shadowColor = '#ffffff';
                        ctx.fillStyle = withAlpha('#ffffff', 0.9 * flicker);
                        ctx.beginPath();
                        ctx.arc(radius * -0.25, radius * -0.25, radius * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        // Orbiting particles
                        ctx.fillStyle = withAlpha(ringColor, 0.8);
                        for (let i = 0; i < 4; i++) {
                            const angle = time * 5 + (i / 4) * Math.PI * 2;
                            const dist = radius * 1.8;
                            const px = Math.cos(angle) * dist;
                            const py = Math.sin(angle) * dist;
                            ctx.beginPath();
                            ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        break;
                    }
                    case "void_reaper": {
                        const time = performance.now() / 1000;
                        const warningPhase = e.phase === 'warning';
                        const emergingPhase = e.phase === 'emerging';
                        const lungePhase = e.phase === 'lunge';
                        const pulse = 0.55 + 0.45 * Math.sin(time * 4.6 + (e.riftSeed || 0));

                        // Spectral aura
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = 0.55 + 0.25 * pulse;
                        const outerRadius = a * 1.8;
                        const aura = ctx.createRadialGradient(0, 0, outerRadius * 0.2, 0, 0, outerRadius);
                        aura.addColorStop(0, 'rgba(180, 120, 255, 0.7)');
                        aura.addColorStop(0.6, 'rgba(120, 60, 200, 0.4)');
                        aura.addColorStop(1, 'rgba(40, 0, 80, 0)');
                        ctx.fillStyle = aura;
                        ctx.beginPath();
                        ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        ctx.save();
                        const heading = e.heading || 0;
                        ctx.rotate(heading - Math.PI / 2); // Rotate so it faces movement direction
                        
                        // Scale for visual effect
                        const scale = 0.9;
                        ctx.scale(scale, scale);
                        
                        // Spectral transparency and glow
                        ctx.globalAlpha = 0.85;
                        ctx.shadowColor = 'rgba(180, 120, 255, 0.7)';
                        ctx.shadowBlur = 20;

                        // Tattered robe body with fade
                        const bodyGradient = ctx.createLinearGradient(0, -a * 2, 0, a * 2);
                        bodyGradient.addColorStop(0, 'rgba(5, 0, 10, 1)');
                        bodyGradient.addColorStop(1, 'rgba(5, 0, 10, 0.4)');
                        ctx.fillStyle = bodyGradient;
                        
                        ctx.beginPath();
                        ctx.moveTo(-a, a * 1.4); // Tattered edge starts
                        ctx.lineTo(-a * 0.7, a * 2);
                        ctx.lineTo(-a * 0.3, a * 1.5);
                        ctx.lineTo(a * 0.15, a * 2);
                        ctx.lineTo(a * 0.6, a * 1.4);
                        ctx.lineTo(a, a * 2); // Tattered edge ends
                        ctx.quadraticCurveTo(a * 1.5, 0, a * 0.9, -a * 1.4); // Right side
                        ctx.quadraticCurveTo(0, -a * 2.1, -a * 0.9, -a * 1.4); // Top hood
                        ctx.quadraticCurveTo(-a * 1.5, 0, -a, a * 1.4); // Left side
                        ctx.closePath();
                        ctx.fill();

                        // Reset shadow for skull and scythe
                        ctx.shadowBlur = 0;

                        // Skull
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.45, -a * 1.3);
                        ctx.quadraticCurveTo(0, -a * 1.7, a * 0.45, -a * 1.3);
                        ctx.quadraticCurveTo(a * 0.6, -a * 0.6, 0, -a * 0.3);
                        ctx.quadraticCurveTo(-a * 0.6, -a * 0.6, -a * 0.45, -a * 1.3);
                        ctx.closePath();
                        ctx.fill();

                        // Eye sockets
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(-a * 0.25, -a, a * 0.18, 0, Math.PI * 2);
                        ctx.arc(a * 0.25, -a, a * 0.18, 0, Math.PI * 2);
                        ctx.fill();

                        // Nose cavity
                        ctx.beginPath();
                        ctx.moveTo(0, -a * 0.8);
                        ctx.lineTo(a * 0.12, -a * 0.6);
                        ctx.lineTo(-a * 0.12, -a * 0.6);
                        ctx.closePath();
                        ctx.fill();

                        // Scythe with swing animation
                        ctx.save();
                        const swingProgress = lungePhase ? Math.min(1, (e.lungeProgress || 0) * 1.4) : (emergingPhase ? (e.emergeProgress || 0) * 0.8 : 0);
                        const swingAngle = Math.sin(swingProgress * Math.PI) * -1.8;
                        ctx.rotate(swingAngle);

                        // Scythe handle
                        ctx.fillStyle = 'black';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = a * 0.25;
                        ctx.beginPath();
                        ctx.moveTo(a * 0.3, -a * 2.3);
                        ctx.lineTo(a * 0.3, a * 1.7);
                        ctx.stroke();

                        // Scythe blade
                        ctx.beginPath();
                        ctx.moveTo(a * 0.3, -a * 2.3);
                        ctx.quadraticCurveTo(a * 1.8, -a * 2.9, a * 2.6, -a * 1.4);
                        ctx.quadraticCurveTo(a * 1.9, -a * 2.4, a * 0.3, -a * 2);
                        ctx.closePath();
                        ctx.fill();

                        // Skeletal hand gripping scythe
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.rect(-a * 0.15, -a * 0.15, a * 0.5, a * 0.5);
                        ctx.rect(-a * 0.2, -a * 0.15, a * 0.12, a * 0.35);
                        ctx.rect(-a * 0.2, a * 0.2, a * 0.12, a * 0.35);
                        ctx.fill();
                        
                        ctx.restore(); // End scythe rotation

                        ctx.restore(); // End main rotation

                        // Afterimage trail during lunge
                        if (lungePhase) {
                            const afterImageCount = 5;
                            const baseAlpha = 0.22;
                            const lungeProgress = e.lungeProgress || 0;
                            for (let i = 1; i <= afterImageCount; i++) {
                                const decay = i / (afterImageCount + 1);
                                const offset = a * 3 * decay;
                                ctx.save();
                                ctx.globalAlpha = baseAlpha * (1 - decay);
                                ctx.translate(-Math.cos(heading) * offset, -Math.sin(heading) * offset);
                                ctx.rotate(heading - Math.PI / 2);
                                ctx.fillStyle = `rgba(130, 70, 220, ${0.6 * (1 - decay)})`;
                                ctx.beginPath();
                                ctx.ellipse(0, 0, a * (1.2 - decay * 0.3) * 0.9, a * (1.6 - decay * 0.4) * 0.9, 0, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        }

                        break;
                    }
                    case "angler": {
                        const scale = a / 20;
                        ctx.save(); ctx.scale(scale, scale);
                        ctx.fillStyle = n + "99"; ctx.strokeStyle = n; ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-20, 0);
                        ctx.quadraticCurveTo(0, -18, 24, 0);
                        ctx.quadraticCurveTo(0, 16, -20, 0);
                        ctx.closePath(); ctx.fill(); ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-6, 5);
                        ctx.quadraticCurveTo(2, 10, 10, 4);
                        ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(8, -6);
                        ctx.quadraticCurveTo(20, -24, 32, -28); ctx.stroke();
                        ctx.shadowColor = "#00FFD5"; ctx.shadowBlur = 12;
                        ctx.beginPath(); ctx.arc(32, -28, 4, 0, Math.PI * 2); ctx.fillStyle = "#00FFD5"; ctx.fill();
                        ctx.restore();
                        break;
                    }
                    case "manta": {
                        // Use PixiJS rendering for hardware acceleration
                        if (pixiApp) {
                            drawMantaPixi(e);
                        }
                        // No canvas fallback needed - PixiJS required for this game
                        break;
                    }
                }
                if (e.stunTimer && e.stunTimer > 0) {
                    ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + 0.3 * Math.sin(performance.now() / 100)})`;
                    ctx.font = 'bold 12px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('STUN', 0, -a - 12);
                }
                // Check if this enemy should show vulnerability visuals based on clustering
                const shouldShowVulnVisuals = (() => {
                    // Count nearby enemies with vulnerability visuals
                    const clusterRadius = 140; // Increased radius to cover more area
                    const maxVisualsPerCluster = 2; // Reduced from 3 to 2 to prevent overdraw
                    let nearbyWithVisuals = 0;
                    
                    for (const other of store.enemies) {
                        if (other === e || other.dead) continue;
                        const dx = other.x - e.x;
                        const dy = other.y - e.y;
                        const distSq = dx * dx + dy * dy;
                        
                        if (distSq < clusterRadius * clusterRadius) {
                            // Check if this nearby enemy has any vulnerability visual
                            if ((other.vulnerabilityPulseStrength && other.vulnerabilityPulseColor) || 
                                other.railgunArmorTimer > 0 || 
                                other.phaseLockTimer > 0) {
                                nearbyWithVisuals++;
                                // If this other enemy has higher priority (more health or closer to player), skip current enemy
                                if (nearbyWithVisuals >= maxVisualsPerCluster && other.hp > e.hp) {
                                    return false;
                                }
                            }
                        }
                    }
                    return nearbyWithVisuals < maxVisualsPerCluster;
                })();

                if (shouldShowVulnVisuals) {
                    if (e.vulnerabilityPulseStrength && e.vulnerabilityPulseColor) {
                        const pulse = (Math.sin(performance.now() / 120) + 1) * 0.5;
                        ctx.save();
                        ctx.globalAlpha = Math.min(0.9, e.vulnerabilityPulseStrength);
                        ctx.strokeStyle = e.vulnerabilityPulseColor;
                        ctx.lineWidth = 2.5 + pulse * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, a * (1.05 + 0.2 * pulse), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                    if (e.railgunArmorTimer > 0) {
                        ctx.save();
                        ctx.strokeStyle = `rgba(215,240,255,${Math.min(0.8, e.railgunArmorTimer / 2)})`;
                        ctx.lineWidth = 1.4;
                        ctx.beginPath();
                        ctx.moveTo(-a * 0.6, -a * 0.3);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(a * 0.5, -a * 0.2);
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-a * 0.2, a * 0.5);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
                if (shouldShowVulnVisuals && e.phaseLockTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.4 + 0.2 * Math.sin(performance.now() / 60);
                    ctx.strokeStyle = '#9e7cff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(-a * 1.2, 0);
                    ctx.lineTo(a * 1.2, 0);
                    ctx.moveTo(0, -a * 1.2);
                    ctx.lineTo(0, a * 1.2);
                    ctx.stroke();
                    ctx.restore();
                }
                if (e.stormShockTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.8, 0.4 + e.stormShockTimer * 0.3);
                    ctx.strokeStyle = '#66d6ff';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + performance.now() / 250;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * a * 0.4, Math.sin(angle) * a * 0.4);
                        ctx.lineTo(Math.cos(angle) * a * 1.3, Math.sin(angle) * a * 1.3);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
                if (e.demolitionPulseWarmup > 0) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.6, e.demolitionPulseWarmup * 1.2);
                    const grad = ctx.createRadialGradient(0, 0, a * 0.2, 0, 0, a * 1.4);
                    grad.addColorStop(0, 'rgba(255, 170, 90, 0.7)');
                    grad.addColorStop(1, 'rgba(255, 90, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * (1 + (1 - e.demolitionPulseWarmup) * 0.4), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                if (e.poisonStacks && e.poisonStacks > 0) {
                    ctx.save();
                    const poisonPulse = 0.6 + 0.4 * Math.cos(performance.now() / 400);
                    const poisonAlpha = 0.5 * poisonPulse;

                    // Outer glow ring
                    ctx.globalAlpha = poisonAlpha * 0.4;
                    ctx.strokeStyle = '#00ff66';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * (1.3 + e.poisonStacks * 0.15), 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner glow ring
                    ctx.globalAlpha = poisonAlpha * 0.7;
                    ctx.strokeStyle = '#00ff66';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * (1.1 + e.poisonStacks * 0.1), 0, Math.PI * 2);
                    ctx.stroke();

                    // Poison bubbles around enemy (without outline)
                    ctx.globalAlpha = 0.6;
                    const bubbleCount = 4 + (e.poisonStacks * 2);
                    const time = performance.now() / 1000;
                    for (let i = 0; i < bubbleCount; i++) {
                        const angle = (i / bubbleCount) * Math.PI * 2 + time;
                        const radius = a * (1.2 + Math.sin(time * 2 + i) * 0.3);
                        const bubbleX = Math.cos(angle) * radius;
                        const bubbleY = Math.sin(angle) * radius;
                        const bubbleSize = 2 + Math.sin(time * 3 + i) * 1.5;
                        ctx.fillStyle = '#00ff66';
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }
                
                // Draw ice damage indicator (dark blue glowing circle)
                if (e.iceStacks && e.iceStacks > 0) {
                    ctx.save();
                    const icePulse = 0.6 + 0.4 * Math.cos(performance.now() / 350);
                    const iceAlpha = 0.5 * icePulse;
                    
                    // Outer glow ring
                    ctx.globalAlpha = iceAlpha * 0.4;
                    ctx.strokeStyle = '#0033ff';
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * (1.3 + e.iceStacks * 0.15), 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner glow ring
                    ctx.globalAlpha = iceAlpha * 0.7;
                    ctx.strokeStyle = '#0088ff';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, a * (1.1 + e.iceStacks * 0.1), 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Snow particles around enemy (increases with stacks)
                    ctx.globalAlpha = 0.5;
                    const snowCount = 5 + (e.iceStacks * 2); // 5, 7, 9 snowflakes for stacks 1, 2, 3
                    const time = performance.now() / 1000;
                    for (let i = 0; i < snowCount; i++) {
                        const angle = (i / snowCount) * Math.PI * 2 + time * 0.5;
                        const radius = a * (1.3 + Math.sin(time * 1.5 + i) * 0.4);
                        const snowX = Math.cos(angle) * radius;
                        const snowY = Math.sin(angle) * radius;
                        const snowSize = 1.5 + Math.sin(time * 2.5 + i) * 1;
                        
                        // Draw snowflake as cross/star pattern
                        ctx.strokeStyle = 'rgba(200, 230, 255, 0.8)';
                        ctx.lineWidth = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(snowX - snowSize, snowY);
                        ctx.lineTo(snowX + snowSize, snowY);
                        ctx.moveTo(snowX, snowY - snowSize);
                        ctx.lineTo(snowX, snowY + snowSize);
                        ctx.moveTo(snowX - snowSize * 0.7, snowY - snowSize * 0.7);
                        ctx.lineTo(snowX + snowSize * 0.7, snowY + snowSize * 0.7);
                        ctx.moveTo(snowX + snowSize * 0.7, snowY - snowSize * 0.7);
                        ctx.lineTo(snowX - snowSize * 0.7, snowY + snowSize * 0.7);
                        ctx.stroke();
                    }
                    
                    if (e.isFrozen && e.iceStacks >= 3) {
                        // FROZEN VISUAL: Blue ice overlay with frosty border
                        // Draw semi-transparent blue ice shell that covers the enemy
                        ctx.globalAlpha = 0.4;
                        const frostShell = ctx.createRadialGradient(0, 0, a * 0.05, 0, 0, a * 1.4);
                        frostShell.addColorStop(0, 'rgba(180, 220, 255, 0.6)');  // Light icy blue center
                        frostShell.addColorStop(0.3, 'rgba(100, 180, 255, 0.5)'); // Medium blue
                        frostShell.addColorStop(0.65, 'rgba(40, 120, 220, 0.4)'); // Darker blue edge
                        frostShell.addColorStop(1, 'rgba(20, 80, 180, 0.2)');      // Transparent outer edge
                        ctx.fillStyle = frostShell;
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.35, 0, Math.PI * 2);
                        ctx.fill();

                        // Bright white frosty border (thicker, more visible)
                        ctx.globalAlpha = 0.7;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = Math.max(3, a * 0.15);
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.25, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Secondary frost ring (slightly pulsing)
                        const frostPulse = 0.85 + 0.15 * Math.sin(time * 3);
                        ctx.globalAlpha = 0.5 * frostPulse;
                        ctx.strokeStyle = '#e0f0ff';
                        ctx.lineWidth = Math.max(2, a * 0.1);
                        ctx.beginPath();
                        ctx.arc(0, 0, a * 1.32, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Stack indicator text
                    if (e.iceStacks > 1) {
                        ctx.globalAlpha = iceAlpha;
                        ctx.fillStyle = '#00ccff';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(e.iceStacks, 0, -a - 12);
                    }
                    
                    ctx.restore();
                }
                
                ctx.restore()
            }
            function createEffect(type, x, y, radius, options = {}) {
                const opts = options || {};
                let effect = { isActive: !0, life: 1, maxLife: 1, x, y, radius, opts };
                switch (type) {
                    case "heartbeatPulse":
                        effect.maxLife = 0.6;
                        effect.life = effect.maxLife;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const alpha = Math.sin((this.life / this.maxLife) * Math.PI) * 0.4;
                            ctx.save();
                            ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
                            ctx.fillRect(0, 0, W, H);
                            ctx.restore();
                        };
                        break;
                    case "fireBurn":
                        effect.maxLife = opts.duration ?? 0.35;
                        effect.life = effect.maxLife;
                        effect.radius = Math.max(6, radius || 18);
                        effect.opts = opts;
                        effect.anchor = opts.anchor || null;
                        effect.offset = opts.offset || { x: 0, y: 0 };
                        effect.follow = opts.follow !== false;
                        effect.step = function (dt) {
                            if (this.follow && this.anchor) {
                                if (this.anchor.dead) {
                                    this.follow = false;
                                } else {
                                    this.x = this.anchor.x + (this.offset?.x || 0);
                                    this.y = this.anchor.y + (this.offset?.y || 0);
                                }
                            }
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const intensity = Math.min(1, Math.max(0, this.opts.intensity ?? 0));
                            const baseAlpha = 0.2 + intensity * 0.2;
                            const flicker = 0.85 + Math.sin(performance.now() / 90 + this.life * 8) * 0.15;
                            const size = this.radius * (0.65 + progress * 0.35);
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = 1;
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = baseAlpha * flicker;
                            const gradient = ctx.createRadialGradient(0, 0, size * 0.1, 0, 0, size);
                            gradient.addColorStop(0, 'rgba(255, 176, 96, 0.8)');
                            gradient.addColorStop(0.4, 'rgba(255, 110, 48, 0.42)');
                            gradient.addColorStop(1, 'rgba(80, 18, 0, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.globalAlpha = baseAlpha * 0.6;
                            ctx.strokeStyle = 'rgba(255, 210, 150, 0.4)';
                            ctx.lineWidth = Math.max(1.2, size * 0.12);
                            ctx.beginPath();
                            ctx.arc(0, 0, size * 0.72, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "voidPulse":
                        effect.maxLife = opts.duration ?? 0.55;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 90;
                        effect.opts = opts;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const lifeRatio = this.life / this.maxLife;
                            const fade = Math.max(0, lifeRatio);
                            const progress = 1 - lifeRatio;
                            const outerRadius = this.radius * (0.9 + progress * 0.25);
                            const innerRadius = outerRadius * 0.26;
                            ctx.save();
                            ctx.translate(this.x, this.y);

                            const gradient = ctx.createRadialGradient(0, 0, innerRadius, 0, 0, outerRadius);
                            gradient.addColorStop(0, `rgba(18, 8, 32, ${0.32 * fade})`);
                            gradient.addColorStop(0.55, `rgba(60, 20, 90, ${0.22 * fade})`);
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                            ctx.globalCompositeOperation = 'source-over';
                            ctx.globalAlpha = 0.75;
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.globalCompositeOperation = 'lighter';
                            ctx.strokeStyle = `rgba(190, 140, 255, ${0.24 * fade})`;
                            ctx.lineWidth = Math.max(1.2, this.radius * 0.05 * fade);
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.strokeStyle = `rgba(90, 45, 150, ${0.18 * fade})`;
                            ctx.lineWidth = Math.max(0.8, this.radius * 0.03 * fade);
                            ctx.setLineDash([5, 20]);
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius * 0.65, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.restore();
                        };
                        break;
                    case "fragPulse":
                        effect.maxLife = opts.duration ?? 0.35;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 35; // Much smaller than voidPulse (90)
                        effect.opts = opts;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const lifeRatio = this.life / this.maxLife;
                            const fade = Math.max(0, lifeRatio);
                            const progress = 1 - lifeRatio;
                            const outerRadius = this.radius * (0.85 + progress * 0.5);
                            const innerRadius = outerRadius * 0.25;
                            ctx.save();
                            ctx.translate(this.x, this.y);

                            // Neon orange/pink gradient pulse
                            const gradient = ctx.createRadialGradient(0, 0, innerRadius, 0, 0, outerRadius);
                            gradient.addColorStop(0, `rgba(255, 140, 0, ${0.75 * fade})`);   // Neon orange center
                            gradient.addColorStop(0.45, `rgba(255, 80, 120, ${0.55 * fade})`); // Hot pink middle
                            gradient.addColorStop(0.75, `rgba(255, 20, 147, ${0.35 * fade})`); // Deep pink
                            gradient.addColorStop(1, 'rgba(255, 0, 100, 0)'); // Transparent edge

                            ctx.globalCompositeOperation = 'lighter';
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                            ctx.fill();

                            // Bright neon ring
                            ctx.strokeStyle = `rgba(255, 200, 100, ${0.65 * fade})`;
                            ctx.lineWidth = Math.max(2, this.radius * 0.1 * fade);
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            // Inner bright core
                            ctx.strokeStyle = `rgba(255, 150, 50, ${0.5 * fade})`;
                            ctx.lineWidth = Math.max(1.5, this.radius * 0.06 * fade);
                            ctx.setLineDash([4, 10]);
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius * 0.6, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.restore();
                        };
                        break;
                    case "fireWipeDeath":
                        effect.maxLife = opts.duration ?? 0.75;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 18;
                        effect.opts = {
                            colorStops: Array.isArray(opts.colorStops) && opts.colorStops.length ? opts.colorStops : [
                                [255, 238, 205],
                                [255, 202, 85],
                                [255, 124, 46]
                            ],
                            seed: opts.seed ?? Math.random() * Math.PI * 2
                        };
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const visible = Math.max(0, 1 - t);
                            if (visible <= 0) return;

                            const baseRadius = this.radius * (1.05 + 0.08 * visible);
                            const time = performance.now() / 1000;
                            const seed = this.opts.seed || 0;
                            const width = baseRadius * 2.6;
                            const height = visible * baseRadius * 2.6;
                            const bottom = baseRadius * 1.2;
                            const top = bottom - height;

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.beginPath();
                            ctx.rect(-width / 2, top, width, height);
                            ctx.clip();

                            ctx.globalCompositeOperation = 'lighter';

                            const layers = 3;
                            const colors = this.opts.colorStops || [[255, 238, 205], [255, 202, 85], [255, 124, 46]];
                            for (let layer = 0; layer < layers; layer++) {
                                const ratio = layer / (layers - 1 || 1);
                                const layerOpacity = (1 - t) * (0.9 - ratio * 0.32);
                                if (layerOpacity <= 0.02) continue;

                                const base = baseRadius * (0.92 + ratio * 0.24);
                                const amp = baseRadius * (0.08 + 0.05 * (1 - ratio) * (1 - t));
                                const segments = 64;
                                const color = colors[Math.min(layer, colors.length - 1)];
                                const lineWidthBase = Math.max(1.7, baseRadius * 0.12 * (1 - ratio * 0.35));

                                ctx.lineWidth = lineWidthBase * (0.85 + Math.sin(time * (6.5 + ratio * 1.8) + seed + ratio * 1.7) * 0.12);
                                ctx.strokeStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${layerOpacity})`;
                                ctx.beginPath();
                                for (let i = 0; i <= segments; i++) {
                                    const angle = (i / segments) * Math.PI * 2;
                                    const wobble = Math.sin(angle * (3.8 + ratio * 0.8) + time * (9 + ratio * 2) + seed * 1.1) + Math.sin(angle * (7.6 + ratio * 1.2) - time * (6.1 + ratio) + seed * 2.3) * 0.5;
                                    const r = base + wobble * amp;
                                    const px = Math.cos(angle) * r;
                                    const py = Math.sin(angle) * r;
                                    if (i === 0) ctx.moveTo(px, py);
                                    else ctx.lineTo(px, py);
                                }
                                ctx.closePath();
                                ctx.stroke();
                            }

                            // Inner glow
                            ctx.globalAlpha = (1 - t) * 0.45;
                            const innerRadius = baseRadius * 0.65;
                            const gradient = ctx.createRadialGradient(0, 0, innerRadius * 0.2, 0, 0, innerRadius);
                            gradient.addColorStop(0, 'rgba(255, 210, 120, 0.78)');
                            gradient.addColorStop(0.55, 'rgba(255, 140, 30, 0.54)');
                            gradient.addColorStop(1, 'rgba(160, 30, 0, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();

                            // Leading wipe spark line
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = Math.max(0, 0.65 * (1 - t));
                            const wipeY = top - baseRadius * 0.05;
                            ctx.fillStyle = 'rgba(255, 220, 150, 0.7)';
                            ctx.fillRect(-width / 2, wipeY - 1.5, width, 3);
                            ctx.globalAlpha *= 0.6;
                            ctx.fillStyle = 'rgba(255, 120, 20, 0.85)';
                            ctx.fillRect(-width / 2, wipeY - 0.5, width, 1);
                            ctx.restore();
                        };
                        break;
                    case "poisonCloud":
                        effect.maxLife = opts.duration ?? 0.75;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 18;
                        effect.seed = opts.seed ?? Math.random() * Math.PI * 2;
                        effect.particles = Array.from({ length: Math.max(4, Math.min(10, Math.floor((radius || 18) / 3))) }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            dist: 0.45 + Math.random() * 0.4,
                            size: 0.18 + Math.random() * 0.22,
                            offset: Math.random() * Math.PI * 2
                        }));
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const lifeRatio = Math.max(0, this.life / this.maxLife);
                            const pulse = 0.9 + Math.sin(performance.now() / 170 + this.seed) * 0.12;
                            const baseRadius = this.radius * (0.85 + (1 - lifeRatio) * 0.2) * pulse;

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';

                            ctx.globalAlpha = 0.45 * lifeRatio;
                            const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.15, 0, 0, baseRadius);
                            gradient.addColorStop(0, 'rgba(120, 255, 150, 0.75)');
                            gradient.addColorStop(0.55, 'rgba(40, 150, 90, 0.45)');
                            gradient.addColorStop(1, 'rgba(12, 48, 26, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
                            ctx.fill();

                            const time = performance.now() / 1000;
                            ctx.globalAlpha = 0.35 * lifeRatio;
                            ctx.fillStyle = 'rgba(120, 255, 170, 0.7)';
                            this.particles.forEach((p, index) => {
                                const swirl = time * 1.6 + this.seed * 0.3 + index * 0.7;
                                const orbit = this.radius * p.dist * (0.9 + Math.sin(time * 1.1 + p.offset) * 0.08);
                                const px = Math.cos(p.angle + swirl) * orbit;
                                const py = Math.sin(p.angle + swirl) * orbit;
                                const bubbleRadius = this.radius * p.size * (0.8 + Math.sin(time * 2.4 + p.offset) * 0.15);
                                ctx.beginPath();
                                ctx.arc(px, py, Math.max(1.2, bubbleRadius), 0, Math.PI * 2);
                                ctx.fill();
                            });

                            ctx.restore();
                        };
                        break;
                    case "beefCharge":
                        effect.maxLife = opts.duration ?? 0.38;
                        effect.origin = x;
                        effect.target = y;
                        effect.opts = opts;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - this.life;
                            const eased = 1 - Math.pow(1 - progress, 2.2);
                            const currentX = this.origin.x + (this.target.x - this.origin.x) * eased;
                            const currentY = this.origin.y + (this.target.y - this.origin.y) * eased;
                            const subclass = this.opts.subclass;
                            const chain = this.opts.segmentLabel === 'chain';
                            const colorMain = subclass === 'juggernaut' ? '255, 210, 120' : '255, 120, 120';
                            const colorEdge = subclass === 'juggernaut' ? '255, 180, 70' : '255, 80, 80';

                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';

                            if (progress > 0.45) {
                                const shockwaveProgress = (progress - 0.45) / 0.55;
                                const decay = 1 - shockwaveProgress;
                                ctx.strokeStyle = `rgba(${colorEdge}, ${0.55 * decay})`;
                                ctx.lineWidth = 6 * decay;
                                ctx.beginPath();
                                ctx.arc(this.target.x, this.target.y, (this.opts.rangeOverride ?? 85) * shockwaveProgress, 0, Math.PI * 2);
                                ctx.stroke();
                            }

                            ctx.strokeStyle = `rgba(${colorMain}, ${0.85 * this.life})`;
                            ctx.lineWidth = (chain ? 10 : 13) * this.life;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(this.origin.x, this.origin.y);
                            ctx.lineTo(currentX, currentY);
                            ctx.stroke();

                            ctx.globalAlpha = 0.6 * this.life;
                            ctx.lineWidth = 2.5 * (chain ? 1.2 : 1);
                            ctx.strokeStyle = `rgba(${colorEdge}, ${0.9 * this.life})`;
                            ctx.beginPath();
                            ctx.moveTo(this.origin.x, this.origin.y);
                            ctx.lineTo(currentX, currentY);
                            ctx.stroke();

                            ctx.restore();
                        };
                        break;
                    case "marauderImpact":
                        effect.maxLife = 0.48;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 90;
                        effect.opts = opts;
                        effect.shards = Array.from({ length: opts.subclass === 'juggernaut' ? 22 : 16 }, () => ({
                            angle: Math.random() * Math.PI * 2,
                            speed: 140 + Math.random() * 160,
                            width: 5 + Math.random() * 3.5
                        }));
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const subclass = this.opts.subclass;
                            const primary = subclass === 'juggernaut' ? '255, 205, 120' : '255, 120, 120';
                            const secondary = subclass === 'juggernaut' ? '255, 175, 60' : '255, 90, 70';

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';

                            const coreRadius = this.radius * (0.45 + 0.25 * Math.sin(performance.now() / 140));
                            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * (0.8 + t * 0.4));
                            gradient.addColorStop(0, `rgba(${primary}, ${0.65 * this.life})`);
                            gradient.addColorStop(0.55, `rgba(${secondary}, ${0.45 * this.life})`);
                            gradient.addColorStop(1, 'rgba(255, 70, 20, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.8 + 0.35 * t), 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * this.life})`;
                            ctx.lineWidth = 6 * (1 - t) + 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, coreRadius * (0.9 + t * 0.6), 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.globalAlpha = 0.9 * this.life;
                            this.shards.forEach((shard, index) => {
                                const length = this.radius * (0.25 + t * 1.1);
                                const decay = Math.pow(1 - t, 0.5);
                                const sx = Math.cos(shard.angle) * length * decay;
                                const sy = Math.sin(shard.angle) * length * decay;
                                ctx.lineWidth = Math.max(1.2, shard.width * this.life * 0.75);
                                ctx.strokeStyle = subclass === 'juggernaut' ? '#ffe7a0' : '#ffc1b1';
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(sx, sy);
                                ctx.stroke();
                            });
                            ctx.restore();
                        };
                        break;
                    case "spawnTeleport":
                        effect.maxLife = opts.duration ?? 0.85;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 18;
                        effect.color = opts.color || '#9ad7ff';
                        effect.clusterIndex = opts.clusterIndex ?? 0;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const eased = 1 - Math.pow(1 - t, 2.4);
                            const alpha = Math.max(0, 0.75 * (1 - eased));
                            const ringPulse = 0.8 + Math.sin(performance.now() / 140 + this.clusterIndex) * 0.15;
                            const baseRadius = this.radius * (0.85 + eased * 0.55);
                            ctx.save();
                            ctx.translate(this.x, this.y + (opts.fallback ? 6 : 0));
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = alpha;
                            const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, baseRadius * 1.15);
                            gradient.addColorStop(0, `${this.color}aa`);
                            gradient.addColorStop(1, `${this.color}00`);
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, baseRadius * 1.15, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = this.color;
                            ctx.lineWidth = 2.5;
                            ctx.beginPath();
                            ctx.arc(0, 0, baseRadius * ringPulse, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.lineWidth = 1.2;
                            ctx.globalAlpha *= 0.8;
                            ctx.beginPath();
                            ctx.arc(0, 0, baseRadius * (0.55 + Math.sin(performance.now() / 180 + this.clusterIndex) * 0.1), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "voidReaperRift":
                        effect.maxLife = opts.duration ?? 2.0;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 80;
                        effect.edge = opts.edge || 'top';
                        effect.seed = Math.random() * Math.PI * 2;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const time = performance.now() / 1000;
                            const spin = time * 4 + this.seed;
                            const alpha = 0.45 + 0.35 * Math.sin(time * 6 + progress * 8);
                            const coreRadius = this.radius * (0.45 + progress * 0.25);
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = alpha;

                            const portal = ctx.createRadialGradient(0, 0, coreRadius * 0.25, 0, 0, coreRadius * 2.1);
                            portal.addColorStop(0, 'rgba(215, 180, 255, 0.85)');
                            portal.addColorStop(0.35, 'rgba(145, 90, 220, 0.6)');
                            portal.addColorStop(0.75, 'rgba(60, 20, 120, 0.35)');
                            portal.addColorStop(1, 'rgba(20, 4, 60, 0)');
                            ctx.fillStyle = portal;
                            ctx.beginPath();
                            ctx.arc(0, 0, coreRadius * (2 + progress * 0.3), 0, Math.PI * 2);
                            ctx.fill();

                            const shardCount = 18;
                            for (let i = 0; i < shardCount; i++) {
                                const angle = spin + (i / shardCount) * Math.PI * 2;
                                const length = coreRadius * (1.4 + Math.sin(time * 5 + i) * 0.25);
                                ctx.globalAlpha = 0.25 + progress * 0.45;
                                ctx.strokeStyle = 'rgba(240, 220, 255, 0.9)';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(angle) * coreRadius * 0.6, Math.sin(angle) * coreRadius * 0.6);
                                ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
                                ctx.stroke();
                            }

                            ctx.restore();
                        };
                        break;
                    case "voidReaperStrike":
                        effect.maxLife = opts.duration ?? 0.35;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 36;
                        effect.heading = opts.heading || 0;
                        effect.warmup = opts.warmup || false;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const eased = this.warmup ? Math.pow(t, 0.6) : t;
                            const radius = this.radius * (1 + eased * 0.45);
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.rotate(this.heading);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = this.warmup ? 0.35 + 0.4 * (1 - eased) : 0.45 * (1 - t) + 0.3;

                            const gradient = ctx.createLinearGradient(-radius * 0.4, 0, radius * 1.2, 0);
                            gradient.addColorStop(0, 'rgba(255, 220, 255, 0.65)');
                            gradient.addColorStop(0.4, 'rgba(180, 140, 255, 0.5)');
                            gradient.addColorStop(1, 'rgba(70, 20, 160, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.moveTo(-radius * 0.4, -radius * 0.35);
                            ctx.lineTo(radius * 1.2, 0);
                            ctx.lineTo(-radius * 0.4, radius * 0.35);
                            ctx.closePath();
                            ctx.fill();

                            ctx.strokeStyle = 'rgba(255, 240, 255, 0.85)';
                            ctx.lineWidth = 2.5;
                            ctx.beginPath();
                            ctx.moveTo(-radius * 0.4, -radius * 0.42);
                            ctx.quadraticCurveTo(radius * 0.6, 0, -radius * 0.4, radius * 0.42);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "voidReaperReward":
                        effect.maxLife = 1.8;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 90;
                        effect.gold = opts.gold || 0;
                        effect.shards = Array.from({ length: 28 }, (_, i) => ({
                            angle: (i / 28) * Math.PI * 2,
                            speed: 140 + Math.random() * 90,
                            size: 6 + Math.random() * 4
                        }));
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const fade = 1 - t;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = 0.8 * fade;

                            const core = ctx.createRadialGradient(0, 0, this.radius * 0.1, 0, 0, this.radius * (0.7 + t * 0.5));
                            core.addColorStop(0, 'rgba(255, 235, 200, 0.85)');
                            core.addColorStop(0.55, 'rgba(210, 150, 255, 0.55)');
                            core.addColorStop(1, 'rgba(120, 60, 200, 0)');
                            ctx.fillStyle = core;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.8 + t * 0.4), 0, Math.PI * 2);
                            ctx.fill();

                            ctx.globalAlpha = 0.6 * fade;
                            this.shards.forEach((shard, index) => {
                                const dist = shard.speed * t * 0.8;
                                const x = Math.cos(shard.angle) * dist;
                                const y = Math.sin(shard.angle) * dist;
                                ctx.fillStyle = index % 2 === 0 ? '#ffe6ff' : '#ffbfef';
                                ctx.beginPath();
                                ctx.arc(x, y, shard.size * (1 - t * 0.6), 0, Math.PI * 2);
                                ctx.fill();
                            });

                            if (this.gold) {
                                ctx.globalAlpha = 0.85 * fade;
                                ctx.fillStyle = '#ffe896';
                                ctx.font = 'bold 16px Orbitron';
                                ctx.textAlign = 'center';
                                ctx.fillText(`+${this.gold}G`, 0, -this.radius * 0.2);
                            }
                            ctx.restore();
                        };
                        break;
                    case "voidReaperDissolve":
                        effect.maxLife = opts.duration ?? 1.4;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 70;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            const ringRadius = this.radius * (0.6 + t * 0.7);
                            ctx.globalAlpha = 0.55 * (1 - t);
                            ctx.strokeStyle = 'rgba(210, 160, 255, 0.8)';
                            ctx.lineWidth = 4 - t * 2.5;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.globalAlpha = 0.35 * (1 - t);
                            ctx.fillStyle = 'rgba(120, 60, 200, 0.55)';
                            for (let i = 0; i < 5; i++) {
                                const angle = (i / 5) * Math.PI * 2 + performance.now() / 400;
                                const offset = ringRadius * 0.65;
                                ctx.beginPath();
                                ctx.arc(Math.cos(angle) * offset, Math.sin(angle) * offset, 8 + Math.sin(angle * 4) * 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            ctx.restore();
                        };
                        break;
                    case "goldenOrbSpawn":
                        effect.maxLife = 0.65;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 70;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const currentRadius = this.radius * (0.55 + progress * 0.7);
                            const time = performance.now() / 1000;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            const glow = ctx.createRadialGradient(0, 0, currentRadius * 0.25, 0, 0, currentRadius);
                            glow.addColorStop(0, 'rgba(255, 245, 200, 0.75)');
                            glow.addColorStop(0.6, 'rgba(255, 210, 90, 0.55)');
                            glow.addColorStop(1, 'rgba(255, 110, 20, 0)');
                            ctx.globalAlpha = 0.85 - progress * 0.5;
                            ctx.fillStyle = glow;
                            ctx.beginPath();
                            ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 220, 120, ${0.9 - progress})`;
                            ctx.lineWidth = 3 + 4 * (1 - progress);
                            ctx.beginPath();
                            ctx.arc(0, 0, currentRadius * (0.7 + Math.sin(time * 12) * 0.08), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "goldenOrbDetonation":
                        effect.maxLife = 0.6;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 150;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const ringRadius = this.radius * t;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, ringRadius);
                            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.75)');
                            gradient.addColorStop(0.35, 'rgba(255, 210, 90, 0.55)');
                            gradient.addColorStop(0.8, 'rgba(255, 120, 0, 0.15)');
                            gradient.addColorStop(1, 'rgba(255, 90, 0, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 200, 80, ${1 - t})`;
                            ctx.lineWidth = 6 * (1 - t);
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius * 0.72, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "iceShatter":
                        effect.maxLife = opts.duration ?? 0.6;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 24;
                        effect.baseColor = opts.baseColor || '#c9f4ff';
                        effect.edgeColor = opts.edgeColor || '#80d8ff';
                        effect.shards = Array.from({ length: Math.max(6, opts.count ?? 16) }, () => ({
                            angle: Math.random() * TAU,
                            speed: randRange(150, 260),
                            wobble: randRange(-0.4, 0.4),
                            length: randRange(effect.radius * 0.9, effect.radius * 1.65),
                            width: randRange(3, 5)
                        }));
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const fade = 1 - progress;

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';

                            const coreRadius = this.radius * (0.55 + progress * 0.4);
                            ctx.globalAlpha = 0.55 * fade;
                            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                            coreGradient.addColorStop(0, 'rgba(230, 250, 255, 0.95)');
                            coreGradient.addColorStop(0.6, 'rgba(150, 210, 255, 0.45)');
                            coreGradient.addColorStop(1, 'rgba(120, 180, 255, 0)');
                            ctx.fillStyle = coreGradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, coreRadius, 0, TAU);
                            ctx.fill();

                            this.shards.forEach(shard => {
                                const travel = shard.speed * progress;
                                const px = Math.cos(shard.angle) * travel;
                                const py = Math.sin(shard.angle) * travel;

                                ctx.save();
                                ctx.translate(px, py);
                                ctx.rotate(shard.angle + shard.wobble * progress);

                                const length = shard.length;
                                const width = shard.width;

                                ctx.globalAlpha = 0.8 * fade;
                                ctx.fillStyle = this.edgeColor;
                                ctx.beginPath();
                                ctx.moveTo(-length * 0.5, -width * 0.5);
                                ctx.lineTo(length * 0.55, 0);
                                ctx.lineTo(-length * 0.5, width * 0.5);
                                ctx.closePath();
                                ctx.fill();

                                ctx.globalAlpha = 0.65 * fade;
                                ctx.fillStyle = this.baseColor;
                                ctx.beginPath();
                                ctx.moveTo(-length * 0.25, -width * 0.3);
                                ctx.lineTo(length * 0.4, 0);
                                ctx.lineTo(-length * 0.25, width * 0.3);
                                ctx.closePath();
                                ctx.fill();

                                ctx.globalAlpha = 0.45 * fade;
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(length * 0.1, -width * 0.18, length * 0.16, width * 0.36);

                                ctx.restore();
                            });

                            ctx.restore();
                        };
                        break;
                    case "hitSpark":
                        effect.maxLife = opts.colorMode === 'gold' ? 0.5 : 0.22;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 14;
                        effect.colorMode = opts.colorMode || 'pink'; // 'pink' or 'gold'
                        
                        // For gold splash, create more liquid-like particles with enhanced visuals
                        if (opts.colorMode === 'gold') {
                            effect.splashParticles = Array.from({ length: 24 }, (_, i) => { // Increased from 16 to 24 particles
                                const angle = (i / 24) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
                                const speed = 250 + Math.random() * 300; // Increased from 180-400 to 250-550
                                return {
                                    angle,
                                    speed,
                                    size: 10 + Math.random() * 14, // Increased from 6-14 to 10-24 (much bigger!)
                                    life: 0.5 + Math.random() * 0.2,
                                    maxLife: 0.5 + Math.random() * 0.2,
                                    wobble: Math.random() * Math.PI * 2,
                                    wobbleSpeed: 4 + Math.random() * 6
                                };
                            });
                        } else {
                            effect.sparks = Array.from({ length: opts.crit ? 8 : 5 }, (_, i) => {
                                const spread = (Math.random() - 0.5) * 0.9;
                                const angle = (opts.angle ?? 0) + spread;
                                const power = (opts.strength ?? 120) * (0.45 + Math.random() * 0.35);
                                return {
                                    angle,
                                    speed: power * 0.015,
                                    length: effect.radius * (opts.crit ? 1.6 : 1.2) * (0.9 + Math.random() * 0.3),
                                    offset: (i / Math.max(1, (opts.crit ? 8 : 5))) * 0.35
                                };
                            });
                        }
                        
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const fade = 1 - t;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            
                            // Gold metallic splash mode
                            if (this.colorMode === 'gold') {
                                // Larger core splash - increased significantly
                                const coreRadius = this.radius * (1.2 + t * 1.8); // Increased expansion
                                ctx.globalAlpha = 0.7 * fade; // Increased alpha from 0.6
                                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                                coreGradient.addColorStop(0, 'rgba(255, 250, 205, 0.95)');
                                coreGradient.addColorStop(0.5, 'rgba(252, 246, 186, 0.8)');
                                coreGradient.addColorStop(1, 'rgba(191, 149, 63, 0)');
                                ctx.fillStyle = coreGradient;
                                ctx.beginPath();
                                ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Liquid gold splash particles - bigger and brighter
                                ctx.globalAlpha = 1.0 * fade; // Max alpha for particles
                                this.splashParticles.forEach((particle, idx) => {
                                    particle.life -= 1 / 60; // Approximate dt
                                    const particleFade = Math.max(0, particle.life / particle.maxLife);
                                    
                                    const dist = particle.speed * t;
                                    const wobbleOffset = Math.sin(t * particle.wobbleSpeed) * 12; // Increased wobble
                                    const px = Math.cos(particle.angle) * dist + wobbleOffset * Math.sin(particle.angle);
                                    const py = Math.sin(particle.angle) * dist + wobbleOffset * Math.cos(particle.angle);
                                    
                                    // Larger gradient for each drop
                                    const dropGradient = ctx.createRadialGradient(px, py, 0, px, py, particle.size);
                                    dropGradient.addColorStop(0, 'rgba(255, 250, 205, 1)'); // Brighter
                                    dropGradient.addColorStop(0.5, 'rgba(252, 246, 186, 0.9)');
                                    dropGradient.addColorStop(0.7, 'rgba(191, 149, 63, 0.8)');
                                    dropGradient.addColorStop(1, 'rgba(170, 119, 28, 0)');
                                    
                                    ctx.fillStyle = dropGradient;
                                    ctx.beginPath();
                                    ctx.arc(px, py, particle.size * particleFade, 0, Math.PI * 2);
                                    ctx.fill();
                                });
                                
                                // Bright center highlight - larger
                                ctx.globalAlpha = 0.8 * fade; // Increased from 0.7
                                ctx.fillStyle = '#FFFACD';
                                ctx.beginPath();
                                ctx.arc(0, 0, this.radius * 0.8, 0, Math.PI * 2); // Increased from 0.5
                                ctx.fill();
                            } else {
                                // Original pink mode
                                ctx.globalAlpha = 0.75 * fade;
                                ctx.strokeStyle = opts.crit ? '#ffd6ff' : '#ff9adb';
                                ctx.lineWidth = opts.crit ? 2.6 * fade : 1.8 * fade;
                                this.sparks.forEach(spark => {
                                    const dist = spark.length * fade;
                                    const dx = Math.cos(spark.angle) * dist;
                                    const dy = Math.sin(spark.angle) * dist;
                                    ctx.beginPath();
                                    ctx.moveTo(Math.cos(spark.angle) * spark.offset * this.radius, Math.sin(spark.angle) * spark.offset * this.radius);
                                    ctx.lineTo(dx, dy);
                                    ctx.stroke();
                                });
                            }
                            ctx.restore();
                        };
                        break;
                    case "rearGuardBlock":
                        effect.maxLife = 0.5;
                        effect.step = function (dt) { this.life -= dt / this.maxLife; if (this.life <= 0) this.isActive = false; };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(store.player.x, store.player.y);
                            ctx.strokeStyle = `rgba(100, 255, 255, ${this.life})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 5, 20 * (1.2 - this.life), Math.PI * 0.2, Math.PI * 0.8);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "omegaExplosion":
                        effect.maxLife = 0.75;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 90;
                        effect.color = opts.color || '#ffffff';
                        effect.omegaType = opts.omegaType;
                        effect.particles = Array.from({ length: 16 }, (_, i) => ({
                            angle: (i / 16) * Math.PI * 2,
                            speed: 120 + Math.random() * 60,
                            size: 4 + Math.random() * 3
                        }));
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - (this.life / this.maxLife);
                            const fade = 1 - t;
                            const time = performance.now() / 1000;
                            
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            
                            // Core explosion
                            const coreRadius = this.radius * (0.4 + t * 0.6);
                            ctx.globalAlpha = 0.7 * fade;
                            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                            gradient.addColorStop(0, this.color);
                            gradient.addColorStop(0.5, this.color + '88');
                            gradient.addColorStop(1, this.color + '00');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Expanding ring
                            ctx.globalAlpha = 0.9 * fade;
                            ctx.strokeStyle = this.color;
                            ctx.lineWidth = 4 * fade;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * t, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Flying particles
                            ctx.globalAlpha = 0.8 * fade;
                            this.particles.forEach(particle => {
                                const dist = particle.speed * t;
                                const px = Math.cos(particle.angle) * dist;
                                const py = Math.sin(particle.angle) * dist;
                                ctx.fillStyle = this.color;
                                ctx.beginPath();
                                ctx.arc(px, py, particle.size * (1 - t * 0.5), 0, Math.PI * 2);
                                ctx.fill();
                            });
                            
                            ctx.restore();
                        };
                        break;
                    case "gravityWell":
                        // Use radius parameter as scale factor (default 1.0 for normal, 0.4 for mini)
                        const scale = radius || 1.0;
                        effect.scale = scale;
                        effect.maxLife = 7;
                        effect.life = 7;
                        effect.radius = 0;
                        effect.maxRadius = scale < 1.0 ? 60 : 150; // Mini version much smaller visual
                        effect.effectRadius = scale < 1.0 ? 72 : 150; // Mini has 20% smaller AOE than before (was 90)
                        effect.damagePulseT = 1;
                        effect.totalDamageDealtToBoss = 0;
                        effect.stars = [];
                        const starCount = scale < 1.0 ? 20 : 50; // Fewer stars for mini version
                        for (let i = 0; i < starCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * effect.maxRadius;
                            effect.stars.push({
                                x: Math.cos(angle) * dist,
                                y: Math.sin(angle) * dist,
                                r: scale < 1.0 ? Math.random() * 0.8 : Math.random() * 1.5, // Smaller stars for mini
                                initialDist: dist
                            });
                        }
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) {
                                this.isActive = false;
                                screenFlash(1, 400, 'rgba(255, 255, 255, 0.5)');
                                return;
                            }
                            if (this.radius < this.maxRadius) {
                                this.radius += 200 * dt;
                            }

                            this.damagePulseT -= dt;
                            const damageThisFrame = this.damagePulseT <= 0;
                            if (damageThisFrame) {
                                this.damagePulseT = 1;
                            }

                            const pullStrength = 300;
                            const effectiveRadius = this.effectRadius || this.maxRadius;
                            const damageRadiusSq = (effectiveRadius * 0.7) ** 2;

                            store.enemies.forEach(e => {
                                if (e.dead) {
                                    return;
                                }
                                const dx = this.x - e.x;
                                const dy = this.y - e.y;
                                const distSq = dx * dx + dy * dy;

                                if (distSq < effectiveRadius ** 2) {
                                    const dist = Math.sqrt(distSq);
                                    if (dist > 10) {
                                        const resistance = (e.type === 'mech' || e.type === 'hunter') ? 0.7 : 1.0;
                                        e.x += (dx / dist) * pullStrength * resistance * dt;
                                        e.y += (dy / dist) * pullStrength * resistance * dt;
                                    }

                                    if (damageThisFrame && distSq < damageRadiusSq) {
                                        const damage = e.hpMax * (0.25 * store.player.dmgMult);
                                        e.hp -= damage;
                                        store.world.totalDamage += damage;

                                        // Apply vampirism healing for blink damage
                                        if (store.player.vampirism > 0) {
                                            let healAmount = damage * store.player.vampirism;
                                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                        }
                                    }
                                }
                            });
                            if (store.boss) {
                                const b = store.boss;
                                const dx = this.x - b.x;
                                const dy = this.y - b.y;
                                const distSq = dx * dx + dy * dy;
                                const effectiveRadius = this.effectRadius || this.maxRadius;
                                if (distSq < effectiveRadius ** 2) {
                                    const dist = Math.sqrt(distSq);
                                    if (dist > 50) {
                                        b.x += (dx / dist) * pullStrength * 0.5 * dt;
                                        b.y += (dy / dist) * pullStrength * 0.5 * dt;
                                    }
                                    if (damageThisFrame && distSq < damageRadiusSq) {
                                        const damageToDeal = b.hpMax * (0.10 * store.player.dmgMult);
                                        const cap = b.hpMax * 0.5;
                                        let actualDamage = damageToDeal;
                                        if (this.totalDamageDealtToBoss + actualDamage > cap) {
                                            actualDamage = cap - this.totalDamageDealtToBoss;
                                        }
                                        if (actualDamage > 0) {
                                            b.hp -= actualDamage;
                                            this.totalDamageDealtToBoss += actualDamage;
                                            store.world.totalDamage += actualDamage;

                                            // Apply vampirism healing for blink damage on boss
                                            if (store.player.vampirism > 0) {
                                                let healAmount = actualDamage * store.player.vampirism;
                                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                                healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                            }
                                        }
                                    }
                                }
                            }
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            const time = performance.now();
                            const lifeRatio = this.life / this.maxLife;

                            ctx.fillStyle = 'white';
                            this.stars.forEach(star => {
                                const pullFactor = 1 - lifeRatio;
                                const currentDist = star.initialDist * (1 - pullFactor * 0.95);
                                const angle = Math.atan2(star.y, star.x) + pullFactor * 3;
                                const sx = Math.cos(angle) * currentDist;
                                const sy = Math.sin(angle) * currentDist;

                                if (currentDist < this.radius) {
                                    ctx.globalAlpha = lifeRatio * (currentDist / this.radius);
                                    ctx.beginPath();
                                    ctx.arc(sx, sy, star.r, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            });
                            ctx.globalAlpha = 1;

                            for (let i = 0; i < 5; i++) {
                                const rotation = (time / (2000 + i * 200)) % (2 * Math.PI);
                                ctx.strokeStyle = `rgba(0, 0, 5, ${0.4 * lifeRatio})`;
                                ctx.lineWidth = (2 + i) * 2;
                                ctx.beginPath();
                                ctx.arc(0, 0, (this.radius / 5) * (i + 1), rotation, rotation + Math.PI * 1.5);
                                ctx.stroke();
                            }

                            const coreScale = this.scale < 1.0 ? 0.5 : 1.0; // Much smaller core for mini version
                            const corePulse = (3 + Math.sin(time / 100) * 2) * coreScale;
                            const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse * 2);
                            coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            coreGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.7)');
                            coreGrad.addColorStop(1, 'rgba(150, 150, 255, 0)');
                            ctx.fillStyle = coreGrad;
                            ctx.shadowColor = 'white';
                            ctx.shadowBlur = 15 * coreScale;
                            ctx.beginPath();
                            ctx.arc(0, 0, corePulse * 2, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        };
                        break;
                    case "grenadeExplosion":
                        effect.maxLife = .5;
                        effect.radius = radius || 60;
                        effect.step = function (dt) { this.life -= 2 * dt; this.life <= 0 && (this.isActive = !1) };
                        effect.draw = function () {
                            // Make clusters more transparent, especially larger ones
                            const alphaScale = this.radius > 100 ? 0.25 : (this.radius > 70 ? 0.35 : 0.5);
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius * (1 - this.life), 0, 2 * Math.PI);
                            ctx.fillStyle = `rgba(255, 153, 51, ${alphaScale * this.life})`;
                            ctx.fill()
                        };
                        break;
                    case "shieldBreak": effect.maxLife = .6; effect.step = function (dt) { this.life -= 1.5 * dt; this.life <= 0 && (this.isActive = !1) }; effect.draw = function () { ctx.strokeStyle = `rgba(154, 102, 255, ${this.life})`; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(this.x, this.y, 24 * (1.5 - this.life), 0, 2 * Math.PI); ctx.stroke() }; break;
                    case "nanoHeal":
                        effect.maxLife = 0.7;
                        effect.step = function (dt) { this.life -= dt / this.maxLife; if (this.life <= 0) this.isActive = false; };
                        effect.draw = function () {
                            const p = 1 - this.life;
                            ctx.save();
                            ctx.translate(store.player.x, store.player.y);
                            ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                            ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                            ctx.stroke();
                            ctx.fill();
                            ctx.restore();
                        };
                        break;
                    case "jugFearIgnite":
                        effect.maxLife = 0.6;
                        effect.radius = radius || 40;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            const progress = 1 - this.life;
                            ctx.globalAlpha = 0.5 + 0.4 * Math.sin(performance.now() / 60);
                            ctx.fillStyle = 'rgba(255,80,40,0.6)';
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.7 + progress * 0.6), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 0.7;
                            ctx.fillStyle = 'rgba(255,200,120,0.5)';
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.4 + progress * 0.3), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        };
                        break;
                    case "jugFearEmber":
                        effect.maxLife = 0.4;
                        effect.radius = radius || 20;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            this.y -= 40 * dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.fillStyle = 'rgba(255,150,80,0.8)';
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.4 + 0.6 * this.life), 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        };
                        break;
                    case "marauderLaunchTrail":
                        const trailCfg = radius || {};
                        effect.maxLife = trailCfg.duration || 0.5;
                        effect.life = effect.maxLife;
                        effect.followEnemy = trailCfg.enemy || null;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.followEnemy) {
                                this.x = this.followEnemy.x;
                                this.y = this.followEnemy.y;
                            }
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                            ctx.strokeStyle = 'rgba(170, 209, 255, 0.7)';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, 30 * (1 + (1 - this.life / this.maxLife)), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "maraImpactShockwave":
                        effect.maxLife = 0.4;
                        effect.radius = radius || 45;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(150, 210, 255, 0.9)';
                            ctx.lineWidth = 6 - (5 * (1 - this.life));
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "armorCrackFlash":
                        effect.maxLife = 0.5;
                        effect.level = radius || 1;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(210, 240, 255, 0.8)';
                            ctx.lineWidth = 1.2;
                            for (let i = 0; i < 3 + this.level; i++) {
                                const angle = (i / (3 + this.level)) * Math.PI * 2;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                                ctx.stroke();
                            }
                            ctx.restore();
                        };
                        break;
                    case "fragmentBlast": {
                        const rand = (min, max) => Math.random() * (max - min) + min;
                        const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
                        const color = opts.color || '#FFD700';
                        const explosionCount = Math.max(0, Math.floor(opts.explosionCount ?? 15));
                        const splashCount = Math.max(0, Math.floor(opts.splashCount ?? 25));
                        const sourceX = Number.isFinite(opts.sourceX) ? opts.sourceX : x;
                        const sourceY = Number.isFinite(opts.sourceY) ? opts.sourceY : y;
                        const impactAngle = Number.isFinite(opts.impactAngle) ? opts.impactAngle : Math.atan2(y - sourceY, x - sourceX);
                        const travelDistance = Number.isFinite(opts.travelDistance) ? opts.travelDistance : Math.hypot(x - sourceX, y - sourceY);
                        const impactSpeed = Number.isFinite(opts.impactSpeed) ? opts.impactSpeed : 320;
                        effect.particles = [];

                        const createBaseParticle = (type, overrides = {}) => ({
                            type,
                            x,
                            y,
                            life: 0,
                            maxLife: overrides.maxLife ?? (type === 'stream' ? rand(34, 48) : rand(24, 36)),
                            alpha: 1,
                            color: overrides.color ?? color,
                            glowColor: overrides.glowColor ?? '#FFE7A3',
                            drag: overrides.drag ?? (type === 'stream' ? 0.94 : 0.9),
                            gravity: overrides.gravity ?? (type === 'stream' ? 0.16 : 0.08),
                            size: overrides.size ?? rand(2, 4),
                            rotation: overrides.rotation ?? impactAngle,
                            length: overrides.length ?? rand(20, 34),
                            thickness: overrides.thickness ?? rand(1.6, 2.8),
                            vx: overrides.vx ?? 0,
                            vy: overrides.vy ?? 0
                        });

                        // Jets push outward from impact direction to create a molten spray streak
                        const createDirectionalSplash = () => {
                            const spread = Math.PI / 7;
                            const offset = rand(-spread, spread);
                            const direction = impactAngle + offset;
                            const speedBoost = clamp(impactSpeed / 90, 2, 10);
                            const distanceBoost = clamp(travelDistance / 40, 0, 6);
                            const speed = rand(6, 10) + speedBoost + distanceBoost;
                            const lengthBase = clamp(travelDistance * 0.45, 26, 120) * rand(0.82, 1.1);
                            return createBaseParticle('stream', {
                                vx: Math.cos(direction) * speed,
                                vy: Math.sin(direction) * speed,
                                rotation: direction,
                                length: lengthBase,
                                thickness: rand(2, 3.6),
                                gravity: 0.12,
                                drag: 0.93,
                                glowColor: '#FFB347',
                                color: '#FFE59A',
                                maxLife: rand(32, 46)
                            });
                        };

                        const createMoltenEmber = () => {
                            const emberAngle = impactAngle + rand(-Math.PI * 0.4, Math.PI * 0.4);
                            const speed = rand(2.5, 6.5);
                            return createBaseParticle('ember', {
                                vx: Math.cos(emberAngle) * speed,
                                vy: Math.sin(emberAngle) * speed,
                                gravity: rand(0.04, 0.12),
                                drag: 0.88,
                                size: rand(1.8, 3.6),
                                glowColor: '#FFF2B8',
                                color: '#FFC857',
                                maxLife: rand(22, 34)
                            });
                        };

                        for (let i = 0; i < explosionCount; i++) {
                            effect.particles.push(createMoltenEmber());
                        }
                        for (let i = 0; i < splashCount; i++) {
                            effect.particles.push(createDirectionalSplash());
                        }

                        effect.step = function (dt) {
                            const frameFactor = dt > 0 ? dt * 60 : 0;
                            for (const particle of this.particles) {
                                particle.life += frameFactor;
                                particle.x += particle.vx * frameFactor;
                                particle.y += particle.vy * frameFactor;
                                if (particle.gravity) {
                                    particle.vy += particle.gravity * frameFactor;
                                }
                                if (particle.drag && particle.drag < 1) {
                                    const dragFactor = Math.pow(particle.drag, Math.max(frameFactor, 0));
                                    particle.vx *= dragFactor;
                                    particle.vy *= dragFactor;
                                }
                                if (particle.type === 'stream') {
                                    particle.length = Math.max(10, particle.length - frameFactor * 0.9);
                                    particle.thickness = Math.max(1, particle.thickness - frameFactor * 0.08);
                                }
                                const lifeRatio = particle.maxLife > 0 ? particle.life / particle.maxLife : 1;
                                particle.alpha = Math.max(0, 1 - lifeRatio);
                            }
                            this.particles = this.particles.filter(p => p.alpha > 0.02);
                            if (this.particles.length === 0) {
                                this.isActive = false;
                            }
                        };

                        effect.draw = function () {
                            if (!this.particles.length) return;
                            ctx.save();
                            ctx.globalCompositeOperation = 'lighter';
                            for (const particle of this.particles) {
                                const alpha = Math.min(1, Math.max(0, particle.alpha));
                                if (alpha <= 0) continue;
                                if (particle.type === 'stream') {
                                    ctx.save();
                                    ctx.translate(particle.x, particle.y);
                                    ctx.rotate(particle.rotation);
                                    ctx.globalAlpha = alpha * 0.9;
                                    const length = particle.length;
                                    const width = particle.thickness;
                                    const gradient = ctx.createLinearGradient(0, 0, length, 0);
                                    gradient.addColorStop(0, particle.glowColor);
                                    gradient.addColorStop(0.35, particle.color);
                                    gradient.addColorStop(1, 'rgba(255, 185, 70, 0)');
                                    ctx.fillStyle = gradient;
                                    ctx.beginPath();
                                    ctx.moveTo(0, -width * 0.5);
                                    ctx.lineTo(length, 0);
                                    ctx.lineTo(0, width * 0.5);
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.restore();
                                } else {
                                    ctx.globalAlpha = alpha * 0.7;
                                    ctx.fillStyle = particle.glowColor || particle.color;
                                    ctx.beginPath();
                                    ctx.arc(particle.x, particle.y, particle.size * 1.6, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.globalAlpha = alpha;
                                    ctx.fillStyle = particle.color;
                                    ctx.beginPath();
                                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            ctx.restore();
                        };
                        break;
                    }
                    case "demolitionPulseCharge":
                        effect.maxLife = 0.7;
                        effect.radius = radius || 40;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(255, 170, 90, 0.8)';
                            ctx.lineWidth = 2 + (1 - this.life) * 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1.2 - this.life * 0.4), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "voidLockChains":
                        effect.maxLife = 0.6;
                        effect.radius = radius || 45;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            const rotation = performance.now() / 200;
                            ctx.globalAlpha = 0.5 + 0.3 * this.life;
                            ctx.strokeStyle = 'rgba(140, 120, 255, 0.9)';
                            ctx.lineWidth = 3;
                            for (let i = 0; i < 4; i++) {
                                const angle = rotation + (i / 4) * Math.PI * 2;
                                ctx.beginPath();
                                ctx.moveTo(Math.cos(angle) * this.radius, Math.sin(angle) * this.radius);
                                ctx.lineTo(Math.cos(angle + Math.PI) * this.radius * 0.4, Math.sin(angle + Math.PI) * this.radius * 0.4);
                                ctx.stroke();
                            }
                            ctx.restore();
                        };
                        break;
                    case "stormDischarge":
                        effect.maxLife = 0.35;
                        effect.radius = radius || 60;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life * 0.8;
                            ctx.strokeStyle = 'rgba(110, 210, 255, 1)';
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1.1 - this.life * 0.4), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "empShockwave":
                        effect.maxLife = opts.duration ?? 0.6;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 220;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const outerRadius = this.radius * (0.4 + progress * 0.6);
                            const innerRadius = outerRadius * 0.65;
                            const alpha = Math.max(0, 0.6 * (1 - progress));

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';

                            ctx.strokeStyle = `rgba(110, 210, 255, ${alpha})`;
                            ctx.lineWidth = 6 * (1 - progress) + 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.setLineDash([8, 6]);
                            ctx.strokeStyle = `rgba(190, 140, 255, ${alpha * 0.8})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.fillStyle = `rgba(60, 160, 255, ${alpha * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, innerRadius * 0.75, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        };
                        break;
                    case "knockbackShockwave":
                        effect.maxLife = opts?.duration ?? 0.55;
                        effect.life = effect.maxLife;
                        effect.radius = radius || 260;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const progress = 1 - (this.life / this.maxLife);
                            const outerRadius = this.radius * (0.45 + progress * 0.55);
                            const innerRadius = outerRadius * 0.6;
                            const alpha = Math.max(0, 0.65 * (1 - progress));

                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';

                            ctx.strokeStyle = `rgba(120, 90, 255, ${alpha})`;
                            ctx.lineWidth = 7 * (1 - progress) + 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.setLineDash([6, 8]);
                            ctx.strokeStyle = `rgba(40, 20, 80, ${alpha * 0.9})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);

                            ctx.fillStyle = `rgba(20, 15, 40, ${alpha * 0.45})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, innerRadius * 0.7, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.restore();
                        };
                        break;
                    case "empStatic":
                        effect.maxLife = opts.duration ?? 0.35;
                        effect.radius = radius || 20;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const t = 1 - this.life;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.globalAlpha = Math.max(0, 0.8 * this.life);

                            ctx.fillStyle = `rgba(130, 210, 255, ${0.5 * this.life})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.6 + 0.5 * t), 0, Math.PI * 2);
                            ctx.fill();

                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * this.life})`;
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (0.35 + 0.4 * t), 0, Math.PI * 2);
                            ctx.stroke();

                            ctx.restore();
                        };
                        break;
                    case "stormArc":
                        const arcTarget = radius || { x, y };
                        effect.maxLife = 0.2;
                        effect.target = arcTarget;
                        effect.x = x;
                        effect.y = y;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(120, 220, 255, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            const controlX = (this.x + this.target.x) / 2 + (Math.random() - 0.5) * 30;
                            const controlY = (this.y + this.target.y) / 2 + (Math.random() - 0.5) * 30;
                            ctx.quadraticCurveTo(controlX, controlY, this.target.x, this.target.y);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "delayedFlamePulse":
                        effect.maxLife = 0.5;
                        effect.radius = radius || 90;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.globalAlpha = this.life;
                            ctx.strokeStyle = 'rgba(255, 150, 60, 0.8)';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * (1 + (1 - this.life) * 0.3), 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        };
                        break;
                    case "dotDamage":
                        effect.maxLife = opts.life ?? 0.55;
                        effect.life = effect.maxLife;
                        effect.text = opts.text || '';
                        effect.color = opts.color || '#ffffff';
                        effect.scale = opts.scale ?? 1;
                        effect.vx = opts.driftX ?? 0;
                        effect.vy = opts.riseSpeed ?? 42;
                        effect.step = function (dt) {
                            this.life -= dt;
                            this.y -= this.vy * dt;
                            this.x += this.vx * dt;
                            this.vy = Math.max(14, this.vy - 60 * dt);
                            this.vx *= 0.9;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            const remaining = Math.max(0, this.life / this.maxLife);
                            ctx.save();
                            ctx.globalAlpha = Math.pow(remaining, 0.8);
                            ctx.fillStyle = this.color;
                            ctx.font = `bold ${12 * this.scale}px Orbitron`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
                            ctx.shadowBlur = 6 * remaining;
                            ctx.fillText(this.text, this.x, this.y);
                            ctx.restore();
                        };
                        break;
                    case "critText":
                        effect.maxLife = 0.6;
                        effect.text = "CRITICAL!";
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            this.y -= 30 * dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                            ctx.font = 'bold 14px Orbitron';
                            ctx.textAlign = 'center';
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = 4;
                            ctx.fillText(this.text, this.x, this.y);
                            ctx.restore();
                        };
                        break;
                    case "bossPhaseChange":
                        effect.maxLife = 0.8;
                        effect.radius = 0;
                        effect.step = function (dt) { this.life -= dt / this.maxLife; if (this.life <= 0) this.isActive = false; this.radius += 600 * dt; };
                        effect.draw = function () {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                            ctx.lineWidth = 1 + 4 * this.life;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                            ctx.stroke();
                        };
                        break;
                    case "screenFlash":
                        effect.maxLife = y / 1000;
                        effect.life = effect.maxLife;
                        effect.color = radius;
                        effect.step = function (dt) {
                            this.life -= dt;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.globalAlpha = this.life / this.maxLife;
                            ctx.fillStyle = this.color;
                            ctx.fillRect(0, 0, W, H);
                            ctx.restore();
                        };
                        break;
                    case "timeRippleExplosion":
                        effect.maxLife = 0.8;
                        effect.radius = 0;
                        effect.maxRadius = 80;
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            this.radius = this.maxRadius * (1 - this.life);
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);

                            // Create time ripple effect with concentric circles
                            for (let i = 0; i < 3; i++) {
                                const rippleRadius = this.radius * (0.3 + i * 0.3);
                                const alpha = this.life * (1 - i * 0.2);

                                // Outer ripple ring
                                ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                                ctx.lineWidth = 3 - i;
                                ctx.beginPath();
                                ctx.arc(0, 0, rippleRadius, 0, 2 * Math.PI);
                                ctx.stroke();

                                // Inner glow
                                ctx.fillStyle = `rgba(150, 220, 255, ${alpha * 0.3})`;
                                ctx.beginPath();
                                ctx.arc(0, 0, rippleRadius * 0.8, 0, 2 * Math.PI);
                                ctx.fill();
                            }

                            // Central time distortion effect
                            const centerAlpha = this.life * 0.6;
                            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                            grad.addColorStop(0, `rgba(200, 240, 255, ${centerAlpha})`);
                            grad.addColorStop(0.7, `rgba(100, 200, 255, ${centerAlpha * 0.5})`);
                            grad.addColorStop(1, `rgba(50, 150, 255, 0)`);

                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
                            ctx.fill();

                            ctx.restore();
                        };
                        break;
                    case "lightningFlash":
                        effect.maxLife = 0.15; // Very short flash duration
                        effect.step = function (dt) {
                            this.life -= dt / this.maxLife;
                            if (this.life <= 0) this.isActive = false;
                        };
                        effect.draw = function () {
                            ctx.save();
                            ctx.translate(this.x, this.y);

                            // Calculate flash intensity based on remaining life
                            const intensity = Math.sin(this.life * Math.PI); // Sine wave for smooth fade
                            const alpha = intensity * 0.8;

                            // Outer blue glow
                            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                            grad.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                            grad.addColorStop(0.5, `rgba(50, 150, 255, ${alpha * 0.6})`);
                            grad.addColorStop(1, `rgba(30, 100, 255, 0)`);

                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                            ctx.fill();

                            // Inner bright white core
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, 8, 0, 2 * Math.PI);
                            ctx.fill();

                            // Electric sparks around the edge
                            for (let i = 0; i < 6; i++) {
                                const angle = (i / 6) * 2 * Math.PI + this.life * 10; // Rotate sparks
                                const sparkX = Math.cos(angle) * (20 + Math.random() * 10);
                                const sparkY = Math.sin(angle) * (20 + Math.random() * 10);

                                ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.7})`;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(sparkX * 0.7, sparkY * 0.7);
                                ctx.lineTo(sparkX, sparkY);
                                ctx.stroke();
                            }

                            ctx.restore();
                        };
                        break;
                }
                return effect
            }

            function spawnDotDamageText(target, amount, options = {}) {
                if (!target || !Number.isFinite(amount) || amount <= 0) return;
                const opts = options || {};
                const magnitude = Math.abs(amount);
                let formatted;
                if (magnitude >= 10) {
                    formatted = Math.round(magnitude).toString();
                } else if (magnitude >= 1) {
                    formatted = magnitude.toFixed(1).replace(/\.0$/, '');
                } else {
                    formatted = magnitude.toFixed(2).replace(/0+$/, '').replace(/\.$/, '.0');
                }
                const text = `-${formatted}`;
                const jitter = Number.isFinite(opts.jitter) ? opts.jitter : 8;
                const riseSpeed = Number.isFinite(opts.riseSpeed) ? opts.riseSpeed : 38 + Math.random() * 12;
                const driftX = Number.isFinite(opts.driftX) ? opts.driftX : (Math.random() - 0.5) * 22;
                const scale = Number.isFinite(opts.scale) ? opts.scale : 1;
                const life = Number.isFinite(opts.life) ? opts.life : 0.55;
                const offsetX = (opts.offsetX || 0) + (Math.random() - 0.5) * jitter;
                const offsetY = opts.offsetY || 0;
                const color = opts.color || '#ffb347';
                const baseX = (target.x ?? 0) + offsetX;
                const baseY = (target.y ?? 0) - (target.r || 18) + offsetY;
                store.activeEffects.push(createEffect('dotDamage', baseX, baseY, 0, {
                    text,
                    color,
                    scale,
                    riseSpeed,
                    driftX,
                    life
                }));
            }


            function explodeMine(mine) {
                playSound('explosion');
                const p = store.player;

                const numBullets = 18;
                for (let i = 0; i < numBullets; i++) {
                    const angle = (i / numBullets) * 2 * Math.PI;
                    const bulletSpeed = 300;
                    spawnBullet({
                        x: mine.x,
                        y: mine.y,
                        vx: Math.cos(angle) * bulletSpeed,
                        vy: Math.sin(angle) * bulletSpeed,
                        r: 3,
                        col: '#ff9966',
                        dmg: 20 * p.dmgMult,
                        pierce: false,
                        life: 0.28
                    });
                }

                const numFlames = 15;
                for (let i = 0; i < numFlames; i++) {
                    const angle = (Math.random() - 0.5) * 120 * Math.PI / 180;
                    const speed = 250 + Math.random() * 50;
                    spawnBullet({
                        x: mine.x,
                        y: mine.y,
                        vx: Math.sin(angle) * speed,
                        vy: -Math.cos(angle) * speed,
                        r: 3 + Math.random() * 2,
                        col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`,
                        dmg: 2 * p.dmgMult,
                        life: 0.3,
                        isFlame: true
                    });
                }

                store.activeEffects.push(createEffect("grenadeExplosion", mine.x, mine.y, 55));
            }

            const GOLD_REWARD_MULTIPLIER = 0.75;
            const XP_REWARD_MULTIPLIER = 0.75;

            function sanitizeGoldValue(value) {
                if (!Number.isFinite(value)) return 0;
                return Math.max(0, Math.round(value));
            }

            function getWorldGold() {
                const world = store.world || (store.world = {});
                world.gold = sanitizeGoldValue(world.gold);
                return world.gold;
            }

            function setWorldGold(value) {
                const world = store.world || (store.world = {});
                world.gold = sanitizeGoldValue(value);
                return world.gold;
            }

            function addWorldGold(delta = 0) {
                const world = store.world || (store.world = {});
                const current = sanitizeGoldValue(world.gold);
                const change = Number.isFinite(delta) ? delta : 0;
                const adjustedChange = change > 0 ? change * GOLD_REWARD_MULTIPLIER : change;
                const next = sanitizeGoldValue(current + adjustedChange);
                world.gold = next;
                return next;
            }

            let shopItemOrder = [...SHOP_DISPLAY_ORDER];

            const AUTO_FORGE_GLOBAL_FALLBACK_KEYS = Object.freeze([
                'luck_boost',
                'nano_save',
                'hp',
                'max_shield',
                'vampirism',
                'crit_chance',
                'speed',
                'dmg'
            ]);
            const AUTO_FORGE_MIN_DECISION_TIME = 2.9;
            const AUTO_FORGE_MAX_DECISION_TIME = 6.1;
            const AUTO_FORGE_REPAIR_WASTE_THRESHOLD = 0.82;

            function scheduleNextAutoForgeDecision(world, extraDelay = 0) {
                if (!world) return;
                const span = Math.max(0, AUTO_FORGE_MAX_DECISION_TIME - AUTO_FORGE_MIN_DECISION_TIME);
                const base = AUTO_FORGE_MIN_DECISION_TIME + (span > 0 ? Math.random() * span : 0);
                world.autoForgeDecisionTimer = base + (extraDelay || 0);
            }

            function getAffordableUpgrades(keys, gold, options = {}) {
                if (!Array.isArray(keys) || keys.length === 0) return [];
                const includeRestricted = !!options.includeRestricted;
                const seen = new Set();
                const results = [];
                for (const key of keys) {
                    if (seen.has(key)) continue;
                    seen.add(key);
                    const upgrade = SHOP_UPGRADES[key];
                    if (!upgrade) continue;
                    if (!includeRestricted && upgrade.autoForgeEligible === false) continue;
                    if (typeof upgrade.isVisible === 'function' && !upgrade.isVisible()) continue;
                    const info = getNextUpgradeCost(key);
                    if (!info || !Number.isFinite(info.cost)) continue;
                    if (info.available && gold >= info.cost) {
                        results.push({ key, info });
                    }
                }
                return results;
            }

            function rankAutoForgeCandidates(candidates, sortMode) {
                if (!Array.isArray(candidates) || candidates.length <= 1) return candidates;
                switch (sortMode) {
                    case 'cost-asc':
                        candidates.sort((a, b) => (a.info.cost ?? Infinity) - (b.info.cost ?? Infinity));
                        break;
                    case 'random':
                        candidates.sort(() => Math.random() - 0.5);
                        break;
                    default:
                        candidates.sort((a, b) => (b.info.cost ?? -Infinity) - (a.info.cost ?? -Infinity));
                        break;
                }
                return candidates;
            }

            function selectAutoForgeCandidate(candidates, pickMode) {
                if (!Array.isArray(candidates) || candidates.length === 0) return null;
                if (pickMode === 'random') {
                    return candidates[Math.floor(Math.random() * candidates.length)];
                }
                return candidates[0];
            }

            function pickMaximallySuboptimalUpgrade(gold) {
                if (!Number.isFinite(gold) || gold <= 0) return null;
                const player = store.player;
                if (!player) return null;

                const profile = getActiveAutoForgeProfile();
                const repairInfo = getNextUpgradeCost('repair');
                if (repairInfo && isFinite(repairInfo.cost) && gold >= repairInfo.cost) {
                    const hpRatio = player.hpMax > 0 ? player.hp / player.hpMax : 1;
                    const repairThreshold = profile && Number.isFinite(profile.repairThreshold)
                        ? profile.repairThreshold
                        : AUTO_FORGE_REPAIR_WASTE_THRESHOLD;
                    const repairCoinFlip = profile && Number.isFinite(profile.repairCoinFlip)
                        ? profile.repairCoinFlip
                        : 0.5;
                    if (hpRatio <= 0.35) {
                        return { key: 'repair', info: repairInfo, isFun: false, reason: 'criticalRepair' };
                    }
                    if (hpRatio >= repairThreshold || (hpRatio > 0.4 && Math.random() < repairCoinFlip)) {
                        return { key: 'repair', info: repairInfo, isFun: false, reason: 'doctrineRepair' };
                    }
                }

                const groups = profile?.groups || [];
                for (const group of groups) {
                    const candidates = getAffordableUpgrades(group.keys, gold, { includeRestricted: !!group.includeRestricted });
                    if (!candidates.length) continue;
                    rankAutoForgeCandidates(candidates, group.sort);
                    const chosen = selectAutoForgeCandidate(candidates, group.pick);
                    if (chosen) {
                        return {
                            key: chosen.key,
                            info: chosen.info,
                            isFun: !!group.isFun,
                            reason: `${profile?.id || 'profile'}:${group.reason || 'priority'}`
                        };
                    }
                }

                const fallbackKeys = profile?.fallback && profile.fallback.length
                    ? profile.fallback
                    : AUTO_FORGE_GLOBAL_FALLBACK_KEYS;
                const fallbackCandidates = getAffordableUpgrades(fallbackKeys, gold);
                if (fallbackCandidates.length) {
                    rankAutoForgeCandidates(fallbackCandidates, 'cost-desc');
                    const fallbackPick = fallbackCandidates[0];
                    if (fallbackPick) {
                        return {
                            key: fallbackPick.key,
                            info: fallbackPick.info,
                            isFun: false,
                            reason: `${profile?.id || 'profile'}:fallback`
                        };
                    }
                }

                const everything = getAffordableUpgrades(Object.keys(SHOP_UPGRADES), gold);
                if (everything.length) {
                    rankAutoForgeCandidates(everything, 'cost-desc');
                    const desperatePick = selectAutoForgeCandidate(everything, 'random');
                    if (desperatePick) {
                        return {
                            key: desperatePick.key,
                            info: desperatePick.info,
                            isFun: false,
                            reason: 'lastResort'
                        };
                    }
                }

                return null;
            }

            function getNextUpgradeCost(key) {
                const upgrade = SHOP_UPGRADES[key];
                if (!upgrade) return { cost: Infinity, available: false };
                const world = store.world || (store.world = {});
                const availableGold = getWorldGold();
                const player = store.player || {};

                if (typeof upgrade.getCost === 'function') {
                    const raw = upgrade.getCost();
                    if (!raw) {
                        return { cost: Infinity, available: false, premium: !!upgrade.isPremium };
                    }
                    const cost = Number.isFinite(raw.cost) ? raw.cost : Infinity;
                    const available = raw.available !== undefined ? !!raw.available : (Number.isFinite(cost) && availableGold >= cost);
                    return {
                        cost,
                        available,
                        premium: !!upgrade.isPremium,
                        detail: raw.detail,
                        meta: raw,
                        reason: raw.reason,
                        level: raw.level
                    };
                }
                if (upgrade.isPremium) {
                    if (key === 'repair') {
                        if (!player.hpMax || player.hp >= player.hpMax) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Health is already full.' };
                        }
                        return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                    }
                    if (key === 'vampirism') {
                        const currentLevel = player.vampirismLevel || 0;
                        if (currentLevel >= upgrade.max) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Max level reached.' };
                        }
                        const cost = 12 + (currentLevel * 5);
                        return { cost, available: availableGold >= cost, premium: true, level: currentLevel };
                    }
                    if (key === 'nano_save') {
                        if (player.nanoSaves >= upgrade.max) {
                            return { cost: Infinity, available: false, premium: true, reason: 'Max charges reached.' };
                        }
                        return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                    }
                    if (key === 'grenade') {
                        if (player.grenades >= upgrade.max) {
                            return { cost: Infinity, available: false, premium: true, reason: 'At maximum capacity.' };
                        }
                        return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                    }
                    if (key === 'knockback_shield') {
                        const currentCharges = store.knockbackCharges ? store.knockbackCharges.length : 0;
                        if (currentCharges >= (KNOCKBACK_SHIELD_CONFIG.maxCharges || upgrade.max || 3)) {
                            return { cost: Infinity, available: false, premium: true, reason: 'At maximum capacity.' };
                        }
                        return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                    }
                    if (upgrade.isUnlock) {
                        let alreadyUnlocked = false;
                        if (key === 'ricochet') {
                            const currentLevel = player.ricochetLevel || 0;
                            if ((upgrade.maxLevel && currentLevel >= upgrade.maxLevel) || (!upgrade.maxLevel && player.hasRicochet)) {
                                alreadyUnlocked = true;
                            }
                        } else {
                            alreadyUnlocked =
                                (key === 'gravity_well' && player.hasVoidBeam) ||
                                (key === 'lazarus_beam' && player.hasLazarusBeam) ||
                                (key === 'launcher' && player.hasLauncher) ||
                                (key === 'luck_boost' && player.luckBoost > 0) ||
                                (key === 'magnet_pull' && player.magnetRadius > 0) ||
                                (key === 'rear_guard' && player.hasRearGuard) ||
                                (key === 'ice_bullets' && player.hasIceBullets) ||
                                (key === 'poison_bullets' && player.hasPoisonBullets) ||
                                (key === 'fire_bullets' && player.hasFireBullets);
                        }
                        if (alreadyUnlocked) {
                            const reason = key === 'ricochet' ? 'Ricochet rounds fully upgraded.' : 'Already unlocked.';
                            return { cost: Infinity, available: false, premium: true, reason };
                        }
                    }
                    
                    // Handle premium items with level-based costs (iceman, ghost_hounds, etc.)
                    if (upgrade.baseCost && upgrade.scale && upgrade.maxLevel) {
                        const currentLevel = (player.upgradeLevels && player.upgradeLevels[key]) || 0;
                        if (currentLevel >= upgrade.maxLevel) {
                            return { cost: Infinity, available: false, premium: true, level: currentLevel, reason: 'Max level reached.' };
                        }
                        const cost = upgrade.increment
                            ? upgrade.baseCost + (currentLevel * upgrade.increment)
                            : Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                        return { cost, available: availableGold >= cost, premium: true, level: currentLevel };
                    }
                    
                    return { cost: upgrade.cost, available: availableGold >= upgrade.cost, premium: true };
                } else {
                    const currentLevel = (player.upgradeLevels && player.upgradeLevels[key]) || 0;
                    if (upgrade.maxLevel && currentLevel >= upgrade.maxLevel) {
                        return { cost: Infinity, available: false, level: currentLevel, reason: 'Max level reached.' };
                    }
                    const cost = upgrade.increment
                        ? upgrade.baseCost + (currentLevel * upgrade.increment)
                        : Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                    return { cost, available: availableGold >= cost, level: currentLevel };
                }
            }

            function attemptPurchaseUpgrade(key, options = {}) {
                const upgrade = SHOP_UPGRADES[key];
                if (!upgrade) return { success: false, cost: 0, key };

                let cost = 0;
                let success = false;

                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const info = getNextUpgradeCost(key);
                        if (isFinite(info.cost) && getWorldGold() >= info.cost) {
                            const prevGold = getWorldGold();
                            success = upgrade.apply();
                            if (success) {
                                const currentGold = getWorldGold();
                                cost = Math.max(0, prevGold - currentGold);
                            }
                        }
                    } else if (upgrade.baseCost && upgrade.scale && upgrade.maxLevel && upgrade.effect) {
                        // Handle leveled premium items (iceman, ghost_hounds, lazarus_beam, etc.)
                        const info = getNextUpgradeCost(key);
                        const isFree = options.free === true;
                        const canAfford = isFree || (info && info.available && Number.isFinite(info.cost) && getWorldGold() >= info.cost);
                        
                        if (canAfford) {
                            const currentLevel = (store.player.upgradeLevels && store.player.upgradeLevels[key]) || 0;
                            if (!isFree) {
                                addWorldGold(-info.cost);
                                cost = info.cost;
                            }
                            upgrade.effect(currentLevel);
                            if (!store.player.upgradeLevels) store.player.upgradeLevels = {};
                            store.player.upgradeLevels[key] = currentLevel + 1;
                            success = true;
                        }
                    } else {
                        const info = getNextUpgradeCost(key);
                        const isFree = options.free === true;
                        const canAfford = isFree || (info && info.available && Number.isFinite(info.cost) && getWorldGold() >= info.cost);
                        
                        if (canAfford) {
                            if (!isFree) {
                                addWorldGold(-info.cost);
                                cost = info.cost;
                            }
                            success = upgrade.apply(info);
                            if (!success && !isFree) {
                                addWorldGold(info.cost);
                                cost = 0;
                            }
                        }
                    }
                } else {
                    const info = getNextUpgradeCost(key);
                    const isFree = options.free === true;
                    const canAfford = isFree || (isFinite(info.cost) && getWorldGold() >= info.cost);
                    
                    if (canAfford) {
                        const currentLevel = store.player.upgradeLevels[key] || 0;
                        if (!isFree) {
                            addWorldGold(-info.cost);
                            cost = info.cost;
                        }
                        upgrade.effect(currentLevel);
                        store.player.upgradeLevels[key] = currentLevel + 1;
                        success = true;
                    }
                }

                if (success) {
                    if (!shopItemOrder.includes(key)) {
                        shopItemOrder.push(key);
                    }
                    store.world.totalForgeSpend = (store.world.totalForgeSpend || 0) + cost;
                    if (!options.silent) {
                        requestAnimationFrame(() => showShop());
                    }
                    // Play upgrade purchase sound
                    if (!options.silent) {
                        playSound('upgradePurchase');
                    }
                    if (typeof options.onSuccess === 'function') {
                        options.onSuccess({ key, upgrade, cost });
                    }
                }

                // Refresh champion dressing room if open and upgrade affects champion
                if (success && (key.includes('champion') || key === 'champion_health' || key === 'champion_damage' || key === 'champion_speed' || key === 'champion_shield' || key === 'champion_regen')) {
                    refreshPrimordialSoldierLaboratory();
                }

                return { success, cost, key, name: upgrade ? upgrade.name : key };
            }

            function setShopTutorialEnabled(enabled) {
                const normalized = !!enabled;
                store.settings.showShopTutorial = normalized;
                if (normalized) {
                    store.world.shopSpotlightDismissed = false;
                } else {
                    dismissShopSpotlight();
                }
                try {
                    if (window.localStorage) {
                        window.localStorage.setItem('voidShopTutorial', normalized ? 'on' : 'off');
                    }
                } catch (err) { }

                const toggle = q('shopTutorialToggle');
                if (toggle && toggle.checked !== normalized) {
                    toggle.checked = normalized;
                }

                const checkbox = q('shopTutorialDontShow');
                if (checkbox) {
                    checkbox.checked = !normalized;
                }
            }

            function showShopSpotlight(message, options = {}) {
                if (!store.settings.showShopTutorial && !options.force) return;
                if (store.world.shopSpotlightDismissed && !options.force) return;
                const container = q('shopSpotlight');
                const messageEl = q('shopSpotlightMessage');
                if (!container || !messageEl) return;

                if (message) {
                    store.ui.shopSpotlightMessage = message;
                }
                if (store.ui.shopSpotlightMessage) {
                    messageEl.textContent = store.ui.shopSpotlightMessage;
                }

                container.classList.remove('hide');
                store.ui.shopSpotlightActive = true;
                if (options.flashButton) {
                    const btn = q('shopBtn');
                    if (btn) {
                        btn.classList.add('mech-forge-pulse');
                    }
                }
            }

            function hideShopSpotlight() {
                const container = q('shopSpotlight');
                if (container) {
                    container.classList.add('hide');
                }
                store.ui.shopSpotlightActive = false;
            }

            function dismissShopSpotlight() {
                store.world.shopSpotlightDismissed = true;
                hideShopSpotlight();
            }

            function showShopTutorial(force = false, message) {
                if (!force) {
                    if (!store.settings.showShopTutorial) return;
                    if (store.world.shopTutorialShown) return;
                }
                const panel = q('shopTutorialPanel');
                if (!panel) return;
                pauseGame();
                panel.classList.remove('hide');
                const checkbox = q('shopTutorialDontShow');
                if (checkbox) {
                    checkbox.checked = !store.settings.showShopTutorial;
                }
                if (message) {
                    store.ui.shopSpotlightMessage = message;
                }
                store.world.shopTutorialShown = true;
            }

            function renderShopPowerupView(container) {
                if (!container) return;
                const player = store.player;
                if (!player) {
                    container.innerHTML = '<div class="shop-empty">Pilot telemetry unavailable.</div>';
                    return;
                }

                const timedEntries = Object.entries(player.powerupTimers || {}).filter(([key, timer]) => {
                    const type = POWERUP_TYPES[key];
                    if (!type || type.type !== 'timed') return false;
                    if (!timer) return false;
                    const remaining = Number(timer.remaining ?? 0);
                    return Number.isFinite(remaining) && remaining > 0.05;
                });

                const timedCards = timedEntries.map(([key, timer]) => {
                    const type = POWERUP_TYPES[key];
                    const remaining = Math.max(0, Number(timer.remaining ?? 0));
                    const maxRaw = Number(timer.max ?? timer.duration ?? remaining);
                    const max = Number.isFinite(maxRaw) && maxRaw > 0 ? maxRaw : Math.max(remaining, 1);
                    const pct = max > 0 ? clamp(Math.round((remaining / max) * 100), 0, 100) : 0;
                    const iconMarkup = type.svgIcon || (type.icon ? `<span class="powerup-icon powerup-icon--fallback">${type.icon}</span>` : '');
                    const nameMarkup = `<span class="shop-power-card-name">${type.name}</span>`;
                    return `<div class="shop-power-card">
    <div class="shop-power-card-title">${iconMarkup}${nameMarkup}</div>
    <div class="shop-power-card-meta">${Math.ceil(remaining)}s remaining</div>
    <div class="shop-power-bar"><span style="width:${pct}%;"></span></div>
</div>`;
                });

                const timedSection = timedCards.length
                    ? `<div class="shop-powerup-grid">${timedCards.join('')}</div>`
                    : '<div class="shop-empty-subtle">No timed powerups are currently active.</div>';

                const reserves = [];
                if (player.grenades > 0) reserves.push(`<li><strong>Shield Pulses</strong> â€¢ Charges: ${player.grenades}</li>`);
                if (player.knockbackShields > 0) reserves.push(`<li><strong>Knockback Shields</strong> â€¢ Charges: ${player.knockbackShields}</li>`);
                if (player.nanoSaves > 0) reserves.push(`<li><strong>Nano Saves</strong> â€¢ Emergency rewinds: ${player.nanoSaves}</li>`);
                if (player.hasLauncher) reserves.push('<li><strong>Fragment Launcher</strong> â€¢ Passive ordnance online</li>');
                if (player.hasHounds) reserves.push('<li><strong>Ghost Hounds</strong> â€¢ Spectral escorts deployed</li>');
                if (player.hasStormbringer) reserves.push('<li><strong>Stormbringer Arsenal</strong> â€¢ Storm grid discharges ready</li>');
                if (player.hasPhasestriker) reserves.push('<li><strong>Phasestriker Arsenal</strong> â€¢ Blink strikes primed</li>');
                if (player.missileVolley > 0) reserves.push(`<li><strong>Missile Salvos</strong> â€¢ Stored volleys: ${player.missileVolley}</li>`);
                if ((store.world?.collarStacks || 0) > 0) reserves.push(`<li><strong>Collar Charges</strong> â€¢ Stacks: ${store.world.collarStacks}</li>`);

                const reserveSection = reserves.length
                    ? `<ul class="shop-powerup-list">${reserves.join('')}</ul>`
                    : '<div class="shop-empty-subtle">No reserve systems stocked. Acquire upgrades to expand your arsenal.</div>';

                container.innerHTML = `
                    <div class="shop-power-section">
                        <h4>Active Powerups</h4>
                        <p>Monitor timed combat boosts currently affecting your fighter.</p>
                        ${timedSection}
                    </div>
                    <div class="shop-power-section">
                        <h4>Support Inventory</h4>
                        <p>Review reserve systems, charges, and passive modules standing by.</p>
                        ${reserveSection}
                    </div>
                `;
            }

            function closeShopTutorial({ dismiss = false, openShop = false } = {}) {
                const panel = q('shopTutorialPanel');
                if (panel) {
                    panel.classList.add('hide');
                }
                if (dismiss) {
                    setShopTutorialEnabled(false);
                } else if (store.settings.showShopTutorial) {
                    showShopSpotlight(store.ui.shopSpotlightMessage, { flashButton: true });
                }
                if (openShop) {
                    showShop();
                } else if (typeof isAnyPanelOpen === 'function') {
                    if (!isAnyPanelOpen()) {
                        resumeGame();
                    }
                } else {
                    resumeGame();
                }
            }

            function flashForgeButton(duration = 1200) {
                const mechForgeBtn = q('shopBtn');
                if (!mechForgeBtn) return;
                mechForgeBtn.classList.add('mech-forge-pulse');
                if (mechForgeBtn._forgePulseTimeout) {
                    clearTimeout(mechForgeBtn._forgePulseTimeout);
                }
                const timeoutId = setTimeout(() => {
                    mechForgeBtn.classList.remove('mech-forge-pulse');
                    mechForgeBtn._forgePulseTimeout = null;
                    store.world.mechForgePulseTimeout = null;
                }, duration);
                mechForgeBtn._forgePulseTimeout = timeoutId;
                store.world.mechForgePulseTimeout = timeoutId;

                const hudBtn = q('shopBtnHUD');
                if (hudBtn) {
                    hudBtn.classList.add('mech-forge-pulse');
                    if (hudBtn._forgePulseTimeout) {
                        clearTimeout(hudBtn._forgePulseTimeout);
                    }
                    const hudTimeout = setTimeout(() => {
                        hudBtn.classList.remove('mech-forge-pulse');
                        hudBtn._forgePulseTimeout = null;
                    }, duration);
                    hudBtn._forgePulseTimeout = hudTimeout;
                }

                showShopSpotlight(null, { flashButton: false });
            }

            function computeNextForgePromptInterval(currentInterval, promptCount) {
                const base = currentInterval || 250;
                const multiplier = 1.18 + Math.min(promptCount, 5) * 0.12;
                const scaled = Math.round(base * multiplier);
                return Math.max(250, Math.min(scaled, 2200));
            }

            function runAutoForge(dt) {
                const world = store.world;
                if (!world) return;

                world.autoForgeAnnounceCooldown = Math.max(0, (world.autoForgeAnnounceCooldown || 0) - dt);

                if (!world.autoForgeEnabled || store.isPaused || store.isGameOver) {
                    return;
                }

                const shopPanel = q('shopPanel');
                if (shopPanel && !shopPanel.classList.contains('hide')) return;
                if (typeof isAnyPanelOpen === 'function' && isAnyPanelOpen()) return;

                if (!store.player || store.player.hp <= 0) return;

                if (typeof world.autoForgeDecisionTimer !== 'number' || Number.isNaN(world.autoForgeDecisionTimer)) {
                    scheduleNextAutoForgeDecision(world);
                } else {
                    world.autoForgeDecisionTimer = Math.max(0, world.autoForgeDecisionTimer - dt);
                }

                if (world.autoForgeDecisionTimer > 0) {
                    return;
                }

                const gold = getWorldGold();
                if (!Number.isFinite(gold) || gold <= 0) {
                    scheduleNextAutoForgeDecision(world, 1.25);
                    return;
                }

                const decision = pickMaximallySuboptimalUpgrade(gold);
                if (!decision) {
                    scheduleNextAutoForgeDecision(world, 1.4);
                    return;
                }

                const purchases = [];
                const result = attemptPurchaseUpgrade(decision.key, { silent: true });
                if (result.success) {
                    result.isFun = !!decision.isFun;
                    result.reason = decision.reason;
                    purchases.push(result);
                }

                const hadPurchase = purchases.length > 0;
                const extraDelay = hadPurchase ? (purchases.some(p => p.isFun) ? 3.6 : 2.45) : 1.35;
                scheduleNextAutoForgeDecision(world, extraDelay);

                if (!hadPurchase) {
                    return;
                }

                const activeProfile = typeof getActiveAutoForgeProfile === 'function' ? getActiveAutoForgeProfile() : null;
                const doctrineName = activeProfile ? `${activeProfile.label} doctrine` : 'Auto-buy doctrine';

                if (!store.world.autoForgeTutorialShown) {
                    store.world.autoForgeTutorialShown = true;
                    announce(`Auto-buy online. ${activeProfile ? `${activeProfile.label} doctrine is now overseeing requisitions.` : 'Hangar logistics will monitor your loadout.'}`);
                } else if ((store.world.autoForgeAnnounceCooldown || 0) <= 0) {
                    const names = purchases.map(p => p.name).join(', ');
                    if (purchases.length === 1 && purchases[0].key === 'repair') {
                        announce(`${doctrineName} rerouted credits toward emergency repairs.`);
                    } else if (purchases.some(p => p.isFun)) {
                        announce(`${doctrineName} queued experimental modules: ${names}.`);
                    } else {
                        announce(`${doctrineName} acquired: ${names}.`);
                    }
                    store.world.autoForgeAnnounceCooldown = purchases.some(p => p.isFun) ? 5.5 : 4.2;
                }

                flashForgeButton(1100 + (purchases.some(p => p.isFun) ? 450 : 0));
            }

            function showShop(defaultView = 'upgrades') {
                pauseGame();
                const panel = q("shopPanel"),
                    grid = q("shopGrid"),
                    goldEl = q("shopgold"),
                    autoStatusEl = q('autoForgeStatusLabel'),
                    powerupView = q('shopPowerupView'),
                    upgradeView = q('shopUpgradeView'),
                    powerupTab = q('shopTabPowerups'),
                    upgradeTab = q('shopTabUpgrades'),
                    mobileToggle = q('shopMobileToggle'),
                    autoToggle = q('shopAutoToggle'),
                    gameMenuBtn = q('shopGameMenuBtn');

                const mechMenu = q('mechForgeMenuPanel');
                if (mechMenu) {
                    mechMenu.classList.add('hide');
                }

                goldEl.textContent = getWorldGold();
                if (autoStatusEl) {
                    autoStatusEl.textContent = getAutoForgeStatusText();
                }



                hideShopSpotlight();

                if (mobileToggle) {
                    mobileToggle.checked = document.body.classList.contains('mobile-controls-active');
                    mobileToggle.onchange = () => {
                        const enabled = !!mobileToggle.checked;
                        if (enabled) {
                            document.body.classList.add('mobile-controls-active');
                        } else {
                            document.body.classList.remove('mobile-controls-active');
                        }
                        try {
                            if (window.localStorage) {
                                window.localStorage.setItem('mobileControlsEnabled', enabled ? 'true' : 'false');
                            }
                        } catch (err) { }
                    };
                }

                if (autoToggle) {
                    autoToggle.checked = !!store.world.autoForgeEnabled;
                    autoToggle.onchange = () => {
                        const enabled = !!autoToggle.checked;
                        store.world.autoForgeEnabled = enabled;
                        store.world.autoForgeAnnounceCooldown = 0;
                        if (enabled) {
                            scheduleNextAutoForgeDecision(store.world, 0.75);
                        } else {
                            store.world.autoForgeDecisionTimer = null;
                        }
                        try {
                            if (window.localStorage) {
                                window.localStorage.setItem('voidAutoForge', enabled ? 'on' : 'off');
                            }
                        } catch (err) { }
                        const profile = getActiveAutoForgeProfile();
                        const statusMessage = enabled
                            ? `Auto-buy enabled. ${profile ? `${profile.label} doctrine engaged.` : 'Hangar logistics will handle repairs and resupply.'}`
                            : 'Auto-buy disabled. Route purchases through the Upgrade Hangar manually.';
                        if (typeof announce === 'function') {
                            announce(statusMessage);
                        }
                        updateAutoForgeStatusLabel();
                        updateAutoForgeProfileButtons();
                    };
                }

                if (gameMenuBtn) {
                    gameMenuBtn.onclick = () => {
                        panel.classList.add('hide');
                        showMechForgeMenu();
                    };
                }

                renderShopPowerupView(powerupView);

                const activateView = (view) => {
                    if (powerupView) powerupView.classList.toggle('hide', view !== 'powerups');
                    if (upgradeView) upgradeView.classList.toggle('hide', view !== 'upgrades');
                    if (powerupTab) powerupTab.classList.toggle('active', view === 'powerups');
                    if (upgradeTab) upgradeTab.classList.toggle('active', view === 'upgrades');
                    if (panel) panel.dataset.shopView = view;
                };

                if (powerupTab) powerupTab.onclick = () => activateView('powerups');
                if (upgradeTab) upgradeTab.onclick = () => activateView('upgrades');

                const normalizedView = defaultView === 'powerups' ? 'powerups' : 'upgrades';
                activateView(normalizedView);

                const rawItems = Object.keys(SHOP_UPGRADES)
                    .map(key => {
                        const upgrade = SHOP_UPGRADES[key];
                        if (!upgrade) return null;
                        if (typeof upgrade.isVisible === 'function' && !upgrade.isVisible()) return null;
                        return { key, upgrade };
                    })
                    .filter(Boolean);

                const currentItems = rawItems.map(item => ({ ...item, info: getNextUpgradeCost(item.key) }));

                const currentKeys = new Set(currentItems.map(item => item.key));
                shopItemOrder = shopItemOrder.filter(key => currentKeys.has(key));
                for (const predefinedKey of SHOP_DISPLAY_ORDER) {
                    if (currentKeys.has(predefinedKey) && !shopItemOrder.includes(predefinedKey)) {
                        shopItemOrder.push(predefinedKey);
                    }
                }
                currentItems.forEach(item => {
                    if (!shopItemOrder.includes(item.key)) {
                        shopItemOrder.push(item.key);
                    }
                });

                // Sort items: unlocked/maxed items go to bottom
                const shopItemsUnsorted = shopItemOrder
                    .map(key => currentItems.find(item => item && item.key === key))
                    .filter(Boolean);
                
                const availableItems = [];
                const unlockedItems = [];
                
                shopItemsUnsorted.forEach(item => {
                    const isMaxed = item.info && item.info.reason && 
                        (item.info.reason.includes('Max level') || 
                         item.info.reason.includes('Already unlocked') || 
                         item.info.reason.includes('fully upgraded'));
                    if (isMaxed) {
                        unlockedItems.push(item);
                    } else {
                        availableItems.push(item);
                    }
                });
                
                const shopItems = [...availableItems, ...unlockedItems];

                const buildCard = (entry) => {
                    const { key, upgrade, info } = entry;
                    const category = upgrade.category || 'utility';
                    const icon = upgrade.icon ?? 'ðŸ’ ';
                    const level = (store.player?.upgradeLevels && store.player.upgradeLevels[key]) || 0;
                    const name = typeof upgrade.getName === 'function' ? upgrade.getName(info, level) : upgrade.name;
                    let desc = typeof upgrade.desc === 'function' ? upgrade.desc(level, info) : upgrade.desc;
                    const costValue = info && Number.isFinite(info.cost) ? info.cost : upgrade.cost;
                    
                    // Check if this is a fully unlocked/maxed upgrade
                    const isMaxed = info && info.reason && 
                        (info.reason.includes('Max level') || 
                         info.reason.includes('Already unlocked') || 
                         info.reason.includes('fully upgraded'));
                    
                    // Special display for bullet types with sale price
                    const isBulletType = key === 'ice_bullets' || key === 'poison_bullets' || key === 'fire_bullets';
                    let costText;
                    if (isMaxed) {
                        costText = '<span class="unlocked-label">UNLOCKED</span>';
                    } else if (isBulletType && Number.isFinite(costValue)) {
                        const originalPrice = costValue * 2;
                        costText = `<span style="text-decoration: line-through; opacity: 0.6; font-size: 0.9em;">${originalPrice}</span> <span style="color: #4ade80; font-weight: bold; display: block;">50% OFF!</span> ${costValue}`;
                    } else {
                        costText = Number.isFinite(costValue) ? costValue : '---';
                    }
                    
                    const available = info ? !!info.available : (Number.isFinite(costValue) && (store.world?.gold ?? 0) >= costValue);
                    const isDisabled = !available;
                    if (isDisabled && info && info.reason && !isMaxed) {
                        desc = info.reason;
                    }
                    
                    const cardClasses = `skill-card shop-item ${isDisabled ? 'disabled' : ''} ${isMaxed ? 'unlocked' : ''} shop-item-${category}`;
                    
                    return `<div class="${cardClasses}" data-key="${key}">
                <div class="skill-icon">${icon}</div>
                <div>
                    <div class="skill-title">${name || ''}</div>
                    <div class="skill-desc">${desc || ''}</div>
                </div>
                <div class="shop-item-cost">${isMaxed ? '' : 'Cost: '}${costText}</div>
            </div>`;
                };

                const playerCards = [];

                for (const entry of shopItems) {
                    if (entry.upgrade?.category === 'champion') {
                        // Champion upgrades moved to Primordial Soldier Laboratory
                        continue;
                    } else {
                        playerCards.push(buildCard(entry));
                    }
                }

                const renderSection = (title, subtitle, cards, extraClass = '') => {
                    if (!cards.length) return '';
                    const headerSubtitle = subtitle ? `<p class="shop-section-subtitle">${subtitle}</p>` : '';
                    return `<div class="shop-section ${extraClass}">
                <div class="shop-section-header">
                    <h3 class="shop-section-title">${title}</h3>
                    ${headerSubtitle}
                </div>
                <div class="shop-section-grid">${cards.join('')}</div>
            </div>`;
                };

                const sections = [];
                sections.push(renderSection('Pilot Systems', 'Enhance your fighter and core modules.', playerCards));
                // Champion Arsenal section removed - moved to Primordial Soldier Laboratory

                if (sections.filter(Boolean).length === 0) {
                    grid.innerHTML = '<div class="shop-empty">No upgrades available right now.</div>';
                } else {
                    grid.innerHTML = sections.filter(Boolean).join('');
                }
                grid.querySelectorAll(".shop-item").forEach(item => {
                    let isProcessing = false;
                    item.addEventListener("click", async () => {
                        // Prevent double-clicks that can cause WebGL context loss
                        if (isProcessing) {
                            console.log('âš ï¸ Purchase already in progress, ignoring double-click');
                            return;
                        }
                        
                        if (item.classList.contains('disabled') || item.classList.contains('unlocked')) return;
                        
                        isProcessing = true;
                        item.style.pointerEvents = 'none'; // Disable temporarily
                        
                        try {
                            const key = item.dataset.key;
                            attemptPurchaseUpgrade(key);
                        } finally {
                            // Re-enable after a short delay
                            setTimeout(() => {
                                isProcessing = false;
                                item.style.pointerEvents = '';
                            }, 300);
                        }
                    })
                });

                panel.classList.remove("hide");
                enterPanel('shopPanel');
            }

            function showMechForgeMenu() {
                pauseGame();
                const panel = q("mechForgeMenuPanel");

                const tutorialToggle = q('shopTutorialToggle');
                if (tutorialToggle) {
                    tutorialToggle.checked = !!store.settings.showShopTutorial;
                    tutorialToggle.onchange = () => {
                        const enabled = !!tutorialToggle.checked;
                        setShopTutorialEnabled(enabled);
                        if (enabled) {
                            showShopSpotlight('Upgrade Hangar alerts reactivated.', { flashButton: true, force: true });
                        }
                    };
                }

                ensureAutoForgeProfileGrid();
                updateAutoForgeProfileButtons();

                // Enable/disable skill tree button based on subclass
                const skillTreeBtn = q('openSkillTreeReadonly');
                if (skillTreeBtn) {
                    const hasSubclass = store.player && store.player.subclass;
                    skillTreeBtn.disabled = !hasSubclass;
                    if (!hasSubclass) {
                        skillTreeBtn.querySelector('.forge-menu-desc').textContent = 'Select a specialization first';
                    } else {
                        skillTreeBtn.querySelector('.forge-menu-desc').textContent = 'Review specialization progress';
                    }
                }
                if (CHAMPION_SYSTEM_ENABLED) {
                    updateChampionQuickStatus();

                    const player = store.player;
                    const isChampionUnlocked = player && player.championUnlocked;

                    const labMenuBtn = q('openPrimordialLabFromMenu');
                    if (labMenuBtn) {
                        labMenuBtn.disabled = !isChampionUnlocked;
                        labMenuBtn.setAttribute('aria-disabled', isChampionUnlocked ? 'false' : 'true');
                    }

                    const championPreviewBtn = q('openChampionDressingRoom');
                    if (championPreviewBtn) {
                        if (isChampionUnlocked) {
                            championPreviewBtn.classList.remove('hide');
                        } else {
                            championPreviewBtn.classList.add('hide');
                        }
                    }
                } else {
                    const championPreviewBtn = q('openChampionDressingRoom');
                    if (championPreviewBtn) {
                        championPreviewBtn.classList.add('hide');
                    }
                    const labMenuBtn = q('openPrimordialLabFromMenu');
                    if (labMenuBtn) {
                        labMenuBtn.disabled = true;
                        labMenuBtn.setAttribute('aria-disabled', 'true');
                    }
                    const quickStatus = q('championQuickStatus');
                    if (quickStatus) {
                        quickStatus.classList.add('locked');
                        quickStatus.textContent = 'Champion systems offline.';
                    }
                }

                panel.classList.remove("hide");
                enterPanel('mechForgeMenuPanel');
            }

            function showCharacterSheet() {
                pauseGame();
                const panel = q("characterSheetPanel");
                const body = q("characterSheetBody");

                if (body) {
                    renderCharacterSheet(body);
                }

                panel.classList.remove("hide");
                enterPanel('characterSheetPanel');
            }

            function showSkillTreeReadonly() {
                if (!store.player || !store.player.subclass) {
                    announce('Select a specialization first!');
                    return;
                }

                // Use the existing skill tree modal system but mark it as read-only from forge
                showSkillTreeModal(true);

                // Update the title to indicate it's read-only after the modal opens
                setTimeout(() => {
                    const panel = q("subclassPanel");
                    if (panel) {
                        const title = panel.querySelector('h2');
                        if (title) {
                            title.textContent = `â­ ${store.player.subclass.toUpperCase()} SKILL TREE (VIEW-ONLY)`;
                        }
                        // Disable all skill buttons to make it truly read-only
                        const skillButtons = panel.querySelectorAll('.skill-icon-button, .skill-card');
                        skillButtons.forEach(btn => {
                            btn.style.pointerEvents = 'none';
                            btn.style.opacity = '0.8';
                        });
                    }
                }, 50);
            }

            function renderCharacterSheet(container) {
                if (!container) {
                    return;
                }

                const player = store.player || {};
                const world = store.world || {};
                const gold = getWorldGold();

                const toNumber = (value, fallback = 0) => {
                    const num = Number(value);
                    return Number.isFinite(num) ? num : fallback;
                };

                const fmt = (value, digits = 2) => {
                    const num = toNumber(value);
                    return num.toFixed(digits);
                };

                const pct = (value, digits = 1) => {
                    const num = toNumber(value);
                    return (num * 100).toFixed(digits) + '%';
                };

                const escapeHtml = (value) => {
                    if (value === undefined || value === null) return '';
                    return String(value)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                };

                const getSkillTreeContext = () => {
                    if (typeof getActiveSubclassAndTree !== 'function') {
                        return { subclass: player.subclass || null, treeData: null };
                    }
                    const { subclass, treeData } = getActiveSubclassAndTree();
                    return { subclass, treeData };
                };

                const { subclass, treeData } = getSkillTreeContext();
                const genomeName = player.pilotGenome ? player.pilotGenome.toUpperCase() : 'PENDING';

                // Only show subclass if actually selected, not just from tree data
                const actualSubclass = player.subclass;
                let subclassDisplay;
                if (actualSubclass && treeData && treeData.title) {
                    subclassDisplay = treeData.title.replace(' MASTERY TREE', '').toUpperCase();
                } else if (actualSubclass) {
                    subclassDisplay = actualSubclass.toUpperCase();
                } else {
                    subclassDisplay = 'PENDING SELECTION';
                }

                const summaryLines = [
                    `GENOME ROUTE â–¸ ${genomeName} âžœ ${subclassDisplay}`,
                    `MISSION STATUS â–¸ W${pad(world.wave || 1)} | LV ${pad(world.level || 1)} | BOSSES ${pad(world.bosses || 0)} | KILLS ${pad(world.kills || 0, 3)}`,
                    `FORGE LEDGER â–¸ GOLD ${pad(gold, 4)} | XP ${pad(world.xp || 0, 4)} | SCORE ${pad(world.score || 0, 6)}`,
                    `PROGRESSION â–¸ TOTAL ${pad(player.totalProgressionPoints || 0)} | SPENT ${pad(player.skillPointsSpent || 0)} | UNSPENT ${pad(player.unspentProgressionPoints || 0)}`
                ];

                // Only show skill matrix if subclass is actually selected
                const skillMatrixData = actualSubclass ? computeSkillMatrix(treeData, player, subclassDisplay) : null;
                if (skillMatrixData && skillMatrixData.laneSummaries.length) {
                    skillMatrixData.laneSummaries.forEach(line => summaryLines.push(line));
                }

                const sections = [];
                sections.push(renderSummarySection(summaryLines));

                const coreRows = [
                    {
                        key: 'Hull Integrity',
                        value: `${pad(toNumber(player.hp || 0), 3)}/${pad(toNumber(player.hpMax || player.hp || 0), 3)}`,
                        detail: player.damageReduction ? `Damage Reduction ${pct(player.damageReduction)} â€¢ Knockback ${player.knockbackImmunity ? 'Immune' : 'Normal'}` : null
                    },
                    {
                        key: 'Shield Matrix',
                        value: `${pad(toNumber(player.shield || 0), 3)}/${pad(toNumber(player.shieldMax || 0), 3)}`,
                        detail: player.shieldRechargeDelayMax ? `Recharge Delay ${fmt(player.shieldRechargeDelayMax, 2)}s` : null
                    },
                    {
                        key: 'Beef Shield',
                        value: player.beefShieldMax > 0 ? `${pad(Math.floor(player.beefShield || 0), 3)}/${pad(Math.floor(player.beefShieldMax), 3)}` : 'LOCKED',
                        detail: player.beefShieldMax > 0 ? `Regen ${fmt(player.beefShieldRegenRate || 5, 1)}/s â€¢ Cooldown ${fmt(player.beefShieldCooldown || 0, 1)}s` : 'Unlock via Beef class skill tree'
                    },
                    {
                        key: 'Velocity',
                        value: `${pad(toNumber(player.speed || 0), 3)}`,
                        detail: `Magnet ${pad(toNumber(player.magnetRadius || 0), 3)} â€¢ Luck ${pct(player.luckBoost || 0)}`
                    },
                    {
                        key: 'Safety Net',
                        value: `Nano ${pad(player.nanoSaves || 0)} â€¢ Vamp ${pct(player.vampirism || 0)}`,
                        detail: `Shield Pulses ${pad(player.grenades || 0)} â€¢ Knockback ${pad(player.knockbackShields || 0)} â€¢ Collar ${pad(world.collarStacks || 0)}`
                    }
                ];
                sections.push(renderGridSection('Core Systems', coreRows));

                const fireRate = toNumber(player.fireRate || 0);
                const shotsPerSecond = fireRate > 0 ? 1 / fireRate : 0;
                const offenseRows = [
                    {
                        key: 'Damage Suite',
                        value: `x${fmt(player.dmgMult || 1, 2)}`,
                        detail: `Crit ${pct(player.critChance || 0)} | Crit Dmg x${fmt(player.critDamage || 1.5, 2)}`
                    },
                    {
                        key: 'Volley Matrix',
                        value: `${fmt(shotsPerSecond, 1)} /s`,
                        detail: `Projectiles ${pad(player.multishot || 1)} â€¢ Pierce ${pad(player.piercing || player.missilePierce || 0)}`
                    },
                    {
                        key: 'Arsenal',
                        value: `Missiles ${pad(player.missileVolley || 0)} â€¢ Shield Pulses ${pad(player.grenades || 0)} â€¢ Knockback ${pad(player.knockbackShields || 0)}`,
                        detail: `Fragment Launcher ${player.hasLauncher ? 'ONLINE' : 'LOCKED'} â€¢ Lazarus ${player.hasLazarusBeam ? 'ONLINE' : 'LOCKED'}`
                    },
                    {
                        key: 'Special Ammo',
                        value: `Storm ${player.hasStormbringer ? 'ONLINE' : 'LOCKED'} â€¢ Phase ${player.hasPhasestriker ? 'ONLINE' : 'LOCKED'}`,
                        detail: player.hasBlink ? `Blink ${player.autoBlinkEnabled ? 'AUTO' : 'MANUAL'}` : 'Blink locked'
                    },
                    {
                        key: 'Special Weapons',
                        value: `Star Cannon ${player.starCannonLevel ? `MK${player.starCannonLevel}` : 'LOCKED'}`,
                        detail: `Gravity Well ${player.hasVoidBeam ? 'ONLINE' : 'LOCKED'} â€¢ Iceman ${player.hasIceman ? 'ACTIVE' : 'LOCKED'}`
                    },
                    {
                        key: 'Beef Class',
                        value: player.beefMaxCharges > 0 ? `Charges ${player.beefCharges || 0}/${player.beefMaxCharges}` : 'N/A',
                        detail: player.beefMaxCharges > 0 ? `Chain Mode ${player.beefChainMode ? 'ON' : 'OFF'} â€¢ Elite Combat ${player.beefEliteCombat ? 'ON' : 'OFF'}` : null
                    },
                    {
                        key: 'Rocketman Class',
                        value: player.missilePierce > 0 || player.missileCluster ? `Pierce ${player.missilePierce || 0} â€¢ Cluster ${player.missileCluster ? 'ON' : 'OFF'}` : 'N/A',
                        detail: player.missileClusterCount ? `Cluster Count ${player.missileClusterCount} â€¢ Radius x${fmt(player.missileClusterRadius || 1, 1)}` : null
                    }
                ];
                sections.push(renderGridSection('Offensive Matrix', offenseRows));

                const economyRows = [
                    {
                        key: 'Resources',
                        value: `Gold ${pad(gold, 4)} â€¢ XP ${pad(world.xp || 0, 4)}`,
                        detail: `Score ${pad(world.score || 0, 6)} â€¢ Threat ${fmt(world.lastThreatScale || 1, 2)}`
                    },
                    {
                        key: 'Boss Progress',
                        value: `Bosses ${pad(world.bosses || 0)} â€¢ Wave ${pad(world.wave || 1)}`,
                        detail: `Kills ${pad(world.kills || 0, 4)} â€¢ XP Mult ${fmt(world.xpMultiplier || 1, 2)}`
                    }
                ];
                sections.push(renderGridSection('Economy & Progress', economyRows));

                const forgeUpgrades = buildForgeUpgradeList(player);
                sections.push(renderListSection('Forge Upgrades', forgeUpgrades, 'No forge upgrades purchased yet.'));

                const systemList = buildSystemList(player);
                sections.push(renderListSection('Active Systems', systemList, 'No special systems online.'));

                if (skillMatrixData) {
                    sections.push(renderSkillMatrixSection(skillMatrixData));
                    if (skillMatrixData.powerSummaries.length) {
                        sections.push(renderListSection('Power Summary', skillMatrixData.powerSummaries));
                    }
                }

                const learnedSkillList = buildLearnedSkillList(player);
                if (learnedSkillList.length) {
                    sections.push(renderListSection('Unlocked Skills', learnedSkillList));
                }

                const calibrationList = buildCalibrationList(player);
                if (calibrationList.length) {
                    sections.push(renderListSection('Calibrations', calibrationList));
                }

                const championSection = renderChampionSection();
                if (championSection) {
                    sections.push(championSection);
                }

                // Add diagnostic section
                sections.push(renderDiagnosticsSection());

                container.innerHTML = sections.join('');

                function renderDiagnosticsSection() {
                    const now = performance.now();
                    const sessionTime = world.gameStartTime ? ((now - world.gameStartTime) / 1000).toFixed(1) : '0.0';
                    const timeSinceLastFrame = store.last ? ((now - store.last) / 1000).toFixed(3) : '0.000';
                    
                    // Count active game objects
                    const bulletCount = (store.bullets || []).length;
                    const enemyCount = (store.enemies || []).length;
                    const fragmentCount = (store.fragmentProjectiles || []).length;
                    const eBulletCount = (store.eBullets || []).length;
                    const powerupCount = (store.powerups || []).length;
                    const droneCount = (store.drones || []).length;
                    const missileCount = (store.missiles || []).length;
                    const mineCount = (store.mines || []).length;
                    const laserCount = (store.lasers || []).length;
                    const championMinionCount = (store.championMinions || []).filter(m => m && !m.dead).length;
                    
                    // Performance metrics
                    const fps = window.perfFPS || 0;
                    const frameTime = window.performanceMetrics?.frameTime?.toFixed(2) || '0.00';
                    const memoryMB = window.performanceMetrics?.memoryUsage?.toFixed(1) || 'N/A';
                    
                    // Game state flags
                    const isPaused = store.isPaused ? 'YES' : 'NO';
                    const isGameOver = store.isGameOver ? 'YES' : 'NO';
                    const autoForge = world.autoForgeEnabled ? 'ON' : 'OFF';
                    
                    // PixiJS state
                    const pixiActive = (window.pixiApp && window.pixiApp.renderer) ? 'ONLINE' : 'OFFLINE';
                    const activeBulletSprites = window.activeBulletSprites?.size || 0;
                    const bulletSpritePoolSize = window.bulletSpritePool?.length || 0;
                    
                    // WebGL context state
                    const webglLost = window.webglContextLost ? 'YES âš ï¸' : 'NO';
                    const webglRecoveries = window.webglRecoveryAttempts || 0;
                    let webglContextStatus = 'Unknown';
                    if (window.pixiApp && window.pixiApp.renderer && window.pixiApp.renderer.gl) {
                        const gl = window.pixiApp.renderer.gl;
                        if (gl.isContextLost && gl.isContextLost()) {
                            webglContextStatus = 'LOST âš ï¸';
                        } else {
                            webglContextStatus = 'HEALTHY âœ“';
                        }
                    }
                    
                    // Mobile-specific diagnostics
                    const isVisible = !document.hidden ? 'YES' : 'NO';
                    const devicePixelRatio = (window.devicePixelRatio || 1).toFixed(2);
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    
                    const diagnosticRows = [
                        {
                            key: 'Game State',
                            value: `Paused: ${isPaused} | Over: ${isGameOver}`,
                            detail: `Session Time: ${sessionTime}s | Frame Delta: ${timeSinceLastFrame}s`
                        },
                        {
                            key: 'Visibility',
                            value: `Page Visible: ${isVisible}`,
                            detail: `Viewport: ${viewportWidth}x${viewportHeight} | DPR: ${devicePixelRatio}`
                        },
                        {
                            key: 'Performance',
                            value: `FPS: ${fps} | Frame: ${frameTime}ms`,
                            detail: `Memory: ${memoryMB}MB | Auto-Forge: ${autoForge}`
                        },
                        {
                            key: 'Player Objects',
                            value: `Bullets: ${bulletCount} | Fragments: ${fragmentCount}`,
                            detail: `Drones: ${droneCount} | Missiles: ${missileCount} | Mines: ${mineCount}`
                        },
                        {
                            key: 'Enemy Objects',
                            value: `Enemies: ${enemyCount} | E-Bullets: ${eBulletCount}`,
                            detail: `Lasers: ${laserCount} | Powerups: ${powerupCount}`
                        },
                        {
                            key: 'Champion',
                            value: store.playerChampion ? `Active (L${store.playerChampion.level || 1})` : 'Offline',
                            detail: `Minions: ${championMinionCount} | Module: ${player.championUpgrades?.attackModule || 'default'}`
                        },
                        {
                            key: 'PixiJS Renderer',
                            value: pixiActive,
                            detail: `Bullet Sprites: ${activeBulletSprites} active | ${bulletSpritePoolSize} pooled`
                        },
                        {
                            key: 'WebGL Context',
                            value: webglContextStatus,
                            detail: `Context Lost: ${webglLost} | Recovery Attempts: ${webglRecoveries}`
                        },
                        {
                            key: 'Last Event',
                            value: window._lastBackgroundEvent || 'None',
                            detail: window._lastBackgroundTime ? `At ${new Date(window._lastBackgroundTime).toLocaleTimeString()}` : 'N/A'
                        }
                    ];

                    // Generate full diagnostic export button and textarea
                    const fullDiagnostics = generateFullDiagnostics();
                    const diagnosticExport = `
                        <div style="margin-top: 12px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px;">
                            <div style="margin-bottom: 8px; font-size: 13px; color: #ffeb3b; font-weight: bold;">
                                ðŸ“‹ FULL DIAGNOSTICS (Copy & Share for Mobile Debug)
                            </div>
                            <button id="generateDiagnosticsBtn" style="
                                width: 100%;
                                padding: 10px;
                                margin-bottom: 8px;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                border: none;
                                border-radius: 4px;
                                font-size: 14px;
                                font-weight: bold;
                                cursor: pointer;
                                font-family: 'Orbitron', sans-serif;
                            " onclick="
                                const textarea = document.getElementById('diagnosticOutput');
                                const btn = this;
                                const fullDiag = window.getPixiDiagnostics ? window.getPixiDiagnostics() : ${JSON.stringify(fullDiagnostics)};
                                textarea.value = JSON.stringify(fullDiag, null, 2);
                                textarea.style.display = 'block';
                                textarea.select();
                                try {
                                    document.execCommand('copy');
                                    btn.textContent = 'âœ“ COPIED TO CLIPBOARD!';
                                    setTimeout(() => { btn.textContent = 'ðŸ“‹ GENERATE & COPY DIAGNOSTICS'; }, 2000);
                                } catch(e) {
                                    btn.textContent = 'ðŸ“‹ DIAGNOSTICS GENERATED - SELECT ALL & COPY';
                                    setTimeout(() => { btn.textContent = 'ðŸ“‹ GENERATE & COPY DIAGNOSTICS'; }, 3000);
                                }
                            ">ðŸ“‹ GENERATE & COPY DIAGNOSTICS</button>
                            <textarea id="diagnosticOutput" readonly style="
                                width: 100%;
                                height: 200px;
                                padding: 8px;
                                font-family: 'Courier New', monospace;
                                font-size: 11px;
                                background: #000;
                                color: #0f0;
                                border: 1px solid #0f0;
                                border-radius: 4px;
                                resize: vertical;
                                display: none;
                            "></textarea>
                            <div style="margin-top: 8px; font-size: 11px; color: #aaa; line-height: 1.4;">
                                <strong>Instructions:</strong> Tap "Generate & Copy" button, then paste diagnostics into a message/email to share.
                                If copy fails, manually select all text in the box and copy it.
                            </div>
                        </div>
                    `;

                    return renderGridSection('ðŸ”§ System Diagnostics', diagnosticRows, 
                        'Live diagnostic data for troubleshooting. Check this panel if the game freezes or behaves unexpectedly.') + diagnosticExport;
                }
                
                function generateFullDiagnostics() {
                    // Same data structure as window.getPixiDiagnostics()
                    const now = performance.now();
                    const sessionTime = world.gameStartTime ? ((now - world.gameStartTime) / 1000).toFixed(1) : '0.0';
                    
                    return {
                        currentTime: new Date().toISOString(),
                        sessionTime: sessionTime + 's',
                        userAgent: navigator.userAgent,
                        viewport: {
                            width: window.innerWidth,
                            height: window.innerHeight,
                            devicePixelRatio: window.devicePixelRatio,
                            orientation: window.screen?.orientation?.type || 'unknown'
                        },
                        webgl: {
                            contextLost: window.webglContextLost || false,
                            recoveryAttempts: window.webglRecoveryAttempts || 0,
                            lastContextLossInfo: window._lastWebGLContextLossInfo || 'Never occurred',
                            lastContextRestoredInfo: window._lastWebGLContextRestoredInfo || 'Never occurred',
                            lastRebuildError: window._lastPixiRebuildError || 'No errors',
                            lastRebuildLog: window._lastPixiRebuildLog || 'No build log'
                        },
                        pixi: {
                            appExists: !!window.pixiApp,
                            rendererExists: !!window.pixiApp?.renderer,
                            hasGL: !!window.pixiApp?.renderer?.gl,
                            bulletTexturesGenerated: Object.keys(window.bulletTextures || {}).length,
                            spritePoolsActive: {
                                activeBulletSprites: window.activeBulletSprites?.size || 0,
                                bulletSpritePool: window.bulletSpritePool?.length || 0,
                                activeParticleSprites: window.activeParticleSprites?.size || 0,
                                particleSpritePool: window.particleSpritePool?.length || 0
                            }
                        },
                        canvas: {
                            exists: !!window.cvs,
                            hasContext: !!window.ctx,
                            scaleX: window.canvasScaleX,
                            scaleY: window.canvasScaleY,
                            width: window.cvs?.width,
                            height: window.cvs?.height,
                            cssWidth: window.cvs?.style.width,
                            cssHeight: window.cvs?.style.height
                        },
                        game: {
                            isPaused: store?.isPaused,
                            isGameOver: store?.isGameOver,
                            wave: store?.wave,
                            bulletCount: store?.bullets?.length || 0,
                            enemyCount: store?.enemies?.length || 0,
                            fragmentCount: store?.fragmentProjectiles?.length || 0,
                            eBulletCount: store?.eBullets?.length || 0,
                            droneCount: store?.drones?.length || 0,
                            missileCount: store?.missiles?.length || 0,
                            playerHp: store?.player?.hp,
                            playerMaxHp: store?.player?.hpMax,
                            playerSubclass: store?.player?.subclass
                        },
                        performance: {
                            fps: window.perfFPS || 0,
                            frameTime: window.performanceMetrics?.frameTime?.toFixed(2) || '0.00',
                            memoryUsageMB: window.performanceMetrics?.memoryUsage?.toFixed(1) || 'N/A'
                        },
                        events: {
                            lastBackgroundEvent: window._lastBackgroundEvent || 'None',
                            lastBackgroundTime: window._lastBackgroundTime ? new Date(window._lastBackgroundTime).toISOString() : 'N/A',
                            pageVisible: !document.hidden
                        }
                    };
                }

                function renderSummarySection(lines) {
                    if (!lines || !lines.length) return '';
                    return `
                <div class="intel-section">
                    <div class="intel-title">Route Overview</div>
                    <div class="intel-summary">
                        ${lines.map(line => `<div class="intel-summary-line">${escapeHtml(line)}</div>`).join('')}
                    </div>
                </div>`;
                }

                function renderGridSection(title, rows, note) {
                    if (!rows || !rows.length) return '';
                    return `
                <div class="intel-section">
                    <div class="intel-title">${escapeHtml(title)}</div>
                    <div class="intel-grid">
                        ${rows.map(row => `
                            <div class="intel-cell">
                                <div class="intel-key">${escapeHtml(row.key)}</div>
                                <div class="intel-val">${escapeHtml(row.value)}</div>
                                ${row.detail ? `<div class="intel-detail">${escapeHtml(row.detail)}</div>` : ''}
                            </div>`).join('')}
                    </div>
                    ${note ? `<div class="intel-note">${escapeHtml(note)}</div>` : ''}
                </div>`;
                }

                function renderListSection(title, items, emptyText) {
                    if (!items || !items.length) {
                        if (!emptyText) return '';
                        return `
                    <div class="intel-section">
                        <div class="intel-title">${escapeHtml(title)}</div>
                        <div class="intel-note">${escapeHtml(emptyText)}</div>
                    </div>`;
                    }
                    return `
                <div class="intel-section">
                    <div class="intel-title">${escapeHtml(title)}</div>
                    <ul class="intel-list">
                        ${items.map(item => `<li>${escapeHtml(item)}</li>`).join('')}
                    </ul>
                </div>`;
                }

                function buildForgeUpgradeList(p) {
                    if (!p.upgradeLevels) return [];
                    const entries = Object.entries(p.upgradeLevels).filter(([, lvl]) => lvl > 0);
                    if (!entries.length) return [];
                    entries.sort((a, b) => {
                        const upA = SHOP_UPGRADES[a[0]];
                        const upB = SHOP_UPGRADES[b[0]];
                        const catA = upA && upA.category ? upA.category : '';
                        const catB = upB && upB.category ? upB.category : '';
                        if (catA !== catB) return catA.localeCompare(catB);
                        const nameA = upA && upA.name ? upA.name : a[0];
                        const nameB = upB && upB.name ? upB.name : b[0];
                        return nameA.localeCompare(nameB);
                    });
                    return entries.map(([key, lvl]) => {
                        const upg = SHOP_UPGRADES[key];
                        const name = upg && upg.name ? upg.name.toUpperCase() : key.replace(/_/g, ' ').toUpperCase();
                        const category = upg && upg.category ? upg.category.toUpperCase() : 'GENERAL';
                        return `${name} â€¢ L${pad(lvl)} â€¢ ${category}`;
                    });
                }

                function buildSystemList(p) {
                    const systems = [];
                    
                    // Defense Systems
                    if (p.hasRearGuard) {
                        const cooldown = p.rearGuardReady ? 'READY' : `${fmt(p.rearGuardCooldown || 8, 1)}s`;
                        systems.push(`Aft Flank Shield â–¸ ${cooldown} â€¢ REAPER COUNTER`);
                    }
                    if (p.grenades > 0) {
                        systems.push(`Shield Pulse (EMP) â–¸ ${pad(p.grenades)} charges â€¢ REAPER COUNTER`);
                    }
                    if (p.knockbackShields > 0) {
                        systems.push(`Knockback Shield â–¸ ${pad(p.knockbackShields)} charges â€¢ CONCUSSIVE BARRIER`);
                    }
                    if (p.beefShieldMax > 0) {
                        systems.push(`Beef Shield â–¸ ${pad(Math.floor(p.beefShield || 0))}/${pad(Math.floor(p.beefShieldMax))} armor`);
                    }
                    
                    // Offensive Systems
                    if (p.hasVoidBeam) systems.push('Gravity Well â–¸ Singularity generator ready');
                    if (p.hasLazarusBeam) {
                        const level = p.upgradeLevels?.lazarus_beam || 1;
                        systems.push(`Lazarus Beam â–¸ Level ${level} ${level > 1 ? 'dual' : 'single'} beam`);
                    }
                    if (p.hasLauncher) {
                        const level = p.upgradeLevels?.launcher || 1;
                        const projectiles = 2 * level;
                        systems.push(`Fragment Launcher â–¸ ${projectiles} projectiles`);
                    }
                    if (p.hasHounds) {
                        const packSize = Array.isArray(store.hounds) ? store.hounds.filter(h => h && !h.dead).length : 2;
                        systems.push(`Ghost Hounds â–¸ Pack of ${pad(packSize)}`);
                    }
                    if (p.hasIceman) {
                        const level = store.iceman?.level || 1;
                        systems.push(`The Iceman â–¸ Level ${level} mirror support`);
                    }
                    if (p.starCannonLevel) {
                        const support = p.starCannonIcemanSupport ? ' + Iceman sync' : '';
                        systems.push(`Star Cannon â–¸ MK${pad(p.starCannonLevel)}${support}`);
                    }
                    
                    // Mobility & Special
                    if (p.hasBlink) {
                        const mode = p.autoBlinkEnabled ? 'Auto-response' : 'Manual trigger';
                        systems.push(`Blink Teleport â–¸ ${mode} â€¢ Range ${pad(Math.floor(p.blinkRange || 250))}`);
                    }
                    if (p.hasVoidLaser || p.hasPhasestriker) {
                        const level = p.phasestRikerLevel || 0;
                        const range = level >= 1 ? 'Unlimited' : 'Short';
                        systems.push(`Void Laser â–¸ ${range} range â€¢ ${p.doubleBeam ? 'Double beam' : 'Single beam'}`);
                    }
                    if (p.hasChainLightning || p.hasStormbringer) {
                        const level = p.stormstrikerLevel || 1;
                        const bolts = level >= 3 ? '4 bolts' : level >= 2 ? 'Twin bolts' : 'Single bolt';
                        systems.push(`Chain Lightning â–¸ ${bolts} â€¢ Damage x${fmt(p.chainLightningDamage || 1, 1)}`);
                    }
                    if (p.hasBeefClone) {
                        const mode = p.juggernautCloneActive ? 'Bomber' : 'Marauder';
                        systems.push(`Battle Clone â–¸ ${mode} mode active`);
                    }
                    if (p.wiperLasers) {
                        systems.push(`Wiper Lasers â–¸ Sweeping laser array online`);
                    }
                    
                    // Buffs & Stacks
                    if (p.attackSpeedStacks) systems.push(`Hyper Drive â–¸ ${pad(p.attackSpeedStacks)} stacks active`);
                    if (p.timeShardStacks) systems.push(`Time Shards â–¸ ${pad(p.timeShardStacks)} stacks â€¢ x${fmt(p.timeShardMultiplier || 1, 2)} rate`);
                    
                    return systems;
                }

                function computeSkillMatrix(treeData, p, subclassDisplay) {
                    if (!treeData || !p.subclass) return null; // Don't show matrix without actual subclass selection
                    const result = {
                        rows: [],
                        laneSummaries: [],
                        laneNotes: [],
                        powerSummaries: []
                    };
                    const skillTree = p.skillTree || {};

                    const lanes = [];
                    // Lane 1: Core progression path
                    if (treeData.path && Array.isArray(treeData.path.nodes)) {
                        const lane = {
                            index: 1,
                            name: treeData.path.name || 'Core Path',
                            nodes: []
                        };
                        treeData.path.nodes.forEach((node, idx) => {
                            const unlocked = !!skillTree[node.id];
                            const order = idx + 1;
                            result.rows.push({
                                tier: `T${order}`,
                                lane: 'Lane Î± â€“ Core Path',
                                name: node.name,
                                status: unlocked ? 'ONLINE' : 'LOCKED',
                                desc: node.desc,
                                active: unlocked
                            });
                            lane.nodes.push({
                                order,
                                name: node.name,
                                desc: node.desc,
                                unlocked,
                                statusSymbol: unlocked ? 'âœ”' : 'âœ–'
                            });
                            if (unlocked) {
                                result.powerSummaries.push(`${node.name} â€” ${node.desc}`);
                            }
                        });
                        lanes.push(lane);
                    }

                    // Lane 2: Signature â†’ Crossover â†’ Ultimate progression
                    const succession = [];
                    if (treeData.classAbility) {
                        succession.push({ node: treeData.classAbility, kind: 'Signature' });
                    }
                    const crossDetails = typeof getCrossUnlockNode === 'function' ? getCrossUnlockNode(treeData) : null;
                    if (crossDetails && crossDetails.node) {
                        succession.push({ node: crossDetails.node, kind: 'Crossover', requirement: crossDetails.config && crossDetails.config.requiredInvestments });
                    }
                    if (treeData.ultimateAbility) {
                        succession.push({ node: treeData.ultimateAbility, kind: 'Ultimate' });
                    }

                    if (succession.length) {
                        const lane = {
                            index: 2,
                            name: `${subclassDisplay || 'SIGNATURE'} Abilities`,
                            nodes: []
                        };
                        succession.forEach((entry, idx) => {
                            const id = entry.node.id;
                            const unlocked = !!skillTree[id];
                            const laneLabel = `Lane Î² â€“ ${entry.kind}`;
                            result.rows.push({
                                tier: entry.kind.toUpperCase(),
                                lane: laneLabel,
                                name: entry.node.name,
                                status: unlocked ? 'ONLINE' : 'LOCKED',
                                desc: entry.node.desc,
                                active: unlocked
                            });
                            lane.nodes.push({
                                order: entry.kind, // Use ability type instead of number
                                name: entry.node.name,
                                desc: entry.node.desc,
                                unlocked,
                                statusSymbol: unlocked ? 'âœ”' : 'âœ–',
                                requirement: entry.requirement,
                                kind: entry.kind
                            });
                            if (unlocked) {
                                result.powerSummaries.push(`${entry.node.name} â€” ${entry.node.desc}`);
                            }
                        });
                        lanes.push(lane);
                    }

                    if (!result.rows.length) {
                        return null;
                    }

                    lanes.forEach(lane => {
                        if (lane.index === 1) {
                            // Core path uses numbered nodes
                            const nodeStatus = lane.nodes.map(node => `${node.statusSymbol}${node.order}`);
                            result.laneSummaries.push(`LANE ${lane.index} â–¸ ${lane.name.toUpperCase()} â†’ Nodes ${nodeStatus.join(' ')}`);
                        } else {
                            // Ability path uses ability types
                            const nodeStatus = lane.nodes.map(node => `${node.statusSymbol}${node.kind.substring(0, 3)}`);
                            result.laneSummaries.push(`LANE ${lane.index} â–¸ ${lane.name.toUpperCase()} â†’ ${nodeStatus.join(' ')}`);
                        }

                        result.laneNotes.push(lane.nodes.map(node => {
                            const requirement = node.requirement ? ` (req ${node.requirement})` : '';
                            return `${node.kind || node.order}. ${node.name}${requirement} (${node.unlocked ? 'active' : 'locked'})`;
                        }).join(' | '));
                    });

                    return result;
                }

                function renderSkillMatrixSection(data) {
                    if (!data.rows.length) return '';
                    return `
                <div class="intel-section">
                    <div class="intel-title">Skill Path Matrix</div>
                    <table class="intel-table">
                        <thead>
                            <tr>
                                <th>Tier</th>
                                <th>Lane</th>
                                <th>Node</th>
                                <th>Status</th>
                                <th>Effect</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.rows.map(row => `
                                <tr class="${row.active ? 'active' : 'inactive'}">
                                    <td>${escapeHtml(row.tier)}</td>
                                    <td>${escapeHtml(row.lane)}</td>
                                    <td>${escapeHtml(row.name)}</td>
                                    <td>${escapeHtml(row.status)}</td>
                                    <td>${escapeHtml(row.desc)}</td>
                                </tr>`).join('')}
                        </tbody>
                    </table>
                    ${data.laneNotes.length ? `
                        <div class="intel-subtitle">Lane Breakdown</div>
                        <div class="intel-summary">
                            ${data.laneNotes.map(note => `<div class="intel-summary-line">${escapeHtml(note)}</div>`).join('')}
                        </div>` : ''}
                </div>`;
                }

                function buildLearnedSkillList(p) {
                    if (!Array.isArray(p.learnedSkills) || !p.learnedSkills.length) return [];
                    const unique = Array.from(new Set(p.learnedSkills));
                    return unique.map(id => {
                        const meta = resolveSkillMeta(id);
                        if (meta) {
                            return `${meta.name.toUpperCase()}`;
                        }
                        return id.replace(/_/g, ' ').toUpperCase();
                    });
                }

                function buildCalibrationList(p) {
                    const list = [];
                    if (p.attackSpeedStacks) list.push(`Hyper Drive Stacks â–¸ ${pad(p.attackSpeedStacks)}`);
                    if (p.voidCoreStacks) {
                        list.push(`Void Core Resonance â–¸ ${pad(p.voidCoreStacks)} (Damage x${fmt(p.voidCoreDmgMult || 1, 2)} | Fire ${fmt(p.voidCoreFireRateMult || 1, 2)}x)`);
                    }
                    if (p.stormstrikerLevel) list.push(`Stormbringer Intensity â–¸ L${fmt(p.stormstrikerLevel, 1)}`);
                    if (p.phasestRikerLevel) list.push(`Phase Laser Ramp â–¸ L${fmt(p.phasestRikerLevel, 1)}`);
                    if (p.starCannonLevel) list.push(`Star Cannon Calibration â–¸ MK${pad(p.starCannonLevel)}`);
                    if (p.vampirismLevel) list.push(`Vampiric Augments â–¸ L${pad(p.vampirismLevel)} (${pct(p.vampirism)})`);
                    return list;
                }

                function renderChampionSection() {
                    const champion = store.playerChampion;
                    if (!champion || champion.dead) {
                        return renderListSection('Champion Companion', [], 'Champion offline. Secure sigils to deploy guardian.');
                    }
                    const minions = Array.isArray(store.championMinions) ? store.championMinions.filter(m => m && !m.dead).length : 0;
                    const rows = [
                        { key: 'Level', value: pad(champion.level || 1), detail: `Damage x${fmt(champion.damageScale || 1, 2)}` },
                        { key: 'Volley', value: `${pad(champion.volleySize || 0)} rounds`, detail: `Cooldown ${fmt(champion.fireCooldown || 0, 2)}s` },
                        { key: 'Dash', value: `${fmt(champion.dashCooldown || 0, 2)}s`, detail: `Momentum ${fmt(champion.momentum || 0, 2)}` },
                        { key: 'Minions', value: pad(minions), detail: `Guard Radius ${fmt(champion.guardRadius || 0, 1)}` }
                    ];
                    return renderGridSection('Champion Companion', rows);
                }

                function resolveSkillName(skillId) {
                    const meta = resolveSkillMeta(skillId);
                    if (meta && meta.name) {
                        return meta.name;
                    }
                    return skillId ? skillId.replace(/_/g, ' ') : '';
                }

                function resolveSkillMeta(skillId) {
                    if (!skillId || typeof SKILL_TREE_DATA === 'undefined') return null;
                    for (const key of Object.keys(SKILL_TREE_DATA)) {
                        const tree = SKILL_TREE_DATA[key];
                        if (!tree) continue;
                        if (tree.path && Array.isArray(tree.path.nodes)) {
                            const node = tree.path.nodes.find(n => n.id === skillId);
                            if (node) return node;
                        }
                        if (tree.classAbility && tree.classAbility.id === skillId) return tree.classAbility;
                        if (tree.ultimateAbility && tree.ultimateAbility.id === skillId) return tree.ultimateAbility;
                        const cross = typeof getCrossUnlockNode === 'function' ? getCrossUnlockNode(tree) : null;
                        if (cross && cross.node && cross.node.id === skillId) return cross.node;
                    }
                    return null;
                }
            }

            function showShopWithHighlight() { showShop(); announce('Low integrity! Route to the Upgrade Hangar for repairs.'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }

            function triggerNanoSaveCharge() {
                const p = store.player;
                if (!p || p.nanoSaves <= 0) return false;
                
                // Block death, set life to 10
                p.nanoSaves--;
                p.hp = 10;
                
                // Increase max health
                p.hpMax += 15;
                
                // Trigger heal effect
                store.activeEffects.push(createEffect("nanoHeal"));
                announce('âš¡ NANO CHARGE ACTIVATED! âš¡');
                
                // Open shop
                showShop();
                
                return true;
            }

            function triggerMechForgeGoldMilestone(forceShop = false) {
                const world = store.world;
                if (!world) return;

                world.mechForgePromptActive = true;
                if (!world.mechForgeGoldTriggered || forceShop) {
                    world.mechForgeGoldTriggered = true;
                }

                const promptCount = (world.mechForgePromptCount || 0) + 1;
                world.mechForgePromptCount = promptCount;

                const interval = computeNextForgePromptInterval(world.mechForgePromptInterval, promptCount);
                world.mechForgePromptInterval = interval;
                world.nextMechForgePrompt = getWorldGold() + interval;

                flashForgeButton(promptCount <= 2 ? 10000 : 5000);

                const autoEnabled = !!world.autoForgeEnabled;
                if (store.settings.showShopTutorial && (!world.shopTutorialShown || forceShop)) {
                    showShopTutorial(forceShop, 'Upgrade Hangar unlocked. Allocate your credits.');
                    showShopSpotlight('Upgrade Hangar unlocked. Allocate your credits.', { flashButton: true, force: true });
                } else if (!autoEnabled || forceShop) {
                    announce('Upgrade Hangar unlocked. Deploy your credits.');
                    showShopSpotlight('Upgrade Hangar unlocked. Deploy your credits.', { flashButton: true });
                    if (forceShop) {
                        showShop();
                    }
                } else {
                    const profile = typeof getActiveAutoForgeProfile === 'function' ? getActiveAutoForgeProfile() : null;
                    const doctrineName = profile ? `${profile.label} doctrine` : 'Auto-buy doctrine';
                    announce(`${doctrineName} stocked up. Open the Upgrade Hangar to adjust priorities.`);
                    showShopSpotlight(`${doctrineName} stocked up. Adjust priorities in the Upgrade Hangar.`, { flashButton: false });
                }

                setTimeout(() => {
                    world.mechForgePromptActive = false;
                }, 600);
            }
            function getChampionPrimaryTarget(origin) {
                if (!origin) return null;
                const ox = origin.x ?? store.player.x;
                const oy = origin.y ?? store.player.y;
                let best = null;
                let bestDist = Infinity;
                let bestChampion = null;
                let bestChampionDist = Infinity;

                // Always prioritize boss first
                if (store.boss && !store.boss.dead) {
                    const dx = store.boss.x - ox;
                    const dy = store.boss.y - oy;
                    const dist = dx * dx + dy * dy;
                    if (dist < bestDist) {
                        bestDist = dist;
                        best = store.boss;
                    }
                }

                // Search for enemy champions and regular enemies
                for (let i = 0; i < store.enemies.length; i++) {
                    const enemy = store.enemies[i];
                    if (!enemy || enemy.dead || enemy.hp <= 0) continue;
                    const dx = enemy.x - ox;
                    const dy = enemy.y - oy;
                    const dist = dx * dx + dy * dy;

                    // Check if this is a champion type enemy
                    const isChampion = enemy.type === 'void_champion' || enemy.type === 'shadow_champion';

                    if (isChampion) {
                        // Track the closest champion separately
                        if (dist < bestChampionDist) {
                            bestChampionDist = dist;
                            bestChampion = enemy;
                        }
                    } else {
                        // Regular enemy - only consider if no champions found yet
                        if (dist < bestDist) {
                            bestDist = dist;
                            best = enemy;
                        }
                    }
                }

                // Prioritize champions over regular enemies (unless boss exists)
                if (bestChampion && (!store.boss || store.boss.dead)) {
                    return bestChampion;
                }

                return best;
            }

            function resolveChampionTarget(entity, options = {}) {
                if (!entity) return null;
                const now = performance.now();
                const stickRange = options.stickRange ?? 620;
                const lingerMs = options.lingerMs ?? 260;
                const originX = entity.x ?? store.player?.x ?? 0;
                const originY = entity.y ?? store.player?.y ?? 0;
                const stickRangeSq = stickRange * stickRange;

                const existing = entity.currentTarget;
                if (existing && !existing.dead && existing.hp > 0) {
                    const dx = existing.x - originX;
                    const dy = existing.y - originY;
                    if (dx * dx + dy * dy <= stickRangeSq) {
                        entity.currentTarget = existing;
                        entity._lastTargetSeen = now;
                        return existing;
                    }
                }

                const fresh = getChampionPrimaryTarget(entity);
                if (fresh) {
                    entity.currentTarget = fresh;
                    entity._lastTargetSeen = now;
                    return fresh;
                }

                if (existing && !existing.dead && existing.hp > 0 && entity._lastTargetSeen && (now - entity._lastTargetSeen) < lingerMs) {
                    return existing;
                }

                entity.currentTarget = null;
                return null;
            }

            function championDealDamage(target, damage, options = {}) {
                if (!target || target.dead || damage <= 0) return 0;
                const champion = store.playerChampion;
                const upgradeState = getChampionUpgradeState();
                let finalDamage = damage;

                if (options.vulnerabilityProfile) {
                    finalDamage = applyChampionVulnerabilityScaling(finalDamage, target, options.vulnerabilityProfile);
                }
                if (typeof options.damageMultiplier === 'number') {
                    finalDamage *= options.damageMultiplier;
                }
                if (typeof options.damageBonus === 'number') {
                    finalDamage += options.damageBonus;
                }
                finalDamage = Math.max(0, finalDamage);

                const pseudoBullet = {
                    x: options.x ?? target.x,
                    y: options.y ?? target.y,
                    dmg: finalDamage,
                    pierce: true,
                    explosive: false,
                    isChampionShot: true,
                    skipChampionEffects: !!options.skipChampionEffects,
                    championAttackModule: options.sourceAttackModule ?? (champion?.attackModule || upgradeState.attackModule || 'default'),
                    championLevel: options.championLevel ?? (champion?.level || 1),
                    vulnerabilityProfile: options.vulnerabilityProfile || null,
                    fromChampionMinion: !!options.fromChampionMinion,
                    minionProtocolLevel: options.minionProtocolLevel ?? 0,
                    minionProtocolSlowFactor: options.minionProtocolSlowFactor ?? null,
                    minionProtocolNovaDamageScale: options.minionProtocolNovaDamageScale ?? 0
                };
                handleBulletImpact(pseudoBullet, target);
                return finalDamage;
            }

            function championFireStarfallSalvo(champion, target, context = {}) {
                if (!champion || champion.dead || !target) return null;
                const player = store.player;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const baseAngle = Math.atan2(target.y - champion.y, target.x - champion.x);
                const volley = Math.max(3, champion.volleySize || 4);
                const spread = champion.volleySpread || 0.16;
                const projectileSpeed = 360 + (champion.level || 1) * 45;
                const baseDamage = (26 + (champion.level || 1) * 8) * dmgMult * (champion.attackDamageMultiplier || 1);
                const vulnerabilityProfile = context.vulnerabilityProfile || null;
                let highestDamage = 0;

                for (let i = 0; i < volley; i++) {
                    const offsetIdx = i - (volley - 1) / 2;
                    const angle = baseAngle + offsetIdx * spread;
                    const bullet = spawnBullet({
                        x: champion.x + Math.cos(baseAngle) * 10,
                        y: champion.y + Math.sin(baseAngle) * 10,
                        vx: Math.cos(angle) * projectileSpeed,
                        vy: Math.sin(angle) * projectileSpeed,
                        r: champion.level >= 4 ? 6 : 5,
                        col: champion.level >= 4 ? 'rgba(205, 210, 255, 0.96)' : 'rgba(162, 170, 255, 0.94)',
                        dmg: baseDamage,
                        life: 1.9,
                        pierce: champion.level >= 4,
                        isChampionShot: true,
                        championAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default',
                        championLevel: champion.level || 1
                    });
                    bullet.collisionSearchRadius = 160;
                    if (vulnerabilityProfile) {
                        bullet.vulnerabilityProfile = vulnerabilityProfile;
                    }
                    highestDamage = Math.max(highestDamage, bullet.dmg || 0);
                }

                const jitter = 0.06 + Math.random() * 0.08;
                const now = performance.now();
                if (!champion.lastShotTime || (now - champion.lastShotTime) > 200) {
                    champion.lastShotTime = now;
                }
                store.activeEffects.push(createEffect('hitSpark', champion.x + Math.cos(baseAngle) * 6, champion.y + Math.sin(baseAngle) * 6, 14, { strength: 45 }));
                return {
                    fireTimer: champion.fireCooldown || 1,
                    jitter,
                    damageApplied: highestDamage
                };
            }


            function championPerformCharge(champion, target, dmgMult) {
                const dx = target.x - champion.x;
                const dy = target.y - champion.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const chargeSpeed = 600;

                // Play charge sound
                playSound('beefCharge');

                champion.state = 'special_charge';
                champion.dashTimer = 0.4;
                champion.dashDuration = 0.4;
                champion.dashVX = (dx / dist) * chargeSpeed;
                champion.dashVY = (dy / dist) * chargeSpeed;
                champion.visualAim = Math.atan2(champion.dashVY, champion.dashVX);
                champion.dashHits = new Set();
                champion.echoCooldown = 0;

                // Enhanced charge damage
                champion.chargeDamage = (80 + (champion.level || 1) * 20) * dmgMult;

                // Visual effect - charge trail
                for (let i = 0; i < 8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 30;
                    const particle = createParticle(
                        champion.x + Math.random() * 10 - 5,
                        champion.y + Math.random() * 10 - 5,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        '#4080ff',
                        200 + Math.random() * 100
                    );
                    if (particle) particle.size = 2 + Math.random() * 2;
                    store.flameParticles.push(particle);
                }

                addShadowEcho(champion.x, champion.y);
                champion.fireTimer = 1.2;
                playSound('beefCharge');
            }

            function championExecuteCrescentRicochet(champion, context = {}) {
                const target = context.target;
                if (!champion || champion.dead || !target) return null;

                const player = store.player;
                const level = champion.level || 1;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const baseDamage = (22 + level * 9) * dmgMult * (champion.attackDamageMultiplier || 1);
                const maxTargets = context.ability?.maxTargets ?? 3;
                const radius = context.ability?.searchRadius ?? 240;
                const vulnerabilityProfile = context.vulnerabilityProfile || null;

                const candidates = [];
                forEachEnemyNearby(target.x, target.y, radius, enemy => {
                    if (!enemy || enemy.dead || enemy.hp <= 0) return false;
                    const dx = enemy.x - target.x;
                    const dy = enemy.y - target.y;
                    const distSq = dx * dx + dy * dy;
                    candidates.push({ enemy, distSq });
                    return false;
                });

                if (store.boss && !store.boss.dead) {
                    const boss = store.boss;
                    const dx = boss.x - target.x;
                    const dy = boss.y - target.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= Math.pow(radius + (boss.r || 60), 2)) {
                        candidates.push({ enemy: boss, distSq });
                    }
                }

                candidates.sort((a, b) => a.distSq - b.distSq);

                let totalDamage = 0;
                let hits = 0;
                const arcPoints = [];

                for (let i = 0; i < candidates.length && hits < maxTargets; i++) {
                    const foe = candidates[i].enemy;
                    if (!foe || foe.dead || foe.hp <= 0) continue;
                    const applied = championDealDamage(foe, baseDamage, {
                        x: champion.x,
                        y: champion.y,
                        vulnerabilityProfile,
                        sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                    });
                    totalDamage += applied;
                    hits++;
                    arcPoints.push({ x: foe.x, y: foe.y });
                    foe.vulnerabilityPulseColor = '#7c9dff';
                    foe.vulnerabilityPulseStrength = Math.max(foe.vulnerabilityPulseStrength || 0, 0.7);
                }

                if (hits > 0) {
                    let prevPoint = { x: champion.x, y: champion.y };
                    arcPoints.forEach(point => {
                        store.activeEffects.push(createEffect('lightning', prevPoint.x, prevPoint.y, 20, {
                            targetX: point.x,
                            targetY: point.y,
                            strength: 48
                        }));
                        prevPoint = point;
                    });
                    playSound('chainLightning');
                }

                return {
                    fireTimer: 0.85,
                    cooldown: context.ability?._baseCooldown ?? context.ability?.baseCooldown ?? 4.6,
                    appliedDamage: totalDamage,
                    hits
                };
            }

            function championExecuteSolarBrand(champion, context = {}) {
                const target = context.target;
                if (!champion || champion.dead || !target) return null;

                const player = store.player;
                const level = champion.level || 1;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const burstDamage = (34 + level * 11) * dmgMult * (champion.attackDamageMultiplier || 1);
                const burnPayload = (18 + level * 6) * dmgMult;
                const vulnerabilityProfile = context.vulnerabilityProfile || null;

                const applied = championDealDamage(target, burstDamage, {
                    x: champion.x,
                    y: champion.y,
                    vulnerabilityProfile,
                    sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                });

                applyChampionEmberBurn(target, {
                    finalDamage: burnPayload,
                    championLevel: level
                });

                target.vulnerabilityPulseColor = '#ffb347';
                target.vulnerabilityPulseStrength = Math.max(target.vulnerabilityPulseStrength || 0, 1.0);

                store.activeEffects.push(createEffect('jugFearEmber', target.x, target.y, (target.r || 20) * 1.35));
                store.activeEffects.push(createEffect('hitSpark', target.x, target.y, (target.r || 18) * 1.1, { strength: 70 }));
                playSound('stargun');

                return {
                    fireTimer: 0.95,
                    cooldown: context.ability?._baseCooldown ?? context.ability?.baseCooldown ?? 7.5,
                    appliedDamage: applied
                };
            }

            function championExecuteNebulaBloom(champion, context = {}) {
                const target = context.target;
                if (!champion || champion.dead || !target) return null;

                const player = store.player;
                const level = champion.level || 1;
                const dmgMult = (player?.dmgMult || 1) * (champion.damageScale || 1);
                const baseDamage = (24 + level * 9) * dmgMult * (champion.attackDamageMultiplier || 1);
                const radius = context.ability?.radius ?? 165;
                const vulnerabilityProfile = context.vulnerabilityProfile || null;
                const radiusSq = radius * radius;
                let hits = 0;
                let totalDamage = 0;

                const originX = target.x;
                const originY = target.y;

                forEachEnemyNearby(originX, originY, radius, enemy => {
                    if (!enemy || enemy.dead || enemy.hp <= 0) return false;
                    const dx = enemy.x - originX;
                    const dy = enemy.y - originY;
                    if (dx * dx + dy * dy > radiusSq) return false;
                    const applied = championDealDamage(enemy, baseDamage, {
                        x: originX,
                        y: originY,
                        vulnerabilityProfile,
                        sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                    });
                    totalDamage += applied;
                    hits++;
                    enemy.vulnerabilityPulseColor = '#96c8ff';
                    enemy.vulnerabilityPulseStrength = Math.max(enemy.vulnerabilityPulseStrength || 0, 0.85);
                    return false;
                });

                if (store.boss && !store.boss.dead) {
                    const boss = store.boss;
                    const dx = boss.x - originX;
                    const dy = boss.y - originY;
                    if (dx * dx + dy * dy <= Math.pow(radius + (boss.r || 60), 2)) {
                        const applied = championDealDamage(boss, baseDamage, {
                            x: originX,
                            y: originY,
                            vulnerabilityProfile,
                            sourceAttackModule: champion.attackModule || getChampionUpgradeState().attackModule || 'default'
                        });
                        totalDamage += applied;
                        hits++;
                        boss.vulnerabilityPulseColor = '#96c8ff';
                        boss.vulnerabilityPulseStrength = Math.max(boss.vulnerabilityPulseStrength || 0, 0.55);
                    }
                }

                store.activeEffects.push(createEffect('grenadeExplosion', originX, originY, radius * 1.2, { strength: 75 }));
                store.activeEffects.push(createEffect('hitSpark', originX, originY, radius, { strength: 55 }));
                playSound('explosion');

                return {
                    fireTimer: 1.15,
                    cooldown: context.ability?._baseCooldown ?? context.ability?.baseCooldown ?? 11,
                    appliedDamage: totalDamage,
                    hits,
                    jitterRange: [0.08, 0.14]
                };
            }

            // Primordial Soldier Laboratory Functions
            function showPrimordialSoldierLaboratory() {
                const player = store.player;
                if (!player || !player.championUnlocked) {
                    announce('Champion must be unlocked first! Collect the Shadow Sigil.');
                    return;
                }

                pauseGame();
                const panel = q("championDressingRoom");
                populateChampionBuilder();
                populateChampionUpgradeGrid();
                updateChampionPreview();
                updateChampionStats();
                resetChampionPresetPanel();
                panel.classList.remove("hide");
                enterPanel('championDressingRoom');
            }

            function getSelectedChampionPresentation() {
                const player = store.player;
                const champion = store.playerChampion;
                const upgradeState = getChampionUpgradeState(player);

                // Override with selected values
                const selectedAttackModule = q('attackModuleSelect')?.value;
                const selectedCadence = parseInt(q('cadenceSelect')?.value || 0);
                const selectedProtocol = parseInt(q('protocolSelect')?.value || 0);
                const selectedSkin = q('skinSelect')?.value;

                const previewState = {
                    ...upgradeState,
                    attackModule: selectedAttackModule || upgradeState.attackModule,
                    cadenceLevel: selectedCadence >= 0 ? selectedCadence : upgradeState.cadenceLevel,
                    minionProtocols: selectedProtocol >= 0 ? selectedProtocol : upgradeState.minionProtocols,
                    skin: selectedSkin || upgradeState.skin
                };

                const skinId = previewState.skin || 'default';
                const skinOption = CHAMPION_SKIN_OPTION_MAP[skinId] || CHAMPION_SKIN_OPTION_MAP.default;
                const skinTheme = getChampionSkinTheme(skinOption.theme || skinOption.id || skinOption.key || 'default');
                const profile = (player && CHAMPION_PREVIEW_PROFILES[player.pilotGenome]) || CHAMPION_PREVIEW_PROFILES.default;
                return { player, champion, upgradeState: previewState, skinOption, skinTheme, profile };
            }

            function applyChampionLoadoutLabels(presentation) {
                if (!presentation) return;
                const { profile, skinOption, upgradeState, player } = presentation;
                const nameEl = q('previewChampionName');
                if (nameEl) {
                    const profileTitle = profile?.title || 'Shadow Guardian';
                    const skinName = skinOption?.name || 'Void Vanguard';
                    nameEl.textContent = `${profileTitle} Â· ${skinName}`;
                }

                const classEl = q('previewChampionClass');
                if (classEl) {
                    const subclass = player?.subclass ? player.subclass.replace(/_/g, ' ').toUpperCase() : '';
                    const baseLabel = profile?.classLabel || '';
                    classEl.textContent = subclass ? `${baseLabel}${baseLabel ? ' â€” ' : ''}${subclass}` : baseLabel;
                }

                const skinLabel = q('championSkinLabel');
                if (skinLabel) skinLabel.textContent = skinOption?.name || 'Void Vanguard';

                const attackModuleLabel = q('championAttackModuleLabel');
                const attackModule = (upgradeState?.attackModule && CHAMPION_ATTACK_MODULE_MAP[upgradeState.attackModule]) || null;
                if (attackModuleLabel) attackModuleLabel.textContent = attackModule?.name || 'Starfall Salvo';

                const cadenceLabel = q('championCadenceLabel');
                const cadenceOption = CHAMPION_CADENCE_LEVELS[upgradeState?.cadenceLevel || 0] || CHAMPION_CADENCE_LEVELS[0];
                if (cadenceLabel) cadenceLabel.textContent = cadenceOption?.name || 'BASELINE CADENCE';

                const protocolLabel = q('championProtocolLabel');
                const protocolOption = CHAMPION_MINION_PROTOCOL_LEVELS[upgradeState?.minionProtocols || 0] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                if (protocolLabel) protocolLabel.textContent = protocolOption?.name || 'ESCORT DRONES';

                const signatureLabel = q('championSignatureLabel');
                if (signatureLabel) signatureLabel.textContent = profile?.signature || 'Adaptive Void Sentinel';
            }

            function updateChampionPreview(animationType = currentPreviewAnimationType) {
                currentPreviewAnimationType = animationType;
                const canvas = q("championPreviewCanvas");
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const presentation = getSelectedChampionPresentation();
                const { champion, skinTheme, profile, upgradeState } = presentation;
                applyChampionLoadoutLabels(presentation);

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background
                const gradient = ctx.createRadialGradient(100, 110, 20, 100, 110, 120);
                const aura = skinTheme?.aura || CHAMPION_SKIN_THEMES.default.aura;
                gradient.addColorStop(0, withAlpha(aura.inner || 'rgba(51, 0, 68, 0.4)', 0.65));
                gradient.addColorStop(0.55, withAlpha(aura.mid || 'rgba(51, 0, 68, 0.3)', 0.55));
                gradient.addColorStop(1, withAlpha(aura.outer || 'rgba(5, 0, 15, 0.8)', 0.9));
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (!champion) {
                    // Draw placeholder champion
                    drawPlaceholderChampion(ctx, animationType, presentation);
                } else {
                    // Draw actual champion
                    drawChampionPreview(ctx, presentation, animationType);
                }
            }

            function drawChampionPreview(ctx, presentation, animationType, options = {}) {
                const { champion, skinTheme, profile, upgradeState } = presentation;
                const centerX = 100;
                const centerY = 118;
                const time = performance.now() / 1000;
                const isPlaceholder = options.forcePlaceholder || !champion;

                const level = champion?.level || 1;
                const health = champion?.hp ?? champion?.hpMax ?? (160 + level * 40);
                const maxHealth = champion?.hpMax ?? (180 + level * 45);
                const shield = champion?.shield ?? Math.max(0, (upgradeState?.champion_shield || 0) * 30);
                const auraPhase = (champion?.auraPulse || 0) + time * 2.1;

                let offsetY = 0;
                let scale = 1;
                let rotation = 0;

                switch (animationType) {
                    case 'attack':
                        offsetY = Math.sin(time * 7.5) * 2.6;
                        scale = 1 + Math.sin(time * 9) * 0.12;
                        rotation = Math.sin(time * 8) * 0.12;
                        break;
                    case 'special':
                        offsetY = Math.sin(time * 4.2) * 3.5;
                        scale = 1 + Math.sin(time * 5.4) * 0.18;
                        rotation = Math.sin(time * 3.3) * 0.11;
                        break;
                    default:
                        offsetY = Math.sin(time * 2.4) * 2.2;
                        scale = 1 + Math.sin(time * 1.8) * 0.06;
                        rotation = Math.sin(time * 1.7) * 0.04;
                        break;
                }

                const bodyTheme = skinTheme?.body || CHAMPION_SKIN_THEMES.default.body;
                const visorTheme = skinTheme?.visor || CHAMPION_SKIN_THEMES.default.visor;
                const auraTheme = skinTheme?.aura || CHAMPION_SKIN_THEMES.default.aura;
                const trailColor = skinTheme?.trail || '#78b4ff';

                const baseSize = 20 + Math.min(5, level) * 2.2;
                const accentColor = bodyTheme.accent || trailColor;

                ctx.save();
                ctx.translate(centerX, centerY + offsetY);
                ctx.scale(scale, scale);
                ctx.rotate(rotation);

                // Aura
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const auraRadius = baseSize * (2.1 + Math.sin(auraPhase) * 0.28);
                const auraGradient = ctx.createRadialGradient(0, 0, baseSize * 0.35, 0, 0, auraRadius);
                auraGradient.addColorStop(0, withAlpha(auraTheme.inner || '#7ab0ff', isPlaceholder ? 0.5 : 0.85));
                auraGradient.addColorStop(0.55, withAlpha(auraTheme.mid || '#2d559f', isPlaceholder ? 0.35 : 0.55));
                auraGradient.addColorStop(1, withAlpha(auraTheme.outer || '#0f1732', 0));
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Body - Shape based on skin
                const bodyGradient = ctx.createLinearGradient(0, -baseSize * 1.1, 0, baseSize * 1.05);
                bodyGradient.addColorStop(0, bodyTheme.top || '#2a3560');
                bodyGradient.addColorStop(0.45, bodyTheme.mid || bodyTheme.top || '#1e2845');
                bodyGradient.addColorStop(1, bodyTheme.bottom || bodyTheme.mid || '#3c4f78');

                ctx.globalAlpha = isPlaceholder ? 0.85 : 1;
                ctx.fillStyle = bodyGradient;
                ctx.strokeStyle = bodyTheme.outline || accentColor;
                ctx.lineWidth = 2.1;
                ctx.beginPath();

                // Different shapes based on skin
                const skinId = upgradeState?.skin || 'default';
                switch (skinId) {
                    case 'solstice': // Angular, sharp design
                        ctx.moveTo(0, -baseSize * 1.2);
                        ctx.lineTo(baseSize * 0.8, -baseSize * 0.3);
                        ctx.lineTo(baseSize * 0.9, baseSize * 0.2);
                        ctx.lineTo(baseSize * 0.4, baseSize * 1.0);
                        ctx.lineTo(0, baseSize * 1.1);
                        ctx.lineTo(-baseSize * 0.4, baseSize * 1.0);
                        ctx.lineTo(-baseSize * 0.9, baseSize * 0.2);
                        ctx.lineTo(-baseSize * 0.8, -baseSize * 0.3);
                        ctx.closePath();
                        break;
                    case 'tempest': // Flowing, curved design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.quadraticCurveTo(baseSize * 0.6, -baseSize * 0.8, baseSize * 0.8, -baseSize * 0.1);
                        ctx.quadraticCurveTo(baseSize * 0.9, baseSize * 0.4, baseSize * 0.5, baseSize * 0.9);
                        ctx.quadraticCurveTo(baseSize * 0.2, baseSize * 1.1, 0, baseSize * 1.05);
                        ctx.quadraticCurveTo(-baseSize * 0.2, baseSize * 1.1, -baseSize * 0.5, baseSize * 0.9);
                        ctx.quadraticCurveTo(-baseSize * 0.9, baseSize * 0.4, -baseSize * 0.8, -baseSize * 0.1);
                        ctx.quadraticCurveTo(-baseSize * 0.6, -baseSize * 0.8, 0, -baseSize * 1.1);
                        ctx.closePath();
                        break;
                    case 'aurora': // Spiral/helix design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.lineTo(baseSize * 0.7, -baseSize * 0.4);
                        ctx.quadraticCurveTo(baseSize * 1.0, -baseSize * 0.1, baseSize * 0.8, baseSize * 0.3);
                        ctx.quadraticCurveTo(baseSize * 0.6, baseSize * 0.7, baseSize * 0.3, baseSize * 0.9);
                        ctx.lineTo(0, baseSize * 1.0);
                        ctx.lineTo(-baseSize * 0.3, baseSize * 0.9);
                        ctx.quadraticCurveTo(-baseSize * 0.6, baseSize * 0.7, -baseSize * 0.8, baseSize * 0.3);
                        ctx.quadraticCurveTo(-baseSize * 1.0, -baseSize * 0.1, -baseSize * 0.7, -baseSize * 0.4);
                        ctx.closePath();
                        break;
                    case 'bastion': // Blocky, armored design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.lineTo(baseSize * 0.9, -baseSize * 0.3);
                        ctx.lineTo(baseSize * 0.9, baseSize * 0.1);
                        ctx.lineTo(baseSize * 0.6, baseSize * 0.1);
                        ctx.lineTo(baseSize * 0.6, baseSize * 0.8);
                        ctx.lineTo(baseSize * 0.3, baseSize * 0.8);
                        ctx.lineTo(baseSize * 0.3, baseSize * 1.0);
                        ctx.lineTo(0, baseSize * 1.05);
                        ctx.lineTo(-baseSize * 0.3, baseSize * 1.0);
                        ctx.lineTo(-baseSize * 0.3, baseSize * 0.8);
                        ctx.lineTo(-baseSize * 0.6, baseSize * 0.8);
                        ctx.lineTo(-baseSize * 0.6, baseSize * 0.1);
                        ctx.lineTo(-baseSize * 0.9, baseSize * 0.1);
                        ctx.lineTo(-baseSize * 0.9, -baseSize * 0.3);
                        ctx.closePath();
                        break;
                    case 'umbra': // Spiky, crystalline design
                        ctx.moveTo(0, -baseSize * 1.2);
                        ctx.lineTo(baseSize * 0.4, -baseSize * 0.8);
                        ctx.lineTo(baseSize * 0.8, -baseSize * 0.2);
                        ctx.lineTo(baseSize * 0.6, baseSize * 0.2);
                        ctx.lineTo(baseSize * 0.9, baseSize * 0.6);
                        ctx.lineTo(baseSize * 0.4, baseSize * 0.9);
                        ctx.lineTo(0, baseSize * 1.1);
                        ctx.lineTo(-baseSize * 0.4, baseSize * 0.9);
                        ctx.lineTo(-baseSize * 0.9, baseSize * 0.6);
                        ctx.lineTo(-baseSize * 0.6, baseSize * 0.2);
                        ctx.lineTo(-baseSize * 0.8, -baseSize * 0.2);
                        ctx.lineTo(-baseSize * 0.4, -baseSize * 0.8);
                        ctx.closePath();
                        break;
                    default: // Void Vanguard - original design
                        ctx.moveTo(0, -baseSize * 1.1);
                        ctx.lineTo(baseSize * 0.92, -baseSize * 0.12);
                        ctx.lineTo(baseSize * 0.58, baseSize * 0.92);
                        ctx.lineTo(0, baseSize * 1.06);
                        ctx.lineTo(-baseSize * 0.58, baseSize * 0.92);
                        ctx.lineTo(-baseSize * 0.92, -baseSize * 0.12);
                        ctx.closePath();
                        break;
                }

                ctx.fill();
                ctx.stroke();

                // Interior panel
                ctx.globalAlpha = 0.75;
                ctx.fillStyle = bodyTheme.interior || '#1a2440';
                ctx.beginPath();
                ctx.moveTo(-baseSize * 0.28, -baseSize * 0.28);
                ctx.lineTo(baseSize * 0.28, -baseSize * 0.28);
                ctx.lineTo(baseSize * 0.42, baseSize * 0.16);
                ctx.lineTo(-baseSize * 0.42, baseSize * 0.16);
                ctx.closePath();
                ctx.fill();

                // Visor
                ctx.globalAlpha = 0.92;
                const visorGradient = ctx.createLinearGradient(-baseSize * 0.42, -baseSize * 0.26, baseSize * 0.42, 0);
                visorGradient.addColorStop(0, visorTheme.left || 'rgba(80, 150, 255, 0.85)');
                visorGradient.addColorStop(0.5, visorTheme.center || 'rgba(120, 180, 255, 0.95)');
                visorGradient.addColorStop(1, visorTheme.right || 'rgba(60, 120, 200, 0.8)');
                ctx.fillStyle = visorGradient;
                ctx.beginPath();
                ctx.moveTo(0, -baseSize * 0.48);
                ctx.lineTo(baseSize * 0.42, -baseSize * 0.22);
                ctx.lineTo(baseSize * 0.32, 0);
                ctx.lineTo(-baseSize * 0.32, 0);
                ctx.lineTo(-baseSize * 0.42, -baseSize * 0.22);
                ctx.closePath();
                ctx.fill();

                // Accent struts
                ctx.globalAlpha = 0.85;
                ctx.strokeStyle = withAlpha(accentColor, level >= 4 ? 0.95 : 0.8);
                ctx.lineWidth = 1.9;
                ctx.beginPath();
                ctx.moveTo(-baseSize * 0.36, baseSize * 0.26);
                ctx.lineTo(baseSize * 0.36, baseSize * 0.26);
                ctx.moveTo(-baseSize * 0.25, baseSize * 0.62);
                ctx.lineTo(baseSize * 0.25, baseSize * 0.62);
                ctx.stroke();

                // Core glow
                ctx.globalAlpha = 0.78;
                const coreGradient = ctx.createRadialGradient(0, baseSize * 0.18, 0, 0, baseSize * 0.18, baseSize * 0.52);
                coreGradient.addColorStop(0, withAlpha(accentColor, 0.85));
                coreGradient.addColorStop(1, withAlpha(trailColor, 0.26));
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, baseSize * 0.18, baseSize * 0.48, 0, Math.PI * 2);
                ctx.fill();

                // Level indicators
                ctx.globalAlpha = 0.85;
                const levelCount = Math.min(6, level);
                for (let i = 0; i < levelCount; i++) {
                    const angle = (i / levelCount) * Math.PI * 2 + auraPhase * 0.18;
                    const lx = Math.cos(angle) * (baseSize + 6);
                    const ly = Math.sin(angle) * (baseSize + 6);
                    ctx.fillStyle = withAlpha(accentColor, 0.88);
                    ctx.beginPath();
                    ctx.arc(lx, ly, 2.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Shield ring
                if (shield > 0) {
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(trailColor, 0.85);
                    ctx.lineWidth = 2.4;
                    const shieldRatio = Math.min(1, shield / (champion?.shieldMax || shield + 60));
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 1.28, -Math.PI / 2, -Math.PI / 2 + shieldRatio * Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                drawChampionPreviewMinions(ctx, centerX, centerY + offsetY, presentation, baseSize, time);
                drawChampionPreviewEffect(ctx, centerX, centerY + offsetY, animationType, presentation, baseSize, time);
            }

            function drawPlaceholderChampion(ctx, animationType, presentation) {
                drawChampionPreview(ctx, presentation, animationType, { forcePlaceholder: true });
            }

            function drawChampionPreviewMinions(ctx, x, y, presentation, baseSize, time) {
                const { skinTheme, champion, upgradeState } = presentation;
                const theme = skinTheme?.minion || CHAMPION_SKIN_THEMES.default.minion;
                const selectedProtocol = upgradeState?.minionProtocols || 0;
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[selectedProtocol] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                let minionCount = protocol.minionCount || 2;

                if (minionCount <= 0) return;

                const radius = baseSize * (1.9 + minionCount * 0.14);
                for (let i = 0; i < minionCount; i++) {
                    const angle = time * 0.9 + (i / minionCount) * Math.PI * 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius * 0.6;

                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = withAlpha(theme.trail || '#4362a8', 0.4);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(px, py);
                    ctx.stroke();
                    ctx.restore();

                    ctx.save();
                    ctx.translate(px, py);
                    ctx.globalAlpha = 0.82;
                    ctx.fillStyle = withAlpha(theme.core || '#bcd4ff', 0.9);
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.32, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(theme.aura || '#82a7ff', 0.75);
                    ctx.lineWidth = 1.5;
                    const pulse = 1 + Math.sin(time * 3.2 + i) * 0.18;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.44 * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            function drawChampionPreviewEffect(ctx, x, y, animationType, presentation, baseSize, time) {
                const { upgradeState, skinTheme } = presentation;
                const trailColor = skinTheme?.trail || '#78b4ff';
                const accent = skinTheme?.body?.accent || trailColor;

                // Get selected modules
                const attackModule = upgradeState?.attackModule || 'default';
                const cadenceLevel = upgradeState?.cadenceLevel || 0;
                const minionProtocol = upgradeState?.minionProtocols || 0;

                switch (animationType) {
                    case 'idle': // Attack Module demo
                        drawAttackModuleEffect(ctx, x, y, attackModule, baseSize * 1.2, time, accent, trailColor);
                        break;
                    case 'attack': // Cadence Core demo
                        drawCadenceEffect(ctx, x, y, cadenceLevel, baseSize * 1.2, time, accent, trailColor);
                        break;
                    case 'special': // Minion Protocol demo
                        drawMinionProtocolEffect(ctx, x, y, minionProtocol, baseSize * 1.2, time, accent, trailColor);
                        break;
                }
            }

            function drawAttackModuleEffect(ctx, x, y, moduleId, baseSize, time, accent, trailColor) {
                const module = CHAMPION_ATTACK_MODULE_MAP[moduleId];
                if (!module) return;

                switch (moduleId) {
                    case 'charge_cannon':
                        // Charge up effect
                        const chargeProgress = Math.sin(time * 3) * 0.5 + 0.5;
                        ctx.save();
                        ctx.globalAlpha = 0.9;
                        ctx.strokeStyle = withAlpha(accent, chargeProgress * 0.8);
                        ctx.lineWidth = 4 + chargeProgress * 3;
                        ctx.beginPath();
                        ctx.arc(x, y, baseSize * (1.3 + chargeProgress * 0.6), 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                        break;
                    case 'lightning_storm':
                        // Lightning arcs
                        const bolts = 3;
                        ctx.globalAlpha = 0.85;
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = withAlpha('#d4e6ff', 0.95);
                        for (let i = 0; i < bolts; i++) {
                            const angle = time * 2.4 + i * (Math.PI * 2 / bolts);
                            const ex = x + Math.cos(angle) * baseSize * 1.8;
                            const ey = y + Math.sin(angle) * baseSize * 1.4;
                            ctx.beginPath();
                            ctx.moveTo(x, y - baseSize * 0.3);
                            ctx.lineTo((x + ex) / 2 + Math.sin(time * 8 + i) * 8, (y + ey) / 2 + Math.cos(time * 7 + i) * 6);
                            ctx.lineTo(ex, ey);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1;
                        break;
                    case 'plasma_burst':
                        // Plasma projectiles
                        const burstCount = 5;
                        for (let i = 0; i < burstCount; i++) {
                            const angle = time * 1.5 + i * (Math.PI * 2 / burstCount);
                            const px = x + Math.cos(angle) * baseSize * 1.4;
                            const py = y + Math.sin(angle) * baseSize * 1.0;
                            ctx.save();
                            ctx.translate(px, py);
                            ctx.globalAlpha = 0.9;
                            ctx.fillStyle = withAlpha('#4adeff', 0.95);
                            ctx.beginPath();
                            ctx.arc(0, 0, baseSize * 0.18, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                        break;
                    case 'void_beam':
                        // Void beam
                        ctx.save();
                        ctx.globalAlpha = 0.9;
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = withAlpha('#c6a4ff', 0.8);
                        ctx.lineWidth = 6;
                        ctx.beginPath();
                        ctx.moveTo(x, y - baseSize * 0.4);
                        ctx.lineTo(x, y - baseSize * 4.0);
                        ctx.stroke();
                        ctx.restore();
                        break;
                    case 'cluster_launcher':
                        // Cluster missiles
                        const clusterCount = 6;
                        for (let i = 0; i < clusterCount; i++) {
                            const angle = time * 1.2 + i * (Math.PI * 2 / clusterCount);
                            const px = x + Math.cos(angle) * baseSize * 1.5;
                            const py = y + Math.sin(angle) * baseSize * 1.1;
                            ctx.save();
                            ctx.translate(px, py);
                            ctx.rotate(angle + Math.PI / 2);
                            ctx.globalAlpha = 0.8;
                            ctx.fillStyle = withAlpha('#ff6b35', 0.95);
                            ctx.beginPath();
                            ctx.moveTo(0, -baseSize * 0.22);
                            ctx.lineTo(baseSize * 0.09, baseSize * 0.22);
                            ctx.lineTo(-baseSize * 0.09, baseSize * 0.22);
                            ctx.closePath();
                            ctx.fill();
                            ctx.restore();
                        }
                        break;
                    default: // Starfall Salvo volley
                        const volleyCount = 3;
                        for (let i = 0; i < volleyCount; i++) {
                            const angle = time * 2 + i * (Math.PI * 2 / volleyCount);
                            const px = x + Math.cos(angle) * baseSize * 1.2;
                            const py = y + Math.sin(angle) * baseSize * 0.8;
                            ctx.save();
                            ctx.translate(px, py);
                            ctx.globalAlpha = 0.8;
                            ctx.fillStyle = withAlpha(accent, 0.9);
                            ctx.beginPath();
                            ctx.arc(0, 0, baseSize * 0.12, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                        break;
                }
            }

            function drawCadenceEffect(ctx, x, y, cadenceLevel, baseSize, time, accent, trailColor) {
                const cadence = CHAMPION_CADENCE_LEVELS[cadenceLevel] || CHAMPION_CADENCE_LEVELS[0];

                // Show firing pattern based on cadence
                const fireRate = cadence.fireRate || 1.4;
                const burstSize = cadence.burstSize || 1;

                // Simulate firing pattern
                const fireInterval = 1 / fireRate;
                const timeInCycle = time % fireInterval;
                const progress = timeInCycle / fireInterval;

                if (progress < 0.3) { // Firing phase
                    for (let i = 0; i < burstSize; i++) {
                        const offset = (i - (burstSize - 1) / 2) * baseSize * 0.35;
                        ctx.save();
                        ctx.translate(x + offset, y - baseSize * 0.6);
                        ctx.globalAlpha = 0.95;
                        ctx.fillStyle = withAlpha(accent, 0.98);
                        ctx.beginPath();
                        ctx.arc(0, 0, baseSize * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }

                // Show cooldown ring
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = withAlpha(trailColor, 0.9);
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, baseSize * 1.2, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            function drawMinionProtocolEffect(ctx, x, y, protocolLevel, baseSize, time, accent, trailColor) {
                const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[protocolLevel] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                const minionCount = protocol.minionCount || 2;

                // Draw orbiting minions
                const radius = baseSize * 2.0;
                for (let i = 0; i < minionCount; i++) {
                    const angle = time * 0.8 + (i / minionCount) * Math.PI * 2;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius * 0.6;

                    // Minion tether
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = withAlpha(trailColor, 0.7);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(px, py);
                    ctx.stroke();
                    ctx.restore();

                    // Minion body
                    ctx.save();
                    ctx.translate(px, py);
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = withAlpha(accent, 0.95);
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.28, 0, Math.PI * 2);
                    ctx.fill();

                    // Minion aura
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(trailColor, 0.8);
                    ctx.lineWidth = 2;
                    const pulse = 1 + Math.sin(time * 3 + i) * 0.25;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseSize * 0.4 * pulse, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            function updateChampionStats() {
                const presentation = getSelectedChampionPresentation();
                const { champion, player } = presentation;
                const levels = player?.upgradeLevels || {};

                const stats = {
                    health: 180,
                    maxHealth: 180,
                    shield: 0,
                    maxShield: 0,
                    attackPower: 28,
                    fireRate: 1.4,
                    level: champion?.level || 1,
                    experience: champion?.xp || 0,
                    maxExp: getChampionLevelUpCost(champion?.level || 1)
                };

                if (champion) {
                    stats.health = Math.floor(champion.hp || 0);
                    stats.maxHealth = Math.floor(champion.hpMax || 0) || 180;
                    stats.shield = Math.floor(champion.shield || 0);
                    stats.maxShield = Math.floor(champion.shieldMax || 0);
                    stats.level = champion.level || 1;
                    stats.experience = champion.xp || 0;
                    stats.maxExp = getChampionLevelUpCost(stats.level);
                    stats.fireRate = 1 / Math.max(0.2, champion.fireCooldown || 1.5);

                    const baseDamage = 25 + stats.level * 8;
                    const damageScale = champion.damageScale || 1;
                    stats.attackPower = Math.floor(baseDamage * damageScale);
                } else {
                    const healthBonus = 1 + (levels.champion_health || 0) * 0.2;
                    stats.maxHealth = Math.round(stats.maxHealth * healthBonus);
                    stats.health = stats.maxHealth;
                    stats.maxShield = (levels.champion_shield || 0) * 30;
                    stats.shield = stats.maxShield;
                    stats.attackPower = Math.round(stats.attackPower + (levels.champion_damage || 0) * 25);
                    stats.fireRate = 1.4 + (levels.champion_speed || 0) * 0.12;
                }

                applyChampionLoadoutLabels(presentation);

                q('championHealthStat').textContent = `${stats.health}/${stats.maxHealth}`;
                q('championShieldStat').textContent = stats.maxShield > 0 ? `${stats.shield}/${stats.maxShield}` : 'None';
                q('championAttackStat').textContent = stats.attackPower;
                q('championFireRateStat').textContent = `${stats.fireRate.toFixed(1)}/s`;
                q('championLevelStat').textContent = stats.level;
                q('championExpStat').textContent = `${stats.experience}/${stats.maxExp}`;

                updateChampionAttackTypes(presentation);
                updateChampionUpgrades(presentation);
            }

            function updateChampionAttackTypes(presentation = getSelectedChampionPresentation()) {
                const container = q('championAttackTypesList');
                if (!container) return;

                container.innerHTML = '';

                const { profile, upgradeState } = presentation;
                const attackTypes = [];
                const seen = new Set();

                if (upgradeState?.attackModule && upgradeState.attackModule !== 'default') {
                    const module = CHAMPION_ATTACK_MODULE_MAP[upgradeState.attackModule];
                    if (module) {
                        attackTypes.push({
                            id: `module-${module.id}`,
                            name: `${module.name}`,
                            icon: module.icon || 'ðŸ› ï¸',
                            description: module.desc
                        });
                        seen.add(`module-${module.id}`);
                    }
                }

                (profile?.abilityHighlights || []).forEach(ability => {
                    if (!ability) return;
                    const key = ability.id || ability.name;
                    if (seen.has(key)) return;
                    seen.add(key);
                    attackTypes.push(ability);
                });

                CHAMPION_COMBAT_SUMMARY.forEach(summary => {
                    if (!summary) return;
                    const key = summary.id || summary.name;
                    if (key && seen.has(key)) return;
                    if (key) seen.add(key);
                    attackTypes.push(summary);
                });

                if (!attackTypes.length) {
                    attackTypes.push({
                        name: 'Starfall Salvo',
                        icon: 'âœ¨',
                        description: 'Staggered plasma bolts that lock to the guardianâ€™s focus.'
                    });
                }

                attackTypes.forEach(attack => {
                    const div = document.createElement('div');
                    div.className = 'attack-type-item';
                    const iconHtml = attack.icon ? `<span class="ability-icon">${attack.icon}</span>` : '';
                    div.innerHTML = `
                <div class="attack-name">${iconHtml}${attack.name}</div>
                <div>${attack.description || ''}</div>
            `;
                    container.appendChild(div);
                });
            }

            function updateChampionUpgrades(presentation = getSelectedChampionPresentation()) {
                const container = q('championUpgradesList');
                if (!container) return;

                container.innerHTML = '';

                const { player, champion, upgradeState, skinOption, profile } = presentation;
                const levels = player?.upgradeLevels || {};
                const upgrades = [];

                const cadenceOption = CHAMPION_CADENCE_LEVELS[upgradeState?.cadenceLevel || 0] || CHAMPION_CADENCE_LEVELS[0];
                upgrades.push({
                    name: `Cadence Â· ${cadenceOption.name}`,
                    description: cadenceOption.desc
                });

                const protocolOption = CHAMPION_MINION_PROTOCOL_LEVELS[upgradeState?.minionProtocols || 0] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                upgrades.push({
                    name: `Minion Protocol Â· ${protocolOption.name}`,
                    description: protocolOption.desc
                });

                if (upgradeState?.attackModule && upgradeState.attackModule !== 'default') {
                    const module = CHAMPION_ATTACK_MODULE_MAP[upgradeState.attackModule];
                    if (module) {
                        upgrades.push({
                            name: `Attack Module Â· ${module.name}`,
                            description: module.desc
                        });
                    }
                } else {
                    upgrades.push({
                        name: 'Attack Module Â· Starfall Salvo',
                        description: 'Baseline plasma barrage configured for sustained guardian fire.'
                    });
                }

                if (skinOption) {
                    upgrades.push({
                        name: `Skin Â· ${skinOption.name}`,
                        description: skinOption.desc || profile?.signature || ''
                    });
                }

                if (levels.champion_health > 0) {
                    upgrades.push({
                        name: 'Enhanced Vitality',
                        description: `Health increased by ${levels.champion_health * 20}%`,
                        level: levels.champion_health
                    });
                }

                if (levels.champion_damage > 0) {
                    upgrades.push({
                        name: 'Combat Amplifier',
                        description: `Attack power increased by ${levels.champion_damage * 25}%`,
                        level: levels.champion_damage
                    });
                }

                if (levels.champion_speed > 0) {
                    upgrades.push({
                        name: 'Mobility Enhancement',
                        description: `Movement and attack speed increased by ${levels.champion_speed * 15}%`,
                        level: levels.champion_speed
                    });
                }

                if (levels.champion_shield > 0) {
                    upgrades.push({
                        name: 'Defensive Matrix',
                        description: `Shield capacity increased by ${levels.champion_shield * 30} points`,
                        level: levels.champion_shield
                    });
                }

                if (levels.champion_regen > 0) {
                    upgrades.push({
                        name: 'Auto-Repair System',
                        description: `Regenerates ${levels.champion_regen * 2} health per second`,
                        level: levels.champion_regen
                    });
                }

                if (champion && champion.level > 1) {
                    upgrades.push({
                        name: 'Combat Experience',
                        description: `Level ${champion.level} â€” Guardian combat AI unlocked new tactics`,
                        level: champion.level
                    });
                }

                if (!upgrades.length) {
                    const div = document.createElement('div');
                    div.className = 'upgrade-item';
                    div.innerHTML = `
                <div class="upgrade-name">No Active Upgrades</div>
                <div>Visit the Upgrade Hangar to enhance your champion</div>
            `;
                    container.appendChild(div);
                    return;
                }

                upgrades.forEach(upgrade => {
                    const div = document.createElement('div');
                    div.className = 'upgrade-item';
                    const levelTag = upgrade.level && upgrade.level > 1 ? ` (Lv.${upgrade.level})` : '';
                    div.innerHTML = `
                <div class="upgrade-name">${upgrade.name}${levelTag}</div>
                <div>${upgrade.description || ''}</div>
            `;
                    container.appendChild(div);
                });
            }

            function setChampionPresetStatus(message, type = '') {
                const statusEl = q('championPresetStatus');
                if (!statusEl) return;
                statusEl.textContent = message || '';
                statusEl.classList.remove('success', 'error');
                if (type) {
                    statusEl.classList.add(type);
                }
            }

            function resetChampionPresetPanel({ preserveInput = false } = {}) {
                const output = q('championPresetCodeOutput');
                if (output) {
                    output.value = store.lastChampionPresetCode || '';
                }
                if (!preserveInput) {
                    const input = q('championPresetCodeInput');
                    if (input) input.value = '';
                }
                if (!preserveInput) {
                    setChampionPresetStatus('');
                }
            }

            function loadChampionPresetCode(code, options = {}) {
                const preset = decodeChampionPresetCode(code);
                if (!preset) {
                    return { success: false, message: 'Invalid or corrupted champion code.' };
                }
                const applied = applyChampionPresetToPlayer(preset, options);
                if (!applied) {
                    return { success: false, message: 'Unable to apply champion configuration.' };
                }
                store.lastChampionPresetCode = code;
                return { success: true, preset };
            }

            function updateChampionBuilderDetails() {
                const formatLabel = (value) => {
                    if (value === undefined || value === null) return '';
                    return String(value)
                        .replace(/[_-]+/g, ' ')
                        .split(' ')
                        .filter(Boolean)
                        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
                        .join(' ');
                };

                const pluralize = (count, singular, plural = `${singular}s`) => {
                    const safeCount = Number(count);
                    if (!Number.isFinite(safeCount)) return plural;
                    return safeCount === 1 ? singular : plural;
                };

                const attackDetail = q('attackModuleDetail');
                if (attackDetail) {
                    const select = q('attackModuleSelect');
                    const value = select ? select.value : 'default';
                    const module = value && value !== 'default' ? CHAMPION_ATTACK_MODULE_MAP[value] : null;
                    const info = module ? module : {
                        icon: 'âœ¨',
                        name: 'Starfall Salvo',
                        desc: 'Radiant starfire bolts cascade toward your focus target and nearby threats.',
                        damageType: 'adaptive',
                        targetType: 'multi-role',
                        attackSpeed: 'balanced',
                        tradeOff: 'Reliable baseline pattern without specialized amplification.'
                    };
                    const meta = [];
                    if (info.damageType) {
                        meta.push(`<li><strong>Damage Type:</strong> ${escapeHtml(formatLabel(info.damageType))}</li>`);
                    }
                    if (info.attackSpeed) {
                        meta.push(`<li><strong>Tempo:</strong> ${escapeHtml(formatLabel(info.attackSpeed))}</li>`);
                    }
                    if (info.targetType) {
                        meta.push(`<li><strong>Target Profile:</strong> ${escapeHtml(formatLabel(info.targetType))}</li>`);
                    }
                    if (info.tradeOff) {
                        meta.push(`<li><strong>Trade-Off:</strong> ${escapeHtml(info.tradeOff)}</li>`);
                    }
                    if (module && module.specialEffect) {
                        meta.push(`<li><strong>Signature Effect:</strong> ${escapeHtml(formatLabel(module.specialEffect))}</li>`);
                    }
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    attackDetail.innerHTML = `
                        <div class="builder-detail-title"><span>${escapeHtml(info.icon || 'âœ¨')}</span><span>${escapeHtml(info.name || 'Starfall Salvo')}</span></div>
                        <p>${escapeHtml(info.desc || 'Radiant starfire bolts cascade toward your focus target and nearby threats.')}</p>
                        ${metaHtml}
                    `;
                }

                const cadenceDetail = q('cadenceDetail');
                if (cadenceDetail) {
                    const select = q('cadenceSelect');
                    const selected = select ? parseInt(select.value, 10) : 0;
                    const cadence = CHAMPION_CADENCE_LEVELS[selected] || CHAMPION_CADENCE_LEVELS[0];
                    const meta = [];
                    if (Number.isFinite(cadence.fireRateMult)) {
                        const fireMult = cadence.fireRateMult;
                        const fireDelta = Math.round((1 - fireMult) * 100);
                        const fireLabel = Math.abs(fireDelta) < 1
                            ? 'Matches baseline timing'
                            : fireDelta > 0
                                ? `${fireDelta}% faster firing cadence`
                                : `${Math.abs(fireDelta)}% slower firing cadence`;
                        meta.push(`<li><strong>Weapon Tempo:</strong> ${escapeHtml(fireLabel)} (Ã—${fireMult.toFixed(2)})</li>`);
                    }
                    if (Number.isFinite(cadence.dashCooldownMult)) {
                        const dashMult = cadence.dashCooldownMult;
                        const dashDelta = Math.round((1 - dashMult) * 100);
                        const dashLabel = Math.abs(dashDelta) < 1
                            ? 'Baseline dash cooldown'
                            : dashDelta > 0
                                ? `${dashDelta}% quicker recovery`
                                : `${Math.abs(dashDelta)}% longer recovery`;
                        meta.push(`<li><strong>Dash Systems:</strong> ${escapeHtml(dashLabel)} (Ã—${dashMult.toFixed(2)})</li>`);
                    }
                    meta.push(`<li><strong>Cadence Tier:</strong> Level ${escapeHtml(cadence.level ?? 0)}</li>`);
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    cadenceDetail.innerHTML = `
                        <div class="builder-detail-title"><span>ðŸŽµ</span><span>${escapeHtml(cadence.name || 'Baseline Cadence')}</span></div>
                        <p>${escapeHtml(cadence.desc || 'Standard guardian timing.')}</p>
                        ${metaHtml}
                    `;
                }

                const protocolDetail = q('protocolDetail');
                if (protocolDetail) {
                    const select = q('protocolSelect');
                    const selected = select ? parseInt(select.value, 10) : 0;
                    const protocol = CHAMPION_MINION_PROTOCOL_LEVELS[selected] || CHAMPION_MINION_PROTOCOL_LEVELS[0];
                    const meta = [];
                    if (Number.isFinite(protocol.minionCount)) {
                        const droneWord = pluralize(protocol.minionCount, 'drone');
                        meta.push(`<li><strong>Escort Count:</strong> ${escapeHtml(`${protocol.minionCount} ${droneWord}`)}</li>`);
                    }
                    if (Number.isFinite(protocol.damageMult)) {
                        const dmgDelta = Math.round((protocol.damageMult - 1) * 100);
                        const dmgLabel = Math.abs(dmgDelta) < 1
                            ? 'Baseline damage output'
                            : dmgDelta > 0
                                ? `+${dmgDelta}% damage`
                                : `${dmgDelta}% damage`;
                        meta.push(`<li><strong>Damage Output:</strong> ${escapeHtml(dmgLabel)} (Ã—${protocol.damageMult.toFixed(2)})</li>`);
                    }
                    if (Number.isFinite(protocol.fireRateMult)) {
                        const rateDelta = Math.round((1 - protocol.fireRateMult) * 100);
                        const rateLabel = Math.abs(rateDelta) < 1
                            ? 'Baseline firing tempo'
                            : rateDelta > 0
                                ? `${rateDelta}% faster firing`
                                : `${Math.abs(rateDelta)}% slower firing`;
                        meta.push(`<li><strong>Fire Tempo:</strong> ${escapeHtml(rateLabel)} (Ã—${protocol.fireRateMult.toFixed(2)})</li>`);
                    }
                    if (Number.isFinite(protocol.slowFactor)) {
                        const slow = Math.round((1 - protocol.slowFactor) * 100);
                        if (slow > 0) {
                            meta.push(`<li><strong>Debilitation:</strong> Slows enemies by ${escapeHtml(slow)}%</li>`);
                        }
                    }
                    if (Number.isFinite(protocol.novaDamageScale) && protocol.novaDamageScale > 0) {
                        meta.push(`<li><strong>Nova Splash:</strong> ${escapeHtml(Math.round(protocol.novaDamageScale * 100))}% of minion damage in an area</li>`);
                    }
                    meta.push(`<li><strong>Protocol Tier:</strong> Level ${escapeHtml(protocol.level ?? 0)}</li>`);
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    protocolDetail.innerHTML = `
                        <div class="builder-detail-title"><span>ðŸ›°ï¸</span><span>${escapeHtml(protocol.name || 'Escort Drones')}</span></div>
                        <p>${escapeHtml(protocol.desc || 'Standard escort pattern.')}</p>
                        ${metaHtml}
                    `;
                }

                const skinDetail = q('skinDetail');
                if (skinDetail) {
                    const select = q('skinSelect');
                    const value = select ? select.value : 'default';
                    const skin = CHAMPION_SKIN_OPTION_MAP[value] || CHAMPION_SKIN_OPTION_MAP.default;
                    const meta = [];
                    if (Number.isFinite(skin.cost)) {
                        if (skin.cost <= 0) {
                            meta.push('<li><strong>Cost:</strong> Unlocked by default</li>');
                        } else {
                            meta.push(`<li><strong>Cost:</strong> ${escapeHtml(skin.cost)} credits</li>`);
                        }
                    }
                    if (skin.theme) {
                        meta.push(`<li><strong>Theme:</strong> ${escapeHtml(formatLabel(skin.theme))}</li>`);
                    }
                    const metaHtml = meta.length ? `<ul class="builder-detail-meta">${meta.join('')}</ul>` : '';
                    skinDetail.innerHTML = `
                        <div class="builder-detail-title"><span>${escapeHtml(skin.icon || 'ðŸ’ ')}</span><span>${escapeHtml(skin.name || 'Void Vanguard')}</span></div>
                        <p>${escapeHtml(skin.desc || 'Baseline guardian plating.')}</p>
                        ${metaHtml}
                    `;
                }
            }

            function populateChampionBuilder() {
                const state = getChampionUpgradeState();

                // Attack Module Select
                const attackSelect = q('attackModuleSelect');
                if (attackSelect) {
                    attackSelect.innerHTML = '<option value="default">Starfall Salvo</option>';
                    const unlockedModules = Object.entries(state.unlockedAttacks || {})
                        .filter(([, unlocked]) => !!unlocked)
                        .map(([moduleId]) => moduleId);

                    // Group modules by damage type for better organization
                    const modulesByType = {
                        kinetic: [],
                        fire: [],
                        laser: [],
                        lightning: []
                    };

                    unlockedModules.forEach(moduleId => {
                        const module = CHAMPION_ATTACK_MODULE_MAP[moduleId];
                        if (module && module.damageType) {
                            modulesByType[module.damageType].push(module);
                        }
                    });

                    // Add grouped options with enhanced descriptions
                    Object.entries(modulesByType).forEach(([damageType, modules]) => {
                        if (modules.length > 0) {
                            const group = document.createElement('optgroup');
                            group.label = `${damageType.toUpperCase()} MODULES`;

                            modules.forEach(module => {
                                const option = document.createElement('option');
                                option.value = module.id;
                                option.textContent = `${module.icon} ${module.name} - ${module.tradeOff}`;
                                option.title = module.desc;
                                group.appendChild(option);
                            });

                            attackSelect.appendChild(group);
                        }
                    });

                    const desiredModule = state.attackModule || 'default';
                    attackSelect.value = attackSelect.querySelector(`option[value="${desiredModule}"]`) ? desiredModule : 'default';
                    if (attackSelect.value !== desiredModule) {
                        state.attackModule = attackSelect.value;
                    }
                }

                // Cadence Select
                const cadenceSelect = q('cadenceSelect');
                if (cadenceSelect) {
                    cadenceSelect.innerHTML = '';
                    CHAMPION_CADENCE_LEVELS.forEach((level, index) => {
                        if (index <= (state.cadenceLevel || 0)) {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = level.name;
                            cadenceSelect.appendChild(option);
                        }
                    });
                    const desiredCadence = state.cadenceLevel || 0;
                    cadenceSelect.value = cadenceSelect.querySelector(`option[value="${desiredCadence}"]`) ? desiredCadence : 0;
                    if (parseInt(cadenceSelect.value) !== desiredCadence) {
                        state.cadenceLevel = parseInt(cadenceSelect.value);
                    }
                }

                // Protocol Select
                const protocolSelect = q('protocolSelect');
                if (protocolSelect) {
                    protocolSelect.innerHTML = '';
                    CHAMPION_MINION_PROTOCOL_LEVELS.forEach((level, index) => {
                        if (index <= (state.minionProtocols || 0)) {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = level.name;
                            protocolSelect.appendChild(option);
                        }
                    });
                    const desiredProtocol = state.minionProtocols || 0;
                    protocolSelect.value = protocolSelect.querySelector(`option[value="${desiredProtocol}"]`) ? desiredProtocol : 0;
                    if (parseInt(protocolSelect.value) !== desiredProtocol) {
                        state.minionProtocols = parseInt(protocolSelect.value);
                    }
                }

                // Skin Select
                const skinSelect = q('skinSelect');
                if (skinSelect) {
                    skinSelect.innerHTML = '<option value="default">Void Vanguard</option>';
                    const unlockedSkins = Object.entries(state.unlockedSkins || {})
                        .filter(([skinId, unlocked]) => skinId !== 'default' && !!unlocked)
                        .map(([skinId]) => skinId);
                    unlockedSkins.forEach(skinId => {
                        const skin = CHAMPION_SKIN_OPTION_MAP[skinId];
                        if (skin && !skinSelect.querySelector(`option[value="${skinId}"]`)) {
                            const option = document.createElement('option');
                            option.value = skinId;
                            option.textContent = skin.name;
                            skinSelect.appendChild(option);
                        }
                    });
                    const desiredSkin = state.skin || 'default';
                    skinSelect.value = skinSelect.querySelector(`option[value="${desiredSkin}"]`) ? desiredSkin : 'default';
                    if (skinSelect.value !== desiredSkin) {
                        state.skin = skinSelect.value;
                    }
                }

                updateChampionBuilderDetails();
            }

            function populateChampionUpgradeGrid() {
                const grid = q('championUpgradeGrid');
                if (!grid) return;

                const rawItems = Object.keys(SHOP_UPGRADES)
                    .map(key => {
                        const upgrade = SHOP_UPGRADES[key];
                        if (!upgrade || upgrade.category !== 'champion') return null;
                        if (typeof upgrade.isVisible === 'function' && !upgrade.isVisible()) return null;
                        return { key, upgrade };
                    })
                    .filter(Boolean);

                const currentItems = rawItems.map(item => ({ ...item, info: getNextUpgradeCost(item.key) }));

                grid.innerHTML = '';

                for (const entry of currentItems) {
                    const { key, upgrade, info } = entry;
                    const icon = upgrade.icon ?? 'âš”ï¸';
                    const level = (store.player?.upgradeLevels && store.player.upgradeLevels[key]) || 0;
                    const name = typeof upgrade.getName === 'function' ? upgrade.getName(info, level) : upgrade.name;
                    let desc = typeof upgrade.desc === 'function' ? upgrade.desc(level, info) : upgrade.desc;
                    const costValue = info && Number.isFinite(info.cost) ? info.cost : upgrade.cost;
                    const costText = Number.isFinite(costValue) ? costValue : '---';
                    const available = info ? !!info.available : (Number.isFinite(costValue) && (store.world?.gold ?? 0) >= costValue);
                    const isDisabled = !available;
                    if (isDisabled && info && info.reason) {
                        desc = info.reason;
                    }

                    const div = document.createElement('div');
                    div.className = `upgrade-card ${isDisabled ? 'disabled' : ''}`;
                    div.innerHTML = `
                <div class="upgrade-icon">${icon}</div>
                <div class="upgrade-content">
                    <div class="upgrade-title">${name || ''}</div>
                    <div class="upgrade-desc">${desc || ''}</div>
                    <div class="upgrade-cost">Cost: ${costText}</div>
                </div>
            `;
                    div.addEventListener('click', () => {
                        if (!isDisabled) {
                            attemptPurchaseUpgrade(key);
                            populateChampionUpgradeGrid();
                            populateChampionBuilder();
                            updateChampionPreview();
                            updateChampionStats();
                        }
                    });
                    grid.appendChild(div);
                }
            }

            function getChampionLevelUpCost(currentLevel) {
                // Progressive XP cost for champion levels
                return Math.floor(100 * Math.pow(1.5, currentLevel - 1));
            }

            // Function to refresh laboratory if it's currently open
            function refreshPrimordialSoldierLaboratory() {
                const panel = q("championDressingRoom");
                if (panel && !panel.classList.contains("hide")) {
                    populateChampionBuilder();
                    populateChampionUpgradeGrid();
                    updateChampionPreview();
                    updateChampionStats();
                    resetChampionPresetPanel({ preserveInput: true });
                }
            }

            // Animation loop for champion preview
            let championPreviewAnimationFrame = null;

            function startChampionPreviewAnimation() {
                if (championPreviewAnimationFrame) return; // Already running

                function animate() {
                    const panel = q("championDressingRoom");
                    if (panel && !panel.classList.contains("hide")) {
                        updateChampionPreview();
                        championPreviewAnimationFrame = requestAnimationFrame(animate);
                    } else {
                        championPreviewAnimationFrame = null;
                    }
                }

                animate();
            }

            // Override the showPrimordialSoldierLaboratory function to start animation
            const originalShowPrimordialSoldierLaboratory = showPrimordialSoldierLaboratory;
            showPrimordialSoldierLaboratory = function () {
                originalShowPrimordialSoldierLaboratory();
                startChampionPreviewAnimation();
            };

            function stepPlayerChampion(dt) {
                const champion = store.playerChampion;
                const player = store.player;
                if (!champion || champion.dead || !player) return;

                champion.auraPulse = (champion.auraPulse || 0) + dt * 2.4;
                if (champion.dashCooldownTimer > 0) {
                    champion.dashCooldownTimer -= dt;
                }

                const hadTarget = !!(champion.currentTarget && !champion.currentTarget.dead && champion.currentTarget.hp > 0);
                const fireTimerBase = champion.fireTimer ?? champion.fireCooldown ?? PLAYER_CHAMPION_CONFIG.baseFireCooldown;
                champion.fireTimer = Math.max(0, fireTimerBase - dt);
                const combatProfile = ensureChampionCombatProfile(champion);
                if (combatProfile && Array.isArray(combatProfile.specials)) {
                    combatProfile.specials.forEach(special => {
                        if (!special) return;
                        special.timer = Math.max(0, (special.timer ?? 0) - dt);
                    });
                }

                const target = resolveChampionTarget(champion);
                if (!hadTarget && target && champion.fireTimer > 0.15) {
                    champion.fireTimer = Math.min(champion.fireTimer, 0.15);
                }

                if (target) {
                    champion.visualAim = Math.atan2(target.y - champion.y, target.x - champion.x);
                } else if (champion.roamAnchor) {
                    champion.visualAim = Math.atan2(champion.roamAnchor.y - champion.y, champion.roamAnchor.x - champion.x);
                } else {
                    const dx = champion.x - player.x;
                    const dy = champion.y - player.y;
                    champion.visualAim = Math.atan2(dy, dx);
                }

                const dashActive = champion.state === 'dash' || champion.state === 'special_charge';
                champion.swirlPhase = (champion.swirlPhase || 0) + dt * (dashActive ? 9 : 5.4);
                if (champion.swirlPhase > Math.PI * 2) champion.swirlPhase -= Math.PI * 2;

                // Handle laser beam damage over time
                if (champion.laserTimer > 0) {
                    champion.laserTimer -= dt;
                    if (champion.laserTarget && !champion.laserTarget.dead && champion.laserDamage) {
                        championDealDamage(champion.laserTarget, champion.laserDamage * dt * 2, { x: champion.x, y: champion.y });
                    }
                    if (champion.laserTimer <= 0) {
                        champion.laserTarget = null;
                        champion.laserDamage = 0;
                    }
                }

                const marginX = champion.r || 18;
                const marginY = champion.r || 18;
                const clampAnchor = (x, y) => ({
                    x: clamp(x, marginX, W - marginX),
                    y: clamp(y, marginY, H - marginY)
                });

                if (!champion.roamAnchor) {
                    champion.roamAnchor = clampAnchor(player.x, player.y - 120);
                    champion.roamMode = 'idle';
                    champion.roamTimer = 0;
                } else {
                    champion.roamAnchor = clampAnchor(champion.roamAnchor.x, champion.roamAnchor.y);
                }

                champion.roamTimer = (champion.roamTimer || 0) - dt;

                if (target) {
                    if (champion.roamMode !== 'target' || champion.roamTimer <= 0) {
                        const baseRadius = Math.max(120, Math.min(210, champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius));
                        const offsetAngle = Math.random() * Math.PI * 2;
                        const offsetDist = baseRadius * (0.4 + Math.random() * 0.8);
                        const anchorX = target.x + Math.cos(offsetAngle) * offsetDist;
                        const anchorY = target.y + Math.sin(offsetAngle) * offsetDist * 0.65;
                        champion.roamAnchor = clampAnchor(anchorX, anchorY);
                        champion.roamMode = 'target';
                        champion.roamTimer = 1.1 + Math.random() * 1.8;
                    }
                } else if (champion.roamMode !== 'idle' || champion.roamTimer <= 0) {
                    const px = clamp(player.x, 80, W - 80);
                    const py = clamp(player.y - 140, 80, H - 160);
                    const idleAngle = Math.random() * Math.PI * 2;
                    const idleDist = 140 + Math.random() * 160;
                    const anchorX = px + Math.cos(idleAngle) * idleDist;
                    const anchorY = py + Math.sin(idleAngle) * 90;
                    champion.roamAnchor = clampAnchor(anchorX, anchorY);
                    champion.roamMode = 'idle';
                    champion.roamTimer = 2.4 + Math.random() * 1.8;
                }

                if (dashActive) {
                    champion.dashTimer -= dt;
                    if (champion.dashVX || champion.dashVY) {
                        champion.visualAim = Math.atan2(champion.dashVY || 0, champion.dashVX || 0);
                    }
                    champion.x += (champion.dashVX || 0) * dt;
                    champion.y += (champion.dashVY || 0) * dt;
                    champion.echoCooldown = (champion.echoCooldown || 0) - dt;
                    if ((champion.echoCooldown || 0) <= 0) {
                        addShadowEcho(champion.x, champion.y);
                        champion.echoCooldown = 0.035;
                    }

                    const dashRadius = (champion.r || 20) + (champion.state === 'special_charge' ? 10 : 6);
                    const damage = champion.state === 'special_charge' && champion.chargeDamage ?
                        champion.chargeDamage :
                        (120 + (champion.level || 1) * 28) * (player.dmgMult || 1) * (champion.damageScale || 1);

                    if (!champion.dashHits) champion.dashHits = new Set();

                    if (store.boss && !store.boss.dead) {
                        const boss = store.boss;
                        const dx = boss.x - champion.x;
                        const dy = boss.y - champion.y;
                        const hitRadius = (boss.r || 70) + dashRadius;
                        if (dx * dx + dy * dy <= hitRadius * hitRadius && !champion.dashHits.has('boss')) {
                            championDealDamage(boss, damage, { x: champion.x, y: champion.y });
                            champion.dashHits.add('boss');
                            store.activeEffects.push(createEffect('hitSpark', boss.x, boss.y, boss.r || 60, { strength: 90 }));
                        }
                    }

                    forEachEnemyNearby(champion.x, champion.y, dashRadius + 48, enemy => {
                        if (!enemy || enemy.dead) return false;
                        if (enemy.id && champion.dashHits.has(enemy.id)) return false;
                        const dx = enemy.x - champion.x;
                        const dy = enemy.y - champion.y;
                        const hitRadius = (enemy.r || 18) + dashRadius;
                        if (dx * dx + dy * dy <= hitRadius * hitRadius) {
                            championDealDamage(enemy, damage, { x: champion.x, y: champion.y });
                            if (enemy.id) champion.dashHits.add(enemy.id);
                        }
                        return false;
                    });

                    if (champion.dashTimer <= 0) {
                        champion.state = null;
                        champion.dashVX = 0;
                        champion.dashVY = 0;
                        champion.dashHits = null;
                    }
                } else {
                    const guardRadius = Math.max(100, champion.guardRadius || PLAYER_CHAMPION_CONFIG.baseGuardRadius);
                    const orbitAspect = 0.55 + Math.min(0.25, (champion.level || 1) * 0.04);
                    champion.guardAngle = (champion.guardAngle || Math.random() * Math.PI * 2) + (champion.angularSpeed || 1.2) * dt * (target ? 1.2 : 0.85);
                    const desiredX = champion.roamAnchor.x + Math.cos(champion.guardAngle) * guardRadius;
                    const desiredY = champion.roamAnchor.y + Math.sin(champion.guardAngle) * guardRadius * orbitAspect;
                    const followFactor = Math.min(1, (champion.momentum || 4.3) * dt);
                    champion.x += (desiredX - champion.x) * followFactor;
                    champion.y += (desiredY - champion.y) * followFactor * 0.92;

                    if (target) {
                        const dx = target.x - champion.x;
                        const dy = target.y - champion.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        if (dist > 420) {
                            const chase = Math.min(220, (dist - 420) * 0.6);
                            champion.x += (dx / dist) * chase * dt;
                            champion.y += (dy / dist) * chase * dt * 0.85;
                        }
                    }

                    if (target && champion.fireTimer <= 0) {
                        const dx = target.x - champion.x;
                        const dy = target.y - champion.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const canDash = (champion.dashCooldownTimer || 0) <= 0 && dist <= 420;
                        const dashChance = dist <= 220 ? 0.65 : dist <= 320 ? 0.45 : 0.28;

                        if (canDash && Math.random() < dashChance) {
                            const dashSpeed = 480 + (champion.level || 1) * 55;
                            champion.state = 'dash';
                            champion.dashTimer = 0.32;
                            champion.dashDuration = 0.32;
                            champion.dashVX = (dx / dist) * dashSpeed;
                            champion.dashVY = (dy / dist) * dashSpeed;
                            champion.dashCooldownTimer = champion.dashCooldown || PLAYER_CHAMPION_CONFIG.baseDashCooldown;
                            champion.visualAim = Math.atan2(champion.dashVY, champion.dashVX);
                            champion.dashHits = new Set();
                            champion.echoCooldown = 0;
                            addShadowEcho(champion.x, champion.y);
                            champion.fireTimer = 0.4;
                        } else {
                            const targetTraits = classifyEnemyForChampionVulnerabilities(target);
                            const nearbyCount = countEnemiesAround(target.x, target.y, 220);
                            const selectedSpecial = selectChampionSpecialAbility(champion, target, {
                                targetTraits,
                                nearbyCount,
                                scanRadius: 240
                            });

                            if (selectedSpecial) {
                                executeChampionAbility(champion, selectedSpecial, {
                                    target,
                                    targetTraits,
                                    nearbyCount,
                                    ability: selectedSpecial,
                                    vulnerabilityProfile: selectedSpecial.vulnerabilities || null
                                });
                            } else {
                                executeChampionPrimary(champion, target, {
                                    ability: combatProfile?.primary,
                                    targetTraits,
                                    vulnerabilityProfile: combatProfile?.primary?.vulnerabilities || null
                                });
                            }
                        }
                    }
                }

                champion.x = clamp(champion.x, marginX, W - marginX);
                champion.y = clamp(champion.y, marginY, H - marginY);
            }

            function stepChampionMinions(dt) {
                if (!store.championMinions || store.championMinions.length === 0) return;
                const owner = store.playerChampion;
                if (!owner || owner.dead) {
                    store.championMinions.length = 0;
                    return;
                }

                for (let i = store.championMinions.length - 1; i >= 0; i--) {
                    const minion = store.championMinions[i];
                    if (!minion || minion.dead) {
                        // Check minion status effects and spawn appropriate death visuals
                        if (minion && !minion.deathProcessed) {
                            minion.deathProcessed = true;
                            const minionDeathType = getStackDeathType(minion, {
                                fallbackElement: minion.lastStackHitElement || null
                            });
                            
                            // Spawn status effect death visuals for minions
                            if (minionDeathType === 'ice') {
                                spawnIceShards(minion.x, minion.y, {
                                    enemyRadius: minion.r || 8
                                });
                            } else if (minionDeathType === 'fire') {
                                spawnFireWipeDeath(minion.x, minion.y, {
                                    enemyRadius: minion.r || 8,
                                    baseColor: minion.color || '#cdd0ff'
                                });
                            } else if (minionDeathType === 'poison') {
                                spawnPoisonDeath(minion.x, minion.y, {
                                    enemyRadius: minion.r || 8,
                                    baseColor: minion.color || '#cdd0ff'
                                });
                            } else {
                                // Default small explosion if no status effect
                                spawnGibs(minion.x, minion.y, minion.color || '#cdd0ff', 6);
                            }
                        }
                        store.championMinions.splice(i, 1);
                        continue;
                    }

                    minion.orbitAngle += (minion.orbitSpeed || 1.6) * dt;
                    minion.pulsePhase = (minion.pulsePhase || 0) + dt * 3.1;
                    const radius = minion.orbitRadius * (1 + Math.sin(minion.pulsePhase) * 0.03);
                    const targetX = owner.x + Math.cos(minion.orbitAngle) * radius;
                    const targetY = owner.y + Math.sin(minion.orbitAngle) * radius * 0.55;
                    minion.x += (targetX - minion.x) * Math.min(1, 10 * dt);
                    minion.y += (targetY - minion.y) * Math.min(1, 10 * dt);

                    const desiredCooldown = Math.max(0.75, 1.4 - (owner.level || 1) * 0.12);
                    minion.fireCooldown += (desiredCooldown - minion.fireCooldown) * Math.min(1, dt * 3);
                    minion.damageScale = 1 + ((owner.level || 1) - 1) * 0.18;

                    const hadTarget = !!(minion.currentTarget && !minion.currentTarget.dead && minion.currentTarget.hp > 0);
                    const fireBase = minion.fireTimer ?? minion.fireCooldown ?? desiredCooldown;
                    minion.fireTimer = Math.max(0, fireBase - dt);

                    const target = resolveChampionTarget(minion, { stickRange: 520, lingerMs: 220 });
                    if (!hadTarget && target && minion.fireTimer > 0.2) {
                        minion.fireTimer = Math.min(minion.fireTimer, 0.2);
                    }
                    if (minion.fireTimer <= 0 && target) {
                        const angle = Math.atan2(target.y - minion.y, target.x - minion.x);
                        const speed = 340 + (owner.level || 1) * 30;
                        const damage = (18 + (owner.level || 1) * 6) * (store.player?.dmgMult || 1) * (minion.damageScale || 1);
                        const abilityModule = minion.abilityModule || owner.attackModule || getChampionUpgradeState().attackModule || 'default';
                        const abilityTheme = minion.abilityTheme || getChampionMinionAbilityTheme(abilityModule);
                        const projectileColor = abilityTheme?.trail || abilityTheme?.ring || '#cdd0ff';
                        const bullet = spawnBullet({
                            x: minion.x,
                            y: minion.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 4,
                            col: projectileColor,
                            dmg: damage,
                            life: 1.6,
                            pierce: owner.level >= 4,
                            isChampionShot: true,
                            championAttackModule: owner.attackModule || getChampionUpgradeState().attackModule || 'default',
                            championLevel: owner.level || 1,
                            fromChampionMinion: true,
                            minionProtocolLevel: minion.protocolLevel || 0,
                            minionProtocolSlowFactor: minion.protocolSlowFactor ?? null,
                            minionProtocolNovaDamageScale: minion.protocolNovaDamageScale || 0
                        });
                        bullet.collisionSearchRadius = 150;
                        minion.fireTimer = minion.fireCooldown + Math.random() * 0.1;
                    }
                }
            }

            function createHound(side, isMini = false) {
                const isTuxedo = side === -1 || side === -2;
                let color = isTuxedo ? { main: '#222222', accent: '#FFFFFF' } : { main: '#F0E68C', accent: '#BDB76B' };

                let isUpgraded = false;
                let eyeType = 'normal';
                let expression = 'normal';
                let breed = 'standard';
                let eyeConfig = null;
                let radius = isMini ? 8 : 12; // Mini hounds are smaller

                if (Math.abs(side) > 1) {
                    isUpgraded = true;
                    if (side === -2) {
                        color = { main: '#c4b5a0', accent: '#333' };
                        eyeType = 'swirly';
                        expression = 'silly';
                    } else if (side === 2) {
                        color = { main: '#ffb366', accent: '#000' };
                        eyeType = 'dilated';
                        expression = 'mischievous';
                    } else if (side === 3 || side === 4) {
                        breed = 'bernese';
                        color = { main: '#1C1C1C', accent: '#FFFFFF', tan: '#6E4C2E' };
                        radius = isMini ? 10 : 14; // Mini bernese are smaller too
                        if (side === 3) {
                            eyeType = 'heterochromia';
                            eyeConfig = { type: 'heterochromia', colors: ['#5DADE2', '#8B4513'] };
                        } else {
                            eyeType = 'swirly';
                            eyeConfig = { type: 'swirly' };
                        }
                        expression = 'loyal';
                    }
                }

                return {
                    x: store.player.x + 50 * side,
                    y: store.player.y + 20,
                    side,
                    target: null,
                    attackT: 0,
                    r: radius,
                    killCount: 0,
                    color,
                    isUpgraded,
                    eyeType,
                    eyeConfig,
                    expression,
                    breed,
                    isMini
                };
            }
            function selectHoundPackTarget() {
                if (!store.player?.hasHounds || !Array.isArray(store.hounds) || store.hounds.length === 0) {
                    store.houndPackTarget = null;
                    return null;
                }

                let target = store.houndPackTarget;
                if (target && (target.dead || target.hp <= 0)) {
                    target = null;
                }

                if (!target) {
                    for (const h of store.hounds) {
                        if (h?.target && !h.target.dead && h.target.hp > 0) {
                            target = h.target;
                            break;
                        }
                    }
                }

                if (!target) {
                    const hounds = store.hounds;
                    const player = store.player;
                    let pivotX = player.x;
                    let pivotY = player.y;

                    if (hounds.length > 0) {
                        let sumX = 0;
                        let sumY = 0;
                        let count = 0;
                        for (const h of hounds) {
                            if (!h) continue;
                            sumX += h.x;
                            sumY += h.y;
                            count++;
                        }
                        if (count > 0) {
                            pivotX = sumX / count;
                            pivotY = sumY / count;
                        }
                    }

                    let best = null;
                    let bestScore = Infinity;
                    const consider = (enemy) => {
                        if (!enemy || enemy.dead || enemy.hp <= 0) return;
                        const dx = enemy.x - pivotX;
                        const dy = enemy.y - pivotY;
                        let distSq = dx * dx + dy * dy;
                        if (enemy === store.boss) {
                            distSq *= 0.7;
                        }
                        if (distSq < bestScore) {
                            bestScore = distSq;
                            best = enemy;
                        }
                    };

                    const enemies = Array.isArray(store.enemies) ? store.enemies : [];
                    for (const enemy of enemies) {
                        consider(enemy);
                    }
                    if (store.boss) {
                        consider(store.boss);
                    }

                    target = best;
                }

                store.houndPackTarget = target || null;
                return target || null;
            }

            function moveHoundTowards(hound, targetX, targetY, maxSpeed, dt) {
                const dx = targetX - hound.x;
                const dy = targetY - hound.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 1e-3) {
                    hound.x = targetX;
                    hound.y = targetY;
                    return;
                }
                const step = Math.min(dist, maxSpeed * dt);
                hound.x += (dx / dist) * step;
                hound.y += (dy / dist) * step;
            }

            function stepHounds(dt) {
                if (!store.player.hasHounds || !Array.isArray(store.hounds) || store.hounds.length === 0) {
                    store.houndPackTarget = null;
                    return;
                }

                const player = store.player;
                const hounds = store.hounds;
                const ordered = hounds.slice().sort((a, b) => (a?.side || 0) - (b?.side || 0));
                const slotLookup = new Map();
                ordered.forEach((hound, index) => {
                    if (hound) slotLookup.set(hound, index);
                });
                const totalSlots = ordered.length || 1;
                const timeFactor = performance.now() * 0.001;
                let packTarget = selectHoundPackTarget();

                for (const h of hounds) {
                    if (!h) continue;
                    h.attackT = Math.max(0, (h.attackT || 0) - dt);
                    const target = packTarget && !packTarget.dead && packTarget.hp > 0 ? packTarget : null;

                    if (target) {
                        h.target = target;
                        const slot = slotLookup.get(h) ?? 0;
                        const angleStep = (Math.PI * 2) / totalSlots;
                        const baseAngle = Math.atan2(player.y - target.y, player.x - target.x);
                        const jitter = Math.sin(timeFactor * 1.7 + slot * 2.3) * 0.18;
                        const desiredAngle = baseAngle + slot * angleStep + jitter;
                        const orbitRadius = Math.max(18, Math.min(34, 20 + totalSlots * 2.5));
                        const anchorX = target.x + Math.cos(desiredAngle) * orbitRadius;
                        const anchorY = target.y + Math.sin(desiredAngle) * orbitRadius * 0.9;

                        moveHoundTowards(h, anchorX, anchorY, 360, dt);

                        const dx = target.x - h.x;
                        const dy = target.y - h.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const attackRange = Math.max((target.r || 18) + 12, h.r ? h.r * 1.8 : 24);

                        if (dist <= attackRange && h.attackT <= 0) {
                            h.attackT = 0.25;
                            let dmg = 8 * (store.player.dmgMult || 1);
                            if (target === store.boss) dmg *= 0.3;
                            if (!target.dead && target.hp > 0) {
                                target.hp -= dmg;
                                if (store.player.vampirism > 0) {
                                    let healAmount = dmg * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 0.5);
                                    healAmount = Math.min(healAmount, 2);
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }
                                if (target.hp <= 0) {
                                    h.killCount = (h.killCount || 0) + 1;
                                    if (h.killCount > 0 && h.killCount % 12 === 0) {
                                        playSound('dogs');
                                    }
                                    store.houndPackTarget = null;
                                    packTarget = null;
                                }
                            }
                        }
                    } else {
                        h.target = null;
                        const slot = slotLookup.get(h) ?? 0;
                        const angleStep = (Math.PI * 2) / totalSlots;
                        const idleAngle = slot * angleStep + timeFactor * 0.9;
                        const idleRadius = 46 + slot * 3;
                        const anchorX = player.x + Math.cos(idleAngle) * idleRadius;
                        const anchorY = player.y + Math.sin(idleAngle) * idleRadius * 0.45 + 24;
                        moveHoundTowards(h, anchorX, anchorY, 280, dt);
                    }
                }
            }

            function stepVoidRifts(dt) {
                if (!store.voidRifts || !store.voidRifts.length) return;
                const player = store.player;
                for (let i = store.voidRifts.length - 1; i >= 0; i--) {
                    const rift = store.voidRifts[i];
                    if (!rift) {
                        store.voidRifts.splice(i, 1);
                        continue;
                    }
                    rift.life -= dt;
                    if (rift.life <= 0 || rift.dead) {
                        store.voidRifts.splice(i, 1);
                        continue;
                    }
                    
                    // Damage player if standing in rift
                    rift.damageTimer -= dt;
                    if (rift.damageTimer <= 0) {
                        rift.damageTimer = 0.3;
                        const dx = player.x - rift.x;
                        const dy = player.y - rift.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= rift.r + (player.r || 18)) {
                            takeDamage(rift.damage);
                        }
                    }
                }
            }

            function stepShadowHounds(dt) {
                if (!store.shadowHounds || !store.shadowHounds.length) return;
                const player = store.player;
                for (let i = store.shadowHounds.length - 1; i >= 0; i--) {
                    const h = store.shadowHounds[i];
                    if (!h) {
                        store.shadowHounds.splice(i, 1);
                        continue;
                    }
                    h.life -= dt;
                    if (h.life <= 0 || h.dead) {
                        store.shadowHounds.splice(i, 1);
                        continue;
                    }
                    h.attackCooldown = Math.max(0, h.attackCooldown - dt);
                    if (h.collisionDamageCooldown && h.collisionDamageCooldown > 0) {
                        h.collisionDamageCooldown = Math.max(0, h.collisionDamageCooldown - dt);
                    }
                    h.wobble += dt * 3.4;
                    const targetOffsetX = Math.sin(h.wobble) * 16;
                    const targetOffsetY = Math.cos(h.wobble * 0.7) * 12;
                    const targetX = clamp(player.x + targetOffsetX, 20, W - 20);
                    const targetY = clamp(player.y + targetOffsetY, 40, H - 40);
                    const dx = targetX - h.x;
                    const dy = targetY - h.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const step = Math.min(dist, h.speed * dt);
                    h.x += (dx / dist) * step;
                    h.y += (dy / dist) * step;

                    const px = player.x - h.x;
                    const py = player.y - h.y;
                    const hitRadius = (player.r || 18) + 10;
                    if (px * px + py * py <= hitRadius * hitRadius && h.attackCooldown <= 0) {
                        if (!Number.isFinite(h.hp)) {
                            h.hp = 4;
                            h.hpMax = 4;
                        }
                        const handled = resolvePlayerEnemyCollision(h, {
                            enemyCooldown: 0.7,
                            playerCooldown: 0.35,
                            separationForce: 14,
                            skipEnemyDeathResolution: true
                        });
                        if (handled) {
                            h.attackCooldown = 0.7;
                            if (h.hp <= 0) {
                                h.dead = true;
                                store.shadowHounds.splice(i, 1);
                                continue;
                            }
                        }
                    }
                }
            }
            function drawBerneseGhostHound(ctx, r, eyeConfig, timeMs) {
                ctx.save();

                const now = typeof timeMs === 'number' ? timeMs : performance.now();
                const anim = now * 0.001;
                const auraRadius = r * 2.2;

                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.32;
                const auraGradient = ctx.createRadialGradient(0, 0, r * 0.4, 0, 0, auraRadius);
                auraGradient.addColorStop(0, 'rgba(210, 230, 255, 0.9)');
                auraGradient.addColorStop(0.6, 'rgba(140, 170, 255, 0.25)');
                auraGradient.addColorStop(1, 'rgba(110, 150, 255, 0)');
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                const bodyAlpha = 0.88;

                // Main body silhouette
                ctx.globalAlpha = bodyAlpha;
                ctx.fillStyle = 'rgba(28, 28, 36, 0.9)';
                ctx.beginPath();
                ctx.moveTo(-r, -r * 0.5);
                ctx.quadraticCurveTo(0, -r * 1.55, r, -r * 0.5);
                ctx.quadraticCurveTo(r * 1.28, 0, r, r * 1.08);
                ctx.quadraticCurveTo(0, r * 1.38, -r, r * 1.08);
                ctx.quadraticCurveTo(-r * 1.28, 0, -r, -r * 0.5);
                ctx.closePath();
                ctx.fill();

                // White chest blaze
                ctx.globalAlpha = 0.85;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.92)';
                ctx.beginPath();
                ctx.moveTo(-r * 0.7, r * 0.42);
                ctx.quadraticCurveTo(0, r * 1.25, r * 0.7, r * 0.42);
                ctx.lineTo(r * 0.45, -r * 0.15);
                ctx.quadraticCurveTo(0, r * 0.18, -r * 0.45, -r * 0.15);
                ctx.closePath();
                ctx.fill();

                // Brown cheek and eyebrow markings
                ctx.globalAlpha = 0.86;
                ctx.fillStyle = 'rgba(110, 76, 46, 0.9)';
                ctx.beginPath();
                ctx.arc(-r * 0.4, -r * 0.7, r * 0.16, 0, Math.PI * 2);
                ctx.arc(r * 0.4, -r * 0.7, r * 0.16, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(-r * 0.6, r * 0.1, r * 0.26, 0, Math.PI * 2);
                ctx.arc(r * 0.6, r * 0.1, r * 0.26, 0, Math.PI * 2);
                ctx.fill();

                // Floppy ears
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = 'rgba(22, 22, 30, 0.95)';
                ctx.beginPath();
                ctx.moveTo(-r, -r * 0.42);
                ctx.lineTo(-r * 0.5, -r * 1.28);
                ctx.lineTo(-r * 1.18, -r * 1.02);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(r, -r * 0.42);
                ctx.lineTo(r * 0.5, -r * 1.28);
                ctx.lineTo(r * 1.18, -r * 1.02);
                ctx.closePath();
                ctx.fill();

                // Snout blaze
                ctx.globalAlpha = 0.94;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.92)';
                ctx.beginPath();
                ctx.moveTo(0, -r * 0.62);
                ctx.quadraticCurveTo(-r * 0.12, 0, 0, r * 0.22);
                ctx.quadraticCurveTo(r * 0.12, 0, 0, -r * 0.62);
                ctx.fill();

                // Nose
                ctx.globalAlpha = 0.95;
                ctx.fillStyle = 'rgba(26, 26, 32, 0.95)';
                ctx.beginPath();
                ctx.moveTo(-r * 0.16, r * 0.22);
                ctx.lineTo(r * 0.16, r * 0.22);
                ctx.lineTo(0, r * 0.35);
                ctx.closePath();
                ctx.fill();

                // Eyes
                const scleraRadius = r * 0.22;
                const pupilRadius = scleraRadius * 0.6;
                const eyeY = -r * 0.24;
                const step = Math.PI * 4 / 26;
                const eyeType = eyeConfig?.type || 'normal';

                ctx.globalAlpha = 0.98;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.arc(-r * 0.4, eyeY, scleraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(r * 0.4, eyeY, scleraRadius, 0, Math.PI * 2);
                ctx.fill();

                if (eyeType === 'heterochromia' && Array.isArray(eyeConfig?.colors)) {
                    ctx.fillStyle = eyeConfig.colors[0] || '#5DADE2';
                    ctx.beginPath();
                    ctx.arc(-r * 0.4, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = eyeConfig.colors[1] || '#8B4513';
                    ctx.beginPath();
                    ctx.arc(r * 0.4, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();
                } else if (eyeType === 'swirly') {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.85)';
                    ctx.lineWidth = Math.max(0.6, r * 0.035);
                    ctx.beginPath();
                    for (let t = 0; t <= Math.PI * 4; t += step) {
                        const radiusFactor = t * r * 0.015;
                        const sx = -r * 0.4 + Math.cos(t + anim * 2) * radiusFactor;
                        const sy = eyeY + Math.sin(t + anim * 2) * radiusFactor;
                        if (t === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();

                    ctx.beginPath();
                    for (let t = 0; t <= Math.PI * 4; t += step) {
                        const radiusFactor = t * r * 0.015;
                        const sx = r * 0.4 + Math.cos(t - anim * 2.2) * radiusFactor;
                        const sy = eyeY + Math.sin(t - anim * 2.2) * radiusFactor;
                        if (t === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'rgba(12, 12, 18, 0.9)';
                    ctx.beginPath();
                    ctx.arc(-r * 0.4, eyeY, pupilRadius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(r * 0.4, eyeY, pupilRadius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Mouth and tongue
                ctx.globalAlpha = 0.92;
                ctx.fillStyle = 'rgba(255, 110, 170, 0.85)';
                ctx.beginPath();
                ctx.moveTo(0, r * 0.4);
                ctx.quadraticCurveTo(r * 0.22, r * 0.78, 0, r * 0.84);
                ctx.quadraticCurveTo(-r * 0.22, r * 0.78, 0, r * 0.4);
                ctx.fill();

                ctx.strokeStyle = 'rgba(20, 20, 28, 0.95)';
                ctx.lineWidth = Math.max(0.6, r * 0.05);
                ctx.beginPath();
                ctx.arc(0, r * 0.35, r * 0.22, 0, Math.PI);
                ctx.stroke();

                // Soft highlights
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = 'rgba(240, 250, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(-r * 0.2, -r * 0.2, r * 0.4, r * 0.18, 0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawHound(h) {
                ctx.save();
                ctx.translate(h.x, h.y);
                const time = performance.now();
                ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time / 1000 + h.side);
                let r = h.r;

                // Make the 4th dog (tanish orange one with regular pupils) half size
                if (h.side === 2) {
                    r = r * 0.5;
                }

                if (!h.isUpgraded) {
                    const { main, accent } = h.color;
                    const isTuxedo = accent === '#FFFFFF';

                    ctx.fillStyle = main;
                    ctx.beginPath();
                    ctx.moveTo(-r, -r * 0.5);
                    ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
                    ctx.quadraticCurveTo(r * 1.2, 0, r, r);
                    ctx.lineTo(-r, r);
                    ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = isTuxedo ? main : accent;
                    ctx.beginPath();
                    ctx.moveTo(-r, -r * 0.4);
                    ctx.lineTo(-r * 0.5, -r * 1.2);
                    ctx.lineTo(-r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r, -r * 0.4);
                    ctx.lineTo(r * 0.5, -r * 1.2);
                    ctx.lineTo(r * 0.2, -r * 0.6);
                    ctx.closePath();
                    ctx.fill();

                    if (isTuxedo) {
                        ctx.fillStyle = accent;
                        ctx.beginPath();
                        ctx.moveTo(-r * 0.6, r * 0.2);
                        ctx.quadraticCurveTo(0, r, r * 0.6, r * 0.2);
                        ctx.lineTo(0, r * 0.5);
                        ctx.closePath();
                        ctx.fill();
                    }

                    ctx.fillStyle = "#FFF";
                    ctx.beginPath();
                    ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = "#000";
                    ctx.beginPath();
                    ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = isTuxedo ? main : accent;
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.3, r * 0.5, r * 0.4, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = "#FFF";
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.3, r * 0.5);
                    ctx.lineTo(-r * 0.1, r * 0.5);
                    ctx.lineTo(-r * 0.2, r * 0.9);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(r * 0.3, r * 0.5);
                    ctx.lineTo(r * 0.1, r * 0.5);
                    ctx.lineTo(r * 0.2, r * 0.9);
                    ctx.closePath();
                    ctx.fill();
                } else if (h.breed === 'bernese') {
                    drawBerneseGhostHound(ctx, r, h.eyeConfig || { type: h.eyeType }, time);
                } else {
                    const color = h.color.main;
                    const opacity = ctx.globalAlpha;
                    const eyeType = h.eyeType;
                    const expression = h.expression;
                    const radius = r * 1.5;

                    if (h.side === 2) {
                        ctx.save();
                        ctx.globalAlpha = 0.7 * opacity;
                        ctx.fillStyle = '#9966ff';
                        ctx.beginPath();
                        ctx.moveTo(0, -radius * 1.8);
                        ctx.lineTo(-radius * 0.8, -radius * 0.9);
                        ctx.lineTo(radius * 0.8, -radius * 0.9);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-radius * 0.6, -radius * 0.7);
                    ctx.lineTo(-radius * 0.4, -radius * 1.2);
                    ctx.lineTo(-radius * 0.2, -radius * 0.8);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(radius * 0.6, -radius * 0.7);
                    ctx.lineTo(radius * 0.4, -radius * 1.2);
                    ctx.lineTo(radius * 0.2, -radius * 0.8);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(-radius, 0);
                    for (let i = 0; i <= 6; i++) {
                        let waveX = -radius + (radius * 2 / 6) * i;
                        let waveY = radius + Math.sin(i * 0.8 + time * 0.005) * radius * 0.2;
                        ctx.lineTo(waveX, waveY);
                    }
                    ctx.lineTo(radius, 0);
                    ctx.fill();

                    ctx.fillStyle = 'white';

                    if (eyeType === 'dilated') {
                        ctx.beginPath();
                        ctx.ellipse(-radius * 0.35, -radius * 0.1, radius * 0.28, radius * 0.35, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.ellipse(radius * 0.35, -radius * 0.15, radius * 0.25, radius * 0.32, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(-radius * 0.3 + Math.sin(time * 0.001) * radius * 0.05,
                            -radius * 0.05, radius * 0.08, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(radius * 0.4,
                            -radius * 0.2 + Math.cos(time * 0.001) * radius * 0.05,
                            radius * 0.06, 0, Math.PI * 2);
                        ctx.fill();
                    } else { // 'swirly'
                        ctx.beginPath();
                        ctx.arc(-radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = radius * 0.04;

                        ctx.beginPath();
                        for (let t = 0; t < Math.PI * 4; t += 0.1) {
                            let r_swirl = t * radius * 0.02;
                            let sx = -radius * 0.35 + Math.cos(t + time * 0.001) * r_swirl;
                            let sy = -radius * 0.1 + Math.sin(t + time * 0.001) * r_swirl;
                            if (t === 0) ctx.moveTo(sx, sy);
                            else ctx.lineTo(sx, sy);
                        }
                        ctx.stroke();

                        ctx.beginPath();
                        for (let t = 0; t < Math.PI * 4; t += 0.1) {
                            let r_swirl = t * radius * 0.02;
                            let sx = radius * 0.35 + Math.cos(t - time * 0.001) * r_swirl;
                            let sy = -radius * 0.1 + Math.sin(t - time * 0.001) * r_swirl;
                            if (t === 0) ctx.moveTo(sx, sy);
                            else ctx.lineTo(sx, sy);
                        }
                        ctx.stroke();
                    }

                    ctx.fillStyle = 'white';

                    ctx.beginPath();
                    ctx.moveTo(-radius * 0.25, radius * 0.2);
                    ctx.lineTo(-radius * 0.2, radius * 0.5);
                    ctx.lineTo(-radius * 0.15, radius * 0.2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(radius * 0.25, radius * 0.2);
                    ctx.lineTo(radius * 0.2, radius * 0.5);
                    ctx.lineTo(radius * 0.15, radius * 0.2);
                    ctx.fill();

                    for (let i = -1; i <= 1; i++) {
                        if (i === 0) continue;
                        ctx.beginPath();
                        ctx.moveTo(i * radius * 0.08, radius * 0.2);
                        ctx.lineTo(i * radius * 0.08 + radius * 0.02, radius * 0.35);
                        ctx.lineTo(i * radius * 0.08 - radius * 0.02, radius * 0.35);
                        ctx.fill();
                    }

                    ctx.strokeStyle = expression === 'silly' ? '#000' : '#333';
                    ctx.lineWidth = radius * 0.03;
                    ctx.beginPath();

                    if (expression === 'silly') {
                        ctx.moveTo(-radius * 0.3, radius * 0.15);
                        ctx.quadraticCurveTo(-radius * 0.1, radius * 0.05, 0, radius * 0.15);
                        ctx.quadraticCurveTo(radius * 0.1, radius * 0.25, radius * 0.3, radius * 0.15);
                    } else {
                        ctx.arc(0, 0, radius * 0.35, Math.PI * 0.2, Math.PI * 0.8);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawVoidRift(rift) {
                ctx.save();
                ctx.translate(rift.x, rift.y);
                const time = performance.now() / 1000;
                const lifeRatio = Math.max(0, Math.min(1, rift.life / rift.maxLife));
                const pulse = 0.6 + 0.4 * Math.sin(time * 4);
                const rotation = time * 0.5;

                // Outer swirling void
                ctx.globalAlpha = 0.4 * lifeRatio;
                const outerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, rift.r * 1.3);
                outerGrad.addColorStop(0, 'rgba(80, 40, 120, 0.8)');
                outerGrad.addColorStop(0.5, 'rgba(40, 20, 80, 0.6)');
                outerGrad.addColorStop(1, 'rgba(20, 10, 40, 0)');
                ctx.fillStyle = outerGrad;
                ctx.beginPath();
                ctx.arc(0, 0, rift.r * 1.3 * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Inner void core
                ctx.globalAlpha = 0.7 * lifeRatio;
                ctx.rotate(rotation);
                const innerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, rift.r);
                innerGrad.addColorStop(0, 'rgba(140, 80, 180, 0.9)');
                innerGrad.addColorStop(0.6, 'rgba(80, 40, 120, 0.7)');
                innerGrad.addColorStop(1, 'rgba(40, 20, 80, 0.2)');
                ctx.fillStyle = innerGrad;
                ctx.beginPath();
                ctx.arc(0, 0, rift.r, 0, Math.PI * 2);
                ctx.fill();

                // Swirl pattern
                ctx.strokeStyle = `rgba(180, 140, 220, ${0.5 * lifeRatio})`;
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, rift.r * 0.7, angle, angle + Math.PI * 0.6);
                    ctx.stroke();
                }

                ctx.restore();
            }

            function drawShadowHound(h) {
                const bodyWidth = 18;
                drawEntityShadow(h.x, h.y, bodyWidth * 1.05, Math.max(6, bodyWidth * 0.45), {
                    alpha: 0.26,
                    yOffset: bodyWidth * 0.8
                });
                ctx.save();
                ctx.translate(h.x, h.y);
                const time = performance.now() / 1000;
                const lifeRatio = h.maxLife ? Math.max(0, Math.min(1, h.life / h.maxLife)) : 1;
                const pulse = 0.5 + 0.4 * Math.sin(time * 6 + h.wobble);

                ctx.globalAlpha = 0.55 + 0.35 * lifeRatio;

                const bodyHeight = 12;

                const gradient = ctx.createRadialGradient(0, 0, bodyHeight * 0.4, 0, 0, bodyWidth);
                gradient.addColorStop(0, `rgba(35, 38, 62, ${0.9})`);
                gradient.addColorStop(1, `rgba(18, 20, 34, ${0.9 * lifeRatio})`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(205, 211, 255, ${0.8})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(0, 0, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowColor = 'rgba(120, 130, 220, 0.7)';
                ctx.shadowBlur = 18 * lifeRatio;
                ctx.fillStyle = `rgba(200, 210, 255, ${0.55 + pulse * 0.25})`;
                ctx.beginPath();
                ctx.arc(-6, -2, 3, 0, Math.PI * 2);
                ctx.arc(6, -2, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#2a2f4e';
                ctx.beginPath();
                ctx.moveTo(-bodyWidth * 0.25, bodyHeight * 0.2);
                ctx.lineTo(-bodyWidth * 0.45, bodyHeight * 0.95);
                ctx.lineTo(-bodyWidth * 0.28, bodyHeight * 0.95);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(bodyWidth * 0.25, bodyHeight * 0.2);
                ctx.lineTo(bodyWidth * 0.45, bodyHeight * 0.95);
                ctx.lineTo(bodyWidth * 0.28, bodyHeight * 0.95);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = `rgba(150, 160, 240, ${0.8})`;
                ctx.lineWidth = 1.4;
                ctx.beginPath();
                ctx.moveTo(-bodyWidth * 0.6, -bodyHeight * 0.2);
                ctx.quadraticCurveTo(-bodyWidth * 0.1, -bodyHeight * 0.9, 0, -bodyHeight * 0.4);
                ctx.quadraticCurveTo(bodyWidth * 0.1, -bodyHeight * 0.9, bodyWidth * 0.6, -bodyHeight * 0.2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(bodyWidth * 0.4, -bodyHeight * 0.05);
                ctx.quadraticCurveTo(bodyWidth * 0.9, -bodyHeight * 0.4, bodyWidth * 0.7, bodyHeight * 0.2);
                ctx.stroke();

                ctx.restore();
            }

            function drawChampionMinion(minion, owner) {
                if (!minion) return;
                const level = owner?.level || 1;
                const baseRadius = 6 + Math.min(level, 3);
                const now = performance.now() / 1000;
                const pulse = 0.6 + 0.35 * Math.sin(now * 6 + (minion.pulsePhase || 0));
                const swirl = now * 5.2 + (minion.swirlPhase || 0);
                const fireCooldown = Math.max(0.12, minion.fireCooldown || 0.6);
                const fireRatio = Math.max(0, Math.min(1, (minion.fireTimer || 0) / fireCooldown));

                drawEntityShadow(minion.x, minion.y, Math.max(10, baseRadius * 1.5), Math.max(4, baseRadius * 0.6), {
                    alpha: 0.24 + 0.02 * level,
                    yOffset: Math.max(8, baseRadius * 0.9)
                });

                const upgrades = getChampionUpgradeState();
                const abilityModule = minion.abilityModule || owner?.attackModule || (upgrades ? upgrades.attackModule : 'default') || 'default';
                const abilityTheme = minion.abilityTheme || getChampionMinionAbilityTheme(abilityModule);
                const fallbackSkin = owner?.skinTheme?.minion || (upgrades ? getChampionSkinTheme(upgrades.skin).minion : getChampionSkinTheme('default').minion);
                const skinTheme = minion.skinTheme || fallbackSkin || {};

                const auraTheme = abilityTheme.aura || {};
                const tailTheme = abilityTheme.tail || {};
                const thrusterTheme = abilityTheme.thruster || {};
                const coreTheme = abilityTheme.core || {};
                const swirlPrimary = abilityTheme.swirlPrimary || withAlpha(skinTheme.aura || '#82a7ff', 0.75);
                const swirlSecondary = abilityTheme.swirlSecondary || withAlpha(skinTheme.trail || '#4362a8', 0.6);
                const highlightFill = abilityTheme.highlight || withAlpha(skinTheme.core || '#bcd4ff', 0.9);
                const ringColor = abilityTheme.ring || withAlpha(skinTheme.aura || '#82a7ff', level >= 5 ? 0.9 : 0.8);
                const thrusterInner = thrusterTheme.inner || withAlpha(skinTheme.aura || '#82a7ff', 0.85);
                const thrusterOuter = thrusterTheme.outer || 'rgba(20, 40, 80, 0)';
                const trailColor = abilityTheme.trail || skinTheme.trail || '#4362a8';
                const tailStart = tailTheme.start || withAlpha(trailColor, 0);
                const tailMid = tailTheme.mid || withAlpha(trailColor, 0.35);
                const tailEnd = tailTheme.end || withAlpha(trailColor, 0.75);
                const auraInner = auraTheme.inner || withAlpha(skinTheme.aura || '#82a7ff', 0.78);
                const auraMid = auraTheme.mid || withAlpha(skinTheme.aura || '#82a7ff', 0.5);
                const auraOuter = auraTheme.outer || 'rgba(20, 40, 80, 0)';
                const coreInner = coreTheme.inner || skinTheme.core || '#f2f6ff';
                const coreMid = coreTheme.mid || withAlpha(skinTheme.core || '#bcd4ff', 0.9);
                const coreOuter = coreTheme.outer || withAlpha(skinTheme.trail || '#4362a8', 0.95);
                const coreEdge = coreTheme.edge || withAlpha(trailColor, 1);

                ctx.save();
                ctx.translate(minion.x, minion.y);

                if (owner) {
                    const angleToOwner = Math.atan2(owner.y - minion.y, owner.x - minion.x);
                    const tailLength = baseRadius * (2.2 + level * 0.35);

                    ctx.save();
                    ctx.rotate(angleToOwner + Math.PI);
                    ctx.globalAlpha = 0.32 + 0.28 * (1 - fireRatio);
                    const tailGradient = ctx.createLinearGradient(-tailLength, 0, 0, 0);
                    tailGradient.addColorStop(0, tailStart);
                    tailGradient.addColorStop(0.85, tailMid);
                    tailGradient.addColorStop(1, tailEnd);
                    ctx.fillStyle = tailGradient;
                    ctx.beginPath();
                    ctx.moveTo(-tailLength, -baseRadius * 0.55);
                    ctx.quadraticCurveTo(-tailLength * 0.6, -baseRadius, -baseRadius * 0.25, -baseRadius * 0.4);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(-baseRadius * 0.25, baseRadius * 0.4);
                    ctx.quadraticCurveTo(-tailLength * 0.6, baseRadius, -tailLength, baseRadius * 0.55);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.4 + 0.25 * (1 - fireRatio);
                const auraRadius = baseRadius * (1.9 + pulse * 0.35 + level * 0.1);
                const auraGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.2, 0, 0, auraRadius);
                auraGradient.addColorStop(0, auraInner);
                auraGradient.addColorStop(0.55, auraMid);
                auraGradient.addColorStop(1, auraOuter);
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';

                ctx.save();
                ctx.rotate(swirl * 0.4);
                ctx.globalAlpha = 0.4 + 0.2 * (1 - fireRatio);
                ctx.lineWidth = 1.25;
                ctx.strokeStyle = swirlPrimary;
                ctx.beginPath();
                ctx.ellipse(0, 0, baseRadius * (1.18 + 0.08 * Math.sin(swirl)), baseRadius * (0.62 + 0.1 * Math.cos(swirl * 1.3)), 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                ctx.save();
                ctx.rotate(-swirl * 0.45);
                ctx.globalAlpha = 0.25 + 0.2 * (1 - fireRatio);
                ctx.lineWidth = 0.9;
                ctx.strokeStyle = swirlSecondary;
                ctx.beginPath();
                ctx.ellipse(0, 0, baseRadius * 1.45, baseRadius * 0.78, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                ctx.globalAlpha = 0.95;
                const coreGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.22, 0, 0, baseRadius * 0.92);
                coreGradient.addColorStop(0, withAlpha(coreInner, 0.98));
                coreGradient.addColorStop(0.42, withAlpha(coreMid, 0.92));
                coreGradient.addColorStop(0.78, withAlpha(coreOuter, 0.96));
                coreGradient.addColorStop(1, withAlpha(coreEdge, 1));
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius * (0.95 + pulse * 0.05), 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 0.8;
                ctx.lineWidth = 1.6;
                ctx.strokeStyle = level >= 5 ? withAlpha(ringColor, 1) : ringColor;
                ctx.beginPath();
                ctx.arc(0, 0, baseRadius * 1.1, 0, Math.PI * 2);
                ctx.stroke();

                ctx.save();
                ctx.rotate(0.12 * Math.sin(swirl));
                ctx.globalAlpha = 0.9;
                ctx.fillStyle = highlightFill;
                ctx.beginPath();
                ctx.moveTo(-baseRadius * 0.52, -baseRadius * 0.12);
                ctx.quadraticCurveTo(-baseRadius * 0.12, -baseRadius * 0.58, baseRadius * 0.48, -baseRadius * 0.05);
                ctx.quadraticCurveTo(-baseRadius * 0.08, baseRadius * 0.28, -baseRadius * 0.45, baseRadius * 0.1);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 0.65;
                ctx.strokeStyle = withAlpha(trailColor, 0.85);
                ctx.lineWidth = 0.9;
                ctx.stroke();
                ctx.restore();

                ctx.globalAlpha = 0.6 * (1 - fireRatio);
                const thrusterGradient = ctx.createRadialGradient(0, baseRadius * 0.95, baseRadius * 0.1, 0, baseRadius * 1.25, baseRadius * 0.6);
                thrusterGradient.addColorStop(0, thrusterInner);
                thrusterGradient.addColorStop(1, thrusterOuter);
                ctx.fillStyle = thrusterGradient;
                ctx.beginPath();
                ctx.ellipse(0, baseRadius * 1.05, baseRadius * 0.6, baseRadius * 0.36, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawPlayerChampion(champion) {
                if (!champion) return;

                const level = champion.level || 1;
                const baseRadius = champion.r || 20;
                const now = performance.now() / 1000;
                const auraPhase = champion.auraPulse || 0;
                const auraPulse = 0.8 + 0.18 * Math.sin(now * 3 + auraPhase);
                const dashActive = champion.state === 'dash';
                const facing = typeof champion.visualAim === 'number' ? champion.visualAim : 0;
                const swirl = champion.swirlPhase || 0;
                const skinTheme = champion.skinTheme || getChampionSkinTheme(champion.skinKey || 'default');
                const bodyTheme = skinTheme.body;
                const visorTheme = skinTheme.visor;
                const auraTheme = skinTheme.aura;
                const trailColor = skinTheme.trail || '#78b4ff';
                const accentColor = bodyTheme.accent || trailColor || '#6090d0';
                
                // Check if star power is active
                const isStarPowerActive = champion.isInvincible && champion.starPowerEndTime > performance.now();

                drawEntityShadow(champion.x, champion.y, Math.max(24, baseRadius * 1.7), Math.max(10, baseRadius * 0.65), {
                    alpha: 0.3 + Math.min(0.15, level * 0.02),
                    yOffset: Math.max(14, baseRadius * 1.1)
                });

                ctx.save();
                ctx.translate(champion.x, champion.y);
                
                // â­ STAR POWER EFFECT (Mario/Mario Kart style invincibility) â­
                if (isStarPowerActive) {
                    const starProgress = (champion.starPowerEndTime - performance.now()) / 5000;
                    const rainbowPhase = now * 8; // Fast rainbow cycling
                    
                    // Rainbow rotating aura rings
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    for (let i = 0; i < 4; i++) {
                        const ringAngle = (now * 4 + i * Math.PI / 2) % (Math.PI * 2);
                        const ringRadius = baseRadius * (1.8 + i * 0.3);
                        const hue = ((rainbowPhase + i * 60) % 360);
                        ctx.globalAlpha = 0.6 * starProgress;
                        ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 0.8)`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, ringAngle, ringAngle + Math.PI / 2);
                        ctx.stroke();
                    }
                    
                    // Rainbow sparkle particles
                    for (let i = 0; i < 8; i++) {
                        const sparklePhase = (now * 5 + i * 0.8) % 3;
                        const sparkleAlpha = Math.max(0, 1 - sparklePhase / 3) * starProgress;
                        const sparkleAngle = (i / 8) * Math.PI * 2 + now * 2;
                        const sparkleDist = baseRadius * (1.2 + sparklePhase * 0.8);
                        const sparkleX = Math.cos(sparkleAngle) * sparkleDist;
                        const sparkleY = Math.sin(sparkleAngle) * sparkleDist;
                        const sparkleHue = ((rainbowPhase + i * 45) % 360);
                        
                        ctx.globalAlpha = sparkleAlpha;
                        ctx.fillStyle = `hsla(${sparkleHue}, 100%, 70%, 1)`;
                        ctx.shadowColor = `hsla(${sparkleHue}, 100%, 80%, 0.9)`;
                        ctx.shadowBlur = 8;
                        
                        // Four-pointed star shape
                        ctx.save();
                        ctx.translate(sparkleX, sparkleY);
                        ctx.rotate(sparklePhase * Math.PI);
                        ctx.beginPath();
                        for (let j = 0; j < 4; j++) {
                            const angle = (j / 4) * Math.PI * 2;
                            const r = j % 2 === 0 ? 4 : 2;
                            const px = Math.cos(angle) * r;
                            const py = Math.sin(angle) * r;
                            if (j === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Pulsing rainbow glow around ship
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.4 * starProgress * (0.7 + 0.3 * Math.sin(now * 12));
                    const glowHue = (rainbowPhase % 360);
                    const glowGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.5, 0, 0, baseRadius * 2.5);
                    glowGradient.addColorStop(0, `hsla(${glowHue}, 100%, 70%, 0.8)`);
                    glowGradient.addColorStop(0.5, `hsla(${(glowHue + 60) % 360}, 100%, 60%, 0.4)`);
                    glowGradient.addColorStop(1, `hsla(${(glowHue + 120) % 360}, 100%, 50%, 0)`);
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Premium multi-layered aura with pulsing rings
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                // Outer expanding rings for premium skins
                const isPremiumSkin = ['blackgold', 'crimsonhex', 'prismrift', 'ghostflame', 'voidcrystal', 'chromestrike', 'infernalcore', 'glacialwarden'].includes(skinTheme.key);
                if (isPremiumSkin) {
                    for (let i = 0; i < 3; i++) {
                        const ringPhase = (now * 1.5 + i * 0.8) % 2;
                        const ringAlpha = Math.max(0, 0.3 - ringPhase * 0.15);
                        ctx.globalAlpha = ringAlpha;
                        ctx.strokeStyle = withAlpha(accentColor, 0.6);
                        ctx.lineWidth = 2 + level * 0.3;
                        ctx.beginPath();
                        ctx.arc(0, 0, baseRadius * (2.2 + ringPhase * 0.8 + level * 0.15), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Main aura
                ctx.globalAlpha = 0.32 + 0.24 * Math.sin(now * 2.5 + auraPhase * 0.9);
                const auraRadius = baseRadius * (2.0 + auraPulse * 0.7 + level * 0.1);
                const auraGradient = ctx.createRadialGradient(0, 0, baseRadius * 0.3, 0, 0, auraRadius);
                auraGradient.addColorStop(0, withAlpha(auraTheme.inner, 0.9));
                auraGradient.addColorStop(0.5, withAlpha(auraTheme.mid, 0.4 + Math.min(0.3, level * 0.04)));
                auraGradient.addColorStop(1, withAlpha(auraTheme.outer, 0));
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                if (dashActive && (champion.dashVX || champion.dashVY)) {
                    const dashDuration = champion.dashDuration || 0.01;
                    const dashProgress = Math.max(0, Math.min(1, 1 - (champion.dashTimer || 0) / dashDuration));
                    const streakLength = baseRadius * (3.2 + level * 0.35);
                    const trailAngle = Math.atan2(champion.dashVY || 0, champion.dashVX || 1);

                    ctx.save();
                    ctx.rotate(trailAngle);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.globalAlpha = 0.6 + 0.3 * dashProgress;
                    const streakGradient = ctx.createLinearGradient(-streakLength, 0, baseRadius * 0.9, 0);
                    streakGradient.addColorStop(0, withAlpha(bodyTheme.mid || '#1e2845', 0));
                    streakGradient.addColorStop(0.4, withAlpha(trailColor, 0.45));
                    streakGradient.addColorStop(1, withAlpha(trailColor, 0.85));
                    ctx.fillStyle = streakGradient;
                    ctx.beginPath();
                    ctx.moveTo(-streakLength, -baseRadius * 0.6);
                    ctx.lineTo(baseRadius * 0.9, -baseRadius * 0.2);
                    ctx.lineTo(baseRadius * 0.9, baseRadius * 0.2);
                    ctx.lineTo(-streakLength, baseRadius * 0.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }

                // Angular diamond body
                ctx.save();
                ctx.rotate(facing);

                // Main diamond body - darker blue gradient
                const bodyGradient = ctx.createLinearGradient(0, -baseRadius * 1.2, 0, baseRadius * 1.1);
                bodyGradient.addColorStop(0, bodyTheme.top || '#2a3560');
                bodyGradient.addColorStop(0.45, bodyTheme.mid || bodyTheme.top || '#1e2845');
                bodyGradient.addColorStop(1, bodyTheme.bottom || bodyTheme.mid || '#3c4f78');
                ctx.fillStyle = bodyGradient;
                ctx.strokeStyle = bodyTheme.outline || accentColor;
                ctx.lineWidth = 2.2;
                ctx.globalAlpha = 0.95;

                // Angular diamond shape
                ctx.beginPath();
                ctx.moveTo(0, -baseRadius * 1.1);                    // Top point
                ctx.lineTo(baseRadius * 0.9, -baseRadius * 0.15);    // Top-right
                ctx.lineTo(baseRadius * 0.6, baseRadius * 0.9);      // Bottom-right
                ctx.lineTo(0, baseRadius * 1.05);                    // Bottom point
                ctx.lineTo(-baseRadius * 0.6, baseRadius * 0.9);     // Bottom-left
                ctx.lineTo(-baseRadius * 0.9, -baseRadius * 0.15);   // Top-left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Angular inner sections
                ctx.fillStyle = bodyTheme.interior || '#1a2440';
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(-baseRadius * 0.25, -baseRadius * 0.3);
                ctx.lineTo(baseRadius * 0.25, -baseRadius * 0.3);
                ctx.lineTo(baseRadius * 0.4, baseRadius * 0.15);
                ctx.lineTo(-baseRadius * 0.4, baseRadius * 0.15);
                ctx.closePath();
                ctx.fill();

                // Visor - angular hexagonal shape
                ctx.fillStyle = bodyTheme.interior || '#0f1525';
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(0, -baseRadius * 0.55);
                ctx.lineTo(baseRadius * 0.45, -baseRadius * 0.25);
                ctx.lineTo(baseRadius * 0.35, baseRadius * 0.05);
                ctx.lineTo(-baseRadius * 0.35, baseRadius * 0.05);
                ctx.lineTo(-baseRadius * 0.45, -baseRadius * 0.25);
                ctx.closePath();
                ctx.fill();

                // Glowing visor
                const visorGradient = ctx.createLinearGradient(-baseRadius * 0.4, -baseRadius * 0.3, baseRadius * 0.4, 0);
                visorGradient.addColorStop(0, visorTheme.left || 'rgba(80, 150, 255, 0.8)');
                visorGradient.addColorStop(0.5, visorTheme.center || 'rgba(120, 180, 255, 0.95)');
                visorGradient.addColorStop(1, visorTheme.right || 'rgba(60, 120, 200, 0.7)');
                ctx.fillStyle = visorGradient;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(0, -baseRadius * 0.5);
                ctx.lineTo(baseRadius * 0.4, -baseRadius * 0.22);
                ctx.lineTo(baseRadius * 0.3, 0);
                ctx.lineTo(-baseRadius * 0.3, 0);
                ctx.lineTo(-baseRadius * 0.4, -baseRadius * 0.22);
                ctx.closePath();
                ctx.fill();

                // Angular accent lines with premium glow effects
                const accentLevelColor = level >= 4 ? withAlpha(accentColor, 0.95) : withAlpha(accentColor, 0.82);
                
                // Premium skins get glowing accent lines
                if (isPremiumSkin) {
                    ctx.shadowColor = accentColor;
                    ctx.shadowBlur = 8 + level * 2;
                    ctx.globalAlpha = 0.9;
                } else {
                    ctx.globalAlpha = 0.8;
                }
                
                ctx.strokeStyle = accentLevelColor;
                ctx.lineWidth = isPremiumSkin ? 2.2 : 1.8;
                ctx.beginPath();
                ctx.moveTo(-baseRadius * 0.35, baseRadius * 0.25);
                ctx.lineTo(baseRadius * 0.35, baseRadius * 0.25);
                ctx.moveTo(-baseRadius * 0.25, baseRadius * 0.6);
                ctx.lineTo(baseRadius * 0.25, baseRadius * 0.6);
                ctx.stroke();
                
                ctx.shadowBlur = 0;

                // Level indicators with premium effects
                if (level >= 2) {
                    ctx.globalAlpha = 0.6 + 0.25 * Math.sin(now * 5.5 + auraPhase);
                    ctx.lineWidth = level >= 4 ? 2.5 : 1.8;
                    ctx.strokeStyle = accentLevelColor;
                    
                    // Premium skins get crown/halo indicators
                    if (isPremiumSkin && level >= 4) {
                        ctx.shadowColor = accentColor;
                        ctx.shadowBlur = 12;
                        ctx.lineWidth = 3;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -baseRadius * 1.5);
                    ctx.lineTo(0, -baseRadius * 2.0);
                    ctx.moveTo(-baseRadius * 0.3, -baseRadius * 1.75);
                    ctx.lineTo(baseRadius * 0.3, -baseRadius * 1.75);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // Special skin-specific effects
                if (skinTheme.key === 'blackgold') {
                    // Gold shimmer particles
                    for (let i = 0; i < 4; i++) {
                        const sparklePhase = (now * 3 + i * 1.5) % 4;
                        const sparkleAlpha = Math.max(0, 0.8 - sparklePhase * 0.2);
                        const sparkleSize = 2 + sparklePhase * 0.5;
                        const sparkleAngle = (i / 4) * Math.PI * 2 + now * 0.5;
                        const sparkleX = Math.cos(sparkleAngle) * baseRadius * 1.4;
                        const sparkleY = Math.sin(sparkleAngle) * baseRadius * 1.4;
                        ctx.globalAlpha = sparkleAlpha;
                        ctx.fillStyle = '#ffd700';
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (skinTheme.key === 'ghostflame') {
                    // Ethereal flame wisps
                    ctx.globalAlpha = 0.4 + 0.2 * Math.sin(now * 4);
                    ctx.strokeStyle = withAlpha('#18ffff', 0.7);
                    ctx.lineWidth = 1.5;
                    for (let i = 0; i < 5; i++) {
                        const wispAngle = (i / 5) * Math.PI * 2 + now * 2;
                        const wispDist = baseRadius * (1.6 + 0.3 * Math.sin(now * 3 + i));
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(wispAngle) * baseRadius * 1.2, Math.sin(wispAngle) * baseRadius * 1.2);
                        ctx.lineTo(Math.cos(wispAngle) * wispDist, Math.sin(wispAngle) * wispDist);
                        ctx.stroke();
                    }
                } else if (skinTheme.key === 'prismrift') {
                    // Prismatic light refraction
                    const prismColors = ['#00d4ff', '#00bfa5', '#69f0ae', '#b2ff59'];
                    for (let i = 0; i < 4; i++) {
                        const prismPhase = (now * 2 + i * 0.8) % 3;
                        const prismAlpha = Math.max(0, 0.5 - prismPhase * 0.15);
                        const prismAngle = (i / 4) * Math.PI * 2 + now * 1.2;
                        ctx.globalAlpha = prismAlpha;
                        ctx.strokeStyle = prismColors[i];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(Math.cos(prismAngle) * baseRadius * 0.8, Math.sin(prismAngle) * baseRadius * 0.8, 
                               baseRadius * (0.3 + prismPhase * 0.2), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Special ability charge indicator
                if (champion.specialAbilityCooldown > 0) {
                    const cooldownRatio = champion.specialAbilityCooldown / 5000; // 5 second cooldown
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = withAlpha(accentColor, 0.78);
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, baseRadius * 1.2, -Math.PI / 2, -Math.PI / 2 + (1 - cooldownRatio) * Math.PI * 2);
                    ctx.stroke();

                    // Class ability icons when ready
                    if (cooldownRatio <= 0) {
                        const iconPulse = 0.8 + 0.2 * Math.sin(now * 4);
                        ctx.globalAlpha = 0.9 * iconPulse;

                        // Determine next ability type (same logic as the special ability function)
                        const player = store.player;
                        let abilityType = 'beef'; // default
                        if (player) {
                            if (player.pilotGenome === 'rocketman') abilityType = 'rocket';
                            else if (player.pilotGenome === 'voidmancer') {
                                abilityType = champion.lastVoidmancerAbility === 'lightning' ? 'laser' : 'lightning';
                            }
                        }

                        // Draw ability icon
                        ctx.fillStyle = withAlpha(accentColor, 0.9);
                        ctx.font = `${baseRadius * 0.4}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        let iconText = 'âš¡';
                        if (abilityType === 'beef') iconText = 'ðŸ’¨';
                        else if (abilityType === 'rocket') iconText = 'ðŸš€';
                        else if (abilityType === 'laser') iconText = 'ðŸ”«';

                        ctx.fillText(iconText, 0, baseRadius * 1.8);
                    }
                }

                ctx.restore();

                // Rotating energy field
                ctx.save();
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = withAlpha(accentColor, 0.6);
                ctx.lineWidth = 1.8;
                ctx.rotate(swirl * 0.8);
                for (let i = 0; i < 6; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, baseRadius * 0.3);
                    ctx.lineTo(0, baseRadius * 1.4);
                    ctx.stroke();
                    ctx.rotate(Math.PI / 3);
                }
                ctx.restore();

                // Core energy orb
                ctx.globalAlpha = 0.7;
                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, baseRadius * 0.5);
                coreGradient.addColorStop(0, withAlpha(accentColor, 0.8));
                coreGradient.addColorStop(1, withAlpha(trailColor, 0.25));
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, baseRadius * 0.15, baseRadius * 0.45, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            function drawIceman(iceman) {
                const { x, y, isMini } = iceman;
                const scale = isMini ? 0.4 : 1.0;
                drawEntityShadow(x, y, Math.max(12, 20 * scale), Math.max(5, 8 * scale), {
                    alpha: 0.28,
                    yOffset: Math.max(10, 18 * scale)
                });
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(12, 8);
                ctx.lineTo(8, 14);
                ctx.lineTo(0, 10);
                ctx.lineTo(-8, 14);
                ctx.lineTo(-12, 8);
                ctx.closePath();

                const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
                bodyGrad.addColorStop(0, "#a0e9ff");
                bodyGrad.addColorStop(1, "#3c9aed");
                ctx.fillStyle = bodyGrad;
                ctx.fill();

                ctx.lineWidth = 2;
                ctx.strokeStyle = "#d0f8ff";
                ctx.stroke();

                ctx.strokeStyle = "#a0e9ff";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-12, 5);
                ctx.lineTo(-20, -2);
                ctx.lineTo(-18, 8);
                ctx.moveTo(12, 5);
                ctx.lineTo(20, -2);
                ctx.lineTo(18, 8);
                ctx.stroke();

                ctx.fillStyle = "#ffffff";
                ctx.beginPath();
                ctx.arc(0, -8, 3, 0, 2 * Math.PI);
                ctx.fill();

                ctx.restore();
            }

            function stepEscortDrones(dt) {
                const p = store.player;
                if (!store.escortDrones || store.escortDrones.length === 0) return;

                for (let i = 0; i < store.escortDrones.length; i++) {
                    const drone = store.escortDrones[i];
                    
                    // Position drones out front of the player, alternating left/right
                    const targetX = p.x + (drone.side === 'left' ? -80 : 80);
                    const targetY = p.y - 60 - (drone.offset * 25); // Stagger vertically
                    
                    // Smooth movement towards target position
                    drone.x += (targetX - drone.x) * 0.15;
                    drone.y += (targetY - drone.y) * 0.15;
                    
                    // Update fire timer
                    drone.fireT += dt;
                    
                    // Fire a burst that mirrors the player's multishot pattern (every 0.25s)
                    if (drone.fireT >= 0.25) {
                        drone.fireT = 0;

                        const totalMultishot = Math.max(1, (p.multishot || 1) + (p.cheatMultishotBonus || 0));
                        const angleSpread = 10;
                        const bulletSpeed = 900;
                        const damagePerVolley = (15 * p.dmgMult * 0.35) * 0.5; // Preserve previous total volley damage
                        const damagePerBullet = damagePerVolley / totalMultishot;
                        const swirlShot = !!p.swirlShots;

                        for (let shotIndex = 0; shotIndex < totalMultishot; shotIndex++) {
                            const angleDegrees = (shotIndex - (totalMultishot - 1) / 2) * angleSpread;
                            const angle = angleDegrees * Math.PI / 180;
                            spawnBullet({
                                x: drone.x + 6 * Math.sin(angle),
                                y: drone.y - 8,
                                vx: Math.sin(angle) * bulletSpeed,
                                vy: -Math.cos(angle) * bulletSpeed,
                                r: 1.3,
                                col: '#66d1ff',
                                dmg: damagePerBullet,
                                pierce: p.piercing,
                                explosive: false,
                                isEscortDrone: true,
                                isSwirl: swirlShot
                            });
                        }
                    }
                }
            }

            function stepFragmentBlasters(dt, p) {
                if (!p.fragmentBlasters || p.fragmentBlasters.length === 0) return;

                const meleeRange = 150; // Reduced from 280
                const triggerRange = 100; // Reduced from 200

                for (let i = 0; i < p.fragmentBlasters.length; i++) {
                    const barrel = p.fragmentBlasters[i];
                    
                    // Update cooldowns
                    if (barrel.cooldown > 0) {
                        barrel.cooldown -= dt;
                    }
                    if (barrel.barrelDelay > 0) {
                        barrel.barrelDelay -= dt;
                    }

                    // Skip if on cooldown or in barrel delay
                    if (barrel.cooldown > 0 || barrel.barrelDelay > 0) continue;

                    // Find nearest enemy within trigger range (including boss)
                    let nearestEnemy = null;
                    let nearestDist = triggerRange;

                    // Check regular enemies
                    for (const e of store.enemies) {
                        if (e.dead) continue;
                        const dx = e.x - p.x;
                        const dy = e.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = e;
                        }
                    }
                    
                    // Also check for boss
                    if (store.boss && !store.boss.dead) {
                        const bossRadius = store.boss.r || 60;
                        const dx = store.boss.x - p.x;
                        const dy = store.boss.y - p.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) - bossRadius;
                        
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = store.boss;
                        }
                    }

                    // Fire if enemy found
                    if (nearestEnemy) {
                        // Calculate angle to target
                        const dx = nearestEnemy.x - p.x;
                        const dy = nearestEnemy.y - p.y;
                        const angle = Math.atan2(dy, dx);

                        // Fire a shotgun blast of fragments - smaller and more controlled
                        const fragmentCount = 10; // Reduced from 18
                        const spreadAngle = 0.5; // Reduced from 0.7
                        
                        for (let j = 0; j < fragmentCount; j++) {
                            const offsetAngle = angle + (Math.random() - 0.5) * spreadAngle;
                            const speed = 400 + Math.random() * 100; // Reduced from 520-670

                            spawnFragmentProjectile({
                                x: p.x,
                                y: p.y,
                                vx: Math.cos(offsetAngle) * speed,
                                vy: Math.sin(offsetAngle) * speed,
                                r: 2, // Reduced from 3
                                col: '#FFD700',
                                dmg: 8 * p.dmgMult,
                                pierce: p.piercing,
                                explosive: false,
                                isFragment: true,
                                maxLifetime: meleeRange / speed
                            });
                        }

                        // Set cooldown for this barrel
                        barrel.cooldown = 10; // 10 second cooldown

                        // Trigger barrel delay for ALL barrels
                        for (const b of p.fragmentBlasters) {
                            b.barrelDelay = 1.0; // 1 second delay before any barrel can fire again
                        }
                    }
                }
            }

            function drawEscortDrones() {
                if (!store.escortDrones || store.escortDrones.length === 0) return;

                for (const drone of store.escortDrones) {
                    drawEntityShadow(drone.x, drone.y, 10, 4, { alpha: 0.24, yOffset: 8 });
                    ctx.save();
                    ctx.translate(drone.x, drone.y);
                    
                    // Small pulsing opacity
                    ctx.globalAlpha = 0.7 + 0.15 * Math.sin(performance.now() / 150);
                    
                    // Draw a small triangular drone
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(6, 4);
                    ctx.lineTo(0, 2);
                    ctx.lineTo(-6, 4);
                    ctx.closePath();
                    
                    const gradient = ctx.createLinearGradient(0, -8, 0, 4);
                    gradient.addColorStop(0, '#a0e9ff');
                    gradient.addColorStop(1, '#4c9aed');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = '#d0f8ff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Small glowing core
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, -2, 1.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.restore();
                }
            }

            function drawBeefClone(beefClone) {
                const { x, y, mode } = beefClone;
                const visualScale = beefClone.visualScale || 1;
                drawEntityShadow(x, y, Math.max(16, 24 * visualScale), Math.max(7, 10 * visualScale), {
                    alpha: 0.28,
                    yOffset: Math.max(12, 22 * visualScale)
                });
                ctx.save();
                ctx.translate(x, y);

                const facing = beefClone.direction || 1;
                if (facing < 0) {
                    ctx.scale(-visualScale, visualScale);
                } else {
                    ctx.scale(visualScale, visualScale);
                }

                if (mode === 'juggernaut_bomber') {
                    const time = performance.now();
                    const tilt = (Math.sin((beefClone.bobPhase || 0) * 0.8) * 0.08) + ((beefClone.direction || 1) * 0.05);
                    ctx.rotate(tilt);
                    ctx.globalAlpha = 0.6 + 0.12 * Math.sin(time / 140);

                    ctx.beginPath();
                    ctx.moveTo(0, -24);
                    ctx.lineTo(22, -6);
                    ctx.lineTo(18, 10);
                    ctx.lineTo(0, 20);
                    ctx.lineTo(-18, 10);
                    ctx.lineTo(-22, -6);
                    ctx.closePath();

                    const hullGrad = ctx.createLinearGradient(0, -24, 0, 20);
                    hullGrad.addColorStop(0, '#f5c8a2');
                    hullGrad.addColorStop(0.45, '#e28553');
                    hullGrad.addColorStop(1, '#3a1e1e');
                    ctx.fillStyle = hullGrad;
                    ctx.fill();

                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(230, 160, 115, 0.6)';
                    ctx.stroke();

                    // Nose glow
                    ctx.fillStyle = 'rgba(245, 220, 185, 0.65)';
                    ctx.beginPath();
                    ctx.arc(0, -20, 4, 0, 2 * Math.PI);
                    ctx.fill();

                    // Cockpit canopy
                    ctx.fillStyle = 'rgba(240, 228, 208, 0.6)';
                    ctx.beginPath();
                    ctx.ellipse(0, -8, 6, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Thruster flames
                    const pulse = 0.7 + 0.3 * Math.sin(time / 90 + (beefClone.bobPhase || 0) * 2);
                    const flameHeight = 12 + pulse * 6;
                    ctx.fillStyle = `rgba(240, 140, 60, ${0.28 + 0.22 * pulse})`;
                    ctx.beginPath();
                    ctx.moveTo(-10, 12);
                    ctx.lineTo(-20, 12 + flameHeight);
                    ctx.lineTo(-4, 18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(10, 12);
                    ctx.lineTo(20, 12 + flameHeight);
                    ctx.lineTo(4, 18);
                    ctx.closePath();
                    ctx.fill();

                    // Bomb bay glow
                    ctx.fillStyle = 'rgba(255, 200, 110, 0.45)';
                    ctx.beginPath();
                    ctx.ellipse(0, 8, 12, 6, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.globalAlpha = 0.46 + 0.12 * Math.sin(performance.now() / 220);

                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(8, 14);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(-8, 14);
                    ctx.lineTo(-12, 8);
                    ctx.closePath();

                    const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
                    bodyGrad.addColorStop(0, '#7dd8a3');
                    bodyGrad.addColorStop(1, '#269960');
                    ctx.fillStyle = bodyGrad;
                    ctx.fill();

                    ctx.lineWidth = 1.6;
                    ctx.strokeStyle = 'rgba(168, 228, 185, 0.65)';
                    ctx.stroke();

                    ctx.strokeStyle = 'rgba(140, 215, 165, 0.55)';
                    ctx.lineWidth = 1.4;
                    ctx.beginPath();
                    ctx.moveTo(-12, 5);
                    ctx.lineTo(-20, -2);
                    ctx.lineTo(-18, 8);
                    ctx.moveTo(12, 5);
                    ctx.lineTo(20, -2);
                    ctx.lineTo(18, 8);
                    ctx.stroke();

                    ctx.fillStyle = 'rgba(230, 245, 235, 0.75)';
                    ctx.beginPath();
                    ctx.arc(0, -8, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }

                ctx.restore();
            }
            function drawLightningBolt(bolt) {
                const { points, life, maxLife } = bolt;
                const t = life / maxLife;
                if (t <= 0) return;

                ctx.save();
                
                // Draw ambient energy glow that persists longer (fades slower at the end)
                const glowT = Math.min(1, t * 1.5); // Glow fades 50% slower
                if (glowT > 0) {
                    ctx.lineWidth = 14 * glowT;
                    ctx.strokeStyle = `rgba(180, 200, 255, ${0.15 * glowT})`;
                    ctx.shadowColor = '#b8d4ff';
                    ctx.shadowBlur = 40 * glowT;
                    
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.stroke();
                }
                
                // Draw secondary outer glow
                ctx.lineWidth = 8 * t;
                ctx.strokeStyle = `rgba(200, 220, 255, ${0.3 * t})`;
                ctx.shadowColor = '#9a66ff';
                ctx.shadowBlur = 25 * t;
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();

                // Draw main bright lightning bolt
                ctx.lineWidth = 4 * t;
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * t})`;
                ctx.shadowColor = '#d0e8ff';
                ctx.shadowBlur = 20 * t;

                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();

                // Draw bright core
                ctx.lineWidth = 1.5 * t;
                ctx.strokeStyle = `rgba(255, 255, 255, ${t})`;
                ctx.shadowBlur = 10 * t;
                ctx.stroke();

                ctx.restore();
            }
            
            function drawHunterLightningChain(chain) {
                const { x1, y1, x2, y2, life, gang } = chain;
                const maxLife = 0.3;
                const t = life / maxLife;
                if (t <= 0) return;
                
                ctx.save();
                
                // Create jagged lightning effect
                const segments = 8;
                const dx = (x2 - x1) / segments;
                const dy = (y2 - y1) / segments;
                const perpX = -dy;
                const perpY = dx;
                const perpLen = Math.sqrt(perpX * perpX + perpY * perpY);
                const perpNormX = perpLen > 0 ? perpX / perpLen : 0;
                const perpNormY = perpLen > 0 ? perpY / perpLen : 0;
                
                const points = [{ x: x1, y: y1 }];
                for (let i = 1; i < segments; i++) {
                    const baseX = x1 + dx * i;
                    const baseY = y1 + dy * i;
                    const jitter = (Math.random() - 0.5) * 20;
                    points.push({
                        x: baseX + perpNormX * jitter,
                        y: baseY + perpNormY * jitter
                    });
                }
                points.push({ x: x2, y: y2 });
                
                // Draw glow
                ctx.shadowColor = '#5DADE2';
                ctx.shadowBlur = 15 * t;
                ctx.lineWidth = 6 * t;
                ctx.strokeStyle = `rgba(93, 173, 226, ${0.6 * t})`;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
                
                // Draw bright core
                ctx.shadowBlur = 8 * t;
                ctx.lineWidth = 2.5 * t;
                ctx.strokeStyle = `rgba(180, 220, 255, ${0.95 * t})`;
                ctx.stroke();
                
                // Draw white hot center
                ctx.shadowBlur = 4 * t;
                ctx.lineWidth = 1 * t;
                ctx.strokeStyle = `rgba(255, 255, 255, ${t})`;
                ctx.stroke();
                
                ctx.restore();
            }

            function drawFlamePulse(pulse) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                const time = performance.now() / 1000;
                const lifeRatio = pulse.life / 2.0;
                const opacity = Math.min(1, lifeRatio);

                // Outer fire ring (orange)
                const outerGradient = ctx.createRadialGradient(pulse.x, pulse.y, pulse.radius - 20, pulse.x, pulse.y, pulse.radius + 10);
                outerGradient.addColorStop(0, `rgba(255, 69, 0, 0)`);
                outerGradient.addColorStop(0.4, `rgba(255, 120, 0, ${opacity * 0.6})`);
                outerGradient.addColorStop(0.7, `rgba(255, 80, 0, ${opacity * 0.8})`);
                outerGradient.addColorStop(1, `rgba(255, 40, 0, 0)`);

                ctx.fillStyle = outerGradient;
                ctx.beginPath();
                ctx.arc(pulse.x, pulse.y, pulse.radius + 10, 0, Math.PI * 2);
                ctx.arc(pulse.x, pulse.y, Math.max(0, pulse.radius - 20), 0, Math.PI * 2, true);
                ctx.fill();

                // Inner hot core (yellow/white)
                const innerGradient = ctx.createRadialGradient(pulse.x, pulse.y, pulse.radius - 15, pulse.x, pulse.y, pulse.radius + 5);
                innerGradient.addColorStop(0, `rgba(255, 255, 200, 0)`);
                innerGradient.addColorStop(0.5, `rgba(255, 220, 100, ${opacity * 0.7})`);
                innerGradient.addColorStop(1, `rgba(255, 150, 50, 0)`);

                ctx.fillStyle = innerGradient;
                ctx.beginPath();
                ctx.arc(pulse.x, pulse.y, pulse.radius + 5, 0, Math.PI * 2);
                ctx.arc(pulse.x, pulse.y, Math.max(0, pulse.radius - 15), 0, Math.PI * 2, true);
                ctx.fill();

                // Pulsing glow effect
                const pulseEffect = 0.5 + 0.5 * Math.sin(time * 10);
                ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
                ctx.shadowBlur = 20 * pulseEffect;
                ctx.strokeStyle = `rgba(255, 180, 80, ${opacity * 0.8 * pulseEffect})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pulse.x, pulse.y, pulse.radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            function drawEmpNova(nova) {
                ctx.save();

                // Create pulsing effect
                const time = performance.now() / 1000;
                const pulse = 0.8 + 0.2 * Math.sin(time * 8);
                const opacity = Math.min(1, nova.life / 2) * 0.3; // Fade in over 2 seconds

                // Draw expanding EMP ring
                ctx.strokeStyle = `rgba(255, 140, 0, ${opacity * pulse})`; // Orange cyberpunk color
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]); // Dashed line for tech effect
                ctx.shadowColor = '#FF8C00';
                ctx.shadowBlur = 15;

                ctx.beginPath();
                ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner energy ring
                ctx.strokeStyle = `rgba(138, 43, 226, ${opacity * pulse * 0.7})`; // Purple
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.shadowColor = '#8A2BE2';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.arc(nova.x, nova.y, nova.radius * 0.7, 0, Math.PI * 2);
                ctx.stroke();

                // Add some sparking effects around the perimeter
                ctx.setLineDash([]);
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * pulse})`;
                ctx.lineWidth = 1;

                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + time * 2;
                    const x1 = nova.x + Math.cos(angle) * (nova.radius - 5);
                    const y1 = nova.y + Math.sin(angle) * (nova.radius - 5);
                    const x2 = nova.x + Math.cos(angle) * (nova.radius + 5);
                    const y2 = nova.y + Math.sin(angle) * (nova.radius + 5);

                    if (Math.random() < 0.3) { // Random sparking
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

            function activateGravityWell(scale = 1.0) {
                if (!store.isPaused) {
                    const spawnX = W * 0.2 + Math.random() * W * 0.6;
                    const spawnY = H * 0.2 + Math.random() * H * 0.6;
                    store.activeEffects.push(createEffect("gravityWell", spawnX, spawnY, scale));
                    announce(scale < 1.0 ? 'MINI GRAVITY WELL ACTIVATED' : 'GRAVITY WELL ACTIVATED');
                    screenFlash(2, 250, 'rgba(255, 255, 255, 0.7)');
                }
            }
            function activateLazarus(scale = 1.0) {
                if (store.player.hasLazarusBeam && !store.isPaused) {
                    const angle = Math.random() * 2 * Math.PI,
                        speed = 800,
                        p = store.player;
                    const laserRadius = scale < 1.0 ? 6 : 12; // Mini version has half the width
                    store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 6, r: laserRadius, hitEnemies: new Set, isMini: scale < 1.0 });

                    if (p.upgradeLevels.lazarus_beam > 1) {
                        const oppositeAngle = angle + Math.PI;
                        store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(oppositeAngle) * speed, vy: Math.sin(oppositeAngle) * speed, life: 6, r: laserRadius, hitEnemies: new Set, isMini: scale < 1.0 });
                    }
                }
            }
            // Shield Pulse System Configuration (internal name: EMP_BURST_CONFIG for backwards compatibility)
            const EMP_BURST_CONFIG = {
                radius: 480, // Doubled from 240
                baseStun: 2.8,
                shockDuration: 1.6,
                mechanicalStunBonus: 1.2,
                mechanicalShockBonus: 0.8,
                electrifiedStunBonus: 1.1,
                electrifiedShockBonus: 0.9,
                slowFactor: 0.5,
                slowDuration: 2.6,
                projectilePurgeRadiusRatio: 0.75,
                proximityTriggerRadius: 180, // Auto-activate when enemy within this range (imminent threat)
                chargeCooldown: 30, // Per-charge cooldown in seconds
                globalCooldown: 4.5, // Prevent overlapping bursts while effects resolve
                maxCharges: 3,
                orbitRadius: 85,
                orbitSpeed: 1.2,
                bossMaxStun: 2.2,
                bossMaxShock: 2.0
            };

            function createEmpCharge() {
                if (!store.empCharges) store.empCharges = [];
                if (store.empCharges.length >= (EMP_BURST_CONFIG.maxCharges || 3)) {
                    store.player.grenades = store.empCharges.length;
                    return;
                }
                const chargeCount = store.empCharges.length;
                const charge = {
                    x: store.player.x,
                    y: store.player.y,
                    orbitAngle: (chargeCount / (chargeCount + 1)) * Math.PI * 2,
                    orbitRadius: EMP_BURST_CONFIG.orbitRadius,
                    orbitSpeed: EMP_BURST_CONFIG.orbitSpeed,
                    pulsePhase: Math.random() * Math.PI * 2,
                    cooldown: 0, // Track cooldown per charge
                    dead: false
                };
                store.empCharges.push(charge);
                store.player.grenades = store.empCharges.length;

                const total = store.empCharges.length;
                if (total > 0) {
                    for (let i = 0; i < total; i++) {
                        const c = store.empCharges[i];
                        if (!c) continue;
                        c.orbitAngle = (i / total) * Math.PI * 2;
                    }
                }
            }

            function stepEmpCharges(dt) {
                if (!store.empCharges || store.empCharges.length === 0) return;
                const p = store.player;
                if (!p || p.dead) {
                    store.empCharges.length = 0;
                    store.empGlobalCooldown = 0;
                    store.player.grenades = 0;
                    return;
                }

                store.empGlobalCooldown = Math.max(0, (store.empGlobalCooldown || 0) - dt);

                const proximityRadiusSq = EMP_BURST_CONFIG.proximityTriggerRadius ** 2;
                const targets = store.boss
                    ? [...(store.enemies || []), store.boss]
                    : [...(store.enemies || [])];

                for (let i = store.empCharges.length - 1; i >= 0; i--) {
                    const charge = store.empCharges[i];
                    if (!charge || charge.dead) {
                        store.empCharges.splice(i, 1);
                        store.player.grenades = store.empCharges.length;
                        continue;
                    }

                    // Update orbit position
                    charge.orbitAngle += charge.orbitSpeed * dt;
                    charge.pulsePhase += dt * 4;
                    const radius = charge.orbitRadius * (1 + Math.sin(charge.pulsePhase) * 0.05);
                    const targetX = p.x + Math.cos(charge.orbitAngle) * radius;
                    const targetY = p.y + Math.sin(charge.orbitAngle) * radius * 0.6;
                    charge.x += (targetX - charge.x) * Math.min(1, 12 * dt);
                    charge.y += (targetY - charge.y) * Math.min(1, 12 * dt);

                    // Update cooldown
                    charge.cooldown = Math.max(0, (charge.cooldown || 0) - dt);
                    if (charge.cooldown > 0) {
                        continue; // Skip trigger check if on cooldown
                    }

                    if ((store.empGlobalCooldown || 0) > 0) {
                        continue; // Ability still in global cooldown window
                    }

                    if (!targets.length) {
                        continue;
                    }

                    // Count unaffected enemies within blast radius to avoid wasteful triggering
                    let unaffectedEnemiesInRange = 0;
                    const empBlastRadius = EMP_BURST_CONFIG.radius || 480;
                    const empBlastRadiusSq = empBlastRadius * empBlastRadius;
                    
                    for (const enemy of targets) {
                        if (!enemy || enemy.dead) continue;
                        
                        // First check if enemy is in proximity trigger range (close threat)
                        const dxProximity = enemy.x - charge.x;
                        const dyProximity = enemy.y - charge.y;
                        const distSqProximity = dxProximity * dxProximity + dyProximity * dyProximity;
                        
                        if (distSqProximity < proximityRadiusSq) {
                            // Now check if they're within the actual EMP blast radius
                            if (distSqProximity < empBlastRadiusSq) {
                                // Check if this enemy would actually be affected by EMP
                                const hasRecentEmpStun = enemy.stunTimer && enemy.stunTimer > 1.5; // Has >1.5s stun left
                                const hasRecentEmpShock = enemy.stormShockTimer && enemy.stormShockTimer > 1.0; // Has >1s shock left
                                const isRecentlyAffected = hasRecentEmpStun || hasRecentEmpShock;
                                
                                if (!isRecentlyAffected) {
                                    unaffectedEnemiesInRange++;
                                }
                            }
                        }
                    }

                    // Only trigger if we have at least 2 valid targets (or 1 boss)
                    const isBossNearby = store.boss && !store.boss.dead && 
                        ((store.boss.x - charge.x) ** 2 + (store.boss.y - charge.y) ** 2 < proximityRadiusSq);
                    const minTargetsRequired = isBossNearby ? 1 : 2;
                    
                    if (unaffectedEnemiesInRange >= minTargetsRequired) {
                        // Trigger Shield Pulse burst at charge location
                        triggerEmpBurst(charge.x, charge.y);
                        // Set cooldown - Shield Pulse charges recharge after use
                        charge.cooldown = EMP_BURST_CONFIG.chargeCooldown;
                        store.empGlobalCooldown = Math.max(store.empGlobalCooldown || 0, EMP_BURST_CONFIG.globalCooldown || 0);
                    }
                }

                store.player.grenades = store.empCharges.length;
            }

            function triggerEmpBurst(x, y) {
                const p = store.player;
                if (!p || store.isPaused) return;

                const isMini = p.miniAbilities && p.miniAbilities.has('grenade');
                const radius = isMini ? EMP_BURST_CONFIG.radius * 0.6 : EMP_BURST_CONFIG.radius; // Mini EMP is 60% radius
                screenFlash(1, 140, 'rgba(100, 200, 255, 0.2)');
                store.activeEffects.push(createEffect('empShockwave', x, y, radius));

                const radiusSq = radius * radius;
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;

                targets.forEach(enemy => {
                    if (!enemy || enemy.dead) return;
                    const dx = enemy.x - x;
                    const dy = enemy.y - y;
                    if (dx * dx + dy * dy > radiusSq) return;

                    const isBoss = enemy === store.boss;
                    const type = typeof enemy.type === 'string' ? enemy.type.toLowerCase() : '';
                    const isMechanical = /mech|drone|sentinel|turret|construct|omega/.test(type);

                    let stunDuration = EMP_BURST_CONFIG.baseStun;
                    let shockDuration = EMP_BURST_CONFIG.shockDuration;

                    if (isMechanical) {
                        stunDuration += EMP_BURST_CONFIG.mechanicalStunBonus;
                        shockDuration += EMP_BURST_CONFIG.mechanicalShockBonus || 0;
                    }

                    const isElectrified = enemy.stormShockTimer && enemy.stormShockTimer > 0;
                    if (isElectrified) {
                        stunDuration += EMP_BURST_CONFIG.electrifiedStunBonus;
                        shockDuration += EMP_BURST_CONFIG.electrifiedShockBonus || 0;
                    }

                    if (enemy.phaseLockTimer && enemy.phaseLockTimer > 0) {
                        stunDuration += 0.8;
                        enemy.phaseLockTimer = Math.max(enemy.phaseLockTimer, 1.8);
                        enemy.phaseLockSlowFactor = Math.min(enemy.phaseLockSlowFactor || 1, 0.35);
                    }

                    if (isBoss) {
                        stunDuration = Math.min(stunDuration, EMP_BURST_CONFIG.bossMaxStun ?? 2.2);
                        shockDuration = Math.min(shockDuration, EMP_BURST_CONFIG.bossMaxShock ?? 2.0);
                    }

                    enemy.stunTimer = Math.max(enemy.stunTimer || 0, stunDuration);
                    enemy.stormShockTimer = Math.max(enemy.stormShockTimer || 0, shockDuration);
                    enemy.stormShockIntensity = Math.max(enemy.stormShockIntensity || 0, 1);

                    enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, EMP_BURST_CONFIG.slowFactor);
                    enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, EMP_BURST_CONFIG.slowDuration ?? 2.6);

                    store.activeEffects.push(createEffect('stormDischarge', enemy.x, enemy.y, Math.max(enemy.r || 24, 24) * 1.6));
                });

                if (store.eBullets && store.eBullets.length) {
                    const purgeRadius = EMP_BURST_CONFIG.radius * EMP_BURST_CONFIG.projectilePurgeRadiusRatio;
                    const purgeRadiusSq = purgeRadius * purgeRadius;
                    for (let i = store.eBullets.length - 1; i >= 0; i--) {
                        const bullet = store.eBullets[i];
                        if (!bullet) continue;
                        const dx = bullet.x - x;
                        const dy = bullet.y - y;
                        if (dx * dx + dy * dy <= purgeRadiusSq) {
                            store.eBullets.splice(i, 1);
                            store.activeEffects.push(createEffect('empStatic', bullet.x, bullet.y, 20));
                        }
                    }
                }
            }

            function ensureKnockbackChargeList() {
                if (!store.knockbackCharges) store.knockbackCharges = [];
            }

            function createKnockbackShieldCharge() {
                ensureKnockbackChargeList();
                if (store.knockbackCharges.length >= (KNOCKBACK_SHIELD_CONFIG.maxCharges || 3)) {
                    if (store.player) store.player.knockbackShields = store.knockbackCharges.length;
                    return;
                }

                const chargeCount = store.knockbackCharges.length;
                const charge = {
                    x: store.player.x,
                    y: store.player.y,
                    orbitAngle: (chargeCount / (chargeCount + 1)) * Math.PI * 2,
                    orbitRadius: KNOCKBACK_SHIELD_CONFIG.orbitRadius,
                    orbitSpeed: KNOCKBACK_SHIELD_CONFIG.orbitSpeed,
                    pulsePhase: Math.random() * Math.PI * 2,
                    cooldown: 0,
                    dead: false
                };

                store.knockbackCharges.push(charge);

                const total = store.knockbackCharges.length;
                if (total > 0) {
                    for (let i = 0; i < total; i++) {
                        const c = store.knockbackCharges[i];
                        if (!c) continue;
                        c.orbitAngle = (i / total) * Math.PI * 2;
                    }
                }

                if (store.player) store.player.knockbackShields = store.knockbackCharges.length;
            }

            function stepKnockbackShieldCharges(dt) {
                ensureKnockbackChargeList();

                if (store.knockbackCharges.length === 0) {
                    store.knockbackGlobalCooldown = Math.max(0, (store.knockbackGlobalCooldown || 0) - dt);
                    if (store.player) store.player.knockbackShields = 0;
                    return;
                }

                const p = store.player;
                if (!p || p.dead) {
                    store.knockbackCharges.length = 0;
                    store.knockbackGlobalCooldown = 0;
                    if (store.player) store.player.knockbackShields = 0;
                    return;
                }

                store.knockbackGlobalCooldown = Math.max(0, (store.knockbackGlobalCooldown || 0) - dt);

                const stats = getKnockbackShieldStats();
                const beefMode = stats.beefMode;
                const proximityRadius = KNOCKBACK_SHIELD_CONFIG.proximityTriggerRadius || 0;
                const proximityRadiusSq = proximityRadius * proximityRadius;
                const shieldRadiusSq = stats.radius * stats.radius;

                const targets = store.boss
                    ? [...(store.enemies || []), store.boss]
                    : [...(store.enemies || [])];

                for (let i = store.knockbackCharges.length - 1; i >= 0; i--) {
                    const charge = store.knockbackCharges[i];
                    if (!charge || charge.dead) {
                        store.knockbackCharges.splice(i, 1);
                        if (store.player) store.player.knockbackShields = store.knockbackCharges.length;
                        continue;
                    }

                    const targetOrbitRadius = KNOCKBACK_SHIELD_CONFIG.orbitRadius;
                    if (Number.isFinite(targetOrbitRadius)) {
                        charge.orbitRadius += (targetOrbitRadius - charge.orbitRadius) * Math.min(1, 6 * dt);
                    }

                    charge.orbitAngle += charge.orbitSpeed * dt;
                    charge.pulsePhase += dt * 3.6;
                    const radius = charge.orbitRadius * (1 + Math.sin(charge.pulsePhase) * 0.06);
                    const targetX = p.x + Math.cos(charge.orbitAngle) * radius;
                    const targetY = p.y + Math.sin(charge.orbitAngle) * radius * 0.65;
                    charge.x += (targetX - charge.x) * Math.min(1, 10 * dt);
                    charge.y += (targetY - charge.y) * Math.min(1, 10 * dt);

                    charge.cooldown = Math.max(0, (charge.cooldown || 0) - dt);
                    if (charge.cooldown > 0) {
                        continue;
                    }

                    if ((store.knockbackGlobalCooldown || 0) > 0) {
                        continue;
                    }

                    if (!targets.length) {
                        continue;
                    }

                    let validTargets = 0;
                    let contactTrigger = false;
                    let minTargetsRequired = beefMode ? 2 : 1;

                    if (beefMode && store.boss && !store.boss.dead) {
                        const dxBoss = store.boss.x - charge.x;
                        const dyBoss = store.boss.y - charge.y;
                        const bossDistSq = dxBoss * dxBoss + dyBoss * dyBoss;
                        if (bossDistSq < proximityRadiusSq) {
                            minTargetsRequired = 1;
                        }
                    }

                    for (const enemy of targets) {
                        if (!enemy || enemy.dead) continue;

                        const dx = enemy.x - charge.x;
                        const dy = enemy.y - charge.y;
                        const distSq = dx * dx + dy * dy;

                        if (beefMode) {
                            if (distSq > proximityRadiusSq) continue;
                            if (distSq > shieldRadiusSq) continue;

                            validTargets++;
                            if (validTargets >= minTargetsRequired) break;
                        } else {
                            const enemyRadius = Math.max(12, enemy.r || 0);
                            const contactThreshold = stats.contactRadius + enemyRadius * stats.contactEnemyScale;
                            const contactThresholdSq = contactThreshold * contactThreshold;
                            if (distSq <= contactThresholdSq) {
                                contactTrigger = true;
                                break;
                            }
                        }
                    }

                    const shouldTrigger = beefMode ? validTargets >= minTargetsRequired : contactTrigger;

                    if (shouldTrigger) {
                        triggerKnockbackShieldBurst(charge.x, charge.y, stats);
                        charge.cooldown = KNOCKBACK_SHIELD_CONFIG.chargeCooldown;
                        store.knockbackGlobalCooldown = Math.max(store.knockbackGlobalCooldown || 0, KNOCKBACK_SHIELD_CONFIG.globalCooldown || 0);
                    }
                }

                if (store.player) store.player.knockbackShields = store.knockbackCharges.length;
            }

            function triggerKnockbackShieldBurst(x, y, precomputedStats) {
                const p = store.player;
                if (!p || store.isPaused) return;

                const stats = precomputedStats || getKnockbackShieldStats();
                const { beefMode, radius, knockbackStrength, knockbackDuration, stunDuration, slowFactor, slowDuration } = stats;
                const radiusSq = radius * radius;

                if (typeof screenFlash === 'function') {
                    const flashColor = beefMode
                        ? (KNOCKBACK_SHIELD_CONFIG.screenFlashColor || 'rgba(40, 40, 55, 0.35)')
                        : (KNOCKBACK_SHIELD_CONFIG.nonBeefScreenFlashColor || KNOCKBACK_SHIELD_CONFIG.screenFlashColor || 'rgba(40, 40, 55, 0.22)');
                    screenFlash(1, beefMode ? 120 : 90, flashColor);
                }

                store.activeEffects.push(createEffect('knockbackShockwave', x, y, radius));

                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;

                targets.forEach(enemy => {
                    if (!enemy || enemy.dead) return;
                    const dx = enemy.x - x;
                    const dy = enemy.y - y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > radiusSq) return;

                    const angle = Math.atan2(dy, dx);
                    registerEnemyHit(enemy, {
                        angle,
                        knockbackStrength,
                        knockbackDuration,
                        shakeIntensity: beefMode ? 6 : 3,
                        shakeDuration: beefMode ? 0.24 : 0.16,
                        slowFactor,
                        slowDuration,
                        effect: false
                    });

                    if (enemy.knockback) {
                        enemy.knockback.type = 'knockbackShield';
                        enemy.knockback.duration = Math.max(enemy.knockback.duration || 0, knockbackDuration);
                    }

                    enemy.stunTimer = Math.max(enemy.stunTimer || 0, stunDuration);
                    enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, slowFactor);
                    enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
                });

                if (store.eBullets && store.eBullets.length) {
                    const purgeRatioBase = KNOCKBACK_SHIELD_CONFIG.projectilePurgeRadiusRatio || 0;
                    const purgeRatio = purgeRatioBase * (beefMode ? 1 : (KNOCKBACK_SHIELD_CONFIG.nonBeefPurgeMultiplier ?? 0.4));
                    if (purgeRatio > 0) {
                        const purgeRadius = radius * purgeRatio;
                        const purgeRadiusSq = purgeRadius * purgeRadius;
                        for (let i = store.eBullets.length - 1; i >= 0; i--) {
                            const bullet = store.eBullets[i];
                            if (!bullet) continue;
                            const dx = bullet.x - x;
                            const dy = bullet.y - y;
                            if (dx * dx + dy * dy <= purgeRadiusSq) {
                                store.eBullets.splice(i, 1);
                                store.activeEffects.push(createEffect('empStatic', bullet.x, bullet.y, 20));
                            }
                        }
                    }
                }
            }

            function stepVoidLaser(dt) {
                const p = store.player;

                // Determine range based on phasestriker level
                let maxRange;
                if (p.phasestRikerLevel >= 1) {
                    // Level 1+: Global range - can hit anything on screen (unlimited range upgrade)
                    maxRange = Math.max(W, H) * 2; // Unlimited range using game dimensions
                } else if (p.phasestRikerLevel >= 0.5) {
                    // Base phasestriker: Use voidLaserRange (medium range)
                    maxRange = p.voidLaserRange || 250;
                } else {
                    // No phasestriker: Default short range
                    maxRange = p.r * 12;
                }

                // Timer for retargeting - check for new targets every 0.1 seconds
                p.voidLaserRetargetTimer -= dt;
                if (p.voidLaserRetargetTimer <= 0) {
                    p.voidLaserRetargetTimer = 0.1;

                    // Find highest priority (HP) enemy within range AND in playfield
                    const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
                    
                    // Filter enemies within range and in playfield, then sort by HP descending
                    const playfieldMargin = 50; // Allow some margin for bosses
                    const enemiesInRange = allEnemies.filter(e => {
                        const distSq = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                        const inPlayfield = e.x >= -playfieldMargin && e.x <= W + playfieldMargin && 
                                           e.y >= -playfieldMargin && e.y <= H + playfieldMargin;
                        return distSq <= maxRange * maxRange && inPlayfield;
                    });
                    
                    let highestPriorityTarget = null;
                    if (enemiesInRange.length > 0) {
                        // Prioritize: Boss > Champion > Highest HP
                        const bosses = enemiesInRange.filter(e => e.isBoss);
                        const champions = enemiesInRange.filter(e => e.isChampion && !e.isBoss);
                        const regular = enemiesInRange.filter(e => !e.isBoss && !e.isChampion);
                        
                        if (bosses.length > 0) {
                            highestPriorityTarget = bosses.sort((a, b) => b.hp - a.hp)[0];
                        } else if (champions.length > 0) {
                            highestPriorityTarget = champions.sort((a, b) => b.hp - a.hp)[0];
                        } else {
                            highestPriorityTarget = regular.sort((a, b) => b.hp - a.hp)[0];
                        }
                    }

                    // Reset ramp time if target changed
                    if (highestPriorityTarget !== p.voidLaserLastTarget) {
                        p.voidLaserRampTime = 0;
                        p.voidLaserLastTarget = highestPriorityTarget;
                        
                        // Play power sound once when locking onto a NEW significant target
                        if (highestPriorityTarget) {
                            const isSignificantTarget = highestPriorityTarget.isBoss || 
                                                       highestPriorityTarget.isChampion || 
                                                       highestPriorityTarget.type === 'cube_burglar';
                            if (isSignificantTarget && !powerSoundPlayedTargets.has(highestPriorityTarget)) {
                                playSound('power');
                                powerSoundPlayedTargets.add(highestPriorityTarget);
                            }
                        }
                    }

                    p.voidLaserTarget = highestPriorityTarget;
                }

                // Apply continuous damage if we have a target
                if (p.voidLaserTarget && !p.voidLaserTarget.dead) {
                    // Check if target is still in range
                    const distSq = (p.x - p.voidLaserTarget.x) ** 2 + (p.y - p.voidLaserTarget.y) ** 2;
                    if (distSq <= maxRange * maxRange) {
                        // Increase ramp time for level 2 phasestriker
                        if (p.phasestRikerLevel >= 2) {
                            p.voidLaserRampTime += dt;
                        }

                        // Damage timer - apply damage every 0.1 seconds for smooth continuous damage
                        p.voidLaserDamageTimer -= dt;
                        if (p.voidLaserDamageTimer <= 0) {
                            p.voidLaserDamageTimer = 0.1;

                            // Base damage
                            let damage = 8.5 * p.dmgMult;

                            // Level 2 phasestriker: Ramping damage based on time on target
                            if (p.phasestRikerLevel >= 2) {
                                const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // +80% damage per second
                                damage *= Math.min(rampMultiplier, 4.0); // Cap at 4x damage
                            }

                            // Level 4 phasestriker: Double Long Range Intensifying Beam - double damage with intensification
                            if (p.phasestRikerLevel >= 4 && p.doubleBeam) {
                                damage *= 2; // Double beam doubles the damage
                                // Additional intensification over time
                                if (p.beamIntensifyRate && p.voidLaserRampTime > 0) {
                                    const intensifyMultiplier = 1 + (p.voidLaserRampTime * p.beamIntensifyRate);
                                    damage *= Math.min(intensifyMultiplier, 2.0); // Cap at 2x additional intensification
                                }
                            }

                            if (p.voidLaserTarget === store.boss) damage *= 0.4; // Reduced damage to boss

                            const voidLaserVuln = applySubclassVulnerability(p.voidLaserTarget, damage, {
                                subclass: p.subclass,
                                player: p,
                                damageTags: ['void', 'magic'],
                                source: 'voidLaser',
                                baseDamage: damage
                            });
                            damage = voidLaserVuln.damage;

                            p.voidLaserTarget.hp -= damage;
                            store.world.totalDamage += damage;

                            // Apply vampirism healing for laser damage
                            if (store.player.vampirism > 0) {
                                let healAmount = damage * store.player.vampirism;
                                healAmount = Math.max(healAmount, 0.1); // Minimum heal
                                healAmount = Math.min(healAmount, 0.6); // Increased heal cap slightly
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                        }
                    } else {
                        // Target out of range
                        p.voidLaserTarget = null;
                        p.voidLaserRampTime = 0;
                        p.voidLaserLastTarget = null;
                    }
                } else {
                    // No target or target dead - reset ramp
                    p.voidLaserTarget = null;
                    p.voidLaserRampTime = 0;
                    p.voidLaserLastTarget = null;
                }
            }

            function stepWiperLasers(dt) {
                const p = store.player;
                const time = performance.now() / 1000;

                // Initialize wiper laser blur tracking if needed
                if (!p.wiperLaserBlurTrail) p.wiperLaserBlurTrail = [];

                // Different behavior during blink slash vs normal mode
                if (p.isBlinkSlashing) {
                    // SLASH MODE: Focused, dramatic blade-like movement
                    const slashSpeed = 4.5; // Faster, more dramatic during slash
                    const slashRange = Math.PI; // Wider sweep range (Â±180Â°)

                    // Create synchronized slashing motion
                    const slashPhase = time * slashSpeed;
                    p.wiperLaser1Angle = Math.sin(slashPhase) * slashRange * 0.5;
                    p.wiperLaser2Angle = p.wiperLaser1Angle + Math.PI; // Opposite side

                    // Add motion blur during slash
                    p.wiperLaserBlurTrail.unshift({
                        angle1: p.wiperLaser1Angle,
                        angle2: p.wiperLaser2Angle,
                        life: 0.15,
                        intensity: 0.8
                    });

                } else {
                    // NORMAL MODE: Ninja-like variable speed movement
                    const baseSpeed = 1.8; // Slightly slower for better control
                    const speedVariation = 1.2 * Math.sin(time * 2.5) + 0.6 * Math.cos(time * 4.8);
                    const currentSpeed = baseSpeed + speedVariation;

                    // Add occasional direction changes for more dynamic movement
                    if (Math.random() < 0.001) { // Less frequent for smoother flow
                        p.wiperLaserSpeed *= -1;
                    }

                    // Update wiper laser angles with variable speed
                    const adjustedSpeed = p.wiperLaserSpeed * currentSpeed;
                    p.wiperLaser1Angle += adjustedSpeed * dt;
                    p.wiperLaser2Angle += adjustedSpeed * dt;

                    // Normal range limits (Â±135Â°)
                    const normalRange = Math.PI * 0.75;
                    if (p.wiperLaser1Angle > normalRange) {
                        p.wiperLaserSpeed = -Math.abs(p.wiperLaserSpeed);
                    } else if (p.wiperLaser1Angle < -normalRange) {
                        p.wiperLaserSpeed = Math.abs(p.wiperLaserSpeed);
                    }

                    // Keep second laser offset by PI (opposite side)
                    p.wiperLaser2Angle = p.wiperLaser1Angle + Math.PI;

                    // Add subtle motion blur for normal movement
                    if (Math.abs(adjustedSpeed) > 2.0) { // Only blur during fast movement
                        p.wiperLaserBlurTrail.unshift({
                            angle1: p.wiperLaser1Angle,
                            angle2: p.wiperLaser2Angle,
                            life: 0.08,
                            intensity: 0.3
                        });
                    }
                }

                // Update blur trail
                for (let i = p.wiperLaserBlurTrail.length - 1; i >= 0; i--) {
                    p.wiperLaserBlurTrail[i].life -= dt;
                    if (p.wiperLaserBlurTrail[i].life <= 0) {
                        p.wiperLaserBlurTrail.splice(i, 1);
                    }
                }

                // Cap blur trail length
                if (p.wiperLaserBlurTrail.length > 8) {
                    p.wiperLaserBlurTrail.length = 8;
                }

                // Apply damage continuously
                p.wiperLaserDamageTimer -= dt;
                if (p.wiperLaserDamageTimer <= 0) {
                    p.wiperLaserDamageTimer = 0.15; // Damage every 0.15 seconds

                    // Calculate laser endpoints
                    const laserLength = 180; // Fixed laser length - matches visual
                    const laser1EndX = p.x + Math.cos(p.wiperLaser1Angle) * laserLength;
                    const laser1EndY = p.y + Math.sin(p.wiperLaser1Angle) * laserLength;
                    const laser2EndX = p.x + Math.cos(p.wiperLaser2Angle) * laserLength;
                    const laser2EndY = p.y + Math.sin(p.wiperLaser2Angle) * laserLength;

                    // Check for enemies hit by laser beams
                    const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
                    const laserWidth = 20; // Width of laser beam for collision

                    allEnemies.forEach(enemy => {
                        // Check collision with laser 1
                        if (isPointNearLine(enemy.x, enemy.y, p.x, p.y, laser1EndX, laser1EndY, laserWidth)) {
                            let damage = 6 * p.dmgMult; // Base wiper laser damage
                            const hittingBoss = enemy === store.boss;
                            if (hittingBoss) damage *= 0.3; // Reduced damage to boss

                            const wiperVuln = applySubclassVulnerability(enemy, damage, {
                                subclass: p.subclass,
                                player: p,
                                damageTags: ['void', 'magic'],
                                source: 'wiperLaser',
                                baseDamage: damage
                            });
                            damage = wiperVuln.damage;

                            let applied = damage;
                            if (hittingBoss) {
                                const result = applyBossDamage(store.boss, damage, { point: { x: enemy.x, y: enemy.y } });
                                applied = result.amount;
                            } else {
                                enemy.hp -= damage;
                                store.world.totalDamage += damage;
                            }

                            if (p.vampirism > 0 && applied > 0) {
                                let healAmount = applied * p.vampirism;
                                healAmount = Math.max(healAmount, 0.1);
                                healAmount = Math.min(healAmount, 0.4);
                                p.hp = Math.min(p.hpMax, p.hp + healAmount);
                            }
                        }

                        // Check collision with laser 2
                        if (isPointNearLine(enemy.x, enemy.y, p.x, p.y, laser2EndX, laser2EndY, laserWidth)) {
                            let damage = 6 * p.dmgMult; // Base wiper laser damage
                            const hittingBoss = enemy === store.boss;
                            if (hittingBoss) damage *= 0.3; // Reduced damage to boss

                            const wiperVuln = applySubclassVulnerability(enemy, damage, {
                                subclass: p.subclass,
                                player: p,
                                damageTags: ['void', 'magic'],
                                source: 'wiperLaser',
                                baseDamage: damage
                            });
                            damage = wiperVuln.damage;

                            let applied = damage;
                            if (hittingBoss) {
                                const result = applyBossDamage(store.boss, damage, { point: { x: enemy.x, y: enemy.y } });
                                applied = result.amount;
                            } else {
                                enemy.hp -= damage;
                                store.world.totalDamage += damage;
                            }

                            if (p.vampirism > 0 && applied > 0) {
                                let healAmount = applied * p.vampirism;
                                healAmount = Math.max(healAmount, 0.1);
                                healAmount = Math.min(healAmount, 0.4);
                                p.hp = Math.min(p.hpMax, p.hp + healAmount);
                            }
                        }
                    });
                }
            }

            // Helper function to check if a point is near a line segment
            function isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;

                if (lenSq === 0) return Math.sqrt(A * A + B * B) <= threshold;

                let param = dot / lenSq;
                param = Math.max(0, Math.min(1, param));

                const xx = x1 + param * C;
                const yy = y1 + param * D;

                const dx = px - xx;
                const dy = py - yy;

                return Math.sqrt(dx * dx + dy * dy) <= threshold;
            }

            function fireChainLightning() {
                const p = store.player;

                if (p.stormstrikerLevel >= 3) {
                    // Level 3: Fire four simultaneous chain lightning bolts from all positions (Thunder Lord)
                    const positions = [
                        { x: p.x - 25, y: p.y - 15 }, // Far left
                        { x: p.x - 8, y: p.y - 8 },  // Left wing
                        { x: p.x + 8, y: p.y - 8 },  // Right wing  
                        { x: p.x + 25, y: p.y - 15 } // Far right
                    ];

                    // Fire all four bolts simultaneously
                    positions.forEach(pos => {
                        fireChainLightningBolt(1.0, pos);
                    });
                } else if (p.stormstrikerLevel >= 2) {
                    // Level 2: Alternate between left and right wing guns
                    const leftWing = { x: p.x - 18, y: p.y - 8 };
                    const rightWing = { x: p.x + 18, y: p.y - 8 };
                    const position = p.lightningAlternate ? rightWing : leftWing;
                    p.lightningAlternate = !p.lightningAlternate; // Toggle for next shot
                    fireChainLightningBolt(1.0, position);
                } else if (p.hasHybridVoid) {
                    // Fire single lightning bolt (reduced power for hybrid)
                    fireChainLightningBolt(0.7); // 70% damage for hybrid mode
                } else {
                    // Standard single chain lightning from ship center (default stormbringer)
                    fireChainLightningBolt(2.25); // 125% increased damage (1.0 + 1.25 = 2.25x)
                }
            }

            function fireChainLightningBolt(damageMultiplier = 1.0, startPos = null) {
                const p = store.player;
                const playfieldMargin = 50;
                const allEnemies = (store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead))
                    .filter(e => e.x >= -playfieldMargin && e.x <= W + playfieldMargin && 
                                 e.y >= -playfieldMargin && e.y <= H + playfieldMargin);
                if (allEnemies.length === 0) return;

                // Use custom start position or default to center above player
                const startPoint = startPos || { x: p.x, y: p.y - 20 };

                // Find highest priority initial target (Boss > Champion > Highest HP)
                const bosses = allEnemies.filter(e => e.isBoss);
                const champions = allEnemies.filter(e => e.isChampion && !e.isBoss);
                const regular = allEnemies.filter(e => !e.isBoss && !e.isChampion);
                
                let currentTarget = null;
                if (bosses.length > 0) {
                    currentTarget = bosses.sort((a, b) => b.hp - a.hp)[0];
                } else if (champions.length > 0) {
                    currentTarget = champions.sort((a, b) => b.hp - a.hp)[0];
                } else if (regular.length > 0) {
                    currentTarget = regular.sort((a, b) => b.hp - a.hp)[0];
                }

                if (!currentTarget) return;

                const maxJumps = 100; // High limit for unlimited potential with probabilistic limiting
                const chainChance = 0.65; // 65% chance to chain each jump
                let currentDamage = 95 * p.dmgMult * damageMultiplier * (p.chainLightningDamage || 1.0);
                const targetsHit = new Set();
                const chainPoints = [startPoint];
                let chainKillCount = 0;
                const now = performance.now();

                for (let i = 0; i < maxJumps && currentTarget; i++) {
                    targetsHit.add(currentTarget);
                    chainPoints.push({ x: currentTarget.x, y: currentTarget.y });

                    // Create blue lightning flash at hit point
                    store.activeEffects.push(createEffect('lightningFlash', currentTarget.x, currentTarget.y));

                    let dmg = currentDamage;
                    const hittingBoss = currentTarget === store.boss;
                    if (hittingBoss) dmg *= 0.3;
                    const lightningResult = applySubclassVulnerability(currentTarget, dmg, {
                        subclass: store.player.subclass,
                        player: store.player,
                        damageTags: ['lightning', 'magic'],
                        source: 'chainLightning',
                        baseDamage: dmg
                    });
                    dmg = lightningResult.damage;
                    let applied = dmg;
                    const prevHp = currentTarget.hp;
                    if (hittingBoss) {
                        const result = applyBossDamage(store.boss, dmg, { point: { x: currentTarget.x, y: currentTarget.y } });
                        applied = result.amount;
                    } else {
                        currentTarget.hp -= dmg;
                        store.world.totalDamage += dmg;
                    }
                    
                    // Track kills from lightning chain for lightning crack sound
                    if (!hittingBoss && currentTarget.hp <= 0 && prevHp > 0) {
                        chainKillCount++;
                        consecutiveLightningHits++;
                    } else if (currentTarget.hp > 0) {
                        consecutiveLightningHits++;
                    }

                    // Apply vampirism healing for chain lightning damage
                    if (store.player.vampirism > 0) {
                        let healAmount = applied * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for lightning
                        healAmount = Math.min(healAmount, 3); // Cap at 3 HP for lightning
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }

                    // Check if the lightning should chain (50% chance each jump)
                    if (Math.random() >= chainChance) {
                        // Chain failed - stop here
                        break;
                    }

                    // Find next target for chaining
                    let nextTarget = null;
                    let nextDistSq = Infinity;
                    allEnemies.forEach(e => {
                        if (e.dead || targetsHit.has(e)) return;
                        const distSq = (currentTarget.x - e.x) ** 2 + (currentTarget.y - e.y) ** 2;
                        if (distSq < nextDistSq) {
                            nextDistSq = distSq;
                            nextTarget = e;
                        }
                    });

                    // If no valid target found, stop chaining
                    if (!nextTarget) break;

                    currentTarget = nextTarget;
                    currentDamage *= 0.85; // Slightly less decay since we have probabilistic limiting
                }
                
                // LIGHTNING CRACK SOUND - huge multi-hit kill streak
                // Trigger when: 3+ hits in a chain OR 2+ kills in a chain
                if ((consecutiveLightningHits >= 3 || chainKillCount >= 2) && 
                    now - lastLightningCrackTime >= SOUND_COOLDOWNS.lightningCrack) {
                    playSound('lightningCrack');
                    lastLightningCrackTime = now;
                    // Reset the hit counter after sound
                    consecutiveLightningHits = 0;
                }

                if (chainPoints.length > 1) {
                    store.lightningBolts.push({
                        points: chainPoints,
                        life: 0.6, // Increased from 0.4 to let ambient glow persist longer
                        maxLife: 0.6,
                        dead: false
                    });
                }
            }

            const VOIDSTEP = {
                cooldownMs: 2500,
                iframeMs: 450,
                riftMs: 600,
                edgePadding: 6
            };
            let lastVoidStep = -9999;
            let invulUntil = 0;
            const rifts = [];
            const blinkFlashes = [];

            // Ensure the result is never NaN

            function spawnBlinkFlash(x, y, life = 200) { blinkFlashes.push({ x, y, life, birth: performance.now(), dead: false }); }
            function spawnRift(x1, y1, x2, y2, life = VOIDSTEP.riftMs) {
                rifts.push({ x1, y1, x2, y2, birth: performance.now(), life, dead: false });
            }

            function getBlinkUpgradeDamageBonus(player) {
                // Calculate upgrade-based damage bonus for standard enemies
                let bonus = 0;
                
                // Base blink unlocked: starts at 30% (no bonus)
                
                // Enhanced blink: +15%
                if (player.blinkDamageEnhanced) {
                    bonus += 0.15;
                }
                
                // Area damage: +10%
                if (player.blinkAreaDamage) {
                    bonus += 0.10;
                }
                
                // Phasestriker skills: +10%
                if (player.hasPhasestriker) {
                    bonus += 0.10;
                }
                
                // Void laser enhancement: +5%
                if (player.voidLaserEnhanced) {
                    bonus += 0.05;
                }
                
                // Impact phase enhancement: +15%
                if (player.hasImpactPhase) {
                    bonus += 0.15;
                }
                
                return bonus;
            }

            function calculatePercentageBasedBlinkDamage(player, enemy, basePercentage, upgradeBonus) {
                const isBoss = enemy === store.boss || enemy.type === 'void_champion' || enemy.type === 'shadow_champion';
                
                if (!isBoss) {
                    // Standard enemy: 30% base, scales to 85% max with upgrades
                    let damagePercentage = basePercentage;
                    damagePercentage += upgradeBonus;
                    damagePercentage = Math.min(damagePercentage, 0.85);
                    return enemy.hpMax * damagePercentage;
                } else {
                    // Boss: 4% base (no scaling for Voidmancer - they don't get Demolitioner buff)
                    // Voidmancer maintains mobility advantage but consistent boss damage
                    return enemy.hpMax * 0.04;
                }
            }

            function executeBlinkLineDamage(player, start, end, damageMultiplier = 1) {
                if (!player || !player.blinkDamage) return;

                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distSq = dx * dx + dy * dy;
                if (distSq <= 0.001) return;

                const upgradeBonus = getBlinkUpgradeDamageBonus(player);

                store.enemies.forEach(e => {
                    if (e.dead) return;
                    const dot = (((e.x - start.x) * dx) + ((e.y - start.y) * dy)) / distSq;
                    if (dot <= 0 || dot >= 1) return;

                    const closestX = start.x + dot * dx;
                    const closestY = start.y + dot * dy;
                    const distToLine = Math.sqrt((e.x - closestX) ** 2 + (e.y - closestY) ** 2);
                    if (distToLine > e.r + 10) return;

                    // Calculate percentage-based damage
                    let blinkDmg = calculatePercentageBasedBlinkDamage(player, e, 0.30, upgradeBonus);
                    blinkDmg *= damageMultiplier * player.dmgMult;

                    e.hp -= blinkDmg;
                    store.world.totalDamage += blinkDmg;

                    if (player.vampirism > 0) {
                        let healAmount = blinkDmg * player.vampirism;
                        healAmount = Math.max(healAmount, 1);
                        healAmount = Math.min(healAmount, 8);
                        player.hp = Math.min(player.hpMax, player.hp + healAmount);
                    }
                });
            }

            function clampToField(nx, ny) {
                const pad = VOIDSTEP.edgePadding;
                nx = Math.max(pad, Math.min(W - pad, nx));
                ny = Math.max(pad, Math.min(H - pad, ny));
                return { nx, ny };
            }

            function tryVoidStep(player, target, now = performance.now()) {
                const cd = VOIDSTEP.cooldownMs;
                if (now - lastVoidStep < cd) return false;

                const start = { x: player.x, y: player.y };
                let { nx, ny } = clampToField(target.x, target.y);

                if (player.blinkDamage) {
                    executeBlinkLineDamage(player, start, { x: nx, y: ny });
                }

                spawnRift(start.x, start.y, nx, ny, VOIDSTEP.riftMs);

                player.x = nx; player.y = ny;

                if (typeof mouse !== 'undefined' && !document.body.classList.contains('mobile-controls-active')) {
                    mouse.x = nx;
                    mouse.y = ny;
                }
                invulUntil = now + VOIDSTEP.iframeMs;
                lastVoidStep = now;

                // Phasestriker mastery: Time ripple explosion at destination
                if (player.blinkDamageEnhanced) {
                    // Create time ripple explosion effect
                    store.activeEffects.push(createEffect("timeRippleExplosion", nx, ny));

                    // Damage enemies in explosion radius with percentage-based damage
                    const explosionRadius = 80;
                    const upgradeBonus = getBlinkUpgradeDamageBonus(player);
                    const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
                    targets.forEach(e => {
                        if (e.dead) return;
                        const distSq = (e.x - nx) ** 2 + (e.y - ny) ** 2;
                        if (distSq < explosionRadius ** 2) {
                            // Use percentage-based damage for explosion too
                            let explosionDamage = calculatePercentageBasedBlinkDamage(player, e, 0.30, upgradeBonus);
                            explosionDamage *= player.dmgMult * 0.8; // Explosion does 80% of line damage
                            e.hp -= explosionDamage;
                            store.world.totalDamage += explosionDamage;
                        }
                    });
                }

                // Impact shockwave for earthquake enhancement
                if (player.hasImpactPhase) {
                    createImpactShockwave(nx, ny, player.dmgMult);
                }

                spawnBlinkFlash(nx, ny);
                return true;
            }
            function performBlinkSlash(player, bullet, now = performance.now()) {
                const cd = VOIDSTEP.cooldownMs;
                if (player.isBlinkSlashing) return false;
                if (now - lastVoidStep < cd) return false;

                const origin = { x: player.x, y: player.y };

                let dirX = -(bullet?.vx || 0);
                let dirY = -(bullet?.vy || 0);
                if (Math.abs(dirX) < 0.001 && Math.abs(dirY) < 0.001 && bullet) {
                    dirX = bullet.x - origin.x;
                    dirY = bullet.y - origin.y;
                }
                let mag = Math.hypot(dirX, dirY);
                if (mag < 0.001) {
                    dirX = 0;
                    dirY = -1;
                    mag = 1;
                }
                dirX /= mag;
                dirY /= mag;

                const blinkRange = Math.min(player.blinkRange || 250, 320);
                const searchRadius = blinkRange * 1.1;

                const candidates = [];
                store.enemies.forEach(e => {
                    if (e.dead) return;
                    const dx = e.x - origin.x;
                    const dy = e.y - origin.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= searchRadius * searchRadius) {
                        candidates.push({ x: e.x, y: e.y, dist: Math.sqrt(distSq) });
                    }
                });

                candidates.sort((a, b) => a.dist - b.dist);
                const maxTargets = 4;
                const selected = candidates.slice(0, maxTargets);
                for (let i = selected.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [selected[i], selected[j]] = [selected[j], selected[i]];
                }

                const slashPoints = selected.map(candidate => {
                    const offsetAngle = Math.random() * Math.PI * 2;
                    const offsetDist = Math.random() * 35;
                    const tx = candidate.x + Math.cos(offsetAngle) * offsetDist;
                    const ty = candidate.y + Math.sin(offsetAngle) * offsetDist;
                    const clamped = clampToField(tx, ty);
                    return { x: clamped.nx, y: clamped.ny };
                });

                if (!slashPoints.length) {
                    const fallbackCount = 3;
                    for (let i = 0; i < fallbackCount; i++) {
                        const angleVariance = (Math.random() - 0.5) * Math.PI * 0.9;
                        const baseAngle = Math.atan2(dirY, dirX);
                        const angle = baseAngle + angleVariance;
                        const dist = blinkRange * (0.35 + Math.random() * 0.4);
                        const clampPos = clampToField(
                            origin.x + Math.cos(angle) * dist,
                            origin.y + Math.sin(angle) * dist
                        );
                        slashPoints.push({ x: clampPos.nx, y: clampPos.ny });
                    }
                }

                const legDelay = 120;
                const initialDelay = 60;
                const totalDuration = initialDelay + legDelay * (slashPoints.length + 1);

                invulUntil = now + VOIDSTEP.iframeMs + totalDuration;
                lastVoidStep = now;
                player.autoBlinkLastTrigger = now;
                player.isBlinkSlashing = true;
                if (bullet) {
                    bullet.dead = true;
                }

                spawnBlinkFlash(origin.x, origin.y, 320);

                const runSlashStep = (index, currentPos) => {
                    const isReturn = index >= slashPoints.length;
                    const dest = isReturn ? origin : slashPoints[index];
                    const dx = dest.x - currentPos.x;
                    const dy = dest.y - currentPos.y;
                    const hasTravel = Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5;

                    if (hasTravel) {
                        spawnRift(currentPos.x, currentPos.y, dest.x, dest.y, VOIDSTEP.riftMs * 1.5);
                        const damageMultiplier = isReturn
                            ? (slashPoints.length ? 1.1 : 1.0)
                            : (index === 0 ? 1.2 : 1.0);
                        executeBlinkLineDamage(player, currentPos, dest, damageMultiplier);
                    }

                    spawnBlinkFlash(dest.x, dest.y, isReturn ? 340 : 280);
                    player.x = dest.x;
                    player.y = dest.y;

                    if (isReturn) {
                        player.isBlinkSlashing = false;
                        player.autoBlinkLastTrigger = performance.now();
                        invulUntil = performance.now() + VOIDSTEP.iframeMs * 1.2;
                        spawnBlinkFlash(origin.x, origin.y, 360);
                        return;
                    }

                    setTimeout(() => runSlashStep(index + 1, dest), legDelay);
                };

                setTimeout(() => runSlashStep(0, origin), initialDelay);
                return true;
            }

            const AUTO_BLINK_DEFAULT_LOOKAHEAD = 0.45;
            const AUTO_BLINK_MIN_SPEED = 40;

            function attemptAutoBlink(player, bullet, now = performance.now()) {
                if (!player || !bullet) return false;
                if (!player.autoBlinkEnabled || !player.hasBlink) return false;
                if (player.isBlinkSlashing) return false;
                if (store.isPaused || store.isGameOver) return false;
                if (store.boss && !store.boss.dead) return false;
                if (playerIsInvulnerable()) return false;

                const range = player.autoBlinkRange || Math.max(150, (player.blinkRange || 0) * 0.6);
                const dx = player.x - bullet.x;
                const dy = player.y - bullet.y;
                const distSq = dx * dx + dy * dy;
                if (distSq > range * range) return false;

                const vx = bullet.vx || 0;
                const vy = bullet.vy || 0;
                const speedSq = vx * vx + vy * vy;
                if (speedSq < AUTO_BLINK_MIN_SPEED * AUTO_BLINK_MIN_SPEED) return false;

                const dist = Math.sqrt(distSq) || 1;
                const speed = Math.sqrt(speedSq);
                const approach = vx * dx + vy * dy;
                if (approach <= 0) return false; // Bullet moving away or across

                const lookahead = player.autoBlinkLookahead ?? AUTO_BLINK_DEFAULT_LOOKAHEAD;
                if (dist / speed > lookahead) return false; // Too early to react

                if (player.autoBlinkLastTrigger && now - player.autoBlinkLastTrigger < 200) return false;

                return performBlinkSlash(player, bullet, now);
            }

            // Impact shockwave system for earthquake enhancement
            const impactRipples = [];

            function createImpactShockwave(x, y, dmgMult) {
                const shockDamage = 200 * dmgMult;  // High impact damage
                const maxRadius = 120;  // Large earthquake radius

                // Create expanding ripple effect
                impactRipples.push({
                    x: x, y: y,
                    radius: 0,
                    maxRadius: maxRadius,
                    life: 0.8,
                    maxLife: 0.8,
                    birth: performance.now(),
                    dead: false
                });

                // Damage all enemies in impact radius
                store.enemies.forEach(e => {
                    if (e.dead) return;
                    const dist = Math.sqrt((e.x - x) ** 2 + (e.y - y) ** 2);
                    if (dist <= maxRadius) {
                        const damageFalloff = 1.0 - (dist / maxRadius) * 0.3; // 30% falloff at edge
                        const actualDamage = shockDamage * damageFalloff;
                        e.hp -= actualDamage;
                        store.world.totalDamage += actualDamage;

                        // Knockback effect
                        if (dist > 0) {
                            const knockbackForce = 200;
                            const knockbackX = (e.x - x) / dist * knockbackForce;
                            const knockbackY = (e.y - y) / dist * knockbackForce;
                            e.knockback = { x: knockbackX, y: knockbackY, duration: 0.3, timer: 0.3 };
                        }
                    }
                });

                // Damage boss if in range
                if (store.boss && !store.boss.dead) {
                    const dist = Math.sqrt((store.boss.x - x) ** 2 + (store.boss.y - y) ** 2);
                    if (dist <= maxRadius) {
                        const damageFalloff = 1.0 - (dist / maxRadius) * 0.3;
                        const bossDamage = shockDamage * damageFalloff * 0.4;
                        applyBossDamage(store.boss, bossDamage, { point: { x, y } });
                    }
                }
            }

            function updateImpactSystem() {
                const now = performance.now();
                for (const ripple of impactRipples) {
                    if (ripple.dead) continue;

                    const age = (now - ripple.birth) / 1000; // Convert to seconds
                    ripple.radius = (age / ripple.maxLife) * ripple.maxRadius;

                    if (age >= ripple.maxLife) {
                        ripple.dead = true;
                    }
                }

                // Remove dead ripples
                for (let i = impactRipples.length - 1; i >= 0; i--) {
                    if (impactRipples[i].dead) {
                        impactRipples.splice(i, 1);
                    }
                }
            }

            function renderImpactSystem(ctx) {
                for (const ripple of impactRipples) {
                    if (ripple.dead) continue;

                    const now = performance.now();
                    const age = (now - ripple.birth) / 1000;
                    const progress = age / ripple.maxLife;
                    const alpha = 1.0 - progress; // Fade out over time

                    ctx.save();
                    ctx.globalAlpha = alpha * 0.6;
                    ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;  // Yellow earthquake ripples
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner ripple for more impact
                    if (progress < 0.7) {
                        ctx.globalAlpha = alpha * 0.4;
                        ctx.strokeStyle = `rgba(255, 200, 0, ${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(ripple.x, ripple.y, ripple.radius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            function updateVoidStepSystems(enemies) {
                for (const r of rifts) if (!r.dead) {
                    if (performance.now() - r.birth >= r.life) r.dead = true;
                }
                for (const f of blinkFlashes) if (!f.dead) {
                    if (performance.now() - f.birth >= f.life) f.dead = true;
                }
                for (let i = rifts.length - 1; i >= 0; i--) if (rifts[i].dead) rifts.splice(i, 1);
                for (let i = blinkFlashes.length - 1; i >= 0; i--) if (blinkFlashes[i].dead) blinkFlashes.splice(i, 1);
            }

            function renderVoidStepSystems(ctx) {
                rifts.forEach(r => {
                    const t = (performance.now() - r.birth) / r.life;
                    if (t >= 1) { r.dead = true; return; }
                    const a = (1 - t) * 0.8 + 0.2;
                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.strokeStyle = "#ff99cc";
                    ctx.lineWidth = 10 * (1 - t);
                    ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 25 * (1 - t);
                    ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
                    ctx.restore();
                });
                blinkFlashes.forEach(f => {
                    const t = (performance.now() - f.birth) / f.life;
                    if (t >= 1) { f.dead = true; return; }
                    ctx.save();
                    ctx.globalAlpha = 1 - t;
                    ctx.strokeStyle = "#ff99cc";
                    ctx.lineWidth = 4 * (1 - t);
                    ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, 20 + 30 * t, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.globalAlpha = 1 - t * t;
                    ctx.beginPath(); ctx.arc(f.x, f.y, 20 * (1 - t), 0, Math.PI * 2);
                    ctx.fillStyle = "#ffddff"; ctx.fill();
                    ctx.restore();
                });
            }

            function playerIsInvulnerable() { return performance.now() < invulUntil; }

            function screenFlash(count, duration, color) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        store.activeEffects.push(createEffect("screenFlash", 0, duration, color));
                    }, i * (duration / 2));
                }
            }

            // --- PAUSE & MENU LOGIC ---
            const PANELS = ['namePanel', 'pilotPanel', 'scorePanel', 'levelPanel', 'shopPanel', 'storyPanel', 'subclassPanel', 'teleportTutorialPanel', 'championDressingRoom', 'mechForgeMenuPanel', 'characterSheetPanel', 'upgradePopupPanel'];
            function isAnyPanelOpen() {
                return PANELS.some(id => !q(id).classList.contains('hide'));
            }

            function pauseGame() {
                if (!store.isPaused) {
                    store.isPaused = true;
                    q('pauseBtn').classList.add('hide');
                }
            }

            function resumeGame(force = false) {
                // Force resume when closing specific panels, otherwise check if all panels are closed
                if (force || !isAnyPanelOpen()) {
                    clearPanelStack();
                    store.isPaused = false;
                    q('pauseBtn').classList.remove('hide');
                    q('pauseBtn').textContent = 'PAUSE';
                }
            }

            function showUpgradePopup(upgradeInfo) {
                if (!upgradeInfo) return;
                
                const panel = q('upgradePopupPanel');
                const icon = q('upgradePopupIcon');
                const title = q('upgradePopupTitle');
                const desc = q('upgradePopupDesc');
                const tier = q('upgradePopupTier');
                
                if (icon) icon.innerHTML = upgradeInfo.icon || 'âš¡';
                if (title) title.textContent = upgradeInfo.name || 'UPGRADE ACQUIRED';
                if (desc) desc.textContent = upgradeInfo.desc || 'Enhancement applied to your systems.';
                if (tier) {
                    let tierText;
                    let tierColor;
                    if (upgradeInfo.tier === 'bossTier') {
                        tierText = 'BOSS-TIER UPGRADE';
                        tierColor = '#ff6b6b';
                    } else if (upgradeInfo.tier === 'champion') {
                        tierText = 'CHAMPION UPGRADE';
                        tierColor = '#52ffce';
                    } else {
                        tierText = 'MID-TIER UPGRADE';
                        tierColor = '#4ecdc4';
                    }
                    tier.textContent = tierText;
                    tier.style.color = tierColor;
                }
                
                pauseGame();
                panel.classList.remove('hide');
            }

            // --- EVENT LISTENERS & INITIALIZATION ---
            function showPilotSelect() {
                playSound('epicHorn');
                pauseGame();
                const panel = q('pilotPanel');

                panel.classList.remove('hide');
                const cards = panel.querySelectorAll('.skill-card');

                const clickHandler = (e) => {
                    const card = e.currentTarget;
                    const genome = card.dataset.genome;
                    store.player.pilotGenome = genome;
                    panel.classList.add('hide');
                    applyGenomeBonus(genome);

                    // Spend progression point for successful class selection
                    spendProgressionPoint();

                    // Update mobile controls ability button icon
                    updateAbilityButtonIcon();

                    // Resume game for all genomes (removed teleport tutorial popup)
                    resumeGame(true);  // Force resume to avoid panel visibility race condition
                    cards.forEach(c => c.removeEventListener('click', clickHandler));
                };

                cards.forEach(card => {
                    card.addEventListener('click', clickHandler);
                });
            }

            function showTeleportTutorial() {
                const panel = q('teleportTutorialPanel');
                panel.classList.remove('hide');

                // Set up close button handler
                const closeBtn = q('closeTeleportTutorial');
                const closeHandler = () => {
                    panel.classList.add('hide');
                    closeBtn.removeEventListener('click', closeHandler);
                    resumeGame(true);  // Force resume to avoid panel visibility race condition
                };

                closeBtn.addEventListener('click', closeHandler);
            }

            // --- HIT PARTICLE EFFECT ---

            class ImpactParticle {
                constructor(x, y, color, type = 'explosion', scale = 1) {
                    this.x = x;
                    this.y = y;
                    this.color = color || '#ffffff';
                    this.alpha = 1;
                    this.baseSize = randRange(2, 5) * scale;
                    this.fadeRate = 1.8; // Matches original per-frame fade (0.03) at 60 FPS

                    if (type === 'splash') {
                        const angle = randRange(-Math.PI * 0.9, -Math.PI * 0.1);
                        const speed = randRange(3, 7) * 60 * Math.max(0.35, scale);
                        this.vx = Math.cos(angle) * speed;
                        this.vy = Math.sin(angle) * speed;
                        this.gravity = 12 * Math.max(0.35, scale);
                    } else {
                        this.vx = randRange(-2, 2) * 60 * Math.max(0.35, scale);
                        this.vy = randRange(-2, 2) * 60 * Math.max(0.35, scale);
                        this.gravity = 0;
                    }
                }

                update(dt) {
                    this.x += this.vx * dt;
                    this.y += this.vy * dt;
                    if (this.gravity) {
                        this.vy += this.gravity * dt;
                    }
                    this.alpha = Math.max(0, this.alpha - this.fadeRate * dt);
                }

                draw(ctx) {
                    if (this.alpha <= 0) return;
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    const radius = this.baseSize * (0.6 + this.alpha * 0.4);
                    ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            function spawnHitParticles(x, y, color, options = {}) {
                const { count = 18, type = 'explosion', scale = 1 } = options;
                if (!store.hitParticles) store.hitParticles = [];

                const MAX_PARTICLES = 400;
                if (store.hitParticles.length >= MAX_PARTICLES) {
                    const overflow = store.hitParticles.length - MAX_PARTICLES + count;
                    if (overflow > 0) {
                        store.hitParticles.splice(0, overflow);
                    }
                }

                for (let i = 0; i < count; i++) {
                    const jitterX = randRange(-2, 2) * Math.max(0.2, scale);
                    const jitterY = randRange(-2, 2) * Math.max(0.2, scale);
                    store.hitParticles.push(new ImpactParticle(x + jitterX, y + jitterY, color, type, scale));
                }
            }

            function updateHitParticles(dt) {
                if (!store.hitParticles || store.hitParticles.length === 0) return;
                for (let i = store.hitParticles.length - 1; i >= 0; i--) {
                    const particle = store.hitParticles[i];
                    particle.update(dt);
                    if (particle.alpha <= 0) {
                        store.hitParticles.splice(i, 1);
                    }
                }
            }

            function drawHitParticles(ctx) {
                if (!store.hitParticles || store.hitParticles.length === 0) return;
                store.hitParticles.forEach(p => p.draw(ctx));
            }

            // --- GIBBING EFFECT ---

            // Initialize the gibs array in your game's store
            store.gibs = [];
            const MAX_GIBS = 150;

            function isEnemyFrozenForShatter(enemy) {
                if (!enemy || enemy.dead) return false;
                if (enemy.cannotBeFrozen) return false;

                // Bosses can never be frozen (only slowed)
                if (enemy === store.boss || enemy.isBoss) return false;

                const isCubeBurglar = enemy.type === 'cube_burglar';
                const stacks = ensureFiniteNumber(enemy.iceStacks, 0);
                
                // Cube Burglar needs 9 stacks and active freeze timer
                if (isCubeBurglar) {
                    if (stacks < 9) return false;
                    if (!enemy.burglarFreezeTimer || enemy.burglarFreezeTimer <= 0) return false;
                } else {
                    // Regular enemies need 3 stacks
                    if (stacks < 3) return false;
                }

                if (enemy.iceStackTimer !== undefined && enemy.iceStackTimer <= 0) {
                    return false;
                }

                const speedMult = enemy.speedMultiplier;
                if (speedMult !== undefined && Number.isFinite(speedMult) && speedMult > 0.08) {
                    return false;
                }

                return true;
            }

            function spawnIceShards(x, y, options = {}) {
                const {
                    count = 18,
                    baseColor = '#bceeff',
                    accentColor = '#70d4ff',
                    enemyRadius = 18,
                    gravity = 120,
                    minSpeed = 140,
                    maxSpeed = 280,
                    minLife = 0.55,
                    maxLife = 1.05
                } = options;

                // Ice shards are half the size - reduced from original dimensions
                const minLength = options.minLength !== undefined ? options.minLength : Math.max(5, enemyRadius * 0.3);
                const maxLength = options.maxLength !== undefined ? options.maxLength : Math.max(minLength + 3, enemyRadius * 0.9);
                const minThickness = options.minThickness !== undefined ? options.minThickness : 1;
                const maxThickness = options.maxThickness !== undefined ? options.maxThickness : 2.25;

                const shardCount = Math.max(1, Math.floor(count));

                if (store.gibs.length >= MAX_GIBS) {
                    const excessCount = store.gibs.length - MAX_GIBS + shardCount;
                    if (excessCount > 0) {
                        store.gibs.splice(0, excessCount);
                    }
                }

                for (let i = 0; i < shardCount; i++) {
                    const angle = Math.random() * TAU;
                    const speed = randRange(minSpeed, maxSpeed);
                    const life = randRange(minLife, maxLife);
                    const length = randRange(minLength, maxLength);
                    const thickness = randRange(minThickness, maxThickness);

                    store.gibs.push({
                        type: 'iceShard',
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        gravity,
                        life,
                        maxLife: life,
                        color: baseColor,
                        accentColor,
                        length,
                        thickness,
                        rotation: Math.random() * TAU,
                        rotationSpeed: randRange(-8, 8),
                        sparkle: Math.random()
                    });
                }

                if (!Array.isArray(store.activeEffects)) {
                    store.activeEffects = [];
                }

                store.activeEffects.push(createEffect('iceShatter', x, y, enemyRadius, {
                    count: shardCount,
                    baseColor,
                    edgeColor: accentColor
                }));
            }

            function hexToRgb(hex) {
                if (typeof hex !== 'string') return null;
                const cleaned = hex.replace('#', '').trim();
                if (cleaned.length === 3) {
                    const r = parseInt(cleaned[0] + cleaned[0], 16);
                    const g = parseInt(cleaned[1] + cleaned[1], 16);
                    const b = parseInt(cleaned[2] + cleaned[2], 16);
                    if (Number.isNaN(r) || Number.isNaN(g) || Number.isNaN(b)) return null;
                    return { r, g, b };
                }
                if (cleaned.length === 6) {
                    const r = parseInt(cleaned.slice(0, 2), 16);
                    const g = parseInt(cleaned.slice(2, 4), 16);
                    const b = parseInt(cleaned.slice(4, 6), 16);
                    if (Number.isNaN(r) || Number.isNaN(g) || Number.isNaN(b)) return null;
                    return { r, g, b };
                }
                return null;
            }

            function parseColorStop(color, fallbackRgb) {
                const rgb = hexToRgb(color);
                if (rgb) return [rgb.r, rgb.g, rgb.b];
                if (Array.isArray(fallbackRgb) && fallbackRgb.length === 3) {
                    return fallbackRgb;
                }
                return [255, 180, 80];
            }

            function normalizeElementKey(element) {
                if (!element) return null;
                const str = String(element).toLowerCase();
                if (str.startsWith('fire')) return 'fire';
                if (str.startsWith('ice')) return 'ice';
                if (str.startsWith('pois')) return 'poison';
                if (str === 'f') return 'fire';
                if (str === 'i') return 'ice';
                if (str === 'p') return 'poison';
                return null;
            }

            function recordStackElementHit(enemy, element) {
                if (!enemy) return;
                const key = normalizeElementKey(element);
                if (!key) return;
                const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
                enemy.lastStackHitElement = key;
                enemy.lastStackHitTime = now;
                switch (key) {
                    case 'fire':
                        enemy.lastFireStackTime = now;
                        break;
                    case 'ice':
                        enemy.lastIceStackTime = now;
                        break;
                    case 'poison':
                        enemy.lastPoisonStackTime = now;
                        break;
                    default:
                        break;
                }
            }

            function getStackDeathType(enemy, options = {}) {
                if (!enemy) return null;

                const candidates = [];

                if (isEnemyFrozenForShatter(enemy)) {
                    candidates.push('ice');
                }

                const fireStacks = ensureFiniteNumber(enemy.fireStacks, 0);
                if (fireStacks >= 5 && (enemy.fireStackTimer || 0) > 0) { // Increased to 5
                    candidates.push('fire');
                }

                const poisonStacks = ensureFiniteNumber(enemy.poisonStacks, 0);
                if (poisonStacks >= 5 && (enemy.poisonStackTimer || 0) > 0) { // Increased to 5
                    candidates.push('poison');
                }

                if (!candidates.length) return null;
                if (candidates.length === 1) return candidates[0];

                const fallback = normalizeElementKey(options.fallbackElement || enemy.lastStackHitElement || null);
                if (fallback && candidates.includes(fallback)) {
                    return fallback;
                }

                const lastElement = normalizeElementKey(enemy.lastStackHitElement);
                if (lastElement && candidates.includes(lastElement)) {
                    return lastElement;
                }

                const times = {
                    fire: enemy.lastFireStackTime || 0,
                    ice: enemy.lastIceStackTime || 0,
                    poison: enemy.lastPoisonStackTime || 0
                };

                candidates.sort((a, b) => {
                    const timeDiff = (times[b] || 0) - (times[a] || 0);
                    if (timeDiff !== 0) return timeDiff;
                    const stackDiff = ensureFiniteNumber(enemy[`${b}Stacks`], 0) - ensureFiniteNumber(enemy[`${a}Stacks`], 0);
                    if (stackDiff !== 0) return stackDiff;
                    const priority = { ice: 3, fire: 2, poison: 1 };
                    return (priority[b] || 0) - (priority[a] || 0);
                });

                return candidates[0];
            }

            function spawnFireWipeDeath(x, y, options = {}) {
                if (!store) return;
                if (!Array.isArray(store.activeEffects)) {
                    store.activeEffects = [];
                }

                const radius = Math.max(12, Number.isFinite(options.enemyRadius) ? options.enemyRadius : (options.radius || 18));
                const baseColor = options.baseColor || '#ff7c2e';
                const accentColor = options.accentColor || '#ffca55';
                const outlineColor = options.outlineColor || '#ffeecd';
                const duration = Math.max(0.45, options.duration || 0.75);
                const colorStops = [
                    parseColorStop(outlineColor, [255, 238, 205]),
                    parseColorStop(accentColor, [255, 202, 85]),
                    parseColorStop(baseColor, [255, 124, 46])
                ];

                store.activeEffects.push(createEffect('fireWipeDeath', x, y, radius, {
                    duration,
                    seed: Math.random() * Math.PI * 2,
                    colorStops
                }));

                const pseudoTarget = { x, y, r: radius, dead: false };
                spawnLocalizedFireBurn(pseudoTarget, 0.8, {
                    follow: false,
                    radiusScale: 0.7,
                    offsetScale: 0.9
                });
            }

            function spawnPoisonDeath(x, y, options = {}) {
                if (!store) return;
                if (!Array.isArray(store.activeEffects)) {
                    store.activeEffects = [];
                }

                const radius = Math.max(12, Number.isFinite(options.enemyRadius) ? options.enemyRadius : (options.radius || 18));
                const duration = Math.max(0.5, options.duration || 0.85);
                const cloudCount = Math.max(5, Math.min(18, Math.floor(radius * 0.6)));
                for (let i = 0; i < cloudCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const spread = Math.random() * radius * 0.65;
                    const cloudX = x + Math.cos(angle) * spread;
                    const cloudY = y + Math.sin(angle) * spread;
                    const cloudRadius = Math.max(8, radius * (0.35 + Math.random() * 0.4));
                    store.activeEffects.push(createEffect('poisonCloud', cloudX, cloudY, cloudRadius, {
                        duration: duration * (0.75 + Math.random() * 0.35),
                        seed: Math.random() * Math.PI * 2
                    }));
                }
            }

            /**
             * Spawns a cluster of gib particles at a specific location.
             * Call this function when an enemy dies.
             * @param {number} x - The x-coordinate of the enemy.
             * @param {number} y - The y-coordinate of the enemy.
             * @param {string} color - The base color of the enemy.
             * @param {number} [amount=15] - The number of gibs to create.
             */
            function spawnGibs(x, y, color, amount = 12) {
                // If we're at max, remove oldest gibs first
                if (store.gibs.length >= MAX_GIBS) {
                    const excessCount = store.gibs.length - MAX_GIBS + amount;
                    if (excessCount > 0) {
                        store.gibs.splice(0, excessCount);
                    }
                }
                
                for (let i = 0; i < amount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 150;
                    const size = 2 + Math.random() * 4;
                    const life = 0.5 + Math.random() * 0.5;

                    store.gibs.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        r: size,
                        life,
                        maxLife: life,
                        color,
                        gravity: 300, // Pulls gibs downward
                    });
                }
            }

            /**
             * Updates the position and lifetime of all active gibs.
             * This should be called once per frame from your main game loop.
             * @param {number} dt - Delta time, the time since the last frame.
             */
            function updateGibs(dt) {
                for (let i = store.gibs.length - 1; i >= 0; i--) {
                    const gib = store.gibs[i];

                    const gravity = Number.isFinite(gib.gravity) ? gib.gravity : 300;
                    gib.vy += gravity * dt;

                    if (gib.type === 'iceShard') {
                        gib.vx *= 0.985;
                        gib.vy *= 0.985;
                        gib.rotation = (gib.rotation || 0) + (gib.rotationSpeed || 0) * dt;
                    }

                    gib.x += gib.vx * dt;
                    gib.y += gib.vy * dt;
                    gib.life -= dt;

                    if (gib.life <= 0) {
                        store.gibs.splice(i, 1);
                    }
                }
            }

            /**
             * Draws all active gibs to the canvas.
             * This is called from the main render() function.
             * @param {object} ctx - The 2D rendering context of the canvas.
             */
            function drawGibs(ctx) {
                // Only render gibs that are on-screen to prevent overdraw
                const margin = 20;
                store.gibs.forEach(gib => {
                    // Skip off-screen gibs
                    if (gib.x < -margin || gib.x > W + margin || gib.y < -margin || gib.y > H + margin) {
                        return;
                    }
                    
                    const alpha = Math.max(0, gib.life / gib.maxLife); // Fade out effect
                    if (alpha <= 0) return;

                    if (gib.type === 'iceShard') {
                        const length = gib.length || 20;
                        const thickness = gib.thickness || 3;
                        const primaryColor = gib.color || '#bceeff';
                        const highlightColor = gib.accentColor || '#e0f6ff';

                        ctx.save();
                        ctx.translate(gib.x, gib.y);
                        ctx.rotate(gib.rotation || 0);
                        ctx.globalCompositeOperation = 'lighter';
                        ctx.globalAlpha = alpha * 0.9;

                        ctx.fillStyle = primaryColor;
                        ctx.beginPath();
                        ctx.moveTo(-length * 0.5, -thickness * 0.55);
                        ctx.lineTo(length * 0.55, 0);
                        ctx.lineTo(-length * 0.5, thickness * 0.55);
                        ctx.closePath();
                        ctx.fill();

                        ctx.globalAlpha = alpha * 0.55;
                        ctx.fillStyle = highlightColor;
                        ctx.beginPath();
                        ctx.moveTo(-length * 0.2, -thickness * 0.25);
                        ctx.lineTo(length * 0.35, 0);
                        ctx.lineTo(-length * 0.2, thickness * 0.25);
                        ctx.closePath();
                        ctx.fill();

                        ctx.globalAlpha = alpha * 0.4;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(length * 0.1, -thickness * 0.18, length * 0.18, thickness * 0.36);
                        ctx.restore();
                        return;
                    }

                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = gib.color;
                    ctx.beginPath();
                    ctx.fillRect(gib.x - gib.r / 2, gib.y - gib.r / 2, gib.r, gib.r);
                    ctx.restore();
                });
            }

            function applyGenomeBonus(genome) {
                if (!genome) return;

                const p = store.player;
                const preservedMultishot = Number.isFinite(p.multishot) ? p.multishot : 2;
                const preservedRearMultishot = Number.isFinite(p.rearMultishot) ? p.rearMultishot : 0;
                const preservedAddFront = typeof p.addFrontNext === 'boolean' ? p.addFrontNext : true;

                // Reset all potential subclass stats to their defaults
                p.subclass = null;
                p.beefMaxCharges = 1;
                p.missilePierce = 0;
                p.missileCluster = false;
                p.blinkDamage = false;
                resetPlayerLightningState(p);
                p.phasestRikerLevel = 0;
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = null;
                p.hasVoidLaser = false;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                p.isBlinkSlashing = false;

                p.multishot = preservedMultishot;
                p.rearMultishot = preservedRearMultishot;
                p.addFrontNext = preservedAddFront;

                store.world.bossesAtPilotSelection = store.world.bosses;

                switch (genome) {
                    case 'beef':
                        // Base beef no longer gets abilities by default - subclasses must unlock them via skill trees
                        break;
                    case 'voidmancer':
                        // Give +2 multishot base and mild speed boost for base voidmancer
                        p.multishot = preservedMultishot + 2;
                        p.speed = (p.speed || 2.5) * 1.05; // 5% speed boost
                        break;
                    case 'rocketman':
                        // Rocketman no longer auto-gains the frag launcher; keep any previously unlocked state
                        p.hasLauncher = !!p.hasLauncher;
                        break;
                }

                ensurePlayerMultishotIntegrity(p);
            }

            // 5-Node Skill Tree Data Structure + Separate Class Ability - Single focused path per subclass with Omega node
            const SKILL_TREE_DATA = {
                // Each subclass gets a focused 4-node skill tree + separate secondary path with Omega node + class ability (available immediately)
                marauder: {
                    title: 'MARAUDER MASTERY TREE',
                    path: {
                        name: 'MARAUDER PATH',
                        nodes: [
                            { id: 'marauder_multi_charge', name: 'Multi Charge', desc: 'Gain 3 charge attacks with enhanced chain capability', icon: 'mar11.png', tier: 1 },
                            { id: 'marauder_chain_assault', name: 'Chain Assault', desc: 'Keep charge chains active and add +50% chain damage.', icon: 'mar2.png', tier: 2 },
                            { id: 'marauder_combat_mastery', name: 'Combat Mastery', desc: 'Double chain damage bonuses and boost attack speed by 30%.', icon: 'mar3.png', tier: 3 },
                            { id: 'marauder_elite_warrior', name: 'Elite Warrior', desc: 'Unlock 5 charges and elite double-hits that strike for 3x damage.', icon: 'mar4.png', tier: 4 }
                        ]
                    },
                    secondaryPath: {
                        name: 'ADVANCED SYSTEMS',
                        nodes: [
                            { id: 'marauder_omega_burst', name: 'OMEGA BURST', desc: 'Transform multishot into explosive energy orbs that detonate on impact with massive AOE.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' },
                    crossUnlock: { subclass: 'juggernaut', requiredInvestments: 3 },
                    ultimateAbility: { id: 'marauder_clone', name: 'Battle Clone', desc: 'Summon a powerful green clone ally that fights alongside you', icon: 'clone.png', tier: 'ultimate' }
                },
                juggernaut: {
                    title: 'JUGGERNAUT MASTERY TREE',
                    path: {
                        name: 'CHARGE PATH',
                        nodes: [
                            { id: 'juggernaut_charge_power', name: 'Charge Power', desc: '+100% charge damage and knockback, +50% charge range', icon: 'jug1.png', tier: 1 },
                            { id: 'juggernaut_charge_mastery', name: 'Charge Mastery', desc: 'Charge creates damaging shockwave, +2 charge capacity', icon: 'jug22.png', tier: 2 },
                            { id: 'juggernaut_heavy_armor', name: 'Heavy Armor', desc: '+50 HP, 25% damage reduction, knockback immunity', icon: 'jug33.png', tier: 3 },
                            { id: 'juggernaut_unstoppable', name: 'Unstoppable Force', desc: '2.5x explosion radius, 3x damage - devastating impact', icon: 'jug4.png', tier: 4 }
                        ]
                    },
                    secondaryPath: {
                        name: 'ADVANCED SYSTEMS',
                        nodes: [
                            { id: 'juggernaut_omega_hammer', name: 'OMEGA HAMMER', desc: 'Transform multishot into devastating hammer projectiles that shatter on impact with shockwave AOE.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' },
                    crossUnlock: { subclass: 'marauder', requiredInvestments: 3 },
                    ultimateAbility: { id: 'juggernaut_clone', name: 'War Clone', desc: 'Summon a powerful green clone ally that fights alongside you', icon: 'clone.png', tier: 'ultimate' }
                },
                railgunner: {
                    title: 'RAILGUNNER MASTERY TREE',
                    path: {
                        name: 'RAILGUN PATH',
                        nodes: [
                            { id: 'railgunner_super_pierce', name: 'Super Pierce', desc: 'Missiles pierce 5 enemies with +30% pierce damage', icon: 'one.png', tier: 1 },
                            { id: 'railgunner_perfect_aim', name: 'Perfect Aim', desc: '+25% critical hit chance with +50% accuracy', icon: 'two.png', tier: 2 },
                            { id: 'railgunner_advanced_ballistics', name: 'Advanced Ballistics', desc: 'Pierce 8 enemies with +80% velocity and homing', icon: 'three.png', tier: 3 },
                            { id: 'railgunner_precision_master', name: 'Precision Master', desc: '+50% critical chance, 2x crit damage, and full railgun mastery.', icon: 'four.png', tier: 4 }
                        ]
                    },
                    secondaryPath: {
                        name: 'ADVANCED SYSTEMS',
                        nodes: [
                            { id: 'railgunner_omega_lance', name: 'OMEGA LANCE', desc: 'Transform multishot into piercing energy lances that explode in a line on impact.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'firewall_unlock', name: 'FLAME PULSE', desc: 'UNLOCK: Expanding ring of fire that damages and pushes enemies back', icon: 'firewall.png', tier: 'class' },
                    crossUnlock: { subclass: 'demolitioner', requiredInvestments: 3 },
                    ultimateAbility: { id: 'railgunner_stealth_rockets', name: 'Stealth Rockets', desc: 'More badass rockets!', icon: 'badass.png', tier: 'ultimate' }
                },
                demolitioner: {
                    title: 'DEMOLITIONER MASTERY TREE',
                    path: {
                        name: 'CLUSTER PATH',
                        nodes: [
                            { id: 'demolitioner_bigger_clusters', name: 'Bigger Clusters', desc: 'Cluster bombs are 2x larger with increased blast radius', icon: 'demo1.png', tier: 1 },
                            { id: 'demolitioner_cluster_mastery', name: 'Cluster Mastery', desc: 'Clusters split into secondary explosions, +50% cluster count', icon: 'demo2.png', tier: 2 },
                            { id: 'demolitioner_explosive_mastery', name: 'Explosive Mastery', desc: 'Guarantee 12 cluster bombs and chain detonations across explosions.', icon: 'demo3.png', tier: 3 },
                            { id: 'demolitioner_demolition_expert', name: 'Demolition Expert', desc: 'Double cluster blast radius and add a 30% mega explosion chance.', icon: 'demo4.png', tier: 4 }
                        ]
                    },
                    secondaryPath: {
                        name: 'ADVANCED SYSTEMS',
                        nodes: [
                            { id: 'demolitioner_omega_nova', name: 'OMEGA NOVA', desc: 'Transform multishot into unstable nova orbs that create massive chain explosions on impact.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'firewall_unlock', name: 'FLAME PULSE', desc: 'UNLOCK: Expanding ring of fire that damages and pushes enemies back', icon: 'firewall.png', tier: 'class' },
                    crossUnlock: { subclass: 'railgunner', requiredInvestments: 3 },
                    ultimateAbility: { id: 'demolitioner_stealth_rockets', name: 'Stealth Rockets', desc: 'More badass rockets!', icon: 'badass.png', tier: 'ultimate' }
                },
                phasestriker: {
                    title: 'PHASESTRIKER MASTERY TREE',
                    path: {
                        name: 'LASER PATH',
                        nodes: [
                            { id: 'phasestriker_unlimited_range', name: 'Unlimited Range', desc: 'Void laser can target enemies anywhere on screen - no range limitations', icon: 'phase1.png', tier: 1 },
                            { id: 'phasestriker_ramping_power', name: 'Ramping Power', desc: 'Laser increases in size and damage each millisecond on the same target', icon: 'phase2.png', tier: 2 },
                            { id: 'phasestriker_dimensional_control', name: 'Dimensional Control', desc: 'Void laser phases through reality with 2.5x damage', icon: 'phase3.png', tier: 3 },
                            { id: 'phasestriker_double_beam', name: 'Double Long Range Intensifying Beam', desc: 'Fires two parallel beams that intensify over time, dealing massive damage', icon: 'phase4.png', tier: 4 }
                        ]
                    },
                    secondaryPath: {
                        name: 'ADVANCED SYSTEMS',
                        nodes: [
                            { id: 'phasestriker_omega_void', name: 'OMEGA VOID', desc: 'Transform multishot into void discs that implode on impact, creating collapsing singularities.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' },
                    crossUnlock: { subclass: 'stormbringer', requiredInvestments: 3 },
                    ultimateAbility: { id: 'phasestriker_wiper_lasers', name: 'Wiper Lasers', desc: 'Two lasers sweep back and forth like windshield wipers!', icon: 'sweep.png', tier: 'ultimate' }
                },
                stormbringer: {
                    title: 'STORMBRINGER MASTERY TREE',
                    path: {
                        name: 'LIGHTNING PATH',
                        nodes: [
                            { id: 'stormbringer_chain_boost', name: 'Twin Lightning', desc: 'Alternating left/right wing lightning at double fire rate', icon: 'storm1.png', tier: 1 },
                            { id: 'stormbringer_storm_mastery', name: 'Storm Mastery', desc: '+50% jump range and +80% chain lightning damage', icon: 'storm2.png', tier: 2 },
                            { id: 'stormbringer_thunder_lord', name: 'Thunder Lord', desc: '4 simultaneous lightning bolts from all positions - devastating coverage', icon: 'storm3.png', tier: 3 },
                            { id: 'stormbringer_storm_god', name: 'Storm God', desc: '3x lightning damage multiplier - omnipotent electrical dominance', icon: 'storm4.png', tier: 4 }
                        ]
                    },
                    secondaryPath: {
                        name: 'ADVANCED SYSTEMS',
                        nodes: [
                            { id: 'stormbringer_omega_storm', name: 'OMEGA STORM', desc: 'Transform multishot into charged plasma spheres that unleash chain lightning explosions on impact.', icon: 'omega.png', tier: 5, requiresAllPrevious: true }
                        ]
                    },
                    classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' },
                    crossUnlock: { subclass: 'phasestriker', requiredInvestments: 3 },
                    ultimateAbility: { id: 'stormbringer_wiper_lasers', name: 'Wiper Lasers', desc: 'Two lasers sweep back and forth like windshield wipers!', icon: 'sweep.png', tier: 'ultimate' }
                }
            };

            const SUBCLASSES = {
                rocketman: [
                    { id: 'railgunner', name: 'Railgunner', desc: 'Missiles pierce through multiple enemies with devastating precision.', icon: 'rail.png' },
                    { id: 'demolitioner', name: 'Demolitioner', desc: 'Missiles explode into deadly cluster bombs on impact.', icon: 'demo.png' }
                ],
                beef: [
                    { id: 'juggernaut', name: 'juggernaut', desc: 'Charge ability creates a damaging explosion on impact.', icon: 'jug2.png' },
                    { id: 'marauder', name: 'Marauder', desc: 'Gain a second charge for your special ability.', icon: 'marauder.png' }
                ],
                voidmancer: [
                    { id: 'phasestriker', name: 'Phase Striker', desc: 'Basic short-range void laser that can be upgraded for unlimited range and power.', icon: 'phase.png' },
                    { id: 'stormbringer', name: 'Stormbringer', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                ]
            };

            function showSubclassSelect() {
                pauseGame();
                const panel = q('subclassPanel');
                const grid = q('subclassGrid');
                const skillTree = q('skillTree');
                const genome = store.player.pilotGenome;

                if (!panel || !grid) {
                    resumeGame();
                    return;
                }

                // Show traditional card selection for all pilots (including beef)
                const choices = SUBCLASSES[genome];
                if (!choices) {
                    resumeGame();
                    return;
                }
                if (skillTree) {
                    skillTree.classList.add('hide');
                }
                grid.classList.remove('hide');
                panel.classList.remove('skill-tree-active'); // Ensure normal panel size for subclass selection

                grid.innerHTML = choices.map(s => `<div class="skill-card" data-subclass="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');

                grid.querySelectorAll('.skill-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const subclassId = card.dataset.subclass;
                        store.player.subclass = subclassId;
                        applySubclassBonus(subclassId);

                        // Spend progression point for successful subclass selection
                        spendProgressionPoint();

                        // Update mobile controls ability button icon
                        updateAbilityButtonIcon();

                        panel.classList.add('hide');
                        exitPanel('subclassPanel');
                        resumeGame(true);  // Force resume to avoid panel visibility race condition
                    }, { once: true });
                });

                const heading = panel.querySelector('h2');
                if (heading) {
                    heading.style.display = 'block'; // Show h2 for subclass selection
                }
                panel.classList.remove('hide');
            }

            function showProgressiveSkillTree() {
                showSkillTreeModal();
            }

            function showSkillTreeModal(openedFromForge = false) {
                if (!store.player.pilotGenome || store.player.pilotGenome === 'pending') {
                    return;
                }

                const panel = q('subclassPanel');
                if (!panel) {
                    resumeGame();
                    return;
                }

                const grid = q('subclassGrid');
                let skillTree = q('skillTree');

                window.skillTreeOpenedFromForge = openedFromForge;
                window.skillTreePinnedOpen = openedFromForge;
                clearSkillTreeAutoCloseTimers();

                if (!openedFromForge) {
                    playSound('epicHorn');
                }

                pauseGame();

                if (grid) {
                    grid.classList.add('hide');
                }

                if (!skillTree) {
                    skillTree = document.createElement('div');
                    skillTree.id = 'skillTree';
                    panel.appendChild(skillTree);
                } else if (!panel.contains(skillTree)) {
                    panel.appendChild(skillTree);
                }

                skillTree.classList.remove('hide');

                panel.classList.remove('hide');
                panel.classList.add('skill-tree-active');
                panel.classList.add('panel-floating-close');
                panel.scrollTop = 0;
                enterPanel('subclassPanel');

                const heading = panel.querySelector('h2');
                if (heading) {
                    if (!panel.dataset.originalHeading) {
                        panel.dataset.originalHeading = heading.textContent || '';
                    }
                    heading.textContent = 'SPECIALIZATION MASTERY';
                    heading.style.display = 'block';
                }

                generateDynamicSkillTree();

                const closeBtn = q('skillTreeCloseBtn');
                if (closeBtn) closeBtn.onclick = () => closeSkillTree();
                const closeBottomBtn = q('skillTreeCloseBottomBtn');
                if (closeBottomBtn) closeBottomBtn.onclick = () => closeSkillTree();
            }

            function viewCurrentSkillTree() {
                showSkillTreeModal(true);
            }

            function isSkillTreePinnedOpen() {
                return window.skillTreePinnedOpen === true;
            }

            function clearSkillTreeAutoCloseTimers() {
                if (Array.isArray(window.skillTreeAutoCloseTimers)) {
                    window.skillTreeAutoCloseTimers.forEach(id => clearTimeout(id));
                    window.skillTreeAutoCloseTimers.length = 0;
                } else {
                    window.skillTreeAutoCloseTimers = [];
                }
            }

            function scheduleSkillTreeAutoClose(delay) {
                if (isSkillTreePinnedOpen()) {
                    return;
                }
                if (!Array.isArray(window.skillTreeAutoCloseTimers)) {
                    window.skillTreeAutoCloseTimers = [];
                }
                const timerId = setTimeout(() => {
                    if (isSkillTreePinnedOpen()) {
                        return;
                    }
                    clearSkillTreeAutoCloseTimers();
                    closeSkillTree();
                }, ensureFiniteNumber(delay, 0));
                window.skillTreeAutoCloseTimers.push(timerId);
            }



            function generateDynamicSkillTree() {
                const skillTreeElement = q('skillTree');
                const genome = store.player.pilotGenome;

                // Map pilot genome to default subclass for skill tree display
                let subclass = store.player.subclass;
                if (!subclass) {
                    // Default subclass based on genome if none selected
                    switch (genome) {
                        case 'rocketman': subclass = 'railgunner'; break;
                        case 'beef': subclass = 'marauder'; break;
                        case 'voidmancer': subclass = 'phasestriker'; break;
                        default:
                            return;
                    }
                }

                // Get the skill tree data for the current subclass
                const treeData = SKILL_TREE_DATA[subclass];
                if (!treeData) {
                    return;
                }

                const buildSkillCard = (node, options = {}) => {
                    const {
                        tier,
                        parentId,
                        extraClasses = '',
                        note = '',
                        crossSource,
                        crossRequired,
                        imageExtraClass = ''
                    } = options;

                    const escapeAttr = value => String(value).replace(/"/g, '&quot;');

                    const classList = ['skill-icon-button', 'locked'];
                    if (extraClasses) {
                        extraClasses.split(' ').filter(Boolean).forEach(cls => classList.push(cls));
                    }

                    const tierAttr = tier ? ` data-tier="${tier}"` : '';
                    const parentAttr = parentId ? ` data-parent="${parentId}"` : '';
                    const crossSourceAttr = crossSource ? ` data-cross-source="${crossSource}"` : '';
                    const crossRequiredAttr = crossRequired ? ` data-cross-required="${crossRequired}"` : '';
                    const noteAttr = note ? ` data-note="${escapeAttr(note)}"` : '';
                    const titleAttr = node.name ? ` data-title="${escapeAttr(node.name)}"` : '';
                    const imageClass = `skill-icon-image${imageExtraClass ? ` ${imageExtraClass}` : ''}`;
                    const noteHTML = note ? `<div class="skill-info-note">${note}</div>` : '';

                    return `
                        <div class="${classList.join(' ')}" data-skill="${node.id}"${tierAttr}${parentAttr}${crossSourceAttr}${crossRequiredAttr}${noteAttr}${titleAttr}>
                            <div class="skill-icon-frame">
                                <img src="${node.icon}" alt="${node.name}" class="${imageClass}">
                            </div>
                            <div class="skill-info-table">
                                <div class="skill-info-row">
                                    <div class="skill-info-label">Ability</div>
                                    <div class="skill-info-value">${node.name}</div>
                                </div>
                                <div class="skill-info-row">
                                    <div class="skill-info-label">Details</div>
                                    <div class="skill-info-value">${node.desc}</div>
                                </div>
                                ${noteHTML}
                            </div>
                        </div>`;
                };

                const formatTitle = (text) => {
                    if (!text) return '';
                    return text
                        .replace(/_/g, ' ')
                        .toLowerCase()
                        .replace(/\b\w/g, char => char.toUpperCase());
                };

                const path = treeData.path;
                const classAbility = treeData.classAbility;
                const crossDetails = getCrossUnlockNode(treeData);
                let crossSummary = '';
                let crossTitle = '';
                if (crossDetails) {
                    crossTitle = crossDetails.tree.title ? crossDetails.tree.title.replace(' MASTERY TREE', '').trim() : crossDetails.tree.path.name;
                }
                const friendlyCrossTitle = crossTitle ? formatTitle(crossTitle) : '';
                if (friendlyCrossTitle) {
                    crossSummary = ` Unlock your signature ability to cross-train into <strong>${friendlyCrossTitle}</strong>.`;
                }

                const pathCardsHTML = path.nodes.map((node, index) => {
                    const card = buildSkillCard(node, {
                        tier: `${index + 1}`,
                        parentId: index > 0 ? path.nodes[index - 1].id : undefined
                    });
                    const connector = index < path.nodes.length - 1 ? '<div class="skill-track-connector" aria-hidden="true"></div>' : '';
                    return card + connector;
                }).join('');

                const signatureEntries = [];
                if (classAbility) {
                    signatureEntries.push({
                        node: classAbility,
                        options: {
                            tier: 'class',
                            extraClasses: 'class-ability-solo',
                            note: 'Unlock this to access crossover training.',
                            imageExtraClass: 'class-ability'
                        }
                    });
                }
                if (crossDetails) {
                    signatureEntries.push({
                        node: crossDetails.node,
                        options: {
                            tier: 'cross',
                            parentId: classAbility ? classAbility.id : undefined,
                            extraClasses: 'cross-ability',
                            note: 'Unlocks after mastering your signature ability.',
                            crossSource: crossDetails.config.subclass
                        }
                    });
                }
                if (treeData.ultimateAbility) {
                    const ultimateOptions = {
                        tier: 'ultimate',
                        parentId: crossDetails ? crossDetails.node.id : 'cross',
                        extraClasses: 'ultimate-ability',
                        note: crossDetails && friendlyCrossTitle ? `Unlocks once your ${friendlyCrossTitle} crossover is mastered.` : 'Unlocks once crossover training is complete.',
                        crossRequired: 'true'
                    };
                    signatureEntries.push({ node: treeData.ultimateAbility, options: ultimateOptions });
                }

                const signatureCardsHTML = signatureEntries.map((entry, index, arr) => {
                    const card = buildSkillCard(entry.node, entry.options);
                    const connector = index < arr.length - 1 ? '<div class="skill-track-connector" aria-hidden="true"></div>' : '';
                    return card + connector;
                }).join('');

                const subclassTitle = formatTitle(subclass);
                const genomeTitle = formatTitle(store.player.pilotGenome || '') || 'Signature';
                const pathToggleLabel = treeData.toggleLabels?.path || `${subclassTitle} Tree (Main Track)`;
                const signatureToggleLabel = treeData.toggleLabels?.signature || `${genomeTitle} Tree`;

                skillTreeElement.innerHTML = `
            <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
            <div class="skill-tree-title">${treeData.title}</div>
            <div class="skill-view-wrapper">
                <div class="skill-view-toggle" role="group" aria-label="Skill tree view">
                    <button type="button" class="skill-view-btn active" data-view="main">
                        <span class="skill-view-badge" aria-hidden="true">PRIMARY</span>
                        <span class="skill-view-label">${pathToggleLabel}</span>
                    </button>
                    <button type="button" class="skill-view-btn" data-view="signature">
                        <span class="skill-view-badge" aria-hidden="true">SIGNATURE</span>
                        <span class="skill-view-label">${signatureToggleLabel}</span>
                    </button>
                </div>
            </div>
            <div class="skill-grid" data-active-view="main">
                <div class="skill-row">
                    <div class="skill-track view-main">
                        <div class="track-title">${path.name}</div>
                        ${pathCardsHTML}
                    </div>
                    <div class="skill-track class-ability-track view-signature">
                        <div class="track-title" style="color: #FFD700;">SIGNATURE TRAINING</div>
                        ${signatureCardsHTML}
                    </div>
                </div>
            </div>
            <div class="skill-description" id="skillDescription">
                Master your ${subclass} specialization through focused training. Spend progression points to unlock path upgrades and your signature ability.${crossSummary}
            </div>
            <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;

                initializeSkillTreeViewToggle();

                // Initialize skill tree progression
                initializeSkillTree();
            }

            function initializeSkillTreeViewToggle() {
                const skillTreeElement = q('skillTree');
                if (!skillTreeElement) return;

                const grid = skillTreeElement.querySelector('.skill-grid');
                const buttons = skillTreeElement.querySelectorAll('.skill-view-btn');
                if (!grid || buttons.length === 0) return;

                const setActiveView = (view) => {
                    const normalized = view === 'signature' ? 'signature' : 'main';
                    grid.dataset.activeView = normalized;
                    buttons.forEach(btn => {
                        const isActive = btn.dataset.view === normalized;
                        btn.classList.toggle('active', isActive);
                        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                    });
                };

                buttons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        setActiveView(btn.dataset.view);
                    });
                });

                setActiveView('main');
            }

            function getActiveSubclassAndTree() {
                const p = store.player;
                let subclass = p.subclass;

                if (!subclass) {
                    switch (p.pilotGenome) {
                        case 'rocketman':
                            subclass = 'railgunner';
                            break;
                        case 'beef':
                            subclass = 'marauder';
                            break;
                        case 'voidmancer':
                            subclass = 'phasestriker';
                            break;
                        default:
                            return { subclass: null, treeData: null };
                    }
                }

                const treeData = SKILL_TREE_DATA[subclass];
                if (!treeData) {
                    return { subclass: null, treeData: null };
                }

                return { subclass, treeData };
            }

            function getCrossUnlockNode(treeData) {
                if (!treeData || !treeData.crossUnlock) return null;
                const otherTree = SKILL_TREE_DATA[treeData.crossUnlock.subclass];
                if (!otherTree || !otherTree.path || !otherTree.path.nodes || otherTree.path.nodes.length === 0) return null;
                return {
                    config: treeData.crossUnlock,
                    tree: otherTree,
                    node: otherTree.path.nodes[0]
                };
            }

            // Old skill tree code - now commented out as we use dynamic trees
            /*
            function generateOldSkillTree() {
                // Old static skill trees removed - now using SKILL_TREE_DATA structure
            }
                    // Create voidmancer skill tree
                    skillTreeElement.innerHTML = `
                        <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
                        <div class="skill-tree-title">VOIDMANCER SPECIALIZATION TREE</div>
                        <div class="skill-grid">
                            <div class="skill-row">
                                <div class="skill-track">
                                    <div class="track-title">PHASE STRIKER</div>
                                    <div class="skill-icon-button available" data-skill="phasestriker" data-tier="1">
                                        <img src="phase.png" alt="Phase Striker" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">PHASE STRIKER</div>
                                            <div class="skill-overlay-desc">Void manipulation specialist with damaging blink teleportation</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="phasestriker_enhanced" data-tier="2" data-parent="phasestriker">
                                        <img src="phase.png" alt="Ramping Laser" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">RAMPING LASER</div>
                                            <div class="skill-overlay-desc">MASTERY: Laser grows in size and damage while fixated on the same target</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="skill-track">
                                    <div class="track-title">STORMBRINGER</div>
                                    <div class="skill-icon-button available" data-skill="stormbringer" data-tier="1">
                                        <img src="storm.png" alt="Stormbringer" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">STORMBRINGER</div>
                                            <div class="skill-overlay-desc">Lightning manipulation specialist with chain lightning weaponry</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="stormbringer_enhanced" data-tier="2" data-parent="stormbringer">
                                        <img src="storm.png" alt="Chain Storm" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">CHAIN STORM</div>
                                            <div class="skill-overlay-desc">MASTERY: Enhanced stormbringer with maximum chain lightning power</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="skill-track">
                                    <div class="track-title">BLINK ABILITY</div>
                                    <div class="skill-icon-button available" data-skill="blink_ability" data-tier="1">
                                        <img src="blink.png" alt="Blink Ability" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">BLINK ABILITY</div>
                                            <div class="skill-overlay-desc">Mobility specialist with instant teleportation and damage</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="blink_ability_enhanced" data-tier="2" data-parent="blink_ability">
                                        <img src="blink.png" alt="Void Step" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">VOID STEP</div>
                                            <div class="skill-overlay-desc">MASTERY: Enhanced blink with area damage and faster cooldown</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="skill-track">
                                    <div class="track-title">VOID LASER</div>
                                    <div class="skill-icon-button available" data-skill="void_laser" data-tier="1">
                                        <img src="voidlaser.png" alt="Void Laser" class="skill-icon-image">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">VOID LASER</div>
                                            <div class="skill-overlay-desc">Energy weapons specialist with focused beam attacks</div>
                                        </div>
                                    </div>
                                    <div class="skill-icon-button locked" data-skill="void_laser_enhanced" data-tier="2" data-parent="void_laser">
                                        <img src="voidlaser.png" alt="Annihilation Beam" class="skill-icon-image enhanced">
                                        <div class="skill-info-overlay">
                                            <div class="skill-overlay-title">ANNIHILATION BEAM</div>
                                            <div class="skill-overlay-desc">MASTERY: Enhanced void laser with ramping damage and wider beam</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-description" id="skillDescription">
                            Choose your specialization path: Phase Striker for void teleportation, Stormbringer for chain lightning, Blink Ability for mobility, Void Laser for focused damage. Mix and match for powerful combos!
                        </div>
                        <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
                } else {
                    // Fallback for unknown pilot types
                    skillTreeElement.innerHTML = `
                        <button class="close-btn" id="skillTreeCloseBtn" type="button">âœ•</button>
                        <div class="skill-tree-title">UNKNOWN PILOT TYPE</div>
                        <div class="skill-description" id="skillDescription">
                            Skill tree not available for this pilot type.
                        </div>
                        <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
                }
            }
            
            */

            function initializeSkillTree() {
                const p = store.player;
                const { subclass, treeData } = getActiveSubclassAndTree();
                if (!subclass || !treeData) {
                    return;
                }

                // Initialize skill tree properties if needed
                if (!p.skillTree) {
                    p.skillTree = {};
                }

                ensureSkillTrackingLists();
                const learnedSkillSet = new Set(p.learnedSkills || []);

                // Ensure current subclass nodes exist on the player's skill tree map
                treeData.path.nodes.forEach(node => {
                    if (p.skillTree[node.id] === undefined) {
                        p.skillTree[node.id] = false;
                    }
                    if (learnedSkillSet.has(node.id)) {
                        p.skillTree[node.id] = true;
                    }
                });

                if (p.skillTree[treeData.classAbility.id] === undefined) {
                    p.skillTree[treeData.classAbility.id] = false;
                }
                if (learnedSkillSet.has(treeData.classAbility.id)) {
                    p.skillTree[treeData.classAbility.id] = true;
                }

                const crossDetails = getCrossUnlockNode(treeData);
                if (crossDetails && p.skillTree[crossDetails.node.id] === undefined) {
                    p.skillTree[crossDetails.node.id] = false;
                }
                if (crossDetails && learnedSkillSet.has(crossDetails.node.id)) {
                    p.skillTree[crossDetails.node.id] = true;
                }

                if (treeData.ultimateAbility) {
                    const ultimateId = treeData.ultimateAbility.id;
                    if (p.skillTree[ultimateId] === undefined) {
                        p.skillTree[ultimateId] = false;
                    }
                    if (learnedSkillSet.has(ultimateId)) {
                        p.skillTree[ultimateId] = true;
                    }
                }

                if (!p.skillTreeProgress) p.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
                if (typeof p.skillPoints !== 'number') p.skillPoints = 0;
                if (typeof p.skillPointsSpent !== 'number') p.skillPointsSpent = 0;

                // Don't award skill points here - they're awarded in handleBossDefeat
                // Just update the UI with whatever points we have
                updateSkillTreeUI();
                setupSkillTreeHandlers();
            }

            function updateSkillTreeUI() {
                const p = store.player;
                const panel = q('subclassPanel');

                // Early return if skill tree panel is not visible - major performance optimization
                if (!panel || panel.classList.contains('hide') || !panel.classList.contains('skill-tree-active')) {
                    return;
                }

                const iconButtons = document.querySelectorAll('.skill-icon-button');

                // Update button states first, regardless of whether tree will close
                iconButtons.forEach(button => {
                    const skill = button.dataset.skill;
                    const tierRaw = button.dataset.tier;
                    let tier;
                    if (tierRaw === 'class') {
                        tier = 'class';
                    } else if (tierRaw === 'cross') {
                        tier = 'cross';
                    } else if (tierRaw === 'ultimate') {
                        tier = 'ultimate';
                    } else {
                        tier = parseInt(tierRaw, 10);
                    }
                    const parent = button.dataset.parent;

                    // Remove all state classes
                    button.classList.remove('available', 'active', 'locked');

                    if (p.skillTree && p.skillTree[skill]) {
                        // Skill is learned - show active glow effect
                        button.classList.add('active');
                    } else if (canLearnSkill(skill, tier, parent)) {
                        // Skill can be learned - show available state
                        button.classList.add('available');
                    } else {
                        // Skill is locked - show dim state
                        button.classList.add('locked');
                    }
                });

                // Update skill description based on progression state
                const skillDescription = document.getElementById('skillDescription');
                const unspentProgPts = p.unspentProgressionPoints || 0;
                const skillPointsSpent = p.skillPointsSpent || 0;

                const { treeData } = getActiveSubclassAndTree();
                const pathNodes = treeData && Array.isArray(treeData.path?.nodes) ? treeData.path.nodes : [];
                const unlockedPathNodes = pathNodes.filter(node => p.skillTree && p.skillTree[node.id]).length;
                const signatureId = treeData && treeData.classAbility ? treeData.classAbility.id : null;
                const signatureUnlocked = signatureId ? !!(p.skillTree && p.skillTree[signatureId]) : false;
                const crossDetails = treeData ? getCrossUnlockNode(treeData) : null;
                const crossTitle = crossDetails ? (crossDetails.tree.title ? crossDetails.tree.title.replace(' MASTERY TREE', '').trim() : crossDetails.tree.path.name) : '';
                const crossUnlocked = crossDetails ? !!(p.skillTree && p.skillTree[crossDetails.node.id]) : false;
                const ultimateAbility = treeData ? treeData.ultimateAbility : null;
                const ultimateUnlocked = ultimateAbility ? !!(p.skillTree && p.skillTree[ultimateAbility.id]) : false;

                const statusLines = [];
                if (pathNodes.length) {
                    statusLines.push(`<div class="skill-status-line">Path progress: <strong>${unlockedPathNodes}/${pathNodes.length}</strong></div>`);
                }
                if (signatureId) {
                    statusLines.push(`<div class="skill-status-line">Signature ability: <strong>${signatureUnlocked ? 'Unlocked' : 'Locked'}</strong></div>`);
                }
                if (crossDetails) {
                    const crossStateText = crossUnlocked
                        ? `${crossTitle} active`
                        : signatureUnlocked
                            ? `${crossTitle} available`
                            : 'Locked â€” master your signature ability first';
                    statusLines.push(`<div class="skill-status-line">Crossover: <strong>${crossStateText}</strong></div>`);
                }
                if (ultimateAbility) {
                    statusLines.push(`<div class="skill-status-line">Ultimate ability: <strong>${ultimateUnlocked ? 'Ready' : 'Locked'}</strong></div>`);
                }

                if (skillDescription) {
                    const statusMarkup = statusLines.join('');
                    if (unspentProgPts === 0) {
                        skillDescription.innerHTML = `
                    <div class="skill-status-heading readonly">Read-only overview</div>
                    <div class="skill-status-body">Defeat bosses to earn specialization points, then invest them to advance your path.</div>
                    ${statusMarkup}
                    <div class="skill-status-line">Points spent so far: <strong>${skillPointsSpent}</strong></div>
                `;
                    } else {
                        skillDescription.innerHTML = `
                    <div class="skill-status-heading">Progression ready</div>
                    <div class="skill-status-body">You have <strong>${unspentProgPts}</strong> specialization point${unspentProgPts !== 1 ? 's' : ''} awaiting assignment.</div>
                    ${statusMarkup}
                `;
                    }
                    skillDescription.dataset.defaultDescription = skillDescription.innerHTML;
                }

                const availableNodes = Array.from(iconButtons).some(button => button.classList.contains('available'));
                const openedFromMechForge = window.skillTreeOpenedFromForge;
                if (!unspentProgPts && !availableNodes && !openedFromMechForge) {
                    const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
                    scheduleSkillTreeAutoClose(delay);
                    return;
                }

                // If tree is fully capped, also close it
                if (isSkillTreeFullyCapped()) {
                    const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
                    scheduleSkillTreeAutoClose(delay);
                    return;
                }

                // If 4 skill points have been spent, don't auto-close (allow viewing)
                // const skillPointsSpent = p.skillPointsSpent || 0;
                // if (skillPointsSpent >= 4 && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                //     setTimeout(() => {
                //         console.log(`Auto-closing skill tree from updateSkillTreeUI - 4 skill points spent (${skillPointsSpent}/4)`);
                //         closeSkillTree();
                //     }, 100);
                //     return;
                // }
            }

            function canLearnSkill(skill, tier, parent) {
                const p = store.player;

                // Can't learn a skill that's already learned
                if (p.skillTree && p.skillTree[skill]) return false;

                // Initialize progression tracking
                initializeProgressionTracking();

                const totalUnspentPts = p.unspentProgressionPoints || 0;
                const totalSpentPts = p.skillPointsSpent || 0;

                // NEW PROGRESSION SYSTEM:
                if (tier === 'class') {
                    // Signature abilities become available as soon as a progression point is free
                    return totalUnspentPts > 0;
                }

                if (tier === 'cross') {
                    const hasSignatureUnlocked = parent && p.skillTree && p.skillTree[parent];
                    return totalUnspentPts > 0 && !!hasSignatureUnlocked;
                }

                if (tier === 1) {
                    // Tier 1 skills: First unlock once a progression point is available
                    return totalUnspentPts > 0;
                }

                if (tier === 2) {
                    // Tier 2 skills: Need one prior spend and the tier 1 parent
                    return totalUnspentPts > 0 && totalSpentPts >= 1 && p.skillTree && p.skillTree[parent];
                }

                if (tier === 3) {
                    // Tier 3 skills: Need two prior spends and the tier 2 parent
                    return totalUnspentPts > 0 && totalSpentPts >= 2 && p.skillTree && p.skillTree[parent];
                }

                if (tier === 4) {
                    // Tier 4 skills: Need three prior spends and the tier 3 parent
                    return totalUnspentPts > 0 && totalSpentPts >= 3 && p.skillTree && p.skillTree[parent];
                }

                if (tier === 5) {
                    // Tier 5 (Omega) skills: Need ALL previous tier skills (1-4) unlocked from primary path
                    // Omega nodes are in secondaryPath, but require primary path completion
                    const { treeData } = getActiveSubclassAndTree();
                    if (!treeData || !treeData.path || !Array.isArray(treeData.path.nodes)) return false;
                    
                    const requiredNodes = treeData.path.nodes.filter(node => node.tier >= 1 && node.tier <= 4);
                    const allPreviousUnlocked = requiredNodes.every(node => p.skillTree && p.skillTree[node.id]);
                    
                    return totalUnspentPts > 0 && totalSpentPts >= 4 && allPreviousUnlocked;
                }

                if (tier === 'ultimate') {
                    // Ultimate skills: Need the crossover skill (parent) to be unlocked
                    const hasCrossoverUnlocked = parent && p.skillTree && p.skillTree[parent];
                    return totalUnspentPts > 0 && !!hasCrossoverUnlocked;
                }

                return false;
            }

            function setupSkillTreeHandlers() {
                const iconButtons = document.querySelectorAll('.skill-icon-button');
                const description = q('skillDescription');
                if (description) {
                    description.dataset.defaultDescription = description.dataset.defaultDescription || description.innerHTML;
                }

                // Remove any existing handlers first to prevent duplicates
                iconButtons.forEach(button => {
                    button.replaceWith(button.cloneNode(true));
                });

                // Re-query after cloning to get fresh elements
                const freshButtons = document.querySelectorAll('.skill-icon-button');

                // Updated skill descriptions sourced from tree data + key legacy abilities
                const skillDescriptions = {};
                const addSkillDescription = (id, name, desc) => {
                    if (!id || !name || !desc) return;
                    skillDescriptions[id] = { name, desc };
                };

                Object.values(SKILL_TREE_DATA).forEach(treeData => {
                    if (treeData.path && Array.isArray(treeData.path.nodes)) {
                        treeData.path.nodes.forEach(node => {
                            addSkillDescription(node.id, node.name, node.desc);
                        });
                    }
                    if (treeData.secondaryPath && Array.isArray(treeData.secondaryPath.nodes)) {
                        treeData.secondaryPath.nodes.forEach(node => {
                            addSkillDescription(node.id, node.name, node.desc);
                        });
                    }
                    if (treeData.classAbility) {
                        addSkillDescription(treeData.classAbility.id, treeData.classAbility.name, treeData.classAbility.desc);
                    }
                    if (treeData.ultimateAbility) {
                        addSkillDescription(treeData.ultimateAbility.id, treeData.ultimateAbility.name, treeData.ultimateAbility.desc);
                    }
                });

                [
                    { id: 'blink_ability', name: 'Blink Assault', desc: 'Unlocks a damaging blink teleport for rapid repositioning.' },
                    { id: 'blink_ability_enhanced', name: 'Blink Assault+', desc: 'Enhances blink with wider range, area damage, and faster recharge.' },
                    { id: 'void_laser', name: 'Void Laser', desc: 'Activates the void laser beam weapon for precise, sustained damage.' },
                    { id: 'void_laser_enhanced', name: 'Void Laser+', desc: 'Supercharges the void laser with ramping power and a wider beam.' },
                    { id: 'flame_barrier', name: 'Flame Barrier', desc: 'Deploys a protective wall of fire that scorches incoming threats.' },
                    { id: 'flame_barrier_enhanced', name: 'Flame Barrier+', desc: 'Fortifies the flame barrier with explosive retaliation and longer uptime.' },
                    { id: 'missile_volley', name: 'Missile Volley', desc: 'Fires a multi-missile salvo for overwhelming burst damage.' },
                    { id: 'missile_volley_enhanced', name: 'Missile Volley+', desc: 'Maximizes missile volleys with faster reload and additional rockets.' },
                    { id: 'beef_shield', name: 'Beef Shield', desc: 'Activates regenerating armor plating that absorbs incoming damage.' },
                    { id: 'beef_shield_enhanced', name: 'Beef Shield+', desc: 'Improves the beef shield with faster regeneration and reflective plating.' },
                    { id: 'beef_charge', name: 'Beef Charge', desc: 'Unlocks a devastating beef charge rush attack.' },
                    { id: 'beef_charge_enhanced', name: 'Beef Charge+', desc: 'Boosts charge range and impact for unstoppable momentum.' },
                    { id: 'firewall_unlock', name: 'Flame Pulse', desc: 'Unlocks Flame Pulse: expanding fire ring that damages and pushes enemies away.' },
                    { id: 'blink_unlock', name: 'Blink', desc: 'Unlocks the Blink signature ability for instantaneous teleportation.' },
                    { id: 'beef_shield_unlock', name: 'Beef Shield', desc: 'Unlocks the Beef Shield signature ability for defensive fortification.' }
                ].forEach(entry => addSkillDescription(entry.id, entry.name, entry.desc));

                const defaultDescriptionHTML = description ? (description.dataset.defaultDescription || description.innerHTML) : '';

                // Add hover effects to icon buttons
                freshButtons.forEach(button => {
                    const skill = button.dataset.skill;

                    button.addEventListener('mouseenter', () => {
                        if (!description) return;
                        const info = skillDescriptions[skill];
                        const note = button.dataset.note ? `<div class="skill-hover-note">${button.dataset.note}</div>` : '';
                        if (info) {
                            description.innerHTML = `
                        <div class="skill-hover-title">${info.name}</div>
                        <div class="skill-hover-body">${info.desc}</div>
                        ${note}
                    `;
                        } else {
                            const fallbackTitle = button.dataset.title || (button.querySelector('.skill-info-value')?.textContent?.trim() || 'Specialization Node');
                            description.innerHTML = `
                        <div class="skill-hover-title">${fallbackTitle}</div>
                        <div class="skill-hover-body">Review the specialization card for full details.</div>
                        ${note}
                    `;
                        }
                    });

                    button.addEventListener('mouseleave', () => {
                        if (!description) return;
                        const fallback = description.dataset.defaultDescription || defaultDescriptionHTML;
                        if (fallback) {
                            description.innerHTML = fallback;
                        }
                    });
                });

                // Click handlers - icon buttons are directly clickable
                freshButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // Skill button clicked
                        if (button.classList.contains('available')) {
                            const skill = button.dataset.skill;
                            // About to learn skill
                            learnSkill(skill);
                        }
                    });
                });
            }

            let isLearningSkill = false;

            function learnSkill(skill) {
                if (isLearningSkill) {
                    // Already learning a skill, ignoring duplicate call
                    return;
                }

                isLearningSkill = true;

                try {
                    const p = store.player;
                    const skillButton = document.querySelector(`[data-skill="${skill}"]`);
                    if (!skillButton) {
                        isLearningSkill = false;
                        return;
                    }

                    const tierRaw = skillButton.dataset.tier;
                    let tier;
                    if (tierRaw === 'class') {
                        tier = 'class';
                    } else if (tierRaw === 'cross') {
                        tier = 'cross';
                    } else if (tierRaw === 'ultimate') {
                        tier = 'ultimate';
                    } else {
                        tier = parseInt(tierRaw, 10);
                    }
                    const parentId = skillButton.dataset.parent;

                    if (!canLearnSkill(skill, tier, parentId)) {
                        isLearningSkill = false;
                        return;
                    }

                    const spentPoint = spendProgressionPoint();
                    if (!spentPoint) {
                        isLearningSkill = false;
                        return;
                    }

                    if (!p.skillTree) p.skillTree = {};
                    p.skillTree[skill] = true;
                    ensureSkillTrackingLists();
                    if (!p.learnedSkills.includes(skill)) {
                        p.learnedSkills.push(skill);
                    }
                    if (p.skillPoints > 0) {
                        p.skillPoints--;
                    }
                    p.skillPointsSpent = (p.skillPointsSpent || 0) + 1; // Track total spent

                    // Handle signature ability flag for class tier skills
                    if (tier === 'class') {
                        if (!p.signatureAbilities || typeof p.signatureAbilities !== 'object') {
                            p.signatureAbilities = {};
                        }
                        p.signatureAbilities[skill] = true;
                        p.signatureAbility = true;
                    }

                    // Apply the skill effects
                    applySkillBonus(skill);

                    // Check for combo when both base skills are learned
                    // Check for combo when both base skills are learned
                    const pilotType = p.pilotGenome;
                    if (tier === 1) {
                        if (pilotType === 'beef' && p.skillTree.marauder && p.skillTree.juggernaut) {
                            p.beefDoubleCharge = true;
                            announce('DOUBLE CHARGE COMBO ACTIVATED!');
                        } else if (pilotType === 'rocketman' && p.skillTree.railgunner && p.skillTree.demolitioner) {
                            p.rocketmanHybrid = true;
                            announce('HYBRID MISSILES COMBO ACTIVATED!');
                        } else if (pilotType === 'voidmancer' && p.skillTree.phasestriker && p.skillTree.stormbringer) {
                            p.voidmancerHybrid = true;
                            announce('VOID STORM COMBO ACTIVATED!');
                        }
                    }

                    updateSkillTreeUI();

                    // Update remaining skill points display

                    // Check if tree is now fully capped
                    if (isSkillTreeFullyCapped()) {
                        const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                        scheduleSkillTreeAutoClose(delay);
                    } else {
                        // Check if no progression is available
                        const unspentProgPts = p.unspentProgressionPoints || 0;
                        const skillPointsSpent = p.skillPointsSpent || 0;
                        const hasSignature = p.signatureAbility;
                        const canProgress = unspentProgPts > 0 || (!hasSignature && unspentProgPts > 0) || (skillPointsSpent >= 2 && skillPointsSpent < 5);

                        if (!canProgress) {
                            const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                            scheduleSkillTreeAutoClose(delay);
                        }
                    }
                    // Note: No longer auto-closing when 4 skill points are spent - allow viewing
                } catch (error) {
                    // Skill learning error silenced
                } finally {
                    isLearningSkill = false;
                }
            }

            function closeSkillTree() {
                // Clear the flag for Upgrade Hangar opened skill tree
                window.skillTreeOpenedFromForge = false;
                window.skillTreePinnedOpen = false;
                clearSkillTreeAutoCloseTimers();

                const panel = q('subclassPanel');
                if (!panel) {
                    resumeGame();
                    return;
                }

                const skillTree = q('skillTree');
                if (skillTree) {
                    skillTree.classList.add('hide');
                }

                if (panel.dataset && panel.dataset.originalHeading) {
                    const heading = panel.querySelector('h2');
                    if (heading) {
                        heading.textContent = panel.dataset.originalHeading;
                    }
                }

                panel.classList.add('hide');
                panel.classList.remove('skill-tree-active');
                panel.classList.remove('panel-floating-close');
                exitPanel('subclassPanel');
                resumeGame(true);  // Force resume to avoid panel visibility race condition
            }

            function isSkillTreeFullyCapped() {
                const p = store.player;
                const { subclass, treeData } = getActiveSubclassAndTree();

                if (!p.skillTree || !subclass || !treeData) return false;

                const pathNodes = treeData.path.nodes.map(node => node.id);
                const pathComplete = pathNodes.every(skill => p.skillTree[skill] === true);
                if (!pathComplete) return false;

                const crossDetails = getCrossUnlockNode(treeData);
                if (crossDetails && !p.skillTree[crossDetails.node.id]) return false;

                // Check ultimate ability if it exists
                if (treeData.ultimateAbility && !p.skillTree[treeData.ultimateAbility.id]) return false;

                return true;
            }

            function ensurePhasestrikerLoadout(p) {
                let newlyUnlocked = false;

                if (!p.hasPhasestriker) {
                    p.hasPhasestriker = true;
                    newlyUnlocked = true;
                }

                if (!p.hasVoidLaser) {
                    p.hasVoidLaser = true;
                    newlyUnlocked = true;
                }

                if (p.voidLaserTarget === undefined) {
                    p.voidLaserTarget = null;
                }
                if (p.voidLaserDamageTimer === undefined) {
                    p.voidLaserDamageTimer = 0;
                }
                if (p.voidLaserRetargetTimer === undefined) {
                    p.voidLaserRetargetTimer = 0;
                }

                const baseRange = 250;
                if (!p.voidLaserRange || p.voidLaserRange < baseRange) {
                    p.voidLaserRange = baseRange;
                }
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel || 0, 0.5);

                return newlyUnlocked;
            }

            function resetPlayerLightningState(p, { preserveUnlock = false } = {}) {
                if (!p) return;

                if (!preserveUnlock) {
                    p.hasStormbringer = false;
                }

                const keepAbility = preserveUnlock && p.hasStormbringer;
                if (!keepAbility) {
                    p.hasChainLightning = false;
                    p.chainLightningDamage = 1.0;
                    p.stormstrikerLevel = 0;
                    p.chainLightningEnhanced = false;
                    p.hasDoubleStorm = false;
                    p.chainLightningRange = undefined;
                }

                p.chainLightningCooldown = 0;
                p.lightningAlternate = false;
                p.lightningCycleIndex = 0;
            }

            function grantPlayerChainLightning(p, { unlock = false, initialLevel = 1 } = {}) {
                if (!p) return false;

                const wasUnlocked = !!p.hasStormbringer;
                const hadLightning = !!p.hasChainLightning;

                if (unlock) {
                    p.hasStormbringer = true;
                }

                p.hasChainLightning = true;
                if (p.chainLightningCooldown == null) {
                    p.chainLightningCooldown = 0;
                } else if (p.chainLightningCooldown < 0) {
                    p.chainLightningCooldown = 0;
                }

                if (!Number.isFinite(p.chainLightningDamage) || p.chainLightningDamage <= 0) {
                    p.chainLightningDamage = 1.0;
                }

                if (p.stormstrikerLevel == null || p.stormstrikerLevel < initialLevel) {
                    p.stormstrikerLevel = initialLevel;
                }

                p.lightningAlternate = false;
                p.lightningCycleIndex = 0;

                // Play lightning power sound when lightning ability is first upgraded or enhanced
                if (!hadLightning) {
                    playSound('lightningPower');
                }

                return (unlock && !wasUnlocked) || (!hadLightning);
            }

            function ensurePlayerStormbringerLoadout(p) {
                if (!p) return false;
                const wasUnlocked = !!p.hasStormbringer;
                grantPlayerChainLightning(p, { unlock: true, initialLevel: 1 });
                return !wasUnlocked;
            }

            function applySkillBonus(skill) {
                const p = store.player;

                switch (skill) {



                    // Tier 2 Enhanced Skills
                    case 'marauder_enhanced':
                        p.beefMaxCharges = 3;
                        p.beefCharges = Math.max(p.beefCharges, 3);
                        p.beefChainMode = true; // Enable chain jumping for enhanced marauder
                        announce('TRIPLE CHAIN ACTIVATED!');
                        break;
                    case 'juggernaut_enhanced':
                        p.beefBigExplosion = true;
                        announce('BIG BANG EXPLOSION ACTIVATED!');
                        break;



                    // Rocketman Tier 2 Enhanced Skills
                    case 'railgunner_enhanced':
                        // Enhanced railgunner should preserve existing abilities
                        if (!p.missilePierce) p.missilePierce = 2; // Give basic piercing if they don't have it
                        p.missilePierce = Math.max(p.missilePierce, 4);
                        announce('SUPER PIERCE ACTIVATED - Maximum Penetration!');
                        break;
                    case 'demolitioner_enhanced':
                        // Enhanced demolitioner should preserve existing abilities
                        if (!p.missileCluster) p.missileCluster = true; // Give basic clusters if they don't have them
                        p.missileClusterEnhanced = true;
                        announce('MEGA CLUSTERS ACTIVATED - Devastating Explosions!');
                        break;

                    // Voidmancer skills  



                    case 'railgunner_barrier':
                        p.subclass = 'railgunner';
                        // Give flame barrier ability
                        p.flameBarrierActive = false;
                        p.flameBarrierCooldown = 0;
                        p.flameBarrierDuration = 8; // 8 seconds
                        p.flameBarrierRecharge = 15; // 15 second cooldown
                        announce('RAILGUNNER ACTIVATED - Flame Barrier Defense!');
                        break;
                    case 'demolitioner_barrier':
                        p.subclass = 'demolitioner';
                        // Give enhanced flame barrier ability
                        p.flameBarrierActive = false;
                        p.flameBarrierCooldown = 0;
                        p.flameBarrierDuration = 12; // Longer duration than railgunner
                        p.flameBarrierRecharge = 10; // Faster cooldown than railgunner
                        p.flameBarrierExplosive = true; // Explosive reactive damage
                        announce('DEMOLITIONER ACTIVATED - Explosive Flame Wall!');
                        break;

                    // Voidmancer Tier 2 Enhanced Skills
                    case 'phasestriker_enhanced':
                        p.phasestRikerLevel = 2; // Level 2: Global range + ramping damage/size
                        announce('PHASESTRIKER LV2 - Ramping Laser Power!');
                        break;
                    case 'stormbringer_enhanced':
                        p.chainLightningEnhanced = true;
                        p.stormstrikerLevel = 2; // Level 2: Twin wing lightning
                        announce('STORMSTRIKER LV2 - Twin Wing Lightning!');
                        break;

                    // New Beef Skills
                    case 'beef_shield': {
                        p.hasBeefShield = true;
                        const previousTier = Number.isFinite(p.beefShieldTier) ? p.beefShieldTier : 0;
                        const targetTier = previousTier >= 1 ? Math.max(previousTier, 2) : 1;
                        p.beefShieldTier = targetTier;
                        p.beefShieldDamageDealt = 0;
                        p.beefShieldDamageTaken = 0;
                        p.beefShieldCooldown = 0;
                        recomputeBeefShieldCapacity(p, { refill: true });
                        announce('BEEF SHIELD ACTIVATED - Defensive Armor Plating!');
                        break;
                    }
                    case 'beef_shield_enhanced': {
                        p.hasBeefShield = true;
                        const previousTier = Number.isFinite(p.beefShieldTier) ? p.beefShieldTier : 0;
                        p.beefShieldTier = Math.max(previousTier, 3);
                        p.beefShieldDamageDealt = 0;
                        p.beefShieldDamageTaken = 0;
                        p.beefShieldCooldown = 0;
                        recomputeBeefShieldCapacity(p, { refill: true });
                        p.beefShieldReflect = true;
                        announce('FORTRESS MODE ACTIVATED - Enhanced Defense and Reflection!');
                        break;
                    }
                    case 'beef_charge':
                        p.beefChargeState = 'ready';
                        p.beefChargeCooldown = 0;
                        p.beefChargeSpeed = Math.max(p.beefChargeSpeed || 0, 1.35);
                        // Don't reset charges if already have more than 1 (preserve subclass bonuses)
                        if (!p.beefMaxCharges || p.beefMaxCharges < 1) {
                            p.beefCharges = 1;
                            p.beefMaxCharges = 1;
                        }
                        announce('BEEF CHARGE ACTIVATED - Devastating Rush Attack!');
                        break;
                    case 'beef_charge_enhanced':
                        p.beefChargeDamageMultiplier = 1.5; // 50% more charge damage (reduced from 2x)
                        p.beefChargeRange = 1.5; // Increased range
                        announce('RAMMING SPEED ACTIVATED - Enhanced Charge Power!');
                        break;

                    // New Rocketman Skills
                    case 'flame_barrier':
                        p.flameBarrierActive = false;
                        p.flameBarrierCooldown = 0;
                        p.flameBarrierDuration = 8; // 8 seconds
                        p.flameBarrierRecharge = 15; // 15 second cooldown
                        announce('FLAME BARRIER ACTIVATED - Burning Protective Field!');
                        break;
                    case 'flame_barrier_enhanced':
                        p.flameBarrierDuration = 12; // Longer duration
                        p.flameBarrierRecharge = 10; // Faster cooldown
                        p.flameBarrierExplosive = true; // Explosive reactive damage
                        announce('INFERNO WALL ACTIVATED - Explosive Reactive Defense!');
                        break;
                    case 'missile_volley':
                        p.missileVolley = Math.max(p.missileVolley || 2, 4);
                        announce('MISSILE VOLLEY ACTIVATED - Multi-Missile Salvos!');
                        break;
                    case 'missile_volley_enhanced':
                        p.missileVolley = Math.max(p.missileVolley || 4, 6);
                        p.missileReloadBonus = 0.5; // 50% faster reload
                        announce('BARRAGE MODE ACTIVATED - Maximum Firepower!');
                        break;

                    // New Voidmancer Skills  
                    case 'blink_ability':
                        p.blinkDamage = true;
                        p.blinkCooldown = 0;
                        p.blinkRecharge = 3; // 3 second cooldown
                        p.hasBlink = true;
                        p.autoBlinkEnabled = true;
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 160);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.4);
                        p.autoBlinkLastTrigger = 0;
                        announce('BLINK ABILITY ACTIVATED - Damaging Teleportation!');
                        break;
                    case 'blink_ability_enhanced':
                        p.blinkDamageEnhanced = true;
                        p.blinkRecharge = 2; // Faster cooldown
                        p.blinkAreaDamage = true; // Area damage on teleport
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 200);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.5);
                        announce('VOID STEP ACTIVATED - Enhanced Teleportation Power!');
                        break;
                    case 'void_laser': {
                        const unlocked = ensurePhasestrikerLoadout(p);
                        p.voidLaserTarget = null;
                        p.voidLaserDamageTimer = 0;
                        p.voidLaserRetargetTimer = 0;
                        announce(unlocked ? 'VOID LASER CROSS-TRAINED - Focused Beam Online!' : 'VOID LASER ACTIVATED - Focused Beam Weapon!');
                        break;
                    }
                    case 'void_laser_enhanced':
                        ensurePhasestrikerLoadout(p);
                        p.voidLaserEnhanced = true;
                        p.voidLaserRampingDamage = 1.0; // Starts at 1x, builds up
                        p.voidLaserBeamWidth = 2.0; // Wider beam
                        announce('ANNIHILATION BEAM ACTIVATED - Ramping Laser Power!');
                        break;

                    // NEW 5-NODE SKILL TREE SKILLS
                    // Marauder Tree Skills
                    case 'marauder_multi_charge':
                        p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3);
                        p.beefCharges = Math.max(p.beefCharges, 3);
                        announce('MULTI CHARGE ACTIVATED - Additional Charge Attacks!');
                        break;
                    case 'marauder_chain_assault':
                        p.beefChainMode = true;
                        p.beefChainBonus = 1.5; // 50% bonus damage on chain
                        announce('CHAIN ASSAULT ACTIVATED - Chain Between Enemies!');
                        break;
                    case 'marauder_armor_boost':
                        p.hpMax += 25;
                        p.hp += 25;
                        p.damageReduction = (p.damageReduction || 0) + 0.15;
                        announce('BATTLE ARMOR ACTIVATED - Enhanced Durability!');
                        break;
                    case 'marauder_shield_mastery':
                        if (p.beefShieldMax) {
                            p.beefShieldRegenRate = (p.beefShieldRegenRate || 5) * 2;
                            p.beefShieldRegenDelay = Math.max((p.beefShieldRegenDelay || 3) - 1, 1);
                        }
                        announce('SHIELD MASTERY ACTIVATED - Enhanced Shield Regeneration!');
                        break;

                    // Juggernaut Tree Skills
                    case 'juggernaut_charge_power':
                        p.beefChargeDamage = (p.beefChargeDamage || 1.0) * 1.5; // 50% more damage (reduced from 100%)
                        p.beefChargeKnockback = (p.beefChargeKnockback || 1.0) * 2.0; // 100% more knockback
                        p.beefChargeRange = (p.beefChargeRange || 1.0) * 1.5; // 50% more range
                        announce('CHARGE POWER ACTIVATED - Enhanced Charge Strength!');
                        break;
                    case 'juggernaut_charge_mastery':
                        p.beefChargeShockwave = true; // Charge creates damaging shockwave
                        p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3); // +2 charges
                        p.beefCharges = Math.max(p.beefCharges || 0, 3);
                        announce('CHARGE MASTERY ACTIVATED - Shockwave & Extra Charges!');
                        break;
                    case 'juggernaut_speed_boost':
                        p.speedMult *= 1.4;
                        p.beefChargeSpeed = (p.beefChargeSpeed || 1.0) * 1.6;
                        announce('HEAVY MOMENTUM ACTIVATED - Enhanced Speed and Charge!');
                        break;
                    case 'juggernaut_dash_mastery':
                        p.beefKnockbackResistance = true;
                        p.beefChargeCooldown = Math.max((p.beefChargeCooldown || 3) - 1, 1);
                        announce('UNSTOPPABLE FORCE ACTIVATED - Enhanced Mobility!');
                        break;

                    // Railgunner Tree Skills
                    case 'railgunner_super_pierce':
                        p.missilePierce = Math.max(p.missilePierce || 1, 5); // Enhance to 5 enemies (from basic)
                        p.missilePierceDamage = (p.missilePierceDamage || 1.0) * 1.3;
                        announce('SUPER PIERCE ACTIVATED - Enhanced Missile Pierce!');
                        break;
                    case 'railgunner_perfect_aim':
                        p.missileCritChance = (p.missileCritChance || 0) + 0.25;
                        p.missileAccuracy = (p.missileAccuracy || 1.0) * 1.5;
                        announce('PERFECT AIM ACTIVATED - Enhanced Targeting!');
                        break;
                    case 'railgunner_flame_mastery':
                        p.flameBarrierDamage = (p.flameBarrierDamage || 1.0) * 1.8;
                        p.flameBarrierRadius = (p.flameBarrierRadius || 1.0) * 1.4;
                        announce('FLAME MASTERY ACTIVATED - Enhanced Fire Power!');
                        break;
                    case 'railgunner_wall_control':
                        p.flameBarrierCount = (p.flameBarrierCount || 1) + 1;
                        p.flameBarrierDuration *= 1.5;
                        announce('WALL CONTROL ACTIVATED - Advanced Flame Tactics!');
                        break;

                    // Demolitioner Tree Skills
                    case 'demolitioner_bigger_clusters':
                        // Make cluster bombs 2x larger with increased blast radius
                        p.missileClusterSize = (p.missileClusterSize || 1.0) * 2.0;
                        p.missileClusterRadius = (p.missileClusterRadius || 1.0) * 2.0;
                        announce('BIGGER CLUSTERS ACTIVATED - Massive Cluster Bombs!');
                        break;
                    case 'demolitioner_cluster_mastery':
                        // Clusters split into secondary explosions, +50% cluster count
                        p.missileClusterSecondary = true;
                        p.missileClusterCount = Math.max(p.missileClusterCount || 4, Math.floor((p.missileClusterCount || 4) * 1.5));
                        announce('CLUSTER MASTERY ACTIVATED - Secondary Explosions!');
                        break;
                    case 'demolitioner_fire_boost':
                        p.fireDamageBonus = (p.fireDamageBonus || 1.0) * 2.0;
                        p.burnDuration = (p.burnDuration || 3) * 1.5;
                        announce('INFERNO BOOST ACTIVATED - Enhanced Fire Damage!');
                        break;
                    case 'demolitioner_flame_master':
                        p.flameBarrierExplosive = true;
                        p.flameBarrierReactiveDamage = 150;
                        announce('FLAME MASTER ACTIVATED - Explosive Barriers!');
                        break;

                    // Phasestriker Tree Skills
                    case 'phasestriker_unlimited_range': {
                        const unlocked = ensurePhasestrikerLoadout(p);
                        // Remove range limitation from void laser
                        p.voidLaserRange = 999999; // Unlimited range - can hit any enemy
                        p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 1); // Ensure level reflects upgrade
                        announce(unlocked ? 'VOID LASER CROSS-TRAINED - Unlimited Range Achieved!' : 'UNLIMITED RANGE ACTIVATED - Global Laser Targeting!');
                        break;
                    }
                    case 'phasestriker_ramping_power':
                        ensurePhasestrikerLoadout(p);
                        // Enable ramping damage/size effect
                        p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 2); // Level 2: Ramping damage/size
                        announce('RAMPING POWER ACTIVATED - Growing Laser Strength!');
                        break;
                    case 'phasestriker_blink_boost':
                        ensurePhasestrikerLoadout(p);
                        const baseBlinkRange = p.blinkRange || 200;
                        p.blinkRange = baseBlinkRange * 1.8;
                        p.blinkCooldown = Math.max((p.blinkCooldown || 5) - 2, 1);
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, p.blinkRange * 0.7);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.55);
                        announce('BLINK BOOST ACTIVATED - Enhanced Teleportation!');
                        break;
                    case 'phasestriker_phase_mastery':
                        ensurePhasestrikerLoadout(p);
                        p.blinkDamage = (p.blinkDamage || 50) * 1.5; // 50% more damage (reduced from 2x)
                        p.blinkInvulnerable = true; // Brief invulnerability during blink
                        announce('PHASE MASTERY ACTIVATED - Dimensional Superiority!');
                        break;

                    // Stormbringer Tree Skills
                    case 'stormbringer_chain_boost': {
                        const unlocked = ensurePlayerStormbringerLoadout(p);
                        // Add twin lightning bolts from wing guns
                        p.stormstrikerLevel = Math.max(p.stormstrikerLevel, 2); // Twin wing lightning
                        announce(unlocked ? 'CHAIN LIGHTNING CROSS-TRAINED - Twin Lightning Ready!' : 'TWIN LIGHTNING ACTIVATED - Dual Chain Lightning!');
                        break;
                    }
                    case 'stormbringer_storm_mastery':
                        ensurePlayerStormbringerLoadout(p);
                        p.chainLightningDamage = (p.chainLightningDamage || 1.0) * 1.8; // 80% damage boost
                        p.chainLightningRange = (p.chainLightningRange || 150) * 1.5; // 50% jump range boost
                        announce('STORM MASTERY ACTIVATED - Enhanced Range & Power!');
                        break;
                    case 'stormbringer_warp_boost':
                        ensurePlayerStormbringerLoadout(p);
                        if (!p.blinkRange) p.blinkRange = 200;
                        p.blinkRange *= 1.6;
                        p.blinkRecharge = Math.max((p.blinkRecharge || 5) - 1.5, 1);
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, p.blinkRange * 0.65);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.5);
                        announce('WARP BOOST ACTIVATED - Enhanced Teleportation!');
                        break;
                    case 'stormbringer_void_control':
                        ensurePlayerStormbringerLoadout(p);
                        p.blinkTimeRipple = true;
                        p.blinkRippleDamage = 100;
                        announce('VOID CONTROL ACTIVATED - Time Ripple Effects!');
                        break;

                    // NEW TIER 3 & 4 SKILLS FOR SINGLE PATH PROGRESSION
                    // Marauder Advanced Skills
                    case 'marauder_combat_mastery':
                        p.beefChainDamageBonus = (p.beefChainDamageBonus || 1.0) * 2.0;
                        p.beefAttackSpeed = (p.beefAttackSpeed || 1.0) * 1.3;
                        announce('COMBAT MASTERY ACTIVATED - Advanced Assault Techniques!');
                        break;
                    case 'marauder_elite_warrior':
                        p.beefMaxCharges = Math.max(p.beefMaxCharges || 3, 5);
                        p.beefCharges = Math.max(p.beefCharges, 5);
                        p.beefEliteCombat = true;
                        p.marauderDoubleHitBonus = 2.0; // Elite double-hit gives 2x damage (reduced from 3x for balance)
                        announce('ELITE WARRIOR ACTIVATED - Peak Marauder Prowess!');
                        break;
                    case 'marauder_clone':
                        p.hasBeefClone = true;
                        p.juggernautCloneActive = false;
                        store.beefClone = createMirrorClone(p, store.beefClone);
                        announce('BATTLE CLONE ACTIVATED - Green ally summoned!');
                        break;

                    // Juggernaut Advanced Skills
                    case 'juggernaut_heavy_armor':
                        p.hpMax += 50;
                        p.hp += 50;
                        p.damageReduction = (p.damageReduction || 0) + 0.25;
                        p.knockbackImmunity = true;
                        announce('HEAVY ARMOR ACTIVATED - Superior Protection!');
                        break;
                    case 'juggernaut_unstoppable':
                        p.beefExplosionRadius = (p.beefExplosionRadius || 1.0) * 2.5;
                        p.beefExplosionDamage = (p.beefExplosionDamage || 1.0) * 3.0;
                        p.beefUnstoppableForce = true;
                        announce('UNSTOPPABLE FORCE ACTIVATED - Maximum Impact Power!');
                        break;
                    case 'juggernaut_clone':
                        p.hasBeefClone = true;
                        p.juggernautCloneActive = true;
                        activateJuggernautClone(p);
                        announce('WAR CLONE ACTIVATED - Bombing run engaged!');
                        break;

                    // Railgunner Advanced Skills
                    case 'railgunner_advanced_ballistics':
                        p.missilePierce = Math.max(p.missilePierce || 5, 8);
                        p.missileVelocity = (p.missileVelocity || 1.0) * 1.8;
                        p.missileHomingStrength = (p.missileHomingStrength || 0.5) * 1.5;
                        announce('ADVANCED BALLISTICS ACTIVATED - Superior Missile Technology!');
                        break;
                    case 'railgunner_precision_master':
                        p.missileCritChance = (p.missileCritChance || 0.25) + 0.5;
                        p.missileCritDamage = (p.missileCritDamage || 2.0) * 2.0;
                        p.railgunMastery = true;
                        announce('PRECISION MASTER ACTIVATED - Ultimate Accuracy!');
                        break;

                    // Demolitioner Advanced Skills
                    case 'demolitioner_explosive_mastery':
                        p.missileClusterCount = Math.max(p.missileClusterCount || 8, 12);
                        p.explosionChain = true;
                        p.explosionChainCount = 3;
                        announce('EXPLOSIVE MASTERY ACTIVATED - Chain Detonations!');
                        break;
                    case 'demolitioner_demolition_expert':
                        p.missileClusterRadius *= 2.0;
                        p.megaExplosionChance = 0.3; // 30% chance for mega explosions
                        p.demolitionExpert = true;
                        announce('DEMOLITION EXPERT ACTIVATED - Maximum Destructive Force!');
                        break;
                    case 'railgunner_stealth_rockets':
                        p.stealthRockets = true;
                        p.stealthRocketDamage = 1.25; // 25% damage boost
                        p.stealthRocketSpeed = 1.5; // 50% speed boost
                        announce('STEALTH ROCKETS ACTIVATED - Advanced Stealth Technology!');
                        break;
                    case 'demolitioner_stealth_rockets':
                        p.stealthRockets = true;
                        p.stealthRocketDamage = 1.25; // 25% damage boost
                        p.stealthRocketSpeed = 1.5; // 50% speed boost
                        announce('STEALTH ROCKETS ACTIVATED - Advanced Stealth Technology!');
                        break;
                    case 'phasestriker_wiper_lasers':
                        p.wiperLasers = true;
                        p.wiperLaserCount = 2; // Additional wiper lasers
                        playSound('epicHorn'); // Epic activation sound
                        announce('WIPER LASERS ACTIVATED - Sweeping Laser Array!');
                        break;
                    case 'stormbringer_wiper_lasers':
                        p.wiperLasers = true;
                        p.wiperLaserCount = 2; // Additional wiper lasers
                        playSound('epicHorn'); // Epic activation sound
                        announce('WIPER LASERS ACTIVATED - Sweeping Laser Array!');
                        break;

                    // Phasestriker Advanced Skills
                    case 'phasestriker_dimensional_control':
                        p.voidLaserPhase = true;
                        p.voidLaserPhaseDamage = 2.5;
                        p.dimensionalControl = true;
                        announce('DIMENSIONAL CONTROL ACTIVATED - Reality Manipulation!');
                        break;
                    case 'phasestriker_double_beam':
                        // Double Long Range Intensifying Beam - fires two parallel beams with intensifying damage
                        p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 4); // Level 4: Double beam
                        p.doubleBeam = true;
                        p.beamIntensifyRate = 0.1; // 10% damage increase per second of sustained fire
                        p.voidLaserMaxRamp *= 2.0; // Double the ramp potential
                        announce('DOUBLE LONG RANGE INTENSIFYING BEAM!');
                        break;

                    // Stormbringer Advanced Skills  
                    case 'stormbringer_thunder_lord':
                        p.stormstrikerLevel = 3; // 4-bolt lightning storm
                        p.lightningStorm = true;
                        p.thunderLordPower = true;
                        announce('THUNDER LORD ACTIVATED - 4 Simultaneous Bolts!');
                        break;
                    case 'stormbringer_storm_god':
                        p.chainLightningDamage *= 3.0;
                        p.stormGodPower = true;
                        p.omnipotentLightning = true;
                        announce('STORM GOD ACTIVATED - Divine Electrical Mastery!');
                        break;

                    // CLASS ABILITY UNLOCKS (5th node rewards)
                    case 'beef_shield_unlock': {
                        p.hasBeefShield = true;
                        const previousTier = Number.isFinite(p.beefShieldTier) ? p.beefShieldTier : 0;
                        p.beefShieldTier = Math.max(previousTier, 1);
                        p.beefShieldDamageDealt = 0;
                        p.beefShieldDamageTaken = 0;
                        p.beefShieldCooldown = 0;
                        recomputeBeefShieldCapacity(p, { refill: true });
                        playSound('powerup');
                        announce('ðŸ›¡ï¸ BEEF SHIELD UNLOCKED! - Class Ability Activated!');
                        break;
                    }
                    case 'blink_unlock':
                        p.hasBlink = true;
                        p.blinkRange = 250;
                        p.blinkCooldown = 4;
                        p.blinkDamage = 75;
                        p.autoBlinkEnabled = true;
                        p.autoBlinkRange = Math.max(p.autoBlinkRange || 0, 190);
                        p.autoBlinkLookahead = Math.max(p.autoBlinkLookahead || 0, 0.45);
                        p.autoBlinkLastTrigger = 0;
                        p.isBlinkSlashing = false;
                        playSound('powerup');
                        announce('âœ¨ BLINK UNLOCKED! - Class Ability Activated!');
                        break;
                    case 'firewall_unlock':
                        p.hasFirewall = true;
                        p.firewallCooldown = 8; // Base cooldown for flame pulse
                        p.flamePulseCooldownMax = 8;
                        p.flamePulseCooldown = 0;
                        p.shipFlameColor = '#ff7b32';
                        p.shipHighlightColor = '#ffd166';
                        p.flamePulseCharge = 1; // Start ready
                        p.flamePulseInitialized = false;
                        playSound('powerup');
                        announce('ðŸ”¥ FLAME PULSE UNLOCKED! - Expanding fire ring ability!');
                        break;
                }
            }

            function applySubclassBonus(subclass) {
                const p = store.player;
                const preservedMultishot = Number.isFinite(p.multishot) ? p.multishot : 2;
                const preservedRearMultishot = Number.isFinite(p.rearMultishot) ? p.rearMultishot : 0;
                const preservedAddFront = typeof p.addFrontNext === 'boolean' ? p.addFrontNext : true;

                switch (subclass) {
                    case 'railgunner':
                        p.subclass = 'railgunner';
                        p.missilePierce = 2;
                        announce('RAILGUNNER ACTIVATED - Piercing Missiles!');
                        break;
                    case 'demolitioner':
                        p.subclass = 'demolitioner';
                        p.missileCluster = true;
                        announce('DEMOLITIONER ACTIVATED - Cluster Bombs!');
                        break;
                    case 'juggernaut':
                        p.subclass = 'juggernaut';
                        // Give 2 charges (beef shield must be purchased separately via skill tree)
                        p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                        p.beefCharges = Math.max(p.beefCharges, 2);
                        announce('JUGGERNAUT ACTIVATED - Enhanced Charges!');
                        break;
                    case 'marauder':
                        p.subclass = 'marauder';
                        // Give 2 charges and enable chain jumping (beef shield must be purchased separately via skill tree)
                        p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                        p.beefCharges = Math.max(p.beefCharges, 2);
                        p.beefChainMode = true; // Enable chain jumping for marauder
                        p.marauderHitTargets = new Set(); // Initialize double-hit tracking
                        announce('MARAUDER ACTIVATED - Chain Jumping!');
                        break;
                    case 'phasestriker':
                        p.subclass = 'phasestriker';
                        // Give basic SHORT RANGE void laser as first upgrade
                        p.hasVoidLaser = true;
                        p.voidLaserTarget = null;
                        p.voidLaserDamageTimer = 0;
                        p.voidLaserRetargetTimer = 0;
                        p.voidLaserRange = 250; // 25% longer base range
                        p.phasestRikerLevel = 0.5; // Base phasestriker level (between 0 and 1)
                        break;
                    case 'stormbringer':
                        p.subclass = 'stormbringer';
                        // Give basic chain lightning ability
                        grantPlayerChainLightning(p, { initialLevel: 1 });
                        break;
                    case 'voidmancer':
                        p.subclass = 'voidmancer';
                        // Base voidmancer bonus applied during genome selection
                        break;
                }
                store.world.enemyHealthBonus *= 1.10;

                p.multishot = preservedMultishot;
                p.rearMultishot = preservedRearMultishot;
                p.addFrontNext = preservedAddFront;

                ensurePlayerMultishotIntegrity(p);
            }

            function showSpecSelect(isAdditive = false) {
                const p = store.player;
                const genome = p.pilotGenome;

                let choices = [];

                if (genome === 'rocketman') {
                    if (p.subclass === 'demolitioner') {
                        if (isAdditive && p.enhancedClusters) {
                            // If they already have enhanced clusters, double current power
                            choices = [{ id: 'double_clusters', name: 'MEGA CLUSTERS', desc: 'Cluster explosions are twice as large and deal massive damage.', icon: 'demo.png' }];
                        } else if (isAdditive && p.missilePierce > 0) {
                            // If they have railgunner abilities, give them enhanced clusters
                            choices = [{ id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' }];
                        } else {
                            // First spec or missing railgunner - offer both
                            const opts = [
                                { id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' },
                                { id: 'railgunner_pierce', name: 'PIERCING MISSILES', desc: 'Missiles pierce through 3 enemies with devastating force.', icon: 'rail.png' },
                                { id: 'compact_clusters_pierce', name: 'COMPACT PIERCING', desc: 'Smaller clusters but missiles pierce through 2 enemies.', icon: 'rail.png' }
                            ];
                            choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_clusters');
                        }
                    } else if (p.subclass === 'railgunner') {
                        if (isAdditive && p.enhancedPierce) {
                            choices = [{ id: 'mega_pierce', name: 'ULTRA PIERCE', desc: 'Missiles pierce through 6 enemies with increased damage.', icon: 'rail.png' }];
                        } else if (isAdditive && p.enhancedClusters) {
                            choices = [{ id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' }];
                        } else {
                            const opts = [
                                { id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' },
                                { id: 'cluster_missiles', name: 'CLUSTER MISSILES', desc: 'Missiles explode into smaller cluster bombs.', icon: 'demo.png' }
                            ];
                            choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_pierce');
                        }
                    }
                } else if (genome === 'voidmancer') {
                    // Voidmancer only gets the power they don't have
                    if (!p.hasStormbringer && !p.hasPhasestriker) {
                        // First spec - let them choose
                        choices = [
                            { id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' },
                            { id: 'stormbringer', name: 'STORMBRINGER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                        ];
                    } else if (!p.hasStormbringer) {
                        choices = [{ id: 'stormbringer', name: 'STORMBRINGER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }];
                    } else if (!p.hasPhasestriker) {
                        choices = [{ id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' }];
                    } else {
                        // They have both - offer three enhanced void caller options
                        choices = [
                            { id: 'double_storm', name: 'TWIN LIGHTNING', desc: 'Fires two chain lightning bolts instead of one.', icon: 'storm.png' },
                            { id: 'hybrid_void', name: 'VOID STORM', desc: 'Voidstep damages enemies + unlocks single lightning bolt.', icon: 'phase.png' },
                            { id: 'impact_phase', name: 'EARTHQUAKE', desc: 'Voidstep creates a massive impact shockwave at destination.', icon: 'void.png' }
                        ];
                    }
                } else if (genome === 'beef') {
                    // Handle beef subclasses similarly
                    if (p.subclass === 'juggernaut') {
                        choices = [{ id: 'enhanced_juggernaut', name: 'MEGA JUGGERNAUT', desc: 'Massive charge radius and knockback increase.', icon: 'jug2.png' }];
                    } else if (p.subclass === 'marauder') {
                        choices = [{ id: 'enhanced_marauder', name: 'SHIELD MASTER', desc: 'Charge restores even more shields and grants temporary invulnerability.', icon: 'marauder.png' }];
                    }
                }

                // Exit early if no choices available - BEFORE pausing game
                if (!choices.length) {
                    return;
                }

                // Only pause game if we have valid choices to show
                pauseGame();
                const panel = q('subclassPanel'); // Reuse the subclass panel
                const grid = q('subclassGrid');

                const title = isAdditive ? 'ENHANCED SPECIALIZATION' : 'CHOOSE SPECIALIZATION';
                document.querySelector('#subclassPanel h2').textContent = title;

                grid.innerHTML = choices.map(s => `<div class="skill-card" data-spec="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');

                grid.querySelectorAll('.skill-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const specId = card.dataset.spec;
                        applySpecBonus(specId);
                        panel.classList.add('hide');
                        resumeGame(true);  // Force resume to avoid panel visibility race condition
                        document.querySelector('#subclassPanel h2').textContent = 'CHOOSE SPECIALIZATION'; // Reset title
                    }, { once: true });
                });

                panel.classList.remove('hide');
            }

            // DISABLED: applySpecBonus function for stability  
            function applySpecBonus(specId) {
                const p = store.player;

                switch (specId) {
                    case 'enhanced_clusters':
                        p.enhancedClusters = true;
                        announce('ENHANCED CLUSTERS ACTIVATED!');
                        break;
                    case 'double_clusters':
                        // Implement double cluster damage
                        announce('MEGA CLUSTERS ACTIVATED!');
                        break;
                    case 'railgunner_pierce':
                        p.missilePierce = 3;
                        announce('PIERCING MISSILES ACTIVATED!');
                        break;
                    case 'compact_clusters_pierce':
                        p.missilePierce = 2;
                        // Keep clusters small but add pierce
                        announce('COMPACT PIERCING ACTIVATED!');
                        break;
                    case 'enhanced_pierce':
                        p.enhancedPierce = true;
                        p.missilePierce = Math.max(p.missilePierce, 4); // Ensure at least 4 pierce
                        announce('ENHANCED PIERCE ACTIVATED!');
                        break;
                    case 'mega_pierce':
                        p.missilePierce = 6;
                        announce('ULTRA PIERCE ACTIVATED!');
                        break;
                    case 'cluster_missiles':
                        p.missileCluster = true;
                        announce('CLUSTER MISSILES ACTIVATED!');
                        break;
                    case 'phasestriker':
                        p.hasPhasestriker = true;
                        announce('PHASESTRIKER ACTIVATED!');
                        break;
                    case 'stormbringer':
                        grantPlayerChainLightning(p, { unlock: true, initialLevel: 1 });
                        announce('CHAIN LIGHTNING ACTIVATED!');
                        playSound('thunder');
                        break;
                    case 'double_storm':
                        p.hasDoubleStorm = true;
                        announce('TWIN CHAIN LIGHTNING ACTIVATED!');
                        break;
                    case 'hybrid_void':
                        p.hasHybridVoid = true;
                        p.blinkDamage = true;  // Enable voidstep damage
                        announce('VOID STORM ACTIVATED!');
                        break;
                    case 'impact_phase':
                        p.hasImpactPhase = true;
                        p.blinkDamage = true;  // Ensure voidstep does damage
                        announce('EARTHQUAKE ACTIVATED!');
                        break;
                    case 'enhanced_storm':
                        announce('MEGA STORM ACTIVATED!');
                        break;
                    case 'enhanced_phase':
                        announce('VOID MASTERY ACTIVATED!');
                        break;
                    case 'enhanced_juggernaut':
                        announce('MEGA JUGGERNAUT ACTIVATED!');
                        break;
                    case 'enhanced_marauder':
                        announce('SHIELD MASTER ACTIVATED!');
                        break;
                }
            }


            function ensureName() {
                if (!store.name) {
                    pauseGame();
                    const panel = q("namePanel");

                    panel.classList.remove("hide");
                    q("nameInput").value = "";
                    setTimeout(() => q("nameInput").focus(), 50)
                } else {
                    resumeGame();
                    if (store.player.pilotGenome === null) {
                        initWave();
                    }
                }
            }

            q("restartBtn").addEventListener("click", resetGame);

            q("saveName").addEventListener("click", () => { const t = (q("nameInput").value || "").slice(0, 16).trim(); if (t) { store.name = t; q("namePanel").classList.add("hide"); if (store.player.pilotGenome === null) { initWave(); resumeGame(true); } else { resumeGame(true); } } });

            const closeShopLogic = () => {
                const panel = q("shopPanel");
                panel.classList.add('hide');
                exitPanel('shopPanel');
                const highlighted = document.querySelector('.shop-item.highlight');
                if (highlighted) highlighted.classList.remove('highlight');
                const mechForgeBtn = q('shopBtn');
                if (mechForgeBtn) {
                    mechForgeBtn.classList.remove('mech-forge-pulse');
                    if (mechForgeBtn._forgePulseTimeout) {
                        clearTimeout(mechForgeBtn._forgePulseTimeout);
                        mechForgeBtn._forgePulseTimeout = null;
                    }
                }
                if (store.world.mechForgePulseTimeout) {
                    clearTimeout(store.world.mechForgePulseTimeout);
                    store.world.mechForgePulseTimeout = null;
                }
                resumeGame(true);  // Force resume to avoid panel visibility race condition
            };
            q("closeShopTopBtn").addEventListener("click", closeShopLogic);
            q("closeShop").addEventListener("click", closeShopLogic);

            const shopTutorialOpenBtn = q('shopTutorialOpen');
            if (shopTutorialOpenBtn) {
                shopTutorialOpenBtn.addEventListener('click', () => {
                    const disable = q('shopTutorialDontShow');
                    closeShopTutorial({ dismiss: !!(disable && disable.checked), openShop: true });
                });
            }
            const shopTutorialSkipBtn = q('shopTutorialSkip');
            if (shopTutorialSkipBtn) {
                shopTutorialSkipBtn.addEventListener('click', () => {
                    const disable = q('shopTutorialDontShow');
                    closeShopTutorial({ dismiss: !!(disable && disable.checked), openShop: false });
                });
            }

            q("shopBtn").addEventListener("click", () => {
                const shopPanel = q('shopPanel');
                if (shopPanel.classList.contains('hide')) {
                    showShop('upgrades');
                } else {
                    closeShopLogic();
                }
            });

            const closeScoresLogic = () => { q('scorePanel').classList.add('hide'); resumeGame(true); };  // Force resume
            // q("closeScores").addEventListener("click", closeScoresLogic); // Button hidden via CSS

            // Upgrade Hangar menu event listeners
            q("closeMechForgeMenu").addEventListener("click", () => {
                const panel = q("mechForgeMenuPanel");
                panel.classList.add("hide");
                exitPanel('mechForgeMenuPanel');
                resumeGame(true);  // Force resume to avoid panel visibility race condition
            });
            q("closeMechForgeMenuBtn").addEventListener("click", () => {
                const panel = q("mechForgeMenuPanel");
                panel.classList.add("hide");
                exitPanel('mechForgeMenuPanel');
                resumeGame(true);  // Force resume to avoid panel visibility race condition
            });
            const openPrimordialLabBtn = q("openPrimordialLabFromMenu");
            if (openPrimordialLabBtn) {
                openPrimordialLabBtn.addEventListener("click", () => {
                    q("mechForgeMenuPanel").classList.add("hide");

                    setTimeout(() => {
                        const subclassPanel = q("subclassPanel");
                        const pilotPanel = q("pilotPanel");
                        const scorePanel = q("scorePanel");

                        if (subclassPanel && !subclassPanel.classList.contains("hide")) {
                            subclassPanel.classList.add("hide");
                            exitPanel('subclassPanel');
                        }
                        if (pilotPanel && !pilotPanel.classList.contains("hide")) {
                            pilotPanel.classList.add("hide");
                        }
                        if (scorePanel && !scorePanel.classList.contains("hide")) {
                            scorePanel.classList.add("hide");
                        }

                        showPrimordialSoldierLaboratory();
                    }, 50);
                });
            }
            q("openCharacterSheet").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); showCharacterSheet(); });
            q("openSkillTreeReadonly").addEventListener("click", () => { q("mechForgeMenuPanel").classList.add("hide"); showSkillTreeReadonly(); });
            q("openShopTutorial").addEventListener("click", () => {
                q("mechForgeMenuPanel").classList.add("hide");
                showShopTutorial(true, 'Upgrade Hangar alerts refreshed.');
            });

            // Character Sheet event listeners
            q("closeCharacterSheet").addEventListener("click", () => {
                const panel = q("characterSheetPanel");
                panel.classList.add("hide");
                exitPanel('characterSheetPanel');
                resumeGame(true);  // Force resume to avoid panel visibility race condition
            });
            q("closeCharacterSheetBtn").addEventListener("click", () => {
                const panel = q("characterSheetPanel");
                panel.classList.add("hide");
                exitPanel('characterSheetPanel');
                resumeGame(true);  // Force resume to avoid panel visibility race condition
            });

            // Primordial Soldier Laboratory event listeners
            let currentPreviewAnimationType = 'idle';

            if (CHAMPION_SYSTEM_ENABLED) {
                const openChampionBtn = q('openChampionDressingRoom');
                if (openChampionBtn) {
                    openChampionBtn.addEventListener('click', () => {
                        q('shopPanel').classList.add('hide');
                        showPrimordialSoldierLaboratory();
                    });
                }

                const closeDressingRoom = q('closeDressingRoom');
                if (closeDressingRoom) {
                    closeDressingRoom.addEventListener('click', () => {
                        const panel = q('championDressingRoom');
                        panel.classList.add('hide');
                        exitPanel('championDressingRoom');
                        resumeGame(true);  // Force resume to avoid panel visibility race condition
                    });
                }

                const closeDressingRoomBtn = q('closeDressingRoomBtn');
                if (closeDressingRoomBtn) {
                    closeDressingRoomBtn.addEventListener('click', () => {
                        const panel = q('championDressingRoom');
                        panel.classList.add('hide');
                        exitPanel('championDressingRoom');
                        resumeGame(true);  // Force resume to avoid panel visibility race condition
                    });
                }

                const openShopFromDressingRoom = q('openShopFromDressingRoom');
                if (openShopFromDressingRoom) {
                    openShopFromDressingRoom.addEventListener('click', () => {
                        q('championDressingRoom').classList.add('hide');
                        showShop();
                    });
                }

                const attackModuleSelect = q('attackModuleSelect');
                if (attackModuleSelect) {
                    attackModuleSelect.addEventListener('change', () => {
                        const state = getChampionUpgradeState();
                        state.attackModule = attackModuleSelect.value;
                        notifyChampionLoadoutChanged();
                        updateChampionPreview('idle');
                        updateChampionStats();
                        updateChampionBuilderDetails();
                    });
                }

                const cadenceSelect = q('cadenceSelect');
                if (cadenceSelect) {
                    cadenceSelect.addEventListener('change', () => {
                        const state = getChampionUpgradeState();
                        state.cadenceLevel = parseInt(cadenceSelect.value);
                        notifyChampionLoadoutChanged();
                        updateChampionPreview('attack');
                        updateChampionStats();
                        updateChampionBuilderDetails();
                    });
                }

                const protocolSelect = q('protocolSelect');
                if (protocolSelect) {
                    protocolSelect.addEventListener('change', () => {
                        const state = getChampionUpgradeState();
                        state.minionProtocols = parseInt(protocolSelect.value);
                        notifyChampionLoadoutChanged();
                        updateChampionPreview('special');
                        updateChampionStats();
                        updateChampionBuilderDetails();
                    });
                }

                const skinSelect = q('skinSelect');
                if (skinSelect) {
                    skinSelect.addEventListener('change', () => {
                        const state = getChampionUpgradeState();
                        state.skin = skinSelect.value;
                        notifyChampionLoadoutChanged();
                        updateChampionPreview();
                        updateChampionStats();
                        updateChampionBuilderDetails();
                    });
                }

                const applyConfigurationBtn = q('applyConfigurationBtn');
                if (applyConfigurationBtn) {
                    applyConfigurationBtn.addEventListener('click', () => {
                        updateChampionPreview();
                        updateChampionStats();
                        updateChampionBuilderDetails();
                        announce('Champion configuration applied!');
                    });
                }

                const resetConfigurationBtn = q('resetConfigurationBtn');
                if (resetConfigurationBtn) {
                    resetConfigurationBtn.addEventListener('click', () => {
                        populateChampionBuilder();
                        updateChampionPreview();
                        updateChampionStats();
                        updateChampionBuilderDetails();
                        announce('Configuration reset to current settings.');
                    });
                }

                const generateChampionPresetBtn = q('generateChampionPresetBtn');
                if (generateChampionPresetBtn) {
                    generateChampionPresetBtn.addEventListener('click', () => {
                        const preset = captureChampionPreset();
                        if (!preset) {
                            setChampionPresetStatus('Champion data unavailable.', 'error');
                            return;
                        }
                        const code = encodeChampionPresetCode(preset);
                        if (!code) {
                            setChampionPresetStatus('Failed to generate champion code.', 'error');
                            return;
                        }
                        store.lastChampionPresetCode = code;
                        const output = q('championPresetCodeOutput');
                        if (output) {
                            output.value = code;
                            try {
                                output.focus();
                                output.select();
                            } catch (err) { }
                        }
                        const canClipboard = typeof navigator !== 'undefined' && navigator.clipboard && typeof navigator.clipboard.writeText === 'function';
                        if (canClipboard) {
                            navigator.clipboard.writeText(code).then(() => {
                                setChampionPresetStatus('Champion code generated and copied to clipboard.', 'success');
                            }).catch(() => {
                                setChampionPresetStatus('Champion code generated. Copy it manually if needed.', 'success');
                            });
                        } else {
                            setChampionPresetStatus('Champion code generated. Copy it manually if needed.', 'success');
                        }
                    });
                }

                const copyChampionPresetBtn = q('copyChampionPresetBtn');
                if (copyChampionPresetBtn) {
                    copyChampionPresetBtn.addEventListener('click', () => {
                        const output = q('championPresetCodeOutput');
                        const code = (output && output.value ? output.value.trim() : '') || store.lastChampionPresetCode || '';
                        if (!code) {
                            setChampionPresetStatus('Generate a champion code first.', 'error');
                            return;
                        }
                        const canClipboard = typeof navigator !== 'undefined' && navigator.clipboard && typeof navigator.clipboard.writeText === 'function';
                        if (canClipboard) {
                            navigator.clipboard.writeText(code).then(() => {
                                setChampionPresetStatus('Champion code copied to clipboard.', 'success');
                            }).catch(() => {
                                try {
                                    if (output) {
                                        output.focus();
                                        output.select();
                                    }
                                    if (typeof document !== 'undefined' && document.execCommand) {
                                        document.execCommand('copy');
                                        setChampionPresetStatus('Champion code copied to clipboard.', 'success');
                                    } else {
                                        setChampionPresetStatus('Champion code readyâ€”copy manually if needed.', 'success');
                                    }
                                } catch (err) {
                                    setChampionPresetStatus('Unable to access clipboard. Select and copy the code manually.', 'error');
                                }
                            });
                        } else {
                            try {
                                if (output) {
                                    output.focus();
                                    output.select();
                                }
                            } catch (err) { }
                            setChampionPresetStatus('Clipboard unavailable. Select and copy the code manually.', 'error');
                        }
                    });
                }

                const championPresetCodeInput = q('championPresetCodeInput');
                const applyChampionPresetBtn = q('applyChampionPresetBtn');
                if (applyChampionPresetBtn) {
                    applyChampionPresetBtn.addEventListener('click', () => {
                        const code = championPresetCodeInput && championPresetCodeInput.value ? championPresetCodeInput.value.trim() : '';
                        if (!code) {
                            setChampionPresetStatus('Enter a champion code to load.', 'error');
                            return;
                        }
                        const result = loadChampionPresetCode(code, { player: store.player, applyChampion: true });
                        if (!result.success) {
                            setChampionPresetStatus(result.message || 'Failed to apply champion code.', 'error');
                            return;
                        }
                        setChampionPresetStatus('Champion configuration restored from code.', 'success');
                        refreshPrimordialSoldierLaboratory();
                    });
                }

                if (championPresetCodeInput) {
                    championPresetCodeInput.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter') {
                            event.preventDefault();
                            if (applyChampionPresetBtn) {
                                applyChampionPresetBtn.click();
                            }
                        }
                    });
                }
            } else {
                const openChampionBtn = q('openChampionDressingRoom');
                if (openChampionBtn) {
                    openChampionBtn.classList.add('hide');
                }
                const championPanel = q('championDressingRoom');
                if (championPanel) {
                    championPanel.classList.add('hide');
                }
            }

            q("menuBtn").addEventListener("click", () => {
                if (q('scorePanel').classList.contains('hide')) {
                    pauseGame();

                    q('scorePanel').classList.remove('hide');
                } else {
                    closeScoresLogic();
                }
            });

            q("fsEnterBtn").addEventListener('click', () => { const r = document.documentElement; if (!document.fullscreenElement) { if (r.requestFullscreen) r.requestFullscreen(); else if (r.webkitRequestFullscreen) r.webkitRequestFullscreen(); else if (r.msRequestFullscreen) r.msRequestFullscreen() } else { if (document.exitFullscreen) document.exitFullscreen() } });

            q('pauseBtn').addEventListener('click', () => {
                if (store.isGameOver || isAnyPanelOpen()) return;
                store.isPaused = !store.isPaused;
                q('pauseBtn').textContent = store.isPaused ? 'RESUME' : 'PAUSE';
            });

            // EMP charges now auto-activate on proximity, no manual button

            /* Commented out for future implementation
            q('storyBtn').addEventListener('click', (e) => {
                e.stopPropagation();
                pauseGame();
                
                q('storyPanel').classList.remove('hide');
            });
            q('storyPanel').addEventListener('click', () => {
                q('storyPanel').classList.add('hide');
                if (!q('pilotPanel').classList.contains('hide')) {
                } else {
                    resumeGame();
                }
            });
            */

            q("nameInput").addEventListener("keydown", (e) => { if (e.key === "Enter") { const t = (q("nameInput").value || "").slice(0, 16).trim(); if (t) { store.name = t; q("namePanel").classList.add("hide"); if (store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); } } } });

            q("namePanel").addEventListener("click", (e) => {
                if (e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
                    q('nameInput').blur();
                }
            });

            let cheatCodeBuffer = "";
            let cheatTapCount = 0;
            let lastCheatTap = 0;

            function activateDamageOffCheat() {
                if (store.isDamageOff) return;
                store.isDamageOff = true;
                store.cheatsUsed = true;
                announce('CHEAT: DAMAGE & ABILITIES OFF');

                const p = store.player;
                const propsToDisable = [
                    'dmgMult', 'multishot', 'rearMultishot', 'piercing', 'explosive',
                    'flamethrowerLevel', 'missileVolley', 'critChance', 'critDamage',
                    'hasLauncher', 'hasHounds', 'hasLazarusBeam', 'hasVoidBeam',
                    'hasChainLightning', 'hasIceman', 'hasBeefClone', 'blinkDamage', 'missilePierce', 'missileCluster',
                    'hasDoubleStorm', 'hasHybridVoid', 'hasImpactPhase'
                ];

                store.savedPlayerState = {};
                propsToDisable.forEach(prop => {
                    store.savedPlayerState[prop] = p[prop];
                    if (typeof p[prop] === 'number') {
                        p[prop] = 0;
                    } else if (typeof p[prop] === 'boolean') {
                        p[prop] = false;
                    }
                });

                store.savedPlayerState.hounds = store.hounds;
                store.hounds = [];
                store.savedPlayerState.iceman = store.iceman;
                store.iceman = null;
                store.savedPlayerState.beefClone = store.beefClone;
                store.beefClone = null;
                store.savedPlayerState.escortDrones = store.escortDrones;
                store.escortDrones = [];
                store.savedPlayerState.playerChampion = store.playerChampion;
                if (store.playerChampion) {
                    store.playerChampion.currentTarget = null;
                    store.playerChampion._lastTargetSeen = 0;
                }
                store.savedPlayerState.championMinions = store.championMinions;
                if (Array.isArray(store.championMinions)) {
                    store.championMinions.forEach(minion => {
                        if (!minion) return;
                        minion.currentTarget = null;
                        minion._lastTargetSeen = 0;
                    });
                }
                store.playerChampion = null;
                store.championMinions = [];
            }

            function deactivateDamageOffCheat() {
                if (!store.isDamageOff || !store.savedPlayerState) return;
                store.isDamageOff = false;
                announce('CHEAT: DAMAGE & ABILITIES ON');

                const p = store.player;
                for (const prop in store.savedPlayerState) {
                    if (prop === 'hounds') {
                        store.hounds = store.savedPlayerState.hounds;
                    } else if (prop === 'iceman') {
                        store.iceman = store.savedPlayerState.iceman;
                    } else if (prop === 'beefClone') {
                        store.beefClone = store.savedPlayerState.beefClone;
                    } else if (prop === 'escortDrones') {
                        store.escortDrones = store.savedPlayerState.escortDrones;
                    } else if (prop === 'playerChampion') {
                        store.playerChampion = store.savedPlayerState.playerChampion || null;
                        if (store.playerChampion) {
                            store.playerChampion.state = null;
                            store.playerChampion.dashTimer = 0;
                            store.playerChampion.dashVX = 0;
                            store.playerChampion.dashVY = 0;
                            store.playerChampion.dashHits = null;
                            store.playerChampion.dashCooldownTimer = Math.max(0, store.playerChampion.dashCooldownTimer || 0);
                            store.playerChampion.currentTarget = null;
                            store.playerChampion._lastTargetSeen = 0;
                            store.playerChampion.fireTimer = Math.max(0, store.playerChampion.fireTimer || 0);
                        }
                    } else if (prop === 'championMinions') {
                        const savedMinions = store.savedPlayerState.championMinions;
                        store.championMinions = Array.isArray(savedMinions) ? savedMinions : [];
                        if (store.playerChampion && store.championMinions.length) {
                            store.championMinions.forEach(minion => {
                                if (!minion) return;
                                minion.dead = false;
                                minion.fireTimer = Math.max(0, minion.fireTimer || 0);
                                minion.currentTarget = null;
                                minion._lastTargetSeen = 0;
                            });
                        }
                    } else if (p.hasOwnProperty(prop)) {
                        p[prop] = store.savedPlayerState[prop];
                    }
                }

                store.savedPlayerState = null;
            }

            function activateSubclassCheat() {
                if (!store.player.pilotGenome) {
                    announce("CHEAT FAILED: Choose a Pilot first.");
                    return;
                }
                if (store.player.subclass) {
                    announce("CHEAT FAILED: Subclass already chosen.");
                    return;
                }

                store.cheatsUsed = true;
                announce('CHEAT: SKIPPING TO SUBCLASS SELECT');
                showSubclassSelect();
            }

            function activateClassCheat() {
                store.cheatsUsed = true;
                announce('CHEAT: SKIPPING TO CLASS SELECT');
                showPilotSelect();
            }

            const CHAMPION_CHEAT_ROTATIONS = Object.freeze([
                { attack: 'ember', skin: 'solstice', label: 'Solar Brand + Solstice' },
                { attack: 'tempest', skin: 'tempest', label: 'Tempest Lattice + Tempest' },
                { attack: 'void', skin: 'umbra', label: 'Umbral Resonance + Umbral' }
            ]);

            function activateChampionCheat() {
                if (!store || !store.player || !store.world) {
                    announce("CHEAT FAILED: Start a run first.");
                    cheatCodeBuffer = "";
                    return;
                }

                store.cheatsUsed = true;
                const player = store.player;
                const upgrades = ensureChampionUpgradeState(player);

                if (typeof store.championCheatIndex !== 'number') {
                    store.championCheatIndex = 0;
                }
                const rotation = CHAMPION_CHEAT_ROTATIONS[store.championCheatIndex % CHAMPION_CHEAT_ROTATIONS.length];
                store.championCheatIndex = (store.championCheatIndex + 1) % CHAMPION_CHEAT_ROTATIONS.length;

                upgrades.unlockedAttacks.ember = true;
                upgrades.unlockedAttacks.tempest = true;
                upgrades.unlockedAttacks.void = true;
                upgrades.attackModule = rotation.attack;
                upgrades.cadenceLevel = CHAMPION_CADENCE_LEVELS.length - 1;
                upgrades.minionProtocols = CHAMPION_MINION_PROTOCOL_LEVELS.length - 1;
                if (!upgrades.unlockedSkins || typeof upgrades.unlockedSkins !== 'object') {
                    upgrades.unlockedSkins = {};
                }
                CHAMPION_SKIN_OPTIONS.forEach(opt => upgrades.unlockedSkins[opt.id] = true);
                upgrades.skin = rotation.skin;

                player.championUnlocked = true;

                let champion = store.playerChampion;
                if (!champion || champion.dead) {
                    grantChampionCompanion();
                    champion = store.playerChampion;
                }

                if (!champion) {
                    announce("CHEAT FAILED: Champion unavailable.");
                    cheatCodeBuffer = "";
                    return;
                }

                champion.dead = false;
                champion.x = clamp(player.x, 60, W - 60);
                champion.y = clamp(player.y - 90, 80, H - 120);
                champion.roamAnchor = null;
                champion.state = null;
                champion.dashCooldownTimer = 0;

                const targetLevel = PLAYER_CHAMPION_CONFIG.maxLevel || 5;
                const levelDelta = Math.max(0, targetLevel - 1);
                champion.level = targetLevel;
                champion.damageScale = 1 + (targetLevel - 1) * 0.25;
                champion.fireCooldownBase = Math.max(0.6, PLAYER_CHAMPION_CONFIG.baseFireCooldown * Math.pow(0.9, levelDelta));
                champion.dashCooldownBase = Math.max(1.5, PLAYER_CHAMPION_CONFIG.baseDashCooldown * Math.pow(0.92, levelDelta));
                champion.momentumBase = Math.min(6.2, 4.1 + 0.25 * levelDelta);
                champion.momentum = champion.momentumBase;
                champion.guardRadiusBase = PLAYER_CHAMPION_CONFIG.baseGuardRadius + targetLevel * 6;
                champion.guardRadius = champion.guardRadiusBase;
                champion.angularSpeedBase = PLAYER_CHAMPION_CONFIG.baseAngularSpeed + (targetLevel - 1) * 0.08;
                champion.angularSpeed = champion.angularSpeedBase;
                champion.volleySize = Math.min(7, 4 + targetLevel);
                champion.volleySpread = Math.min(0.22, 0.16 + (targetLevel - 1) * 0.015);
                champion.specialAbilityCooldown = 0;
                champion.echoCooldown = 0;

                applyChampionUpgradeLoadout(champion, { refreshMinions: true });

                ensureChampionCollections();
                store.championMinions.length = 0;
                for (let i = 0; i < PLAYER_CHAMPION_CONFIG.maxMinions; i++) {
                    spawnChampionMinion(champion);
                }
                refreshChampionMinionsFromState(champion);

                champion.fireTimer = Math.max(0.05, (champion.fireCooldown || PLAYER_CHAMPION_CONFIG.baseFireCooldown) * 0.15);
                champion.dashCooldown = Math.max(0.6, champion.dashCooldownBase * (CHAMPION_CADENCE_LEVELS[upgrades.cadenceLevel]?.dashCooldownMult || 1));

                setWorldGold(Math.max(getWorldGold(), 600));

                announce(`CHEAT: Champion test loadout (${rotation.label}) online!`);
                playSound('epicHorn');

                cheatCodeBuffer = "";
            }

            function activatePowerCheat() {
                store.cheatsUsed = true;
                announce('CHEAT: POWER UP!');
                resetGame();
                setWorldGold(100000);
                store.player.multishot = 4;
                initWave();
                cheatCodeBuffer = "";
            }
            
            function activateBossCheat() {
                store.cheatsUsed = true;
                
                // Clear enemies
                store.enemies = [];
                
                // Get VIBEMASTER definition directly
                const vibemasterDef = RAW_BOSS_DEFINITIONS.vibemaster;
                const scale = 1;
                let hp = vibemasterDef.baseHp * scale * store.world.bossHealthBonus;
                
                // Create VIBEMASTER boss
                const boss = {
                    ...vibemasterDef,
                    key: 'vibemaster',
                    themeKey: 'vibemaster',
                    x: W / 2,
                    y: -80,
                    hpMax: hp,
                    hp,
                    t: 0,
                    fireT: 0,
                    moveT: 0,
                    vx: 100,
                    vy: 30,
                    patternPhase: 0,
                    isEnraged: false,
                    attackPhase: 0,
                    phaseTimer: 0,
                    dashTimer: 0,
                    dashTrailCooldown: 0,
                    rainEvent: null,
                    phase: 0,
                    isLaughing: false,
                    laughStartTime: 0,
                    visible: true
                };
                
                const instanceSuffix = Math.random().toString(36).slice(2, 8);
                boss.instanceId = `boss-cheat-${Date.now().toString(36)}-${instanceSuffix}`;
                boss._instanceId = boss.instanceId;
                boss.spawnWave = store.world.wave;
                boss.spawnedAt = performance.now();
                
                store.boss = boss;
                applyBossTheme(boss);
                
                announce('CHEAT: VIBEMASTER SPAWNED!');
                cheatCodeBuffer = "";
            }

            // ENABLED: Spec2 cheat functions  
            function activateSpec2Cheat() {
                if (!store.player.pilotGenome) {
                    announce("CHEAT FAILED: Choose a Pilot first.");
                    return;
                }
                if (!store.player.subclass) {
                    announce("CHEAT FAILED: Choose a Subclass first.");
                    return;
                }

                store.cheatsUsed = true;
                announce('CHEAT: JUMPING TO SUB2');
                showSpecSelect(true); // true = additive/second spec
            }

            function activateSpeedCheat() {
                // Initialize if not present
                if (!window.gameSpeedMultiplier || window.gameSpeedMultiplier < 1) {
                    window.gameSpeedMultiplier = 1;
                }

                // Cycle through speed multipliers: 1x -> 2x -> 3x -> 1x
                if (window.gameSpeedMultiplier === 1) {
                    window.gameSpeedMultiplier = 2;
                    announce('CHEAT: GAME SPEED 2X');
                } else if (window.gameSpeedMultiplier === 2) {
                    window.gameSpeedMultiplier = 3;
                    announce('CHEAT: GAME SPEED 3X');
                } else {
                    window.gameSpeedMultiplier = 1;
                    announce('CHEAT: GAME SPEED NORMAL');
                }

                store.cheatsUsed = true;
            }

            const SUBCLASS_CHEAT_CODES = {
                jug: { subclass: 'juggernaut', genome: 'beef', label: 'JUGGERNAUT' },
                mar: { subclass: 'marauder', genome: 'beef', label: 'MARAUDER' },
                dem: { subclass: 'demolitioner', genome: 'rocketman', label: 'DEMOLITIONER' },
                rai: { subclass: 'railgunner', genome: 'rocketman', label: 'RAILGUNNER' },
                pha: { subclass: 'phasestriker', genome: 'voidmancer', label: 'PHASESTRIKER' },
                sto: { subclass: 'stormbringer', genome: 'voidmancer', label: 'STORMBRINGER' }
            };

            function clearSubclassEffects() {
                const p = store.player;
                if (!p || !p.subclass) return;

                switch (p.subclass) {
                    case 'railgunner':
                        p.missilePierce = player_initial_state.missilePierce || 0;
                        break;
                    case 'demolitioner':
                        p.missileCluster = player_initial_state.missileCluster || false;
                        break;
                    case 'marauder':
                        p.beefChainMode = false;
                        if (p.marauderHitTargets && typeof p.marauderHitTargets.clear === 'function') {
                            p.marauderHitTargets.clear();
                        }
                        break;
                    case 'phasestriker':
                        if (!p.hasPhasestriker) {
                            p.hasVoidLaser = false;
                        }
                        p.voidLaserTarget = null;
                        p.voidLaserDamageTimer = 0;
                        p.voidLaserRetargetTimer = 0;
                        p.voidLaserRange = 0;
                        break;
                    case 'stormbringer':
                        resetPlayerLightningState(p, { preserveUnlock: true });
                        break;
                }

                p.subclass = null;
            }

            function activateSubclassOverrideCheat(targetSubclass, requiredGenome, label) {
                const p = store.player;
                if (!p || !p.pilotGenome) {
                    announce('CHEAT FAILED: Choose a Pilot first.');
                    cheatCodeBuffer = "";
                    return;
                }

                if (requiredGenome && p.pilotGenome !== requiredGenome) {
                    announce(`CHEAT FAILED: Requires ${requiredGenome.toUpperCase()} pilot.`);
                    cheatCodeBuffer = "";
                    return;
                }

                store.cheatsUsed = true;

                if (p.subclass === targetSubclass) {
                    updateAbilityButtonIcon();
                    announce(`CHEAT: ${targetSubclass.toUpperCase()} ALREADY ACTIVE`);
                    cheatCodeBuffer = "";
                    return;
                }

                clearSubclassEffects();

                const originalEnemyBonus = store.world ? store.world.enemyHealthBonus : null;
                if (label) {
                    announce(`CHEAT: ${label} READY`);
                }
                applySubclassBonus(targetSubclass);
                if (store.world && originalEnemyBonus !== null && originalEnemyBonus !== undefined) {
                    store.world.enemyHealthBonus = originalEnemyBonus;
                }

                if (targetSubclass === 'marauder' && (!p.marauderHitTargets || typeof p.marauderHitTargets.clear !== 'function')) {
                    p.marauderHitTargets = new Set();
                }

                updateAbilityButtonIcon();
                cheatCodeBuffer = "";
            }

            function activateSevenCheat() {
                store.cheatsUsed = true;
                initializeProgressionTracking();

                const pointsGranted = 7;
                for (let i = 0; i < pointsGranted; i++) {
                    checkProgressionLogic(true);
                }

                announce(`CHEAT: +${pointsGranted} PROGRESSION POINTS`);
                updateSkillTreeUI();
                cheatCodeBuffer = "";
            }

            function activateCubeBurglarCheat() {
                if (!store || !store.world || store.isGameOver) {
                    announce('CHEAT FAILED: Start a run first.');
                    cheatCodeBuffer = "";
                    return;
                }

                const existing = getCubeBurglarActiveEnemy();
                if (existing) {
                    announce('CHEAT: Cube Burglar already active.');
                    cheatCodeBuffer = "";
                    return;
                }

                if (!Array.isArray(store.enemies)) {
                    store.enemies = [];
                }

                store.cheatsUsed = true;

                const world = store.world;
                const threatScale = Math.max(1, world.enemyHealthBonus || 1);
                const lateGameScaling = Math.max(1, world.lateGameDamageScaling || 1);
                const burglar = createCubeBurglar({
                    hpScale: threatScale,
                    lateGameScaling,
                    damageMult: 1 + Math.max(0, (world.collarStacks || 0) * 0.05)
                });

                const now = typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now();
                world.cubeBurglarActive = true;
                world.cubeBurglarLastSpawnWave = world.wave;
                world.cubeBurglarLastSpawnTime = now;
                world.cubeBurglarSpawnTimer = 0;
                world.cubeBurglarSpawnAttempts = 0;
                world.cubeBurglarLastAttemptTime = now;
                store.cubeBurglarId = burglar.id;

                activateSpawnIntro(burglar, {
                    duration: burglar.spawnDuration,
                    dropDistance: burglar.spawnDropDistance,
                    effectColor: burglar.spawnEffectColor,
                    clusterIndex: -1,
                    clusterSize: 1,
                    fireDelayBuffer: 0.75
                });

                store.enemies.push(burglar);
                store.world.lastSpawnCount = (store.world.lastSpawnCount || 0) + 1;

                store.activeEffects.push(createEffect('spawnTeleport', burglar.x, burglar.spawnTargetY ?? burglar.y, 48, {
                    color: burglar.spawnEffectColor,
                    duration: (burglar.spawnDuration || 0.8) + 0.35
                }));

                announce('CHEAT: Cube Burglar inbound on demand.');
                if (typeof playSound === 'function') {
                    playSound('thunder');
                }

                cheatCodeBuffer = "";
            }

            q('diagBox').children[0].addEventListener('click', () => {
                const now = performance.now();
                if (now - lastCheatTap > 500) {
                    cheatTapCount = 0;
                }
                lastCheatTap = now;
                cheatTapCount++;
                if (cheatTapCount >= 3) {
                    activatePowerCheat();
                    cheatTapCount = 0;
                }
            });

            addEventListener("keydown", e => {
                const key = e.key.toLowerCase();
                if (document.activeElement.tagName === "INPUT") return;

                if (/[a-z]/.test(key)) {
                    cheatCodeBuffer += key;
                    if (cheatCodeBuffer.length > 10) {
                        cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
                    }

                    if (cheatCodeBuffer.endsWith('power')) {
                        activatePowerCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('off')) {
                        activateDamageOffCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('on')) {
                        deactivateDamageOffCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('fast')) {
                        activateSpeedCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('class')) {
                        activateClassCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('sub')) {
                        activateSubclassCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('spec2')) {
                        activateSpec2Cheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('sigil') || cheatCodeBuffer.endsWith('champ')) {
                        activateChampionCheat();
                        cheatCodeBuffer = "";
                    } else if (cheatCodeBuffer.endsWith('burglar')) {
                        activateCubeBurglarCheat();
                    } else if (cheatCodeBuffer.endsWith('boss')) {
                        activateBossCheat();
                    } else {
                        const subclassCode = Object.keys(SUBCLASS_CHEAT_CODES).find(code => cheatCodeBuffer.endsWith(code));
                        if (subclassCode) {
                            const { subclass, genome, label } = SUBCLASS_CHEAT_CODES[subclassCode];
                            activateSubclassOverrideCheat(subclass, genome, label);
                        } else if (cheatCodeBuffer.endsWith('seven')) {
                            activateSevenCheat();
                        }
                    }
                } else {
                    if (key !== ' ' && key !== 'b') {
                        cheatCodeBuffer = "";
                    }
                }

                // EMP charges auto-activate on proximity, spacebar no longer needed
                if (key === 'escape') {
                    e.preventDefault();
                    // Close skill tree if it's open
                    if (!q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                        closeSkillTree();
                    }
                }
            });

            let lastTapTime = 0;
            cvs.addEventListener('touchend', e => {
                e.preventDefault();
                if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
                    const now = performance.now();
                    const DOUBLE_TAP_DELAY = 300;
                    if (now - lastTapTime < DOUBLE_TAP_DELAY) {
                        const p = pointFromEvent(e);
                        tryVoidStep(store.player, p);
                        lastTapTime = 0;
                    } else {
                        lastTapTime = now;
                    }
                }
            }, { passive: false });

            cvs.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
                    const p = pointFromEvent(e);
                    tryVoidStep(store.player, p);
                }
            });


            // PERFORMANCE: Enhanced performance monitoring
            let perfFrameCount = 0;
            let perfLastFPSUpdate = 0;
            let perfFPS = 0;
            let perfWorstFrameTime = 0;

            function createPerformanceMetrics() {
                return {
                    stepWorldTime: 0,
                    renderTime: 0,
                    frameTime: 0,
                    // New detailed metrics
                    hudUpdateTime: 0,
                    bulletUpdateTime: 0,
                    enemyUpdateTime: 0,
                    collisionTime: 0,
                    drawCallTime: 0,
                    memoryUsage: 0,
                    slowFrameCount: 0,
                    lastSlowLog: 0,
                    activeEnemies: 0,
                    activeBullets: 0,
                    activeFlames: 0
                };
            }

            let performanceMetrics = createPerformanceMetrics();
            
            // Expose performance metrics globally for diagnostics
            window.performanceMetrics = performanceMetrics;
            window.perfFPS = perfFPS;

            // Performance budget alerts
            const PERFORMANCE_BUDGETS = {
                frameTime: 16.67, // 60fps budget
                stepWorld: 8,     // Half frame budget for logic
                render: 4,        // Quarter frame budget for rendering
                hudUpdate: 1      // HUD should be very fast
            };

            function setTelemetryEnabled(enabled, forceReset = false) {
                const normalized = !!enabled;
                if (!forceReset && normalized === store.telemetryEnabled) {
                    return normalized;
                }

                store.telemetryEnabled = normalized;

                try {
                    if (window.localStorage) {
                        window.localStorage.setItem('voidTelemetry', normalized ? '1' : '0');
                    }
                } catch (err) {
                    // Ignore storage access issues
                }

                if (normalized) {
                    performanceMetrics = createPerformanceMetrics();
                    perfFrameCount = 0;
                    perfLastFPSUpdate = performance.now();
                    perfWorstFrameTime = 0;
                }

                console.info(`[PERF] Telemetry ${normalized ? 'enabled' : 'disabled'}`);
                return normalized;
            }

            window.enableTelemetry = () => setTelemetryEnabled(true);
            window.disableTelemetry = () => setTelemetryEnabled(false);
            window.toggleTelemetry = () => setTelemetryEnabled(!store.telemetryEnabled);

            setTelemetryEnabled(store.telemetryEnabled, true);

            function frame(now) {
                const telemetryActive = !!store.telemetryEnabled;
                const frameStart = telemetryActive ? performance.now() : 0;

                // Detect abnormally large time jumps (e.g., app returning from background)
                const timeSinceLastFrame = (now - store.last) / 1000;
                if (timeSinceLastFrame > 1.0) {
                    // Likely returned from background - reset time reference and skip this frame
                    console.log(`âš ï¸ Large time jump detected (${timeSinceLastFrame.toFixed(2)}s) - resetting time reference`);
                    store.last = now;
                    if (!store.isPaused && !store.isGameOver) {
                        // Auto-pause for safety
                        store.isPaused = true;
                        const pauseBtn = document.getElementById('pauseBtn');
                        if (pauseBtn) pauseBtn.textContent = 'RESUME';
                    }
                    requestAnimationFrame(frame);
                    return;
                }

                const rawDt = Math.min(timeSinceLastFrame, 0.07);
                const speedMultiplier = window.gameSpeedMultiplier || 1;

                // Cap the dt to prevent simulation instability even with speed multiplier
                const dt = Math.min(rawDt * speedMultiplier, 0.1);

                store.last = now;

                let stepStart;
                if (telemetryActive) {
                    stepStart = performance.now();
                }
                if (!store.isPaused && !store.isGameOver) {
                    stepWorld(dt);
                }
                if (telemetryActive && stepStart !== undefined) {
                    performanceMetrics.stepWorldTime = performance.now() - stepStart;
                }

                let renderStart;
                if (telemetryActive) {
                    renderStart = performance.now();
                }
                render(rawDt); // Use original dt for rendering to avoid visual issues
                if (telemetryActive && renderStart !== undefined) {
                    performanceMetrics.renderTime = performance.now() - renderStart;
                }

                if (telemetryActive) {
                    const currentFrameTime = performance.now() - frameStart;
                    if (currentFrameTime > PERFORMANCE_BUDGETS.frameTime) {
                        performanceMetrics.slowFrameCount++;
                    }

                    const frameTime = currentFrameTime;
                    performanceMetrics.frameTime = frameTime;
                    performanceMetrics.activeEnemies = store.enemies ? store.enemies.length : 0;
                    const primaryBullets = store.bullets ? store.bullets.length : 0;
                    const fragmentBullets = store.fragmentProjectiles ? store.fragmentProjectiles.length : 0;
                    performanceMetrics.activeBullets = primaryBullets + fragmentBullets;
                    performanceMetrics.activeFlames = store._activeFlamesCache ? store._activeFlamesCache.length : 0;

                    if (frameTime > perfWorstFrameTime) {
                        perfWorstFrameTime = frameTime;
                    }

                    if (frameTime > 33 && (!performanceMetrics.lastSlowLog || now - performanceMetrics.lastSlowLog > 1500)) {
                        performanceMetrics.lastSlowLog = now;
                    }

                    perfFrameCount++;
                    if (now - perfLastFPSUpdate > 3000) { // Log every 3 seconds
                        perfFPS = Math.round(perfFrameCount / 3);
                        window.perfFPS = perfFPS; // Update global reference
                        perfFrameCount = 0;
                        perfLastFPSUpdate = now;

                        // Calculate memory usage if available
                        if (performance.memory) {
                            performanceMetrics.memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                        }
                    }
                }

                requestAnimationFrame(frame);

            }

            // ===== ASSET PRELOADING SYSTEM =====
            
            function preloadAssets() {
                return new Promise((resolve, reject) => {
                    console.log('ðŸŽ® Starting asset preload...');
                    
                    const loadingScreen = document.getElementById('loadingScreen');
                    const loadingBar = document.getElementById('loadingBar');
                    const loadingText = document.getElementById('loadingText');
                    const loadingDetails = document.getElementById('loadingDetails');

                    // Collect all assets to preload
                    const audioAssets = [
                        'Explosion.m4a',
                        'Horn.wav',
                        'thunk.wav',
                        'trap.m4a',
                        'dogs.m4a',
                        'charge.m4a',
                        'beefcharge.m4a',
                        'epichorntrimmed.m4a',
                        'cluster.mp3',
                        'thunder.mp3',
                        'shao_kahn.m4a',
                        'stargun.m4a',
                        'lightningcrit.m4a',
                        'lightningpower.mp3',
                        'thundercrack.m4a',
                        'fire_whoosh.wav',
                        'sizzle.wav',
                        'upgrade_purchase.wav',
                        'void_pulse.wav',
                        'rocket_hit.wav',
                        'coin_pickup.wav',
                        'poison_splash.wav',
                        'snake_hiss_high.wav',
                        'bug_squeal_redo.wav',
                        'far_explosion.wav',
                        'robot_crumble.wav'
                    ];

                    const imageAssets = [
                        'cow.png',
                        'rockyboy.png',
                        'goggles.png',
                        'marauder.png',
                        'jug2.png',
                        'phase.png',
                        'storm.png',
                        'storm4.png',
                        'mar11.png',
                        'mar2.png',
                        'mar3.png',
                        'mar4.png',
                        'bshield.png',
                        'clone.png',
                        'jug1.png',
                        'jug22.png',
                        'jug33.png',
                        'jug4.png'
                    ];

                    console.log(`ðŸ“¦ Total assets to load: ${audioAssets.length} audio, ${imageAssets.length} images`);

                    let loadedCount = 0;
                    const totalAssets = audioAssets.length + imageAssets.length;
                    const errors = [];

                    function updateProgress(assetName, success = true) {
                        loadedCount++;
                        const progress = (loadedCount / totalAssets) * 100;
                        
                        console.log(`${success ? 'âœ…' : 'âŒ'} [${loadedCount}/${totalAssets}] ${assetName}`);
                        
                        if (loadingBar) {
                            loadingBar.style.width = `${progress}%`;
                        }

                        if (loadingText) {
                            if (loadedCount < totalAssets) {
                                loadingText.textContent = `LOADING ASSETS...`;
                            } else {
                                loadingText.textContent = 'SYSTEMS READY!';
                            }
                        }

                        // Check if all assets are loaded
                        if (loadedCount >= totalAssets) {
                            console.log(`ðŸŽ‰ Asset loading complete! Loaded: ${totalAssets - errors.length}, Failed: ${errors.length}`);
                            setTimeout(() => {
                                if (loadingScreen) {
                                    loadingScreen.classList.add('loaded');
                                }
                                setTimeout(() => {
                                    if (errors.length > 0) {
                                        console.warn('âš ï¸ Some assets failed to load (this is OK if files are missing):', errors.map(e => e.src));
                                    }
                                    resolve({ loaded: loadedCount, errors });
                                }, 500); // Wait for fade-out animation
                            }, 300); // Brief delay to show "SYSTEMS READY"
                        }
                    }

                    // Preload audio files
                    audioAssets.forEach(src => {
                        const audio = new Audio();
                        let resolved = false;
                        
                        audio.addEventListener('canplaythrough', () => {
                            if (!resolved) {
                                resolved = true;
                                updateProgress(src, true);
                            }
                        }, { once: true });

                        audio.addEventListener('error', (e) => {
                            if (!resolved) {
                                resolved = true;
                                errors.push({ type: 'audio', src, error: e.type || 'load error' });
                                updateProgress(src, false);
                            }
                        }, { once: true });

                        // Set a timeout fallback in case the asset never loads
                        setTimeout(() => {
                            if (!resolved) {
                                resolved = true;
                                errors.push({ type: 'audio', src, error: 'timeout' });
                                updateProgress(src, false);
                            }
                        }, 5000);

                        audio.src = src;
                        audio.load();
                    });

                    // Preload image files
                    imageAssets.forEach(src => {
                        const img = new Image();
                        let resolved = false;
                        
                        img.addEventListener('load', () => {
                            if (!resolved) {
                                resolved = true;
                                updateProgress(src, true);
                            }
                        }, { once: true });

                        img.addEventListener('error', (e) => {
                            if (!resolved) {
                                resolved = true;
                                errors.push({ type: 'image', src, error: e.type || 'load error' });
                                updateProgress(src, false);
                            }
                        }, { once: true });

                        // Set a timeout fallback
                        setTimeout(() => {
                            if (!resolved) {
                                resolved = true;
                                errors.push({ type: 'image', src, error: 'timeout' });
                                updateProgress(src, false);
                            }
                        }, 5000);

                        img.src = src;
                    });

                    // Fallback: if nothing loads after 10 seconds, proceed anyway
                    setTimeout(() => {
                        if (loadedCount === 0) {
                            console.error('âŒ Asset loading timeout - proceeding anyway');
                            reject(new Error('Asset loading timeout'));
                        }
                    }, 10000);
                });
            }

            // ===== GAME INITIALIZATION =====
            
            // Game initialization now waits for asset preloading
            async function initializeGame() {
                try {
                    // Wait for assets to load
                    const result = await preloadAssets();
                    console.log(`âœ… Assets loaded: ${result.loaded} total`);
                    if (result.errors.length > 0) {
                        console.warn(`âš ï¸ ${result.errors.length} assets failed to load`);
                    }

                    // Initialize game after assets are ready
                    ensureName();
                    refreshScoreList();
                    requestAnimationFrame(frame);
                } catch (error) {
                    console.error('Asset preloading failed:', error);
                    // Try to start game anyway
                    try {
                        updateLeaderboard(null);
                        ensureName();
                        requestAnimationFrame(frame);
                    } catch (criticalError) {
                        console.error('Critical startup error:', criticalError);
                    }
                }
            }

            // Start game initialization when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeGame);
            } else {
                // DOM already loaded
                initializeGame();
            }

            // ========== GLOBAL DIAGNOSTIC HELPERS ==========
            window.getPixiDiagnostics = function() {
                return {
                    currentTime: new Date().toISOString(),
                    webgl: {
                        contextLost: window.webglContextLost,
                        recoveryAttempts: window.webglRecoveryAttempts,
                        lastContextLossInfo: window._lastWebGLContextLossInfo || 'Never occurred',
                        lastContextRestoredInfo: window._lastWebGLContextRestoredInfo || 'Never occurred',
                        lastRebuildError: window._lastPixiRebuildError || 'No errors',
                        lastRebuildLog: window._lastPixiRebuildLog || 'No build log'
                    },
                    pixi: {
                        appExists: !!pixiApp,
                        rendererExists: !!pixiApp?.renderer,
                        hasGL: !!pixiApp?.renderer?.gl,
                        bulletTexturesGenerated: Object.keys(bulletTextures || {}).length,
                        spritePoolsActive: {
                            activeBulletSprites: activeBulletSprites?.size || 0,
                            bulletSpritePool: bulletSpritePool?.length || 0,
                            activeParticleSprites: activeParticleSprites?.size || 0,
                            particleSpritePool: particleSpritePool?.length || 0
                        }
                    },
                    canvas: {
                        cvs: !!cvs,
                        ctx: !!ctx,
                        canvasScaleX,
                        canvasScaleY,
                        width: cvs?.width,
                        height: cvs?.height,
                        cssWidth: cvs?.style.width,
                        cssHeight: cvs?.style.height
                    },
                    game: {
                        isPaused: store?.isPaused,
                        isGameOver: store?.isGameOver,
                        wave: store?.wave,
                        bulletCount: store?.bullets?.length || 0,
                        enemyCount: store?.enemies?.length || 0,
                        playerHp: store?.player?.hp,
                        playerMaxHp: store?.player?.hpMax
                    }
                };
            };

            window.exportPixiDiagnostics = function() {
                const diagnostics = window.getPixiDiagnostics();
                const jsonStr = JSON.stringify(diagnostics, null, 2);
                console.log('='.repeat(60));
                console.log('PIXI DIAGNOSTICS EXPORT');
                console.log('='.repeat(60));
                console.log(jsonStr);
                console.log('='.repeat(60));
                console.log('Copy the above diagnostics and share with developer');
                return jsonStr;
            };

            // Log diagnostic helper availability
            console.log('ðŸ“Š Type window.getPixiDiagnostics() to see current Pixi state');
            console.log('ðŸ“Š Type window.exportPixiDiagnostics() to export all diagnostics');
            // ========== END DIAGNOSTIC HELPERS ==========

            document.addEventListener('DOMContentLoaded', () => {
                // Set up upgrade popup OK button
                const upgradePopupOkBtn = document.getElementById('upgradePopupOkBtn');
                if (upgradePopupOkBtn) {
                    upgradePopupOkBtn.addEventListener('click', () => {
                        const panel = document.getElementById('upgradePopupPanel');
                        if (panel) {
                            panel.classList.add('hide');
                            // Force resume to avoid race condition where panel visibility check happens before CSS update
                            resumeGame(true);
                        }
                    });
                }

                // Initialize mobile controls if the function exists (like fghfgh.html)
                if (typeof setupMobileControls === 'function') {
                    setupMobileControls();
                }
            });

        })();
    </script>
</body>

</html>