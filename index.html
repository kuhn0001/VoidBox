<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 98vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        
        /* Hide VS Code browser controls */
        .monaco-workbench .part.titlebar, 
        .vs-dark .monaco-workbench .part.titlebar,
        .titlebar,
        .browser-close-button,
        .browser-action-buttons,
        .monaco-action-bar {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            opacity: 0 !important;
        }

        .close-btn {
            position: absolute;
            top: 8px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 20px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 4px;
        }
        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        /* Hide only the specific problematic close buttons */
        #closeScores {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
        
        /* More aggressive hiding of browser UI */
        body {
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden;
        }
        
        /* Hide any top-level browser chrome */
        :root {
            --browser-chrome-height: 0px;
        }
        
        #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:0;}
        .stage{width:100vw; height:100svh; position:relative;display:grid;place-items:center;background:#000;border-radius:0;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
        canvas{background:transparent;border-radius:16px;touch-action:none;cursor: url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='14' stroke='rgba(255,153,204,0.8)' stroke-width='2' fill='none'/%3E%3Ccircle cx='16' cy='16' r='8' stroke='rgba(255,153,204,0.6)' stroke-width='2' fill='none'/%3E%3Cline x1='16' y1='0' x2='16' y2='32' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3Cline x1='0' y1='16' x2='32' y2='16' stroke='rgba(255,153,204,0.5)' stroke-width='1'/%3E%3C/svg%3E") 16 16, auto;}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }
        #diagBox{position:absolute;left:8px;top:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:left;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s; font-family: 'Orbitron', 'Audiowide', ui-sans-serif;}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        
        .panel{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:rgba(26,0,34,.95);
            border:1px solid var(--accent);
            border-radius:16px;
            padding:12px;
            width:min(600px, 90vw);
            backdrop-filter:blur(12px);
            color:#ffddff;
            box-shadow:0 0 40px rgba(178,102,255,.3);
            z-index:100;
        }
        
        /* Expanded panel for skill tree */
        #subclassPanel.skill-tree-active {
            width: min(800px, 90vw);
            height: min(600px, 85vh);
            overflow: hidden;
        }
        #namePanel {
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #pilotPanel {
            width: min(800px, 94vw);
            position: relative;
        }
        #shopPanel h2, #levelPanel h2, #scorePanel h2, #namePanel h2, #pilotPanel h2, #subclassPanel h2 {
            margin: 0 0 4px 0;
            padding-top: 4px;
            font-size: clamp(16px, 2vw, 20px);
            text-align: center;
        }
        #shopPanel p, #levelPanel p, #namePanel p {
            margin: 0 0 8px 0;
            text-align: center;
        }
        #shopGrid, #scorePanel div {
            max-height: 60vh; 
            overflow-y: auto;
            padding-right: 8px;
        }
        .grid{
            display:grid;
            gap:8px;
            grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
        }
        .hide{display:none!important}
        #belowBoard{width:min(98vw,var(--maxw));margin:50px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        
        .skill-card {
            background: radial-gradient(circle, rgba(51,0,68,1) 0%, rgba(51,0,68,0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: flex-start;
        }
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        
        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }
        .pilot-icon {
            width: 128px;
            height: 128px;
            object-fit: contain;
            margin-bottom: 8px;
        }
        .skill-title{
            font-weight:700;
            color:#c49cff;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.1;
        }
        .skill-desc{
            font-size:11px;
            color:#ffddff;
            margin-bottom: 8px;
            min-height: 44px;
        }
        .skill-tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 15px;
            max-width: 100%;
            margin: 0 auto;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .skill-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        .skill-card-node-pair {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .skill-row {
            display: flex;
            justify-content: center;
            gap: 40px;
            width: 100%;
        }
        
        /* SKILL TREE - Portrait-oriented Icon Button System */
        .skill-track {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .track-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        .skill-icon-button {
            position: relative;
            width: 120px;
            height: 140px;
            cursor: pointer;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .skill-icon-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: all 0.4s ease;
        }
        .skill-icon-image.enhanced {
            filter: brightness(1.3) saturate(1.2) drop-shadow(0 0 12px rgba(255,215,0,0.8));
        }
        .skill-info-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.8) 30%, rgba(0,0,0,0.95) 100%);
            padding: 15px 12px 12px;
            transform: translateY(70%);
            transition: all 0.4s ease;
        }
        .skill-overlay-title {
            font-size: 14px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 6px;
            text-align: center;
        }
        .skill-overlay-desc {
            font-size: 10px;
            color: #cccccc;
            line-height: 1.3;
            text-align: center;
        }
        
        /* SKILL ICON BUTTON STATES */
        .skill-icon-button.available {
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
        }
        .skill-icon-button.available:hover {
            border-color: #66BB6A;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            transform: translateY(-5px) scale(1.05);
        }
        .skill-icon-button.available:hover .skill-info-overlay {
            transform: translateY(0%);
        }
        .skill-icon-button.available:hover .skill-icon-image {
            filter: brightness(1.2) saturate(1.1);
        }
        
        .skill-icon-button.active {
            border-color: #FFD700;
            background: linear-gradient(135deg, rgba(255,215,0,0.1) 0%, rgba(255,215,0,0.2) 100%);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1);
            animation: activeIconGlow 3s ease-in-out infinite;
        }
        .skill-icon-button.active .skill-icon-image {
            filter: brightness(1.4) saturate(1.3) drop-shadow(0 0 15px rgba(255,215,0,0.9));
        }
        .skill-icon-button.active .skill-info-overlay {
            transform: translateY(0%);
            background: linear-gradient(180deg, transparent 0%, rgba(255,215,0,0.1) 30%, rgba(0,0,0,0.9) 100%);
        }
        
        .skill-icon-button.locked {
            border-color: #333;
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.7);
        }
        .skill-icon-button.locked:hover {
            transform: none;
            box-shadow: none;
        }
        
        /* CLASS ABILITY TRACK STYLING */
        .class-ability-track {
            position: relative;
            margin-left: 40px;
            padding: 20px;
            border-left: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 0 12px 12px 0;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), rgba(135, 206, 235, 0.05));
        }
        .class-ability-track .track-title {
            color: #FFD700;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        .class-ability-solo {
            border: 3px solid #FFD700 !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6) !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.2)) !important;
        }
        .class-ability-solo:hover {
            border-color: #FFF700 !important;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.8) !important;
            transform: translateY(-8px) scale(1.08) !important;
        }
        
        /* BEAUTIFUL GLOW ANIMATIONS */
        @keyframes activeIconGlow {
            0% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
            50% { box-shadow: 0 0 35px rgba(255, 215, 0, 1.0), inset 0 0 25px rgba(255,255,255,0.2), 0 0 50px rgba(135,206,235,0.3); }
            100% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.1); }
        }
        
        /* Old skill node classes for compatibility */
        
        /* Beautiful Marble/Lightning Animations */
        @keyframes marbleSwirl {
            0% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
            25% { background: linear-gradient(225deg, #e6e6fa 0%, #f5f5dc 30%, #f8f8ff 60%, #dcdcdc 100%); }
            50% { background: linear-gradient(315deg, #dcdcdc 0%, #f8f8ff 30%, #f5f5dc 60%, #e6e6fa 100%); }
            75% { background: linear-gradient(45deg, #f5f5dc 0%, #dcdcdc 30%, #e6e6fa 60%, #f8f8ff 100%); }
            100% { background: linear-gradient(135deg, #f8f8ff 0%, #e6e6fa 30%, #dcdcdc 60%, #f5f5dc 100%); }
        }
        
        @keyframes lightningPulse {
            0% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
            50% { box-shadow: 0 0 15px rgba(255,215,0,0.8), inset 0 0 12px rgba(255,255,255,0.6), 0 0 25px rgba(135,206,235,0.4); }
            100% { box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,255,255,0.4); }
        }
        .skill-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .skill-node.active, .skill-combo-node.active {
            border-color: #FFD700;
            background: #2a2a4e;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }
        .skill-node.locked, .skill-combo-node.locked {
            border-color: #444;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skill-combo-node.available {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .skill-tree-title {
            font-size: 16px;
            color: #FFD700;
            margin-bottom: 8px;
            text-align: center;
            font-weight: bold;
        }
        .skill-description {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
            min-height: 40px;
            color: #ffddff;
            font-size: 12px;
        }
        .ability-hint {
            font-size: 10px;
            color: #87CEEB;
            text-align: center;
            margin-top: 6px;
            font-style: italic;
            text-shadow: 0 0 4px rgba(135, 206, 235, 0.5);
        }
        .ability-icon {
            font-size: 12px;
            margin: 0 2px;
            display: inline-block;
            animation: pulse-glow 2s infinite;
        }

        #storyBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 18px;
            font-family: 'Orbitron', serif;
            cursor: pointer;
            line-height: 26px;
            padding: 0;
            transition: all 0.2s;
        }
        #storyBtn:hover {
            background: var(--accent);
            color: var(--bg);
            transform: scale(1.1);
        }
        #storyPanel {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            display: grid;
            place-items: center;
            padding: 20px;
            cursor: pointer;
        }
        #storyPanel p {
            max-width: 600px;
            text-align: center;
            font-size: clamp(16px, 2.5vw, 22px);
            line-height: 1.6;
            color: #ffddff;
            text-shadow: 0 0 10px var(--accent);
        }

        .fixed-btn{
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.4;
            transition: opacity 0.3s ease-in-out;
        }
        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }
        
        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }
        #bottom-right-controls > .fixed-btn {
            position: static;
        }

        #menuBtn, #fsEnterBtn, #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }
        #pauseBtn {
            top: 50%;
            right: 15px; 
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif; box-sizing: border-box;}
        
        #abilityBar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 6; pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }
        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }
        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }
        
        .shop-item-attack { border-color: #00bfff; }
        .shop-item-health { border-color: #00ff00; }
        .shop-item-utility { border-color: #ffd700; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
            50% { box-shadow: 0 0 35px rgba(102, 255, 178, 1); }
            100% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
        }
        @keyframes pulse-glow-ability {
            0% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
            50% { box-shadow: 0 0 20px rgba(178, 102, 255, .8); }
            100% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
        }
        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(500px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
        
        /* Matrix Rain Effect */
        .matrix-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
            z-index: -1;
            pointer-events: none;
        }

        .matrix-column {
            position: absolute;
            top: 0;
            width: 18px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            pointer-events: none;
            will-change: transform;
        }

        .matrix-char {
            position: absolute;
            display: block;
            line-height: 20px;
            width: 100%;
            transition: none;
            transform: translateZ(0); /* Force GPU acceleration */
        }

        /* Purple gradient classes for different brightness levels */
        .bright {
            color: #e6ccff;
            text-shadow: 0 0 5px #cc99ff, 0 0 10px #cc99ff;
        }

        .medium {
            color: #b366ff;
            text-shadow: 0 0 3px #9933ff;
        }

        .dim {
            color: #6600cc;
            text-shadow: 0 0 2px #6600cc;
        }

        .faded {
            color: #330066;
            opacity: 0.7;
        }

        .very-faded {
            color: #1a0033;
            opacity: 0.4;
        }

        /* Teleport Tutorial Popup */
        #teleportTutorialPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(102,0,204,0.2) 100%);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 40px;
            max-width: 500px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(204,153,255,0.4);
        }

        #teleportTutorialPanel h2 {
            color: var(--accent);
            font-family: 'Orbitron';
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--accent);
        }

        .teleport-instruction {
            font-size: 18px;
            color: #ffddff;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .teleport-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 5px var(--accent));
        }

        /* --- MOBILE JOYSTICK & BUTTON CONTROLS --- */
        .mobile-control {
            position: fixed;
            z-index: 20;
            opacity: 0.6;
            display: none; /* Hidden by default */
        }

        body.mobile-controls-active .mobile-control {
            display: block; /* Shown when body class is active */
        }

        #joystick-container {
            bottom: 90px;
            left: 45px;
        }

        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(50, 0, 70, 0.5);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
        }

        #joystick-stick {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #ffddff, var(--accent));
            border-radius: 50%;
            pointer-events: none; /* Pass touches through to the base */
        }

        #ability-button-container {
            bottom: 100px;
            right: 70px;
        }

        #ability-button {
            width: 90px;
            height: 90px;
            background: rgba(150, 80, 255, 0.3);
            border: 2px solid var(--accent);
            border-radius: 50%;
            display: grid;
            place-items: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(178, 102, 255, .5);
        }

        #ability-icon {
            width: 70px;
            height: 70px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            filter: drop-shadow(0 0 5px white);
        }

        /* --- TOGGLE SWITCH IN MECH FORGE --- */
        .mobile-toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            color: var(--accent);
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #330044;
            border: 1px solid var(--accent);
            transition: .4s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--accent2);
        }

        input:checked + .slider:before {
            transform: translateX(22px);
        }

        /* --- SKILL TREE VIEWER BUTTON --- */
        .skill-tree-btn-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        .skill-tree-viewer-btn {
            background: linear-gradient(45deg, var(--accent2), var(--accent));
            color: white;
            border: 2px solid var(--accent);
            padding: 8px 16px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .skill-tree-viewer-btn:hover {
            background: linear-gradient(45deg, var(--accent), var(--accent2));
            box-shadow: 0 0 15px var(--accent);
            transform: scale(1.05);
        }

        .skill-tree-viewer-btn:active {
            transform: scale(0.95);
        }

        .skill-tree-viewer-btn:disabled {
            background: #444;
            color: #888;
            border-color: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .skill-tree-viewer-btn:disabled:hover {
            box-shadow: none;
            transform: none;
        }
        
    </style>
</head>
<body>
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide">
                        <div class="hud-title">‚ó¢ SYSTEMS ONLINE ‚ó£</div>
                        <div id="powerupList"></div>
                    </div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card">
                            <div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div>
                            <div style="text-align:center">
                                SECTOR <b id="waveNum">1</b> ‚Ä¢ KILLS <b id="killsNum">0</b> ‚Ä¢ LVL <b id="levelNum">1</b>
                            </div>
                        </div>
                        <div id="hudPilotContent" class="hud-card">
                            <div class="hud-title" id="pilotTitle">‚ó¢ UNIDENTIFIED ‚ó£</div>
                            <div style="text-align:center">
                                SCORE <b id="scoreNum">0</b> ‚Ä¢ Gold üí∞ <b id="goldNum" style="color:#FFD700;font-size:1.2em">0</b>
                            </div>
                            <div class="bar" id="hpBar"><span id="hpBarFill" style="width:100%"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="hpText">HP: 100 / 100</div>
                            <div class="bar" id="beefShieldBar" style="margin-top:2px;display:none"><span id="beefShieldBarFill" style="background:linear-gradient(90deg,#ff8c00,#ff4500)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="beefShieldText"></div>
                            <div class="bar" id="shieldBar" style="margin-top:2px;display:none"><span id="shieldBarFill" style="background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>
                            <div style="font-size: 9px; text-align: center; line-height: 1;" id="shieldText"></div>
                        </div>
                        <div id="hudBossContent" class="hud-card hide">
                            <div class="hud-title" id="bossTitle">‚ö° BOSS ‚ö°</div>
                            <div class="bar"><span id="bossBarFill" style="width:100%"></span></div>
                        </div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide">
                        <div class="hud-title">‚ó¢ EQUIPMENT ‚ó£</div>
                        <div id="equipmentList"></div>
                    </div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <table style="font-size:10px; color:var(--fg); background:rgba(0,0,0,0.7); padding:8px; border-radius:8px; border-spacing:8px 2px;">
                        <tr><td>v3.8.0</td><td>FPS:</td><td><span id="fps">‚Äî</span></td></tr>
                        <tr><td>Collar:</td><td colspan="2"><span id="collar">0 (0%)</span></td></tr>
                        <tr><td>Dmg/Bullet:</td><td colspan="2"><span id="damagePerBullet">‚Äî</span></td></tr>
                        <tr><td>Avg Enemy HP:</td><td colspan="2"><span id="avgEnemyHp">‚Äî</span></td></tr>
                        <tr><td>Enemy Base:</td><td><span id="enemyBaseHp">-</span></td><td>Current:</td><td><span id="enemyCurrentHp">-</span></td></tr>
                        <tr><td>Boss Base:</td><td><span id="bossBaseHp">-</span></td><td>Current:</td><td><span id="bossCurrentHp">-</span></td></tr>
                    </table>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üöÄ PILOT LOST üöÄ</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="pilotPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <!-- <button id="storyBtn" type="button">i</button> -->
                        <h2 style="font-family:'Orbitron';color:var(--accent)">Choose Genomic Upgrade</h2>
                        <div id="pilotsGrid" class="grid" style="grid-template-columns: repeat(3, 1fr);">
                            <div class="skill-card" data-genome="beef">
                                <div class="skill-icon"><img src="cow.png" class="pilot-icon" alt="BEEF"></div>
                                <div class="skill-title">BEEF</div>
                                <div class="skill-desc">Cybernetic heavy assault unit with adaptive bio-armor that responds to hostile engagement. Neural implants trigger reflexive counterstrike protocols when threatened.</div>
                                <div class="skill-bonuses">
                                    + Defense<br>
                                    + Special Ability
                                </div>
                            </div>
                            <div class="skill-card" data-genome="rocketman">
                                <div class="skill-icon"><img src="rockyboy.png" class="pilot-icon" alt="ROCKETMAN"></div>
                                <div class="skill-title">ROCKETMAN</div>
                                <div class="skill-desc">Former corporate military contractor with black-market ordnance mods. Tactical AI systems provide precision strike capabilities and explosive payload optimization.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                            <div class="skill-card" data-genome="voidmancer">
                                <div class="skill-icon"><img src="goggles.png" class="pilot-icon" alt="VOIDMANCER"></div>
                                <div class="skill-title">VOIDMANCER</div>
                                <div class="skill-desc">Quantum-phase enhanced operative with experimental void-fold technology. Neural interfaces allow instantaneous spatial displacement through dimensional rifts.</div>
                                <div class="skill-bonuses">
                                    + Special Ability<br>
                                    &nbsp;
                                </div>
                            </div>
                        </div>
                    </div>
                     <div id="subclassPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">CHOOSE SPECIALIZATION</h2>
                        <div id="subclassGrid" class="grid" style="grid-template-columns: repeat(2, 1fr);">
                        </div>
                        <!-- Dynamic skill tree that adapts based on selected subclass -->
                        <div id="skillTree" class="skill-tree hide">
                            <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                            <div class="skill-tree-title" id="skillTreeTitle">SPECIALIZATION TREE</div>
                            <div class="skill-grid" id="skillTreeGrid">
                                <!-- This will be populated dynamically based on subclass -->
                            </div>
                            <div class="skill-description" id="skillDescription">
                                Choose your specialization path: Marauder for sustained assault, Juggernaut for devastating impact, Shield for defense, Charge for mobility. Mix and match for powerful combos!
                            </div>
                        </div>
                    </div>
                    <div id="storyPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <p>When we first discovered the voidplane, one of the earliest notes was the similarity of the plane's inhabitant lifeforms to that of deep sea life on Earth.<br><br>
                        Mammalian life developed specialized spacecraft to venture within and colonize the resources of the primitive creatures.<br><br>
                        The hive responded and war ensued.</p>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üíÄ CALLSIGN üíÄ</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. The Coyote" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">üèÜ Aces of the Void üèÜ</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2 style="font-family:'Orbitron';color:var(--accent);">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <button type="button" class="close-btn" id="closeShopTopBtn">√ó</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° MECH FORGE ‚ö°</h2>
                        <p style="color:#ffddff">Gold üí∞ <span id="shopgold" style="color:#FFD700;font-size:1.2em">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="skillTreeBtn" class="btn" type="button">SKILL TREE</button>
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="teleportTutorialPanel" class="panel hide">
                        <div class="matrix-container"></div>
                        <h2>‚ö° VOID-FOLD PROTOCOL ‚ö°</h2>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">üñ±Ô∏è</span>
                            <span>Right-click to teleport</span>
                        </div>
                        <div class="teleport-instruction">
                            <span class="teleport-icon">üëÜüëÜ</span>
                            <span>Double-tap to teleport (mobile)</span>
                        </div>
                        <div style="margin-top: 30px;">
                            <p style="color: #ccaaff; font-size: 14px; margin-bottom: 20px;">
                                Quantum displacement damages enemies at origin point.<br>
                                Use strategically to escape danger and deal damage.
                            </p>
                            <button id="closeTeleportTutorial" class="btn" type="button">GOT IT</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>‚ö° Aces of the Void ‚ö°</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>
    <audio id="audioCharge" src="charge.m4a" preload="auto"></audio>
    <audio id="audioBeefCharge" src="beefcharge.m4a" preload="auto"></audio>
    <audio id="audioEpicHorn" src="epichorntrimmed.m4a" preload="auto"></audio>
    <audio id="audioCluster" src="cluster.mp3" preload="auto"></audio>
    <audio id="audioThunder" src="thunder.mp3" preload="auto"></audio>
    <audio id="audioShaoKahn" src="shao_kahn.m4a" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">‚ö° MECH FORGE üí∞</button>
        <button id="menuBtn" class="fixed-btn" type="button">üèÜ TOP PILOTS</button>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

    <div id="joystick-container" class="mobile-control">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
    <div id="ability-button-container" class="mobile-control">
        <div id="ability-button">
            <div id="ability-icon"></div>
        </div>
    </div>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://interest-christine-kingdom-excerpt.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => {
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height),
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    const pointFromEvent = (e) => {
        const r = cvs.getBoundingClientRect();
        let touch = e;
        if (e.changedTouches && e.changedTouches.length > 0) {
            touch = e.changedTouches[0];
        } else if (e.touches && e.touches.length > 0) {
            touch = e.touches[0];
        }
        const cx = touch.clientX;
        const cy = touch.clientY;
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) };
    };

    // --- MOBILE JOYSTICK & ABILITY BUTTON SETUP ---
    const joystick = {
        base: q('joystick-base'),
        stick: q('joystick-stick'),
        container: q('joystick-container'),
        abilityButton: q('ability-button'),
        abilityIcon: q('ability-icon')
    };

    const joystickState = {
        active: false,
        touchId: null,
        baseRect: null,
        input: { x: 0, y: 0 } // Normalized vector for player movement
    };

    // Mobile device detection
    function isMobileDevice() {
        return window.innerWidth <= 768 || 
               'ontouchstart' in window || 
               navigator.maxTouchPoints > 0 || 
               /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    function setupMobileControls() {
        // Joystick Listeners
        joystick.base.addEventListener('touchstart', handleJoystickStart, { passive: false });
        document.addEventListener('touchmove', handleJoystickMove, { passive: false });
        document.addEventListener('touchend', handleJoystickEnd, { passive: false });
        document.addEventListener('touchcancel', handleJoystickEnd, { passive: false });

        // Ability Button Listener
        joystick.abilityButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleAbilityPress();
        }, { passive: false });

        // Load saved mobile controls preference
        if (localStorage.getItem('mobileControlsEnabled') === 'true') {
            document.body.classList.add('mobile-controls-active');
        }
    }

    function handleJoystickStart(e) {
        e.preventDefault();
        if (joystickState.active) return;
        const touch = e.changedTouches[0];
        joystickState.active = true;
        joystickState.touchId = touch.identifier;
        joystickState.baseRect = joystick.base.getBoundingClientRect();
        handleJoystickMove(e); // Process initial position
    }

    function handleJoystickMove(e) {
        if (!joystickState.active) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
        if (!touch) return;

        const baseCenterX = joystickState.baseRect.left + joystickState.baseRect.width / 2;
        const baseCenterY = joystickState.baseRect.top + joystickState.baseRect.height / 2;
        
        let dx = touch.clientX - baseCenterX;
        let dy = touch.clientY - baseCenterY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const maxDist = joystickState.baseRect.width / 4; // Stick can move 1/4 of the base width from center

        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }

        joystick.stick.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickState.input.x = dx / maxDist;
        joystickState.input.y = dy / maxDist;
    }

    function handleJoystickEnd(e) {
        const touch = Array.from(e.changedTouches).find(t => t.identifier === joystickState.touchId);
        if (!touch) return;

        joystickState.active = false;
        joystickState.touchId = null;
        joystick.stick.style.transform = `translate(0, 0)`;
        joystickState.input = { x: 0, y: 0 };
    }

    function handleAbilityPress() {
        if (store.isPaused || store.isGameOver) return;
        const p = store.player;

        switch(p.pilotGenome) {
            case 'voidmancer':
                // Blink in the direction of joystick input, or straight ahead if idle
                const targetAngle = Math.atan2(joystickState.input.y, joystickState.input.x);
                const targetDist = 200; // Blink distance
                const target = {
                    x: p.x + (joystickState.input.x !== 0 ? Math.cos(targetAngle) * targetDist : 0),
                    y: p.y + (joystickState.input.y !== 0 ? Math.sin(targetAngle) * targetDist : p.y - targetDist)
                };
                tryVoidStep(p, target);
                break;
            case 'beef':
                // Manually trigger the charge ability
                p.isRequestingCharge = true; // A flag for the stepPlayer function
                break;
            default:
                // Default to grenade for other classes
                useGrenade();
                break;
        }
    }

    function updateAbilityButtonIcon() {
        const p = store.player;
        let iconUrl = '';

        // Determine icon based on class and subclass
        switch(p.pilotGenome) {
            case 'beef':
                iconUrl = p.subclass === 'marauder' ? 'marauder.png' : 'jug2.png';
                break;
            case 'voidmancer':
                iconUrl = p.subclass === 'phasestriker' ? 'phase.png' : 'storm.png';
                break;
            default:
                iconUrl = 'https://i.imgur.com/example.png'; // Placeholder for Grenade Icon
                break;
        }
        joystick.abilityIcon.style.backgroundImage = `url('${iconUrl}')`;
    }


    // --- NEW FLAME PARTICLE CLASS ---
class FlameParticle {
    constructor(x, y, attachedEnemy = null) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 40; // Less horizontal spread
        this.vy = -20 - Math.random() * 30; // Slower upward drift
        this.life = 8.4 + Math.random() * 5.6; // 40% longer: 8.4-14 seconds (was 6-10)
        this.maxLife = this.life;
        this.visualLife = this.life * 1.5; // Visual effect lasts 50% longer than mechanics
        this.maxVisualLife = this.visualLife;
        this.size = 8 + Math.random() * 8; // Smaller, more varied sizes
        this.attachedEnemy = attachedEnemy;
        this.damage = 0.45;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.5 + Math.random() * 1;
        this.heat = 0.8 + Math.random() * 0.2; // Start hot
        this.flickerOffset = Math.random() * 1000;
        this.baseSize = this.size;
        this.gravity = 15; // Slight downward pull for realistic behavior
        this.isDying = false;
    }

    update(dt) {
        this.life -= dt;
        this.visualLife -= dt;
        if (this.visualLife <= 0) return false; // Remove particle when visual effect ends

        // Physics - only apply when mechanically active
        if (this.life > 0) {
            this.vy += this.gravity * dt;
            this.vy -= 25 * dt;
            this.x += this.vx * dt;
            this.y += this.vy * dt;

            // Air resistance
            this.vx *= 0.98;
            this.vy *= 0.98;

            // Wobble
            this.wobble += this.wobbleSpeed * dt;
            this.x += Math.sin(this.wobble) * 8 * dt;
        }

        // Heat and void effect - based on VISUAL life for slower fade
        const visualLifeRatio = this.visualLife / this.maxVisualLife;
        this.heat = Math.max(0.2, visualLifeRatio * 0.8); // Minimum heat to avoid pure transparency

        // Size changes - based on visual life for slower shrinking
        if (visualLifeRatio > 0.7) {
            this.size = this.baseSize * (1 + (1 - visualLifeRatio) * 2); // Grow when young
        } else {
            this.size = Math.max(this.baseSize * 0.5, this.baseSize * visualLifeRatio); // Don't shrink below 50% of base
        }

        this.isDying = visualLifeRatio < 0.3;
        return true;
    }

    draw() {
        if (this.visualLife <= 0 || this.size <= 0) return;
        if (!Number.isFinite(this.x) || !Number.isFinite(this.y)) return;

        const alpha = this.heat;
        
        // Simple flame with just 3 circles - no crackling, no sparkles
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Outer glow - simple and clean
        ctx.fillStyle = `rgba(60, 30, 100, ${alpha * 0.2})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 1.2, 0, 6.283185);
        ctx.fill();
        
        // Middle flame
        ctx.fillStyle = `rgba(100, 50, 150, ${alpha * 0.4})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.7, 0, 6.283185);
        ctx.fill();
        
        // Core flame
        ctx.fillStyle = `rgba(140, 70, 190, ${alpha * 0.6})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.3, 0, 6.283185);
        ctx.fill();
        
        ctx.restore(); // Reset blending mode
    }
}


    cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
    cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    
    // --- AUDIO ---
    const bgm = q('bgmAudio');
    const sounds = {
        explosion: q('audioExplosion'),
        horn: q('audioHorn'),
        hit: q('audioHit'),
        trap: q('audioTrap'),
        dogs: q('audioDogs'),
        charge: q('audioCharge'),
        beefCharge: q('audioBeefCharge'),
        epicHorn: q('audioEpicHorn'),
        cluster: q('audioCluster'),
        thunder: q('audioThunder'),
        shao_kahn: q('audioShaoKahn')
    };
    let lastExplosionSoundTime = 0;
    let lastBossHitSoundTime = 0;
    let lastClusterSoundTime = 0;
    
    function playSound(name) {
        const audio = sounds[name];
        if (!audio) return;
        const now = performance.now();
        if (name === 'explosion') {
            if (now - lastExplosionSoundTime < 50) return;
            lastExplosionSoundTime = now;
        }
        if (name === 'cluster') {
            if (now - lastClusterSoundTime < 150) return; // Increased from 60ms to 150ms
            lastClusterSoundTime = now;
        }
        if (name === 'hit') {
            if (now - lastBossHitSoundTime < 100) return;
            lastBossHitSoundTime = now;
        }
        audio.currentTime = 0;
        audio.play().catch(e => {});
    }


    // --- GAME STATE & DATA ---
    const player_initial_state = {
        x: W / 2, y: H * 0.8, r: 14, hp: 50, hpMax: 50, fireT: 0, speed: 380, dmgMult: 1.2, fireRate: 0.16,
        vampirism: 0, shield: 50, shieldMax: 50, multishot: 2, isInvincible: false, piercing: 0, explosive: false,
        hasShieldBubble: false, powerupTimers: {},
        upgradeLevels: { dmg: 0, speed: 0, hp: 0, max_shield: 0, crit_chance: 0, ghost_hounds: 0, launcher: 0, lazarus_beam: 0, gravity_well: 0 },
        grenades: 0, hasVoidBeam: false, voidBeamCooldown: 0,
        hasLazarusBeam: false, lazarusBeamCooldown: 0,
        hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 0, vampirismLevel: 0, flamethrowerLevel: 0,
        flamethrowerT: 0, // Separate timer for lava chunks, unaffected by overclock
        luckBoost: 0, magnetRadius: 0, hasIceman: false, critChance: 0.02, critDamage: 1.85,
        pilotGenome: null, missileVolley: 2,
        hasRearGuard: false, rearGuardCooldown: 0, rearGuardReady: true,
        rearMultishot: 0, addFrontNext: true,
        flameWallCooldown: 0,
        flameWallActiveT: 0,
        beefChargeState: 'ready', beefChargeCooldown: 0, beefChargeOrigin: null, beefChargeTarget: null, beefChargeT: 0, beefCharges: 1, beefMaxCharges: 1,
        beefDoubleCharge: false, beefBigExplosion: false, // New skill tree abilities
        beefChainTargets: [], beefChainIndex: 0, beefChainMode: false, // Chain jumping system for marauder
        hasChainLightning: false, chainLightningCooldown: 0, stormstrikerLevel: 0, lightningAlternate: false, lightningCycleIndex: 0, chainLightningDamage: 1.0,
        phasestRikerLevel: 0, voidLaserRampTime: 0, voidLaserLastTarget: null,
        subclass: null, missilePierce: 0, missileCluster: false, blinkDamage: false,
        enhancedClusters: false, enhancedPierce: false, hasStormcaller: false, hasPhasestriker: false,
        // Void caller enhanced options
        hasDoubleStorm: false, hasHybridVoid: false, hasImpactPhase: false,
        // Skill tree progress
        skillPoints: 0, skillPointsSpent: 0, skillTree: { juggernaut: false, marauder: false, double_charge: false, big_explosion: false, triple_charge: false },
        clusterSoundCounter: 0,
        // EMP nova effects
        empDisabled: false, empDisabledTimer: 0
    };
    
    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        isDamageOff: false,
        savedPlayerState: null,
        world: { 
            wave: 1, 
            score: 0, 
            gold: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0,
            waveTransitionTimer: null, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            lateGameDamageScaling: 1,
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            isLowHealth: false,
            // Temporal Warp System
            temporalAnomalyTriggered: false,
            isTemporalWarp: false,
            temporalWarpPhase: null, // 'transform', 'waves', 'boss', 'death', 'return'
            temporalWarpTimer: 0,
            temporalOriginalStats: null,
            temporalQuestUnlocked: false
        },
        player: { ...player_initial_state },
        boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], hounds: [], missiles: [], lasers: [], mines: [], activeEffects: [],
        flameParticles: [],
        lightningBolts: [],
        empNovas: [],
        mechPuddles: [], // Hazardous puddles left by mech tank attacks
        iceman: null,
        // Object pools for performance optimization
        bulletPool: [],
        eBulletPool: [],
        _startTs: performance.now(),
        cheatInvincibilityCooldown: 0,
        cheatDogHealCooldown: 0,
        heartbeatT: 0,
        cheatsUsed: false
    };

    // --- OBJECT POOLING SYSTEM ---
    function getBulletFromPool(props = {}) {
        let bullet;
        if (store.bulletPool.length > 0) {
            bullet = store.bulletPool.pop();
            // Reset all properties to default
            Object.assign(bullet, {
                x: 0, y: 0, vx: 0, vy: 0, r: 3, col: "#b266ff", 
                dmg: 0, pierce: false, explosive: false, dead: false,
                life: undefined, isSwirl: false, isFlame: false,
                isIceman: false, isDrone: false, isLevelUpPulse: false,
                fadeInTime: undefined, spawnTime: undefined
            });
        } else {
            bullet = {
                x: 0, y: 0, vx: 0, vy: 0, r: 3, col: "#b266ff",
                dmg: 0, pierce: false, explosive: false, dead: false
            };
        }
        
        // Apply custom properties
        Object.assign(bullet, props);
        return bullet;
    }
    
    function getEBulletFromPool(props = {}) {
        let bullet;
        if (store.eBulletPool.length > 0) {
            bullet = store.eBulletPool.pop();
            // Reset all properties to default
            Object.assign(bullet, {
                x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                dmg: 0, dead: false, life: undefined,
                fadeInTime: undefined, spawnTime: undefined,
                bounceCount: 0, maxBounces: 0, type: undefined
            });
        } else {
            bullet = {
                x: 0, y: 0, vx: 0, vy: 0, r: 4, col: "#FF0000",
                dmg: 0, dead: false
            };
        }
        
        // Apply custom properties
        Object.assign(bullet, props);
        return bullet;
    }
    
    function returnBulletToPool(bullet) {
        if (store.bulletPool.length < 1000) { // Cap pool size
            store.bulletPool.push(bullet);
        }
    }
    
    function returnEBulletToPool(bullet) {
        if (store.eBulletPool.length < 1000) { // Cap pool size
            store.eBulletPool.push(bullet);
        }
    }

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', icon: 'üí•', desc: '+6% damage', apply: () => { store.player.dmgMult *= 1.06; } },
        { id: 'fire', name: 'OVERCLOCK', icon: 'üî•', desc: '+6% fire rate', apply: () => { store.player.fireRate *= 0.60; } },
        { id: 'multi', name: 'SCATTER PROTOCOL', icon: '‚òÑÔ∏è', desc: '+1 projectile', apply: () => {
            const p = store.player;
            if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
        }},
        { id: 'shield', name: 'VOID SHIELD', icon: 'üõ°Ô∏è', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'flamethrower', name: 'LAVA CHUNKS', icon: 'üåã', desc: 'Spews chunks of molten rock in a cone.', apply: () => { store.player.flamethrowerLevel++; } },
        
        // ‚ó¢‚ó£ ENTROPY REDUCTION ENGINE UPGRADES - MULTI-PILOT ‚ó£‚ó¢ [DISABLED FOR STABILITY]
        /*
        { id: 'stellarRegeneration', name: 'STELLAR REJUVENATION', icon: 'üåü', desc: 'Rekindle dying stars and prevent heat death. +50% entropy efficiency.', 
          available: () => ENTROPY_ENGINE.active,
          apply: () => { 
              ENTROPY_ENGINE.maxwellDemons += 2; 
              ENTROPY_ENGINE.quantumCoherence *= 1.5; 
              console.log('üåü STELLAR REJUVENATION ACTIVATED - The universe is saved! üåü');
              console.log(`Enhanced efficiency for ${store.player.pilotGenome.toUpperCase()} pilot entropy system`);
          } },
        { id: 'negentropicField', name: 'NEGENTRIOPIC FIELD', icon: '‚öõÔ∏è', desc: 'Generate pure order from chaos. +15% damage based on entropy reduced.', 
          available: () => ENTROPY_ENGINE.active,
          apply: () => { 
              ENTROPY_ENGINE.negentropicField += 0.15; 
              store.player.dmgMult *= (1 + Math.abs(ENTROPY_ENGINE.entropyReduction) * 1e15);
              console.log(`‚öõÔ∏è NEGENTRIOPIC FIELD ENHANCED: ${(ENTROPY_ENGINE.negentropicField * 100).toFixed(1)}% bonus for ${store.player.pilotGenome.toUpperCase()} pilot`);
          } },
        */
          
        // ‚ó¢‚ó£ TEMPORAL TECHNOLOGY UPGRADES ‚ó£‚ó¢
        { id: 'temporalStabilizer', name: 'TEMPORAL STABILIZER', icon: 'üï∞Ô∏è', desc: 'Harness future knowledge. +25% XP from all sources.', 
          available: () => store.world.temporalQuestUnlocked,
          apply: () => { 
              store.world.xpMultiplier *= 1.25;
              console.log('üï∞Ô∏è TEMPORAL STABILIZER: Future knowledge accelerates learning');
          } },
        { id: 'causalityEngine', name: 'CAUSALITY ENGINE', icon: '‚öõÔ∏è', desc: 'Manipulate cause and effect. Critical hits restore 5 HP.', 
          available: () => store.world.temporalQuestUnlocked,
          apply: () => { 
              store.player.temporalHealing = (store.player.temporalHealing || 0) + 5;
              console.log('‚öõÔ∏è CAUSALITY ENGINE: Critical strikes bend spacetime');
          } },
        { id: 'chronoBlast', name: 'CHRONO BLAST', icon: 'üí´', desc: 'Time-dilated projectiles. +1 multishot, bullets move 50% faster.', 
          available: () => store.world.temporalQuestUnlocked,
          apply: () => { 
              store.player.multishot++;
              store.player.temporalSpeedBoost = (store.player.temporalSpeedBoost || 1) * 1.5;
              console.log('üí´ CHRONO BLAST: Relativistic ammunition engaged');
          } }
    ];
    
    const SHOP_UPGRADES = {
        'repair': { name: "NANO REPAIR", icon: 'üîß', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'vampirism': {
            name: "VAMPIRIC ROUNDS", icon: 'ü©∏', isPremium: true, max: 4, category: 'utility',
            apply: () => {
                const p = store.player; const cost = 12 + (p.vampirismLevel * 5);
                if (store.world.gold >= cost && p.vampirismLevel < 4) { store.world.gold -= cost; p.vampirismLevel++; p.vampirism += 0.03; p.dmgMult += 0.04; return true; } return false;
            },
            desc: () => {
                const p = store.player; if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                const cost = 12 + (p.vampirismLevel * 5); return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
            }
        },
        'hp': { 
            name: "MAX HP", 
            icon: '‚ù§Ô∏è', 
            baseCost: 40, 
            scale: 1.4, 
            maxLevel: 20, 
            category: 'health', 
            effect: (level) => { 
                const p = store.player;
                // Scale HP upgrades with current wave for late game viability
                let hpIncrease = 10;
                if (store.world.wave > 20) {
                    // After wave 20, HP upgrades scale with wave
                    hpIncrease = 10 + (store.world.wave - 20) * 2;
                }
                p.hpMax += hpIncrease; 
                p.hp += hpIncrease;
                // console.log(`HP upgrade: +${hpIncrease} HP (wave ${store.world.wave})`);
            }, 
            desc: level => {
                let hpIncrease = 10;
                if (store.world.wave > 20) {
                    hpIncrease = 10 + (store.world.wave - 20) * 2;
                }
                return `+${hpIncrease} Max HP (Lvl ${level + 1})`;
            }
        },
        'nano_save': { name: "NANO SAVE", icon: 'üíæ', cost: 25, isPremium: true, max: 3, category: 'utility', apply: () => { if (store.player.nanoSaves < 3) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Auto-heals on low HP. Charges: ${store.player.nanoSaves}/3` },
        'luck_boost': { name: "LUCK BOOST", icon: 'üçÄ', baseCost: 50, scale: 2, maxLevel: 5, category: 'utility', effect: (level) => { store.player.luckBoost = (store.player.luckBoost || 0) + (0.15 / Math.pow(2, level)); }, desc: level => `+${(0.15 / Math.pow(2, level) * 100).toFixed(1)}% drop chance (Lvl ${level + 1})` },
        'dmg': { name: "DAMAGE", icon: 'üí™', baseCost: 50, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult *= 1.06, desc: level => `+6% Damage (Lvl ${level + 1})` },
        'crit_chance': { name: "SHINOBI REFLEXES", icon: 'ü•∑', baseCost: 40, increment: 24, maxLevel: 10, category: 'attack', effect: () => { store.player.critChance *= 1.5; store.player.critDamage *= 1.5; }, desc: level => `+50% Crit Chance & Dmg (Lvl ${level + 1})` },
        'speed': { name: "SPEED", icon: 'üöÄ', baseCost: 60, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed *= 1.10, desc: level => `+10% Speed (Lvl ${level + 1})` },
        'grenade': { name: "NOVA GRENADE", icon: 'üí•üí£üí•', cost: 70, isPremium: true, max: 3, category: 'attack', apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'max_shield': { 
            name: "MAX SHIELD", 
            icon: 'üõ°Ô∏è', 
            baseCost: 80, 
            scale: 1.8, 
            maxLevel: 20, // Increased max level
            category: 'health', 
            effect: (level) => { 
                const p = store.player;
                if (level < 5) {
                    // First 5 levels: +25 flat shield
                    p.shieldMax += 25; 
                    p.shield += 25;
                } else {
                    // Levels 6+: +25% of current max shield
                    const increase = Math.floor(p.shieldMax * 0.25);
                    p.shieldMax += increase;
                    p.shield += increase;
                }
            }, 
            desc: level => {
                if (level < 5) {
                    return `+25 Max Shield (Lvl ${level + 1})`;
                } else {
                    return `+25% Max Shield (Lvl ${level + 1})`;
                }
            }
        },
        'mine_wall': { name: "MINE WALL", icon: 'üí£', cost: 80, isPremium: true, max: 2, category: 'attack', apply: () => { const activeWalls = store.mines.filter(m => m.isWallMine).length > 0; if(!activeWalls) { deployMineWall(); return true; } return false; }, desc: () => `Deploy a wall of mines.` },
        'rear_guard': { name: 'AFT FLANKSHIELD', icon: 'üõ°Ô∏è‚ú®', baseCost: 130, scale: 2, maxLevel: 2, category: 'utility', effect: (level) => { if (level === 0) store.player.hasRearGuard = true; else store.player.rearGuardCooldown = 6; }, desc: level => level === 0 ? `Blocks one enemy volley from behind every 8s.` : `Reduce cooldown to 6s.` },
        'launcher': {
                name: 'FRAG LAUNCHER',
                icon: 'üí•',
                baseCost: 100,
                scale: 2,
                maxLevel: 3,
                category: 'attack',
                effect: () => {
                    store.player.hasLauncher = true;
                },
                desc: level => {
                    if (level === 0) return `Unlocks launcher (2 projectiles).`;
                    if (level === 1) return `Add 2 projectiles (4 total).`;
                    if (level === 2) return `Add 2 more projectiles (6 total).`;
                    return "Max projectiles reached.";
                }
            },
        'iceman': { name: "THE ICEMAN", icon: '‚ùÑÔ∏è', cost: 118, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.hasIceman) { store.player.hasIceman = true; store.iceman = { x: store.player.x, y: store.player.y + 50, t: 0 }; return true; } return false; }, desc: () => `A clone mirrors your attacks.` },
        'lazarus_beam': { name: "LORD LAZARUS", icon: '‚ò¢Ô∏è‚òÑÔ∏è‚ò¢Ô∏è', baseCost: 200, scale: 3, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasLazarusBeam = true; store.player.lazarusBeamCooldown = 15; } }, desc: level => { if (level === 0) return 'Lazarus smites foes twice as often.'; if (level === 1) return 'Lazarus fires two beams at once.'; return 'Max Level'; }},
        'magnet_pull': { name: "GRAV-PULSE", icon: 'üß≤', cost: 90, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (store.player.magnetRadius <= 0) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Pulls in nearby powerups.` },
        'gravity_well': { name: "GRAVITY WELL", icon: 'üï≥Ô∏è', baseCost: 300, scale: 2, maxLevel: 2, category: 'attack', effect: (level) => { if (level === 0) { store.player.hasVoidBeam = true; store.player.voidBeamCooldown = 15; }}, desc: level => { if (level === 0) return 'Unleash a singularity that traps and crushes foes.'; if (level === 1) return 'Summon a second, smaller singularity.'; return 'Max Level'; }},
        'ghost_hounds': { name: "GHOST HOUNDS", icon: 'üëªüê∫', baseCost: 150, scale: 2, maxLevel: 2, category: 'attack', effect: () => { if (!store.player.hasHounds) { store.player.hasHounds = true; store.hounds = [createHound(-1), createHound(1)]; } else { store.hounds.push(createHound(-2)); store.hounds.push(createHound(2)); } playSound('dogs'); }, desc: level => { if (level === 0) return `Unlocks 2 spectral hounds.`; if (level === 1) return `Add 2 more hounds.`; return "Max hounds reached."; } }
    };
    
    const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: '‚¨ÜÔ∏è', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'üöÅ', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'üõ°Ô∏è', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: '‚ù§Ô∏è', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'üöÄ', duration: 20, type: 'timed' }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) {
        if (store.world.powerupCooldown > 0) return;
        const p = store.player;
        const baseChance = 0.075;
        const wave = store.world.wave;
        const waveReductionFactor = 0.0025;
        let finalChance = Math.max(0.025, baseChance - (wave - 1) * waveReductionFactor);
        let types = Object.keys(POWERUP_TYPES);
        let bonusType = null;
        if (p.pilotGenome === 'beef') {
            // Enhanced drop rates for beef - additional powerups, not replacing existing ones
            if (Math.random() < 0.4) bonusType = 'shield'; // Increased from 0.25 to 0.4
            else if (Math.random() < 0.3) bonusType = 'repair'; // Increased from 0.15 to 0.3
            // Also boost the base chance for beef pilots
            finalChance *= 1.3; // 30% higher overall powerup drop rate
        }
        if (p.pilotGenome === 'rocketman') {
            // Significantly boost missile powerup rates for rocketman
            if (Math.random() < 0.5) bonusType = 'missile'; // 50% chance for missile powerups
            finalChance *= 2.0; // Double overall powerup drop rate
            // Extra chance if rocketman doesn't currently have missiles active
            if (!p.powerupTimers.missile || p.powerupTimers.missile.remaining <= 3) {
                if (Math.random() < 0.3) bonusType = 'missile'; // Extra 30% chance when missiles are low/inactive
            }
        }
        const roll = Math.random();
        if (roll > finalChance && !bonusType) return;
        let typeKey;
        if (bonusType && (roll <= finalChance || Math.random() < 0.5)) {
            typeKey = bonusType;
        } else {
            typeKey = types[Math.floor(Math.random() * types.length)];
        }
        store.powerups.push({ x, y, r: 12, type: typeKey });
        store.world.powerupCooldown = 5;
    }
    
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
        if (typeKey === 'missile') {
            if (p.pilotGenome === 'rocketman') { p.missileVolley = Math.min(5, p.missileVolley + 2); } else { p.missileVolley = 2; }
        }
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; }
            else {
                if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') {
                const p = store.player;
                if (p.multishot < 5) { p.multishot++; } else { if (p.addFrontNext) { p.multishot++; } else { p.rearMultishot = (p.rearMultishot || 0) + 1; } p.addFrontNext = !p.addFrontNext; }
                announce('SCATTER SHOT!');
            }
        }
        announce(powerup.name);
    }

    function initWave() {
        const isBossWave = store.world.wave % 5 === 0;
        
        // Clear poison puddles at start of each wave for clean slate
        if (store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        
        if (isBossWave) {
            store.enemies = [];
            
            // FIXED: Balanced boss scaling instead of aggressive exponential growth
            // Old: 1 + (wave/5 - 1) * 1.5 caused 4x HP by wave 15
            // New: Gentler scaling with reasonable progression
            let bossHpScale;
            if (store.world.wave <= 5) {
                bossHpScale = 1; // No scaling for early bosses
            } else if (store.world.wave <= 15) {
                bossHpScale = 1 + (store.world.wave - 5) * 0.2; // +20% per wave 6-15
            } else {
                bossHpScale = 1 + 10 * 0.2 + (store.world.wave - 15) * 0.1; // +10% per wave after 15
            }
            
            store.boss = createBoss(bossHpScale);
            store.world.bossSpawnTime = performance.now();
            if (store.boss.name === 'VOID SENTINEL') playSound('trap');
            else if (store.boss.name === 'NEURAL CORE') playSound('horn');
            announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
        } else {
            store.enemies = [];
            
            // NEW SCALING SYSTEM: After wave 35, stop increasing spawn count and increase enemy stats instead
            let baseSpawnCount, spawnCount, lateGameScaling = 1;
            
            if (store.world.wave <= 35) {
                // Normal scaling: increase spawn count with waves
                baseSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                spawnCount = baseSpawnCount;
            } else {
                // Wave 35+: Cap spawn count, scale enemy stats instead
                baseSpawnCount = Math.floor((7 + Math.floor(35 * 1.8)) * store.world.enemyDensityBonus);
                spawnCount = Math.max(1, Math.floor(baseSpawnCount * 0.8)); // Slightly fewer enemies for performance
                
                // Calculate what the spawn count WOULD have been, use that as scaling factor
                const theoreticalSpawnCount = Math.floor((7 + Math.floor(store.world.wave * 1.8)) * store.world.enemyDensityBonus);
                lateGameScaling = theoreticalSpawnCount / baseSpawnCount; // This becomes our health/damage multiplier
            }
            
            // Store late-game scaling factor globally for damage calculations
            store.world.lateGameDamageScaling = lateGameScaling;
            
            // Apply collar bonus to spawn count
            const collarBonus = 1 + (store.world.collarStacks * 0.08);
            spawnCount = Math.floor(spawnCount * collarBonus);
            
            // console.log(`Wave ${store.world.wave}: Spawning ${spawnCount} enemies (base: ${baseSpawnCount}, lateGameScaling: ${lateGameScaling.toFixed(2)}x)`);
            
            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter'];
                if (store.world.wave > 3) types.push('phantom');
                if (store.world.wave > 5) types.push('mech');
                if (store.world.wave > 7) types.push('angler');
                if (store.world.wave > 9) types.push('manta');
                
                const enemy = spawnEnemy(types[Math.floor(Math.random() * types.length)]);
                
                // Apply late-game scaling to health and damage
                if (lateGameScaling > 1) {
                    enemy.hp *= lateGameScaling;
                    enemy.hpMax *= lateGameScaling;
                    enemy.damage = (enemy.damage || 10) * lateGameScaling; // Scale damage too
                }
                
                // console.log(`Spawned ${enemy.type} at (${enemy.x.toFixed(1)}, ${enemy.y.toFixed(1)}) with ${enemy.hp} HP`);
                store.enemies.push(enemy);
            }
            
            // console.log(`Total enemies spawned: ${store.enemies.length}`);
            store.world.waveStartTime = performance.now();
            announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
        }
    }
    
    function createBoss(scale) {
        const bossCycle = Math.floor((store.world.wave - 5) / 5) % 5;
        const types = [
            { name: 'VOID SENTINEL', baseHp: 1700, r: 55, behavior: 'sentinel', color: '#8B4A9C' },
            { name: 'NEXUS PHANTOM', baseHp: 2200, r: 50, behavior: 'hex', color: '#66aaff'},
            { name: 'NEURAL CORE', baseHp: 3200, r: 60, behavior: 'malignus', color: '#2E8B57' },
            { name: 'DEATH ENGINE', baseHp: 9000, r: 90, behavior: 'construct', color: '#e54d24', phase: 1, isLaughing: false, laughStartTime: 0, visible: true },
            { name: 'HIVE SOVEREIGN', baseHp: 8500, r: 85, behavior: 'broodlord', color: '#2d5016' }
        ];
        const type = types[bossCycle];
        let hp = type.baseHp * scale * store.world.bossHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks * 0.08); // 8% increase per collar stack
        hp *= collarBonus;
        
        const boss = { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, isEnraged: false, attackPhase: 0, phaseTimer: 0 };
        
        // console.log(`üèÜ Boss Created: ${boss.name} | Wave: ${store.world.wave} | HP: ${hp} | Scale: ${scale} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x`);
        
        // Create Boss class instance for DEATH ENGINE
        if (boss.name === 'DEATH ENGINE') {
            boss.skullRenderer = new Boss(ctx, boss.x, boss.y, boss.color);
            // Store collar stacks before Death Engine fight to restore them after
            store.world.deathEngineCollarStacks = store.world.collarStacks;
            console.log(`Death Engine spawned - preserving ${store.world.deathEngineCollarStacks} collar stacks`);
        }
        
        return boss;
    }

    function spawnEnemy(type = 'drone') {
        const cfgs = {
            drone: { r: 10, v: 80, vx: 0, hp: 22, color: '#C0C0C0', xp: 5, score: 50, gold: 2, fireRateChance: 0.004 },
            hunter: { r: 20, v: 100, vx: 0, hp: 18, color: '#DC143C', xp: 8, score: 80, gold: 2, fireRateChance: 0.005 },
            trap_king_add: { r: 6, v: 90, vx: 0, hp: 9, color: '#ffc83d', damage: 5, xp: 2, score: 10, gold: 1 },
            phantom: { r: 14, v: 90, vx: 0, hp: 35, color: '#FFFFFF', xp: 10, score: 100, gold: 3, fireRateChance: 0.006, fireCooldown: 1.5 },
            mech: { r: 18, v: 40, vx: 0, hp: 73, color: '#FF8500', xp: 15, score: 150, gold: 5, fireRateChance: 0.007, attackPhase: 0 },
            construct_gold: { r: 10, v: 120, vx: 0, hp: 17, color: '#e03434', xp: 3, score: 30, gold: 1 },
            avian_hatchling: { r: 8, v: 150, vx: 0, hp: 22, color: '#9370DB', xp: 4, score: 40, gold: 1 },
            angler: { r: 22, v: 30, vx: 0, hp: 150, color: '#00008b', xp: 18, score: 180, gold: 4, fireRateChance: 0.008 },
            manta: { r: 26, v: 50, vx: 0, hp: 175, color: '#53B6FF', xp: 22, score: 220, gold: 5, fireRateChance: 0.009 }
        };
        let c = { ...cfgs[type] }; const wave = store.world.wave;
        
        // FIXED: Much gentler health scaling to prevent unkillable enemies
        // Old: Math.pow(1.075, wave) - exponential growth was too aggressive
        // New: Linear growth with soft cap
        let waveMultiplier;
        if (wave <= 10) {
            waveMultiplier = 1 + (wave - 1) * 0.15; // +15% per wave early game
        } else {
            waveMultiplier = 1 + 9 * 0.15 + (wave - 10) * 0.05; // +5% per wave after wave 10
        }
        
        c.hp *= waveMultiplier * store.world.enemyHealthBonus;
        const collarBonus = 1 + (store.world.collarStacks * 0.08); // 8% increase per collar stack
        c.hp *= collarBonus;
        
        // console.log(`üîç Enemy Health Debug | Type: ${type} | Base: ${cfgs[type].hp} | Wave: ${wave} | WaveMult: ${waveMultiplier.toFixed(2)} | EnemyBonus: ${store.world.enemyHealthBonus.toFixed(2)} | CollarBonus: ${collarBonus.toFixed(2)} | Final HP: ${c.hp.toFixed(1)}`);
        const e = { ...c, type, id: Date.now() + Math.random(), x: 20 + Math.random() * (W - 40), y: -50 - Math.random() * 250, hpMax: c.hp, phase: type === 'phantom', t: 0, fireT: (c.fireCooldown || 0), isBursting: false, burstTimer: 0, stunTimer: 0, knockback: null };
        if (e.type === 'manta') { e.startX = e.x; e.amplitude = 150 + Math.random() * 100; e.frequency = 0.5 + Math.random() * 0.5; e.dodgeCooldown = 0; e.isDodging = false; }
        return e;
    }

    function stepPlayer(dt) {
        const p = store.player;
        if (p.pilotGenome === 'beef' && p.beefChargeState !== 'ready' && p.beefMaxCharges > 0) {
            p.beefChargeT += dt;
            const chargeDuration = 0.25; const returnDuration = 0.35;
            if (p.beefChargeState === 'charging') {
                const progress = Math.min(p.beefChargeT / chargeDuration, 1);
                p.x = p.beefChargeOrigin.x + (p.beefChargeTarget.x - p.beefChargeOrigin.x) * progress;
                p.y = p.beefChargeOrigin.y + (p.beefChargeTarget.y - p.beefChargeOrigin.y) * progress;
                if (progress >= 1) { 
                    // Check if we're in chain mode and have more targets
                    if (p.beefChainMode && p.beefChainIndex < p.beefChainTargets.length - 1) {
                        // Move to next chain target
                        p.beefChainIndex++;
                        p.beefChargeOrigin = { x: p.x, y: p.y }; // Current position becomes new origin
                        p.beefChargeTarget = { x: p.beefChainTargets[p.beefChainIndex].x, y: p.beefChainTargets[p.beefChainIndex].y };
                        p.beefChargeT = 0; // Reset timing for next jump
                        // console.log(`Chaining to target ${p.beefChainIndex + 1} of ${p.beefChainTargets.length}`);
                    } else {
                        // Chain complete - stay at final position for chain mode, or return for single charge
                        if (p.beefChainMode) {
                            // Chain complete - stay here and reset
                            p.beefChargeState = 'ready'; 
                            p.isInvincible = false;
                            p.beefChainTargets = [];
                            p.beefChainIndex = 0;
                            // console.log('Chain jumping complete!');
                        } else {
                            // Single charge - return to origin
                            p.beefChargeState = 'returning'; 
                            p.beefChargeT = 0; 
                        }
                    }
                }
            } else if (p.beefChargeState === 'returning') {
                // Only used for single charge mode (non-marauder)
                const progress = Math.min(p.beefChargeT / returnDuration, 1);
                p.x = p.beefChargeTarget.x + (p.beefChargeOrigin.x - p.beefChargeTarget.x) * progress;
                p.y = p.beefChargeTarget.y + (p.beefChargeOrigin.y - p.beefChargeTarget.y) * progress;
                if (progress >= 1) { 
                    p.x = p.beefChargeOrigin.x; 
                    p.y = p.beefChargeOrigin.y; 
                    p.beefChargeState = 'ready'; 
                    p.isInvincible = false; 
                }
            }
        } else {
            // MOVEMENT LOGIC
            if (document.body.classList.contains('mobile-controls-active')) {
                // Joystick Movement
                const moveSpeed = p.speed;
                p.x += joystickState.input.x * moveSpeed * dt;
                p.y += joystickState.input.y * moveSpeed * dt;
                p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
            } else {
                // Mouse Movement (Original Logic)
                const vx = mouse.x - p.x, vy = mouse.y - p.y;
                p.x += (vx * p.speed * dt * 0.005); p.y += (vy * p.speed * dt * 0.005);
                p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
            }
        }
        if (p.pilotGenome === 'beef' && p.beefMaxCharges > 0) {
            if (p.beefCharges < p.beefMaxCharges) {
                if (p.beefChargeCooldown > 0) {
                    p.beefChargeCooldown -= dt;
                }
                if (p.beefChargeCooldown <= 0) {
                    p.beefCharges++;
                    if (p.beefCharges < p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                }
            }
            // The charge is triggered either by the button OR automatically by proximity
            const shouldCharge = p.isRequestingCharge || !document.body.classList.contains('mobile-controls-active');

            if (p.beefChargeState === 'ready' && p.beefCharges > 0 && shouldCharge) {
                p.isRequestingCharge = false; // Reset the flag
                const chargeRadius = 120; let closestEnemy = null; let closestDistSq = chargeRadius * chargeRadius;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.stunTimer > 0) return;
                    const dx = e.x - p.x; const dy = e.y - p.y; const distSq = dx * dx + dy * dy;
                    if (distSq < closestDistSq) { closestDistSq = distSq; closestEnemy = e; }
                });
                if (closestEnemy) {
                    if (p.beefCharges === p.beefMaxCharges) {
                        p.beefChargeCooldown = 8;
                    }
                    p.beefCharges--; 
                    
                    // Set up chain jumping system for marauder
                    if (p.beefChainMode && p.beefMaxCharges > 1) {
                        // Find chain targets
                        p.beefChainTargets = [{ x: p.x, y: p.y }]; // Start with player position
                        let currentPos = { x: p.x, y: p.y };
                        
                        // Add targets based on max charges (marauder=2, enhanced=3)
                        for (let i = 0; i < p.beefMaxCharges; i++) {
                            let nextTarget = null;
                            let nextClosestDistSq = 150 * 150; // Chain range
                            
                            potentialTargets.forEach(e => {
                                if (e.dead || e.stunTimer > 0) return;
                                // Don't target the same enemy twice in a row
                                if (p.beefChainTargets.length > 1 && 
                                    Math.abs(e.x - p.beefChainTargets[p.beefChainTargets.length-1].x) < 10 &&
                                    Math.abs(e.y - p.beefChainTargets[p.beefChainTargets.length-1].y) < 10) return;
                                    
                                const dx = e.x - currentPos.x;
                                const dy = e.y - currentPos.y; 
                                const distSq = dx * dx + dy * dy;
                                if (distSq < nextClosestDistSq) { 
                                    nextClosestDistSq = distSq; 
                                    nextTarget = e; 
                                }
                            });
                            
                            if (nextTarget) {
                                p.beefChainTargets.push({ x: nextTarget.x, y: nextTarget.y });
                                currentPos = { x: nextTarget.x, y: nextTarget.y };
                            } else {
                                // No more targets found, end chain
                                break;
                            }
                        }
                        
                        // Start chaining (skip player position)
                        p.beefChainIndex = 0;
                        if (p.beefChainTargets.length > 1) {
                            p.beefChargeOrigin = { x: p.x, y: p.y };
                            p.beefChargeTarget = { x: p.beefChainTargets[1].x, y: p.beefChainTargets[1].y };
                            p.beefChainIndex = 1;
                        } else {
                            // Fall back to single target
                            p.beefChargeOrigin = { x: p.x, y: p.y };
                            p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y };
                        }
                        
                        // console.log(`Chain setup: ${p.beefChainTargets.length} targets for ${p.beefMaxCharges} charges`);
                    } else {
                        // Original single charge system
                        p.beefChargeOrigin = { x: p.x, y: p.y }; 
                        p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y };
                    }
                    
                    p.beefChargeState = 'charging'; 
                    p.beefChargeT = 0; 
                    p.isInvincible = true;
                    store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                    
                    // Calculate impact radius based on skills
                    let impactRadius = 80; // Base radius
                    if (p.skillTree && p.skillTree.juggernaut) impactRadius = 120;
                    if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) impactRadius = 160; // Big explosion
                    
                    // Skill tree compatibility - check subclass for existing players
                    if (p.subclass === 'juggernaut') impactRadius = Math.max(impactRadius, 120);
                    
                    if (p.skillTree && p.skillTree.juggernaut || p.subclass === 'juggernaut') {
                        playSound('charge');
                        explode(closestEnemy.x, closestEnemy.y, false, true);
                    } else {
                        playSound('beefCharge');
                    }
                    
                    // Apply impact damage
                    let baseDamage = 80;
                    if (p.beefBigExplosion || (p.skillTree && p.skillTree.juggernaut_enhanced)) baseDamage = 150; // Big explosion damage
                    
                    potentialTargets.forEach(e => {
                        if (e.dead) return;
                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                        if (distSq < impactRadius * impactRadius) {
                            const chargeDmg = baseDamage * p.dmgMult;
                            e.hp -= chargeDmg; 
                            e.stunTimer = 2.5;
                            
                            // Apply vampirism healing for charge damage
                            if (store.player.vampirism > 0) {
                                let healAmount = chargeDmg * store.player.vampirism;
                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                healAmount = Math.min(healAmount, 8); // Cap at 8 HP for charge
                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                            }
                            
                            const knockbackForce = 250; const angle = Math.atan2(e.y - p.y, e.x - p.x);
                            e.knockback = { vx: Math.cos(angle) * knockbackForce, vy: Math.sin(angle) * knockbackForce, duration: 0.3 };
                        }
                    });
                    
                    // Handle double charge (combo skill)
                    if (p.beefDoubleCharge || (p.skillTree && p.skillTree.combo_charge) && p.beefCharges > 0) {
                        setTimeout(() => {
                            if (p.beefChargeState === 'ready' && p.beefCharges > 0) {
                                // Trigger second charge at same target
                                p.beefCharges--;
                                p.beefChargeState = 'charging'; 
                                p.beefChargeOrigin = { x: p.x, y: p.y }; 
                                p.beefChargeTarget = { x: closestEnemy.x, y: closestEnemy.y }; 
                                p.beefChargeT = 0; p.isInvincible = true;
                                store.activeEffects.push(createEffect("beefCharge", p.beefChargeOrigin, p.beefChargeTarget));
                                
                                setTimeout(() => {
                                    // Second impact (smaller for combo)
                                    if (p.skillTree && p.skillTree.juggernaut || p.subclass === 'juggernaut') {
                                        explode(closestEnemy.x, closestEnemy.y, false, true);
                                    }
                                    potentialTargets.forEach(e => {
                                        if (e.dead) return;
                                        const dx = e.x - closestEnemy.x; const dy = e.y - closestEnemy.y; const distSq = dx * dx + dy * dy;
                                        // Use smaller radius for combo double charge
                                        const comboRadius = 60; 
                                        if (distSq < comboRadius * comboRadius) {
                                            const secondChargeDmg = baseDamage * p.dmgMult * 0.7; // Reduced damage for second hit
                                            e.hp -= secondChargeDmg;
                                            e.stunTimer = Math.max(e.stunTimer, 1.5);
                                            
                                            // Apply vampirism healing for second charge damage
                                            if (store.player.vampirism > 0) {
                                                let healAmount = secondChargeDmg * store.player.vampirism;
                                                healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                                healAmount = Math.min(healAmount, 6); // Cap at 6 HP for second charge
                                                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                            }
                                        }
                                    });
                                }, 400); // Second impact timing
                            }
                        }, 800); // Delay before second charge
                    }
                }
            }
        } else if (p.pilotGenome === 'rocketman' && p.hasFirewall) {
            if (p.flameWallCooldown > 0) p.flameWallCooldown -= dt;
            if (p.flameWallActiveT > 0) p.flameWallActiveT -= dt;
            if (p.flameWallCooldown <= 0) { p.flameWallActiveT = 0.5; p.flameWallCooldown = 10; }
            if (p.flameWallActiveT > 0) {
                for (let i = 0; i < 2; i++) {
                    let attachedEnemy = null;
                    let closestDistSq = Infinity;
                    store.enemies.forEach(enemy => {
                        const distSq = (enemy.x - p.x) * (enemy.x - p.x) + (enemy.y - (p.y + 10)) * (enemy.y - (p.y + 10));
                        if (distSq < 100 * 100 && distSq < closestDistSq) {
                            closestDistSq = distSq;
                            attachedEnemy = enemy;
                        }
                    });
                    store.flameParticles.push(new FlameParticle(p.x, p.y + 10, attachedEnemy));
                }
            }
        } else if (p.pilotGenome === 'voidmancer') {
            if (p.hasChainLightning || p.hasHybridVoid) {
                p.chainLightningCooldown -= dt;
                if (p.chainLightningCooldown <= 0) { 
                    fireChainLightning(); 
                    // Set cooldown based on stormstriker level - more bolts = faster alternation
                    if (p.stormstrikerLevel >= 3) {
                        p.chainLightningCooldown = 0.375; // 4-bolt rotation: quadruple fire rate
                    } else if (p.stormstrikerLevel >= 2) {
                        p.chainLightningCooldown = 0.75; // Alternating bolts: double fire rate
                    } else {
                        p.chainLightningCooldown = 1.5; // Single bolt: normal rate
                    }
                }
            }
            
            // Voidmancer base laser beam system
            if (p.hasVoidLaser) {
                stepVoidLaser(dt);
            }
        }
        if (p.hasIceman && store.iceman) { store.iceman.x = p.x - 50; store.iceman.y = p.y + 40; }
        p.fireT -= dt;
        if (p.fireT <= 0 && !p.empDisabled) { firePlayer(); p.fireT = p.fireRate; }
        
        // Separate flamethrower system (unaffected by overclock)
        if (p.flamethrowerLevel > 0 && !p.empDisabled) {
            p.flamethrowerT -= dt;
            if (p.flamethrowerT <= 0) {
                fireFlamethrower();
                p.flamethrowerT = 0.18; // Fixed fire rate for lava chunks
            }
        }
        
        // Homing Missile system (from powerup)
        if (p.powerupTimers['missile'] && !p.empDisabled) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = p.pilotGenome === 'rocketman' ? 1.0 : 1.2;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });
                if (closest) {
                    const isRocketman = p.pilotGenome === 'rocketman';
                    const missileDmg = isRocketman ? (95 * p.dmgMult * 0.7) : (95 * p.dmgMult);
                    const volleySize = p.missileVolley || 2;
                    
                    for (let i = 0; i < volleySize; i++) {
                        const spreadAngle = (i - (volleySize - 1) / 2) * 0.2;
                        const dx = closest.x - p.x;
                        const dy = closest.y - p.y;
                        const baseAngle = Math.atan2(dy, dx);
                        const finalAngle = baseAngle + spreadAngle;
                        
                        const missile = {
                            x: p.x, y: p.y - 10,
                            vx: Math.cos(finalAngle) * 200,
                            vy: Math.sin(finalAngle) * 200,
                            speed: 200, turnRate: 4.5,
                            target: closest, life: 0,
                            dmg: missileDmg,
                            cluster: isRocketman && p.missileCluster,
                            pierce: isRocketman ? (p.missilePierce || 0) : 0,
                            isIceman: false
                        };
                        store.missiles.push(missile);
                    }
                    playSound('shoot');
                }
            }
        }
        
        /*
        I did not modify the code.
        The base damage for enemy bullets is determined when they are created, primarily within the `stepWorld` function.

        Inside `stepWorld`, a `dmgScale` variable is calculated based on the current wave, collar stacks, and other late-game factors.

        Then, for each enemy type that can fire, a base damage value is set and multiplied by this `dmgScale`.

        Here are some examples from the `stepWorld` function:

        *   **Hunter:** `dmg: 6 * dmgScale`
        *   **Phantom:** `dmg: 5 * dmgScale`
        *   **Mech (Shoulder Cannon):** `dmg: 12 * dmgScale`
        *   **Mech (Lob Attack):** `dmg: 18 * dmgScale`
        *   **Angler:** `dmg: 15 * dmgScale`
        *   **Manta:** `dmg: 12 * dmgScale`
        *   **Default/Drone:** `dmg: 5 * dmgScale`

        The base damage is the hardcoded number (e.g., 6, 5, 12) which is then scaled up as the game progresses. The collision damage from an enemy running into the player is also scaled: `takeDamage(8 * dmgScale)`.
        */
        if (p.shieldMax > 0 && p.shield < p.shieldMax) p.shield = Math.min(p.shieldMax, p.shield + 0.5 * dt);
        for (const key in p.powerupTimers) { p.powerupTimers[key].remaining -= dt; if (p.powerupTimers[key].remaining <= 0) { if (key === 'drones') store.drones = []; delete p.powerupTimers[key]; } }
        if (p.hasRearGuard && p.rearGuardCooldown > 0) { p.rearGuardCooldown -= dt; if (p.rearGuardCooldown <= 0) { p.rearGuardReady = true; } }
        if (p.hasVoidBeam) { p.voidBeamCooldown -= dt; if (p.voidBeamCooldown <= 0) { activateGravityWell(); p.voidBeamCooldown = 30; } }
        if (p.hasLazarusBeam) { p.lazarusBeamCooldown -= dt; if (p.lazarusBeamCooldown <= 0) { activateLazarus(); p.lazarusBeamCooldown = 30 / (p.upgradeLevels.lazarus_beam > 0 ? 2 : 1) ; } }
        if (store.cheatInvincibilityCooldown > 0) store.cheatInvincibilityCooldown -= dt;
        if (store.cheatDogHealCooldown > 0) store.cheatDogHealCooldown -= dt;
        if (p.x < 50 && p.y < 50 && store.cheatInvincibilityCooldown <= 0) {
            store.cheatsUsed = true; p.isInvincible = true; p.cheatMultishotBonus = 2; announce('TEST: INVINCIBILITY ACTIVE');
            setTimeout(() => { p.isInvincible = false; p.cheatMultishotBonus = 0; announce('TEST: INVINCIBILITY ENDS'); store.cheatInvincibilityCooldown = 10; }, 15000);
            store.cheatInvincibilityCooldown = 15 + 10;
        }
        if (p.x > W - 50 && p.y < 50 && store.cheatDogHealCooldown <= 0) {
            store.cheatsUsed = true; p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.20);
            if (!p.hasHounds) { p.hasHounds = true; }
            let houndsToAdd = Math.min(2, 4 - store.hounds.length);
            if (houndsToAdd > 0) {
                const existingSides = new Set(store.hounds.map(h => h.side)); const potentialSides = [-1, 1, -2, 2];
                for (const side of potentialSides) { if (houndsToAdd > 0 && !existingSides.has(side)) { store.hounds.push(createHound(side)); houndsToAdd--; } }
            }
            store.cheatDogHealCooldown = 10; announce('TEST: HEAL & HOUNDS');
        }
        
        // Handle poison effects
        if (p.isPoisoned && performance.now() > p.poisonEndTime) {
            p.isPoisoned = false;
            p.moveSpeed = 100; // Reset to base speed
        }
        
        // Check poison puddle collisions
        if (store.poisonPuddles) {
            store.poisonPuddles.forEach(puddle => {
                const dx = p.x - puddle.x;
                const dy = p.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < puddle.r + p.r) {
                    // Player is in poison puddle - apply damage and effects
                    if (!p.lastPuddleDamageTime || performance.now() - p.lastPuddleDamageTime > 500) {
                        takeDamage(puddle.damage);
                        p.lastPuddleDamageTime = performance.now();
                        
                        // Apply poison debuff
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 3000; // 3 second poison from puddle
                        p.moveSpeed = Math.max(p.moveSpeed * 0.8, 60); // Slow player more
                    }
                }
            });
        }

        // Check mech oil/fuel puddle collisions
        if (store.mechPuddles && store.mechPuddles.length > 0) {
            store.mechPuddles.forEach(puddle => {
                // Calculate current radius with shrinking effect
                const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
                const currentRadius = puddle.r * Math.max(0.3, lifePercent);
                
                const dx = p.x - puddle.x;
                const dy = p.y - puddle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < currentRadius + p.r) {
                    // Player is in hazardous puddle - apply damage and burning effect
                    if (!p.lastMechPuddleDamageTime || performance.now() - p.lastMechPuddleDamageTime > 400) {
                        // console.log('Player in mech puddle! Taking', puddle.damage, 'damage');
                        takeDamage(puddle.damage);
                        p.lastMechPuddleDamageTime = performance.now();
                        
                        // Apply burning/slowing effect
                        p.isBurning = true;
                        p.burnEndTime = performance.now() + 2500; // 2.5 second burn effect
                        
                        // Create burning particle effect
                        for (let i = 0; i < 3; i++) {
                            store.flameParticles.push({
                                x: p.x + (Math.random() - 0.5) * 30,
                                y: p.y + (Math.random() - 0.5) * 30,
                                vx: (Math.random() - 0.5) * 100,
                                vy: -Math.random() * 150,
                                life: 1 + Math.random() * 0.5,
                                maxLife: 1 + Math.random() * 0.5,
                                r: 3 + Math.random() * 4
                            });
                        }
                    }
                }
            });
        }
    }
    function stepPowerups(dt) {
        const p = store.player;
        store.powerups.forEach(powerup => {
            // Handle powerup movement (for Trap King falling powerups)
            if (powerup.vx !== undefined || powerup.vy !== undefined) {
                powerup.x += (powerup.vx || 0) * dt;
                powerup.y += (powerup.vy || 0) * dt;
                
                // Handle powerup lifetime
                if (powerup.life !== undefined) {
                    powerup.life -= dt;
                    if (powerup.life <= 0) {
                        powerup.dead = true;
                        return;
                    }
                }
                
                // Remove powerups that go off screen
                if (powerup.x < -20 || powerup.x > W + 20 || powerup.y < -20 || powerup.y > H + 20) {
                    powerup.dead = true;
                    return;
                }
            }
            
            if (p.magnetRadius > 0) {
                const dx = p.x - powerup.x;
                const dy = p.y - powerup.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);
                
                // Auto-collect if very close to prevent vibration
                if (dist < p.r + powerup.r + 5) {
                    powerup.dead = true;
                    applyPowerup(powerup.type);
                    return;
                }
                
                if (distSq < p.magnetRadius * p.magnetRadius) {
                    const pullSpeed = 350;
                    powerup.x += (dx / dist) * pullSpeed * dt;
                    powerup.y += (dy / dist) * pullSpeed * dt;
                }
            }

            if (collide(p, powerup)) {
                powerup.dead = true;
                applyPowerup(powerup.type);
            }
        });
    }

    function detonateClusterRocket(m) {
        if (m.dead) return;
        m.dead = true;
        
        // Play cluster sound if this missile is marked for sound
        if (m.playSound) {
            playSound('cluster');
        }
        
        const baseRadius = 40; // Halved from 80
        const explosionRadius = store.player.enhancedClusters ? 80 : baseRadius;
        const chainRadius = 90;
        const microExplosionCount = 5;
        const aoeDmg = m.dmg * .8;
        for (let i = 0; i < microExplosionCount; i++) {
            const angle = Math.random() * 2 * Math.PI;
            const dist = Math.random() * explosionRadius * 0.7;
            const ex = m.x + Math.cos(angle) * dist;
            const ey = m.y + Math.sin(angle) * dist;
            store.activeEffects.push(createEffect("grenadeExplosion", ex, ey, 20 + Math.random() * 15));
        }
        const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
        targets.forEach(e => {
            if (!e.dead) {
                const distSq = (e.x - m.x)**2 + (e.y - m.y)**2;
                if (distSq < explosionRadius**2) {
                    e.hp -= aoeDmg;
                    e.hp = Math.max(1, e.hp);
                    
                    // Apply vampirism healing for cluster damage
                    if (store.player.vampirism > 0) {
                        let healAmount = aoeDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for AoE
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for AoE
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            }
        });
        // Remove chain detonation to prevent rockets from exploding each other
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            if (m.chainDetonate && !m.dead) {
                detonateClusterRocket(m);
                return;
            }
            m.life += dt; if (m.life > 6) { m.dead = true; return; }
            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }
            
            // Track movement distance before updating position
            const prevX = m.x, prevY = m.y;
            m.x += m.vx * dt; m.y += m.vy * dt;
            
            // Update travel distance if we have start position
            if (m.startX !== undefined && m.startY !== undefined) {
                m.travelDistance = Math.sqrt((m.x - m.startX)**2 + (m.y - m.startY)**2);
            }
            
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            
            // For cluster rockets, check proximity detonation only when they should explode
            if (m.cluster && !m.pierce) {
                // Original cluster behavior - explode near enemies
                const proxRadiusSq = 50 * 50;
                for (const e of targets) {
                    if (!e.dead && ((m.x - e.x)**2 + (m.y - e.y)**2 < proxRadiusSq)) {
                        detonateClusterRocket(m);
                        return;
                    }
                }
            }
            
            // Handle collision with enemies
            for (const e of targets) {
                if (!e.dead && collide(m, e)) {
                    m.hits = (m.hits || 0) + 1;
                    
                    if (m.cluster && m.pierce > 0) {
                        // Hybrid cluster + piercing: Deal damage, pierce, then set up for delayed explosion
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        m.pierce--;
                        
                        if (m.pierce <= 0) {
                            // No more pierces left - mark for delayed explosion
                            m.shouldExplodeAfterTravel = true;
                            m.minTravelTimeForExplosion = 0.5; // 0.5 seconds minimum travel time
                            m.travelTimeAfterLastHit = 0;
                        } else {
                            // Find next target for piercing
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else {
                                // No more targets - explode immediately
                                detonateClusterRocket(m);
                            }
                        }
                    } else if (m.cluster) {
                        // Pure cluster rocket - explode immediately
                        detonateClusterRocket(m);
                    } else {
                        // Regular missile logic (non-cluster)
                        let dmg = m.dmg;
                        if (e === store.boss) dmg *= 0.1;
                        if (Math.random() < store.player.critChance) {
                            dmg *= store.player.critDamage;
                            store.activeEffects.push(createEffect('critText', e.x, e.y));
                            if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                        }
                        e.hp -= dmg;
                        
                        // Apply vampirism healing for missile damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        explode(m.x, m.y, false, true);
                        if ((store.player.subclass === 'railgunner' || store.player.missilePierce > 0) && m.pierce > 0) {
                            m.pierce--;
                            let farthestTarget = null, maxDistSq = -1;
                            targets.forEach(p_target => {
                                if (p_target.dead || p_target === e) return;
                                const distSq = (p_target.x - e.x)**2 + (p_target.y - e.y)**2;
                                if (distSq > maxDistSq) { maxDistSq = distSq; farthestTarget = p_target; }
                            });
                            if (farthestTarget) {
                                m.target = farthestTarget;
                                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist > 1) { m.vx = (dx / dist) * m.speed; m.vy = (dy / dist) * m.speed; }
                            } else { m.dead = true; }
                        } else if (m.pierce > 0) {
                            m.pierce--;
                        } else {
                            m.dead = true;
                        }
                    }
                    if (m.dead) break;
                }
            }
            
            // Handle delayed explosion for cluster + pierce missiles
            if (m.shouldExplodeAfterTravel) {
                m.travelTimeAfterLastHit += dt;
                if (m.travelTimeAfterLastHit >= m.minTravelTimeForExplosion) {
                    // Check if we're near any enemies to explode
                    const explosionProximity = 60;
                    let shouldExplode = false;
                    for (const e of targets) {
                        if (!e.dead) {
                            const distSq = (m.x - e.x)**2 + (m.y - e.y)**2;
                            if (distSq < explosionProximity * explosionProximity) {
                                shouldExplode = true;
                                break;
                            }
                        }
                    }
                    if (shouldExplode) {
                        detonateClusterRocket(m);
                    }
                }
            }
        });
    }

    function stepLightning(dt) {
        store.lightningBolts.forEach(bolt => {
            bolt.life -= dt;
            if (bolt.life <= 0) { bolt.dead = true; }
        });
    }

    function stepEmpNovas(dt) {
        store.empNovas.forEach(nova => {
            // Expand the nova
            nova.radius += nova.speed * dt;
            if (nova.radius > nova.maxRadius) {
                nova.radius = nova.maxRadius;
            }
            
            // Countdown life
            nova.life -= dt;
            if (nova.life <= 0) {
                nova.dead = true;
                return;
            }
            
            // Check if player is within EMP range
            const dx = store.player.x - nova.x;
            const dy = store.player.y - nova.y;
            const distSq = dx * dx + dy * dy;
            const radiusSq = nova.radius * nova.radius;
            
            if (distSq <= radiusSq) {
                // Player is within EMP range - disable weapons
                store.player.empDisabled = true;
                store.player.empDisabledTimer = 0.5; // Sizzle effect duration
            }
        });
        
        // Update player EMP disabled state
        if (store.player.empDisabledTimer > 0) {
            store.player.empDisabledTimer -= dt;
            if (store.player.empDisabledTimer <= 0) {
                store.player.empDisabled = false;
            }
        }
    }

    function stepLasers(dt) {
        store.lasers.forEach(laser => {
            laser.life -= dt;
            if (laser.life <= 0) { laser.dead = true; return; }
            laser.prevX = laser.x; laser.prevY = laser.y;
            laser.x += laser.vx * dt; laser.y += laser.vy * dt;
            if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                const speed = Math.sqrt(laser.vx**2 + laser.vy**2);
                let newAngle;
                if (laser.x <= laser.r) { newAngle = -Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.x >= W - laser.r) { newAngle = Math.PI / 2 + Math.random() * Math.PI; }
                else if (laser.y <= laser.r) { newAngle = Math.random() * Math.PI; }
                else { newAngle = Math.PI + Math.random() * Math.PI; }
                laser.x = clamp(laser.x, laser.r, W - laser.r); laser.y = clamp(laser.y, laser.r, H - laser.r);
                laser.vx = Math.cos(newAngle) * speed; laser.vy = Math.sin(newAngle) * speed;
                laser.hitEnemies.clear();
            }
            store.enemies.forEach(e => {
                if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) { 
                    const laserDmg = 1000 * store.player.dmgMult;
                    e.hp -= laserDmg; 
                    laser.hitEnemies.add(e); 
                    
                    // Track damage dealt for beef shield system
                    if (store.player.pilotGenome === 'beef') {
                        store.player.beefShieldDamageDealt += laserDmg;
                    }
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = laserDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                        healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            });
            if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) { 
                const bossLaserDmg = 500 * store.player.dmgMult;
                store.boss.hp -= bossLaserDmg; 
                laser.hitEnemies.add(store.boss); 
                
                // Track damage dealt for beef shield system
                if (store.player.pilotGenome === 'beef') {
                    store.player.beefShieldDamageDealt += bossLaserDmg;
                }
                
                // Apply vampirism healing for laser damage on boss
                if (store.player.vampirism > 0) {
                    let healAmount = bossLaserDmg * store.player.vampirism;
                    healAmount = Math.max(healAmount, 2); // Minimum 2 HP for laser
                    healAmount = Math.min(healAmount, 10); // Cap at 10 HP for laser
                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                }
            }
        });
    }

    function stepMines(dt) {
        store.mines.forEach(mine => {
            if (mine.dead) return;
            mine.fuse -= dt;
            let detonate = mine.fuse <= 0;
            if (!detonate) {
                const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                for(const target of targets) { if(!target.dead && collide(mine, target)) { detonate = true; break; } }
            }
            if(detonate) { mine.dead = true; explodeMine(mine); }
        });
    }
    
    function stepFlameParticles(dt) {
        for (let i = store.flameParticles.length - 1; i >= 0; i--) {
            const p = store.flameParticles[i];
            if (p.attachedEnemy) {
                if (p.attachedEnemy.dead) {
                    p.attachedEnemy = null;
                } else {
                    p.x = p.attachedEnemy.x;
                    p.y = p.attachedEnemy.y;
                    p.attachedEnemy.hp -= p.damage;
                    
                    // Apply vampirism healing for attached flame damage
                    if (store.player.vampirism > 0) {
                        let healAmount = p.damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.2); // Minimum 0.2 HP
                        healAmount = Math.min(healAmount, 1); // Cap at 1 HP
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    p.attachedEnemy.slowTimer = 2.0;
                }
            }
            if (p.update && !p.update(dt)) {
                store.flameParticles.splice(i, 1);
            } else if (!p.update) {
                // Handle legacy flame particles without update function
                p.life -= dt;
                if (p.life <= 0) {
                    store.flameParticles.splice(i, 1);
                }
            }
        }
    }




    function stepWorld(dt) {
        stepPlayer(dt);
        if (store.boss) {
            stepBoss(dt);
        }

        stepPowerups(dt);
        stepHounds(dt);
        updateGibs(dt);
        
        // ‚ó¢‚ó£ UPDATE ENTROPY REDUCTION ENGINE ‚ó£‚ó¢ [DISABLED FOR STABILITY]
        // enhanceStellarFusion(); // Continuously update fusion rates
        
        // ‚ó¢‚ó£ UPDATE TEMPORAL WARP SYSTEM ‚ó£‚ó¢
        updateTemporalWarp(dt);
        
        stepMissiles(dt);
        stepLasers(dt);
        stepMines(dt);
        stepFlameParticles(dt);
        stepLightning(dt);
        stepEmpNovas(dt);
        
        // Update beef shield system
        updateBeefShield();
        
        // Update mech oil/fuel puddles
        for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
            const puddle = store.mechPuddles[i];
            puddle.life -= dt;
            if (puddle.life <= 0) {
                store.mechPuddles.splice(i, 1);
            }
        }
        
        updateVoidStepSystems(store.enemies);
        updateImpactSystem();

        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        if (store.world.powerupCooldown > 0) {
            store.world.powerupCooldown -= dt * (1 + (store.player.luckBoost * 2));
        }

        let base = store.world.wave < 200 ? 1.065 : 1.04;
        // BETTER BALANCE: Even more gentle scaling
        let dmgScale;
        if (store.world.wave <= 10) {
            // Very gentle exponential growth for early game
            dmgScale = Math.pow(1.03, store.world.wave - 1); // Reduced from 1.05 to 1.03
        } else {
            // Minimal linear scaling after wave 10
            const wave10Scale = Math.pow(1.03, 9); // ~1.3x at wave 10
            const veryGentleGrowth = (store.world.wave - 10) * 0.02; // Only +2% per wave after 10
            dmgScale = wave10Scale * (1 + veryGentleGrowth);
        }
        // Apply collar bonus and late-game scaling to enemy damage
        const collarBonus = 1 + (store.world.collarStacks * 0.08); // 8% increase per collar stack
        const lateGameBonus = store.world.lateGameDamageScaling || 1;
        dmgScale *= collarBonus * lateGameBonus;
        // console.log(`Wave ${store.world.wave}: Damage scale = ${dmgScale.toFixed(2)} | CollarStacks: ${store.world.collarStacks} | CollarBonus: ${collarBonus.toFixed(2)}x | LateGameBonus: ${lateGameBonus.toFixed(2)}x`);
        store.eBullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.gravity) { b.vy += b.gravity * dt; }
            if (b.life) { b.life -= dt; if (b.life <= 0) b.dead = true; }
            
            // Check if poison blob hits ground
            if (b.type === 'poisonBlob' && b.y > H - 30) {
                // Create poison puddle on ground impact
                if (!store.poisonPuddles) store.poisonPuddles = [];
                store.poisonPuddles.push({
                    x: b.x,
                    y: H - 20,
                    r: 20 + Math.random() * 10,
                    life: 12 + Math.random() * 8,
                    damage: (b.dmg || 15) * 0.5,
                    created: performance.now()
                });
                b.dead = true;
            }
            
            // Check if mech volley hits ground or reaches target area - create puddle
            if (b.isMechVolley && (b.y >= b.targetY - 10 || b.y > H - 30)) {
                // Use intended target location for puddle placement
                const puddleX = b.targetX;
                const puddleY = b.targetY;
                
                // console.log('Mech volley landed! Creating puddle at target:', puddleX, puddleY);
                store.mechPuddles.push({
                    x: puddleX,
                    y: puddleY,
                    r: 10, // Much smaller puddles (half of 20)
                    maxR: 10, // Store original size for shrinking effect
                    life: 1.5, // Reduced to 1.5 seconds
                    maxLife: 1.5, // Store original life for shrinking calculation
                    damage: (b.dmg || 18) * 0.4, // 40% of original damage per tick
                    sourceId: b.sourceId, // Track which mech created this puddle
                    created: performance.now(),
                    pulseOffset: Math.random() * Math.PI * 2, // For animation
                    hp: 15, // Make puddles killable with small HP
                    hpMax: 15 // Store max HP
                });
                b.dead = true;
            }
            
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            if (collide(b, store.player)) {
                const p = store.player;
                if (p.hasRearGuard && p.rearGuardReady && b.y < p.y) {
                    p.rearGuardReady = false;
                    p.rearGuardCooldown = 8;
                    b.dead = true;
                    store.activeEffects.push(createEffect("rearGuardBlock"));
                } else {
                    // Check if this is a poison blob for special effects
                    if (b.type === 'poisonBlob') {
                        // Apply poison debuff to player
                        p.isPoisoned = true;
                        p.poisonEndTime = performance.now() + 5000; // 5 second poison
                        p.moveSpeed = Math.max(p.moveSpeed * 0.7, 50); // Slow player
                        
                        // Create poison puddle at impact location
                        if (!store.poisonPuddles) store.poisonPuddles = [];
                        store.poisonPuddles.push({
                            x: b.x,
                            y: b.y,
                            r: 25,
                            life: 10,
                            damage: (b.dmg || 15) * 0.3,
                            created: performance.now()
                        });
                    }
                    
                    // Calculate fade-in damage multiplier for Death Engine bullet rain
                    let damageMultiplier = 1.0;
                    if (b.fadeInTime && b.spawnTime) {
                        const timeAlive = (performance.now() - b.spawnTime) / 1000;
                        damageMultiplier = Math.min(1.0, timeAlive / b.fadeInTime);
                    }
                    
                    takeDamage((b.dmg || 10) * damageMultiplier);
                    b.dead = true;
                }
            }
        });

        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) {
                    store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale });
                    mine.dead = true;
                }
                if (collide(mine, store.player)) {
                    takeDamage(50 * dmgScale);
                    mine.dead = true;
                }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }


        // CONSOLIDATED enemy processing - flame collision + movement in single loop for performance
        store.enemies.forEach(e => {
            // OPTIMIZED FLAME PARTICLE COLLISION - early distance culling
            if (store.flameParticles.length > 0) {
                store.flameParticles.forEach(flame => {
                    if (flame.life <= 0 || e.dead) return;
                    
                    const dx = flame.x - e.x;
                    const dy = flame.y - e.y;
                    
                    // Early distance culling - skip expensive collision if too far
                    if (Math.abs(dx) > 100 || Math.abs(dy) > 100) return;
                    
                    const distSq = dx * dx + dy * dy; // Skip sqrt - use squared distance
                    const collisionRadius = Math.max(5, flame.size + e.r - 50);
                    const collisionRadiusSq = collisionRadius * collisionRadius;
                    
                    if (distSq < collisionRadiusSq) {
                        e.stunTimer = Math.max(e.stunTimer || 0, 0.5);
                        e.hp -= flame.damage;
                        
                        // Apply vampirism healing for flamethrower damage
                        if (store.player.vampirism > 0) {
                            let healAmount = flame.damage * store.player.vampirism;
                            healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                            healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                        
                        e.isBurning = true;
                        setTimeout(() => { if (e) e.isBurning = false; }, 100);
                    }
                });
            }
            
            // MOVEMENT AND AI UPDATES
            if (e.knockback) {
                e.x += e.knockback.vx * dt;
                e.y += e.knockback.vy * dt;
                e.knockback.duration -= dt;
                if (e.knockback.duration <= 0) e.knockback = null;
            } else if (e.stunTimer && e.stunTimer > 0) {
                e.stunTimer -= dt;
            } else {
                let speedMultiplier = (e.slowTimer > 0) ? 0.3 : 1.0;
                if (e.slowTimer > 0) e.slowTimer -= dt;

                if (e.type === 'construct_gold' || e.type === 'avian_hatchling') {
                    const dx = store.player.x - e.x, dy = store.player.y - e.y, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 1) {
                        e.x += (dx / dist) * e.v * speedMultiplier * dt;
                        e.y += (dy / dist) * e.v * speedMultiplier * dt;
                    }
                } else if (e.type === 'angler') {
                    const dx = store.player.x - e.x;
                    if (Math.abs(dx) > 10) e.x += Math.sign(dx) * 30 * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else if (e.type === 'manta') {
                    e.t += dt;
                    
                    // DISABLED DODGE SYSTEM - was causing enemies to jump off-screen and become unkillable
                    // Simple sinusoidal snake movement only
                    e.x = e.startX + e.amplitude * Math.sin(e.t * e.frequency);
                    e.y += e.v * speedMultiplier * dt;
                } else if (!e.isOrbiter) {
                    e.x += (e.vx || 0) * speedMultiplier * dt;
                    e.y += e.v * speedMultiplier * dt;
                } else {
                    if (store.boss) { e.orbitCenter.x = store.boss.x; e.orbitCenter.y = store.boss.y; }
                    e.orbitAngle += e.orbitSpeed * speedMultiplier * dt;
                    e.x = e.orbitCenter.x + e.orbitRadius * Math.cos(e.orbitAngle);
                    e.y = e.orbitCenter.y + e.orbitRadius * Math.sin(e.orbitAngle);
                }
                if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
            }

            if (e.fireT > 0) e.fireT -= dt;
            if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                switch (e.type) {
                    case 'hunter': { 
                        const a=Math.atan2(store.player.y-e.y,store.player.x-e.x); 
                        const bullet = getEBulletFromPool({x:e.x,y:e.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:3,col:e.color,dmg:6*dmgScale});
                        store.eBullets.push(bullet); 
                        e.fireT=1; break; 
                    }
                    case 'phantom': { 
                        const bullet = getEBulletFromPool({x:e.x,y:e.y,vx:0,vy:180,r:3,col:e.color,dmg:5*dmgScale});
                        store.eBullets.push(bullet); 
                        e.fireT=e.fireCooldown; break; 
                    }
                    case 'mech': {
                        e.attackPhase = (e.attackPhase || 0) + 1;
                        // Changed from 50/50 to 85% lob attacks, 15% shoulder cannons for more frequent lobs
                        if (e.attackPhase % 7 === 1) {
                            // Shoulder cannon attack (less frequent now)
                            const shoulderLeftX = e.x - e.r * 1.2, shoulderRightX = e.x + e.r * 1.2, shoulderY = e.y - e.r;
                            const angleLeft = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderLeftX);
                            store.eBullets.push({ x: shoulderLeftX, y: shoulderY, vx: Math.cos(angleLeft) * 160, vy: Math.sin(angleLeft) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                            const angleRight = Math.atan2(store.player.y - shoulderY, store.player.x - shoulderRightX);
                            store.eBullets.push({ x: shoulderRightX, y: shoulderY, vx: Math.cos(angleRight) * 160, vy: Math.sin(angleRight) * 160, r: 4, col: e.color, dmg: 12 * dmgScale });
                        } else {
                            // Lob attack with randomized target location (more frequent now)
                            // Limit target area to stay on screen with reasonable arc
                            const randomOffsetX = (Math.random() - 0.5) * 300; // Reduced spread to 300 pixels
                            const targetX = Math.max(80, Math.min(W - 80, store.player.x + randomOffsetX)); // Keep well within bounds
                            
                            // Limit Y coordinate to prevent extreme arcs
                            const minY = Math.max(H * 0.5, e.y + 100); // Don't go too high above the mech
                            const maxY = H - 80;   // Stop well above bottom
                            const targetY = minY + Math.random() * (maxY - minY);
                            
                            const dx = targetX - e.x;
                            const dy = targetY - e.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Much slower projectile for visibility and reasonable arc
                            const timeToTarget = Math.max(1.5, dist / 120); // Slower speed = 120 instead of 180
                            const gravity = 250; // Reduced gravity for gentler arc
                            const vx = dx / timeToTarget;
                            const vy = (dy - 0.5 * gravity * timeToTarget * timeToTarget) / timeToTarget;
                            
                            store.eBullets.push({ 
                                x: e.x, y: e.y, vx: vx, vy: vy, r: 6, 
                                col: '#40e0d0', dmg: 18 * dmgScale, // Turquoise projectile color to match mech
                                gravity: gravity, isMechVolley: true, sourceId: e.id,
                                targetX: targetX, targetY: targetY // Store intended target location
                            });
                        }
                        e.fireT = 0.8; break; // Much more frequent attacks - reduced from 1.2 to 0.8
                    }
                    case 'angler': { const a = Math.atan2(store.player.y - e.y, store.player.x - e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*120,vy:Math.sin(a)*120,r:4,col:e.color,dmg:15*dmgScale, life: 5}); e.fireT = 2.5; break; }
                    case 'manta': { for(let i=-1; i<=1; i++) { const angle = (90 + i * 30) * Math.PI/180; store.eBullets.push({x:e.x, y:e.y, vx:Math.cos(angle)*150, vy:Math.sin(angle)*150, r:3, col:e.color, dmg:12*dmgScale}); } e.fireT = 2.8; break; }
                    default: { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:150,r:3,col:e.color,dmg:5*dmgScale}); e.fireT=.5; }
                }
            }

            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) {
                takeDamage(8 * dmgScale); // Reduced from 15 to 8 for better balance
                store.world.gold += e.gold;
                e.dead = true;
            }
        });

        // BOSS flame collision (separate from main enemy loop)
        if (store.boss && !store.boss.dead) {
            store.flameParticles.forEach(flame => {
                if (flame.life <= 0) return;
                
                const dx = flame.x - store.boss.x;
                const dy = flame.y - store.boss.y;
                const distSq = dx * dx + dy * dy;
                const collisionRadius = Math.max(10, flame.size + store.boss.r - 50);
                const collisionRadiusSq = collisionRadius * collisionRadius;
                
                if (distSq < collisionRadiusSq) {
                    store.boss.stunTimer = Math.max(store.boss.stunTimer || 0, 0.3);
                    const bossFlameDmg = flame.damage * 0.5;
                    store.boss.hp -= bossFlameDmg;
                    
                    // Apply vampirism healing for flamethrower damage on boss
                    if (store.player.vampirism > 0) {
                        let healAmount = bossFlameDmg * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.3); // Minimum 0.3 HP for flame
                        healAmount = Math.min(healAmount, 2); // Cap at 2 HP for flame
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                    
                    store.boss.isBurning = true;
                    setTimeout(() => { if (store.boss) store.boss.isBurning = false; }, 100);
                }
            });
        }

        store.bullets.forEach(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.isSwirl) {
                b.life = (b.life || 0) + dt;
                b.x += Math.sin(b.life * 15) * 150 * dt;
            }
            if (b.isFlame) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
                b.particleSpawnT -= dt;
                if (b.particleSpawnT <= 0) {
                    b.particleSpawnT = b.isLavaChunk ? 0.1 : 0.05;
                    const life = 0.3 + Math.random() * 0.3, angle = Math.random() * 2 * Math.PI, speed = b.isLavaChunk ? 10 + Math.random() * 15 : 20 + Math.random() * 20;
                    b.particles.push({ x: 0, y: 0, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: life, maxLife: life, r: 1 + Math.random() * (b.isLavaChunk ? 1.5 : 2) });
                }
                b.particles = b.particles.filter(p => {
                    p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt;
                    return p.life > 0;
                });
            } else if (b.isLevelUpPulse) {
                b.life -= dt;
                if (b.life <= 0) b.dead = true;
            }

            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;

            const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
            for (const e of targets) {
                if (b.dead || e.dead) continue;
                if (collide(b, e)) {
                    if (b.isFlame) e.slowTimer = 1.0;
                    
                    // Skip damage to Heat Death boss - it's just atmospheric
                    if (e.isHeatDeath) {
                        b.dead = true;
                        continue;
                    }
                    
                    // Skip damage to invincible bosses during phase transitions
                    if (e === store.boss && e.isInvincible) {
                        b.dead = true;
                        continue;
                    }
                    
                    let dmg = b.dmg || 15;
                    if (e === store.boss && b.isDrone) dmg *= 0.4;
                    
                    if (Math.random() < store.player.critChance) {
                        dmg *= store.player.critDamage;
                        store.activeEffects.push(createEffect('critText', e.x, e.y));
                        if (Math.random() < 0.05) spawnPowerup(e.x, e.y);
                        
                        // ‚ó¢‚ó£ TEMPORAL HEALING FROM CAUSALITY ENGINE ‚ó£‚ó¢
                        if (store.player.temporalHealing && store.player.temporalHealing > 0) {
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.temporalHealing);
                        }
                    }
                    
                    if (e === store.boss) playSound('hit');
                    e.hp -= dmg;
                    
                    // Track damage dealt for beef shield system
                    if (store.player.pilotGenome === 'beef') {
                        store.player.beefShieldDamageDealt += dmg;
                    }
                    
                    // Apply vampirism healing on damage dealt (not just kills)
                    if (store.player.vampirism > 0) {
                        let healAmount = dmg * store.player.vampirism;
                        // Ensure minimum healing of 1 HP per shot if vampirism is active
                        healAmount = Math.max(healAmount, 1);
                        // Cap healing to prevent overpowered early game
                        healAmount = Math.min(healAmount, 5);
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }

                    if (e.hp <= 0) {
                        e.dead = true;
                        
                        if (e === store.boss) {
                            handleBossDefeat();
                        } else {
                            spawnGibs(e.x, e.y, e.color);
                            store.world.score += e.score;
                            store.world.gold += e.gold;
                            store.world.xp += e.xp;
                            store.world.kills++;
                            
                            // ‚ó¢‚ó£ ENTROPY REDUCTION VIA ENEMY DESTRUCTION ‚ó£‚ó¢ [DISABLED FOR STABILITY]
                            /*
                            const entropyReduced = calculateEntropyReduction(store.world.wave, 1, b.damage);
                            if (entropyReduced > 0 && Math.random() < 0.05) { // 5% chance to show message
                                console.log(`‚öõÔ∏è Entropy reduced: ${entropyReduced.toExponential(2)} J/K - Universe grows more ordered!`);
                            }
                            */
                            
                            spawnPowerup(e.x, e.y);
                            explode(e.x, e.y);
                        }
                    }

                    if (b.explosive) explode(b.x, b.y, false, true);
                    if (!b.pierce) b.dead = true;
                }
            }
            
            // Check bullet collision with mech puddles (make puddles killable)
            if (!b.dead && store.mechPuddles) {
                for (let i = store.mechPuddles.length - 1; i >= 0; i--) {
                    const puddle = store.mechPuddles[i];
                    const dx = b.x - puddle.x;
                    const dy = b.y - puddle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < puddle.r + (b.r || 2)) {
                        // Puddle hit by bullet - take damage
                        puddle.hp -= (b.dmg || 15);
                        
                        if (puddle.hp <= 0) {
                            // Puddle destroyed - award rewards
                            store.world.gold += 1;
                            store.world.xp += 1;
                            
                            // Small explosion effect
                            for (let j = 0; j < 5; j++) {
                                store.flameParticles.push({
                                    x: puddle.x + (Math.random() - 0.5) * 20,
                                    y: puddle.y + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 100,
                                    vy: -Math.random() * 100,
                                    life: 0.3 + Math.random() * 0.3,
                                    maxLife: 0.3 + Math.random() * 0.3,
                                    r: 2 + Math.random() * 3,
                                    update: function(dt) {
                                        this.life -= dt;
                                        this.x += this.vx * dt;
                                        this.y += this.vy * dt;
                                        this.vy += 200 * dt; // gravity
                                        return this.life > 0;
                                    },
                                    draw: function() {
                                        if (!ctx) return;
                                        const alpha = this.life / this.maxLife;
                                        ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
                                        ctx.beginPath();
                                        ctx.arc(this.x, this.y, this.r * alpha, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                });
                            }
                            
                            // console.log('Puddle destroyed by bullet! +1 gold, +1 xp');
                            store.mechPuddles.splice(i, 1);
                        }
                        
                        if (!b.pierce) b.dead = true;
                        break;
                    }
                }
            }
        });

        const p = store.player;
        const healthRatio = p.hp / p.hpMax;
        const lowHealthThreshold = 0.35;

        if (healthRatio < lowHealthThreshold) {
            if (!store.world.isLowHealth) {
                store.world.isLowHealth = true;
                store.heartbeatT = 5.0;
                // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                store.activeEffects.push(createEffect("heartbeatPulse"));
            } else {
                if (store.heartbeatT > 0) {
                    store.heartbeatT -= dt;
                } else {
                    store.heartbeatT = 5.0;
                    // playSound('heartbeat'); // Disabled - heartbeat.mp3 missing
                    store.activeEffects.push(createEffect("heartbeatPulse"));
                }
            }
        } else if (store.world.isLowHealth) {
            store.world.isLowHealth = false;
        }

        // Optimized cleanup with object pooling
        const deadBullets = store.bullets.filter(b => b.dead);
        const deadEBullets = store.eBullets.filter(b => b.dead);
        
        // Return dead bullets to pools
        deadBullets.forEach(returnBulletToPool);
        deadEBullets.forEach(returnEBulletToPool);
        
        // Filter out dead objects
        store.bullets = store.bullets.filter(i => !i.dead);
        store.eBullets = store.eBullets.filter(i => !i.dead);
        ['enemies', 'powerups', 'mines', 'missiles', 'lasers', 'flameParticles', 'lightningBolts', 'empNovas'].forEach(key => store[key] = store[key].filter(i => !i.dead));
        store.activeEffects = store.activeEffects.filter(e => e.isActive !== false);

        if (!store.boss && store.enemies.length === 0) {
            // Add some delay before starting next wave to prevent rapid cycling
            if (!store.world.waveTransitionTimer) {
                store.world.waveTransitionTimer = performance.now();
                return;
            }
            
            // Wait at least 0.5 seconds before progressing to next wave
            if (performance.now() - store.world.waveTransitionTimer < 500) {
                return;
            }
            
            // console.log(`Wave ${store.world.wave} completed, transitioning to wave ${store.world.wave + 1}`);
            
            if (store.world.waveStartTime > 0 && store.world.wave > 1) {
                const waveClearTime = (performance.now() - store.world.waveStartTime) / 1000;
                
                // Guaranteed minimum collar stacks for any reasonable clear
                let collarStacksToAdd = 0;
                
                if (waveClearTime < 2) {
                    // Ultra-instant clear: +9 collar stacks (addresses missing 9 stack issue)
                    collarStacksToAdd = 9;
                    store.world.enemyDensityBonus *= 1.15;
                    store.world.xpMultiplier *= 1.1;
                    announce("üí• ULTRA-INSTANT CLEAR! COLLAR CRUSHES +9 üí•");
                } else if (waveClearTime < 4) {
                    // Instant clear: +6 collar stacks
                    collarStacksToAdd = 6;
                    store.world.enemyDensityBonus *= 1.1;
                    store.world.xpMultiplier *= 1.07;
                    announce("‚ö° INSTANT WAVE CLEAR! COLLAR TIGHTENS +6 ‚ö°");
                } else if (waveClearTime < 8) {
                    // Fast clear: +3 collar stacks
                    collarStacksToAdd = 3;
                    store.world.enemyDensityBonus *= 1.05;
                    store.world.xpMultiplier *= 1.03;
                    announce("‚ö° FAST WAVE CLEAR! COLLAR TIGHTENS +3 ‚ö°");
                } else if (waveClearTime < 12) {
                    // Normal clear: +1 collar stack
                    collarStacksToAdd = 1;
                    announce("‚ö° COLLAR TIGHTENS +1 ‚ö°");
                } else if (waveClearTime > 20) {
                    // Very slow clear: reset collar stacks (except during Death Engine fight)
                    const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
                    if (!isDeathEngineFight) {
                        store.world.collarStacks = Math.max(0, store.world.collarStacks - 2);
                        announce("üêå SLOW CLEAR - COLLAR LOOSENS");
                    } else {
                        announce("THE DEATH ENGINE'S CURSE MAINTAINS THE COLLAR!");
                    }
                }
                
                // Add collar stacks only after 2nd boss is defeated - let first two bosses play normally
                if (collarStacksToAdd > 0 && store.world.bosses >= 2) {
                    store.world.collarStacks += collarStacksToAdd;
                    console.log(`Wave ${store.world.wave} cleared in ${waveClearTime.toFixed(2)}s - Added ${collarStacksToAdd} collar stacks (Total: ${store.world.collarStacks})`);
                } else if (collarStacksToAdd > 0 && store.world.bosses < 2) {
                    console.log(`Wave ${store.world.wave} cleared in ${waveClearTime.toFixed(2)}s - Collar system inactive until 3rd boss (Bosses defeated: ${store.world.bosses})`);
                }
            }
            
            store.world.wave++;
            store.world.waveTransitionTimer = null; // Reset timer
            
            // ‚ó¢‚ó£ TEMPORAL ANOMALY TRIGGER ‚ó£‚ó¢ (COMMENTED OUT - NEEDS POLISH)
            // checkTemporalAnomaly();
            
            const hpBonus = 1;
            store.player.hpMax += hpBonus;
            store.player.hp += hpBonus;
            initWave();
        } else {
            // Reset wave transition timer if there are still enemies or boss
            store.world.waveTransitionTimer = null;
        }

        let xpNeeded = Math.floor(store.world.level * 100 * store.world.xpMultiplier * (store.world.level >= 8 ? 1.3 : store.world.level >= 4 ? 1.1 : 1) * (store.world.wave > 10 ? 1.3 : 1));
        if (store.world.xp >= xpNeeded) {
            store.world.xp -= xpNeeded;
            store.world.level++;
            levelUp();
        }

        // Collar decay system - prevent infinite stacking
        if (!store.world.collarDecayTimer) {
            store.world.collarDecayTimer = 0;
        }
        store.world.collarDecayTimer += dt;
        
        // Apply gradual collar decay every 10 seconds if stacks are high (only after 2nd boss, except during Death Engine fight)
        if (store.world.collarDecayTimer >= 10 && store.world.bosses >= 2) {
            store.world.collarDecayTimer = 0;
            
            // Don't decay collar stacks during Death Engine fight due to its intermission phases
            const isDeathEngineFight = store.world.boss && store.world.boss.name === 'DEATH ENGINE';
            
            if (!isDeathEngineFight) {
                if (store.world.collarStacks > 20) {
                    // Decay faster when collar stacks are very high
                    const decay = Math.max(0.5, store.world.collarStacks * 0.02);
                    store.world.collarStacks = Math.max(0, store.world.collarStacks - decay);
                    // High collar stacks decay applied
                } else if (store.world.collarStacks > 5) {
                    // Gentle decay for moderate stacks
                    store.world.collarStacks = Math.max(0, store.world.collarStacks - 0.3);
                }
            }
        }

        if (store.player.hp <= 0) {
            handleGameOver();
        }
    }





    function handleBossDefeat() {
        const fightDuration = (performance.now() - store.world.bossSpawnTime) / 1000;
        
        // Track boss defeats for progression
        const bossCount = store.world.bosses + 1; // +1 because we increment bosses after this check
        
        // NEW PROGRESSION SYSTEM:
        // 1st boss = pilot class selection
        // 2nd+ boss = skill tree for all pilots
        
        if (bossCount === 1 && !store.player.pilotGenome) {
            // 1st boss defeated - show pilot class selection
            store.player.pilotGenome = 'pending';
            setTimeout(showPilotSelect, 1000);
        } else if (bossCount === 2 && store.player.pilotGenome && store.player.pilotGenome !== 'pending' && !store.player.subclass) {
            // 2nd boss defeated - show subclass selection
            console.log(`2nd boss defeated - showing subclass selection for ${store.player.pilotGenome}`);
            setTimeout(showSubclassSelect, 1500);
        } else if (bossCount >= 3 && store.player.pilotGenome && store.player.pilotGenome !== 'pending') {
            // 3rd+ boss defeated - show skill tree (subclass will be defaulted if not selected)
            
            // Don't award points or show tree if already fully capped OR if 5 skill points have been spent
            const skillPointsSpent = store.player.skillPointsSpent || 0;
            const isTreeCapped = isSkillTreeFullyCapped();
            const hasReachedSkillLimit = skillPointsSpent >= 5; // Allow 4 for main path + 1 for class ability
            const hasNoSkillPoints = (store.player.skillPoints || 0) <= 0;
            
            if (isTreeCapped || hasReachedSkillLimit) {
                console.log(`Skill tree blocked - ${isTreeCapped ? 'fully capped' : '5 skill points spent'} (${skillPointsSpent}/5 points spent)`);
            } else {
                if (!store.player.skillTreeProgress) {
                    store.player.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
                }
                store.player.skillTreeProgress.bossesDefeated = bossCount;
                store.player.skillPoints = (store.player.skillPoints || 0) + 1;
                console.log(`${bossCount}${bossCount === 3 ? 'rd' : bossCount === 4 ? 'th' : 'th'} boss defeated - showing skill tree for ${store.player.pilotGenome} with`, store.player.skillPoints, 'points');
                setTimeout(showSkillTreeModal, 1500);
            }
        }
        
        // Enhanced spec system: after 4th and 6th boss, then every 2 bosses after that  
        if (store.player.pilotGenome && store.player.subclass && bossCount >= 4) {
            if (bossCount === 4 || bossCount === 6 || (bossCount > 6 && (bossCount - 6) % 2 === 0)) {
                setTimeout(() => showSpecSelect(bossCount >= 6), 1500); // Second spec is additive
            }
        }
        
        store.world.score += 2000; store.world.gold += 25; store.world.xp += 100; store.world.bosses++;
        const bossX = store.boss.x;
        const bossY = store.boss.y;
        const bossName = store.boss.name; // Store boss name before nulling
        
        // Clear any poison puddles and poison blobs from HIVE SOVEREIGN when boss is defeated
        if (store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        // Also clear poison blobs still in flight to prevent persistent puddles
        store.bullets = store.bullets.filter(b => b.type !== 'poisonBlob');
        
        store.boss = null;
        announce('‚ö° GUARDIAN DEFEATED ‚ö°');
        explode(bossX, bossY, true);

        let healthBonusMultiplier = 1.0, announcedAdaptation = false;
        // Calculate collar stacks to add based on boss kill speed (more generous)
        let collarStacksToAdd = 0;
        
        if (fightDuration <= 2) {
            // Ultra-fast boss kill: massive collar bonus
            collarStacksToAdd = 12;
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            announce(`üí• COLLAR CRUSHES +${collarStacksToAdd} üí•`);
        } else if (fightDuration <= 5) {
            // Fast boss kill
            collarStacksToAdd = Math.max(8, Math.floor(12 - (fightDuration * 1.5)));
            announcedAdaptation = true;
            if (store.world.wave >= 15) {
                store.world.consecutiveFastKills++;
                if (store.world.consecutiveFastKills === 1) { store.world.fastKillBonus = 0.20; } else { store.world.fastKillBonus *= 2; }
                healthBonusMultiplier = 1.4 + store.world.fastKillBonus;
                announce(`STREAK x${store.world.consecutiveFastKills}! GUARDIAN OVERDRIVE!`);
            } else { healthBonusMultiplier = 1.4; announce("GUARDIANS ADAPTING RAPIDLY!"); }
            announce(`‚ö° COLLAR TIGHTENS +${collarStacksToAdd} ‚ö°`);
        } else if (fightDuration < 8) {
            // Decent boss kill
            collarStacksToAdd = Math.max(3, Math.floor(10 - fightDuration));
            announcedAdaptation = true; 
            healthBonusMultiplier = 1.15;
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            announce(`‚ö° COLLAR TIGHTENS +${collarStacksToAdd} ‚ö°`);
        } else if (fightDuration < 12) {
            // Slow boss kill: minimal collar bonus
            collarStacksToAdd = 1;
            announcedAdaptation = true; 
            healthBonusMultiplier = 1.05;
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            announce(`‚ö° COLLAR TIGHTENS +${collarStacksToAdd} ‚ö°`);
        } else {
            // Very slow kill: reduce collar stacks (except for DEATH ENGINE)
            if (bossName !== 'DEATH ENGINE') {
                store.world.collarStacks = Math.max(0, store.world.collarStacks - 3); 
                announce("‚öñÔ∏è COLLAR LOOSENS - ADAPTATION WEAKENS");
            } else {
                announce("THE DEATH ENGINE'S CURSE PERSISTS!");
            }
            store.world.consecutiveFastKills = 0; 
            store.world.fastKillBonus = 0;
            healthBonusMultiplier = 1.0;
        }
        
        // Special handling for Death Engine - restore preserved collar stacks
        if (bossName === 'DEATH ENGINE' && store.world.deathEngineCollarStacks !== undefined) {
            const originalStacks = store.world.deathEngineCollarStacks;
            store.world.collarStacks = originalStacks + collarStacksToAdd; // Restore + add earned stacks
            console.log(`Death Engine defeated - restored ${originalStacks} collar stacks + ${collarStacksToAdd} earned = ${store.world.collarStacks} total`);
            delete store.world.deathEngineCollarStacks; // Clean up
        } else {
            // Add collar stacks only after 2nd boss is defeated - collar system starts with 3rd boss
            if (collarStacksToAdd > 0 && store.world.bosses >= 2) {
                store.world.collarStacks += collarStacksToAdd;
                console.log(`Boss ${bossName} defeated in ${fightDuration.toFixed(2)}s - Added ${collarStacksToAdd} collar stacks (Total: ${store.world.collarStacks})`);
            } else if (collarStacksToAdd > 0 && store.world.bosses < 2) {
                console.log(`Boss ${bossName} defeated in ${fightDuration.toFixed(2)}s - Collar system will activate after 2nd boss (Current bosses: ${store.world.bosses})`);
            }
        }
        // FIXED: Don't permanently modify health bonuses - collar handles this dynamically
        // Instead, only apply temporary density and XP bonuses based on performance
        if (announcedAdaptation) {
            // Only apply density bonuses, not permanent health increases
            if (healthBonusMultiplier > 1.3) {
                store.world.enemyDensityBonus *= 1.15;
            } else if (healthBonusMultiplier > 1.1) {
                store.world.enemyDensityBonus *= 1.10;
            } else if (healthBonusMultiplier > 1.0) {
                store.world.enemyDensityBonus *= 1.05;
            }
            setTimeout(() => announce("GUARDIAN DEFEATED!"), 1000);
        }
    }

    function explode(x, y, isBoss = false, isSmall = false) {
        playSound('explosion');
        if (isBoss) for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
        if (isSmall) {
            const radius = 60;
            const dmg = 25 * store.player.dmgMult;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            targets.forEach(e => {
                if (!e.dead) {
                    const distSq = (e.x - x)**2 + (e.y - y)**2;
                    if (distSq < radius**2) {
                        e.hp -= dmg;
                        store.world.totalDamage += dmg;
                        
                        // Track damage dealt for beef shield system
                        if (store.player.pilotGenome === 'beef') {
                            store.player.beefShieldDamageDealt += dmg;
                        }
                        
                        // Apply vampirism healing for explosion damage
                        if (store.player.vampirism > 0) {
                            let healAmount = dmg * store.player.vampirism;
                            healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP
                            healAmount = Math.min(healAmount, 2); // Cap at 2 HP
                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                        }
                    }
                }
            });
            store.activeEffects.push(createEffect("grenadeExplosion", x, y, radius));
        }
    }
    
    function levelUp() {
        announce(`LEVEL UP! ‚ö° CHOOSE YOUR AUGMENTATION!`);
        pauseGame();
        
        // Natural health growth: 10% per level
        const healthGrowth = store.player.hpMax * 0.1;
        store.player.hpMax += healthGrowth;
        store.player.hp += healthGrowth;
        console.log(`Level up health growth: +${Math.round(healthGrowth)} HP (now ${Math.round(store.player.hpMax)} max)`);
        
        store.player.isInvincible = true;
        const speedBoost = store.player.speed * 0.75;
        const fireRateBoost = store.player.fireRate * 0.5;
        store.player.speed += speedBoost;
        store.player.fireRate -= fireRateBoost;

        const levelUpPulse = () => {
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 300;
                store.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 4, col: '#ffddff', dmg: 30 * p.dmgMult,
                    pierce: true, life: 1.5, isLevelUpPulse: true
                });
            }
        };

        levelUpPulse();
        setTimeout(levelUpPulse, 250);

        // Store timeout ID to prevent multiple level-ups causing permanent bonuses
        if (store.levelUpTimeoutId) {
            clearTimeout(store.levelUpTimeoutId);
        }
        
        store.levelUpTimeoutId = setTimeout(() => {
            store.player.isInvincible = false;
            store.player.speed -= speedBoost;
            store.player.fireRate += fireRateBoost;
            store.levelUpTimeoutId = null;
        }, 3000);

        const panel = q('levelPanel'), grid = q('skillsGrid');
        const availableUpgrades = LEVEL_UPGRADES.filter(u => {
            if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
            // Check if upgrade has availability function
            if (u.available && typeof u.available === 'function') return u.available();
            return true;
        });

        for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; }
        const choices = availableUpgrades.slice(0, 3);
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        const cards = grid.querySelectorAll('.skill-card');
        const clickHandler = (e) => {
            const card = e.currentTarget;
            const id = card.dataset.id; 
            const upgrade = LEVEL_UPGRADES.find(s => s.id === id);
            if (upgrade) upgrade.apply(); 
            panel.classList.add('hide');
            resumeGame();
            // Clean up event listeners to prevent UI freeze
            cards.forEach(c => c.removeEventListener('click', clickHandler));
        };
        
        cards.forEach(card => {
            card.addEventListener('click', clickHandler);
        }); 

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        panel.classList.remove('hide');
    }
    
    function handleGameOver() {
        if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score);
        announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide');
    }
    
    function resetGame() {
        store.player = JSON.parse(JSON.stringify(player_initial_state));
        
        // Ensure dmgMult is initialized
        if (!store.player.dmgMult) store.player.dmgMult = 1;
    
        store.world = { 
            wave: 1, 
            score: 0, 
            gold: 0, 
            xp: 0, 
            level: 1, 
            kills: 0, 
            bosses: 0,
            bossesAtPilotSelection: null,
            lowHealthTutorialShown: false, 
            bossSpawnTime: 0, 
            waveStartTime: 0, 
            enemyHealthBonus: 1.0, 
            bossHealthBonus: 1.0, 
            enemyDensityBonus: 1.0, 
            powerupCooldown: 0, 
            xpMultiplier: 1.0, 
            collarStacks: 0, 
            consecutiveFastKills: 0, 
            fastKillBonus: 0,
            totalDamage: 0,
            damageStartTime: performance.now()
        };
        
        store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = []; store.powerups = [];
        store.drones = []; store.hounds = []; store.missiles = []; store.lasers = []; store.mines = []; store.activeEffects = []; store.flameParticles = [];
        store.lightningBolts = []; store.empNovas = []; store.poisonPuddles = [];
        store.iceman = null;
        store._startTs = performance.now(); store.isGameOver = false;
        store.cheatsUsed = false;
        store.cheatInvincibilityCooldown = 0;
        store.cheatDogHealCooldown = 0;
        shopItemOrder = [];
        q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide'); 
        q('subclassPanel').classList.add('hide'); q('subclassPanel').classList.remove('skill-tree-active');
        ensureName();
    }

    // --- RENDER & DRAW FUNCTIONS ---
    const starCountA = 100, starCountB = 80;
    const starsA = Array.from({ length: starCountA }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.5, pulse: Math.random() * 10 }));
    const starsB = Array.from({ length: starCountB }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 2, pulse: Math.random() * 10 }));

    // Optimized background star rendering
    function renderBackgroundStars(dt) {
        // Batch star operations to reduce context state changes
        ctx.globalAlpha = 0.8;
        
        // Render starsA in a single pass
        for (let i = 0; i < starsA.length; i++) {
            const s = starsA[i];
            s.y += 30 * dt; 
            if (s.y > H) s.y -= H;
            
            const alpha = 0.5 + 0.5 * Math.sin(frameTime * 2 + s.pulse);
            ctx.fillStyle = `rgba(255,0,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, 6.283185307179586); // Use constant instead of Math.PI * 2
            ctx.fill();
        }
        
        ctx.globalAlpha = 0.6;
        
        // Render starsB in a single pass
        for (let i = 0; i < starsB.length; i++) {
            const s = starsB[i];
            s.y += 60 * dt; 
            if (s.y > H) s.y -= H;
            
            const pulse = Math.sin(frameTime * 1.5 + s.pulse);
            const alpha = 0.4 + 0.6 * pulse;
            const radius = Math.max(0.1, s.r * (0.4 + 0.6 * pulse));
            
            ctx.fillStyle = `rgba(204,0,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, radius, 0, 6.283185307179586);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
    }

// Cache for gradient objects to avoid recreation
let poisonGradientCache = new Map();
let mechGradientCache = new Map();
let frameTime = 0;
let frameCount = 0;

// Clear caches periodically to prevent memory buildup
function clearGradientCaches() {
    if (frameCount % 1000 === 0) { // Clear every ~17 seconds at 60fps
        poisonGradientCache.clear();
        mechGradientCache.clear();
    }
}

function render(dt) {
    frameCount++;
    clearGradientCaches();
    
    // Performance optimization: Use faster fill method and cache time calculation
    ctx.fillStyle = '#050008'; 
    ctx.fillRect(0, 0, W, H);
    frameTime = performance.now() / 1000;
    
    // Render background stars with optimized drawing
    renderBackgroundStars(dt);
    


    const closeBullets = [];
    const farBullets = [];
    const proximityThreshold = 110;
    const playerPos = store.player;

    store.eBullets.forEach(b => {
        const distSq = (b.x - playerPos.x)**2 + (b.y - playerPos.y)**2; 
        if (distSq < proximityThreshold**2) {
            closeBullets.push({ bullet: b, dist: Math.sqrt(distSq) });
        } else {
            farBullets.push(b);
        }
    });
    
    store.powerups.forEach(p => drawPowerup(p));
    store.missiles.forEach(m => drawMissile(m));
    store.lightningBolts.forEach(l => drawLightningBolt(l));
    store.empNovas.forEach(n => drawEmpNova(n));


    // Optimized far bullets rendering with batched operations
    for (let i = 0; i < farBullets.length; i++) {
        const b = farBullets[i];
        
        // Apply visual fade-in for Death Engine bullet rain
        let alpha = 1.0;
        if (b.fadeInTime && b.spawnTime) {
            const timeAlive = (performance.now() - b.spawnTime) / 1000;
            alpha = Math.min(1.0, timeAlive / b.fadeInTime);
        }
        
        if (alpha < 1.0) {
            ctx.save();
            ctx.globalAlpha = alpha;
        }
        
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, 6.283185307179586); // Use constant
        ctx.fill();
        
        if (alpha < 1.0) {
            ctx.restore();
        }
    }
    
    store.bullets.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.fillStyle = b.col;
        ctx.beginPath();
        
        const r = b.r * 1.5;

        if (b.isLavaChunk) {
            ctx.beginPath();
            ctx.moveTo(0, -r); ctx.lineTo(r, r * 0.2); ctx.lineTo(r * 0.5, r); ctx.lineTo(-r * 0.5, r); ctx.lineTo(-r, r * 0.2);
            ctx.closePath();
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const particleR = p.r * t;
                ctx.fillStyle = `rgba(255, ${60 + Math.random() * 60}, 0, ${0.7 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, particleR, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isFlame) {
            ctx.fillStyle = `rgba(255, 150, 50, ${0.3 * (b.life / 50)})`;
            ctx.beginPath();
            ctx.arc(0, 0, b.r * 0.5, 0, 2 * Math.PI);
            ctx.fill();
            b.particles.forEach(p => {
                const t = p.life / p.maxLife;
                const r_particle = p.r * t;
                const g = Math.floor(255 * (0.4 + t * 0.6));
                const b_val = Math.floor(100 * t);
                ctx.fillStyle = `rgba(${g}, ${b_val}, 0, ${0.8 * t})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r_particle, 0, 2 * Math.PI);
                ctx.fill();
            });
        } else if (b.isSwirl || b.explosive) {
            ctx.arc(0, 0, b.r, 0, 2 * Math.PI);
        } else if (b.isIceman) {
            ctx.moveTo(0, r); ctx.lineTo(r * 0.8, -r * 0.8); ctx.lineTo(-r * 0.8, -r * 0.8);
        } else {
            ctx.moveTo(0, -r); ctx.lineTo(r * 0.8, r * 0.8); ctx.lineTo(-r * 0.8, r * 0.8);
        }

        ctx.closePath();
        ctx.fill();
        ctx.restore();
    });

    store.lasers.forEach(l => drawLaser(l));
    store.mines.forEach(m => drawMine(m));
    if (store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(frameTime * 5)})`; ctx.fill(); ctx.restore(); });
    
    // Draw poison puddles - optimized
    if (store.poisonPuddles) {
        store.poisonPuddles.forEach(puddle => {
            const age = (frameTime * 1000 - puddle.created) / 1000;
            const maxAge = puddle.life + (15 - puddle.life); // Total possible age
            
            ctx.save();
            ctx.translate(puddle.x, puddle.y);
            
            // Animate puddle bubbling - cache sin calculation
            const bubbleOffset = Math.sin(frameTime * 3 + puddle.x * 0.01) * 2;
            
            // Create toxic glow effect - cache gradient by radius
            const glowRadius = puddle.r * 1.5;
            const radiusKey = Math.round(glowRadius);
            let gradient = poisonGradientCache.get(radiusKey);
            if (!gradient) {
                gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                gradient.addColorStop(0, 'rgba(124, 252, 0, 1)');
                gradient.addColorStop(0.7, 'rgba(173, 255, 47, 0.5)');
                gradient.addColorStop(1, 'rgba(124, 252, 0, 0)');
                poisonGradientCache.set(radiusKey, gradient);
            }
            
            const glowAlpha = 0.3 * (puddle.life / 15) + 0.2 * Math.sin(frameTime * 4);
            ctx.globalAlpha = glowAlpha;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // Draw the puddle itself
            const puddleAlpha = Math.max(0.4, puddle.life / 15);
            ctx.fillStyle = `rgba(45, 80, 22, ${puddleAlpha})`;
            ctx.beginPath();
            ctx.arc(0, bubbleOffset, puddle.r, 0, Math.PI * 2);
            ctx.fill();
            
            // Add surface texture/ripples
            ctx.strokeStyle = `rgba(124, 252, 0, ${puddleAlpha * 0.8})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const rippleRadius = puddle.r * (0.3 + i * 0.3) + Math.sin(frameTime * 2 + i) * 3;
                const rippleAlpha = puddleAlpha * (0.8 - i * 0.2);
                ctx.globalAlpha = rippleAlpha;
                ctx.arc(0, bubbleOffset, rippleRadius, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Add occasional toxic bubbles - use time-based approach to reduce randomness
            if (Math.sin(frameTime * 8 + puddle.x * 0.1) > 0.8) {
                const bubbleX = Math.sin(frameTime * 3 + puddle.x) * puddle.r * 0.3;
                const bubbleY = Math.cos(frameTime * 2.5 + puddle.y) * puddle.r * 0.3 + bubbleOffset;
                const bubbleSize = 2 + Math.abs(Math.sin(frameTime * 4 + puddle.x)) * 3;
                
                const bubbleAlpha = 0.6 + Math.abs(Math.cos(frameTime * 5 + puddle.y)) * 0.4;
                ctx.fillStyle = `rgba(124, 252, 0, ${bubbleAlpha})`;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    // Draw mech oil/fuel puddles with aqua color scheme - optimized
    if (store.mechPuddles) {
        store.mechPuddles.forEach(puddle => {
            ctx.save();
            ctx.translate(puddle.x, puddle.y);
            
            // Create flickering aqua energy effect - use cached time
            const flicker = 0.8 + Math.sin(frameTime * 6) * 0.2;
            const pulseOffset = Math.sin(frameTime * 4 + puddle.x * 0.02) * 1.5;
            
            // Calculate shrinking effect as puddle disappears
            const lifePercent = Math.max(0, puddle.life) / puddle.maxLife; // Ensure life is never negative
            const currentRadius = puddle.r * Math.max(0.3, lifePercent); // Shrink to 30% min size
            
            // Create aqua hazardous glow effect - cache gradient by radius
            const glowRadius = currentRadius * 1.4;
            const radiusKey = Math.round(glowRadius);
            let gradient = mechGradientCache.get(radiusKey);
            if (!gradient) {
                gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 1)'); // Bright cyan
                gradient.addColorStop(0.6, 'rgba(32, 178, 170, 0.7)'); // Light sea green
                gradient.addColorStop(1, 'rgba(0, 139, 139, 0)'); // Dark cyan fade
                mechGradientCache.set(radiusKey, gradient);
            }
            
            const glowAlpha = 0.4 * lifePercent * flicker;
            ctx.globalAlpha = glowAlpha;
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, pulseOffset, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw the puddle base (dark aqua/teal liquid) with shrinking
            const puddleAlpha = Math.max(0.6, lifePercent);
            ctx.fillStyle = `rgba(14, 75, 92, ${puddleAlpha})`; // Dark aqua blue base
            ctx.beginPath();
            ctx.arc(0, pulseOffset, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Add aqua energy surface effects with shrinking
            ctx.strokeStyle = `rgba(64, 224, 208, ${puddleAlpha * 0.9})`; // Turquoise ripples
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < 2; i++) {
                const energyRadius = Math.max(0.1, currentRadius * (0.4 + i * 0.3) + Math.sin(frameTime * 3 + i * 2) * 2);
                const energyAlpha = puddleAlpha * (0.7 - i * 0.3) * flicker;
                ctx.globalAlpha = energyAlpha;
                ctx.arc(0, pulseOffset, energyRadius, 0, Math.PI * 2);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            
            // Add occasional aqua energy bubbles (only if puddle is large enough)
            if (currentRadius > 5 && Math.random() < 0.15) {
                const bubbleX = (Math.random() - 0.5) * currentRadius * 0.8;
                const bubbleY = (Math.random() - 0.5) * currentRadius * 0.8 + pulseOffset;
                const bubbleSize = 1 + Math.random() * 2;
                
                ctx.fillStyle = `rgba(0, 255, 255, ${0.8 + Math.random() * 0.2})`; // Bright cyan bubbles
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        });
    }
    
    store.enemies.forEach(e => drawEnemy(e));
    drawGibs(ctx); // <-- ADD THIS LINE TO DRAW THE GIBS
    if (store.boss && store.boss.visible !== false) drawBoss(store.boss);
    store.flameParticles.forEach(p => { if (p.draw) p.draw(); });
    store.drones.forEach(d => drawDrone(d));
    store.hounds.forEach(h => drawHound(h));
    if (store.iceman) drawIceman(store.iceman);
    drawShip(store.player.x, store.player.y, store.player);
    
    // Draw EMP disabled effect on player
    if (store.player.empDisabled) {
        const sizzleIntensity = 0.5 + 0.5 * Math.sin(frameTime * 15);
        
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        
        // Electric sparks around player
        ctx.strokeStyle = `rgba(255, 140, 0, ${sizzleIntensity})`;
        ctx.lineWidth = 2;
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 8;
        
        for (let i = 0; i < 8; i++) {
            if (Math.random() < 0.7) {
                const angle = (i / 8) * Math.PI * 2 + frameTime * 5;
                const radius = store.player.r + 5;
                const x1 = Math.cos(angle) * radius;
                const y1 = Math.sin(angle) * radius;
                const x2 = x1 + (Math.random() - 0.5) * 15;
                const y2 = y1 + (Math.random() - 0.5) * 15;
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        // Purple inner glow
        ctx.fillStyle = `rgba(138, 43, 226, ${sizzleIntensity * 0.3})`;
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(0, 0, store.player.r * 1.2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Draw poison effect on player
    if (store.player.isPoisoned) {
        const poisonAlpha = 0.3 + 0.2 * Math.sin(frameTime * 8);
        
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = `rgba(0, 255, 0, ${poisonAlpha})`;
        ctx.beginPath();
        ctx.arc(store.player.x, store.player.y, store.player.r + 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Add poison particle effect around player
        ctx.save();
        ctx.translate(store.player.x, store.player.y);
        for (let i = 0; i < 6; i++) {
            const angle = frameTime * 2 + i * Math.PI / 3;
            const x = Math.cos(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
            const y = Math.sin(angle) * (store.player.r + 12 + Math.sin(frameTime * 4 + i) * 5);
            
            ctx.fillStyle = `rgba(124, 252, 0, ${0.4 + 0.3 * Math.sin(frameTime * 6 + i)})`;
            ctx.beginPath();
            ctx.arc(x, y, 2 + Math.sin(frameTime * 5 + i), 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    // Draw voidmancer laser beam
    if (store.player.hasVoidLaser && store.player.voidLaserTarget && !store.player.voidLaserTarget.dead) {
        const p = store.player;
        const target = p.voidLaserTarget;
        
        // Determine laser color based on player ship color
        let laserColor = '#b266ff'; // Default purple
        switch (p.subclass) {
            case 'juggernaut':
                laserColor = '#ff3333';
                break;
            case 'marauder':
                laserColor = '#33cc33';
                break;
            case 'railgunner':
                laserColor = '#ff6600';
                break;
            case 'demolitionist':
                laserColor = '#ff4500';
                break;
            case 'phasestriker':
                laserColor = '#9900ff';
                break;
            case 'stormcaller':
                laserColor = '#00ccff';
                break;
        }
        
        const time = performance.now() / 1000;
        const pulseAlpha = 0.6 + 0.4 * Math.sin(time * 12);
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Calculate ramping size for level 2 phasestriker
        let baseLineWidth = 3;
        let glowLineWidth = 6;
        
        if (p.phasestRikerLevel >= 2) {
            const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // Same ramp as damage
            const sizeMultiplier = Math.min(rampMultiplier, 3.0); // Cap at 3x size
            baseLineWidth *= sizeMultiplier;
            glowLineWidth *= sizeMultiplier;
        }
        
        // Draw main laser beam
        ctx.strokeStyle = laserColor;
        ctx.globalAlpha = pulseAlpha;
        ctx.lineWidth = baseLineWidth;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - 12);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        
        // Draw laser glow effect
        const gradient = ctx.createLinearGradient(p.x, p.y - 12, target.x, target.y);
        gradient.addColorStop(0, laserColor + '80');
        gradient.addColorStop(0.5, laserColor + 'FF');
        gradient.addColorStop(1, laserColor + '80');
        
        ctx.strokeStyle = gradient;
        ctx.globalAlpha = pulseAlpha * 0.5;
        ctx.lineWidth = glowLineWidth;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y - 12);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        
        // Add impact effect at target
        ctx.fillStyle = laserColor;
        ctx.globalAlpha = pulseAlpha;
        ctx.beginPath();
        ctx.arc(target.x, target.y, 4 + Math.sin(time * 8) * 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    
    closeBullets.forEach(item => {
        const b = item.bullet;
        const dist = item.dist;
        
        // Apply fade-in for Death Engine bullet rain
        let fadeAlpha = 1.0;
        if (b.fadeInTime && b.spawnTime) {
            const timeAlive = (performance.now() - b.spawnTime) / 1000;
            fadeAlpha = Math.min(1.0, timeAlive / b.fadeInTime);
        }
        
        const proxFactor = 1.0 - (dist / proximityThreshold);

        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = proxFactor * fadeAlpha; 
        const glowRadius = b.r * 2;
        const gradient = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, glowRadius);
        gradient.addColorStop(0.3, b.col);
        gradient.addColorStop(1, b.col + '00');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(b.x, b.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = fadeAlpha;
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255, 255, 255, ${proxFactor * 0.8 * fadeAlpha})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
    
    store.activeEffects.forEach(e => e.draw && e.draw());
    renderVoidStepSystems(ctx);
    renderImpactSystem(ctx);
    updateHUD();
}
    
    function takeDamage(dmg) {
        if (store.player.isInvincible || playerIsInvulnerable()) return;
        // Removed boss invincibility check here - that was preventing ALL damage incorrectly

        if (store.player.hasShieldBubble) {
            store.player.hasShieldBubble = false;
            store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
            return;
        }
        const p = store.player;
        
        // Beef shield takes damage first if pilot is beef
        if (p.pilotGenome === 'beef' && p.beefShield > 0 && p.beefShieldCooldown <= 0) {
            const beefAbsorbed = Math.min(p.beefShield, dmg);
            p.beefShield -= beefAbsorbed;
            dmg -= beefAbsorbed;
            p.beefShieldDamageTaken += beefAbsorbed;
            console.log(`Beef shield absorbed ${beefAbsorbed} damage, remaining: ${p.beefShield}`);
            
            // If beef shield was depleted, start cooldown
            if (p.beefShield <= 0) {
                p.beefShieldCooldown = 2.0; // 2 second cooldown before shield can absorb again
                console.log('Beef shield depleted - starting cooldown');
            }
            
            if (dmg <= 0) return; // All damage absorbed by beef shield
        }
        
        const a = Math.min(p.shield, dmg);
        if (a < dmg) playSound('hit');
        p.shield -= a;
        dmg -= a;
        
        // Check for nano save BEFORE applying damage
        const hpAfterDamage = p.hp - dmg;
        if (hpAfterDamage <= 0 && hpAfterDamage > -p.hpMax * 0.75 && p.nanoSaves > 0) {
            p.nanoSaves--;
            p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.25);
            store.activeEffects.push(createEffect("nanoHeal"));
            announce('NANO SAVE ACTIVATED!');
            return; // Don't apply the lethal damage
        }
        
        p.hp = Math.max(0, hpAfterDamage);

        if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
            store.world.lowHealthTutorialShown = true;
            showShopWithHighlight();
        }
    }
    
    function updateBeefShield() {
        if (store.player.pilotGenome !== 'beef') return;
        
        const p = store.player;
        const damageDealt = p.beefShieldDamageDealt;
        const damageTaken = p.beefShieldDamageTaken;
        
        // Skip if no damage events
        if (damageDealt === 0 && damageTaken === 0) return;
        
        // Update cooldown
        if (p.beefShieldCooldown > 0) {
            p.beefShieldCooldown -= 0.016; // Decrease by ~1/60 (assuming 60 FPS)
            if (p.beefShieldCooldown < 0) p.beefShieldCooldown = 0;
        }
        
        // Growth rate: 1 shield per 50 damage dealt, shrinkage rate: 1 shield per 30 damage taken
        // Made more responsive for better gameplay feel
        const shieldChange = (damageDealt * 0.02) - (damageTaken * 0.033);
        
        if (shieldChange > 0) {
            // Shield grows
            p.beefShield = Math.min(p.beefShieldMax, p.beefShield + shieldChange);
        } else if (shieldChange < 0) {
            // Shield shrinks (but not below 0)
            p.beefShield = Math.max(0, p.beefShield + shieldChange);
        }
        
        // Reset damage tracking counters
        p.beefShieldDamageDealt = 0;
        p.beefShieldDamageTaken = 0;
        
        // Only log if there was a significant change
        if (Math.abs(shieldChange) > 0.1) {
            console.log(`Beef shield updated: ${Math.round(p.beefShield)}/${p.beefShieldMax} (change: ${shieldChange.toFixed(2)})`);
        }
    }
    
    function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function announce(text) { const el = q('announce'); el.textContent = text; el.classList.remove('hide'); clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); }
    function updateHUD() { 
        const t = store.player;
        const hpPercent = Math.round(t.hp / t.hpMax * 100);
        const shieldPercent = t.shieldMax > 0 ? Math.round(t.shield / t.shieldMax * 100) : 0;
        const beefShieldPercent = t.pilotGenome === 'beef' && t.beefShieldMax > 0 ? Math.round(t.beefShield / t.beefShieldMax * 100) : 0;
        
        // Update pilot info with textContent (no DOM parsing)
        q("pilotTitle").textContent = store.name ? `‚ó¢ ${store.name} ‚ó£` : "‚ó¢ UNIDENTIFIED ‚ó£";
        q("scoreNum").textContent = store.world.score;
        q("goldNum").textContent = store.world.gold;
        
        // Update health bar and text
        q("hpBarFill").style.width = hpPercent + "%";
        q("hpText").textContent = `HP: ${Math.round(t.hp)} / ${t.hpMax}`;
        
        // Handle beef shield
        const beefShieldBar = q("beefShieldBar");
        const beefShieldText = q("beefShieldText");
        if (t.pilotGenome === 'beef' && t.beefShieldMax > 0) {
            beefShieldBar.style.display = "block";
            q("beefShieldBarFill").style.width = beefShieldPercent + "%";
            beefShieldText.textContent = `BEEF SHIELD: ${Math.round(t.beefShield)} / ${t.beefShieldMax}`;
        } else {
            beefShieldBar.style.display = "none";
            beefShieldText.textContent = "";
        }
        
        // Handle regular shield
        const shieldBar = q("shieldBar");
        const shieldTextEl = q("shieldText");
        if (t.shieldMax > 0) {
            shieldBar.style.display = "block";
            q("shieldBarFill").style.width = shieldPercent + "%";
            shieldTextEl.textContent = `SHIELD: ${Math.round(t.shield)} / ${t.shieldMax}`;
        } else {
            shieldBar.style.display = "none";
            shieldTextEl.textContent = "";
        }
        
        // Update wave info
        q("waveNum").textContent = store.world.wave;
        q("killsNum").textContent = store.world.kills;
        q("levelNum").textContent = store.world.level;
        
        // Update boss info
        const bossContent = q("hudBossContent");
        if (store.boss) {
            bossContent.classList.remove("hide");
            q("bossTitle").textContent = `‚ö° ${store.boss.name} ‚ö°`;
            q("bossBarFill").style.width = Math.round(store.boss.hp / store.boss.hpMax * 100) + "%";
        } else {
            bossContent.classList.add("hide");
        }
        
        // Update powerups (still needs some innerHTML for dynamic content)
        const powerupEl = q("hudPowerup");
        const timedPowerups = Object.keys(store.player.powerupTimers);
        if (timedPowerups.length > 0) {
            let timedContent = '';
            timedPowerups.forEach(key => {
                const timer = store.player.powerupTimers[key];
                const percent = Math.min(100, (timer.remaining / timer.max) * 100);
                timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`;
            });
            q("powerupList").innerHTML = timedContent;
            powerupEl.classList.remove('hide');
        } else {
            powerupEl.classList.add('hide');
        }
        
        // Update equipment (still needs some innerHTML for dynamic content)
        const equipEl = q("hudEquipment");
        let hasEquipment = store.player.hasLauncher || store.player.hasHounds || store.player.nanoSaves > 0;
        if (hasEquipment) {
            let content = '';
            if (store.player.nanoSaves > 0) content += `<div>NANO SAVE [${store.player.nanoSaves}]</div>`;
            if (store.player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`;
            if (store.player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`;
            q("equipmentList").innerHTML = content;
            equipEl.classList.remove('hide');
        } else {
            equipEl.classList.add('hide');
        }
        
        // Update grenade button
        const grenadeBtn = q('grenadeBtnUI');
        if (store.player.grenades > 0) {
            grenadeBtn.classList.remove('hide');
            grenadeBtn.textContent = `GRENADE [${store.player.grenades}]`;
            grenadeBtn.disabled = false;
        } else {
            grenadeBtn.classList.add('hide');
        } 
        
        // Update FPS counter
        if (!store.fpsLastTime) {
            store.fpsLastTime = performance.now();
            store.fpsFrameCount = 0;
        }
        store.fpsFrameCount++;
        const now = performance.now();
        if (now - store.fpsLastTime >= 1000) {
            const fps = Math.round((store.fpsFrameCount * 1000) / (now - store.fpsLastTime));
            q('fps').textContent = fps;
            // Enhanced collar display with better feedback
            const collarStacks = store.world.collarStacks || 0;
            const collarPercent = (collarStacks * 0.08) * 100;
            const collarStatus = collarStacks === 0 ? 'LOOSE' : 
                                collarStacks < 5 ? 'SNUG' :
                                collarStacks < 15 ? 'TIGHT' :
                                collarStacks < 25 ? 'CRUSHING' : 'MAXIMUM';
            q('collar').textContent = `${collarStacks.toFixed(1)} (${collarPercent.toFixed(0)}%) ${collarStatus}`;
            
            // Calculate damage per bullet and average enemy HP
            const baseDamage = 15; // Updated from 20 to 15 (75% of original)
            const actualDamage = baseDamage * store.player.dmgMult;
            q('damagePerBullet').textContent = `${actualDamage.toFixed(1)}`;
            
            // Calculate average enemy HP across all enemy types
            const enemyTypes = [
                { hp: 20, name: 'drone' }, { hp: 15, name: 'hunter' }, { hp: 30, name: 'phantom' },
                { hp: 80, name: 'mech' }, { hp: 120, name: 'angler' }, { hp: 150, name: 'manta' }
            ];
            const collarBonus = 1 + (store.world.collarStacks * 0.08);
            const avgBaseHp = enemyTypes.reduce((sum, type) => sum + type.hp, 0) / enemyTypes.length;
            const waveMultiplier = Math.pow(1.03, store.world.wave - 1);
            const avgCurrentHp = avgBaseHp * waveMultiplier * collarBonus;
            q('avgEnemyHp').textContent = `${avgCurrentHp.toFixed(0)}`;
            
            store.fpsFrameCount = 0;
            store.fpsLastTime = now;
            
            // Update health table
            if (store.enemies.length > 0) {
                const enemy = store.enemies[0];
                q('enemyBaseHp').textContent = Math.round(enemy.hpMax / collarBonus);
                q('enemyCurrentHp').textContent = Math.round(enemy.hp);
            } else {
                q('enemyBaseHp').textContent = '-';
                q('enemyCurrentHp').textContent = '-';
            }
            if (store.boss) {
                q('bossBaseHp').textContent = Math.round(store.boss.hpMax / collarBonus);
                q('bossCurrentHp').textContent = Math.round(store.boss.hp);
            } else {
                q('bossBaseHp').textContent = '-';
                q('bossCurrentHp').textContent = '-';
            }
        }
    }
    function updateLeaderboard(leaderboardData) { 
        const fallbackData = [
            { name: "ACE PILOT", score: 50000, waves: 10 },
            { name: "VOID RUNNER", score: 35000, waves: 8 },
            { name: "STAR HUNTER", score: 25000, waves: 6 },
            { name: "NOVA STRIKER", score: 18000, waves: 5 },
            { name: "COSMIC GUARD", score: 12000, waves: 4 }
        ]; 
        
        // Handle both old format (array) and new format (object with entries)
        let data;
        if (leaderboardData && leaderboardData.entries) {
            data = leaderboardData.entries;
        } else if (leaderboardData && Array.isArray(leaderboardData)) {
            data = leaderboardData;
        } else {
            data = fallbackData;
        }
        
        q("hsList").innerHTML = data.map(s => `<li>${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); 
        q("hsListPopup").innerHTML = data.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); 
    }
    
    async function refreshScoreList() { 
        try { 
            const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 }); 
            if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`); 
            const data = await res.json(); 
            // data.entries contains up to 50 players
            updateLeaderboard(data); 
        } catch (err) { 
            console.warn("Failed to fetch leaderboard, using offline data:", err.message); 
            updateLeaderboard(null); 
        } 
    }
    async function addScore(score) {
        if (store.cheatsUsed) {
            announce("Score not submitted: Cheats used");
            return;
        }
        const name = (store.name || "ROGUE").slice(0, 16); 
        try { 
            const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 }); 
            if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`); 
            const { nonce } = await nonceRes.json(); 
            const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce }; 
            const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 }); 
            if (!res.ok) throw new Error(`Submit failed: ${res.status}`); 
            const data = await res.json(); 
            if (data.ok) { 
                updateLeaderboard(data.top50 || data.top10); 
            } else { 
                console.warn("Score rejected:", data.err); 
                announce(`Score rejected: ${data.err}`); 
                refreshScoreList(); 
            } 
        } catch (err) { 
            console.warn("Score submission failed, game continues offline:", err.message); 
        } 
    }
    function fireBullet(x, y, vx, vy, props = {}) { 
        const p = store.player; 
        const bullet = getBulletFromPool({
            x, y, vx, vy, 
            r: p.explosive ? 5 : 3, 
            col: p.explosive ? "#ED2F32" : "#b266ff", 
            dmg: 15 * p.dmgMult, 
            pierce: p.piercing, 
            explosive: p.explosive, 
            ...props
        });
        store.bullets.push(bullet);
    }
    function firePlayer() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        const baseBulletSpeed = 420;
        const bulletSpeed = baseBulletSpeed * (p.temporalSpeedBoost || 1); // Chrono Blast speed boost
        const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0);
        const angleSpread = 10;
        for (let i = 0; i < totalMultishot; i++) { 
            const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; 
            const bullet = getBulletFromPool({
                x: p.x + 10 * Math.sin(angle), 
                y: p.y - 12, 
                vx: Math.sin(angle) * bulletSpeed, 
                vy: -Math.cos(angle) * bulletSpeed, 
                r: p.explosive ? 5 : 3, 
                col: p.explosive ? "#cc99ff" : "#b266ff", 
                dmg: 15 * p.dmgMult, 
                pierce: p.piercing, 
                explosive: p.explosive
            });
            store.bullets.push(bullet);
        }
        if (p.hasIceman && store.iceman) { for (let i = 0; i < totalMultishot; i++) { const angle = (i - (totalMultishot - 1) / 2) * angleSpread * Math.PI / 180; store.bullets.push({ x: store.iceman.x + 10 * Math.sin(angle), y: store.iceman.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: "#66aaff", dmg: 15 * p.dmgMult * 0.35, pierce: p.piercing, explosive: p.explosive, isIceman: true }); } }
        if (p.rearMultishot > 0) { const rearAngleSpread = 15; for (let i = 0; i < p.rearMultishot; i++) { const angle = (i - (p.rearMultishot - 1) / 2) * rearAngleSpread; const radAngle = angle * Math.PI / 180; store.bullets.push({ x: p.x + 10 * Math.sin(radAngle), y: p.y + 12, vx: Math.sin(radAngle) * bulletSpeed, vy: Math.cos(radAngle) * bulletSpeed, r: 3, col: "#ffddff", dmg: 11.25 * p.dmgMult, pierce: p.piercing > 0 ? p.piercing - 1 : 0 }); } }
        store.drones.forEach(drone => store.bullets.push({ x: p.x + drone.offset, y: p.y + 20, vx: 0, vy: -bulletSpeed, r: 3, col: "#66aaff", dmg: 15 * p.dmgMult * 0.4, isDrone: true }));
        if (p.hasLauncher) {
            const speed = 350;
            const numPairs = store.player.upgradeLevels.launcher || 1;
            for (let i = 0; i < numPairs; i++) {
                const spread = 15 + i * 10;
                const vx_offset = 50 + i * 20;
                store.bullets.push({ x: p.x - spread, y: p.y, vx: -vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                store.bullets.push({ x: p.x + spread, y: p.y, vx: vx_offset, vy: -speed, r: 4, col: '#ff8080', dmg: 2 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true });
                if (p.hasIceman && store.iceman) {
                    store.bullets.push({ x: store.iceman.x - spread, y: store.iceman.y, vx: -vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                    store.bullets.push({ x: store.iceman.x + spread, y: store.iceman.y, vx: vx_offset, vy: -speed, r: 4, col: '#66aaff', dmg: 2 * p.dmgMult * 0.35, explosive: true, pierce: false, life: 0, isSwirl: true, isIceman: true });
                }
            }
        }
    }
    
    function fireFlamethrower() {
        const p = store.player;
        if (p.beefChargeState && p.beefChargeState !== 'ready') return;
        
        let numFlames, angleRange, speed, life;
        switch (p.flamethrowerLevel) {
            case 1: numFlames = 4; angleRange = 40; speed = 250; life = 0.35; break;    // Halved from 8
            case 2: numFlames = 6; angleRange = 70; speed = 280; life = 0.4; break;     // Halved from 12
            default: numFlames = 8; angleRange = 90; speed = 320; life = 0.5; break;    // Halved from 16
        }
        
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
            const currentSpeed = speed + Math.random() * 40;
            const sideOffset = (i % 2 === 0) ? -15 : 15;
            const spawnX = p.x + sideOffset;
            const spawnY = p.y + 5;
            store.bullets.push({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 3, col: `rgba(255, ${60 + Math.random() * 60}, 0, 0.9)`, dmg: 2 * p.dmgMult, life: life * 1.5, isFlame: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
        }
        
        if (p.hasIceman && store.iceman) {
            for (let i = 0; i < numFlames; i++) {
                const angle = (Math.random() - 0.5) * angleRange * Math.PI / 180;
                const currentSpeed = speed + Math.random() * 40;
                const sideOffset = (i % 2 === 0) ? -15 : 15;
                const spawnX = store.iceman.x + sideOffset;
                const spawnY = store.iceman.y + 5;
                store.bullets.push({ x: spawnX, y: spawnY, vx: Math.sin(angle) * currentSpeed + (sideOffset * 2), vy: -Math.cos(angle) * currentSpeed, r: 4 + Math.random() * 2, col: `rgba(100, 150, 255, 0.7)`, dmg: 2 * p.dmgMult * 0.35, life: life, isFlame: true, isIceman: true, isLavaChunk: true, particles: [], particleSpawnT: 0 });
            }
        }
    }
    
    function stepBossOmegaSentinel(dt, b, dmgScale) {
        // Movement behavior
        if (b.y >= 100) {
            b.moveT += dt;
            b.x += Math.sin(b.moveT * 2) * 200 * dt;
            b.x = clamp(b.x, 100, W - 100);
        }
        
        // Initialize EMP nova timer if not set
        if (b.empNovaTimer === undefined) {
            b.empNovaTimer = 8; // EMP nova every 8 seconds
        }
        
        // EMP Nova attack countdown
        b.empNovaTimer -= dt;
        if (b.empNovaTimer <= 0) {
            // Create EMP nova
            store.empNovas.push({
                x: b.x,
                y: b.y,
                radius: 0,
                maxRadius: H / 3, // 1/3 of screen height
                speed: 80, // Slow expansion speed
                life: 15, // Lives for 15 seconds
                dead: false
            });
            b.empNovaTimer = 8; // Reset timer
        }
        
        // Regular attack patterns
        b.fireT -= dt;
        if (b.fireT <= 0) {
            if (b.patternPhase % 4 === 0) {
                // Radial burst
                b.fireT = 1.5;
                const n = 12;
                for (let i = 0; i < n; i++) {
                    const a = (i * Math.PI / 6) + b.t;
                    store.eBullets.push({
                        x: b.x,
                        y: b.y,
                        vx: 150 * Math.cos(a),
                        vy: 150 * Math.sin(a),
                        r: 4,
                        col: '#4169e1',
                        dmg: 12 * dmgScale
                    });
                }
            } else {
                // Aimed shot
                b.fireT = 0.2;
                const a = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                store.eBullets.push({
                    x: b.x,
                    y: b.y,
                    vx: 250 * Math.cos(a),
                    vy: 250 * Math.sin(a),
                    r: 5,
                    col: '#add8e6',
                    dmg: 18 * dmgScale
                });
            }
            b.patternPhase++;
        }
    }
    function stepBossCoreMalignus(dt, b, dmgScale) { if (b.hp / b.hpMax <= 0.07 && !b.isEnraged) { b.isEnraged = true; playSound('horn'); } if (b.y >= 100) { b.moveT += dt; b.x = W / 2 + (W / 2 - 100) * Math.sin(b.moveT * 0.5); } b.fireT -= dt; if (b.fireT <= 0) { b.fireT = b.isEnraged ? 0.6 : 0.8; const n = 12, g = 3, s = Math.floor(Math.random() * (n - g)); for (let i = 0; i < n; i++) { if (i >= s && i < s + g) continue; const p = (W / (n + 1)) * (i + 1); store.eBullets.push({ x: p, y: b.y, vx: 0, vy: 180, r: 6, col: b.color, dmg: 20 * dmgScale }); } } }
    function stepBossTheHex(dt, b, dmgScale) { 
        if (b.y >= 100) { 
            b.moveT += dt; 
            b.x = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4)); 
        } 
        b.fireT -= dt; 
        if (b.hp / b.hpMax < 0.5 && !b.isEnraged) { 
            b.isEnraged = true; 
            playSound('trap'); 
        } 
        const fireRate = b.isEnraged ? 0.8 : 1.5; 
        if (b.fireT <= 0) { 
            b.fireT = fireRate; 
            b.attackPhase = (b.attackPhase + 1) % 3; 
            switch(b.attackPhase) { 
                case 0: 
                    // Gold rain with interspersed powerups for strategic gambling
                    for (let i = 0; i < 20; i++) { 
                        setTimeout(() => { 
                            // 20% chance to spawn a powerup instead of a bullet (strategic gamble)
                            if (Math.random() < 0.2) {
                                // Spawn yellow powerup that looks similar to gold bullets
                                // Use valid powerup types from POWERUP_TYPES
                                const powerupTypes = ['double', 'missile', 'drones', 'shield'];
                                const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                                
                                store.powerups.push({
                                    x: Math.random() * W,
                                    y: 0,
                                    vx: 0,
                                    vy: 250, // Same speed as bullets to blend in
                                    r: 6, // Slightly larger to be distinguishable
                                    type: randomType,
                                    life: H / 250 + 2 // Ensure it lives long enough to reach bottom
                                });
                            } else {
                                // Spawn normal gold bullet
                                store.eBullets.push({ 
                                    x: Math.random() * W, 
                                    y: 0, 
                                    vx: 0, 
                                    vy: 250, 
                                    r: 5, 
                                    col: '#ffc83d', 
                                    dmg: 15 * dmgScale 
                                }); 
                            }
                        }, i * 50); 
                    } 
                    break; 
                case 1: 
                    for (let i = 0; i < 4; i++) { 
                        const isHorizontal = i < 2; 
                        const y = isHorizontal ? 100 + i * 150 : 0; 
                        const x = isHorizontal ? 0 : 200 + (i-2) * 250; 
                        const vx = isHorizontal ? 300 : 0; 
                        const vy = isHorizontal ? 0 : 300; 
                        store.eBullets.push({ 
                            x: x, 
                            y: y, 
                            vx: vx, 
                            vy: vy, 
                            r: 4, 
                            col: '#80ffff', 
                            dmg: 20 * dmgScale, 
                            isLaser: true, 
                            life: 2.5 
                        }); 
                    } 
                    break; 
                case 2: 
                    const targetX = store.player.x; 
                    const dx = targetX - b.x; 
                    const dashSpeed = 800; 
                    b.vx = Math.sign(dx) * dashSpeed; 
                    setTimeout(() => { 
                        b.vx = 0; 
                    }, 500); 
                    break; 
            } 
        } 
        if(b.vx) { 
            b.x += b.vx * dt; 
            store.eBullets.push({ 
                x: b.x, 
                y: b.y, 
                vx: 0, 
                vy: 0, 
                r: 8, 
                col: '#ff8080', 
                dmg: 25 * dmgScale, 
                life: 1 
            }); 
        } 
    }
    function stepBossGeometron(dt, b, dmgScale) { 
        // Handle DEATH ENGINE specific behavior
        if (b.name === 'DEATH ENGINE') {
            // Initialize skull ship specific properties
            if (!b.skullPhaseInitialized) {
                b.skullPhaseInitialized = true;
                b.phase = 1;
                b.disappearPhase = false;
                b.disappearStartTime = 0;
                b.safeZoneY = H * 0.5; // Start safe zone in middle
                b.safeZoneChanges = 0;
                b.maxSafeZoneChanges = 3;
                b.hasDoneSecondDisappear = false;
            }

            // Phase 1: Normal attacks until 50% HP
            if (b.phase === 1 && b.hp / b.hpMax > 0.5) {
                // Movement
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * 0.3); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Normal attack pattern
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                            // Trigger Death Engine laugh
                            b.isLaughing = true;
                            b.laughStartTime = performance.now();
                            if (b.skullRenderer) {
                                b.skullRenderer.triggerAttack(true);
                            }
                            const n = 12; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 160 * Math.cos(a), vy: 160 * Math.sin(a), r: 4, col: '#8B0000', dmg: 18 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Aimed shots at player
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < 5; i++) { 
                                const angle = angleToPlayer + (i - 2) * 0.15; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 280 * Math.cos(angle), vy: 280 * Math.sin(angle), r: 5, col: '#FF4500', dmg: 22 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // Spawn construct gold
                            const numgold = 2 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 120; 
                                gold.y = b.y + 60; 
                                gold.color = '#8B0000';
                                store.enemies.push(gold); 
                            } 
                            break;
                        case 3:
                            // New attack phase: Bouncing skull projectiles
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * Math.PI / 3) + (Math.random() - 0.5) * 0.3;
                                const speed = 150 + Math.random() * 50;
                                store.eBullets.push({ 
                                    x: b.x, 
                                    y: b.y, 
                                    vx: Math.cos(angle) * speed, 
                                    vy: Math.sin(angle) * speed, 
                                    r: 6, 
                                    col: '#DC143C', 
                                    dmg: 20 * dmgScale,
                                    bounces: 2, // Special bouncing bullets
                                    life: 4.0
                                }); 
                            }
                            break; 
                    }
                }
            }
            // Phase transition: Disappear and start train bullet pattern
            else if (b.phase === 1 && b.hp / b.hpMax <= 0.5) {
                b.phase = 2;
                b.disappearPhase = true;
                b.disappearStartTime = performance.now();
                b.isInvincible = true;
                b.visible = false; // Hide the boss
                
                // Move boss offscreen below player so it can't be shot
                b.x = W / 2;
                b.y = H + 200; // Move well below the screen
                
                // Update skull renderer position to be offscreen too
                if (b.skullRenderer) {
                    b.skullRenderer.x = b.x;
                    b.skullRenderer.y = b.y;
                }
                
                playSound('shao_kahn'); // Skull laugh when disappearing
                announce('THE DEATH ENGINE VANISHES INTO THE VOID!');
                
                // Reset safe zone position and changes
                b.safeZoneY = H * 0.5;
                b.safeZoneChanges = 0;
            }
            // Phase 2: Disappear phase with train bullets
            else if (b.disappearPhase) {
                const disappearTime = (performance.now() - b.disappearStartTime) / 1000;
                
                // Spawn train bullets continuously - 2 chunks moving opposite directions with safe zone in middle
                if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                b.trainBulletTimer -= dt;
                
                if (b.trainBulletTimer <= 0) {
                    b.trainBulletTimer = 0.08; // Very frequent spawning
                    
                    const safeZoneHeight = 120; // Safe zone in middle
                    const safeZoneY = H * 0.5; // Center of screen
                    const bulletSpeed = 280;
                    const bulletSpacing = 25;
                    
                    // Top chunk: bullets moving right to left (from top)
                    const topBoundary = safeZoneY - safeZoneHeight/2;
                    if (topBoundary > 30) {
                        for (let y = 0; y < topBoundary; y += bulletSpacing) {
                            store.eBullets.push({
                                x: -10, y: y,
                                vx: bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                    
                    // Bottom chunk: bullets moving left to right (from bottom)
                    const bottomBoundary = safeZoneY + safeZoneHeight/2;
                    if (bottomBoundary < H - 30) {
                        for (let y = bottomBoundary; y < H; y += bulletSpacing) {
                            store.eBullets.push({
                                x: W + 10, y: y,
                                vx: -bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                }
                
                // Return after 4 seconds (single phase)
                if (disappearTime > 4) {
                    b.disappearPhase = false;
                    b.visible = true;
                    b.isInvincible = false;
                    b.fireT = 1.0;
                    
                    // Reposition boss
                    b.x = W / 2;
                    b.y = 100;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Another laugh as he returns
                    announce('THE DEATH ENGINE RETURNS!');
                }
            }
            // Second disappear phase (enraged) - 2 fields of bullets with contact safe zone
            else if (b.disappearPhase && b.hasDoneSecondDisappear) {
                const disappearTime = (performance.now() - b.disappearStartTime) / 1000;
                
                // Spawn train bullets continuously - 2 fields going opposite directions with contact safe zone
                if (!b.trainBulletTimer) b.trainBulletTimer = 0;
                b.trainBulletTimer -= dt;
                
                if (b.trainBulletTimer <= 0) {
                    b.trainBulletTimer = 0.06; // Even more frequent spawning for enraged phase
                    
                    const safeZoneWidth = 60; // Narrower safe zone - contact without buffer
                    const safeZoneX = W * 0.5; // Center of screen
                    const bulletSpeed = 320; // Faster bullets
                    const bulletSpacing = 20;
                    
                    // Left field: bullets moving right (from left side)
                    const leftBoundary = safeZoneX - safeZoneWidth/2;
                    if (leftBoundary > 30) {
                        for (let x = 0; x < leftBoundary; x += bulletSpacing) {
                            for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                store.eBullets.push({
                                    x: x, y: y,
                                    vx: bulletSpeed, vy: 0,
                                    r: 5, col: '#FF0000',
                                    dmg: 30 * dmgScale, // Higher damage
                                    life: (W + 20) / bulletSpeed + 1,
                                    fadeInTime: 2.0, // 2 second fade-in
                                    spawnTime: performance.now()
                                });
                            }
                        }
                    }
                    
                    // Right field: bullets moving left (from right side)
                    const rightBoundary = safeZoneX + safeZoneWidth/2;
                    if (rightBoundary < W - 30) {
                        for (let x = rightBoundary; x < W; x += bulletSpacing) {
                            for (let y = 0; y < H; y += bulletSpacing * 2) { // Fill vertically
                                store.eBullets.push({
                                    x: x, y: y,
                                    vx: -bulletSpeed, vy: 0,
                                    r: 5, col: '#FF0000',
                                    dmg: 30 * dmgScale, // Higher damage
                                    life: (W + 20) / bulletSpeed + 1,
                                    fadeInTime: 2.0, // 2 second fade-in
                                    spawnTime: performance.now()
                                });
                            }
                        }
                    }
                }
                
                // Return after 5 seconds (longer enraged phase)
                if (disappearTime > 5) {
                    b.disappearPhase = false;
                    b.visible = true;
                    b.isInvincible = false;
                    b.fireT = 0.5; // Very aggressive after returning
                    
                    // Reposition boss
                    b.x = W / 2;
                    b.y = 100;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Final laugh as he returns
                    announce('THE DEATH ENGINE RETURNS FOR THE FINAL ASSAULT!');
                }
            }
            // Phase 2: Normal combat after returning
            else if (b.phase === 2 && !b.disappearPhase) {
                // Calculate health percentage for final phase mechanics
                const healthPercent = b.hp / b.hpMax;
                const isFinalPhase = healthPercent <= 0.25; // Final phase at 25% health
                
                // Second disappear phase when enraged (red)
                if (isFinalPhase && !b.hasDoneSecondDisappear) {
                    b.hasDoneSecondDisappear = true;
                    b.disappearPhase = true;
                    b.disappearStartTime = performance.now();
                    b.isInvincible = true;
                    b.visible = false;
                    
                    // Move boss offscreen
                    b.x = W / 2;
                    b.y = H + 200;
                    
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                    
                    playSound('shao_kahn'); // Skull laugh when disappearing again
                    announce('THE DEATH ENGINE VANISHES INTO THE VOID AGAIN!');
                    
                    // Reset bullet timer
                    b.trainBulletTimer = 0;
                }
                
                // Red coloration and faster movement in final phase
                const moveSpeed = isFinalPhase ? 0.9 : 0.6; // Faster movement when low on health
                if (b.y >= 100) { 
                    b.moveT += dt; 
                    b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
                    // Update skull renderer position
                    if (b.skullRenderer) {
                        b.skullRenderer.x = b.x;
                        b.skullRenderer.y = b.y;
                    }
                }
                
                // Override skull ship color to red when in final phase
                if (isFinalPhase && b.color !== '#FF0000') {
                    b.color = '#FF0000'; // Turn red in final phase
                }
                
                // ENRAGE PHASE: Spawn 1/4 density of intermission bullets passing through play field
                if (isFinalPhase) {
                    if (!b.enrageBulletTimer) b.enrageBulletTimer = 0;
                    b.enrageBulletTimer -= dt;
                    
                    if (b.enrageBulletTimer <= 0) {
                        b.enrageBulletTimer = 0.32; // 1/4 density of normal intermission (0.08 * 4)
                        
                        const bulletSpeed = 280;
                        const bulletSpacing = 25;
                        
                        // Spawn bullets from left side moving right (top half)
                        for (let y = 0; y < H * 0.5; y += bulletSpacing * 4) { // Every 4th bullet spacing
                            store.eBullets.push({
                                x: -10, y: y,
                                vx: bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                        
                        // Spawn bullets from right side moving left (bottom half)
                        for (let y = H * 0.5; y < H; y += bulletSpacing * 4) { // Every 4th bullet spacing
                            store.eBullets.push({
                                x: W + 10, y: y,
                                vx: -bulletSpeed, vy: 0,
                                r: 6, col: '#FF0000',
                                dmg: 25 * dmgScale,
                                life: (W + 20) / bulletSpeed + 1,
                                fadeInTime: 2.0, // 2 second fade-in
                                spawnTime: performance.now()
                            });
                        }
                    }
                }
                
                // More aggressive attacks, even faster in final phase
                const fireRate = isFinalPhase ? 1.2 : 1.8; // Faster attacks in final phase
                b.fireT -= dt; 
                if (b.fireT <= 0) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = fireRate;
                    switch(b.attackPhase) { 
                        case 0: 
                            // Trigger Death Engine laugh
                            b.isLaughing = true;
                            b.laughStartTime = performance.now();
                            if (b.skullRenderer) {
                                b.skullRenderer.triggerAttack(true);
                            }
                            // Dense spiral (more bullets in final phase)
                            const n = isFinalPhase ? 20 : 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 1.2; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 200 * Math.cos(a), vy: 200 * Math.sin(a), r: 5, col: bulletColor, dmg: 20 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                            // Triple aimed shots (more spread in final phase)
                            const shotCount = isFinalPhase ? 9 : 7;
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < shotCount; i++) { 
                                const angle = angleToPlayer + (i - Math.floor(shotCount/2)) * 0.12; 
                                const bulletColor = isFinalPhase ? '#FF0000' : '#FF4500';
                                store.eBullets.push({ x: b.x, y: b.y, vx: 320 * Math.cos(angle), vy: 320 * Math.sin(angle), r: 5, col: bulletColor, dmg: 25 * dmgScale }); 
                            } 
                            break; 
                        case 2: 
                            // More gold (significantly more in final phase)
                            const basegold = 3 + Math.floor(store.world.wave / 8);
                            const finalPhaseBonus = isFinalPhase ? Math.floor(basegold * 0.75) : 0; // 75% more adds in final phase
                            const numgold = basegold + finalPhaseBonus;
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 150; 
                                gold.y = b.y + 60; 
                                gold.color = isFinalPhase ? '#FF0000' : '#FF0000';
                                gold.hp *= isFinalPhase ? 1.5 : 1.3; // Tougher adds in final phase
                                store.enemies.push(gold); 
                            } 
                            break; 
                        case 3: 
                            // Cross pattern (more layers in final phase)
                            const layers = isFinalPhase ? 4 : 3;
                            for (let i = 0; i < 4; i++) {
                                const angle = i * Math.PI / 2;
                                for (let j = 1; j <= layers; j++) {
                                    const bulletColor = isFinalPhase ? '#FF0000' : '#8B0000';
                                    store.eBullets.push({ 
                                        x: b.x, y: b.y, 
                                        vx: 180 * j * 0.7 * Math.cos(angle), 
                                        vy: 180 * j * 0.7 * Math.sin(angle), 
                                        r: 4, col: bulletColor, dmg: 18 * dmgScale 
                                    }); 
                                }
                            }
                            break;
                    }
                }
            }
        } else {
            // Original GEOMETRON logic (unchanged)
            if (b.hp / b.hpMax < 0.5 && b.phase === 1) { 
                b.phase = 2; 
                b.isInvincible = true; 
                playSound('horn'); 
                store.activeEffects.push(createEffect("bossPhaseChange", b.x, b.y)); 
                b.attackPhase = 0; 
                b.fireT = 2.0; 
                setTimeout(() => { b.isInvincible = false; }, 2000); 
                announce('GEOMETRON ENRAGED!'); 
            }
            
            // Movement logic
            if (b.y >= 100) { 
                b.moveT += dt; 
                const moveSpeed = (b.phase === 1) ? 0.3 : 0.7; 
                b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * moveSpeed); 
            } 
            
            // Attack logic
            b.fireT -= dt; 
            if (b.fireT <= 0) { 
                if (b.phase === 1) { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.5; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const n = 16; 
                            for (let i = 0; i < n; i++) { 
                                const a = (i * 2 * Math.PI / n) + b.t * 0.5; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numgold = 3 + Math.floor(store.world.wave / 10); 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (Math.random() - 0.5) * 100; 
                                gold.y = b.y + 50; 
                                store.enemies.push(gold); 
                            } 
                            break; 
                    } 
                } else { 
                    b.attackPhase = (b.attackPhase + 1) % 4; 
                    b.fireT = 2.0; 
                    switch(b.attackPhase) { 
                        case 0: 
                        case 2: 
                            const spread = 8; 
                            const numShots = 8; 
                            const angleToPlayer = Math.atan2(store.player.y - b.y, store.player.x - b.x); 
                            for (let i = 0; i < numShots; i++) { 
                                const angle = angleToPlayer + (i - (numShots - 1) / 2) * (spread * Math.PI / 180) * 0.1; 
                                store.eBullets.push({ x: b.x, y: b.y, vx: 350 * Math.cos(angle), vy: 350 * Math.sin(angle), r: 4, col: '#ff4500', dmg: 22 * dmgScale, life: 2.0 }); 
                            } 
                            break; 
                        case 1: 
                        case 3: 
                            const numgold = 2; 
                            for(let i = 0; i < numgold; i++) { 
                                const gold = spawnEnemy('construct_gold'); 
                                gold.x = b.x + (i === 0 ? -50 : 50); 
                                gold.y = b.y + 50; 
                                gold.hp *= 1.5; 
                                gold.v *= 1.3; 
                                gold.color = '#ff4500'; 
                                store.enemies.push(gold); 
                            } 
                            break; 
                    } 
                } 
            }
        }
    }
    function stepBossVoidRaven(dt, b, dmgScale) { b.moveT += dt; if (!b.isDiving) { b.y = 100 + Math.sin(b.moveT * 2) * 20; b.x = W/2 + Math.cos(b.moveT * 0.5) * (W/2 - 100); } b.fireT -= dt; if (b.fireT <=0) { b.attackPhase = (b.attackPhase + 1) % 5; switch(b.attackPhase) { case 0: case 2: b.fireT = 1.2; for(let i = 0; i < 7; i++) { const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1; store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: '#4169e1', dmg: 18 * dmgScale }); } break; case 1: case 3: b.fireT = 2.0; const numHatchlings = 2 + Math.floor(store.world.wave / 15); for(let i = 0; i < numHatchlings; i++) { const hatchling = spawnEnemy('avian_hatchling'); hatchling.x = b.x + (Math.random() - 0.5) * 80; hatchling.y = b.y + 40; store.enemies.push(hatchling); } break; case 4: b.fireT = 4.0; b.isDiving = true; b.diveTarget = { x: store.player.x, y: store.player.y }; const dx = b.diveTarget.x - b.x; const dy = b.diveTarget.y - b.y; const dist = Math.sqrt(dx*dx + dy*dy); b.vx = (dx / dist) * 400; b.vy = (dy / dist) * 400; setTimeout(() => { b.isDiving = false; b.vx = 0; b.vy = 30; }, 1500); break; } } if (b.isDiving) { b.x += b.vx * dt; b.y += b.vy * dt; } }
    
    function stepBossBroodlord(dt, b, dmgScale) {
        // Initialize poison puddles array if not exists
        if (!store.poisonPuddles) {
            store.poisonPuddles = [];
        }
        
        // Broodlord movement - slower, more menacing
        b.moveT += dt;
        if (b.y >= 100) {
            b.x = W/2 + (W/2 - 150) * Math.sin(b.moveT * 0.4);
            b.y = 120 + Math.sin(b.moveT * 0.8) * 15;
        }
        
        // Attack phases
        b.fireT -= dt;
        if (b.fireT <= 0) {
            b.attackPhase = (b.attackPhase + 1) % 4;
            
            switch(b.attackPhase) {
                case 0:
                case 2:
                    // Poison blob barrage
                    b.fireT = 1.8;
                    const numBlobs = 5 + Math.floor(store.world.wave / 10);
                    for (let i = 0; i < numBlobs; i++) {
                        const spread = Math.PI * 0.6;
                        const baseAngle = Math.atan2(store.player.y - b.y, store.player.x - b.x);
                        const angle = baseAngle + (Math.random() - 0.5) * spread;
                        const speed = 180 + Math.random() * 80;
                        
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            r: 8,
                            col: '#7cfc00',
                            dmg: 22 * dmgScale,
                            life: 4,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 1:
                    // Acid spit pattern
                    b.fireT = 2.2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI / 4) + b.t * 0.5;
                        store.eBullets.push({
                            x: b.x,
                            y: b.y,
                            vx: Math.cos(angle) * 160,
                            vy: Math.sin(angle) * 160,
                            r: 6,
                            col: '#adff2f',
                            dmg: 20 * dmgScale,
                            life: 3,
                            type: 'poisonBlob'
                        });
                    }
                    break;
                    
                case 3:
                    // Toxic ground slam - creates multiple puddles
                    b.fireT = 3.0;
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 60 + Math.random() * 100;
                        const puddleX = b.x + Math.cos(angle) * distance;
                        const puddleY = b.y + Math.sin(angle) * distance;
                        
                        // Create poison puddle directly
                        if (puddleX > 20 && puddleX < W - 20 && puddleY > 20 && puddleY < H - 20) {
                            store.poisonPuddles.push({
                                x: puddleX,
                                y: puddleY,
                                r: 25 + Math.random() * 15,
                                life: 15 + Math.random() * 10,
                                damage: 15 * dmgScale,
                                created: performance.now()
                            });
                        }
                    }
                    break;
            }
        }
        
        // Update poison puddles
        for (let i = store.poisonPuddles.length - 1; i >= 0; i--) {
            const puddle = store.poisonPuddles[i];
            puddle.life -= dt;
            if (puddle.life <= 0) {
                store.poisonPuddles.splice(i, 1);
            }
        }
    }
    
    function stepBoss(dt) {
        const b = store.boss;
        b.t += dt;
        if (b.y < 100) { b.y += b.vy * dt; }
        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        
        if (b.slowTimer > 0) { b.slowTimer -= dt; dt *= 0.3; }

        switch (b.behavior) {
            case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break;
            case 'malignus': stepBossCoreMalignus(dt, b, dmgScale); break;
            case 'hex':      stepBossTheHex(dt, b, dmgScale); break;
            case 'construct': stepBossGeometron(dt, b, dmgScale); break;
            case 'avian':    stepBossVoidRaven(dt, b, dmgScale); break;
            case 'broodlord': stepBossBroodlord(dt, b, dmgScale); break;
        }
    }
    function drawMissile(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2);

        ctx.fillStyle = m.isIceman ? "#a0e9ff" : "#ffddff";
        ctx.shadowColor = m.isIceman ? '#3c9aed' : '#ff8080';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(4, 5); 
        ctx.lineTo(-4, 5);
        ctx.closePath();
        ctx.fill();

        ctx.shadowBlur = 0;

        const flameSize = 8 + 4 * Math.sin(performance.now() / 50);
        ctx.fillStyle = m.isIceman ? `rgba(60, 154, 237, ${0.6 + 0.4 * Math.random()})` : `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`;

        ctx.beginPath();
        ctx.moveTo(-3, 5);
        ctx.lineTo(3, 5); 
        ctx.lineTo(0, 5 + flameSize);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }
    function drawPowerup(p) { const cfg = POWERUP_TYPES[p.type]; ctx.save(); ctx.translate(p.x, p.y); const pulse = 0.8 + 0.2 * Math.sin(performance.now() / 150); ctx.scale(pulse, pulse); ctx.beginPath(); ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2); const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3); grad.addColorStop(0, '#FFD70099'); grad.addColorStop(1, '#FFD70000'); ctx.fillStyle = grad; ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, p.r, 0, Math.PI * 2); ctx.fillStyle = '#FFD70044'; ctx.fill(); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 16px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(cfg.icon, 0, 1); ctx.restore(); }
    function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }
    
    function drawLaser(laser) {
        ctx.save();
        const trailLength = 200;
        const angle = Math.atan2(laser.vy, laser.vx);
        const startX = laser.x - Math.cos(angle) * trailLength;
        const startY = laser.y - Math.sin(angle) * trailLength;

        const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
        grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
        grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = laser.r * 1.5;
        ctx.lineCap = 'round';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 25;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(laser.x, laser.y);
        ctx.stroke();
        
        // Inner bright core
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = `rgba(200, 220, 255, 0.8)`;
        ctx.shadowBlur = 10;
        ctx.stroke();

        ctx.restore();
    }
// Helper: safely add alpha to a hex color (falls back if not hex)
    function addAlpha(color, alpha) {
        const a = Math.max(0, Math.min(1, alpha));
        if (typeof color === 'string' && color.startsWith('#')) {
            let hex = color.slice(1);
            if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
            if (hex.length >= 6) {
            const r = parseInt(hex.slice(0, 2), 16);
            const g = parseInt(hex.slice(2, 4), 16);
            const b = parseInt(hex.slice(4, 6), 16);
            return `rgba(${r},${g},${b},${a})`;
            }
        }
        // If it's not hex, return as-is (the caller can tweak globalAlpha if needed)
        return color;
        }

    // Skull Ship Drawing Functions

    /**
     * @class Boss
     * Represents the main antagonist character.
     * This class encapsulates all logic for rendering, animating, and managing the state of the boss.
     */
    class Boss {
        /**
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context for the canvas.
         * @param {number} x The initial X position of the boss.
         * @param {number} y The initial Y position of the boss.
         * @param {string} skullColor The color for the skull (supports red final phase).
         */
        constructor(ctx, x, y, skullColor = '#e54d24') {
            this.ctx = ctx;
            this.x = x;
            this.y = y;
            this.skullColor = skullColor;

            this.width = 180;
            this.height = 280;

            // Animation state
            this.isAttacking = false;
            this.attackStartTime = 0;
            this.bloodDrips = [];
        }

        /**
         * Triggers the boss's attack animation (laugh and scythe swipe).
         * This should be called from the main game logic (e.g., on a timer or player action).
         * @param {boolean} playAudio - Whether to play the laugh sound effect.
         */
        triggerAttack(playAudio = true) {
            if (!this.isAttacking) {
                this.isAttacking = true;
                this.attackStartTime = Date.now();

                // Play death engine laugh sound using game's sound system
                if (playAudio && typeof playSound !== 'undefined') {
                    playSound('shao_kahn');
                }

                // Reset the attack state after the animation duration
                setTimeout(() => {
                    this.isAttacking = false;
                }, 3000);
            }
        }

        /**
         * Updates the boss's state. This should be called every frame in the game loop.
         * It handles internal animations like the blood drips.
         */
        update() {
            this._updateBloodDrips();
        }

        /**
         * Renders the boss on the canvas. This should be called every frame in the game loop after `update`.
         */
        draw() {
            this.ctx.save();
            this.ctx.translate(this.x, this.y);
            this._drawHorns();
            this._drawHead();
            this._drawFacialFeatures();
            this._addWeathering(); // Scars
            this._drawBloodDrips();
            this.ctx.restore();
        }

        // --- Private Helper Methods ---

        _drawHorns() {
            const { ctx, width: skullWidth, height: skullHeight } = this;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            let swipeAngle = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                const duration = 1000;
                if (elapsedTime < duration) {
                    const progress = elapsedTime / duration;
                    swipeAngle = Math.sin(progress * Math.PI) * -0.3;
                }
            }

            const drawHornScythe = (isFlipped) => {
                const side = isFlipped ? -1 : 1;
                ctx.save();
                
                const handleGradient = ctx.createLinearGradient(0, -200, 0, 100);
                handleGradient.addColorStop(0, '#111111');
                handleGradient.addColorStop(0.5, '#333333');
                handleGradient.addColorStop(1, '#222222');
                ctx.fillStyle = handleGradient;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 18;

                ctx.beginPath();
                ctx.moveTo(side * skullWidth * 0.35, -skullHeight * 0.4);
                const handleEndX = side * 400;
                const handleEndY = -skullHeight * 0.20;
                ctx.bezierCurveTo(side * 220, -skullHeight * 0.9, side * 350, -skullHeight * 0.1, handleEndX, handleEndY);
                ctx.bezierCurveTo(side * 360, 0, side * 230, -skullHeight * 0.55, side * skullWidth * 0.25, -skullHeight * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#4a4a4a';
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 10, handleEndY, 14, 20, side * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.ellipse(handleEndX - side * 35, handleEndY - 5, 12, 18, side * 0.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.translate(handleEndX, handleEndY);
                const baseRotation = Math.PI / 4;
                ctx.rotate(side * baseRotation + side * swipeAngle);

                const bladeGradient = ctx.createLinearGradient(side * 50, 0, side * 150, 300);
                bladeGradient.addColorStop(0, '#ffffff');
                bladeGradient.addColorStop(0.5, '#e3dac9');
                bladeGradient.addColorStop(1, '#c1b8a8');
                ctx.fillStyle = bladeGradient;
                ctx.strokeStyle = '#8c8273';
                ctx.lineWidth = 4;

                ctx.beginPath();
                const tipX = side * 150;
                const tipY = 220;
                ctx.moveTo(0, -15);
                ctx.bezierCurveTo(side * 180, 80, side * 200, 200, tipX, tipY);
                ctx.bezierCurveTo(side * 130, 160, side * 40, 70, 0, 15);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.save();
                ctx.clip();
                ctx.strokeStyle = 'rgba(80, 70, 60, 0.2)';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    const startX = side * (Math.random() * 250);
                    const startY = -15 + Math.random() * 300;
                    const length = 20 + Math.random() * 30;
                    const angle = Math.random() * Math.PI * 2;
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(startX + Math.cos(angle) * length, startY + Math.sin(angle) * length);
                    ctx.stroke();
                }
                ctx.restore();
                
                if (this.isAttacking && Math.random() < 0.3) {
                    const dripSpawnPoint = { x: tipX / 2, y: tipY / 1.5 };
                    const rotatedPoint = {
                        x: dripSpawnPoint.x * Math.cos(side * baseRotation) - dripSpawnPoint.y * Math.sin(side * baseRotation),
                        y: dripSpawnPoint.x * Math.sin(side * baseRotation) + dripSpawnPoint.y * Math.cos(side * baseRotation)
                    };
                    this._addBloodDrip(handleEndX + rotatedPoint.x, handleEndY + rotatedPoint.y);
                }

                ctx.restore();
            };

            drawHornScythe(false);
            drawHornScythe(true);
        }

        _drawHead() {
            const { ctx, width: skullWidth, height: skullHeight, skullColor } = this;
            const gradient = ctx.createRadialGradient(0, -50, skullWidth * 0.1, 0, 0, skullWidth * 1.2);
            
            if (skullColor === '#FF0000') {
                // Red final phase colors
                gradient.addColorStop(0, '#ff6666');
                gradient.addColorStop(0.5, '#ff0000');
                gradient.addColorStop(1, '#660000');
            } else {
                // Original orange colors
                gradient.addColorStop(0, '#ff8c66');
                gradient.addColorStop(0.5, '#e54d24');
                gradient.addColorStop(1, '#661a00');
            }

            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#1a0a05';
            ctx.lineWidth = 8;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 20;

            ctx.beginPath();
            ctx.moveTo(0, -skullHeight * 0.55);
            ctx.bezierCurveTo(-skullWidth * 0.6, -skullHeight * 0.6, -skullWidth * 0.6, -skullHeight * 0.1, -skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(-skullWidth * 0.6, skullHeight * 0.3, -skullWidth * 0.2, skullHeight * 0.55, 0, skullHeight * 0.52);
            ctx.bezierCurveTo(skullWidth * 0.2, skullHeight * 0.55, skullWidth * 0.6, skullHeight * 0.3, skullWidth * 0.5, -skullHeight * 0.2);
            ctx.bezierCurveTo(skullWidth * 0.6, -skullHeight * 0.1, skullWidth * 0.6, -skullHeight * 0.6, 0, -skullHeight * 0.55);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.shadowColor = 'transparent';
        }

        _drawFacialFeatures() {
            const { ctx, height: skullHeight } = this;

            const drawMirrorEye = (offsetX, isFlipped) => {
                ctx.save();
                ctx.translate(offsetX, -10);
                if (isFlipped) ctx.scale(-1, 1);
                const eyePath = new Path2D();
                eyePath.moveTo(-30, -20); eyePath.lineTo(30, -30); eyePath.lineTo(25, 28); eyePath.lineTo(-25, 25); eyePath.closePath();
                for (let i = 0; i < 6; i++) {
                    ctx.fillStyle = (i % 2 === 0 || i === 5) ? '#1a0a05' : '#ff3300';
                    ctx.fill(eyePath);
                    ctx.scale(0.8, 0.75);
                }
                ctx.restore();
            };
            drawMirrorEye(-35, true);
            drawMirrorEye(35, false);

            let mouthOpenness = 0;
            if (this.isAttacking) {
                const elapsedTime = Date.now() - this.attackStartTime;
                mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 15;
            }

            ctx.strokeStyle = 'rgba(26, 10, 5, 0.8)';
            ctx.lineWidth = 2;

            for (let i = -6; i <= 6; i++) {
                if (i === 0) continue;
                let toothWidth = 10;
                let toothHeight = 25 - Math.abs(i) * 1.2;
                const isCanine = Math.abs(i) === 5 || Math.abs(i) === 6;
                if (isCanine) {
                    toothHeight += 18;
                    toothWidth -= 2;
                }
                const xPos = i * 9;
                let yPos = skullHeight * 0.53;
                yPos -= Math.pow(i, 2) * 1.8;
                yPos += mouthOpenness;
                ctx.save();
                ctx.translate(xPos, yPos);
                ctx.beginPath();
                ctx.moveTo(-toothWidth / 2, 0);
                ctx.lineTo(toothWidth / 2, 0);
                ctx.lineTo(0, toothHeight);
                ctx.closePath();
                ctx.fillStyle = '#e8d9a9';
                ctx.fill();
                ctx.stroke();
                const tipY = toothHeight;
                ctx.fillStyle = '#8c1803';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 3, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.ellipse(0, tipY, toothWidth / 5, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        _addWeathering() {
            const { ctx } = this;
            ctx.strokeStyle = 'rgba(26, 10, 5, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(40, -30);
            ctx.lineTo(70, 10);
            ctx.lineTo(65, 15);
            ctx.stroke();
        }

        _addBloodDrip(x, y) {
            if (this.bloodDrips.length > 100) return;
            this.bloodDrips.push({
                x: x,
                y: y,
                speed: 2 + Math.random() * 3,
                size: 2 + Math.random() * 3
            });
        }

        _updateBloodDrips() {
            for (let i = this.bloodDrips.length - 1; i >= 0; i--) {
                const drip = this.bloodDrips[i];
                drip.y += drip.speed;
                if (drip.y > this.ctx.canvas.height) {
                    this.bloodDrips.splice(i, 1);
                }
            }
        }

        _drawBloodDrips() {
            const { ctx } = this;
            ctx.fillStyle = '#8c1803';
            for (const drip of this.bloodDrips) {
                ctx.beginPath();
                ctx.arc(drip.x, drip.y, drip.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawBoss(t) {
        // Special rendering for Heat Death of the Universe
        if (t.isHeatDeath) {
            // Darken the top half of screen with haze effect
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, W, H/2);
            
            // Add dark gray haze
            ctx.fillStyle = 'rgba(32, 32, 32, 0.6)';
            ctx.fillRect(0, 0, W, H/2);
            
            // No health bar or physical form - just the void
            ctx.restore();
            return;
        }
        
        ctx.save(); ctx.translate(t.x, t.y); if (t.isEnraged) {ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50);} const hpRatio = Math.max(0, Math.min(1, ((t.hp || 0) / (t.hpMax || 1)))); ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(-60, -t.r - 20, 120, 8); const healthBarColor = t.name === 'EVIL BABYMOON' ? '#ffd700' : (t.color || '#ff4444'); ctx.fillStyle = healthBarColor; ctx.fillRect(-60, -t.r - 20, 120 * hpRatio, 8); ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.strokeRect(-60, -t.r - 20, 120, 8); if (t.behavior === "malignus") {const time = performance.now() / 1000; ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.4, 0, Math.PI * 2); ctx.fill(); const numgold = 5; for (let i = 0; i < numgold; i++) {ctx.save(); const angle = time * (0.5 + 0.1 * i) + i * (2 * Math.PI / numgold); const dist = 0.8 * t.r; ctx.rotate(angle); ctx.translate(dist, 0); ctx.rotate(2 * time); ctx.fillStyle = addAlpha(t.color, 0.67); ctx.strokeStyle = "#FFFFFF"; ctx.lineWidth = 2; const goldize = 0.3 * t.r; ctx.beginPath(); ctx.moveTo(0, -goldize); ctx.lineTo(goldize / 2, goldize); ctx.lineTo(-goldize / 2, goldize); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();}} else if (t.behavior === "hex") {ctx.translate(0, 30); const bodyW_top = t.r * 1.5; const bodyW_bottom = t.r * 2.5; const bodyH = t.r * 1.5; ctx.fillStyle = "#66aaff"; ctx.strokeStyle = "#5599e5"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_top / 2, -bodyH / 2); ctx.lineTo(bodyW_bottom / 2, bodyH / 2); ctx.lineTo(-bodyW_bottom / 2, bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#e03434"; ctx.strokeStyle = "#c02d2d"; const crownH = t.r * 0.8, crownW = bodyW_top * 0.9; ctx.beginPath(); ctx.moveTo(-crownW / 2, -bodyH / 2); ctx.lineTo(-crownW / 2 + crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(0, -bodyH / 2 - crownH / 2); ctx.lineTo(crownW / 2 - crownW / 4, -bodyH / 2 - crownH); ctx.lineTo(crownW / 2, -bodyH / 2); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = "#000"; ctx.fillRect(-t.r * 0.6, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(t.r * 0.2, -t.r * 0.3, t.r * 0.4, t.r * 0.15); ctx.fillRect(-t.r * 0.4, 0, t.r * 0.8, t.r * 0.1); ctx.strokeStyle = "#ffd700"; ctx.lineWidth = 8; ctx.beginPath(); ctx.arc(0, 0, t.r * 1.1, 0.5, Math.PI - 0.5); ctx.stroke(); ctx.fillStyle = "#ffd700"; ctx.strokeStyle = "#daa520"; ctx.lineWidth = 3; const medR = t.r * 0.5; ctx.beginPath(); ctx.moveTo(0, t.r * 1.1 + medR); for (let i = 1; i <= 8; i++) {const angle = i * (2 * Math.PI / 8); ctx.lineTo(medR * Math.sin(angle), t.r * 1.1 + medR * Math.cos(angle));} ctx.closePath(); ctx.fill(); ctx.stroke();} else if (t.behavior === "construct") {
        // Check if this is the DEATH ENGINE boss
        if (t.name === 'DEATH ENGINE') {
            // Update skull renderer position and color for red final phase
            if (t.skullRenderer) {
                t.skullRenderer.x = 0; // Relative position since we're already translated
                t.skullRenderer.y = 0; // Relative position since we're already translated  
                t.skullRenderer.skullColor = t.color || '#e54d24';
                
                // Handle attack animation
                if (t.isLaughing && !t.skullRenderer.isAttacking) {
                    // Trigger attack animation with sound effect
                    t.skullRenderer.triggerAttack(true);
                }
                
                // Update and draw using Boss class
                t.skullRenderer.update();
                t.skullRenderer.draw();
            } else {
                // Fallback to original drawing if skullRenderer is missing (shouldn't happen)
                const skullWidth = t.r * 2; 
                const skullHeight = t.r * 2.8; 
                
                // Calculate mouth openness for animation
                let mouthOpenness = 0;
                if (t.isLaughing) {
                    const elapsedTime = performance.now() - t.laughStartTime;
                    mouthOpenness = Math.abs(Math.sin(elapsedTime * 0.005)) * 7;
                }

                // Draw all parts of the skull ship (pass boss color for red final phase)
                const skullColor = t.color || '#e54d24';
                drawSkullHorns(ctx, skullWidth, skullHeight, skullColor);
                drawSkullMain(ctx, skullWidth, skullHeight, skullColor);
                drawSkullFace(ctx, skullWidth, skullHeight, mouthOpenness, skullColor);
                drawSkullWeathering(ctx, skullWidth, skullHeight, skullColor);
            }
        } else {
            // Original GEOMETRON drawing code
            const phaseColor = t.phase === 1 ? (t.color || "#ff4500") : "#ff4500"; ctx.fillStyle = addAlpha(phaseColor, 0.67); ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; if (t.phase === 2) {ctx.shadowColor = phaseColor; ctx.shadowBlur = 25;} const bodyW = t.r * 1.2, bodyH = t.r * 1.5, headH = t.r * 0.7; ctx.beginPath(); ctx.moveTo(-bodyW * 0.5, bodyH * 0.5); ctx.lineTo(-bodyW * 0.6, bodyH * 0.2); ctx.lineTo(-bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(0, -bodyH * 0.5); ctx.lineTo(bodyW * 0.4, -bodyH * 0.6); ctx.lineTo(bodyW * 0.6, bodyH * 0.2); ctx.lineTo(bodyW * 0.5, bodyH * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); const shoulderY = -bodyH * 0.3, shoulderX = bodyW * 0.4; const armW = 0.4 * t.r, armH = 0.9 * t.r; ctx.beginPath(); ctx.moveTo(-shoulderX, shoulderY); ctx.lineTo(-shoulderX - armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(-shoulderX, shoulderY + armH); ctx.lineTo(-shoulderX + armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(shoulderX, shoulderY); ctx.lineTo(shoulderX + armW * 0.5, shoulderY + armH * 0.2); ctx.lineTo(shoulderX, shoulderY + armH); ctx.lineTo(shoulderX - armW * 0.5, shoulderY + armH * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke(); const eyeR = Math.max(1, t.r * 0.2 + 2 * Math.sin(performance.now() / 200)); ctx.fillStyle = "#ffffff"; ctx.strokeStyle = phaseColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -headH * 0.1, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        }
    } else if (t.behavior === "avian") {ctx.save(); ctx.rotate(-Math.PI / 2); const wingY = -t.r * 0.4; ctx.strokeStyle = "#FFFFFF"; ctx.fillStyle = t.color; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-t.r * 0.4, wingY); ctx.quadraticCurveTo(-t.r * 0.8, wingY - t.r * 0.6, -t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(-t.r * 0.9, wingY - t.r * 0.1, -t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(t.r * 0.4, wingY); ctx.quadraticCurveTo(t.r * 0.8, wingY - t.r * 0.6, t.r * 1.2, wingY - t.r * 0.3); ctx.quadraticCurveTo(t.r * 0.9, wingY - t.r * 0.1, t.r * 0.4, wingY); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0, 0, t.r * 0.6, t.r * 0.8, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); const eyeSize = t.r * 0.15; ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.2, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = "#FF6600"; ctx.beginPath(); ctx.moveTo(0, t.r * 0.1); ctx.lineTo(-t.r * 0.15, t.r * 0.3); ctx.lineTo(t.r * 0.15, t.r * 0.3); ctx.closePath(); ctx.fill(); ctx.restore();} else if (t.behavior === "sentinel") {
        // Cyberpunk VOID SENTINEL with purple-orange sunset gradient
        const time = performance.now() / 1000;
        
        // Create radial gradient for cyberpunk sunset effect
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
        gradient.addColorStop(0, '#FF6B35'); // Orange center
        gradient.addColorStop(0.4, '#FF8E53'); // Orange-purple transition
        gradient.addColorStop(0.7, '#8B4A9C'); // Purple
        gradient.addColorStop(1, '#2D1B69'); // Deep purple edge
        
        // Main body - hexagonal cyberpunk shape
        ctx.fillStyle = gradient;
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const sides = 6;
        for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            const x = Math.cos(angle) * t.r;
            const y = Math.sin(angle) * t.r;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Inner core with pulsing effect
        const pulseSize = 0.6 + 0.2 * Math.sin(time * 3);
        const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 0.5);
        coreGradient.addColorStop(0, '#FFFFFF');
        coreGradient.addColorStop(0.3, '#FF6B35');
        coreGradient.addColorStop(1, '#8B4A9C');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(0, 0, t.r * 0.4 * pulseSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Cyberpunk energy rings
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            const ringTime = time * (2 + i * 0.5);
            const opacity = 0.3 + 0.4 * Math.sin(ringTime);
            ctx.globalAlpha = opacity;
            
            ctx.beginPath();
            ctx.arc(0, 0, t.r * (0.7 + i * 0.15), 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        
        // Rotating cyberpunk elements
        ctx.strokeStyle = '#8B4A9C';
        ctx.fillStyle = '#FF6B35';
        ctx.lineWidth = 2;
        
        for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate(i * Math.PI / 4 + time * 0.5);
            ctx.translate(t.r * 0.8, 0);
            
            // Small diamond-shaped elements
            ctx.beginPath();
            ctx.moveTo(0, -t.r * 0.08);
            ctx.lineTo(t.r * 0.06, 0);
            ctx.lineTo(0, t.r * 0.08);
            ctx.lineTo(-t.r * 0.06, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
        // Glowing eyes with cyberpunk effect
        ctx.shadowColor = '#FF6B35';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#FFFFFF';
        
        const eyeOffset = t.r * 0.25;
        ctx.beginPath();
        ctx.arc(-eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeOffset, -t.r * 0.1, t.r * 0.08, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
    } else if (t.behavior === "broodlord") {
        // Draw cyberpunk HIVE SOVEREIGN - sleek and menacing
        const time = performance.now() / 1000;
        const pulseFactor = 1 + 0.08 * Math.sin(time * 3);
        
        // Create sunset gradient for main body
        const mainGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, t.r * 1.2);
        mainGradient.addColorStop(0, '#FF6B35'); // Orange center
        mainGradient.addColorStop(0.4, '#FF8E53'); // Orange-purple blend
        mainGradient.addColorStop(0.7, '#8B4A9C'); // Purple
        mainGradient.addColorStop(1, '#2D1B69'); // Deep void purple
        
        // Main carapace body with cyberpunk glow
        ctx.fillStyle = mainGradient;
        ctx.strokeStyle = '#FF6B35';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#8B4A9C';
        ctx.shadowBlur = 20 * pulseFactor;
        
        ctx.beginPath();
        ctx.ellipse(0, 0, t.r * 1.2 * pulseFactor, t.r * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Segmented armor plating with energy lines
        ctx.strokeStyle = "#FF8E53";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        
        for (let i = -2; i <= 2; i++) {
            const segmentPulse = 0.9 + 0.1 * Math.sin(time * 4 + i * 0.5);
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.ellipse(0, i * t.r * 0.25, t.r * 1.1 * pulseFactor * segmentPulse, t.r * 0.15, 0, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        
        // Cyberpunk energy claws/appendages
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.translate(side * t.r * 0.8, (i - 1) * t.r * 0.4);
                ctx.rotate(side * (Math.PI/6 + i * Math.PI/12) + Math.sin(time * 2 + i) * 0.15);
                
                // Energy claw with gradient
                const clawGradient = ctx.createLinearGradient(0, 0, t.r * 0.8, 0);
                clawGradient.addColorStop(0, '#8B4A9C');
                clawGradient.addColorStop(0.7, '#FF6B35');
                clawGradient.addColorStop(1, '#FFFFFF');
                
                ctx.fillStyle = clawGradient;
                ctx.strokeStyle = '#FF8E53';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FF6B35';
                ctx.shadowBlur = 8;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.lineTo(t.r * 0.7, -t.r * 0.1);
                ctx.lineTo(t.r * 0.8, 0);
                ctx.lineTo(t.r * 0.7, t.r * 0.1);
                ctx.lineTo(t.r * 0.6, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.restore();
            }
        }
        ctx.shadowBlur = 0;
        
        // Cyberpunk energy eyes
        const eyeGlow = 0.6 + 0.4 * Math.sin(time * 5);
        
        for (let side = -1; side <= 1; side += 2) {
            // Outer eye glow
            ctx.shadowColor = '#FF6B35';
            ctx.shadowBlur = 20 * eyeGlow;
            ctx.fillStyle = '#FF6B35';
            
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.18 * eyeGlow, 0, Math.PI * 2);
            ctx.fill();
            
            // Main eye
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.12, 0, Math.PI * 2);
            ctx.fill();
            
            // Energy core pupil
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#8B4A9C';
            ctx.fillStyle = '#2D1B69';
            ctx.beginPath();
            ctx.arc(side * t.r * 0.4, -t.r * 0.3, t.r * 0.06, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Cyberpunk mandibles with energy effect
        ctx.shadowBlur = 0;
        const mandibleOffset = Math.sin(time * 3) * 0.12;
        
        for (let side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(side * t.r * 0.2, t.r * 0.2);
            ctx.rotate(side * (Math.PI/8 + mandibleOffset));
            
            // Mandible gradient
            const mandibleGradient = ctx.createLinearGradient(0, 0, t.r * 0.4, 0);
            mandibleGradient.addColorStop(0, '#2D1B69');
            mandibleGradient.addColorStop(0.6, '#8B4A9C');
            mandibleGradient.addColorStop(1, '#FF6B35');
            
            ctx.fillStyle = mandibleGradient;
            ctx.strokeStyle = '#FF8E53';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#8B4A9C';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(t.r * 0.3, -t.r * 0.1);
            ctx.lineTo(t.r * 0.4, 0);
            ctx.lineTo(t.r * 0.3, t.r * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        ctx.shadowBlur = 0;
        
    } else {const time = performance.now() / 1000; ctx.fillStyle = '#2c2c54'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, t.r, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#706fd3'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#f0932b'; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.3, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 6; i++) {ctx.save(); ctx.rotate(i * Math.PI / 3 + time * 0.3); ctx.translate(t.r * 0.6, 0); ctx.fillStyle = '#ff6348'; ctx.strokeStyle = '#2f3542'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, t.r * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.restore();} const eyeSize = t.r * 0.12; ctx.fillStyle = '#ff3838'; ctx.beginPath(); ctx.arc(-t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(t.r * 0.2, -t.r * 0.15, eyeSize, 0, Math.PI * 2); ctx.fill(); for (let i = 0; i < 4; i++) {ctx.save(); ctx.rotate(i * Math.PI / 2 + time * -0.5); ctx.translate(t.r * 0.9, 0); ctx.fillStyle = '#3c6382'; ctx.strokeStyle = '#40407a'; ctx.lineWidth = 2; ctx.fillRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.strokeRect(-t.r * 0.08, -t.r * 0.06, t.r * 0.16, t.r * 0.12); ctx.restore();}} ctx.restore();}

    function drawShip(t, e, player) {
        let mainColor = '#b266ff', accentColor1 = '#7a49cc', accentColor2 = '#4d2a80',
            wingStrokeColor = '#c49cff', engineColor = '#cc99ff';

        switch (player.subclass) {
            case 'juggernaut':
                mainColor = '#ff3333'; accentColor1 = '#cc0000'; accentColor2 = '#990000';
                wingStrokeColor = '#ff6666'; engineColor = '#ffaaaa';
                break;
            case 'marauder':
                mainColor = '#33cc33'; accentColor1 = '#009900'; accentColor2 = '#006600';
                wingStrokeColor = '#66ff66'; engineColor = '#aaffaa';
                break;
            case 'demolitionist':
                mainColor = '#ffcc00'; accentColor1 = '#ffaa00'; accentColor2 = '#cc8800';
                wingStrokeColor = '#ffeeaa'; engineColor = '#ffffcc';
                break;
            case 'railgunner':
                mainColor = '#9933ff'; accentColor1 = '#6600cc'; accentColor2 = '#440088';
                wingStrokeColor = '#cc99ff'; engineColor = '#e6ccff';
                break;
            case 'phasestriker':
                mainColor = '#ff69b4'; accentColor1 = '#ff1493'; accentColor2 = '#c71585';
                wingStrokeColor = '#ffb6c1'; engineColor = '#ffc0cb';
                break;
            case 'stormcaller':
                mainColor = '#00bfff'; accentColor1 = '#1e90ff'; accentColor2 = '#0000cd';
                wingStrokeColor = '#87cefa'; engineColor = '#add8e6';
                break;
        }

        ctx.save();
        ctx.translate(t,e);
        if(player.isInvincible || player.hasShieldBubble){
            ctx.beginPath();ctx.arc(0,0,24,0,2*Math.PI);
            const g=ctx.createRadialGradient(0,0,18,0,0,24);
            g.addColorStop(0,"#9a66ff11");g.addColorStop(1,"#9a66ff");
            ctx.fillStyle=g;ctx.fill()
        }
        ctx.beginPath();
        ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);
        ctx.closePath();
        const o=ctx.createLinearGradient(0,-20,0,14);
        o.addColorStop(0, mainColor);o.addColorStop(.5, accentColor1);o.addColorStop(1, accentColor2);
        ctx.fillStyle=o;ctx.fill();
        ctx.lineWidth=2;ctx.strokeStyle=wingStrokeColor;ctx.stroke();
        ctx.strokeStyle=mainColor;ctx.lineWidth=2;
        ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();
        const r=performance.now()/1e3;
        ctx.globalAlpha=.8+.2*Math.sin(10*r);
        ctx.fillStyle=engineColor;
        ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,2*Math.PI);ctx.ellipse(5,16,3,6,0,0,2*Math.PI);ctx.fill();
        ctx.globalAlpha=1;
        ctx.fillStyle="#ffffff";ctx.beginPath();ctx.arc(0,-8,3,0,2*Math.PI);ctx.fill();
        
        // Draw beef shield bubble if pilot is beef and shield is active
        if (player.pilotGenome === 'beef' && player.beefShield > 0) {
            const time = performance.now() / 1000;
            const shieldPercent = player.beefShield / player.beefShieldMax;
            const pulseIntensity = 0.7 + 0.3 * Math.sin(time * 2.5);
            
            // Base radius scales with shield level (8px minimum, up to 30px at full shield)
            const baseRadius = 8 + (22 * shieldPercent); // 8px at 0%, 30px at 100%
            // Add wobbling effect on top of the scaled base
            const wobbleAmount = 4 * shieldPercent; // Wobble gets stronger as shield grows
            const shieldRadius = baseRadius + wobbleAmount * Math.sin(time * 3);
            
            // Create void power shield gradient (dark purple/black energy)
            const shieldGradient = ctx.createRadialGradient(0, 0, shieldRadius * 0.2, 0, 0, shieldRadius);
            shieldGradient.addColorStop(0, `rgba(75, 0, 130, ${0.8 * shieldPercent})`); // Dark purple core (increased opacity)
            shieldGradient.addColorStop(0.4, `rgba(25, 25, 112, ${0.6 * shieldPercent * pulseIntensity})`); // Midnight blue (increased)
            shieldGradient.addColorStop(0.7, `rgba(72, 61, 139, ${0.7 * shieldPercent})`); // Dark slate blue (increased)
            shieldGradient.addColorStop(1, `rgba(138, 43, 226, ${0.5 * shieldPercent})`); // Purple edge (was black, now purple)
            
            ctx.beginPath();
            ctx.arc(0, 0, shieldRadius, 0, 2 * Math.PI);
            ctx.fillStyle = shieldGradient;
            ctx.fill();
            
            // Add void energy sparkles
            ctx.strokeStyle = `rgba(138, 43, 226, ${0.9 * shieldPercent * pulseIntensity})`; // Blue violet sparkles (increased opacity)
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
            
            // Add inner void energy core
            if (shieldPercent > 0.2) {
                const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shieldRadius * 0.3);
                coreGradient.addColorStop(0, `rgba(147, 0, 211, ${0.6 * shieldPercent})`); // Dark violet (increased)
                coreGradient.addColorStop(1, `rgba(75, 0, 130, ${0.3 * shieldPercent})`); // (increased)
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(0, 0, shieldRadius * 0.3 * Math.abs(Math.sin(time * 4)), 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // Draw floating beef shield meter above ship
        if (player.pilotGenome === 'beef' && player.beefShieldMax > 0) {
            const shieldPercent = player.beefShield / player.beefShieldMax;
            const meterY = -35; // Position above ship
            const meterWidth = 40;
            const meterHeight = 4;
            
            // Background bar
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-meterWidth/2, meterY, meterWidth, meterHeight);
            
            // Shield fill bar
            if (shieldPercent > 0) {
                const fillGradient = ctx.createLinearGradient(-meterWidth/2, meterY, meterWidth/2, meterY);
                fillGradient.addColorStop(0, 'rgba(75, 0, 130, 0.9)'); // Dark purple
                fillGradient.addColorStop(0.5, 'rgba(138, 43, 226, 0.9)'); // Blue violet
                fillGradient.addColorStop(1, 'rgba(147, 0, 211, 0.9)'); // Dark violet
                
                ctx.fillStyle = fillGradient;
                ctx.fillRect(-meterWidth/2, meterY, meterWidth * shieldPercent, meterHeight);
            }
            
            // Border
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
            ctx.lineWidth = 1;
            ctx.strokeRect(-meterWidth/2, meterY, meterWidth, meterHeight);
            
            // Shield text
            ctx.fillStyle = 'rgba(138, 43, 226, 0.9)';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            const shieldText = `${Math.round(player.beefShield)}/${Math.round(player.beefShieldMax)}`;
            ctx.fillText(shieldText, 0, meterY - 2);
        }
        
        // ‚ó¢‚ó£ ENTROPY REDUCTION FIELD VISUALIZATION - MULTI-PILOT ‚ó£‚ó¢ [DISABLED FOR STABILITY]
        /*
        if (ENTROPY_ENGINE.active) {
            const time = performance.now() / 1000;
            let entropyIntensity = 0;
            let fieldColor = '#9966ff';
            let meterText = '';
            
            if (player.pilotGenome === 'voidmancer') {
                // Void pilot - quantum field (purple)
                entropyIntensity = Math.min(1, Math.abs(ENTROPY_ENGINE.quantumEntropy) * 1e16);
                fieldColor = '#9966ff';
                meterText = `QUANTUM -ŒîS ${ENTROPY_ENGINE.stellarFusionRate.toFixed(1)}x`;
                
                // Maxwell's Demon particles (void pilot only)
                const demonCount = ENTROPY_ENGINE.maxwellDemons;
                for (let i = 0; i < demonCount; i++) {
                    const angle = (i / demonCount) * Math.PI * 2 + time * 0.5;
                    const orbitRadius = 25 + 10 * Math.sin(time * 2 + i);
                    const demonX = Math.cos(angle) * orbitRadius;
                    const demonY = Math.sin(angle) * orbitRadius;
                    
                    ctx.fillStyle = `rgba(153, 102, 255, ${0.8 * entropyIntensity})`;
                    ctx.beginPath();
                    ctx.arc(demonX, demonY, 2, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Energy trail
                    ctx.strokeStyle = `rgba(153, 102, 255, ${0.3 * entropyIntensity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    const trailX = Math.cos(angle - 0.5) * (orbitRadius - 5);
                    const trailY = Math.sin(angle - 0.5) * (orbitRadius - 5);
                    ctx.moveTo(trailX, trailY);
                    ctx.lineTo(demonX, demonY);
                    ctx.stroke();
                }
                
            } else if (player.pilotGenome === 'beef') {
                // Beef pilot - kinetic field (orange/red energy waves)
                entropyIntensity = Math.min(1, Math.abs(ENTROPY_ENGINE.kineticEntropy) * 1e14);
                fieldColor = '#ff6600';
                meterText = `KINETIC -ŒîS ${ENTROPY_ENGINE.stellarFusionRate.toFixed(1)}x`;
                
                // Kinetic energy waves
                for (let i = 0; i < 3; i++) {
                    const waveRadius = 20 + i * 8 + Math.sin(time * 3 + i) * 3;
                    ctx.strokeStyle = `rgba(255, 102, 0, ${0.4 * entropyIntensity * (1 - i * 0.2)})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, waveRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
            } else if (player.pilotGenome === 'rocketman') {
                // Rocketman - explosive redistribution (yellow/gold sparks)
                entropyIntensity = Math.min(1, Math.abs(ENTROPY_ENGINE.explosiveEntropy) * 1e15);
                fieldColor = '#ffcc00';
                meterText = `EXPLOSIVE -ŒîS ${ENTROPY_ENGINE.stellarFusionRate.toFixed(1)}x`;
                
                // Explosive redistribution sparks
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + time * 2;
                    const sparkRadius = 15 + Math.sin(time * 4 + i) * 8;
                    const sparkX = Math.cos(angle) * sparkRadius;
                    const sparkY = Math.sin(angle) * sparkRadius;
                    
                    ctx.fillStyle = `rgba(255, 204, 0, ${0.7 * entropyIntensity})`;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 1.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Explosion pattern lines
                    ctx.strokeStyle = `rgba(255, 204, 0, ${0.3 * entropyIntensity})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(sparkX, sparkY);
                    ctx.stroke();
                }
            }
            
            // Universal entropy reduction field
            if (entropyIntensity > 0.1) {
                const fieldGradient = ctx.createRadialGradient(0, 0, 10, 0, 0, 40);
                fieldGradient.addColorStop(0, `rgba(${fieldColor === '#9966ff' ? '153, 102, 255' : fieldColor === '#ff6600' ? '255, 102, 0' : '255, 204, 0'}, 0)`);
                fieldGradient.addColorStop(0.7, `rgba(${fieldColor === '#9966ff' ? '153, 102, 255' : fieldColor === '#ff6600' ? '255, 102, 0' : '255, 204, 0'}, ${0.1 * entropyIntensity})`);
                fieldGradient.addColorStop(1, `rgba(${fieldColor === '#9966ff' ? '102, 51, 204' : fieldColor === '#ff6600' ? '204, 51, 0' : '204, 153, 0'}, ${0.2 * entropyIntensity})`);
                
                ctx.fillStyle = fieldGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 40 + 5 * Math.sin(time * 3), 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Entropy meter (universal for all pilots)
            const entropyMeterY = -45;
            const entropyMeterWidth = 50;
            const entropyMeterHeight = 3;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(-entropyMeterWidth/2, entropyMeterY, entropyMeterWidth, entropyMeterHeight);
            
            // Entropy fill
            const entropyPercent = Math.min(1, entropyIntensity);
            if (entropyPercent > 0) {
                ctx.fillStyle = fieldColor;
                ctx.fillRect(-entropyMeterWidth/2, entropyMeterY, entropyMeterWidth * entropyPercent, entropyMeterHeight);
            }
            
            // Border and text
            ctx.strokeStyle = fieldColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(-entropyMeterWidth/2, entropyMeterY, entropyMeterWidth, entropyMeterHeight);
            
            ctx.fillStyle = fieldColor;
            ctx.font = '7px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(meterText, 0, entropyMeterY - 2);
        }
        */

        if (player.hasRearGuard && player.rearGuardReady) {
            ctx.fillStyle = `rgba(100, 255, 255, ${0.4 + 0.3 * Math.sin(performance.now() / 200)})`;
            ctx.beginPath();
            ctx.arc(0, 15, 8, 0, 2 * Math.PI);
            ctx.fill();
        }
        ctx.restore();
    }
    function drawMine(m) {
        ctx.save();
        ctx.translate(m.x, m.y);
        const time = performance.now();
        const pulse = 0.8 + 0.2 * Math.sin(time / 150);
        const fuseRatio = m.fuse / 5;
        const color = `rgb(255, ${100 * fuseRatio}, ${80 * fuseRatio})`;

        ctx.beginPath();
        ctx.arc(0, 0, m.r * 1.5 * pulse, 0, 2 * Math.PI);
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, m.r * 1.5 * pulse);
        grad.addColorStop(0, color + '99');
        grad.addColorStop(1, color + '00');
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.arc(0, 0, m.r, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, m.r * 0.4 * pulse, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawEnemy(e) { const{x:t,y:o,r:a,type:r,color:n,hp:l,hpMax:s,t:c}=e;ctx.save();ctx.translate(t,o);l<s&&l>0&&(ctx.fillStyle='rgba(0,0,0,0.5)',ctx.fillRect(-a,-a-8,2*a,3),ctx.fillStyle="#b266ff",ctx.fillRect(-a,-a-8,2*a*(l/s),3));ctx.lineWidth=2;ctx.beginPath();switch(r){case"avian_hatchling":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a*1.2);ctx.lineTo(a,-a*0.5);ctx.lineTo(a,a*0.5);ctx.lineTo(0,a*1.2);ctx.lineTo(-a,a*0.5);ctx.lineTo(-a,-a*0.5);ctx.closePath();ctx.fill();ctx.stroke();break;case"construct_gold":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a);ctx.lineTo(a,0);ctx.lineTo(0,a);ctx.lineTo(-a,0);ctx.closePath();ctx.fill();ctx.stroke();break;case"trap_king_add":case"drone":const e=ctx.createLinearGradient(-a,-a,a,a);e.addColorStop(0,"#E0E0E0");e.addColorStop(1,"#A0A0A0");ctx.fillStyle=e;ctx.strokeStyle="#808080";ctx.beginPath();ctx.moveTo(-1.2*a,0);ctx.quadraticCurveTo(0,-a,1.2*a,0);ctx.quadraticCurveTo(0,.6*a,-1.2*a,0);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#aaddff";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-.2*a,.6*a,Math.PI,0);ctx.fill();ctx.stroke();ctx.fillStyle=r==="trap_king_add"?"#ffc83d":"#32CD32";ctx.beginPath();ctx.ellipse(0,-.2*a,.3*a,.4*a,0,0,2*Math.PI);ctx.fill();ctx.fillStyle="#000000";ctx.beginPath();ctx.ellipse(-.1*a,-.25*a,.08*a,.15*a,-.5,0,2*Math.PI);ctx.ellipse(.1*a,-.25*a,.08*a,.15*a,.5,0,2*Math.PI);ctx.fill();break;
        case "hunter":
            // Holographic Cyber-Serpent: Robotic/Organic Hybrid
            const hunterTime = performance.now() / 1000;
            const holoFlicker = 0.7 + 0.3 * Math.sin(hunterTime * 8 + c * 3);
            const holoGlow = 0.5 + 0.5 * Math.sin(hunterTime * 12 + c * 2);
            const segments = 14;
            const length = a * 2.0;
            const amplitude = a * 0.6;
            
            // Scary cybernetic colors
            const baseRed = '#8B0000'; // Dark blood red
            const cyberRed = '#FF0040'; // Bright cyber red
            const organicRed = '#DC143C'; // Original red but enhanced
            const holoBlue = '#00FFFF'; // Holographic cyan accent
            
            // Outer holographic aura
            ctx.save();
            ctx.globalAlpha = holoGlow * 0.4;
            ctx.shadowColor = holoBlue;
            ctx.shadowBlur = 25;
            ctx.strokeStyle = holoBlue;
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            ctx.lineDashOffset = -hunterTime * 10;
            
            // Draw holographic outline
            ctx.beginPath();
            for (let i = 0; i <= segments; i++) {
                const progress = i / segments;
                const segmentWidth = a * Math.sin(progress * Math.PI) * 0.6;
                const x = Math.sin(progress * 3 * Math.PI + c * 6) * amplitude;
                const y = (progress - 0.5) * length;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();
            
            // Main serpent body with robotic segments
            ctx.globalAlpha = holoFlicker;
            ctx.setLineDash([]);
            
            const bodyPoints1 = [];
            const bodyPoints2 = [];
            
            for (let i = 0; i <= segments; i++) {
                const progress = i / segments;
                // Robotic segmentation with organic curves
                const roboticPulse = 1 + 0.1 * Math.sin(progress * 8 * Math.PI + hunterTime * 4);
                const segmentWidth = a * Math.sin(progress * Math.PI) * 0.5 * roboticPulse;
                const x = Math.sin(progress * 3 * Math.PI + c * 6) * amplitude;
                const y = (progress - 0.5) * length;
                
                bodyPoints1.push({ x: x + segmentWidth, y: y });
                bodyPoints2.push({ x: x - segmentWidth, y: y });
            }
            
            // Draw main body with gradient
            const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 2);
            bodyGradient.addColorStop(0, cyberRed + 'CC');
            bodyGradient.addColorStop(0.5, baseRed + 'AA');
            bodyGradient.addColorStop(1, organicRed + '88');
            
            ctx.fillStyle = bodyGradient;
            ctx.strokeStyle = cyberRed;
            ctx.lineWidth = 2;
            ctx.shadowColor = cyberRed;
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.moveTo(bodyPoints1[0].x, bodyPoints1[0].y);
            for(let i = 1; i < bodyPoints1.length; i++) {
                ctx.lineTo(bodyPoints1[i].x, bodyPoints1[i].y);
            }
            for(let i = bodyPoints2.length - 1; i >= 0; i--) {
                ctx.lineTo(bodyPoints2[i].x, bodyPoints2[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Robotic spine segments
            ctx.strokeStyle = holoBlue;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 8;
            for (let i = 1; i < segments; i++) {
                const progress = i / segments;
                const x = Math.sin(progress * 3 * Math.PI + c * 6) * amplitude;
                const y = (progress - 0.5) * length;
                const segmentGlow = 0.8 + 0.2 * Math.sin(hunterTime * 6 + i);
                
                ctx.globalAlpha = segmentGlow * holoFlicker;
                ctx.beginPath();
                ctx.moveTo(x - a * 0.3, y);
                ctx.lineTo(x + a * 0.3, y);
                ctx.stroke();
                
                // Cyber nodes
                ctx.fillStyle = holoBlue;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Cybernetic head with organic horror
            const headX = Math.sin(c * 6) * amplitude;
            const headY = -0.5 * length;
            const headPulse = 1 + 0.15 * Math.sin(hunterTime * 10);
            
            ctx.globalAlpha = holoFlicker;
            
            // Head shell - metallic organic hybrid
            const headGradient = ctx.createRadialGradient(headX, headY, 0, headX, headY, a * 0.8);
            headGradient.addColorStop(0, '#FF4444');
            headGradient.addColorStop(0.4, baseRed);
            headGradient.addColorStop(1, '#330000');
            
            ctx.fillStyle = headGradient;
            ctx.strokeStyle = cyberRed;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 20;
            
            ctx.beginPath();
            ctx.ellipse(headX, headY, a * 0.6 * headPulse, a * 0.4 * headPulse, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Cybernetic eye scanners (scarier)
            const eyeGlow = 0.8 + 0.2 * Math.sin(hunterTime * 15);
            ctx.fillStyle = '#FF0000';
            ctx.shadowColor = '#FF0000';
            ctx.shadowBlur = 12;
            ctx.globalAlpha = eyeGlow;
            
            // Left scanner eye
            ctx.beginPath();
            ctx.arc(headX - a*0.2, headY - a*0.1, a * 0.12 * headPulse, 0, 2*Math.PI);
            ctx.fill();
            
            // Right scanner eye  
            ctx.beginPath();
            ctx.arc(headX + a*0.2, headY - a*0.1, a * 0.12 * headPulse, 0, 2*Math.PI);
            ctx.fill();
            
            // Laser scanner lines
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 1;
            ctx.globalAlpha = eyeGlow * 0.6;
            ctx.beginPath();
            ctx.moveTo(headX - a*0.2, headY - a*0.1);
            ctx.lineTo(headX - a*0.8, headY + a*0.5);
            ctx.moveTo(headX + a*0.2, headY - a*0.1);
            ctx.lineTo(headX + a*0.8, headY + a*0.5);
            ctx.stroke();
            
            // Mechanical mandibles
            ctx.strokeStyle = '#888888';
            ctx.lineWidth = 2;
            ctx.globalAlpha = holoFlicker * 0.9;
            const jawAngle = Math.sin(hunterTime * 6) * 0.3;
            
            ctx.beginPath();
            ctx.moveTo(headX - a*0.1, headY + a*0.2);
            ctx.lineTo(headX - a*0.4, headY + a*0.5 + jawAngle);
            ctx.moveTo(headX + a*0.1, headY + a*0.2);
            ctx.lineTo(headX + a*0.4, headY + a*0.5 - jawAngle);
            ctx.stroke();
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            break;
        case "phantom":
            ctx.globalAlpha=.6+.4*Math.sin(5*c);ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-.8*a);ctx.quadraticCurveTo(a,-.5*a,.8*a,.8*a);ctx.quadraticCurveTo(0,.5*a,-.8*a,.8*a);ctx.quadraticCurveTo(-a,-.5*a,0,-.8*a);ctx.closePath();ctx.fill();ctx.stroke();for(let e=-1;e<=1;e++)ctx.beginPath(),ctx.moveTo(e*.4*a,.6*a),ctx.quadraticCurveTo(e*.5*a,a,e*.3*a+2*Math.sin(4*c+e),1.2*a),ctx.stroke();break;
        case "mech": 
            // Enhanced mechanical tank enemy with Aquaman aqua blue theme
            const time = performance.now() / 1000;
            const pulseFactor = 1 + 0.05 * Math.sin(time * 4);
            
            // Aquaman color scheme: aqua blues and ocean greens
            const mainColor = '#0e4b5c'; // Deep aqua blue
            const accentColor = '#20b2aa'; // Light sea green
            const metalColor = '#2e8b8b'; // Dark cyan/teal
            const glowColor = '#00ffff'; // Bright cyan glow
            const highlightColor = '#40e0d0'; // Turquoise highlights
            
            ctx.lineWidth = 2;
            
            // Main chassis with aqua gradient shading
            const chassisGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, a * 1.2);
            chassisGradient.addColorStop(0, highlightColor);
            chassisGradient.addColorStop(0.6, mainColor);
            chassisGradient.addColorStop(1, '#051e28'); // Deep ocean blue
            
            ctx.fillStyle = chassisGradient;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.moveTo(-a * 1.2, -a * 1.0);
            ctx.lineTo(a * 1.2, -a * 1.0); 
            ctx.lineTo(a * 0.7, a * 0.6);  
            ctx.lineTo(-a * 0.7, a * 0.6); 
            ctx.closePath(); 
            ctx.fill(); 
            ctx.stroke();
            
            // Armor plating with rivets
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 1;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(i * a * 0.2, -a * 0.8);
                ctx.lineTo(i * a * 0.15, a * 0.4);
                ctx.stroke();
            }
            
            // Rivets with aqua metallic finish
            ctx.fillStyle = '#5f9ea0'; // Cadet blue rivets
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    ctx.beginPath();
                    ctx.arc(i * a * 0.3, j * a * 0.3, a * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Weapon turrets with menacing design
            ctx.lineWidth = 3;
            // Left turret
            ctx.fillStyle = mainColor;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.rect(-a * 1.6, -a * 0.9, a * 0.7, a * 1.8);
            ctx.fill(); ctx.stroke();
            
            // Left cannon barrel
            ctx.fillStyle = metalColor;
            ctx.beginPath();
            ctx.rect(-a * 1.3 - a * 0.5, -a * 0.1, a * 0.8, a * 0.2);
            ctx.fill(); ctx.stroke();
            
            // Right turret
            ctx.fillStyle = mainColor;
            ctx.strokeStyle = accentColor;
            ctx.beginPath();
            ctx.rect(a * 0.9, -a * 0.9, a * 0.7, a * 1.8);
            ctx.fill(); ctx.stroke();
            
            // Right cannon barrel
            ctx.fillStyle = metalColor;
            ctx.beginPath();
            ctx.rect(a * 1.3, -a * 0.1, a * 0.8, a * 0.2);
            ctx.fill(); ctx.stroke();
            
            // Aqua blue eyes/sensors with oceanic glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 8 * pulseFactor;
            ctx.fillStyle = glowColor;
            ctx.beginPath();
            ctx.arc(-a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(a * 0.3, -a * 0.4, a * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Tank treads with aqua metallic detail
            ctx.fillStyle = '#1c4e4e'; // Dark teal treads
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 2;
            
            // Left tread
            ctx.beginPath();
            ctx.arc(-a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            
            // Tread segments
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time * 2;
                const x = -a * 1.3 + Math.cos(angle) * a * 0.4;
                const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                ctx.fillStyle = '#4682b4'; // Steel blue segments
                ctx.beginPath();
                ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                ctx.fill();
            }
            
            // Right tread
            ctx.fillStyle = '#1c4e4e'; // Dark teal treads
            ctx.beginPath();
            ctx.arc(a * 1.3, a * 1.2, a * 0.6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            
            // Right tread segments
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + time * 2;
                const x = a * 1.3 + Math.cos(angle) * a * 0.4;
                const y = a * 1.2 + Math.sin(angle) * a * 0.4;
                ctx.fillStyle = '#4682b4'; // Steel blue segments
                ctx.beginPath();
                ctx.rect(x - a * 0.1, y - a * 0.05, a * 0.2, a * 0.1);
                ctx.fill();
            }
            
            // Command center/cockpit with aqua gradient
            const cockpitGradient = ctx.createLinearGradient(0, -a * 1.4, 0, -a * 1.0);
            cockpitGradient.addColorStop(0, accentColor);
            cockpitGradient.addColorStop(0.5, mainColor);
            cockpitGradient.addColorStop(1, '#0a2533'); // Deep ocean blue
            
            ctx.fillStyle = cockpitGradient;
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(-a * 0.4, -a * 1.4, a * 0.8, a * 0.5);
            ctx.fill(); ctx.stroke();
            
            // Antenna/communication array
            ctx.strokeStyle = metalColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -a * 1.4);
            ctx.lineTo(-a * 0.2, -a * 1.8);
            ctx.moveTo(0, -a * 1.4);
            ctx.lineTo(a * 0.2, -a * 1.8);
            ctx.stroke();
            
            // Aqua warning lights
            ctx.fillStyle = time % 1 < 0.5 ? glowColor : '#004d4d';
            ctx.beginPath();
            ctx.arc(-a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(a * 0.25, -a * 1.15, a * 0.06, 0, Math.PI * 2);
            ctx.fill();
            
            // Aqua energy exhaust vents
            ctx.fillStyle = '#00bfff'; // Deep sky blue exhaust
            ctx.shadowColor = '#00bfff';
            ctx.shadowBlur = 4;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.rect(-a * 0.1 + i * a * 0.1, a * 0.4, a * 0.05, a * 0.2);
                ctx.fill();
            }
            ctx.shadowBlur = 0;
            break;
        case "angler": {
            const scale = a / 20;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle = n + "99"; ctx.strokeStyle = n; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-20,0);
            ctx.quadraticCurveTo(0,-18,24,0);
            ctx.quadraticCurveTo(0,16,-20,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-6,5);
            ctx.quadraticCurveTo(2,10,10,4);
            ctx.stroke();
            ctx.beginPath(); ctx.moveTo(8,-6);
            ctx.quadraticCurveTo(20,-24,32,-28); ctx.stroke();
            ctx.shadowColor="#00FFD5"; ctx.shadowBlur=12;
            ctx.beginPath(); ctx.arc(32,-28,4,0,Math.PI*2); ctx.fillStyle="#00FFD5"; ctx.fill();
            ctx.restore();
            break;
        }
        case "manta": {
            const scale = a / 36;
            ctx.save(); ctx.scale(scale, scale);
            ctx.fillStyle= n + "cc"; ctx.strokeStyle=n; ctx.lineWidth=2;

            ctx.beginPath();
            ctx.moveTo(-36,0);
            ctx.quadraticCurveTo(-8,-18,0,-8);
            ctx.quadraticCurveTo(8,-18,36,0);
            ctx.quadraticCurveTo(8,14,0,8);
            ctx.quadraticCurveTo(-8,14,-36,0);
            ctx.closePath(); ctx.fill(); ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0,8);
            ctx.quadraticCurveTo(4,22,0,30);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0,0,6,0,Math.PI*2); ctx.stroke();
            ctx.restore();
            break;
        }
    }
    if (e.stunTimer && e.stunTimer > 0) {
        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + 0.3 * Math.sin(performance.now() / 100)})`;
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText('STUN', 0, -a - 12);
    }
    ctx.restore()
    }
    function createEffect(type,x,y, radius){
        let effect={isActive:!0,life:1,maxLife:1,x,y};
        switch(type){
            case "heartbeatPulse":
                effect.maxLife = 0.6;
                effect.life = effect.maxLife;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    const alpha = Math.sin((this.life / this.maxLife) * Math.PI) * 0.4;
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "beefCharge":
                effect.maxLife = 0.4;
                effect.origin = x;
                effect.target = y;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const progress = 1 - this.life;
                    const currentX = this.origin.x + (this.target.x - this.origin.x) * progress;
                    const currentY = this.origin.y + (this.target.y - this.origin.y) * progress;
        
                    ctx.save();
                    if(progress > 0.5) {
                        const shockwaveProgress = (progress - 0.5) / 0.5;
                        ctx.strokeStyle = `rgba(255, 100, 100, ${1 - shockwaveProgress})`;
                        ctx.lineWidth = 5 * (1 - shockwaveProgress);
                        ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, 80 * shockwaveProgress, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.strokeStyle = `rgba(255, 150, 150, ${this.life})`;
                    ctx.lineWidth = 15 * this.life;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.origin.x, this.origin.y);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "rearGuardBlock":
                effect.maxLife = 0.5;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(100, 255, 255, ${this.life})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 5, 20 * (1.2 - this.life), Math.PI * 0.2, Math.PI * 0.8);
                    ctx.stroke();
                    ctx.restore();
                };
                break;
            case "gravityWell":
                effect.maxLife = 7;
                effect.life = 7;
                effect.radius = 0;
                effect.maxRadius = 150;
                effect.damagePulseT = 1;
                effect.totalDamageDealtToBoss = 0;
                effect.stars = [];
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * effect.maxRadius;
                    effect.stars.push({
                        x: Math.cos(angle) * dist,
                        y: Math.sin(angle) * dist,
                        r: Math.random() * 1.5,
                        initialDist: dist
                    });
                }
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) {
                        this.isActive = false;
                        screenFlash(1, 400, 'rgba(255, 255, 255, 0.5)');
                        return;
                    }
                    if (this.radius < this.maxRadius) {
                        this.radius += 200 * dt;
                    }

                    this.damagePulseT -= dt;
                    const damageThisFrame = this.damagePulseT <= 0;
                    if (damageThisFrame) {
                        this.damagePulseT = 1;
                    }
                    
                    const pullStrength = 300;
                    const damageRadiusSq = (this.maxRadius * 0.7)**2;

                    store.enemies.forEach(e => {
                        if (e.dead) {
                            return; 
                        }
                        const dx = this.x - e.x;
                        const dy = this.y - e.y;
                        const distSq = dx * dx + dy * dy;

                        if (distSq < this.radius**2) {
                            const dist = Math.sqrt(distSq);
                            if (dist > 10) {
                                const resistance = (e.type === 'mech' || e.type === 'hunter') ? 0.7 : 1.0;
                                e.x += (dx / dist) * pullStrength * resistance * dt;
                                e.y += (dy / dist) * pullStrength * resistance * dt;
                            }
                            
                            if (damageThisFrame && distSq < damageRadiusSq) {
                                const damage = e.hpMax * (0.25 * store.player.dmgMult);
                                e.hp -= damage;
                                store.world.totalDamage += damage;
                                
                                // Apply vampirism healing for blink damage
                                if (store.player.vampirism > 0) {
                                    let healAmount = damage * store.player.vampirism;
                                    healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                    healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                    store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                }
                            }
                        }
                    });
                     if (store.boss) {
                         const b = store.boss;
                          const dx = this.x - b.x;
                          const dy = this.y - b.y;
                          const distSq = dx*dx + dy*dy;
                          if(distSq < this.radius**2) {
                               const dist = Math.sqrt(distSq);
                               if (dist > 50) {
                                   b.x += (dx/dist) * pullStrength * 0.5 * dt;
                                   b.y += (dy/dist) * pullStrength * 0.5 * dt;
                               }
                               if (damageThisFrame && distSq < damageRadiusSq) {
                                    const damageToDeal = b.hpMax * (0.10 * store.player.dmgMult);
                                    const cap = b.hpMax * 0.5;
                                    let actualDamage = damageToDeal;
                                    if (this.totalDamageDealtToBoss + actualDamage > cap) {
                                        actualDamage = cap - this.totalDamageDealtToBoss;
                                    }
                                    if (actualDamage > 0) {
                                        b.hp -= actualDamage;
                                        this.totalDamageDealtToBoss += actualDamage;
                                        store.world.totalDamage += actualDamage;
                                        
                                        // Apply vampirism healing for blink damage on boss
                                        if (store.player.vampirism > 0) {
                                            let healAmount = actualDamage * store.player.vampirism;
                                            healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                                            healAmount = Math.min(healAmount, 5); // Cap at 5 HP
                                            store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                                        }
                                    }
                               }
                           }
                      }
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    const time = performance.now();
                    const lifeRatio = this.life / this.maxLife;

                    ctx.fillStyle = 'white';
                    this.stars.forEach(star => {
                        const pullFactor = 1 - lifeRatio;
                        const currentDist = star.initialDist * (1 - pullFactor * 0.95);
                        const angle = Math.atan2(star.y, star.x) + pullFactor * 3;
                        const sx = Math.cos(angle) * currentDist;
                        const sy = Math.sin(angle) * currentDist;
                        
                        if (currentDist < this.radius) {
                            ctx.globalAlpha = lifeRatio * (currentDist / this.radius);
                            ctx.beginPath();
                            ctx.arc(sx, sy, star.r, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                    ctx.globalAlpha = 1;

                    for (let i = 0; i < 5; i++) {
                        const rotation = (time / (2000 + i * 200)) % (2 * Math.PI);
                        ctx.strokeStyle = `rgba(0, 0, 5, ${0.4 * lifeRatio})`;
                        ctx.lineWidth = (2 + i) * 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, (this.radius / 5) * (i + 1), rotation, rotation + Math.PI * 1.5);
                        ctx.stroke();
                    }
                    
                    const corePulse = 3 + Math.sin(time / 100) * 2;
                    const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, corePulse * 2);
                    coreGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    coreGrad.addColorStop(0.5, 'rgba(200, 220, 255, 0.7)');
                    coreGrad.addColorStop(1, 'rgba(150, 150, 255, 0)');
                    ctx.fillStyle = coreGrad;
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, corePulse * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case"grenadeExplosion":
                effect.maxLife=.5;
                effect.radius=radius || 60;
                effect.step=function(dt){this.life-=2*dt;this.life<=0&&(this.isActive=!1)};
                effect.draw=function(){
                    ctx.beginPath();
                    ctx.arc(this.x,this.y,this.radius*(1-this.life),0,2*Math.PI);
                    ctx.fillStyle=`rgba(255, 153, 51, ${.8*this.life})`;
                    ctx.fill()
                };
                break;
            case"shieldBreak":effect.maxLife=.6;effect.step=function(dt){this.life-=1.5*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.strokeStyle=`rgba(154, 102, 255, ${this.life})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(this.x,this.y,24*(1.5-this.life),0,2*Math.PI);ctx.stroke()};break;
            case "nanoHeal":
                effect.maxLife = 0.7;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const p = 1 - this.life;
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                    ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "critText":
                effect.maxLife = 0.6;
                effect.text = "CRITICAL!";
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 30 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                };
                break;
            case "bossPhaseChange":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; this.radius += 600 * dt; };
                effect.draw = function() {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.life})`;
                    ctx.lineWidth = 1 + 4 * this.life;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                };
                break;
             case "screenFlash":
                effect.maxLife = y / 1000;
                effect.life = effect.maxLife;
                effect.color = radius;
                effect.step = function(dt) {
                    this.life -= dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.globalAlpha = this.life / this.maxLife;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, 0, W, H);
                    ctx.restore();
                };
                break;
            case "timeRippleExplosion":
                effect.maxLife = 0.8;
                effect.radius = 0;
                effect.maxRadius = 80;
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.radius = this.maxRadius * (1 - this.life);
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Create time ripple effect with concentric circles
                    for (let i = 0; i < 3; i++) {
                        const rippleRadius = this.radius * (0.3 + i * 0.3);
                        const alpha = this.life * (1 - i * 0.2);
                        
                        // Outer ripple ring
                        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                        ctx.lineWidth = 3 - i;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Inner glow
                        ctx.fillStyle = `rgba(150, 220, 255, ${alpha * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius * 0.8, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    // Central time distortion effect
                    const centerAlpha = this.life * 0.6;
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                    grad.addColorStop(0, `rgba(200, 240, 255, ${centerAlpha})`);
                    grad.addColorStop(0.7, `rgba(100, 200, 255, ${centerAlpha * 0.5})`);
                    grad.addColorStop(1, `rgba(50, 150, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.restore();
                };
                break;
            case "lightningFlash":
                effect.maxLife = 0.15; // Very short flash duration
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Calculate flash intensity based on remaining life
                    const intensity = Math.sin(this.life * Math.PI); // Sine wave for smooth fade
                    const alpha = intensity * 0.8;
                    
                    // Outer blue glow
                    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
                    grad.addColorStop(0, `rgba(100, 200, 255, ${alpha})`);
                    grad.addColorStop(0.5, `rgba(50, 150, 255, ${alpha * 0.6})`);
                    grad.addColorStop(1, `rgba(30, 100, 255, 0)`);
                    
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Inner bright white core
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Electric sparks around the edge
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * 2 * Math.PI + this.life * 10; // Rotate sparks
                        const sparkX = Math.cos(angle) * (20 + Math.random() * 10);
                        const sparkY = Math.sin(angle) * (20 + Math.random() * 10);
                        
                        ctx.strokeStyle = `rgba(150, 220, 255, ${alpha * 0.7})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(sparkX * 0.7, sparkY * 0.7);
                        ctx.lineTo(sparkX, sparkY);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                };
                break;
        }
        return effect
    }
    
    function deployMineWall() {
        const p = store.player;
        for (let i = 0; i < 4; i++) {
            store.mines.push({
                x: p.x + (i - 1.5) * 40,
                y: p.y - 50,
                r: 10,
                fuse: 5,
                proxRadius: 75,
                isWallMine: true,
            });
        }
    }

    function explodeMine(mine) {
        playSound('explosion');
        const p = store.player;
        
        const numBullets = 18;
        for (let i = 0; i < numBullets; i++) {
            const angle = (i / numBullets) * 2 * Math.PI;
            const bulletSpeed = 300;
            store.bullets.push({
                x: mine.x, y: mine.y,
                vx: Math.cos(angle) * bulletSpeed,
                vy: Math.sin(angle) * bulletSpeed,
                r: 3, col: '#ff9966', dmg: 20 * p.dmgMult,
                pierce: false, life: 0.28
            });
        }

        const numFlames = 15;
        for (let i = 0; i < numFlames; i++) {
            const angle = (Math.random() - 0.5) * 120 * Math.PI / 180;
            const speed = 250 + Math.random() * 50;
            store.bullets.push({
                x: mine.x, y: mine.y,
                vx: Math.sin(angle) * speed, vy: -Math.cos(angle) * speed,
                r: 3 + Math.random() * 2, col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`,
                dmg: 2 * p.dmgMult, life: 0.3, isFlame: true
            });
        }

        store.activeEffects.push(createEffect("grenadeExplosion", mine.x, mine.y, 55));
    }


    let shopItemOrder = [];
    function showShop() {
        pauseGame();
        const panel = q("shopPanel"),
            grid = q("shopGrid"),
            goldEl = q("shopgold");
        goldEl.textContent = store.world.gold;

        // Add the mobile controls toggle if it doesn't exist
        if (!q('mobileControlsToggle')) {
            const toggleHTML = `
                <div class="mobile-toggle-container">
                    <span>Mobile Controls</span>
                    <label class="switch">
                        <input type="checkbox" id="mobileControlsToggle">
                        <span class="slider"></span>
                    </label>
                </div>`;
            panel.insertAdjacentHTML('afterbegin', toggleHTML);
            
            const toggle = q('mobileControlsToggle');
            toggle.checked = document.body.classList.contains('mobile-controls-active');

            toggle.addEventListener('change', () => {
                if (toggle.checked) {
                    document.body.classList.add('mobile-controls-active');
                    localStorage.setItem('mobileControlsEnabled', 'true');
                } else {
                    document.body.classList.remove('mobile-controls-active');
                    localStorage.setItem('mobileControlsEnabled', 'false');
                }
            });
        }

        // Add the skill tree viewer button if it doesn't exist AND player has a subclass
        if (!q('skillTreeViewerBtn') && store.player.subclass) {
            const skillTreeBtnHTML = `
                <div class="skill-tree-btn-container">
                    <button id="skillTreeViewerBtn" class="skill-tree-viewer-btn">View Skill Tree</button>
                </div>`;
            q('mobileControlsToggle').closest('.mobile-toggle-container').insertAdjacentHTML('afterend', skillTreeBtnHTML);
            
            const skillTreeBtn = q('skillTreeViewerBtn');
            skillTreeBtn.addEventListener('click', () => {
                viewCurrentSkillTree();
            });
        }

        // Hide the skill tree button if player doesn't have a subclass
        const existingBtn = q('skillTreeViewerBtn');
        if (existingBtn) {
            if (store.player.subclass) {
                existingBtn.style.display = 'block';
            } else {
                existingBtn.style.display = 'none';
            }
        }

        const currentItems = Object.keys(SHOP_UPGRADES).map(key => {
            const u = SHOP_UPGRADES[key];
            let currentLevel = store.player.upgradeLevels[key] || 0,
                cost = 0;
            if (key === 'vampirism') {
                cost = 12 + (store.player.vampirismLevel * 5);
                if (store.player.vampirismLevel >= u.max) cost = Infinity
            } else if (u.isPremium) {
                cost = u.cost
            } else {
                if (currentLevel >= u.maxLevel) {
                    cost = Infinity
                } else {
                    if (u.increment) {
                        cost = u.baseCost + (currentLevel * u.increment);
                    } else {
                        cost = Math.floor(u.baseCost * Math.pow(u.scale, currentLevel))
                    }
                }
            }
            return {
                key, ...u,
                cost
            }
        });
        const temporarilyDisabled = ["mine_wall"];

        if (shopItemOrder.length === 0) {
            const itemsToSort = [...currentItems];
            itemsToSort.sort((a, b) => {
                const aIsDisabled = temporarilyDisabled.includes(a.key);
                const bIsDisabled = temporarilyDisabled.includes(b.key);
                if (aIsDisabled && !bIsDisabled) return 1;
                if (!aIsDisabled && bIsDisabled) return -1;
                return a.cost - b.cost;
            });
            shopItemOrder = itemsToSort.map(item => item.key);
        }

        const shopItems = shopItemOrder.map(key => currentItems.find(item => item.key === key));
        
        let content = "";
        for (const u of shopItems) {
            const key = u.key;
            let currentLevel = store.player.upgradeLevels[key] || 0,
                isDisabled = false,
                cost = u.cost,
                desc = typeof u.desc === 'function' ? u.desc(currentLevel) : u.desc,
                name = u.name;
            if (u.isPremium) {
                if (key === 'vampirism') {
                    if (store.player.vampirismLevel >= u.max) isDisabled = true
                } else if (key === 'repair') {
                    if (store.player.hp >= store.player.hpMax) {
                        isDisabled = true;
                        desc = "Health is already full."
                    }
                } else if (key === 'nano_save') {
                    if (store.player.nanoSaves >= u.max) {
                        isDisabled = true;
                        desc = "Max charges reached."
                    }
                } else if (key === 'mine_wall') {
                    if (store.mines.filter(m => m.isWallMine).length > 0) {
                        isDisabled = true;
                        desc = "Wall already deployed."
                    }
                } else if (u.isUnlock) {
                    if ( (key === 'gravity_well' && store.player.hasVoidBeam) ||
                         (key === 'lazarus_beam' && store.player.hasLazarusBeam) ||
                         (key === 'launcher' && store.player.hasLauncher) ||
                         (key === 'luck_boost' && store.player.luckBoost > 0) ||
                         (key === 'magnet_pull' && store.player.magnetRadius > 0) ||
                         (key === 'rear_guard' && store.player.hasRearGuard) ||
                         (key === 'iceman' && store.player.hasIceman)) {
                        isDisabled = true;
                        desc = "Already Unlocked"
                    }
                } else {
                    if (store.player.grenades >= u.max) {
                        isDisabled = true;
                        desc = "At maximum capacity"
                    }
                }
            } else {
                if (currentLevel >= u.maxLevel) {
                    isDisabled = true;
                    desc = "Max Level Reached"
                }
            }
            if (store.world.gold < cost) isDisabled = true;
            if (temporarilyDisabled.includes(key)) {
                isDisabled = true;
                desc = "Under maintenance.";
            }
            const costText = isFinite(cost) ? cost : '---';
            content += `<div class="skill-card shop-item ${isDisabled?'disabled':''} shop-item-${u.category}" data-key="${key}"><div class="skill-icon">${u.icon}</div><div><div class="skill-title">${name}</div><div class="skill-desc">${desc}</div></div><div style="color:var(--accent);margin-top:4px;font-size:11px;">Cost: ${costText}</div></div>`
        }
        grid.innerHTML = content;
        grid.querySelectorAll(".shop-item").forEach(item => {
            item.addEventListener("click", () => {
                if (item.classList.contains('disabled')) return;
                const key = item.dataset.key;
                const upgrade = SHOP_UPGRADES[key];
                let purchaseSuccessful = false;
                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const cost = 12 + (store.player.vampirismLevel * 5);
                        if (store.world.gold >= cost) {
                            purchaseSuccessful = upgrade.apply()
                        }
                    } else {
                        const cost = upgrade.cost;
                        if (store.world.gold >= cost) {
                            store.world.gold -= cost;
                            purchaseSuccessful = upgrade.apply()
                        }
                    }
                } else {
                    const currentLevel = store.player.upgradeLevels[key] || 0;
                    let cost;
                    if (upgrade.increment) {
                        cost = upgrade.baseCost + (currentLevel * upgrade.increment);
                    } else {
                        cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, currentLevel));
                    }

                    if (store.world.gold >= cost) {
                        store.world.gold -= cost;
                        upgrade.effect(currentLevel);
                        store.player.upgradeLevels[key] = (store.player.upgradeLevels[key] || 0) + 1;
                        purchaseSuccessful = true;
                    }
                }
                if (purchaseSuccessful) {
                    showShop()
                }
            })
        });

        // Update skill tree button state
        const skillTreeBtn = q('skillTreeBtn');
        if (skillTreeBtn) {
            skillTreeBtn.onclick = () => {
                const subclassPanel = q('subclassPanel');
                // Check if skill tree is already open
                if (subclassPanel.classList.contains('skill-tree-active') && !subclassPanel.classList.contains('hide')) {
                    // Close the skill tree
                    subclassPanel.classList.add('hide');
                    subclassPanel.classList.remove('skill-tree-active');
                    resumeGame();
                } else {
                    // Open the progressive skill tree system
                    q('shopPanel').classList.add('hide');
                    showProgressiveSkillTree();
                }
            };
        }

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        panel.classList.remove("hide")
    }

    function showShopWithHighlight() { showShop(); announce('Low health! Use the Mech Forge to repair!'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }
    function createHound(side) {
        const isTuxedo = side === -1 || side === -2;
        let color = isTuxedo ? { main: '#222222', accent: '#FFFFFF' } : { main: '#F0E68C', accent: '#BDB76B' };
        
        let isUpgraded = false;
        let eyeType = 'normal';
        let expression = 'normal';

        if (Math.abs(side) > 1) { 
            isUpgraded = true;
            if (side === -2) { 
                color = { main: '#c4b5a0', accent: '#333' }; 
                eyeType = 'swirly';
                expression = 'silly';
            } else { 
                color = { main: '#ffb366', accent: '#000' }; 
                eyeType = 'dilated';
                expression = 'mischievous';
            }
        }

        return {
            x: store.player.x + 50 * side,
            y: store.player.y + 20,
            side,
            target: null,
            attackT: 0,
            r: 12,
            killCount: 0,
            color,
            isUpgraded,
            eyeType,
            expression
        };
    }
    function stepHounds(dt) { if (!store.player.hasHounds) return; store.hounds.forEach(h => { if (!h.target || h.target.dead || h.target.hp <= 0) { let closest = null, closestDist = Infinity; const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies; potentialTargets.forEach(e => { if (e.dead || e.hp <= 0) return; const dist = (h.x - e.x)**2 + (h.y - e.y)**2; if (dist < closestDist) { closestDist = dist; closest = e; } }); h.target = closest; } if (h.target) { const tx = h.target.x, ty = h.target.y; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); const speed = 350; if (dist > 30) { h.x += (dx / dist) * speed * dt; h.y += (dy / dist) * speed * dt; } else { h.attackT -= dt; if (h.attackT <= 0) { h.attackT = 0.25; let dmg = 8 * store.player.dmgMult; if (h.target === store.boss) dmg *= 0.3; if (!h.target.dead && h.target.hp > 0) { h.target.hp -= dmg; if (store.player.vampirism > 0) { let healAmount = dmg * store.player.vampirism; healAmount = Math.max(healAmount, 0.5); healAmount = Math.min(healAmount, 2); store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount); } if (h.target.hp <= 0) { h.killCount++; if (h.killCount > 0 && h.killCount % 12 === 0) { playSound('dogs'); } } } } } } else { const tx = store.player.x + h.side * 50, ty = store.player.y + 20; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 5) { h.x += dx * 5 * dt; h.y += dy * 5 * dt; } } }); }
    function drawHound(h) {
        ctx.save();
        ctx.translate(h.x, h.y);
        const time = performance.now();
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time / 1000 + h.side);
        const r = h.r;

        if (!h.isUpgraded) {
            const { main, accent } = h.color;
            const isTuxedo = accent === '#FFFFFF';

            ctx.fillStyle = main;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.5);
            ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
            ctx.quadraticCurveTo(r * 1.2, 0, r, r);
            ctx.lineTo(-r, r);
            ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.moveTo(-r, -r * 0.4);
            ctx.lineTo(-r * 0.5, -r * 1.2);
            ctx.lineTo(-r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r, -r * 0.4);
            ctx.lineTo(r * 0.5, -r * 1.2);
            ctx.lineTo(r * 0.2, -r * 0.6);
            ctx.closePath();
            ctx.fill();

            if (isTuxedo) {
                ctx.fillStyle = accent;
                ctx.beginPath();
                ctx.moveTo(-r * 0.6, r * 0.2);
                ctx.quadraticCurveTo(0, r, r * 0.6, r * 0.2);
                ctx.lineTo(0, r * 0.5);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = isTuxedo ? main : accent;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.3, r * 0.5, r * 0.4, 0, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = "#FFF";
            ctx.beginPath();
            ctx.moveTo(-r * 0.3, r * 0.5);
            ctx.lineTo(-r * 0.1, r * 0.5);
            ctx.lineTo(-r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.3, r * 0.5);
            ctx.lineTo(r * 0.1, r * 0.5);
            ctx.lineTo(r * 0.2, r * 0.9);
            ctx.closePath();
            ctx.fill();
        } else {
            const color = h.color.main;
            const opacity = ctx.globalAlpha;
            const eyeType = h.eyeType;
            const expression = h.expression;
            const radius = r * 1.5;

            if (h.side === 2) {
                ctx.save();
                ctx.globalAlpha = 0.7 * opacity;
                ctx.fillStyle = '#9966ff';
                ctx.beginPath();
                ctx.moveTo(0, -radius * 1.8);
                ctx.lineTo(-radius * 0.8, -radius * 0.9);
                ctx.lineTo(radius * 0.8, -radius * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius * 0.6, -radius * 0.7);
            ctx.lineTo(-radius * 0.4, -radius * 1.2);
            ctx.lineTo(-radius * 0.2, -radius * 0.8);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.6, -radius * 0.7);
            ctx.lineTo(radius * 0.4, -radius * 1.2);
            ctx.lineTo(radius * 0.2, -radius * 0.8);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-radius, 0);
            for(let i = 0; i <= 6; i++) {
                let waveX = -radius + (radius * 2 / 6) * i;
                let waveY = radius + Math.sin(i * 0.8 + time * 0.005) * radius * 0.2;
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(radius, 0);
            ctx.fill();

            ctx.fillStyle = 'white';
            
            if (eyeType === 'dilated') {
                ctx.beginPath();
                ctx.ellipse(-radius * 0.35, -radius * 0.1, radius * 0.28, radius * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(radius * 0.35, -radius * 0.15, radius * 0.25, radius * 0.32, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(-radius * 0.3 + Math.sin(time * 0.001) * radius * 0.05,
                      -radius * 0.05, radius * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.4,
                      -radius * 0.2 + Math.cos(time * 0.001) * radius * 0.05,
                      radius * 0.06, 0, Math.PI * 2);
                ctx.fill();
            } else { // 'swirly'
                ctx.beginPath();
                ctx.arc(-radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(radius * 0.35, -radius * 0.1, radius * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'black';
                ctx.lineWidth = radius * 0.04;
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = -radius * 0.35 + Math.cos(t + time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t + time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
                
                ctx.beginPath();
                for(let t = 0; t < Math.PI * 4; t += 0.1) {
                    let r_swirl = t * radius * 0.02;
                    let sx = radius * 0.35 + Math.cos(t - time * 0.001) * r_swirl;
                    let sy = -radius * 0.1 + Math.sin(t - time * 0.001) * r_swirl;
                    if(t === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            
            ctx.fillStyle = 'white';
            
            ctx.beginPath();
            ctx.moveTo(-radius * 0.25, radius * 0.2);
            ctx.lineTo(-radius * 0.2, radius * 0.5);
            ctx.lineTo(-radius * 0.15, radius * 0.2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(radius * 0.25, radius * 0.2);
            ctx.lineTo(radius * 0.2, radius * 0.5);
            ctx.lineTo(radius * 0.15, radius * 0.2);
            ctx.fill();
            
            for(let i = -1; i <= 1; i++) {
                if(i === 0) continue;
                ctx.beginPath();
                ctx.moveTo(i * radius * 0.08, radius * 0.2);
                ctx.lineTo(i * radius * 0.08 + radius * 0.02, radius * 0.35);
                ctx.lineTo(i * radius * 0.08 - radius * 0.02, radius * 0.35);
                ctx.fill();
            }
            
            ctx.strokeStyle = expression === 'silly' ? '#000' : '#333';
            ctx.lineWidth = radius * 0.03;
            ctx.beginPath();
            
            if (expression === 'silly') {
                ctx.moveTo(-radius * 0.3, radius * 0.15);
                ctx.quadraticCurveTo(-radius * 0.1, radius * 0.05, 0, radius * 0.15);
                ctx.quadraticCurveTo(radius * 0.1, radius * 0.25, radius * 0.3, radius * 0.15);
            } else {
                ctx.arc(0, 0, radius * 0.35, Math.PI * 0.2, Math.PI * 0.8);
            }
            ctx.stroke();
        }
        ctx.restore();
    }
    function drawIceman(iceman) {
        const { x, y } = iceman;
        ctx.save();
        ctx.translate(x, y);
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12, 8);
        ctx.lineTo(8, 14);
        ctx.lineTo(0, 10);
        ctx.lineTo(-8, 14);
        ctx.lineTo(-12, 8);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
        bodyGrad.addColorStop(0, "#a0e9ff");
        bodyGrad.addColorStop(1, "#3c9aed");
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d0f8ff";
        ctx.stroke();

        ctx.strokeStyle = "#a0e9ff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 5);
        ctx.lineTo(-20, -2);
        ctx.lineTo(-18, 8);
        ctx.moveTo(12, 5);
        ctx.lineTo(20, -2);
        ctx.lineTo(18, 8);
        ctx.stroke();

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(0, -8, 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function drawLightningBolt(bolt) {
        const { points, life, maxLife } = bolt;
        const t = life / maxLife;
        if (t <= 0) return;

        ctx.save();
        ctx.lineWidth = 4 * t;
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * t})`;
        ctx.shadowColor = '#9a66ff';
        ctx.shadowBlur = 20 * t;
        
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.stroke();
        
        ctx.lineWidth = 1.5 * t;
        ctx.strokeStyle = `rgba(200, 220, 255, ${t})`;
        ctx.shadowBlur = 10 * t;
        ctx.stroke();

        ctx.restore();
    }

    function drawEmpNova(nova) {
        ctx.save();
        
        // Create pulsing effect
        const time = performance.now() / 1000;
        const pulse = 0.8 + 0.2 * Math.sin(time * 8);
        const opacity = Math.min(1, nova.life / 2) * 0.3; // Fade in over 2 seconds
        
        // Draw expanding EMP ring
        ctx.strokeStyle = `rgba(255, 140, 0, ${opacity * pulse})`; // Orange cyberpunk color
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]); // Dashed line for tech effect
        ctx.shadowColor = '#FF8C00';
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner energy ring
        ctx.strokeStyle = `rgba(138, 43, 226, ${opacity * pulse * 0.7})`; // Purple
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.shadowColor = '#8A2BE2';
        ctx.shadowBlur = 10;
        
        ctx.beginPath();
        ctx.arc(nova.x, nova.y, nova.radius * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        
        // Add some sparking effects around the perimeter
        ctx.setLineDash([]);
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * pulse})`;
        ctx.lineWidth = 1;
        
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2 + time * 2;
            const x1 = nova.x + Math.cos(angle) * (nova.radius - 5);
            const y1 = nova.y + Math.sin(angle) * (nova.radius - 5);
            const x2 = nova.x + Math.cos(angle) * (nova.radius + 5);
            const y2 = nova.y + Math.sin(angle) * (nova.radius + 5);
            
            if (Math.random() < 0.3) { // Random sparking
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
        
        ctx.restore();
    }

    function activateGravityWell() {
        if (!store.isPaused) {
            const spawnX = W * 0.2 + Math.random() * W * 0.6;
            const spawnY = H * 0.2 + Math.random() * H * 0.6;
            store.activeEffects.push(createEffect("gravityWell", spawnX, spawnY));
            announce('GRAVITY WELL ACTIVATED');
            screenFlash(2, 250, 'rgba(255, 255, 255, 0.7)');
        }
    }
    function activateLazarus() {
        if (store.player.hasLazarusBeam && !store.isPaused) {
            const angle = Math.random() * 2 * Math.PI,
                speed = 800,
                p = store.player;
            store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 6, r: 12, hitEnemies: new Set });
            
            if (p.upgradeLevels.lazarus_beam > 1) {
                const oppositeAngle = angle + Math.PI;
                store.lasers.push({ x: p.x, y: p.y, prevX: p.x, prevY: p.y, vx: Math.cos(oppositeAngle) * speed, vy: Math.sin(oppositeAngle) * speed, life: 6, r: 12, hitEnemies: new Set });
            }
        }
    }
    function useGrenade() {
        if (store.player.grenades > 0 && !store.isPaused) {
            playSound('explosion');
            store.player.grenades--;
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 400;
                store.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 5, col: '#ff8080', dmg: 40 * p.dmgMult,
                    pierce: true, life: 0.8
                });
            }
            store.activeEffects.push(createEffect("shieldBreak", p.x, p.y));
        }
    }
    
    function stepVoidLaser(dt) {
        const p = store.player;
        
        // Determine range based on phasestriker level
        let maxRange;
        if (p.phasestRikerLevel >= 1) {
            // Level 1+: Global range - can hit anything on screen (unlimited range upgrade)
            maxRange = Math.max(W, H) * 2; // Unlimited range using game dimensions
        } else if (p.phasestRikerLevel >= 0.5) {
            // Base phasestriker: Use voidLaserRange (medium range)
            maxRange = p.voidLaserRange || 250;
        } else {
            // No phasestriker: Default short range
            maxRange = p.r * 12;
        }
        
        // Timer for retargeting - check for new targets every 0.1 seconds
        p.voidLaserRetargetTimer -= dt;
        if (p.voidLaserRetargetTimer <= 0) {
            p.voidLaserRetargetTimer = 0.1;
            
            // Find closest enemy within range
            const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
            let closestTarget = null;
            let closestDistSq = maxRange * maxRange;
            
            allEnemies.forEach(e => {
                const distSq = (p.x - e.x) ** 2 + (p.y - e.y) ** 2;
                if (distSq < closestDistSq) {
                    closestDistSq = distSq;
                    closestTarget = e;
                }
            });
            
            // Reset ramp time if target changed
            if (closestTarget !== p.voidLaserLastTarget) {
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = closestTarget;
            }
            
            p.voidLaserTarget = closestTarget;
        }
        
        // Apply continuous damage if we have a target
        if (p.voidLaserTarget && !p.voidLaserTarget.dead) {
            // Check if target is still in range
            const distSq = (p.x - p.voidLaserTarget.x) ** 2 + (p.y - p.voidLaserTarget.y) ** 2;
            if (distSq <= maxRange * maxRange) {
                // Increase ramp time for level 2 phasestriker
                if (p.phasestRikerLevel >= 2) {
                    p.voidLaserRampTime += dt;
                }
                
                // Damage timer - apply damage every 0.1 seconds for smooth continuous damage
                p.voidLaserDamageTimer -= dt;
                if (p.voidLaserDamageTimer <= 0) {
                    p.voidLaserDamageTimer = 0.1;
                    
                    // Base damage
                    let damage = 8.5 * p.dmgMult;
                    
                    // Level 2 phasestriker: Ramping damage based on time on target
                    if (p.phasestRikerLevel >= 2) {
                        const rampMultiplier = 1 + (p.voidLaserRampTime * 0.8); // +80% damage per second
                        damage *= Math.min(rampMultiplier, 4.0); // Cap at 4x damage
                    }
                    
                    if (p.voidLaserTarget === store.boss) damage *= 0.3; // Reduced damage to boss
                    
                    p.voidLaserTarget.hp -= damage;
                    store.world.totalDamage += damage;
                    
                    // Apply vampirism healing for laser damage
                    if (store.player.vampirism > 0) {
                        let healAmount = damage * store.player.vampirism;
                        healAmount = Math.max(healAmount, 0.1); // Minimum heal
                        healAmount = Math.min(healAmount, 0.6); // Increased heal cap slightly
                        store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                    }
                }
            } else {
                // Target out of range
                p.voidLaserTarget = null;
                p.voidLaserRampTime = 0;
                p.voidLaserLastTarget = null;
            }
        } else {
            // No target or target dead - reset ramp
            p.voidLaserTarget = null;
            p.voidLaserRampTime = 0;
            p.voidLaserLastTarget = null;
        }
    }
    
    function fireChainLightning() {
        const p = store.player;
        
        if (p.stormstrikerLevel >= 3) {
            // Level 3: Fire four chain lightning bolts alternating in sequence (Thunder Lord)
            // Cycle through positions: far left -> left wing -> right wing -> far right -> repeat
            const positions = [
                { x: p.x - 25, y: p.y - 15 }, // Far left
                { x: p.x - 8, y: p.y - 8 },  // Left wing
                { x: p.x + 8, y: p.y - 8 },  // Right wing  
                { x: p.x + 25, y: p.y - 15 } // Far right
            ];
            
            if (!p.lightningCycleIndex) p.lightningCycleIndex = 0;
            const position = positions[p.lightningCycleIndex];
            fireChainLightningBolt(1.0, position);
            p.lightningCycleIndex = (p.lightningCycleIndex + 1) % 4;
        } else if (p.stormstrikerLevel >= 2) {
            // Level 2: Alternate between left and right wing guns (Twin Lightning)
            if (p.lightningAlternate) {
                fireChainLightningBolt(1.0, { x: p.x + 18, y: p.y - 8 }); // Right wing gun
            } else {
                fireChainLightningBolt(1.0, { x: p.x - 18, y: p.y - 8 }); // Left wing gun
            }
            p.lightningAlternate = !p.lightningAlternate; // Toggle for next shot
        } else if (p.hasHybridVoid) {
            // Fire single lightning bolt (reduced power for hybrid)
            fireChainLightningBolt(0.7); // 70% damage for hybrid mode
        } else {
            // Standard single chain lightning from ship center (default stormcaller)
            fireChainLightningBolt();
        }
    }
    
    function fireChainLightningBolt(damageMultiplier = 1.0, startPos = null) {
        const p = store.player;
        const allEnemies = store.boss ? [...store.enemies.filter(e => !e.dead), store.boss] : store.enemies.filter(e => !e.dead);
        if (allEnemies.length === 0) return;

        // Use custom start position or default to center above player
        const startPoint = startPos || { x: p.x, y: p.y - 20 };

        let closestDistSq = Infinity;
        let currentTarget = null;
        allEnemies.forEach(e => {
            const distSq = (startPoint.x - e.x)**2 + (startPoint.y - e.y)**2;
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                currentTarget = e;
            }
        });

        if (!currentTarget) return;

        const maxJumps = 100; // High limit for unlimited potential with probabilistic limiting
        const chainChance = 0.65; // 65% chance to chain each jump
        let currentDamage = 95 * p.dmgMult * damageMultiplier * (p.chainLightningDamage || 1.0);
        const targetsHit = new Set();
        const chainPoints = [startPoint];

        for (let i = 0; i < maxJumps && currentTarget; i++) {
            targetsHit.add(currentTarget);
            chainPoints.push({ x: currentTarget.x, y: currentTarget.y });

            // Create blue lightning flash at hit point
            store.activeEffects.push(createEffect('lightningFlash', currentTarget.x, currentTarget.y));

            let dmg = currentDamage;
            if (currentTarget === store.boss) dmg *= 0.3;
            currentTarget.hp -= dmg;
            store.world.totalDamage += dmg;
            
            // Apply vampirism healing for chain lightning damage
            if (store.player.vampirism > 0) {
                let healAmount = dmg * store.player.vampirism;
                healAmount = Math.max(healAmount, 0.5); // Minimum 0.5 HP for lightning
                healAmount = Math.min(healAmount, 3); // Cap at 3 HP for lightning
                store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
            }

            // Check if the lightning should chain (50% chance each jump)
            if (Math.random() >= chainChance) {
                // Chain failed - stop here
                break;
            }

            // Find next target for chaining
            let nextTarget = null;
            let nextDistSq = Infinity;
            allEnemies.forEach(e => {
                if (e.dead || targetsHit.has(e)) return;
                const distSq = (currentTarget.x - e.x)**2 + (currentTarget.y - e.y)**2;
                if (distSq < nextDistSq) {
                    nextDistSq = distSq;
                    nextTarget = e;
                }
            });

            // If no valid target found, stop chaining
            if (!nextTarget) break;

            currentTarget = nextTarget;
            currentDamage *= 0.85; // Slightly less decay since we have probabilistic limiting
        }

        if (chainPoints.length > 1) {
            store.lightningBolts.push({
                points: chainPoints,
                life: 0.4,
                maxLife: 0.4,
                dead: false
            });
        }
    }
    
    const VOIDSTEP = {
        cooldownMs: 2500,
        iframeMs: 220,
        riftMs: 600,
        edgePadding: 6
    };
    let lastVoidStep = -9999;
    let invulUntil = 0;
    const rifts = [];
    const blinkFlashes = [];
    
    // ‚ó¢‚ó£‚ó•‚ó§ ENTROPY REDUCTION ENGINE - MULTI-PILOT SYSTEM ‚ó¢‚ó£‚ó•‚ó§ [DISABLED FOR STABILITY]
    // Maxwell's Demon + Szilard Engine + Quantum Field Manipulation
    const ENTROPY_ENGINE = {
        active: false, // PERMANENTLY DISABLED FOR STABILITY
        entropyReduction: 0,
        quantumCoherence: 1.0,
        maxwellDemons: 0,
        stellarFusionRate: 1.0,
        universalHeatDeath: false,
        thermalGradient: 0,
        negentropicField: 0,
        // Pilot-specific entropy systems
        kineticEntropy: 0,        // Beef pilot - kinetic energy conversion
        explosiveEntropy: 0,      // Rocketman pilot - explosive redistribution  
        quantumEntropy: 0         // Void pilot - pure quantum manipulation
    };
    
    // Physics Constants for Entropy Reduction
    const PHYSICS = {
        BOLTZMANN_CONSTANT: 1.380649e-23,
        PLANCK_CONSTANT: 6.62607015e-34,
        SPEED_OF_LIGHT: 299792458,
        STEFAN_BOLTZMANN: 5.670374419e-8,
        VACUUM_PERMEABILITY: 4 * Math.PI * 1e-7
    };
    
    // Entropy Reduction Formula: ŒîS = -k_B * ln(Œ©) * Q_coherence * N_demons
    function calculateEntropyReduction(waveNumber, kills, damageDelt) {
        if (!ENTROPY_ENGINE.active) return 0;
        
        const pilotType = store.player.pilotGenome;
        let entropyReduced = 0;
        
        if (pilotType === 'voidmancer') {
            // VOID PILOT: Pure quantum manipulation (original system)
            const coherenceFactor = Math.exp(-waveNumber / 1000) * ENTROPY_ENGINE.quantumCoherence;
            const demonMultiplier = 1 + ENTROPY_ENGINE.maxwellDemons * 0.1;
            const negentropicEnergy = kills * 10 + damageDelt * 0.01;
            const informationBits = Math.log2(Math.max(1, kills));
            const szilardWork = informationBits * PHYSICS.BOLTZMANN_CONSTANT * 300;
            
            entropyReduced = -szilardWork * coherenceFactor * demonMultiplier * negentropicEnergy / 1e20;
            ENTROPY_ENGINE.quantumEntropy += entropyReduced;
            
        } else if (pilotType === 'beef') {
            // BEEF PILOT: Kinetic entropy conversion via collision dynamics
            const kineticEnergy = store.player.speed * damageDelt * 0.001; // Mass-energy from movement
            const collisionOrder = kills * 5; // Each kill creates order from chaos
            const thermalConversion = Math.sqrt(kineticEnergy * collisionOrder);
            
            entropyReduced = -thermalConversion / 1e18;
            ENTROPY_ENGINE.kineticEntropy += entropyReduced;
            console.log(`üí• KINETIC ENTROPY CONVERSION: ${entropyReduced.toExponential(2)} J/K`);
            
        } else if (pilotType === 'rocketman') {
            // ROCKETMAN: Explosive entropy redistribution via controlled detonation
            const explosiveYield = damageDelt * 0.1; // Energy from explosions
            const redistributionFactor = Math.log(1 + kills) * 2; // Exponential distribution efficiency
            const orderedExplosion = explosiveYield * redistributionFactor * Math.PI; // œÄ for circular distribution
            
            entropyReduced = -orderedExplosion / 1e19;
            ENTROPY_ENGINE.explosiveEntropy += entropyReduced;
            if (Math.random() < 0.03) { // 3% chance to show message
                console.log(`üöÄ EXPLOSIVE ENTROPY REDISTRIBUTION: ${entropyReduced.toExponential(2)} J/K`);
            }
        }
        
        // Universal entropy tracking
        ENTROPY_ENGINE.entropyReduction += entropyReduced;
        ENTROPY_ENGINE.thermalGradient = Math.sin(performance.now() / 1000) * Math.abs(entropyReduced) * 100;
        
        return entropyReduced;
    }
    
    // Stellar Fusion Rate Enhancement via Entropy Manipulation  
    function enhanceStellarFusion() {
        if (!ENTROPY_ENGINE.active) return 1.0;
        
        // Ensure entropy reduction is valid
        const entropyReduction = isNaN(ENTROPY_ENGINE.entropyReduction) ? 0 : ENTROPY_ENGINE.entropyReduction;
        
        // Negative entropy increases fusion efficiency via quantum tunneling enhancement
        const fusionBoost = 1.0 + (Math.max(0, entropyReduction) * 1e15);
        const calculatedRate = Math.max(0.1, fusionBoost);
        
        // Ensure the result is never NaN
        ENTROPY_ENGINE.stellarFusionRate = isNaN(calculatedRate) ? 1.0 : calculatedRate;
        
        // Prevent heat death by maintaining thermal gradients
        if (entropyReduction > 0.001) {
            ENTROPY_ENGINE.universalHeatDeath = false;
        }
        
        return ENTROPY_ENGINE.stellarFusionRate;
    }
    
    // Activate entropy engine for all pilots with specialized systems [DISABLED FOR STABILITY]
    function activateEntropyEngine() {
        const pilotType = store.player.pilotGenome;
        if (pilotType && ['voidmancer', 'beef', 'rocketman'].includes(pilotType)) {
            // ENTROPY_ENGINE.active = true; // DISABLED FOR STABILITY
            ENTROPY_ENGINE.maxwellDemons = Math.floor(store.world.level / 10);
            ENTROPY_ENGINE.quantumCoherence = Math.min(1.0, 0.5 + store.world.score / 1000000);
            
            console.log(`üåå ENTROPY REDUCTION ENGINE ACTIVATED üåå`);
            console.log(`üì° REVERSING UNIVERSAL HEAT DEATH üì°`);
            
            if (pilotType === 'voidmancer') {
                console.log(`üîÆ VOID PILOT: Pure Quantum Manipulation System`);
                console.log(`‚öõÔ∏è Physics: ŒîS = -k_B * ln(Œ©) * Q_coherence * N_demons`);
                console.log(`üî¨ Maxwell's Demons: ${ENTROPY_ENGINE.maxwellDemons}`);
                console.log(`üåÄ Quantum Coherence: ${ENTROPY_ENGINE.quantumCoherence.toFixed(3)}`);
            } else if (pilotType === 'beef') {
                console.log(`üí• BEEF PILOT: Kinetic Entropy Conversion System`);
                console.log(`‚ö° Physics: ŒîS = -‚àö(KE * Order) via collision dynamics`);
                console.log(`üèÉ Kinetic conversion efficiency based on speed and impact`);
            } else if (pilotType === 'rocketman') {
                console.log(`üöÄ ROCKETMAN: Explosive Entropy Redistribution System`);
                console.log(`üí£ Physics: ŒîS = -(Yield * ln(kills) * œÄ) via controlled detonation`);
                console.log(`üéØ Explosive distribution creates ordered energy patterns`);
            }
            
            console.log(`üåü Mission: Save the Sun and all dying stars! üåü`);
            console.log(`üî• Stellar fusion enhancement: ${ENTROPY_ENGINE.stellarFusionRate.toFixed(1)}x`);
        }
    }
    
    // ‚ó¢‚ó£ TEMPORAL WARP SYSTEM ‚ó£‚ó¢
    function checkTemporalAnomaly() {
        if (store.world.temporalAnomalyTriggered || store.world.isTemporalWarp) return;
        
        // Don't trigger during boss fights or if there are active enemies
        if (store.boss || store.enemies.length > 0) return;
        
        // Trigger at wave 15 with physics justification
        if (store.world.wave === 15) {
            store.world.temporalAnomalyTriggered = true;
            showTemporalAnomalyChoice();
        }
    }
    
    function showTemporalAnomalyChoice() {
        const choice = confirm(
            "‚ö†Ô∏è TEMPORAL ANOMALY DETECTED ‚ö†Ô∏è\n\n" +
            `Relativistic effects detected near c=${PHYSICS.SPEED_OF_LIGHT} m/s\n` +
            "Spacetime distortion creates temporal rift to future timeline.\n\n" +
            "‚öõÔ∏è WARNING: Dangerous temporal effects ahead\n" +
            "üï∞Ô∏è Time jump may cause causality paradox\n\n" +
            "Enter the time rift?"
        );
        
        if (choice) {
            initTemporalWarp();
        }
    }
    
    function initTemporalWarp() {
        console.log("üåÄ INITIATING TEMPORAL WARP SEQUENCE üåÄ");
        
        // Save original player state
        store.world.temporalOriginalStats = {
            wave: store.world.wave,
            hp: store.player.hp,
            hpMax: store.player.hpMax,
            shield: store.player.shield,
            shieldMax: store.player.shieldMax,
            dmgMult: store.player.dmgMult,
            speed: store.player.speed,
            multishot: store.player.multishot,
            xp: store.world.xp,
            gold: store.world.gold
        };
        
        store.world.isTemporalWarp = true;
        store.world.temporalWarpPhase = 'transform';
        store.world.temporalWarpTimer = 0;
        
        // Apply future ship transformation
        applyFutureShipUpgrade();
    }
    
    function applyFutureShipUpgrade() {
        console.log("üöÄ SHIP TRANSFORMATION: FUTURE TECHNOLOGY ENGAGED");
        
        // Massive temporary stat boosts
        store.player.dmgMult *= 50;  // 50x damage
        store.player.speed *= 3;     // 3x speed
        store.player.multishot = Math.max(store.player.multishot, 8); // At least 8 shots
        store.player.hpMax = 2000;   // Future ship durability
        store.player.hp = store.player.hpMax;
        store.player.shieldMax = 2000; // Massive shields
        store.player.shield = store.player.shieldMax;
        
        announce("‚ó¢ FUTURE SHIP ONLINE - OVERWHELMING POWER ‚ó£");
        
        // Start power demonstration phase after brief delay
        setTimeout(() => {
            store.world.temporalWarpPhase = 'waves';
            store.world.temporalWarpTimer = 0;
            initTemporalWaves();
        }, 1000);
    }
    
    function initTemporalWaves() {
        console.log("‚ö° TEMPORAL POWER DEMONSTRATION: DECIMATING FUTURE ENEMIES");
        announce("‚ó¢ FUTURE TIMELINE - YEAR 2847 ‚ó£");
        
        // Clear current enemies and spawn demonstration waves
        store.enemies = [];
        store.eBullets = [];
        
        // Spawn first demonstration wave
        spawnTemporalWave(1);
    }
    
    function spawnTemporalWave(waveNum) {
        const enemyCount = 15 + waveNum * 5;
        
        for (let i = 0; i < enemyCount; i++) {
            const enemy = spawnEnemy('basic');
            enemy.x = Math.random() * W;
            enemy.y = -50 - Math.random() * 200;
            enemy.hp *= 0.1; // Make them die instantly to show power
            store.enemies.push(enemy);
        }
        
        announce(`‚ó¢ TEMPORAL WAVE ${waveNum} - ANNIHILATION MODE ‚ó£`);
    }
    
    function updateTemporalWarp(dt) {
        if (!store.world.isTemporalWarp) return;
        
        // Safety check: if somehow we have normal bosses during temporal warp, abort
        if (store.boss && !store.boss.isHeatDeath) {
            console.log("‚ö†Ô∏è TEMPORAL WARP CONFLICT DETECTED - ABORTING");
            store.world.isTemporalWarp = false;
            store.world.temporalWarpPhase = null;
            store.player.isInvincible = false;
            return;
        }
        
        store.world.temporalWarpTimer += dt;
        
        if (store.world.temporalWarpPhase === 'waves') {
            // Check if enemies are cleared for wave progression
            if (store.enemies.length === 0) {
                if (store.world.temporalWarpTimer < 8) { // First wave cleared quickly
                    spawnTemporalWave(2);
                    store.world.temporalWarpTimer = 4; // Reset timer for second wave
                } else if (store.world.temporalWarpTimer >= 15) { // After ~15 seconds total
                    // Start Heat Death boss fight
                    store.world.temporalWarpPhase = 'boss';
                    store.world.temporalWarpTimer = 0;
                    initHeatDeathBoss();
                }
            }
        } else if (store.world.temporalWarpPhase === 'boss') {
            // Heat death boss phase - player dies after 10 seconds
            if (store.world.temporalWarpTimer >= 10) {
                store.world.temporalWarpPhase = 'death';
                store.world.temporalWarpTimer = 0;
                initTemporalDeath();
            }
        } else if (store.world.temporalWarpPhase === 'death') {
            // Death narrative phase
            if (store.world.temporalWarpTimer >= 3) {
                store.world.temporalWarpPhase = 'return';
                store.world.temporalWarpTimer = 0;
                returnFromTemporalWarp();
            }
        }
    }
    
    function initHeatDeathBoss() {
        console.log("üíÄ HEAT DEATH OF THE UNIVERSE - INEVITABLE DOOM");
        
        // Clear everything and create the void boss
        store.enemies = [];
        store.eBullets = [];
        
        // Create Heat Death "boss" (invisible, atmospheric)
        store.boss = {
            name: "HEAT DEATH OF THE UNIVERSE",
            x: W/2,
            y: H/4,
            hp: 999999999, // Effectively invincible
            hpMax: 999999999,
            dead: false,
            isHeatDeath: true, // Special flag
            visible: false // Don't show in normal HUD
        };
        
        announce("üíÄ HEAT DEATH OF THE UNIVERSE üíÄ");
        
        // Show futility message
        setTimeout(() => {
            announce("‚ö´ YOUR WEAPONS HAVE NO EFFECT ‚ö´");
        }, 3000);
        
        setTimeout(() => {
            announce("üåå THE VOID CONSUMES ALL üåå");
        }, 6000);
    }
    
    function initTemporalDeath() {
        console.log("üíÄ TEMPORAL DEATH: CONSUMED BY THE VOID");
        
        // Player dies automatically
        store.player.hp = 0;
        store.boss = null;
        
        // Show narrative text
        setTimeout(() => {
            announce("üí≠ THIS FUTURE... MUST BE PREVENTED... üí≠");
        }, 1000);
    }
    
    function returnFromTemporalWarp() {
        console.log("‚ú® RETURNING FROM TEMPORAL WARP - REALITY RESTORED");
        
        // Restore original stats
        const orig = store.world.temporalOriginalStats;
        store.world.wave = orig.wave;
        store.player.hp = orig.hp;
        store.player.hpMax = orig.hpMax;
        store.player.shield = orig.shield;
        store.player.shieldMax = orig.shieldMax;
        store.player.dmgMult = orig.dmgMult;
        store.player.speed = orig.speed;
        store.player.multishot = orig.multishot;
        
        // Give temporal rewards
        const bonusXP = 500;
        const bonusgold = 50;
        
        store.world.xp += bonusXP;
        store.world.gold += bonusgold;
        
        // Reset temporal state
        store.world.isTemporalWarp = false;
        store.world.temporalWarpPhase = null;
        store.world.temporalWarpTimer = 0;
        store.world.temporalQuestUnlocked = true;
        
        // ‚ó¢‚ó£ CRITICAL: Clear all invincibility and temporal effects ‚ó£‚ó¢
        store.player.isInvincible = false;
        store.player.temporalSpeedBoost = 1; // Reset bullet speed
        
        // Clear temporal enemies and restart normal wave
        store.enemies = [];
        store.eBullets = [];
        store.boss = null;
        
        // Show reward animation and narrative
        showTemporalRewards(bonusXP, bonusgold);
        
        // Resume normal gameplay
        initWave();
        
        announce("‚ö° TIMELINE RESTORED - NEW QUEST UNLOCKED ‚ö°");
        setTimeout(() => {
            announce("üéØ OBJECTIVE: PREVENT THE DARK TIMELINE");
        }, 3000);
    }
    
    function showTemporalRewards(xp, gold) {
        console.log(`üéÅ TEMPORAL REWARDS: +${xp} XP, +${gold} gold`);
        
        // Create animated reward display
        const rewardDisplay = document.createElement('div');
        rewardDisplay.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(32,32,64,0.9));
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            font-family: monospace;
            color: white;
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
            animation: temporalRewardPulse 0.5s ease-out;
        `;
        
        // Add CSS animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes temporalRewardPulse {
                0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
                50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            }
            @keyframes temporalCountUp {
                0% { opacity: 0; transform: translateY(10px); }
                100% { opacity: 1; transform: translateY(0); }
            }
        `;
        document.head.appendChild(style);
        
        rewardDisplay.innerHTML = `
            <div style="font-size: 18px; margin-bottom: 10px; color: #ffd700;">
                ÔøΩ TEMPORAL KNOWLEDGE ACQUIRED üåå
            </div>
            <div style="font-size: 24px; margin: 15px 0;">
                <span style="color: #66ff66; text-shadow: 0 0 10px #66ff66;">+${xp}</span>
                <span style="color: #66ff66; margin: 0 10px;">XP</span>
            </div>
            <div style="font-size: 24px; margin: 15px 0;">
                <span style="color: #ffd700; text-shadow: 0 0 10px #ffd700;">+${gold}</span>
                <span style="color: #ffd700; margin: 0 10px;">gold</span>
            </div>
            <div style="font-size: 12px; color: #cccccc; margin-top: 15px;">
                ‚öõÔ∏è Future timeline knowledge preserved ‚öõÔ∏è
            </div>
        `;
        
        document.body.appendChild(rewardDisplay);
        
        // Add counting animation effect
        setTimeout(() => {
            const numbers = rewardDisplay.querySelectorAll('span[style*="text-shadow"]');
            numbers.forEach(num => {
                num.style.animation = 'temporalCountUp 0.8s ease-out';
            });
        }, 200);
        
        // Auto-remove after 4 seconds
        setTimeout(() => {
            rewardDisplay.style.animation = 'temporalRewardPulse 0.3s ease-in reverse';
            setTimeout(() => {
                if (rewardDisplay.parentNode) {
                    document.body.removeChild(rewardDisplay);
                }
                if (style.parentNode) {
                    document.head.removeChild(style);
                }
            }, 300);
        }, 4000);
        
        announce(`üéÅ TEMPORAL KNOWLEDGE GAINED: +${xp} XP ‚Ä¢ +${gold} gold`);
    }
    
    function spawnBlinkFlash(x, y, life=200){ blinkFlashes.push({x, y, life, birth: performance.now(), dead:false}); }
    function spawnRift(x1,y1,x2,y2, life=VOIDSTEP.riftMs){
        rifts.push({ x1,y1,x2,y2, birth: performance.now(), life, dead:false });
    }

function clampToField(nx, ny){
    const pad = VOIDSTEP.edgePadding;
    nx = Math.max(pad, Math.min(W - pad, nx));
    ny = Math.max(pad, Math.min(H - pad, ny));
    return { nx, ny };
}

function tryVoidStep(player, target, now = performance.now()){
    const cd = VOIDSTEP.cooldownMs;
    if (now - lastVoidStep < cd) return false;

    const start = { x: player.x, y: player.y };
    let { nx, ny } = clampToField(target.x, target.y);

    if (player.blinkDamage) {
        const dx = nx - start.x;
        const dy = ny - start.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        let damage = 150 * player.dmgMult;
        
        // Enhanced damage for phasestriker mastery
        if (player.blinkDamageEnhanced) {
            damage = 200 * player.dmgMult;
        }
        
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dot = (((e.x - start.x) * dx) + ((e.y - start.y) * dy)) / (dist * dist);
            const closestX = start.x + dot * dx;
            const closestY = start.y + dot * dy;
            
            const onSegment = dot > 0 && dot < 1;
            if (onSegment) {
                 const distToLine = Math.sqrt((e.x - closestX)**2 + (e.y - closestY)**2);
                 if (distToLine < e.r + 10) {
                     e.hp -= damage;
                     store.world.totalDamage += damage;
                     
                     // Apply vampirism healing for void step damage
                     if (store.player.vampirism > 0) {
                         let healAmount = damage * store.player.vampirism;
                         healAmount = Math.max(healAmount, 1); // Minimum 1 HP
                         healAmount = Math.min(healAmount, 6); // Cap at 6 HP
                         store.player.hp = Math.min(store.player.hpMax, store.player.hp + healAmount);
                     }
                 }
            }
        });
    }

    spawnRift(start.x, start.y, nx, ny, VOIDSTEP.riftMs);

    player.x = nx; player.y = ny;
    invulUntil = now + VOIDSTEP.iframeMs;
    lastVoidStep = now;

    // Phasestriker mastery: Time ripple explosion at destination
    if (player.blinkDamageEnhanced) {
        // Create time ripple explosion effect
        store.activeEffects.push(createEffect("timeRippleExplosion", nx, ny));
        
        // Damage enemies in explosion radius
        const explosionRadius = 80;
        const explosionDamage = 120 * player.dmgMult;
        const targets = store.boss ? [store.boss, ...store.enemies] : store.enemies;
        targets.forEach(e => {
            if (e.dead) return;
            const distSq = (e.x - nx)**2 + (e.y - ny)**2;
            if (distSq < explosionRadius**2) {
                e.hp -= explosionDamage;
                store.world.totalDamage += explosionDamage;
            }
        });
    }

    // Impact shockwave for earthquake enhancement
    if (player.hasImpactPhase) {
        createImpactShockwave(nx, ny, player.dmgMult);
    }

    spawnBlinkFlash(nx, ny);
    return true;
}
    
    // Impact shockwave system for earthquake enhancement
    const impactRipples = [];
    
    function createImpactShockwave(x, y, dmgMult) {
        const shockDamage = 200 * dmgMult;  // High impact damage
        const maxRadius = 120;  // Large earthquake radius
        
        // Create expanding ripple effect
        impactRipples.push({
            x: x, y: y,
            radius: 0,
            maxRadius: maxRadius,
            life: 0.8,
            maxLife: 0.8,
            birth: performance.now(),
            dead: false
        });
        
        // Damage all enemies in impact radius
        store.enemies.forEach(e => {
            if (e.dead) return;
            const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3; // 30% falloff at edge
                const actualDamage = shockDamage * damageFalloff;
                e.hp -= actualDamage;
                store.world.totalDamage += actualDamage;
                
                // Knockback effect
                if (dist > 0) {
                    const knockbackForce = 200;
                    const knockbackX = (e.x - x) / dist * knockbackForce;
                    const knockbackY = (e.y - y) / dist * knockbackForce;
                    e.knockback = { x: knockbackX, y: knockbackY, duration: 0.3, timer: 0.3 };
                }
            }
        });
        
        // Damage boss if in range
        if (store.boss && !store.boss.dead) {
            const dist = Math.sqrt((store.boss.x - x)**2 + (store.boss.y - y)**2);
            if (dist <= maxRadius) {
                const damageFalloff = 1.0 - (dist / maxRadius) * 0.3;
                const bossDamage = shockDamage * damageFalloff * 0.4;
                store.boss.hp -= bossDamage; // Reduced boss damage
                store.world.totalDamage += bossDamage;
                console.log(`üí• Boss Hit (Shockwave): ${bossDamage.toFixed(1)} damage | HP: ${store.boss.hp.toFixed(1)}/${store.boss.hpMax}`);
            }
        }
        
        playSound('thunder'); // Play earthquake sound
    }
    
    function updateImpactSystem() {
        const now = performance.now();
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const age = (now - ripple.birth) / 1000; // Convert to seconds
            ripple.radius = (age / ripple.maxLife) * ripple.maxRadius;
            
            if (age >= ripple.maxLife) {
                ripple.dead = true;
            }
        }
        
        // Remove dead ripples
        for (let i = impactRipples.length - 1; i >= 0; i--) {
            if (impactRipples[i].dead) {
                impactRipples.splice(i, 1);
            }
        }
    }
    
    function renderImpactSystem(ctx) {
        for (const ripple of impactRipples) {
            if (ripple.dead) continue;
            
            const now = performance.now();
            const age = (now - ripple.birth) / 1000;
            const progress = age / ripple.maxLife;
            const alpha = 1.0 - progress; // Fade out over time
            
            ctx.save();
            ctx.globalAlpha = alpha * 0.6;
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;  // Yellow earthquake ripples
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner ripple for more impact
            if (progress < 0.7) {
                ctx.globalAlpha = alpha * 0.4;
                ctx.strokeStyle = `rgba(255, 200, 0, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ripple.x, ripple.y, ripple.radius * 0.6, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    
    function updateVoidStepSystems(enemies){
        for (const r of rifts) if (!r.dead) {
        if(performance.now() - r.birth >= r.life) r.dead = true;
        }
        for (const f of blinkFlashes) if (!f.dead) {
        if(performance.now() - f.birth >= f.life) f.dead = true;
        }
        for (let i=rifts.length-1; i>=0; i--) if (rifts[i].dead) rifts.splice(i,1);
        for (let i=blinkFlashes.length-1; i>=0; i--) if (blinkFlashes[i].dead) blinkFlashes.splice(i,1);
    }

    function renderVoidStepSystems(ctx){
        rifts.forEach(r => {
            const t = (performance.now() - r.birth)/r.life;
            if (t>=1) { r.dead = true; return; }
            const a = (1 - t) * 0.8 + 0.2;
            ctx.save();
            ctx.globalAlpha = a;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 10 * (1-t);
            ctx.shadowColor = "#b266ff"; ctx.shadowBlur = 25 * (1-t);
            ctx.beginPath(); ctx.moveTo(r.x1, r.y1); ctx.lineTo(r.x2, r.y2); ctx.stroke();
            ctx.restore();
        });
        blinkFlashes.forEach(f => {
            const t = (performance.now() - f.birth)/f.life;
            if (t>=1) { f.dead = true; return; }
            ctx.save();
            ctx.globalAlpha = 1 - t;
            ctx.strokeStyle = "#ff99cc";
            ctx.lineWidth = 4 * (1 - t);
            ctx.shadowColor="#b266ff"; ctx.shadowBlur=20;
            ctx.beginPath();
            ctx.arc(f.x, f.y, 20 + 30 * t, 0, Math.PI*2);
            ctx.stroke();

            ctx.globalAlpha = 1 - t*t;
            ctx.beginPath(); ctx.arc(f.x, f.y, 20 * (1-t), 0, Math.PI*2);
            ctx.fillStyle="#ffddff"; ctx.fill();
            ctx.restore();
        });
    }
    
    function playerIsInvulnerable(){ return performance.now() < invulUntil; }
    
    function screenFlash(count, duration, color) {
        for (let i = 0; i < count; i++) {
            setTimeout(() => {
                store.activeEffects.push(createEffect("screenFlash", 0, duration, color));
            }, i * (duration / 2));
        }
    }

    // --- PAUSE & MENU LOGIC ---
    const PANELS = ['namePanel', 'pilotPanel', 'scorePanel', 'levelPanel', 'shopPanel', 'storyPanel', 'subclassPanel', 'teleportTutorialPanel'];
    function isAnyPanelOpen() {
        return PANELS.some(id => !q(id).classList.contains('hide'));
    }
    
    function pauseGame() {
        if (!store.isPaused) {
            store.isPaused = true;
            q('pauseBtn').classList.add('hide');
            // Start matrix effects for any visible panels
            startMatrixForVisiblePanels();
        }
    }

    function resumeGame() {
        if (!isAnyPanelOpen()) {
            store.isPaused = false;
            q('pauseBtn').classList.remove('hide');
            q('pauseBtn').textContent = 'PAUSE';
            // Stop all matrix effects when gameplay resumes
            stopAllMatrixEffects();
        }
    }
    
    // Stop all matrix effects
    function stopAllMatrixEffects() {
        document.querySelectorAll('.matrix-container').forEach(container => {
            if (container.matrix) {
                container.matrix.pause();
            }
        });
    }
    
    // Start matrix effects for visible panels
    function startMatrixForVisiblePanels() {
        PANELS.forEach(panelId => {
            const panel = q(panelId);
            if (!panel.classList.contains('hide')) {
                startMatrixForPanel(panel);
            }
        });
    }
    
    // Helper function to start matrix effects for panels
    function startMatrixForPanel(panel) {
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer && matrixContainer.matrix) {
            matrixContainer.matrix.init();
            matrixContainer.matrix.resume();
        }
    }
    
    // Helper function to stop matrix effects for panels  
    function stopMatrixForPanel(panel) {
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer && matrixContainer.matrix) {
            matrixContainer.matrix.pause();
        }
    }
    
    // --- EVENT LISTENERS & INITIALIZATION ---
    function showPilotSelect() {
        playSound('epicHorn');
        pauseGame();
        const panel = q('pilotPanel');
        
        // Start matrix effect
        startMatrixForPanel(panel);
        
        panel.classList.remove('hide');
        const cards = panel.querySelectorAll('.skill-card');
        
        const clickHandler = (e) => {
            const card = e.currentTarget;
            const genome = card.dataset.genome;
            store.player.pilotGenome = genome;
            panel.classList.add('hide');
            applyGenomeBonus(genome);
            
            // Update mobile controls ability button icon
            updateAbilityButtonIcon();
            
            // Resume game for all genomes (removed teleport tutorial popup)
            // ‚ó¢‚ó£ ACTIVATE ENTROPY REDUCTION ENGINE FOR ALL PILOTS ‚ó£‚ó¢ [DISABLED FOR STABILITY]
            // activateEntropyEngine(); // Now works for voidmancer, beef, and rocketman
            
            resumeGame();
            cards.forEach(c => c.removeEventListener('click', clickHandler));
        };
        
        cards.forEach(card => {
            card.addEventListener('click', clickHandler);
        });
    }

    function showTeleportTutorial() {
        const panel = q('teleportTutorialPanel');
        
        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }
        
        panel.classList.remove('hide');
        
        // Set up close button handler
        const closeBtn = q('closeTeleportTutorial');
        const closeHandler = () => {
            panel.classList.add('hide');
            closeBtn.removeEventListener('click', closeHandler);
            resumeGame();
        };
        
        closeBtn.addEventListener('click', closeHandler);
    }

    // --- GIBBING EFFECT ---

    // Initialize the gibs array in your game's store
    store.gibs = [];

    /**
     * Spawns a cluster of gib particles at a specific location.
     * Call this function when an enemy dies.
     * @param {number} x - The x-coordinate of the enemy.
     * @param {number} y - The y-coordinate of the enemy.
     * @param {string} color - The base color of the enemy.
     * @param {number} [amount=15] - The number of gibs to create.
     */
    function spawnGibs(x, y, color, amount = 15) {
        for (let i = 0; i < amount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 50 + Math.random() * 150;
            const size = 2 + Math.random() * 4;
            const life = 0.5 + Math.random() * 0.5;

            store.gibs.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                r: size,
                life,
                maxLife: life,
                color,
                gravity: 300, // Pulls gibs downward
            });
        }
    }

    /**
     * Updates the position and lifetime of all active gibs.
     * This should be called once per frame from your main game loop.
     * @param {number} dt - Delta time, the time since the last frame.
     */
    function updateGibs(dt) {
        for (let i = store.gibs.length - 1; i >= 0; i--) {
            const gib = store.gibs[i];
            
            // Apply physics
            gib.vy += gib.gravity * dt;
            gib.x += gib.vx * dt;
            gib.y += gib.vy * dt;
            gib.life -= dt;

            // Remove gibs that have expired
            if (gib.life <= 0) {
                store.gibs.splice(i, 1);
            }
        }
    }

    /**
     * Draws all active gibs to the canvas.
     * This is called from the main render() function.
     * @param {object} ctx - The 2D rendering context of the canvas.
     */
    function drawGibs(ctx) {
        store.gibs.forEach(gib => {
            const alpha = gib.life / gib.maxLife; // Fade out effect
            
            ctx.save();
            ctx.globalAlpha = Math.max(0, alpha);
            ctx.fillStyle = gib.color;
            ctx.beginPath();
            ctx.fillRect(gib.x - gib.r / 2, gib.y - gib.r / 2, gib.r, gib.r);
            ctx.restore();
        });
    }

    function applyGenomeBonus(genome) {
        if (!genome) return;

        // Reset all potential subclass stats to their defaults
        const p = store.player;
        p.subclass = null;
        p.beefMaxCharges = 1;
        p.missilePierce = 0;
        p.missileCluster = false;
        p.blinkDamage = false;
        p.hasChainLightning = false;
        p.stormstrikerLevel = 0;
        p.lightningAlternate = false;
        p.lightningCycleIndex = 0;
        p.chainLightningDamage = 1.0;
        p.phasestRikerLevel = 0;
        p.voidLaserRampTime = 0;
        p.voidLaserLastTarget = null;
        p.hasVoidLaser = false;
        p.voidLaserTarget = null;
        p.voidLaserDamageTimer = 0;
        p.voidLaserRetargetTimer = 0;
        console.log('GENOME RESET: Reset blinkDamage=false, hasChainLightning=false, hasVoidLaser=false');

        store.world.bossesAtPilotSelection = store.world.bosses;
        
        switch(genome) {
            case 'beef':
                // Base beef no longer gets abilities by default - subclasses must unlock them via skill trees
                break;
            case 'voidmancer':
                // Give +2 multishot base and mild speed boost for base voidmancer
                p.multishot = (p.multishot || 2) + 2; // Base 2 + 2 = 4 bullets total
                p.speed = (p.speed || 2.5) * 1.05; // 5% speed boost
                console.log(`Base voidmancer genome applied - multishot: ${p.multishot}, speed: ${p.speed}`);
                break;
            case 'rocketman':
                // Give basic missile launcher ability - required for missiles to work
                p.hasLauncher = true;
                console.log('Base rocketman genome applied - hasLauncher: true');
                break;
        }
    }
    
    // 4-Node Skill Tree Data Structure + Separate Class Ability - Single focused path per subclass
    const SKILL_TREE_DATA = {
        // Each subclass gets a focused 4-node skill tree + separate class ability (available immediately)
        marauder: {
            title: 'MARAUDER MASTERY TREE',
            path: {
                name: 'MARAUDER PATH',
                nodes: [
                    { id: 'marauder_multi_charge', name: 'Multi Charge', desc: 'Gain 3 charge attacks with enhanced chain capability', icon: 'mar11.png', tier: 1 },
                    { id: 'marauder_chain_assault', name: 'Chain Assault', desc: '+50% chain damage bonus and improved chain targeting', icon: 'mar2.png', tier: 2 },
                    { id: 'marauder_combat_mastery', name: 'Combat Mastery', desc: '+25 HP, 15% damage reduction, enhanced armor', icon: 'mar3.png', tier: 3 },
                    { id: 'marauder_elite_warrior', name: 'Elite Warrior', desc: '5 total charges with elite combat techniques', icon: 'mar4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' }
        },
        juggernaut: {
            title: 'JUGGERNAUT MASTERY TREE',
            path: {
                name: 'CHARGE PATH',
                nodes: [
                    { id: 'juggernaut_charge_power', name: 'Charge Power', desc: '+100% charge damage and knockback, +50% charge range', icon: 'jug1.png', tier: 1 },
                    { id: 'juggernaut_charge_mastery', name: 'Charge Mastery', desc: 'Charge creates damaging shockwave, +2 charge capacity', icon: 'jug22.png', tier: 2 },
                    { id: 'juggernaut_heavy_armor', name: 'Heavy Armor', desc: '+50 HP, 25% damage reduction, knockback immunity', icon: 'jug33.png', tier: 3 },
                    { id: 'juggernaut_unstoppable', name: 'Unstoppable Force', desc: '2.5x explosion radius, 3x damage - devastating impact', icon: 'jug4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'beef_shield_unlock', name: 'BEEF SHIELD', desc: 'UNLOCK: Regenerating armor plating with damage absorption', icon: 'bshield.png', tier: 'class' }
        },
        railgunner: {
            title: 'RAILGUNNER MASTERY TREE',
            path: {
                name: 'RAILGUN PATH',
                nodes: [
                    { id: 'railgunner_super_pierce', name: 'Super Pierce', desc: 'Missiles pierce 5 enemies with +30% pierce damage', icon: 'one.png', tier: 1 },
                    { id: 'railgunner_perfect_aim', name: 'Perfect Aim', desc: '+25% critical hit chance with +50% accuracy', icon: 'two.png', tier: 2 },
                    { id: 'railgunner_advanced_ballistics', name: 'Advanced Ballistics', desc: 'Pierce 8 enemies with +80% velocity and homing', icon: 'three.png', tier: 3 },
                    { id: 'railgunner_precision_master', name: 'Precision Master', desc: 'Pierce 12 enemies with +100% critical damage', icon: 'four.png', tier: 4 }
                ]
            },
            classAbility: { id: 'firewall_unlock', name: 'FIREWALL', desc: 'UNLOCK: Deployable burning barrier for area control', icon: 'firewall.png', tier: 'class' }
        },
        demolitionist: {
            title: 'DEMOLITIONIST MASTERY TREE',
            path: {
                name: 'CLUSTER PATH',
                nodes: [
                    { id: 'demolitionist_bigger_clusters', name: 'Bigger Clusters', desc: 'Cluster bombs are 2x larger with increased blast radius', icon: 'demo1.png', tier: 1 },
                    { id: 'demolitionist_cluster_mastery', name: 'Cluster Mastery', desc: 'Clusters split into secondary explosions, +50% cluster count', icon: 'demo2.png', tier: 2 },
                    { id: 'demolitionist_explosive_mastery', name: 'Explosive Mastery', desc: 'Advanced explosive techniques and enhanced detonation power', icon: 'demo3.png', tier: 3 },
                    { id: 'demolitionist_demolition_expert', name: 'Demolition Expert', desc: 'Peak explosive specialist with maximum destructive force', icon: 'demo4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'firewall_unlock', name: 'FIREWALL', desc: 'UNLOCK: Deployable burning barrier for area control', icon: 'firewall.png', tier: 'class' }
        },
        phasestriker: {
            title: 'PHASESTRIKER MASTERY TREE',
            path: {
                name: 'LASER PATH',
                nodes: [
                    { id: 'phasestriker_unlimited_range', name: 'Unlimited Range', desc: 'Void laser can target enemies anywhere on screen - no range limitations', icon: 'phase1.png', tier: 1 },
                    { id: 'phasestriker_ramping_power', name: 'Ramping Power', desc: 'Laser increases in size and damage each millisecond on the same target', icon: 'phase2.png', tier: 2 },
                    { id: 'phasestriker_dimensional_control', name: 'Dimensional Control', desc: 'Void laser phases through reality with 2.5x damage', icon: 'phase3.png', tier: 3 },
                    { id: 'phasestriker_void_lord', name: 'Void Lord', desc: '3x laser ramp multiplier - ultimate void energy mastery', icon: 'phase4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' }
        },
        stormcaller: {
            title: 'STORMCALLER MASTERY TREE',
            path: {
                name: 'LIGHTNING PATH',
                nodes: [
                    { id: 'stormcaller_chain_boost', name: 'Twin Lightning', desc: 'Alternating left/right wing lightning at double fire rate', icon: 'storm1.png', tier: 1 },
                    { id: 'stormcaller_storm_mastery', name: 'Storm Mastery', desc: '+50% jump range and +80% chain lightning damage', icon: 'storm2.png', tier: 2 },
                    { id: 'stormcaller_thunder_lord', name: 'Thunder Lord', desc: '4-position rotating lightning sequence at quadruple fire rate', icon: 'storm3.png', tier: 3 },
                    { id: 'stormcaller_storm_god', name: 'Storm God', desc: '3x lightning damage multiplier - omnipotent electrical dominance', icon: 'storm4.png', tier: 4 }
                ]
            },
            classAbility: { id: 'blink_unlock', name: 'BLINK', desc: 'UNLOCK: Teleportation ability with tactical positioning', icon: 'blink.png', tier: 'class' }
        }
    };

    const SUBCLASSES = {
        rocketman: [
            { id: 'railgunner', name: 'Railgunner', desc: 'Missiles pierce through multiple enemies with devastating precision.', icon: 'rail.png' },
            { id: 'demolitionist', name: 'Demolitionist', desc: 'Missiles explode into deadly cluster bombs on impact.', icon: 'demo.png' }
        ],
        beef: [
            { id: 'juggernaut', name: 'juggernaut', desc: 'Charge ability creates a damaging explosion on impact.', icon: 'jug2.png' },
            { id: 'marauder', name: 'Marauder', desc: 'Gain a second charge for your special ability.', icon: 'marauder.png' }
        ],
        voidmancer: [
            { id: 'phasestriker', name: 'Phase Striker', desc: 'Basic short-range void laser that can be upgraded for unlimited range and power.', icon: 'phase.png' },
            { id: 'stormcaller', name: 'Stormcaller', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
        ]
    };

    function showSubclassSelect() {
        pauseGame();
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const skillTree = q('skillTree');
        const genome = store.player.pilotGenome;

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        // Show traditional card selection for all pilots (including beef)
        const choices = SUBCLASSES[genome];
        if (!choices) {
            resumeGame();
            return;
        }
        
        skillTree.classList.add('hide');
        grid.classList.remove('hide');
        panel.classList.remove('skill-tree-active'); // Ensure normal panel size for subclass selection
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-subclass="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const subclassId = card.dataset.subclass;
                store.player.subclass = subclassId;
                applySubclassBonus(subclassId);
                
                // Update mobile controls ability button icon
                updateAbilityButtonIcon();
                
                panel.classList.add('hide');
                resumeGame();
            }, { once: true });
        });

        panel.querySelector('h2').style.display = 'block'; // Show h2 for subclass selection
        panel.classList.remove('hide');
    }

    function showProgressiveSkillTree() {
        // Progressive skill tree access based on player state
        if (!store.player.pilotGenome || store.player.pilotGenome === 'pending') {
            // Show class selection
            showPilotSelect();
            return;
        }
        
        if (!store.player.subclass) {
            // Show subclass selection
            showSubclassSelect();
            return;
        }
        
        // Show actual skill tree
        showSkillTreeModal();
    }

    function showSkillTreeModal() {
        // Check if player has selected a pilot genome first
        if (!store.player.pilotGenome || store.player.pilotGenome === 'pending') {
            console.log('No pilot genome selected - cannot view skill tree');
            return;
        }

        playSound('epicHorn');
        pauseGame();
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const skillTree = q('skillTree');

        // Check if skill tree is fully capped before showing
        if (isSkillTreeFullyCapped()) {
            console.log('Skill tree is fully capped - not showing modal');
            resumeGame();
            return;
        }

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        // Hide grid, show skill tree
        grid.classList.add('hide');
        skillTree.classList.remove('hide');
        panel.classList.add('skill-tree-active'); // Expand panel for skill tree
        panel.classList.remove('hide');

        // Hide the h2 since skill tree has its own title
        panel.querySelector('h2').style.display = 'none';

        // Generate dynamic skill tree based on pilot type
        generateDynamicSkillTree();
        
        // Set up close button handlers AFTER generating the tree
        const closeBtn = q('skillTreeCloseBtn');
        const closeBottomBtn = q('skillTreeCloseBottomBtn');
        if (closeBtn) {
            closeBtn.onclick = () => {
                closeSkillTree();
            };
        }
        if (closeBottomBtn) {
            closeBottomBtn.onclick = () => {
                closeSkillTree();
            };
        }
        
        // Update UI to reflect learned skills
        updateSkillTreeUI();
        
        // Set up click handlers for skill buttons
        setupSkillTreeHandlers();
        
        // If no skill points are available or 4 skill points have been spent, or skill tree is fully capped, don't show the tree
        const skillPointsSpent = store.player.skillPointsSpent || 0;
        const isTreeCapped = isSkillTreeFullyCapped();
        const hasReachedSkillLimit = skillPointsSpent >= 4;
        const hasNoSkillPoints = store.player.skillPoints <= 0;
        
        if (hasNoSkillPoints || hasReachedSkillLimit || isTreeCapped) {
            console.log(`Not showing skill tree - ${hasNoSkillPoints ? 'no skill points available' : hasReachedSkillLimit ? '4 skill points spent' : 'tree fully capped'} (${skillPointsSpent}/4 points spent)`);
            panel.classList.add('hide');
            resumeGame();
            return;
        }
        
        // Mobile timeout: auto-close skill tree after 5 seconds on mobile (helps with scrolling issues)
        if (isMobileDevice()) {
            console.log('Mobile device detected - setting 5 second auto-close timer for skill tree');
            setTimeout(() => {
                // Only close if the skill tree is still open
                if (!panel.classList.contains('hide') && panel.classList.contains('skill-tree-active')) {
                    console.log('Auto-closing skill tree on mobile after 5 seconds to prevent scroll lock');
                    closeSkillTree();
                }
            }, 5000);
        }
    }

    function viewCurrentSkillTree() {
        // Check if player has selected a subclass
        if (!store.player.subclass) {
            console.log('No subclass selected - cannot view skill tree');
            return;
        }

        // Close shop panel first
        const shopPanel = q("shopPanel");
        shopPanel.classList.add('hide');

        // Show the skill tree modal
        const panel = q('subclassPanel');
        const grid = q('subclassGrid');
        const skillTree = q('skillTree');

        // Initialize matrix
        const matrixContainer = panel.querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }

        // Hide grid, show skill tree
        grid.classList.add('hide');
        skillTree.classList.remove('hide');
        panel.classList.add('skill-tree-active'); // Expand panel for skill tree
        panel.classList.remove('hide');

        // Hide the h2 since skill tree has its own title
        panel.querySelector('h2').style.display = 'none';

        // Generate dynamic skill tree based on current pilot type
        generateDynamicSkillTree();
        
        // Set up close button handlers AFTER generating the tree
        const closeBtn = q('skillTreeCloseBtn');
        const closeBottomBtn = q('skillTreeCloseBottomBtn');
        if (closeBtn) {
            closeBtn.onclick = () => {
                closeSkillTree();
            };
        }
        if (closeBottomBtn) {
            closeBottomBtn.onclick = () => {
                closeSkillTree();
            };
        }

        // Update UI to reflect current skills (no awarding points)
        updateSkillTreeUI();
        
        // Don't set up click handlers for skill buttons since this is view-only
        // setupSkillTreeHandlers();

        // Don't award skill points or play sound for viewing - just show the tree
    }



    function generateDynamicSkillTree() {
        const skillTreeElement = q('skillTree');
        const genome = store.player.pilotGenome;
        
        // Map pilot genome to default subclass for skill tree display
        let subclass = store.player.subclass;
        if (!subclass) {
            // Default subclass based on genome if none selected
            switch (genome) {
                case 'rocketman': subclass = 'railgunner'; break;
                case 'beef': subclass = 'marauder'; break;
                case 'voidmancer': subclass = 'phasestriker'; break;
                default: 
                    console.error('Unknown pilot genome:', genome);
                    return;
            }
        }
        
        // Get the skill tree data for the current subclass
        const treeData = SKILL_TREE_DATA[subclass];
        if (!treeData) {
            console.error('No skill tree data found for subclass:', subclass);
            console.log('Available subclasses:', Object.keys(SKILL_TREE_DATA));
            return;
        }
        
        // Generate the 5-node single path skill tree HTML
        const path = treeData.path;
        const classAbility = treeData.classAbility;
        
        skillTreeElement.innerHTML = `
            <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
            <div class="skill-tree-title">${treeData.title}</div>
            <div class="skill-grid">
                <div class="skill-row">
                    <!-- Main progression path with 4 nodes -->
                    <div class="skill-track">
                        <div class="track-title">${path.name}</div>
                        <!-- Tier 1 -->
                        <div class="skill-icon-button available" data-skill="${path.nodes[0].id}" data-tier="1">
                            <img src="${path.nodes[0].icon}" alt="${path.nodes[0].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[0].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[0].desc}</div>
                            </div>
                        </div>
                        <!-- Tier 2 -->
                        <div class="skill-icon-button locked" data-skill="${path.nodes[1].id}" data-tier="2" data-parent="${path.nodes[0].id}">
                            <img src="${path.nodes[1].icon}" alt="${path.nodes[1].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[1].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[1].desc}</div>
                            </div>
                        </div>
                        <!-- Tier 3 -->
                        <div class="skill-icon-button locked" data-skill="${path.nodes[2].id}" data-tier="3" data-parent="${path.nodes[1].id}">
                            <img src="${path.nodes[2].icon}" alt="${path.nodes[2].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[2].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[2].desc}</div>
                            </div>
                        </div>
                        <!-- Tier 4 -->
                        <div class="skill-icon-button locked" data-skill="${path.nodes[3].id}" data-tier="4" data-parent="${path.nodes[2].id}">
                            <img src="${path.nodes[3].icon}" alt="${path.nodes[3].name}" class="skill-icon-image">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${path.nodes[3].name}</div>
                                <div class="skill-overlay-desc">${path.nodes[3].desc}</div>
                            </div>
                        </div>
                    </div>
                    <!-- Separate class ability track (always available) -->
                    <div class="skill-track class-ability-track">
                        <div class="track-title" style="color: #FFD700;">SIGNATURE ABILITY</div>
                        <div class="skill-icon-button available class-ability-solo" data-skill="${classAbility.id}" data-tier="class">
                            <img src="${classAbility.icon}" alt="${classAbility.name}" class="skill-icon-image class-ability">
                            <div class="skill-info-overlay">
                                <div class="skill-overlay-title">${classAbility.name}</div>
                                <div class="skill-overlay-desc">${classAbility.desc}</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="skill-description" id="skillDescription">
                Master your ${subclass} specialization through focused training. Your signature ability is available immediately!
            </div>
            <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        
        // Initialize skill tree progression
        initializeSkillTree();
    }
    
    // Old skill tree code - now commented out as we use dynamic trees
    /*
    function generateOldSkillTree() {
        // Old static skill trees removed - now using SKILL_TREE_DATA structure
    }
            // Create voidmancer skill tree
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">VOIDMANCER SPECIALIZATION TREE</div>
                <div class="skill-grid">
                    <div class="skill-row">
                        <div class="skill-track">
                            <div class="track-title">PHASE STRIKER</div>
                            <div class="skill-icon-button available" data-skill="phasestriker" data-tier="1">
                                <img src="phase.png" alt="Phase Striker" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">PHASE STRIKER</div>
                                    <div class="skill-overlay-desc">Void manipulation specialist with damaging blink teleportation</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="phasestriker_enhanced" data-tier="2" data-parent="phasestriker">
                                <img src="phase.png" alt="Ramping Laser" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">RAMPING LASER</div>
                                    <div class="skill-overlay-desc">MASTERY: Laser grows in size and damage while fixated on the same target</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">STORMCALLER</div>
                            <div class="skill-icon-button available" data-skill="stormcaller" data-tier="1">
                                <img src="storm.png" alt="Stormcaller" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">STORMCALLER</div>
                                    <div class="skill-overlay-desc">Lightning manipulation specialist with chain lightning weaponry</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="stormcaller_enhanced" data-tier="2" data-parent="stormcaller">
                                <img src="storm.png" alt="Chain Storm" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">CHAIN STORM</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced stormcaller with maximum chain lightning power</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">BLINK ABILITY</div>
                            <div class="skill-icon-button available" data-skill="blink_ability" data-tier="1">
                                <img src="blink.png" alt="Blink Ability" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">BLINK ABILITY</div>
                                    <div class="skill-overlay-desc">Mobility specialist with instant teleportation and damage</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="blink_ability_enhanced" data-tier="2" data-parent="blink_ability">
                                <img src="blink.png" alt="Void Step" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">VOID STEP</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced blink with area damage and faster cooldown</div>
                                </div>
                            </div>
                        </div>
                        <div class="skill-track">
                            <div class="track-title">VOID LASER</div>
                            <div class="skill-icon-button available" data-skill="void_laser" data-tier="1">
                                <img src="voidlaser.png" alt="Void Laser" class="skill-icon-image">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">VOID LASER</div>
                                    <div class="skill-overlay-desc">Energy weapons specialist with focused beam attacks</div>
                                </div>
                            </div>
                            <div class="skill-icon-button locked" data-skill="void_laser_enhanced" data-tier="2" data-parent="void_laser">
                                <img src="voidlaser.png" alt="Annihilation Beam" class="skill-icon-image enhanced">
                                <div class="skill-info-overlay">
                                    <div class="skill-overlay-title">ANNIHILATION BEAM</div>
                                    <div class="skill-overlay-desc">MASTERY: Enhanced void laser with ramping damage and wider beam</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="skill-description" id="skillDescription">
                    Choose your specialization path: Phase Striker for void teleportation, Stormcaller for chain lightning, Blink Ability for mobility, Void Laser for focused damage. Mix and match for powerful combos!
                </div>
                <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        } else {
            // Fallback for unknown pilot types
            skillTreeElement.innerHTML = `
                <button class="close-btn" id="skillTreeCloseBtn" type="button">‚úï</button>
                <div class="skill-tree-title">UNKNOWN PILOT TYPE</div>
                <div class="skill-description" id="skillDescription">
                    Skill tree not available for this pilot type.
                </div>
                <button class="btn" id="skillTreeCloseBottomBtn" type="button" style="margin-top: 15px;">Close</button>`;
        }
    }
    
    */
    
    function initializeSkillTree() {
        const p = store.player;
        let subclass = p.subclass;
        
        // Default subclass based on genome if none selected
        if (!subclass) {
            switch (p.pilotGenome) {
                case 'rocketman': subclass = 'railgunner'; break;
                case 'beef': subclass = 'marauder'; break;
                case 'voidmancer': subclass = 'phasestriker'; break;
                default: 
                    console.error('Unknown pilot genome:', p.pilotGenome);
                    return;
            }
        }
        
        // Initialize skill tree properties if needed
        if (!p.skillTree) {
            p.skillTree = {};
            
            // Initialize all skills as false for the current subclass
            const treeData = SKILL_TREE_DATA[subclass];
            if (treeData) {
                // Add path skills (4 nodes)
                treeData.path.nodes.forEach(node => {
                    p.skillTree[node.id] = false;
                });
                // Add class ability (5th node)
                p.skillTree[treeData.classAbility.id] = false;
            }
        }
        
        if (!p.skillTreeProgress) p.skillTreeProgress = { bossesDefeated: 0, tier1Choice: null, tier2Choice: null };
        if (!p.skillPoints) p.skillPoints = 0;
        if (!p.skillPointsSpent) p.skillPointsSpent = 0;
        
        // Don't award skill points here - they're awarded in handleBossDefeat
        // Just update the UI with whatever points we have
        updateSkillTreeUI();
        setupSkillTreeHandlers();
    }
    
    function updateSkillTreeUI() {
        const p = store.player;
        const panel = q('subclassPanel');
        
        // Early return if skill tree panel is not visible - major performance optimization
        if (!panel || panel.classList.contains('hide') || !panel.classList.contains('skill-tree-active')) {
            return;
        }
        
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        
        // Update button states first, regardless of whether tree will close
        iconButtons.forEach(button => {
            const skill = button.dataset.skill;
            const tier = parseInt(button.dataset.tier);
            const parent = button.dataset.parent;
            
            // Remove all state classes
            button.classList.remove('available', 'active', 'locked');
            
            if (p.skillTree && p.skillTree[skill]) {
                // Skill is learned - show active glow effect
                button.classList.add('active');
            } else if (canLearnSkill(skill, tier, parent)) {
                // Skill can be learned - show available state
                button.classList.add('available');
            } else {
                // Skill is locked - show dim state
                button.classList.add('locked');
            }
        });
        
        // Safety check: if no skill points remain and skill tree is open, close it
        if (p.skillPoints <= 0) {
            const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
            setTimeout(() => {
                closeSkillTree();
            }, delay);
            return;
        }
        
        // If tree is fully capped, also close it
        if (isSkillTreeFullyCapped()) {
            const delay = isMobileDevice() ? 5000 : 100; // 5 second delay on mobile, immediate on desktop
            setTimeout(() => {
                closeSkillTree();
            }, delay);
            return;
        }
        
        // If 4 skill points have been spent, don't auto-close (allow viewing)
        // const skillPointsSpent = p.skillPointsSpent || 0;
        // if (skillPointsSpent >= 4 && !q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
        //     setTimeout(() => {
        //         console.log(`Auto-closing skill tree from updateSkillTreeUI - 4 skill points spent (${skillPointsSpent}/4)`);
        //         closeSkillTree();
        //     }, 100);
        //     return;
        // }
    }
    
    function canLearnSkill(skill, tier, parent) {
        const p = store.player;
        
        // Can't learn a skill that's already learned
        if (p.skillTree && p.skillTree[skill]) return false;
        
        if (p.skillPoints <= 0) return false;
        
        if (tier === 1) {
            return true; // First tier is always available with skill points
        }
        
        if (tier === 'class') {
            return true; // Class abilities are always available with skill points (signature abilities)
        }
        
        // For tiers 2-4, requires the specific parent skill to be learned
        if (tier >= 2 && tier <= 4) {
            return p.skillTree && p.skillTree[parent];
        }
        
        return false;
    }
    
    function setupSkillTreeHandlers() {
        const iconButtons = document.querySelectorAll('.skill-icon-button');
        const description = q('skillDescription');
        
        // Remove any existing handlers first to prevent duplicates
        iconButtons.forEach(button => {
            button.replaceWith(button.cloneNode(true));
        });
        
        // Re-query after cloning to get fresh elements
        const freshButtons = document.querySelectorAll('.skill-icon-button');
        
        // Updated skill descriptions for icon button system
        const skillDescriptions = {
            // Beef skills
            juggernaut: "Heavy assault specialist with explosive charge impacts and superior defensive capabilities.",
            marauder: "Rapid assault specialist with multiple charge capacity for sustained offensive operations.",
            juggernaut_enhanced: "MASTERY: Enhanced juggernaut with devastating explosion radius and catastrophic damage output.", 
            marauder_enhanced: "MASTERY: Elite marauder with triple charge capacity for relentless battlefield dominance.",
            
            // Rocketman skills
            railgunner: "Precision missile specialist with devastating piercing capabilities that cut through multiple enemies.",
            demolitionist: "Explosive missile specialist with cluster bombs that devastate large areas on impact.",
            railgunner_enhanced: "MASTERY: Enhanced railgunner with maximum piercing power and superior accuracy.",
            demolitionist_enhanced: "MASTERY: Elite demolitionist with massive cluster explosions and enhanced area damage.",
            
            // Wizard skills
            phasestriker: "Long-range laser specialist with unlimited targeting range across the entire battlefield.",
            stormcaller: "Lightning manipulation specialist with chain lightning weaponry that arcs between targets.",
            phasestriker_enhanced: "MASTERY: Ramping laser that grows in size and damage the longer it focuses on the same target.",
            stormcaller_enhanced: "MASTERY: Elite stormcaller with maximum chain lightning power and enhanced conductivity."
        };
        
        // Add hover effects to icon buttons
        freshButtons.forEach(button => {
            const skill = button.dataset.skill;
            
            button.addEventListener('mouseenter', () => {
                description.textContent = skillDescriptions[skill] || "Specialization path available";
            });
            
            button.addEventListener('mouseleave', () => {
                const pilotType = store.player.pilotGenome;
                if (pilotType === 'beef') {
                    description.textContent = "Choose your specialization path: Marauder for sustained assault, Juggernaut for devastating impact. Select both for the ultimate combo!";
                } else if (pilotType === 'rocketman') {
                    description.textContent = "Choose your specialization path: Railgunner for piercing precision, Demolitionist for explosive devastation. Select both for the ultimate combo!";
                } else if (pilotType === 'voidmancer') {
                    description.textContent = "Choose your specialization path: Phase Striker for void teleportation, Stormcaller for chain lightning. Select both for the ultimate combo!";
                }
            });
        });
        
        // Click handlers - icon buttons are directly clickable
        freshButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Skill button clicked
                if (button.classList.contains('available')) {
                    const skill = button.dataset.skill;
                    // About to learn skill
                    learnSkill(skill);
                }
            });
        });
    }
    
    let isLearningSkill = false;
    
    function learnSkill(skill) {
        if (isLearningSkill) {
            // Already learning a skill, ignoring duplicate call
            return;
        }
        
        isLearningSkill = true;
        
        try {
            const p = store.player;
            const skillButton = document.querySelector(`[data-skill="${skill}"]`);
            const tier = parseInt(skillButton.dataset.tier);
            
            if (!canLearnSkill(skill, tier, skillButton.dataset.parent)) {
                isLearningSkill = false;
                return;
            }
            
            if (!p.skillTree) p.skillTree = {};
            p.skillTree[skill] = true;
            p.skillPoints--; // Spend the skill point
            p.skillPointsSpent = (p.skillPointsSpent || 0) + 1; // Track total spent
            // Apply the skill effects
            applySkillBonus(skill);
            
            // Check for combo when both base skills are learned
            // Check for combo when both base skills are learned
            const pilotType = p.pilotGenome;
            if (tier === 1) {
                if (pilotType === 'beef' && p.skillTree.marauder && p.skillTree.juggernaut) {
                    p.beefDoubleCharge = true;
                    announce('DOUBLE CHARGE COMBO ACTIVATED!');
                } else if (pilotType === 'rocketman' && p.skillTree.railgunner && p.skillTree.demolitionist) {
                    p.rocketmanHybrid = true;
                    announce('HYBRID MISSILES COMBO ACTIVATED!');
                } else if (pilotType === 'voidmancer' && p.skillTree.phasestriker && p.skillTree.stormcaller) {
                    p.voidmancerHybrid = true;
                    announce('VOID STORM COMBO ACTIVATED!');
                }
            }
            
            console.log('Updating UI...');
            updateSkillTreeUI();
            
            // Update remaining skill points display
            
            // Check if tree is now fully capped
            if (isSkillTreeFullyCapped()) {
                const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                setTimeout(() => {
                    console.log('Skill tree is now fully capped - closing tree');
                    closeSkillTree();
                }, delay);
            } else if (p.skillPoints <= 0) {
                // Close skill tree if no more points remaining
                const delay = isMobileDevice() ? 5000 : 1500; // Longer delay on mobile
                setTimeout(() => {
                    console.log('Auto-closing skill tree - no points remaining');
                    closeSkillTree();
                }, delay);
            }
            // Note: No longer auto-closing when 4 skill points are spent - allow viewing
        } catch (error) {
            console.error('Error in learnSkill:', error);
        } finally {
            isLearningSkill = false;
        }
    }
    
    function closeSkillTree() {
        const panel = q('subclassPanel');
        panel.classList.add('hide');
        panel.classList.remove('skill-tree-active');
        resumeGame();
    }
    
    function isSkillTreeFullyCapped() {
        const p = store.player;
        const subclass = p.subclass;
        
        if (!p.skillTree || !subclass) return false;
        
        // Check if the current subclass main progression path is fully capped (all 4 path nodes learned)
        // Class ability is separate and doesn't count toward "fully capped" since it's always available
        const treeData = SKILL_TREE_DATA[subclass];
        if (!treeData) return false;
        
        // Check if all 4 path nodes are learned (class ability is separate)
        const pathNodes = treeData.path.nodes.map(node => node.id);
        
        return pathNodes.every(skill => p.skillTree[skill] === true);
    }
    
    function applySkillBonus(skill) {
        const p = store.player;
        
        switch(skill) {


                
            // Tier 2 Enhanced Skills
            case 'marauder_enhanced':
                p.beefMaxCharges = 3;
                p.beefCharges = Math.max(p.beefCharges, 3);
                p.beefChainMode = true; // Enable chain jumping for enhanced marauder
                announce('TRIPLE CHAIN ACTIVATED!');
                break;
            case 'juggernaut_enhanced':
                p.beefBigExplosion = true;
                announce('BIG BANG EXPLOSION ACTIVATED!');
                break;
                

                
            // Rocketman Tier 2 Enhanced Skills
            case 'railgunner_enhanced':
                // Enhanced railgunner should preserve existing abilities
                if (!p.missilePierce) p.missilePierce = 2; // Give basic piercing if they don't have it
                p.missilePierce = Math.max(p.missilePierce, 4);
                announce('SUPER PIERCE ACTIVATED - Maximum Penetration!');
                break;
            case 'demolitionist_enhanced':
                // Enhanced demolitionist should preserve existing abilities
                if (!p.missileCluster) p.missileCluster = true; // Give basic clusters if they don't have them
                p.missileClusterEnhanced = true;
                announce('MEGA CLUSTERS ACTIVATED - Devastating Explosions!');
                break;
                
            // Voidmancer skills  



            case 'railgunner_barrier':
                p.subclass = 'railgunner';
                // Give flame barrier ability
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 8; // 8 seconds
                p.flameBarrierRecharge = 15; // 15 second cooldown
                announce('RAILGUNNER ACTIVATED - Flame Barrier Defense!');
                break;
            case 'demolitionist_barrier':
                p.subclass = 'demolitionist';
                // Give enhanced flame barrier ability
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 12; // Longer duration than railgunner
                p.flameBarrierRecharge = 10; // Faster cooldown than railgunner
                p.flameBarrierExplosive = true; // Explosive reactive damage
                announce('DEMOLITIONIST ACTIVATED - Explosive Flame Wall!');
                break;
                
            // Voidmancer Tier 2 Enhanced Skills
            case 'phasestriker_enhanced':
                p.phasestRikerLevel = 2; // Level 2: Global range + ramping damage/size
                announce('PHASESTRIKER LV2 - Ramping Laser Power!');
                break;
            case 'stormcaller_enhanced':
                p.chainLightningEnhanced = true;
                p.stormstrikerLevel = 2; // Level 2: Twin wing lightning
                announce('STORMSTRIKER LV2 - Twin Wing Lightning!');
                break;
                
            // New Beef Skills
            case 'beef_shield':
                p.beefShieldMax = 100;
                p.beefShield = 100;
                p.beefShieldRegenRate = 5; // Shield per second
                announce('BEEF SHIELD ACTIVATED - Defensive Armor Plating!');
                break;
            case 'beef_shield_enhanced':
                p.beefShieldMax = Math.max(p.beefShieldMax || 100, 200);
                p.beefShield = p.beefShieldMax;
                p.beefShieldRegenRate = 15; // Faster regeneration
                p.beefShieldReflect = true; // Reflect damage back to enemies
                announce('FORTRESS MODE ACTIVATED - Enhanced Defense and Reflection!');
                break;
            case 'beef_charge':
                p.beefChargeState = 'ready';
                p.beefChargeCooldown = 0;
                p.beefCharges = 1;
                p.beefMaxCharges = 1;
                announce('BEEF CHARGE ACTIVATED - Devastating Rush Attack!');
                break;
            case 'beef_charge_enhanced':
                p.beefChargeDamageMultiplier = 2.0; // Double charge damage
                p.beefChargeRange = 1.5; // Increased range
                announce('RAMMING SPEED ACTIVATED - Enhanced Charge Power!');
                break;
                
            // New Rocketman Skills
            case 'flame_barrier':
                p.flameBarrierActive = false;
                p.flameBarrierCooldown = 0;
                p.flameBarrierDuration = 8; // 8 seconds
                p.flameBarrierRecharge = 15; // 15 second cooldown
                announce('FLAME BARRIER ACTIVATED - Burning Protective Field!');
                break;
            case 'flame_barrier_enhanced':
                p.flameBarrierDuration = 12; // Longer duration
                p.flameBarrierRecharge = 10; // Faster cooldown
                p.flameBarrierExplosive = true; // Explosive reactive damage
                announce('INFERNO WALL ACTIVATED - Explosive Reactive Defense!');
                break;
            case 'missile_volley':
                p.missileVolley = Math.max(p.missileVolley || 2, 4);
                announce('MISSILE VOLLEY ACTIVATED - Multi-Missile Salvos!');
                break;
            case 'missile_volley_enhanced':
                p.missileVolley = Math.max(p.missileVolley || 4, 6);
                p.missileReloadBonus = 0.5; // 50% faster reload
                announce('BARRAGE MODE ACTIVATED - Maximum Firepower!');
                break;
                
            // New Voidmancer Skills  
            case 'blink_ability':
                p.blinkDamage = true;
                p.blinkCooldown = 0;
                p.blinkRecharge = 3; // 3 second cooldown
                announce('BLINK ABILITY ACTIVATED - Damaging Teleportation!');
                break;
            case 'blink_ability_enhanced':
                p.blinkDamageEnhanced = true;
                p.blinkRecharge = 2; // Faster cooldown
                p.blinkAreaDamage = true; // Area damage on teleport
                announce('VOID STEP ACTIVATED - Enhanced Teleportation Power!');
                break;
            case 'void_laser':
                p.hasVoidLaser = true;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                announce('VOID LASER ACTIVATED - Focused Beam Weapon!');
                break;
            case 'void_laser_enhanced':
                p.voidLaserEnhanced = true;
                p.voidLaserRampingDamage = 1.0; // Starts at 1x, builds up
                p.voidLaserBeamWidth = 2.0; // Wider beam
                announce('ANNIHILATION BEAM ACTIVATED - Ramping Laser Power!');
                break;
                
            // NEW 5-NODE SKILL TREE SKILLS
            // Marauder Tree Skills
            case 'marauder_multi_charge':
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3);
                p.beefCharges = Math.max(p.beefCharges, 3);
                announce('MULTI CHARGE ACTIVATED - Additional Charge Attacks!');
                break;
            case 'marauder_chain_assault':
                p.beefChainMode = true;
                p.beefChainBonus = 1.5; // 50% bonus damage on chain
                announce('CHAIN ASSAULT ACTIVATED - Chain Between Enemies!');
                break;
            case 'marauder_armor_boost':
                p.hpMax += 25;
                p.hp += 25;
                p.damageReduction = (p.damageReduction || 0) + 0.15;
                announce('BATTLE ARMOR ACTIVATED - Enhanced Durability!');
                break;
            case 'marauder_shield_mastery':
                if (p.beefShieldMax) {
                    p.beefShieldRegenRate = (p.beefShieldRegenRate || 5) * 2;
                    p.beefShieldRegenDelay = Math.max((p.beefShieldRegenDelay || 3) - 1, 1);
                }
                announce('SHIELD MASTERY ACTIVATED - Enhanced Shield Regeneration!');
                break;
                
            // Juggernaut Tree Skills
            case 'juggernaut_charge_power':
                p.beefChargeDamage = (p.beefChargeDamage || 1.0) * 2.0; // 100% more damage
                p.beefChargeKnockback = (p.beefChargeKnockback || 1.0) * 2.0; // 100% more knockback
                p.beefChargeRange = (p.beefChargeRange || 1.0) * 1.5; // 50% more range
                announce('CHARGE POWER ACTIVATED - Enhanced Charge Strength!');
                break;
            case 'juggernaut_charge_mastery':
                p.beefChargeShockwave = true; // Charge creates damaging shockwave
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 1, 3); // +2 charges
                p.beefCharges = Math.max(p.beefCharges || 0, 3);
                announce('CHARGE MASTERY ACTIVATED - Shockwave & Extra Charges!');
                break;
            case 'juggernaut_speed_boost':
                p.speedMult *= 1.4;
                p.beefChargeSpeed = (p.beefChargeSpeed || 1.0) * 1.6;
                announce('HEAVY MOMENTUM ACTIVATED - Enhanced Speed and Charge!');
                break;
            case 'juggernaut_dash_mastery':
                p.beefKnockbackResistance = true;
                p.beefChargeCooldown = Math.max((p.beefChargeCooldown || 3) - 1, 1);
                announce('UNSTOPPABLE FORCE ACTIVATED - Enhanced Mobility!');
                break;
                
            // Railgunner Tree Skills
            case 'railgunner_super_pierce':
                p.missilePierce = Math.max(p.missilePierce || 1, 5); // Enhance to 5 enemies (from basic)
                p.missilePierceDamage = (p.missilePierceDamage || 1.0) * 1.3;
                announce('SUPER PIERCE ACTIVATED - Enhanced Missile Pierce!');
                break;
            case 'railgunner_perfect_aim':
                p.missileCritChance = (p.missileCritChance || 0) + 0.25;
                p.missileAccuracy = (p.missileAccuracy || 1.0) * 1.5;
                announce('PERFECT AIM ACTIVATED - Enhanced Targeting!');
                break;
            case 'railgunner_flame_mastery':
                p.flameBarrierDamage = (p.flameBarrierDamage || 1.0) * 1.8;
                p.flameBarrierRadius = (p.flameBarrierRadius || 1.0) * 1.4;
                announce('FLAME MASTERY ACTIVATED - Enhanced Fire Power!');
                break;
            case 'railgunner_wall_control':
                p.flameBarrierCount = (p.flameBarrierCount || 1) + 1;
                p.flameBarrierDuration *= 1.5;
                announce('WALL CONTROL ACTIVATED - Advanced Flame Tactics!');
                break;
                
            // Demolitionist Tree Skills
            case 'demolitionist_bigger_clusters':
                // Make cluster bombs 2x larger with increased blast radius
                p.missileClusterSize = (p.missileClusterSize || 1.0) * 2.0;
                p.missileClusterRadius = (p.missileClusterRadius || 1.0) * 2.0;
                announce('BIGGER CLUSTERS ACTIVATED - Massive Cluster Bombs!');
                break;
            case 'demolitionist_cluster_mastery':
                // Clusters split into secondary explosions, +50% cluster count
                p.missileClusterSecondary = true;
                p.missileClusterCount = Math.max(p.missileClusterCount || 4, Math.floor((p.missileClusterCount || 4) * 1.5));
                announce('CLUSTER MASTERY ACTIVATED - Secondary Explosions!');
                break;
            case 'demolitionist_fire_boost':
                p.fireDamageBonus = (p.fireDamageBonus || 1.0) * 2.0;
                p.burnDuration = (p.burnDuration || 3) * 1.5;
                announce('INFERNO BOOST ACTIVATED - Enhanced Fire Damage!');
                break;
            case 'demolitionist_flame_master':
                p.flameBarrierExplosive = true;
                p.flameBarrierReactiveDamage = 150;
                announce('FLAME MASTER ACTIVATED - Explosive Barriers!');
                break;
                
            // Phasestriker Tree Skills
            case 'phasestriker_unlimited_range':
                // Remove range limitation from void laser
                p.voidLaserRange = 999999; // Unlimited range - can hit any enemy
                p.phasestRikerLevel = 1; // Upgrade to level 1 for unlimited range
                console.log(`Phasestriker unlimited range: level=${p.phasestRikerLevel}, range=${p.voidLaserRange}`);
                announce('UNLIMITED RANGE ACTIVATED - Global Laser Targeting!');
                break;
            case 'phasestriker_ramping_power':
                // Enable ramping damage/size effect
                p.phasestRikerLevel = Math.max(p.phasestRikerLevel, 2); // Level 2: Ramping damage/size
                announce('RAMPING POWER ACTIVATED - Growing Laser Strength!');
                break;
            case 'phasestriker_blink_boost':
                p.blinkRange = (p.blinkRange || 200) * 1.8;
                p.blinkCooldown = Math.max((p.blinkCooldown || 5) - 2, 1);
                announce('BLINK BOOST ACTIVATED - Enhanced Teleportation!');
                break;
            case 'phasestriker_phase_mastery':
                p.blinkDamage = (p.blinkDamage || 50) * 2;
                p.blinkInvulnerable = true; // Brief invulnerability during blink
                announce('PHASE MASTERY ACTIVATED - Dimensional Superiority!');
                break;
                
            // Stormcaller Tree Skills
            case 'stormcaller_chain_boost':
                // Add twin lightning bolts from wing guns
                p.stormstrikerLevel = 2; // Twin wing lightning
                announce('TWIN LIGHTNING ACTIVATED - Dual Chain Lightning!');
                break;
            case 'stormcaller_storm_mastery':
                p.chainLightningDamage = (p.chainLightningDamage || 1.0) * 1.8; // 80% damage boost
                p.chainLightningRange = (p.chainLightningRange || 150) * 1.5; // 50% jump range boost
                announce('STORM MASTERY ACTIVATED - Enhanced Range & Power!');
                break;
            case 'stormcaller_warp_boost':
                if (!p.blinkRange) p.blinkRange = 200;
                p.blinkRange *= 1.6;
                p.blinkRecharge = Math.max((p.blinkRecharge || 5) - 1.5, 1);
                announce('WARP BOOST ACTIVATED - Enhanced Teleportation!');
                break;
            case 'stormcaller_void_control':
                p.blinkTimeRipple = true;
                p.blinkRippleDamage = 100;
                announce('VOID CONTROL ACTIVATED - Time Ripple Effects!');
                break;
                
            // NEW TIER 3 & 4 SKILLS FOR SINGLE PATH PROGRESSION
            // Marauder Advanced Skills
            case 'marauder_combat_mastery':
                p.beefChainDamageBonus = (p.beefChainDamageBonus || 1.0) * 2.0;
                p.beefAttackSpeed = (p.beefAttackSpeed || 1.0) * 1.3;
                announce('COMBAT MASTERY ACTIVATED - Advanced Assault Techniques!');
                break;
            case 'marauder_elite_warrior':
                p.beefMaxCharges = Math.max(p.beefMaxCharges || 3, 5);
                p.beefCharges = Math.max(p.beefCharges, 5);
                p.beefEliteCombat = true;
                announce('ELITE WARRIOR ACTIVATED - Peak Marauder Prowess!');
                break;
                
            // Juggernaut Advanced Skills
            case 'juggernaut_heavy_armor':
                p.hpMax += 50;
                p.hp += 50;
                p.damageReduction = (p.damageReduction || 0) + 0.25;
                p.knockbackImmunity = true;
                announce('HEAVY ARMOR ACTIVATED - Superior Protection!');
                break;
            case 'juggernaut_unstoppable':
                p.beefExplosionRadius *= 2.5;
                p.beefExplosionDamage *= 3.0;
                p.beefUnstoppableForce = true;
                announce('UNSTOPPABLE FORCE ACTIVATED - Maximum Impact Power!');
                break;
                
            // Railgunner Advanced Skills
            case 'railgunner_advanced_ballistics':
                p.missilePierce = Math.max(p.missilePierce || 5, 8);
                p.missileVelocity = (p.missileVelocity || 1.0) * 1.8;
                p.missileHomingStrength = (p.missileHomingStrength || 0.5) * 1.5;
                announce('ADVANCED BALLISTICS ACTIVATED - Superior Missile Technology!');
                break;
            case 'railgunner_precision_master':
                p.missileCritChance = (p.missileCritChance || 0.25) + 0.5;
                p.missileCritDamage = (p.missileCritDamage || 2.0) * 2.0;
                p.railgunMastery = true;
                announce('PRECISION MASTER ACTIVATED - Ultimate Accuracy!');
                break;
                
            // Demolitionist Advanced Skills
            case 'demolitionist_explosive_mastery':
                p.missileClusterCount = Math.max(p.missileClusterCount || 8, 12);
                p.explosionChain = true;
                p.explosionChainCount = 3;
                announce('EXPLOSIVE MASTERY ACTIVATED - Chain Detonations!');
                break;
            case 'demolitionist_demolition_expert':
                p.missileClusterRadius *= 2.0;
                p.megaExplosionChance = 0.3; // 30% chance for mega explosions
                p.demolitionExpert = true;
                announce('DEMOLITION EXPERT ACTIVATED - Maximum Destructive Force!');
                break;
                
            // Phasestriker Advanced Skills
            case 'phasestriker_dimensional_control':
                p.voidLaserPhase = true;
                p.voidLaserPhaseDamage = 2.5;
                p.dimensionalControl = true;
                announce('DIMENSIONAL CONTROL ACTIVATED - Reality Manipulation!');
                break;
            case 'phasestriker_void_lord':
                p.voidLaserMaxRamp *= 3.0;
                p.voidMastery = true;
                p.voidLordPower = true;
                announce('VOID LORD ACTIVATED - Ultimate Phase Mastery!');
                break;
                
            // Stormcaller Advanced Skills  
            case 'stormcaller_thunder_lord':
                p.stormstrikerLevel = 3; // 4-bolt lightning storm
                p.lightningStorm = true;
                p.thunderLordPower = true;
                announce('THUNDER LORD ACTIVATED - 4-Bolt Storm!');
                break;
            case 'stormcaller_storm_god':
                p.chainLightningDamage *= 3.0;
                p.stormGodPower = true;
                p.omnipotentLightning = true;
                announce('STORM GOD ACTIVATED - Divine Electrical Mastery!');
                break;
                
            // CLASS ABILITY UNLOCKS (5th node rewards)
            case 'beef_shield_unlock':
                p.beefShieldMax = 150;
                p.beefShield = 150;
                p.beefShieldRegenRate = 8;
                p.beefShieldRegenDelay = 3;
                p.beefShieldDamageDealt = 0; // Track damage dealt for shield charging
                p.beefShieldDamageTaken = 0; // Track damage taken for shield depletion
                p.beefShieldCooldown = 0; // Cooldown after depletion before shield can absorb again
                playSound('powerup');
                announce('üõ°Ô∏è BEEF SHIELD UNLOCKED! - Class Ability Activated!');
                break;
            case 'blink_unlock':
                p.hasBlink = true;
                p.blinkRange = 250;
                p.blinkCooldown = 4;
                p.blinkDamage = 75;
                playSound('powerup');
                announce('‚ú® BLINK UNLOCKED! - Class Ability Activated!');
                break;
            case 'firewall_unlock':
                p.hasFirewall = true;
                p.firewallDuration = 10;
                p.firewallCooldown = 15;
                p.firewallDamage = 50;
                playSound('powerup');
                announce('üî• FIREWALL UNLOCKED! - Class Ability Activated!');
                break;
        }
    }

    function applySubclassBonus(subclass) {
        const p = store.player;
        console.log(`Applying subclass bonus for: ${subclass}`);
        console.log(`Before - multishot: ${p.multishot}, speed: ${p.speed}`);

        switch(subclass) {
            case 'railgunner': 
                p.subclass = 'railgunner';
                p.missilePierce = 2;
                announce('RAILGUNNER ACTIVATED - Piercing Missiles!');
                break;
            case 'demolitionist': 
                p.subclass = 'demolitionist';
                p.missileCluster = true;
                announce('DEMOLITIONIST ACTIVATED - Cluster Bombs!');
                break;
            case 'juggernaut': 
                p.subclass = 'juggernaut';
                // Give 2 charges (beef shield must be purchased separately via skill tree)
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);
                p.beefCharges = Math.max(p.beefCharges, 2);
                announce('JUGGERNAUT ACTIVATED - Enhanced Charges!');
                break;
            case 'marauder': 
                p.subclass = 'marauder';
                // Give 2 charges and enable chain jumping (beef shield must be purchased separately via skill tree)
                p.beefMaxCharges = Math.max(p.beefMaxCharges, 2);  
                p.beefCharges = Math.max(p.beefCharges, 2);
                p.beefChainMode = true; // Enable chain jumping for marauder
                announce('MARAUDER ACTIVATED - Chain Jumping!');
                break;
            case 'phasestriker': 
                p.subclass = 'phasestriker';
                // Give basic SHORT RANGE void laser as first upgrade
                p.hasVoidLaser = true;
                p.voidLaserTarget = null;
                p.voidLaserDamageTimer = 0;
                p.voidLaserRetargetTimer = 0;
                p.voidLaserRange = 250; // 25% longer base range
                p.phasestRikerLevel = 0.5; // Base phasestriker level (between 0 and 1)
                console.log(`Base phasestriker: level=${p.phasestRikerLevel}, range=${p.voidLaserRange}`);
                break;
            case 'stormcaller':
                p.subclass = 'stormcaller';
                // Give basic chain lightning ability
                p.hasChainLightning = true;
                p.chainLightningCooldown = 0;
                break;
            case 'voidmancer':
                p.subclass = 'voidmancer';
                // Base voidmancer bonus applied during genome selection
                console.log(`Voidmancer subclass selected - multishot: ${p.multishot}, speed: ${p.speed}`);
                break;
        }
        console.log(`Final - multishot: ${p.multishot}, speed: ${p.speed}`);
        store.world.enemyHealthBonus *= 1.10;
}

    function showSpecSelect(isAdditive = false) {
        pauseGame();
        const panel = q('subclassPanel'); // Reuse the subclass panel
        const grid = q('subclassGrid');
        const p = store.player;
        const genome = p.pilotGenome;
        
        let choices = [];
        
        if (genome === 'rocketman') {
            if (p.subclass === 'demolitionist') {
                if (isAdditive && p.enhancedClusters) {
                    // If they already have enhanced clusters, double current power
                    choices = [{ id: 'double_clusters', name: 'MEGA CLUSTERS', desc: 'Cluster explosions are twice as large and deal massive damage.', icon: 'demo.png' }];
                } else if (isAdditive && p.missilePierce > 0) {
                    // If they have railgunner abilities, give them enhanced clusters
                    choices = [{ id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' }];
                } else {
                    // First spec or missing railgunner - offer both
                    const opts = [
                        { id: 'enhanced_clusters', name: 'ENHANCED CLUSTERS', desc: 'Cluster explosions have massive radius and deal devastating damage.', icon: 'demo.png' },
                        { id: 'railgunner_pierce', name: 'PIERCING MISSILES', desc: 'Missiles pierce through 3 enemies with devastating force.', icon: 'rail.png' },
                        { id: 'compact_clusters_pierce', name: 'COMPACT PIERCING', desc: 'Smaller clusters but missiles pierce through 2 enemies.', icon: 'rail.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_clusters');
                }
            } else if (p.subclass === 'railgunner') {
                if (isAdditive && p.enhancedPierce) {
                    choices = [{ id: 'mega_pierce', name: 'ULTRA PIERCE', desc: 'Missiles pierce through 6 enemies with increased damage.', icon: 'rail.png' }];
                } else if (isAdditive && p.enhancedClusters) {
                    choices = [{ id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' }];
                } else {
                    const opts = [
                        { id: 'enhanced_pierce', name: 'ENHANCED PIERCE', desc: 'Missiles pierce through enemies with incredible force.', icon: 'rail.png' },
                        { id: 'cluster_missiles', name: 'CLUSTER MISSILES', desc: 'Missiles explode into smaller cluster bombs.', icon: 'demo.png' }
                    ];
                    choices = isAdditive ? opts : opts.filter(o => o.id === 'enhanced_pierce');
                }
            }
        } else if (genome === 'voidmancer') {
            // Voidmancer only gets the power they don't have
            if (!p.hasStormcaller && !p.hasPhasestriker) {
                // First spec - let them choose
                choices = [
                    { id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' },
                    { id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }
                ];
            } else if (!p.hasStormcaller) {
                choices = [{ id: 'stormcaller', name: 'STORMCALLER', desc: 'Chain lightning that jumps between enemies with 50% chance per jump.', icon: 'storm.png' }];
            } else if (!p.hasPhasestriker) {
                choices = [{ id: 'phasestriker', name: 'PHASESTRIKER', desc: 'Void step damages all enemies you pass through.', icon: 'phase.png' }];
            } else {
                // They have both - offer three enhanced void caller options
                choices = [
                    { id: 'double_storm', name: 'TWIN LIGHTNING', desc: 'Fires two chain lightning bolts instead of one.', icon: 'storm.png' },
                    { id: 'hybrid_void', name: 'VOID STORM', desc: 'Voidstep damages enemies + unlocks single lightning bolt.', icon: 'phase.png' },
                    { id: 'impact_phase', name: 'EARTHQUAKE', desc: 'Voidstep creates a massive impact shockwave at destination.', icon: 'void.png' }
                ];
            }
        } else if (genome === 'beef') {
            // Handle beef subclasses similarly
            if (p.subclass === 'juggernaut') {
                choices = [{ id: 'enhanced_juggernaut', name: 'MEGA JUGGERNAUT', desc: 'Massive charge radius and knockback increase.', icon: 'jug2.png' }];
            } else if (p.subclass === 'marauder') {
                choices = [{ id: 'enhanced_marauder', name: 'SHIELD MASTER', desc: 'Charge restores even more shields and grants temporary invulnerability.', icon: 'marauder.png' }];
            }
        }
        
        if (!choices.length) {
            resumeGame();
            return;
        }
        
        const title = isAdditive ? 'ENHANCED SPECIALIZATION' : 'CHOOSE SPECIALIZATION';
        document.querySelector('#subclassPanel h2').textContent = title;
        
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-spec="${s.id}"><div class="skill-icon"><img src="${s.icon}" class="pilot-icon"></div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join('');
        
        grid.querySelectorAll('.skill-card').forEach(card => {
            card.addEventListener('click', () => {
                const specId = card.dataset.spec;
                applySpecBonus(specId);
                panel.classList.add('hide');
                resumeGame();
                document.querySelector('#subclassPanel h2').textContent = 'CHOOSE SPECIALIZATION'; // Reset title
            }, { once: true });
        });

        panel.classList.remove('hide');
    }

    // DISABLED: applySpecBonus function for stability  
    function applySpecBonus(specId) {
        const p = store.player;
        
        switch(specId) {
            case 'enhanced_clusters':
                p.enhancedClusters = true;
                announce('ENHANCED CLUSTERS ACTIVATED!');
                break;
            case 'double_clusters':
                // Implement double cluster damage
                announce('MEGA CLUSTERS ACTIVATED!');
                break;
            case 'railgunner_pierce':
                p.missilePierce = 3;
                announce('PIERCING MISSILES ACTIVATED!');
                break;
            case 'compact_clusters_pierce':
                p.missilePierce = 2;
                // Keep clusters small but add pierce
                announce('COMPACT PIERCING ACTIVATED!');
                break;
            case 'enhanced_pierce':
                p.enhancedPierce = true;
                p.missilePierce = Math.max(p.missilePierce, 4); // Ensure at least 4 pierce
                announce('ENHANCED PIERCE ACTIVATED!');
                break;
            case 'mega_pierce':
                p.missilePierce = 6;
                announce('ULTRA PIERCE ACTIVATED!');
                break;
            case 'cluster_missiles':
                p.missileCluster = true;
                announce('CLUSTER MISSILES ACTIVATED!');
                break;
            case 'phasestriker':
                p.hasPhasestriker = true;
                console.log('PHASESTRIKER: Set hasPhasestriker=true (mobility only)');
                announce('PHASESTRIKER ACTIVATED!');
                break;
            case 'stormcaller':
                p.hasStormcaller = true;
                p.hasChainLightning = true;
                console.log('STORMCALLER: Set hasChainLightning=true, hasStormcaller=true');
                announce('CHAIN LIGHTNING ACTIVATED!');
                playSound('thunder');
                break;
            case 'double_storm':
                p.hasDoubleStorm = true;
                announce('TWIN CHAIN LIGHTNING ACTIVATED!');
                break;
            case 'hybrid_void':
                p.hasHybridVoid = true; 
                p.blinkDamage = true;  // Enable voidstep damage
                announce('VOID STORM ACTIVATED!');
                break;
            case 'impact_phase':
                p.hasImpactPhase = true;
                p.blinkDamage = true;  // Ensure voidstep does damage
                announce('EARTHQUAKE ACTIVATED!');
                break;
            case 'enhanced_storm':
                announce('MEGA STORM ACTIVATED!');
                break;
            case 'enhanced_phase':
                announce('VOID MASTERY ACTIVATED!');
                break;
            case 'enhanced_juggernaut':
                announce('MEGA JUGGERNAUT ACTIVATED!');
                break;
            case 'enhanced_marauder':
                announce('SHIELD MASTER ACTIVATED!');
                break;
        }
    }


    function ensureName(){
        if(!store.name){
            pauseGame();
            const panel = q("namePanel");
            
            // Initialize matrix
            const matrixContainer = panel.querySelector('.matrix-container');
            if (matrixContainer.matrix) {
                matrixContainer.matrix.init();
            }
            
            panel.classList.remove("hide");
            q("nameInput").value="";
            setTimeout(()=>q("nameInput").focus(),50)
        } else {
            resumeGame();
            if (store.player.pilotGenome === null) {
                initWave();
            }
        }
    }
    
    q("restartBtn").addEventListener("click", resetGame);
    
    q("saveName").addEventListener("click",()=>{const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}});
    
    const closeShopLogic = () => { q("shopPanel").classList.add('hide'); resumeGame(); const highlighted = document.querySelector('.shop-item.highlight'); if (highlighted) highlighted.classList.remove('highlight'); };
    q("closeShopTopBtn").addEventListener("click", closeShopLogic);
    q("closeShop").addEventListener("click", closeShopLogic);

    q("shopBtn").addEventListener("click", () => {
        if (q('shopPanel').classList.contains('hide')) {
            showShop();
        } else {
            closeShopLogic();
        }
    });

    const closeScoresLogic = () => { q('scorePanel').classList.add('hide'); resumeGame(); };
    // q("closeScores").addEventListener("click", closeScoresLogic); // Button hidden via CSS
    
    q("menuBtn").addEventListener("click",()=>{
        if (q('scorePanel').classList.contains('hide')) {
            pauseGame();
            
            // Initialize matrix
            const matrixContainer = q('scorePanel').querySelector('.matrix-container');
            if (matrixContainer.matrix) {
                matrixContainer.matrix.init();
            }
            
            q('scorePanel').classList.remove('hide');
        } else {
            closeScoresLogic();
        }
    });

    q("fsEnterBtn").addEventListener('click',()=>{const r=document.documentElement;if(!document.fullscreenElement){if(r.requestFullscreen)r.requestFullscreen();else if(r.webkitRequestFullscreen)r.webkitRequestFullscreen();else if(r.msRequestFullscreen)r.msRequestFullscreen()}else{if(document.exitFullscreen)document.exitFullscreen()}});
    
    q('pauseBtn').addEventListener('click',()=>{
        if(store.isGameOver || isAnyPanelOpen()) return;
        store.isPaused = !store.isPaused;
        q('pauseBtn').textContent = store.isPaused ? 'RESUME' : 'PAUSE';
    });
    
    q('grenadeBtnUI').addEventListener('click',useGrenade);

    /* Commented out for future implementation
    q('storyBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        pauseGame();
        
        // Initialize matrix
        const matrixContainer = q('storyPanel').querySelector('.matrix-container');
        if (matrixContainer.matrix) {
            matrixContainer.matrix.init();
        }
        
        q('storyPanel').classList.remove('hide');
    });
    q('storyPanel').addEventListener('click', () => {
        q('storyPanel').classList.add('hide');
        if (!q('pilotPanel').classList.contains('hide')) {
        } else {
            resumeGame();
        }
    });
    */
    
    q("nameInput").addEventListener("keydown",(e)=>{if(e.key==="Enter"){const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");if(store.player.pilotGenome === null) { initWave(); resumeGame(); } else { resumeGame(); }}}});

    q("namePanel").addEventListener("click", (e) => {
        if(e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
            q('nameInput').blur();
        }
    });
    
    let cheatCodeBuffer = "";
    let cheatTapCount = 0;
    let lastCheatTap = 0;

    function activateDamageOffCheat() {
    if (store.isDamageOff) return;
    store.isDamageOff = true;
    store.cheatsUsed = true;
    announce('CHEAT: DAMAGE & ABILITIES OFF');

    const p = store.player;
    const propsToDisable = [
        'dmgMult', 'multishot', 'rearMultishot', 'piercing', 'explosive', 
        'flamethrowerLevel', 'missileVolley', 'critChance', 'critDamage', 
        'hasLauncher', 'hasHounds', 'hasLazarusBeam', 'hasVoidBeam', 
        'hasChainLightning', 'hasIceman', 'blinkDamage', 'missilePierce', 'missileCluster',
        'hasDoubleStorm', 'hasHybridVoid', 'hasImpactPhase'
    ];
    
    store.savedPlayerState = {};
    propsToDisable.forEach(prop => {
        store.savedPlayerState[prop] = p[prop];
        if (typeof p[prop] === 'number') {
            p[prop] = 0;
        } else if (typeof p[prop] === 'boolean') {
            p[prop] = false;
        }
    });

    store.savedPlayerState.hounds = store.hounds;
    store.hounds = [];
    store.savedPlayerState.iceman = store.iceman;
    store.iceman = null;
}

    function deactivateDamageOffCheat() {
        if (!store.isDamageOff || !store.savedPlayerState) return;
        store.isDamageOff = false;
        announce('CHEAT: DAMAGE & ABILITIES ON');

        const p = store.player;
        for (const prop in store.savedPlayerState) {
            if (prop === 'hounds') {
                store.hounds = store.savedPlayerState.hounds;
            } else if (prop === 'iceman') {
                store.iceman = store.savedPlayerState.iceman;
            } else if (p.hasOwnProperty(prop)) {
                p[prop] = store.savedPlayerState[prop];
            }
        }
        
        store.savedPlayerState = null;
}

    function activateSubclassCheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (store.player.subclass) {
            announce("CHEAT FAILED: Subclass already chosen.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO SUBCLASS SELECT');
        showSubclassSelect();
    }
    
    function activateClassCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: SKIPPING TO CLASS SELECT');
        showPilotSelect();
    }
    
    function activatePowerCheat() {
        store.cheatsUsed = true;
        announce('CHEAT: POWER UP!');
        resetGame();
        store.world.gold = 800;
        store.player.multishot = 10;
        initWave();
        cheatCodeBuffer = "";
    }

    // ENABLED: Spec2 cheat functions  
    function activateSpec2Cheat() {
        if (!store.player.pilotGenome) {
            announce("CHEAT FAILED: Choose a Pilot first.");
            return;
        }
        if (!store.player.subclass) {
            announce("CHEAT FAILED: Choose a Subclass first.");
            return;
        }
        
        store.cheatsUsed = true;
        announce('CHEAT: JUMPING TO SUB2');
        showSpecSelect(true); // true = additive/second spec
    }

    function activateSpeedCheat() {
        // Initialize if not present
        if (!window.gameSpeedMultiplier || window.gameSpeedMultiplier < 1) {
            window.gameSpeedMultiplier = 1;
        }
        
        // Cycle through speed multipliers: 1x -> 2x -> 3x -> 1x
        if (window.gameSpeedMultiplier === 1) {
            window.gameSpeedMultiplier = 2;
            announce('CHEAT: GAME SPEED 2X');
        } else if (window.gameSpeedMultiplier === 2) {
            window.gameSpeedMultiplier = 3;
            announce('CHEAT: GAME SPEED 3X');
        } else {
            window.gameSpeedMultiplier = 1;
            announce('CHEAT: GAME SPEED NORMAL');
        }
        
        store.cheatsUsed = true;
        console.log('Speed multiplier set to:', window.gameSpeedMultiplier);
    }

    q('diagBox').children[0].addEventListener('click', () => {
        const now = performance.now();
        if (now - lastCheatTap > 500) {
            cheatTapCount = 0;
        }
        lastCheatTap = now;
        cheatTapCount++;
        if (cheatTapCount >= 3) {
            activatePowerCheat();
            cheatTapCount = 0;
        }
    });

    addEventListener("keydown", e => {
        const key = e.key.toLowerCase();
        if (document.activeElement.tagName === "INPUT") return;

        if (/[a-z]/.test(key)) {
            cheatCodeBuffer += key;
            if (cheatCodeBuffer.length > 10) {
                cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
            }

            if (cheatCodeBuffer.endsWith('power')) {
                activatePowerCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('off')) {
                activateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('on')) {
                deactivateDamageOffCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('spec')) {
                activateSubclassCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('sub2')) {
                activateSpec2Cheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('fast')) {
                activateSpeedCheat();
                cheatCodeBuffer = "";
            } else if (cheatCodeBuffer.endsWith('class')) {
                activateClassCheat();
                cheatCodeBuffer = "";
            }
        } else {
            if (key !== ' ' && key !== 'b') {
                cheatCodeBuffer = "";
            }
        }

        if (key === ' ') { e.preventDefault(); useGrenade() }
        if (key === 'escape') { 
            e.preventDefault(); 
            // Close skill tree if it's open
            if (!q('subclassPanel').classList.contains('hide') && q('subclassPanel').classList.contains('skill-tree-active')) {
                closeSkillTree();
            }
        }
    });

    let lastTapTime = 0;
    cvs.addEventListener('touchend', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
            const now = performance.now();
            const DOUBLE_TAP_DELAY = 300;
            if (now - lastTapTime < DOUBLE_TAP_DELAY) {
                const p = pointFromEvent(e);
                tryVoidStep(store.player, p);
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: false });

    cvs.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (store.player.pilotGenome === 'voidmancer' && store.player.hasBlink && !store.isPaused && !store.isGameOver) {
            const p = pointFromEvent(e);
            tryVoidStep(store.player, p);
        }
    });


    function frame(now) {
        const rawDt = Math.min((now - store.last) / 1000, 0.07);
        const speedMultiplier = window.gameSpeedMultiplier || 1;
        // Cap the dt to prevent simulation instability even with speed multiplier
        const dt = Math.min(rawDt * speedMultiplier, 0.1); 
        
        store.last = now;
        if (!store.isPaused && !store.isGameOver) {
            stepWorld(dt);
        }
        render(rawDt); // Use original dt for rendering to avoid visual issues
        requestAnimationFrame(frame);
    }
    try{
        ensureName();
        refreshScoreList();
        requestAnimationFrame(frame)
    }catch(error){
        console.error("Game initialization failed:",error);
        try{
            updateLeaderboard(null);
            ensureName();
            requestAnimationFrame(frame);
            console.log("Game started in offline mode")
        }catch(criticalError){
            console.error("Critical startup failure:",criticalError);
        }
    }
    

    // Matrix Rain Effect for Menus
    class OptimizedMatrixRain {
        constructor(container) {
            this.container = container;
            this.columns = [];
            this.isRunning = true;
            this.speed = 50;
            this.density = 85;
            this.trailLength = 15;
            this.columnWidth = 30;
            this.charHeight = 20;
            
            // Character pool for reuse
            this.characterPool = [];
            this.activeCharacters = new Set();
            
            // Matrix-style character set with emphasis on 0, 1, 2
            this.matrixChars = [
                '0', '0', '0', '1', '1', '1', '2', '2', '2',
                '3', '4', '5', '6', '7', '8', '9',
                '$', '‚Ç¨', '¬•', '¬£', '‚Çπ', '%', '&', '*',
                '„Ç¢', '„Ç§', '„Ç¶', '„Ç®', '„Ç™', '„Ç´', '„Ç≠',
                '„ÇØ', '„Ç±', '„Ç≥', '„Çµ', '„Ç∑', '„Çπ', '„Çª'
            ];
            
            // Performance tracking
            this.frameCount = 0;
            this.lastFpsTime = performance.now();
            this.fps = 60;
            
            // Use RAF for smooth animation
            this.lastAnimationTime = 0;
            this.animationId = null;
            
            this.init();
            // Don't auto-start - will be controlled by panel visibility
        }

        init() {
            // Clear container
            this.container.innerHTML = '';
            this.columns = [];
            this.characterPool = [];
            this.activeCharacters.clear();
            
            const screenWidth = this.container.clientWidth;
            const screenHeight = this.container.clientHeight;
            const numColumns = Math.floor(screenWidth / this.columnWidth);
            
            // Pre-create character pool (reusable elements)
            const poolSize = numColumns * this.trailLength * 2;
            for (let i = 0; i < poolSize; i++) {
                const char = document.createElement('span');
                char.className = 'matrix-char';
                char.style.display = 'none';
                this.container.appendChild(char);
                this.characterPool.push(char);
            }
            
            // Initialize columns
            for (let i = 0; i < numColumns; i++) {
                const column = {
                    x: i * this.columnWidth,
                    chars: [],
                    speed: 0.5 + Math.random() * 1.5,
                    nextSpawnTime: Math.random() * 1000
                };
                this.columns.push(column);
            }
        }

        getCharFromPool() {
            // Reuse character from pool
            for (let char of this.characterPool) {
                if (!this.activeCharacters.has(char)) {
                    this.activeCharacters.add(char);
                    char.style.display = 'block';
                    return char;
                }
            }
            return null; // Pool exhausted
        }

        returnCharToPool(char) {
            char.style.display = 'none';
            this.activeCharacters.delete(char);
        }

        getRandomChar() {
            return this.matrixChars[Math.floor(Math.random() * this.matrixChars.length)];
        }

        updateColumn(column, deltaTime, currentTime) {
            const screenHeight = this.container.clientHeight;
            const speedMultiplier = this.speed / 50;
            
            // Check if should spawn new character
            if (currentTime > column.nextSpawnTime) {
                if (Math.random() * 100 < this.density) {
                    const char = this.getCharFromPool();
                    if (char && column.chars.length < this.trailLength) {
                        char.textContent = this.getRandomChar();
                        char.style.left = column.x + 'px';
                        char.style.top = '0px';
                        char.className = 'matrix-char bright';
                        
                        column.chars.push({
                            element: char,
                            y: 0,
                            changeTime: currentTime + Math.random() * 500
                        });
                    }
                }
                column.nextSpawnTime = currentTime + (100 / this.density) * 50;
            }
            
            // Update existing characters
            for (let i = column.chars.length - 1; i >= 0; i--) {
                const char = column.chars[i];
                
                // Move character down
                char.y += column.speed * speedMultiplier * deltaTime * 0.05;
                
                // Remove if off screen
                if (char.y > screenHeight) {
                    this.returnCharToPool(char.element);
                    column.chars.splice(i, 1);
                    continue;
                }
                
                // Update position using transform (GPU accelerated)
                char.element.style.transform = `translateY(${char.y}px)`;
                
                // Change character occasionally
                if (currentTime > char.changeTime) {
                    char.element.textContent = this.getRandomChar();
                    char.changeTime = currentTime + 200 + Math.random() * 800;
                }
                
                // Update brightness based on position in trail
                const progress = char.y / screenHeight;
                const trailPosition = i / column.chars.length;
                
                if (i === column.chars.length - 1 && progress < 0.1) {
                    char.element.className = 'matrix-char bright';
                } else if (progress < 0.3 && trailPosition > 0.6) {
                    char.element.className = 'matrix-char medium';
                } else if (progress < 0.5) {
                    char.element.className = 'matrix-char dim';
                } else if (progress < 0.8) {
                    char.element.className = 'matrix-char faded';
                } else {
                    char.element.className = 'matrix-char very-faded';
                }
            }
        }

        animate(currentTime) {
            if (!this.isRunning) {
                return; // Stop completely when not running
            }
            
            const deltaTime = currentTime - this.lastAnimationTime;
            this.lastAnimationTime = currentTime;
            
            // Update all columns
            for (let column of this.columns) {
                this.updateColumn(column, deltaTime, currentTime);
            }
            
            this.animationId = requestAnimationFrame(time => this.animate(time));
        }
        
        pause() {
            this.isRunning = false;
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }
        }
        
        resume() {
            if (!this.isRunning) {
                this.isRunning = true;
                this.lastAnimationTime = performance.now();
                this.animate(this.lastAnimationTime);
            }
        }
        
        destroy() {
            this.pause();
            this.container.innerHTML = '';
        }
    }

    // Initialize matrix effects for all panels - but don't start them yet
    let matrixInstances = [];
    document.addEventListener('DOMContentLoaded', () => {
        const matrixContainers = document.querySelectorAll('.matrix-container');
        matrixContainers.forEach(container => {
            const matrix = new OptimizedMatrixRain(container);
            matrix.pause(); // Start paused
            matrixInstances.push(matrix);
            container.matrix = matrix; // Store reference on the container
        });
        
        // Initialize mobile controls
        setupMobileControls();
    });

})();
</script>
</body>
</html>
