<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
    <title>Void Skies</title>
    <style>
        :root {
            --bg:#050008; --fg:#ff99cc; --accent:#b266ff; --accent2:#9a66ff;
            --edge:rgba(178,102,255,.35); --hud-text: clamp(9px, 1vw, 12px);
            --btn-text: clamp(16px, 2vw, 20px); --btn-pad-y: clamp(12px, 1.5vw, 18px);
            --btn-pad-x: clamp(18px, 2.5vw, 24px); --maxw: 98vw;
        }
        html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% 40%,#330044,var(--bg));color:var(--fg);font-family:'Audiowide',ui-sans-serif,system-ui}
        #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:0;}
        .stage{width:100vw; height:100svh; position:relative;display:grid;place-items:center;background:#000;border-radius:0;overflow:hidden;box-shadow:0 0 60px rgba(255,0,255,.4);container-type:inline-size;z-index:2;}
        canvas{background:transparent;border-radius:16px;touch-action:none;cursor:none}
        
        #ui { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; }

        #topBar{position:absolute;left:0;right:0;top:0;display:grid;grid-template-columns:1fr auto 1fr;align-items:start;padding:4px;pointer-events:none}
        #hud{display:flex;gap:8px;pointer-events:none;font-size:var(--hud-text);justify-content:center;align-items:flex-start;width:auto;max-width:none;transform:translateY(2px);grid-column:2}
        .hud-card{pointer-events:none;border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:6px 10px;border-radius:8px;width:auto;min-width:220px}
        .hud-title{opacity:.85;font-weight:600;margin-bottom:4px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:10px;color:#c49cff}
        #hudPowerup{grid-column:1;justify-self:start;margin-left:8px;min-width:150px}
        #hudEquipment{grid-column:3;justify-self:end;margin-right:8px;min-width:150px; text-align:right;}
        .bar{height:4px;width:100%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
        .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2))}
        #announce {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: 70px;
            background: linear-gradient(180deg, rgba(0, 255, 150, .26), rgba(0, 255, 150, .1));
            border: 1px solid #00ff96;
            padding: 6px 10px;
            border-radius: 10px;
            font-weight: 600;
            text-shadow: 0 0 10px #00ff96;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-size: 12px;
            color: #fff;
        }
        #diagBox{position:absolute;left:8px;top:8px;display:grid;gap:4px;pointer-events:none}
        .chip{pointer-events:auto;background:rgba(0,0,0,.7);border:1px solid var(--edge);padding:4px 8px;border-radius:8px;font-size:10px;letter-spacing:.3px;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:left;color:#c49cff}
        .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all .2s; font-family: 'Orbitron', 'Audiowide', ui-sans-serif;}
        .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5)}
        
        .panel{
            position:absolute;
            left:50%;
            top:50%;
            transform:translate(-50%,-50%);
            background:rgba(26,0,34,.95);
            border:1px solid var(--accent);
            border-radius:16px;
            padding:12px;
            width:min(600px, 90vw);
            backdrop-filter:blur(12px);
            color:#ffddff;
            box-shadow:0 0 40px rgba(178,102,255,.3);
            z-index:100;
        }
        #namePanel {
            top: 25%;
            transform: translate(-50%, -25%);
        }
        .close-btn {
            position: absolute;
            top: 8px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--accent);
            font-size: 20px;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding: 4px;
        }
        .close-btn:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        #shopPanel h2, #levelPanel h2, #scorePanel h2, #namePanel h2 {
            margin: 0 0 8px 0;
            padding-top: 10px;
            font-size: clamp(18px, 2.2vw, 22px);
            text-align: center;
        }
        #shopPanel p, #levelPanel p, #namePanel p {
            margin: 0 0 10px 0;
            text-align: center;
        }
        #shopGrid, #scorePanel div {
            max-height: 60vh; 
            overflow-y: auto;
            padding-right: 8px;
        }
        .grid{
            display:grid;
            gap:8px;
            grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
        }
        .hide{display:none!important}
        #belowBoard{width:min(98vw,var(--maxw));margin:50px auto 0;padding:8px;display:grid;gap:8px}
        #hsCard{border:1px solid var(--edge);background:linear-gradient(180deg,rgba(150,80,255,.12),rgba(150,80,255,.06));backdrop-filter:blur(8px);padding:8px;border-radius:8px}
        #hsCard h3{margin:0 0 6px 0;font-family:'Orbitron','Audiowide',ui-sans-serif;text-align:center;font-size:14px;color:#c49cff}
        #hsList{list-style:decimal;margin:0;padding:0 0 0 1rem;line-height:1.4;font-size:12px;color:#ffddff}
        
        .skill-card {
            background: radial-gradient(circle, rgba(51,0,68,1) 0%, rgba(51,0,68,0.8) 70%);
            border: 1px solid var(--accent);
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            justify-content: space-between;
        }
        .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05)}
        .skill-card.disabled{opacity:0.5;cursor:not-allowed;transform:none!important;box-shadow:none!important}
        
        .skill-icon {
            font-size: 28px;
            margin-bottom: 8px;
            line-height: 1;
        }
        .skill-title{
            font-weight:700;
            color:#c49cff;
            margin-bottom: 4px;
            font-size: 13px;
            line-height: 1.1;
        }
        .skill-desc{
            font-size:10px;
            color:#ffddff;
            flex-grow: 1;
            margin-bottom: 4px;
        }

        .fixed-btn{
            position: fixed;
            z-index: 5;
            border-radius: 10px;
            padding: var(--btn-pad-y) var(--btn-pad-x);
            background: rgba(150, 80, 255, .2);
            border: 1px solid var(--accent);
            backdrop-filter: blur(8px);
            cursor: pointer;
            font-size: var(--btn-text);
            color: #ffddff;
            height: auto;
            font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
            opacity: 0.4;
            transition: opacity 0.3s ease-in-out;
        }
        .fixed-btn:hover {
            opacity: 1;
        }

        #fsEnterBtn {
            left: 20px;
            bottom: 20px;
        }
        
        #bottom-right-controls {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 5;
            display: flex;
            gap: 10px;
        }
        #bottom-right-controls > .fixed-btn {
            position: static;
        }

        #menuBtn, #fsEnterBtn, #shopBtn {
            font-size: clamp(12.8px, 1.6vw, 16px);
            padding: clamp(9.6px, 1.2vw, 14.4px) clamp(14.4px, 2vw, 19.2px);
            min-width: auto;
        }

        #shopBtn {
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 165, 0, 0.2));
            border-color: #ffd700;
        }
        #pauseBtn {
            top: 50%;
            right: 15px; 
            transform: translateY(-50%);
            width: auto;
            height: auto;
            min-width: 0;
            padding: 20px 10px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: clamp(12.8px, 1.6vw, 16px);
            z-index: 5;
            position: fixed;
        }
        .input{width:100%;padding:8px 10px;border-radius:10px;background:#17001f;color:#ffddff;border:1px solid var(--accent);font-family:'Orbitron','Audiowide',ui-sans-serif; box-sizing: border-box;} /* ADDED: box-sizing */
        
        #abilityBar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 6; pointer-events: auto;
        }
        #abilityBar .ability-btn {
            position: relative; bottom: auto; left: auto; right: auto; top: auto;
            min-width: 150px; padding: clamp(10px, 1.2vw, 14px) clamp(16px, 2vw, 22px);
            font-size: clamp(14px, 1.8vw, 18px);
            background: linear-gradient(180deg, rgba(178, 102, 255, .4), rgba(178, 102, 255, .2));
            text-shadow: 0 0 8px #ff99cc;
            transition: all 0.2s ease-in-out;
            opacity: 1.0;
        }
        #abilityBar .ability-btn:not(:disabled) {
            animation: pulse-glow-ability 2s infinite;
        }
        #abilityBar .ability-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(178, 102, 255, .7);
        }
        
        .shop-item-attack { border-color: #00bfff; }
        .shop-item-health { border-color: #00ff00; }
        .shop-item-utility { border-color: #ffd700; }

        @keyframes pulse-glow {
            0% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
            50% { box-shadow: 0 0 35px rgba(102, 255, 178, 1); }
            100% { box-shadow: 0 0 15px rgba(102, 255, 178, .5); }
        }
        @keyframes pulse-glow-ability {
            0% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
            50% { box-shadow: 0 0 20px rgba(178, 102, 255, .8); }
            100% { box-shadow: 0 0 10px rgba(178, 102, 255, .5); }
        }
        .shop-item.highlight {
            animation: pulse-glow 1.5s infinite;
            border-color: #66ffb2;
        }

        @media (max-width:820px){canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}.panel{width:min(500px,94vw)}.stage{width:98vw}#belowBoard{width:98vw}}
    </style>
</head>
<body>
    <div id="wrap">
        <div>
            <div class="stage" id="stage">
                <div id="topBar">
                    <div id="hudPowerup" class="hud-card hide"></div>
                    <div id="hud">
                        <div id="hudWaveContent" class="hud-card"></div>
                        <div id="hudPilotContent" class="hud-card"></div>
                        <div id="hudBossContent" class="hud-card hide"></div>
                    </div>
                    <div id="hudEquipment" class="hud-card hide"></div>
                    <div id="announce" class="hide" aria-live="polite"></div>
                </div>
                <canvas id="game" width="960" height="540"></canvas>
                <div id="diagBox">
                    <div class="chip">v3.6.3</div>
                    <div class="chip">FPS <span id="fps">‚Äî</span></div>
                </div>
                
                <div id="ui">
                    <div id="gameOverPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üöÄ PILOT LOST üöÄ</h2>
                        <p style="text-align:center;font-size:1.2em;color:#ffddff">FINAL SCORE: <span id="finalScore">0</span></p>
                        <div class="row" style="justify-content:center;margin-top:20px">
                            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
                        </div>
                    </div>
                    <div id="namePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üíÄ CALLSIGN üíÄ</h2>
                        <p style="color:#ffddff;margin-top:0">Enter your pilot callsign (max 16 chars).</p>
                        <input id="nameInput" class="input" maxlength="16" placeholder="e.g. NIGHTWRAITH" />
                        <div class="row" style="display: flex; justify-content:center;margin-top:12px"> <button id="saveName" class="btn" type="button">CONFIRM</button>
                        </div>
                    </div>
                    <div id="scorePanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0">üèÜ Aces of the Void üèÜ</h2>
                        <div style="max-height:60vh;overflow-y:auto">
                            <ol id="hsListPopup" style="line-height:1.6;color:#ffddff"></ol>
                        </div>
                        <div style="display:flex;justify-content:center;margin-top:10px">
                            <button id="closeScores" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                    <div id="levelPanel" class="panel hide">
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
                        <p style="color:#ffddff">Select your neural enhancement:</p>
                        <div id="skillsGrid" class="grid"></div>
                    </div>
                    <div id="shopPanel" class="panel hide">
                        <button type="button" class="close-btn" id="closeShopTopBtn">X</button>
                        <h2 style="font-family:'Orbitron';color:var(--accent)">‚ö° MECH FORGE ‚ö°</h2>
                        <p style="color:#ffddff">Available Shards: <span id="shopShards">0</span></p>
                        <div id="shopGrid" class="grid"></div>
                        <div class="row" style="justify-content:center;margin-top:10px">
                            <button id="closeShop" class="btn" type="button">CLOSE</button>
                        </div>
                    </div>
                </div>
                
                <div id="abilityBar">
                    <button id="grenadeBtnUI" class="fixed-btn ability-btn hide" type="button">GRENADE</button>
                    <button id="voidBeamBtnUI" class="fixed-btn ability-btn hide" type="button">VOID BEAM</button>
                </div>

            </div>
            <div id="belowBoard">
                <div id="hsCard">
                    <h3>‚ö° Aces of the Void ‚ö°</h3>
                    <ol id="hsList"></ol>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgmAudio" loop></audio>
    <audio id="audioExplosion" src="Explosion.m4a" preload="auto"></audio>
    <audio id="audioHorn" src="Horn.wav" preload="auto"></audio>
    <audio id="audioHit" src="thunk.wav" preload="auto"></audio>
    <audio id="audioTrap" src="trap.m4a" preload="auto"></audio>
    <audio id="audioDogs" src="dogs.m4a" preload="auto"></audio>

    <button id="fsEnterBtn" class="fixed-btn" type="button">FULLSCREEN</button>
    <div id="bottom-right-controls">
        <button id="shopBtn" class="fixed-btn" type="button">‚ö° MECH FORGE</button>
        <button id="menuBtn" class="fixed-btn" type="button">üèÜ TOP PILOTS</button>
    </div>
    <button id="pauseBtn" class="fixed-btn hide" type="button">PAUSE</button>

<script>
(() => {
    // --- CORE SETUP ---
    const W = 960, H = 540;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const collide = (a, b) => { const dx = a.x - b.x, dy = a.y - b.y; const rr = (a.r || 0) + (b.r || 0); return dx * dx + dy * dy < rr * rr; };
    const API_BASE = "https://ignored-insight-easter-scholars.trycloudflare.com/api";
    const q = (id) => document.getElementById(id);
    const cvs = q('game'), ctx = cvs.getContext('2d'), stage = q('stage');
    new ResizeObserver(() => { 
        const r = stage.getBoundingClientRect(), cssW = Math.floor(r.width), cssH = Math.floor(r.height), 
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); 
        cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px'; 
        cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr); 
        ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0); 
    }).observe(stage);
    const mouse = { x: W / 2, y: H * 0.8 };
    const pointFromEvent = (e) => { 
        const r = cvs.getBoundingClientRect(), 
        cx = 'clientX' in e ? e.clientX : e.touches[0].clientX, 
        cy = 'clientY' in e ? e.clientY : e.touches[0].clientY; 
        return { x: (cx - r.left) * (W / r.width), y: (cy - r.top) * (H / r.height) }; 
    };

    cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
    cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    cvs.addEventListener('touchmove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive: false });
    
    // --- AUDIO ---
    const bgm = q('bgmAudio');
    const sounds = {
        explosion: q('audioExplosion'),
        horn: q('audioHorn'),
        hit: q('audioHit'),
        trap: q('audioTrap'),
        dogs: q('audioDogs')
    };
    let lastExplosionSoundTime = 0;
    let lastBossHitSoundTime = 0;
    
    function playSound(name) {
        const audio = sounds[name];
        if (!audio) return;
        
        const now = performance.now();
        if (name === 'explosion') {
            if (now - lastExplosionSoundTime < 50) return; // Throttle explosion sounds
            lastExplosionSoundTime = now;
        }
        if (name === 'hit') {
            if (now - lastBossHitSoundTime < 100) return; // Throttle hit sounds
            lastBossHitSoundTime = now;
        }

        audio.currentTime = 0;
        audio.play().catch(e => {}); // Catch errors if user hasn't interacted yet
    }


    // --- GAME STATE & DATA ---
    const player_initial_state = { 
        x: W / 2, y: H * 0.8, r: 14, hp: 100, hpMax: 100, fireT: 0, speed: 380, dmgMult: 1, fireRate: 0.18, 
        vampirism: 0, shield: 0, shieldMax: 0, multishot: 1, isInvincible: false, piercing: 0, explosive: false, 
        hasShieldBubble: false, powerupTimers: {}, 
        upgradeLevels: { dmg: 0, speed: 0, hp: 0, shield: 0 }, grenades: 0, hasVoidBeam: false, 
        voidBeamCooldown: 0, hasLauncher: false, hasHounds: false, missileFireT: 0, nanoSaves: 0, vampirismLevel: 0, flamethrowerLevel: 0,
        luckBoost: 0, magnetRadius: 0, hasIceman: false, critChance: 0.02, critDamage: 2
    };
    
    const store = {
        frame: 0, last: performance.now(), isGameOver: false, isPaused: false,
        world: { wave: 1, score: 0, shards: 0, xp: 0, level: 1, kills: 0, bosses: 0, lowHealthTutorialShown: false },
        player: { ...player_initial_state },
        boss: null, bullets: [], eBullets: [], enemies: [], powerups: [], drones: [], grenades: [], hounds: [], missiles: [], lasers: [], mines: [], activeEffects: [],
        iceman: null,
        _startTs: performance.now(),
        cheatInvincibilityCooldown: 0,
        cheatDogHealCooldown: 0,
        cheatsUsed: false
    };

    const LEVEL_UPGRADES = [
        { id: 'dmg', name: 'PLASMA CORE', icon: 'üí•', desc: '+25% damage', apply: () => store.player.dmgMult *= 1.25 },
        { id: 'fire', name: 'OVERCLOCK', icon: 'üî•', desc: '+25% fire rate', apply: () => store.player.fireRate *= 0.75 },
        { id: 'multi', name: 'SCATTER PROTOCOL', icon: '‚òÑÔ∏è', desc: '+1 projectile', apply: () => store.player.multishot += 1 },
        { id: 'shield', name: 'VOID SHIELD', icon: 'üõ°Ô∏è', desc: '+20 regenerating shield', apply: () => { store.player.shieldMax += 20; store.player.shield = store.player.shieldMax; } },
        { id: 'flamethrower', name: 'FLAMETHROWER', icon: 'üî•üî•üî•', desc: 'Adds a flamethrower to your ship.', apply: () => { 
            store.player.flamethrowerLevel++; 
        } }
    ];
    
    const SHOP_UPGRADES = {
        'repair': { name: "NANO REPAIR", icon: 'üîß', cost: 3, isPremium: true, category: 'health', apply: () => { if (store.player.hp < store.player.hpMax) { store.player.hp = Math.min(store.player.hpMax, store.player.hp + store.player.hpMax * 0.25); return true; } return false; }, desc: () => `Restore 25% of max HP.` },
        'vampirism': { 
            name: "VAMPIRIC ROUNDS", 
            icon: 'ü©∏', 
            isPremium: true, 
            max: 4, 
            category: 'utility', 
            apply: () => {
                const p = store.player;
                const cost = 12 + (p.vampirismLevel * 5);
                if (store.world.shards >= cost && p.vampirismLevel < 4) {
                    store.world.shards -= cost;
                    p.vampirismLevel++;
                    p.vampirism += 0.03;
                    p.dmgMult += 0.04;
                    return true;
                }
                return false;
            }, 
            desc: () => {
                const p = store.player;
                if (p.vampirismLevel >= 4) return `Max Level Reached (${(p.vampirism * 100).toFixed(0)}% Lifesteal, +${p.vampirismLevel * 4}% Dmg)`;
                const cost = 12 + (p.vampirismLevel * 5);
                return `+3% lifesteal, +4% dmg. Cost: ${cost}`;
            } 
        },
        'hp': { name: "MAX HP", icon: '‚ù§Ô∏è', baseCost: 20, scale: 1.4, maxLevel: 10, category: 'health', effect: () => { store.player.hpMax += 10; store.player.hp += 10; }, desc: level => `+10 Max HP (Lvl ${level + 1})` },
        'nano_save': { name: "NANO SAVE", icon: 'üíæ', cost: 25, isPremium: true, max: 3, category: 'utility', apply: () => { if (store.player.nanoSaves < 3) { store.player.nanoSaves++; return true; } return false; }, desc: () => `Auto-heals on low HP. Charges: ${store.player.nanoSaves}/3` },
        'luck_boost': { name: "LUCK BOOST", icon: 'üçÄ', cost: 25, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.luckBoost) { store.player.luckBoost = 0.15; return true; } return false; }, desc: () => `+15% chance for powerups.` },
        'magnet_pull': { name: "MAGNET PULL", icon: 'üß≤', cost: 25, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.magnetRadius) { store.player.magnetRadius = 150; return true; } return false; }, desc: () => `Powerups are drawn to you.` },
        'dmg': { name: "DAMAGE", icon: 'üí™', baseCost: 25, scale: 1.5, maxLevel: 10, category: 'attack', effect: () => store.player.dmgMult += 0.1, desc: level => `+10% Damage (Lvl ${level + 1})` },
        'speed': { name: "SPEED", icon: 'üöÄ', baseCost: 30, scale: 1.6, maxLevel: 8, category: 'utility', effect: () => store.player.speed += 30, desc: level => `+30 Speed (Lvl ${level + 1})` },
        'grenade': { name: "NOVA GRENADE", icon: 'üí•üí£üí•', cost: 35, isPremium: true, max: 3, category: 'attack', apply: () => { if (store.player.grenades < 3) { store.player.grenades++; return true; } return false; }, desc: () => `Buy 1 (Max 3)` },
        'shield': { name: "MAX SHIELD", icon: 'üõ°Ô∏è', baseCost: 40, scale: 1.8, maxLevel: 5, category: 'health', effect: () => { store.player.shieldMax += 25; store.player.shield += 25; }, desc: level => `+25 Max Shield (Lvl ${level + 1})` },
        'mine_wall': { name: "MINE WALL", icon: 'üí£', cost: 40, isPremium: true, max: 2, category: 'attack', apply: () => { const activeWalls = store.mines.filter(m => m.isWallMine).length > 0; if(!activeWalls) { deployMineWall(); return true; } return false; }, desc: () => `Deploy a wall of mines.` },
        'launcher': { name: 'FRAGMENTATION LAUNCHER', icon: 'üí•', cost: 50, isPremium: true, isUnlock: true, category: 'attack', apply: () => { if (!store.player.hasLauncher) { store.player.hasLauncher = true; return true; } return false; }, desc: () => `Adds swirling nova projectiles.` },
        'the_iceman': { name: "THE ICEMAN", icon: '‚ùÑÔ∏è', cost: 59, isPremium: true, isUnlock: true, category: 'utility', apply: () => { if (!store.player.hasIceman) { store.player.hasIceman = true; store.iceman = { x: store.player.x, y: store.player.y + 50, t: 0}; return true; } return false; }, desc: () => `A clone mirrors your attacks.` },
        'void_beam': { name: "VOID BEAM", icon: '‚ò¢Ô∏è‚òÑÔ∏è‚ò¢Ô∏è', cost: 75, isPremium: true, isUnlock: true, category: 'attack', apply: () => { if (!store.player.hasVoidBeam) { store.player.hasVoidBeam = true; return true; } return false; }, desc: () => `Unlock Ultimate Weapon` },
        'ghost_hounds': { name: "GHOST HOUNDS", icon: 'üëªüê∫', cost: 75, isPremium: true, isUnlock: true, category: 'attack', apply: () => { 
            if (!store.player.hasHounds) { 
                store.player.hasHounds = true; 
                store.hounds = [createHound(-1), createHound(1)];
                playSound('dogs');
                return true; 
            } 
            return false; 
        }, desc: () => `Unlocks 2 spectral hounds.` }
    };
    
   const POWERUP_TYPES = {
        'double': { name: 'SCATTER SHOT', icon: '‚¨ÜÔ∏è', duration: 0, type: 'instant' },
        'drones': { name: 'SIDE DRONES', icon: 'üöÅ', duration: 15, type: 'timed' },
        'shield': { name: 'SHIELD BUBBLE', icon: 'üõ°Ô∏è', duration: 0, type: 'instant' },
        'repair': { name: 'REPAIR KIT', icon: '‚ù§Ô∏è', duration: 0, type: 'instant' },
        'missile': { name: 'HOMING MISSILES', icon: 'üöÄ', duration: 20, type: 'timed' }
    };

    // --- GAME MECHANICS ---
    function spawnPowerup(x, y) { 
        const baseChance = 0.15 + (store.player.luckBoost || 0);
        const wave = store.world.wave;
        const waveReductionFactor = 0.005;
        const chance = Math.max(0.05, baseChance - (wave - 1) * waveReductionFactor);
        if (Math.random() > chance) return;
        const types = Object.keys(POWERUP_TYPES); 
        const typeKey = types[Math.floor(Math.random() * types.length)]; 
        store.powerups.push({ x, y, r: 12, type: typeKey }); 
    }
    
    function applyPowerup(typeKey) {
        const p = store.player;
        const powerup = POWERUP_TYPES[typeKey];
        if (powerup.type === 'timed') {
            if (p.powerupTimers[typeKey]) { p.powerupTimers[typeKey].remaining += powerup.duration; } 
            else { if (typeKey === 'drones') store.drones = [{ active: true, offset: -40 }, { active: true, offset: 40 }];
                p.powerupTimers[typeKey] = { remaining: powerup.duration, max: powerup.duration };
            }
        } else if (powerup.type === 'instant') {
            if (typeKey === 'shield') p.hasShieldBubble = true;
            if (typeKey === 'repair') p.hp = Math.min(p.hpMax, p.hp + 30);
            if (typeKey === 'double') { p.multishot++; announce('SCATTER SHOT!'); }
        }
        announce(powerup.name);
    }

    function initWave() {
        const isBossWave = store.world.wave % 5 === 0;
        if (isBossWave) {
            store.enemies = [];
            const bossHpScale = 1 + (store.world.wave / 5 - 1) * 1.5;
            store.boss = createBoss(bossHpScale);
            if (store.boss.name === 'TRAP KING') playSound('trap');
            else if (store.boss.name === 'CORE MALIGNUS') playSound('horn');

            announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
        } else {
            store.enemies = [];
            const spawnCount = 7 + Math.floor(store.world.wave * 1.8);
            for (let i = 0; i < spawnCount; i++) {
                const types = ['drone', 'drone', 'hunter', 'phantom', 'mech'];
                store.enemies.push(spawnEnemy(types[Math.floor(Math.random() * types.length)]));
            }
            announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
        }
    }
    
    function createBoss(scale) {
        const bossCycle = Math.floor((store.world.wave - 5) / 5) % 5;
        const types = [
            { name: 'MAJOR JUEVO', baseHp: 1200, r: 55, behavior: 'sentinel', color: '#ff8080' },
            { name: 'TRAP KING', baseHp: 1500, r: 50, behavior: 'hex', color: '#66aaff'},
            { name: 'CORE MALIGNUS', baseHp: 1800, r: 60, behavior: 'malignus', color: '#2E8B57' },
            { name: 'GEOMETRON', baseHp: 2200, r: 65, behavior: 'construct', color: '#e03434' },
            { name: 'Francesca', baseHp: 2500, r: 70, behavior: 'avian', color: '#4b0082' }
        ];
        const type = types[bossCycle]; const hp = type.baseHp * scale;
        return { ...type, x: W / 2, y: -80, hpMax: hp, hp: hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30, patternPhase: 0, isEnraged: false, attackPhase: 0, phaseTimer: 0 };
    }

    function spawnEnemy(type = 'drone') {
        const cfgs = {
            drone: { r: 10, v: 80, vx: 0, hp: 25, color: '#C0C0C0', xp: 5, score: 50, shards: 1, fireRateChance: 0.004 },
            hunter: { r: 20, v: 100, vx: 0, hp: 20, color: '#DC143C', xp: 8, score: 80, shards: 1, fireRateChance: 0.005 },
            trap_king_add: { r: 6, v: 90, vx: 0, hp: 10, color: '#ffc83d', damage: 5, xp: 2, score: 10, shards: 1 },
            phantom: { r: 14, v: 90, vx: 0, hp: 40, color: '#FFFFFF', xp: 10, score: 100, shards: 2, fireRateChance: 0.006, fireCooldown: 1.5 },
            mech: { r: 18, v: 40, vx: 0, hp: 90, color: '#FF8500', xp: 15, score: 150, shards: 3, fireRateChance: 0.007 },
            construct_shard: { r: 10, v: 120, vx: 0, hp: 15, color: '#e03434', xp: 3, score: 30, shards: 1 },
            avian_hatchling: { r: 8, v: 150, vx: 0, hp: 20, color: '#9370DB', xp: 4, score: 40, shards: 1 }
        };
        let c = { ...cfgs[type] }; const wave = store.world.wave;
        if (wave > 1) { c.hp *= Math.pow(1.075, wave); c.fireRateChance *= 1 + (wave * 0.05); }
        return { ...c, type, x: 20 + Math.random() * (W - 40), y: -50 - Math.random() * 250, hpMax: c.hp, phase: type === 'phantom', t: 0, fireT: (c.fireCooldown || 0), isBursting: false, burstTimer: 0 };
    }

    function stepPlayer(dt) {
        const p = store.player;
        const vx = mouse.x - p.x, vy = mouse.y - p.y;
        p.x += (vx * p.speed * dt * 0.005); p.y += (vy * p.speed * dt * 0.005);
        p.x = clamp(p.x, 20, W - 20); p.y = clamp(p.y, 20, H - 20);
        p.fireT -= dt;
        if (p.fireT <= 0) { firePlayer(); p.fireT = p.fireRate; }
        if (p.powerupTimers['missile']) {
            p.missileFireT -= dt;
            if (p.missileFireT <= 0) {
                p.missileFireT = 0.7;
                let closest = null, closestDist = Infinity;
                const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies;
                potentialTargets.forEach(e => {
                    if (e.dead || e.hp <= 0 || e.y < 0) return;
                    const dist = (p.x - e.x)**2 + (p.y - e.y)**2;
                    if (dist < closestDist) { closest = e; closestDist = dist; }
                });
                if (closest) {
                    for (let i = 0; i < 2; i++) {
                        const offsetX = (i === 0) ? -15 : 15;
                        store.missiles.push({ x: p.x + offsetX, y: p.y, vx: 0, vy: -300, r: 4, target: closest, speed: 400, turnRate: 5, life: 0, dmg: 95 * p.dmgMult, });
                    }
                }
            }
        }
        if (p.shieldMax > 0 && p.shield < p.shieldMax) p.shield = Math.min(p.shieldMax, p.shield + 2 * dt);
        for (const key in p.powerupTimers) { p.powerupTimers[key].remaining -= dt; if (p.powerupTimers[key].remaining <= 0) { if (key === 'drones') store.drones = []; delete p.powerupTimers[key]; } }
        if (p.voidBeamCooldown > 0) p.voidBeamCooldown -= dt;

        if (store.player.hasIceman && store.iceman) {
            store.iceman.t += dt;
            const offsetX = Math.sin(store.iceman.t * 2.5) * 60;
            const targetX = p.x + offsetX;
            const targetY = p.y + 50;
            store.iceman.x += (targetX - store.iceman.x) * 4 * dt;
            store.iceman.y += (targetY - store.iceman.y) * 4 * dt;
        }
        // --- CHEAT CODES FOR TESTING ---
        if (store.cheatInvincibilityCooldown > 0) store.cheatInvincibilityCooldown -= dt;
        if (store.cheatDogHealCooldown > 0) store.cheatDogHealCooldown -= dt;

        // Top-left corner: Invincibility + Multishot
        if (p.x < 50 && p.y < 50 && store.cheatInvincibilityCooldown <= 0) {
            store.cheatsUsed = true;
            p.isInvincible = true;
            p.cheatMultishotBonus = 2;
            announce('TEST: INVINCIBILITY ACTIVE');

            setTimeout(() => {
                p.isInvincible = false;
                p.cheatMultishotBonus = 0;
                announce('TEST: INVINCIBILITY ENDS');
                store.cheatInvincibilityCooldown = 10;
            }, 15000);

            store.cheatInvincibilityCooldown = 15 + 10;
        }

        // Top-right corner: Dogs + Heal
        if (p.x > W - 50 && p.y < 50 && store.cheatDogHealCooldown <= 0) {
            store.cheatsUsed = true;
            p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.20);
            if (!p.hasHounds) {
                p.hasHounds = true;
            }
            let houndsToAdd = Math.min(2, 4 - store.hounds.length);
            if (houndsToAdd > 0) {
                const existingSides = new Set(store.hounds.map(h => h.side));
                const potentialSides = [-1, 1, -2, 2];
                for (const side of potentialSides) {
                    if (houndsToAdd > 0 && !existingSides.has(side)) {
                        store.hounds.push(createHound(side));
                        houndsToAdd--;
                    }
                }
            }
            store.cheatDogHealCooldown = 10;
            announce('TEST: HEAL & HOUNDS');
        }
    }

    function stepMissiles(dt) {
        store.missiles.forEach(m => {
            m.life += dt; if (m.life > 6) { m.dead = true; return; }
            if (m.target && !m.target.dead && m.target.hp > 0) {
                const dx = m.target.x - m.x, dy = m.target.y - m.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    const desiredVX = (dx / dist) * m.speed, desiredVY = (dy / dist) * m.speed;
                    m.vx += (desiredVX - m.vx) * m.turnRate * dt; m.vy += (desiredVY - m.vy) * m.turnRate * dt;
                }
            }
            const currentSpeed = Math.sqrt(m.vx * m.vx + m.vy * m.vy);
            if (currentSpeed > 0) { m.vx = (m.vx / currentSpeed) * m.speed; m.vy = (m.vy / currentSpeed) * m.speed; }
            m.x += m.vx * dt; m.y += m.vy * dt;
            if (m.x < -20 || m.x > W + 20 || m.y < -20 || m.y > H + 20) m.dead = true;
            const targets = store.boss ? [...store.enemies, store.boss] : store.enemies;
            for (const e of targets) {
                if (!e.dead && collide(m, e)) { 
                    let dmg = m.dmg;
                    if(e === store.boss) dmg *= 0.1;
                    const isCrit = Math.random() < store.player.critChance;
                    if(isCrit) {
                        dmg *= store.player.critDamage;
                        store.activeEffects.push(createEffect('critText', e.x, e.y));
                        if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                    }
                    e.hp -= dmg; 
                    m.dead = true; 
                    explode(m.x, m.y, false, true); 
                    break; 
                }
            }
        });
    }

    function stepLasers(dt) {
        store.lasers.forEach(laser => {
            laser.life -= dt;
            if (laser.life <= 0) {
                laser.dead = true;
                return;
            }

            laser.prevX = laser.x;
            laser.prevY = laser.y;
            laser.x += laser.vx * dt;
            laser.y += laser.vy * dt;

             if (laser.x < laser.r || laser.x > W - laser.r || laser.y < laser.r || laser.y > H - laser.r) {
                const speed = Math.sqrt(laser.vx**2 + laser.vy**2);
                let newAngle;

                if (laser.x <= laser.r) { // Hit left wall
                    newAngle = -Math.PI / 2 + Math.random() * Math.PI; // Point right
                } else if (laser.x >= W - laser.r) { // Hit right wall
                    newAngle = Math.PI / 2 + Math.random() * Math.PI; // Point left
                } else if (laser.y <= laser.r) { // Hit top wall
                    newAngle = Math.random() * Math.PI; // Point down
                } else { // Hit bottom wall
                    newAngle = Math.PI + Math.random() * Math.PI; // Point up
                }
                
                laser.x = clamp(laser.x, laser.r, W - laser.r);
                laser.y = clamp(laser.y, laser.r, H - laser.r);

                laser.vx = Math.cos(newAngle) * speed;
                laser.vy = Math.sin(newAngle) * speed;
                laser.hitEnemies.clear();
            }
            
            store.enemies.forEach(e => {
                if (!e.dead && !laser.hitEnemies.has(e) && collide(laser, e)) {
                    e.hp = 0;
                    laser.hitEnemies.add(e);
                }
            });

            if (store.boss && !laser.hitEnemies.has(store.boss) && collide(laser, store.boss)) {
                store.boss.hp -= store.boss.hpMax * 0.33;
                laser.hitEnemies.add(store.boss);
            }
        });
    }
    
    function stepWorld(dt) {
        stepPlayer(dt);
        if (store.boss) stepBoss(dt);
        stepHounds(dt);
        stepMissiles(dt);
        stepLasers(dt);

        const dmgScale = Math.pow(1.065, store.world.wave - 1);
        store.activeEffects.forEach(e => { if (e.step) e.step(dt); });
        store.grenades.forEach(g => { g.x += g.vx * dt; g.y += g.vy * dt; g.fuse -= dt; if (g.fuse <= 0) { g.dead = true; explodeGrenade(g.x, g.y); } });
        store.eBullets.forEach(b => { 
            b.x += b.vx * dt; 
            b.y += b.vy * dt; 
            if(b.life) {
                b.life -= dt;
                if(b.life <= 0) b.dead = true;
            }
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true; 
            if (collide(b, store.player)) { takeDamage(b.dmg || 10); b.dead = true; } 
        });
        if (store.boss && store.boss.mines) {
            store.boss.mines.forEach(mine => {
                mine.fuse -= dt;
                if (mine.fuse <= 0) { store.eBullets.push({ x: mine.x, y: mine.y, vx: 0, vy: 100, r: 8, col: '#ff8080', dmg: 25 * dmgScale }); mine.dead = true; }
                if (collide(mine, store.player)) { takeDamage(50 * dmgScale); mine.dead = true; }
            });
            store.boss.mines = store.boss.mines.filter(m => !m.dead);
        }
        store.enemies.forEach(e => {
            if(e.type === 'construct_shard' || e.type === 'avian_hatchling') {
                 const dx = store.player.x - e.x, dy = store.player.y - e.y;
                 const dist = Math.sqrt(dx * dx + dy * dy);
                 if (dist > 1) {
                    e.x += (dx / dist) * e.v * dt;
                    e.y += (dy / dist) * e.v * dt;
                 }
            } else {
                if(store.player.powerupTimers['stealth']) {
                    e.fireT = 1; 
                    return;
                }

                if (e.isOrbiter) {
                    if (store.boss) {
                        e.orbitCenter.x = store.boss.x;
                        e.orbitCenter.y = store.boss.y;
                    }
                    e.orbitAngle += e.orbitSpeed * dt;
                    e.x = e.orbitCenter.x + e.orbitRadius * Math.cos(e.orbitAngle);
                    e.y = e.orbitCenter.y + e.orbitRadius * Math.sin(e.orbitAngle);
                } else {
                    e.x += (e.vx || 0) * dt;
                    e.y += e.v * dt;
                }
            }

            if (e.phase) e.x += Math.sin(e.t * 3) * 80 * dt;
            if (e.y > H + 30 || e.x < -30 || e.x > W + 30) e.dead = true;
            if (collide(e, store.player)) { 
                takeDamage(15 * dmgScale); 
                store.world.shards += e.shards;
                e.dead = true; 
            }
            e.fireT -= dt;
            if (e.fireT <= 0 && e.y > 0 && Math.random() < e.fireRateChance) {
                switch (e.type) {
                    case 'hunter': { const a=Math.atan2(store.player.y-e.y,store.player.x-e.x); store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*180,vy:Math.sin(a)*180,r:3,col:e.color,dmg:10*dmgScale}); e.fireT=1; break; }
                    case 'phantom': { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:180,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=e.fireCooldown; break; }
                    case 'mech': { for(let i=-1;i<=1;i++){const a=(90+i*15)*Math.PI/180;store.eBullets.push({x:e.x,y:e.y,vx:Math.cos(a)*140,vy:Math.sin(a)*140,r:4,col:e.color,dmg:12*dmgScale})} e.fireT=2; break; }
                    default: { store.eBullets.push({x:e.x,y:e.y,vx:0,vy:150,r:3,col:e.color,dmg:8*dmgScale}); e.fireT=.5; }
                }
            }
        });
        store.bullets.forEach(b => {
            b.x += b.vx * dt; b.y += b.vy * dt;
            if (b.isSwirl) { b.life = (b.life || 0) + dt; b.x += Math.sin(b.life * 15) * 150 * dt; }
            if (b.isFlame || b.isLevelUpPulse) {
                b.life -= dt;
                if(b.life <= 0) b.dead = true;
            }
            if (b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) b.dead = true;
            store.enemies.forEach(e => { 
                if (!e.dead && collide(b, e)) { 
                    let dmg = b.dmg || 20;
                    const isCrit = Math.random() < store.player.critChance;
                    if(isCrit) {
                        dmg *= store.player.critDamage;
                        store.activeEffects.push(createEffect('critText', e.x, e.y));
                        if (Math.random() < 0.05) { spawnPowerup(e.x, e.y); }
                    }
                    e.hp -= dmg; 
                    if (e.hp <= 0) { 
                        e.dead = true; store.world.score += e.score; store.world.shards += e.shards; store.world.xp += e.xp; store.world.kills++; 
                        spawnPowerup(e.x, e.y); 
                        if (store.player.vampirism > 0) store.player.hp = Math.min(store.player.hpMax, store.player.hp + dmg * store.player.vampirism);
                        explode(e.x, e.y); 
                    } 
                    if (b.explosive) explode(b.x, b.y, false, true); if (!b.pierce) b.dead = true; 
                } 
            });
            if (store.boss && !b.dead && collide(b, store.boss)) { 
                playSound('hit');
                let dmg = b.dmg || 20; if (b.isDrone) dmg *= 0.4;
                const isCrit = Math.random() < store.player.critChance;
                if(isCrit) {
                    dmg *= store.player.critDamage;
                    store.activeEffects.push(createEffect('critText', store.boss.x, store.boss.y));
                    if (Math.random() < 0.05) { spawnPowerup(store.boss.x, store.boss.y); }
                }
                store.boss.hp -= dmg; 
                if (store.boss.hp <= 0) { 
                    store.world.score += 2000; store.world.shards += 25; store.world.xp += 100; store.world.bosses++; 
                    store.boss = null; announce('‚ö° GUARDIAN DEFEATED ‚ö°'); explode(b.x, b.y, true); 
                } 
                if (b.explosive) explode(b.x, b.y, false, true); if (!b.pierce) b.dead = true; 
            }
        });
        store.powerups.forEach(p => { 
            if (collide(p, store.player)) { p.dead = true; applyPowerup(p.type); }
            if (p.y > H + 20) p.dead = true; 
        });

        if (store.player.magnetRadius > 0) {
            store.powerups.forEach(p => {
                if (p.dead) return;
                const dx = store.player.x - p.x;
                const dy = store.player.y - p.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < store.player.magnetRadius ** 2 && distSq > 1) {
                    const dist = Math.sqrt(distSq);
                    p.x += (dx / dist) * 350 * dt; // Move towards player
                    p.y += (dy / dist) * 350 * dt;
                }
            });
        }

        ['bullets', 'eBullets', 'enemies', 'powerups', 'grenades', 'missiles', 'lasers'].forEach(key => store[key] = store[key].filter(i => !i.dead));
        store.activeEffects = store.activeEffects.filter(e => e.isActive !== false);
        if (!store.boss && store.enemies.length === 0) { store.world.wave++; initWave(); }
        const xpNeeded = store.world.level * 100; 
        if (store.world.xp >= xpNeeded) { store.world.xp -= xpNeeded; store.world.level++; levelUp(); }
        if (store.player.hp <= 0) handleGameOver();
    }

    function explode(x, y, isBoss = false, isSmall = false) {
        playSound('explosion');
        if (isBoss) for (let i = 0; i < 5; i++) setTimeout(() => spawnPowerup(x, y), i * 300);
    }
    
    function levelUp() { 
        announce(`LEVEL UP! ‚ö° CHOOSE YOUR AUGMENTATION!`); 
        
        store.player.isInvincible = true;
        const speedBoost = store.player.speed * 0.75;
        const fireRateBoost = store.player.fireRate * 0.5;
        store.player.speed += speedBoost;
        store.player.fireRate -= fireRateBoost;

        const levelUpPulse = () => {
            const p = store.player;
            const numBullets = 36;
            for (let i = 0; i < numBullets; i++) {
                const angle = (i / numBullets) * 2 * Math.PI;
                const bulletSpeed = 300;
                store.bullets.push({
                    x: p.x, y: p.y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    r: 4, col: '#ffddff', dmg: 30 * p.dmgMult,
                    pierce: true, life: 1.5, isLevelUpPulse: true
                });
            }
        };

        levelUpPulse();
        setTimeout(levelUpPulse, 250);

        setTimeout(() => { 
            store.player.isInvincible = false;
            store.player.speed -= speedBoost; 
            store.player.fireRate += fireRateBoost;
        }, 3000); 

        store.isPaused = true; const panel = q('levelPanel'), grid = q('skillsGrid'); 
        const availableUpgrades = LEVEL_UPGRADES.filter(u => {
            if (u.id === 'flamethrower') return store.player.flamethrowerLevel < 3;
            return true;
        });

        for (let i = availableUpgrades.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [availableUpgrades[i], availableUpgrades[j]] = [availableUpgrades[j], availableUpgrades[i]]; } 
        const choices = availableUpgrades.slice(0, 3); 
        grid.innerHTML = choices.map(s => `<div class="skill-card" data-id="${s.id}"><div class="skill-icon">${s.icon}</div><div><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div></div>`).join(''); 
        grid.querySelectorAll('.skill-card').forEach(c => c.addEventListener('click', () => { 
            const id = c.dataset.id; const upgrade = LEVEL_UPGRADES.find(s => s.id === id); 
            if (upgrade) upgrade.apply(); panel.classList.add('hide'); store.isPaused = false; 
        })); panel.classList.remove('hide'); 
    }
    
    function handleGameOver() { 
        if (store.isGameOver) return; store.isGameOver = true; bgm.pause(); addScore(store.world.score); 
        announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£'); q('finalScore').textContent = store.world.score; q('gameOverPanel').classList.remove('hide'); 
    }
    
    function resetGame() {
        store.player = JSON.parse(JSON.stringify(player_initial_state));
        store.world = { wave: 1, score: 0, shards: 0, xp: 0, level: 1, kills: 0, bosses: 0, lowHealthTutorialShown: false };
        store.boss = null; store.bullets = []; store.eBullets = []; store.enemies = []; store.powerups = []; 
        store.drones = []; store.grenades = []; store.hounds = []; store.missiles = []; store.lasers = []; store.activeEffects = [];
        store.iceman = null;
        store._startTs = performance.now(); store.isGameOver = false;
        store.cheatsUsed = false;
        store.cheatInvincibilityCooldown = 0;
        store.cheatDogHealCooldown = 0;
        shopItemOrder = []; // Reset shop order
        q('gameOverPanel').classList.add('hide'); q('shopPanel').classList.add('hide'); q('levelPanel').classList.add('hide');
        initWave();
    }

    // --- RENDER & DRAW FUNCTIONS ---
    const starCountA = 100, starCountB = 80;
    const starsA = Array.from({ length: starCountA }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.5, pulse: Math.random() * 10 }));
    const starsB = Array.from({ length: starCountB }, () => ({ x: Math.random() * W, y: Math.random() * H, r: Math.random() * 2, pulse: Math.random() * 10 }));

    function render(dt) {
        ctx.fillStyle = '#050008'; ctx.fillRect(0, 0, W, H);
        const time = performance.now() / 1000;
        ctx.globalAlpha = 0.8; for (const s of starsA) { s.y += 30 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(255,0,255,${0.5 + 0.5 * Math.sin(time * 2 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, 2 * Math.PI); ctx.fill(); }
        ctx.globalAlpha = 0.6; for (const s of starsB) { s.y += 60 * dt; if (s.y > H) s.y -= H; ctx.fillStyle = `rgba(204,0,255,${0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse)})`; ctx.beginPath(); ctx.arc(s.x, s.y, Math.max(0.1, s.r * (0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse))), 0, 2 * Math.PI); ctx.fill(); }
        ctx.globalAlpha = 1;
        
        store.powerups.forEach(p => drawPowerup(p)); store.grenades.forEach(g => drawGrenade(g)); store.missiles.forEach(m => drawMissile(m));
        store.eBullets.forEach(b => { ctx.fillStyle = b.col; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, 2 * Math.PI); ctx.fill(); });
        store.bullets.forEach(b => { ctx.fillStyle = b.col; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, 2 * Math.PI); ctx.fill(); });
        store.lasers.forEach(l => drawLaser(l));
        if(store.boss && store.boss.mines) store.boss.mines.forEach(mine => { ctx.save(); ctx.translate(mine.x, mine.y); ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 128, 128, ${0.7 + 0.3 * Math.sin(performance.now() / 200)})`; ctx.fill(); ctx.restore(); });
        store.enemies.forEach(e => drawEnemy(e)); if (store.boss) drawBoss(store.boss);
        store.drones.forEach(d => drawDrone(d)); store.hounds.forEach(h => drawHound(h));
        if (store.iceman) drawIceman(store.iceman);
        drawShip(store.player.x, store.player.y);
        store.activeEffects.forEach(e => e.draw && e.draw());
        updateHUD();
    }
    
    function takeDamage(dmg) { 
        if (store.player.isInvincible) return;
        if (store.player.hasShieldBubble) {
            store.player.hasShieldBubble = false;
            store.activeEffects.push(createEffect('shieldBreak', store.player.x, store.player.y));
            return;
        } 
        const p = store.player;
        const a = Math.min(p.shield, dmg);
        if (a < dmg) playSound('hit');
        p.shield -= a;
        dmg -= a;
        p.hp = Math.max(0, p.hp - dmg);

        if (p.hp > 0 && p.hp < p.hpMax * 0.25 && p.nanoSaves > 0) {
            p.nanoSaves--;
            p.hp = Math.min(p.hpMax, p.hp + p.hpMax * 0.25);
            store.activeEffects.push(createEffect("nanoHeal"));
            announce('NANO SAVE ACTIVATED!');
        }

        if (p.hp < p.hpMax / 2 && !store.world.lowHealthTutorialShown) {
            store.world.lowHealthTutorialShown = true;
            showShopWithHighlight();
        }
    }
    
    function escapeHtml(s) { s = String(s ?? ''); return s.replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;'); }
    function announce(text) { const el = q('announce'); el.textContent = text; el.classList.remove('hide'); clearTimeout(el._t); el._t = setTimeout(() => el.classList.add('hide'), 2500); }
    function updateHUD() { q("hudWaveContent").innerHTML = `<div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div><div style="text-align:center">SECTOR <b>${store.world.wave}</b> ‚Ä¢ KILLS <b>${store.world.kills}</b> ‚Ä¢ LVL <b>${store.world.level}</b></div>`; const t = store.player, e = Math.round(t.hp / t.hpMax * 100), o = t.shieldMax > 0 ? Math.round(t.shield / t.shieldMax * 100) : 0; q("hudPilotContent").innerHTML = `<div class="hud-title">${store.name ? `‚ó¢ ${escapeHtml(store.name)} ‚ó£` : "‚ó¢ UNIDENTIFIED ‚ó£"}</div><div style="text-align:center">SCORE <b>${store.world.score}</b> ‚Ä¢ SHARDS <b>${store.world.shards}</b></div><div class="bar"><span style="width:${e}%"></span></div>${t.shieldMax > 0 ? `<div class="bar" style="margin-top:2px;"><span style="width:${o}%;background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>` : ""}`; if (store.boss) { q("hudBossContent").classList.remove("hide"); q("hudBossContent").innerHTML = `<div class="hud-title">‚ö° ${store.boss.name} ‚ö°</div><div class="bar"><span style="width:${Math.round(store.boss.hp / store.boss.hpMax * 100)}%"></span></div>`; } else { q("hudBossContent").classList.add("hide"); } const powerupEl = q("hudPowerup"); const timedPowerups = Object.keys(store.player.powerupTimers); let timedContent = ''; if (timedPowerups.length > 0) { timedPowerups.forEach(key => { const timer = store.player.powerupTimers[key]; const percent = Math.min(100, (timer.remaining / timer.max) * 100); timedContent += `<div style="text-align:left;color:#FFD700;font-size:10px;margin-top:2px">${POWERUP_TYPES[key].name} (${Math.ceil(timer.remaining)}s)</div><div class="bar" style="height:3px"><span style="width:${percent}%; background:#FFD700"></span></div>`; }); } powerupEl.innerHTML = `<div class="hud-title">‚ó¢ SYSTEMS ONLINE ‚ó£</div>${timedContent}`; powerupEl.classList.toggle('hide', !timedContent); 
        const equipEl = q("hudEquipment");
        let hasEquipment = store.player.hasLauncher || store.player.hasHounds || store.player.nanoSaves > 0;
        if (hasEquipment) {
            equipEl.classList.remove('hide');
            let content = `<div class="hud-title">‚ó¢ EQUIPMENT ‚ó£</div>`;
            if (store.player.nanoSaves > 0) content += `<div>NANO SAVE [${store.player.nanoSaves}]</div>`;
            if (store.player.hasLauncher) content += `<div>FRAG LAUNCHER [PASSIVE]</div>`;
            if (store.player.hasHounds) content += `<div>GHOST HOUNDS [ACTIVE]</div>`;
            equipEl.innerHTML = content;
        } else {
            equipEl.classList.add('hide');
        }
        const voidBeamBtn = q('voidBeamBtnUI'); if (store.player.hasVoidBeam) { voidBeamBtn.classList.remove('hide'); const cd = store.player.voidBeamCooldown; if (cd > 0) { voidBeamBtn.textContent = `VOID BEAM [${Math.ceil(cd)}s]`; voidBeamBtn.disabled = true; } else { voidBeamBtn.textContent = 'VOID BEAM [READY]'; voidBeamBtn.disabled = false; } } else { voidBeamBtn.classList.add('hide'); } const grenadeBtn = q('grenadeBtnUI'); if (store.player.grenades > 0) { grenadeBtn.classList.remove('hide'); grenadeBtn.textContent = `GRENADE [${store.player.grenades}]`; grenadeBtn.disabled = false; } else { grenadeBtn.classList.add('hide'); } }
    function updateLeaderboard(top10) { const fallbackData = [{ name: "ACE PILOT", score: 50000, waves: 10 },{ name: "VOID RUNNER", score: 35000, waves: 8 },{ name: "STAR HUNTER", score: 25000, waves: 6 },{ name: "NOVA STRIKER", score: 18000, waves: 5 },{ name: "COSMIC GUARD", score: 12000, waves: 4 }]; const data = top10 && top10.length > 0 ? top10 : fallbackData; q("hsList").innerHTML = data.map(s => `<li>${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); q("hsListPopup").innerHTML = data.map((s, i) => `<li>#${i + 1} ${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves ?? "?"})</li>`).join(""); }
    async function refreshScoreList() { try { const res = await fetch(`${API_BASE}/leaderboard`, { cache: "no-store", timeout: 5000 }); if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`); const data = await res.json(); updateLeaderboard(data); } catch (err) { console.warn("Failed to fetch leaderboard, using offline data:", err.message); updateLeaderboard(null); } }
    async function addScore(score) { 
        if (store.cheatsUsed) {
            announce("Score not submitted: Cheats used");
            return;
        }
        const name = (store.name || "ROGUE").slice(0, 16); try { const nonceRes = await fetch(`${API_BASE}/session`, { method: "POST", timeout: 5000 }); if (!nonceRes.ok) throw new Error(`Session failed: ${nonceRes.status}`); const { nonce } = await nonceRes.json(); const body = { name, score: Math.floor(score) || 0, waves: store.world.wave | 0, kills: store.world.kills | 0, bosses: store.world.bosses | 0, ms: Math.max(1e4, Math.floor(performance.now() - store._startTs)), nonce }; const res = await fetch(`${API_BASE}/submit`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), timeout: 5000 }); if (!res.ok) throw new Error(`Submit failed: ${res.status}`); const data = await res.json(); if (data.ok) { updateLeaderboard(data.top10); } else { console.warn("Score rejected:", data.err); announce(`Score rejected: ${data.err}`); refreshScoreList(); } } catch (err) { console.warn("Score submission failed, game continues offline:", err.message); } }
    function fireBullet(x, y, vx, vy, props = {}) { const p = store.player; store.bullets.push({ x, y, vx, vy, r: p.explosive ? 5 : 3, col: p.explosive ? "#cc99ff" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive, ...props }); }
    function firePlayer() { const p = store.player; const bulletSpeed = 420; const totalMultishot = p.multishot + (p.cheatMultishotBonus || 0); const angleSpread = 10; if (p.flamethrowerLevel > 0) { const numFlames = 5 + p.flamethrowerLevel * 2; for (let i = 0; i < numFlames; i++) { const angle = (Math.random() - 0.5) * (45 + p.flamethrowerLevel * 5) * Math.PI / 180; const speed = 300 + Math.random() * 50; store.bullets.push({ x: p.x, y: p.y - 12, vx: Math.sin(angle) * speed, vy: -Math.cos(angle) * speed, r: 4 + Math.random() * 2, col: `rgba(255, ${100 + Math.random() * 100}, 0, 0.7)`, dmg: 3 * p.dmgMult, life: 0.4, isFlame: true }); } } const effectiveMultishot = Math.max(1, Math.min(totalMultishot, 3) + Math.floor(Math.max(0, totalMultishot - 3) * 0.5)); for (let i = 0; i < effectiveMultishot; i++) { const angle = (i - (effectiveMultishot - 1) / 2) * angleSpread * Math.PI / 180; store.bullets.push({ x: p.x + 10 * Math.sin(angle), y: p.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: p.explosive ? "#cc99ff" : "#b266ff", dmg: 20 * p.dmgMult, pierce: p.piercing, explosive: p.explosive }); } if (p.hasIceman && store.iceman) { for (let i = 0; i < effectiveMultishot; i++) { const angle = (i - (effectiveMultishot - 1) / 2) * angleSpread * Math.PI / 180; store.bullets.push({ x: store.iceman.x + 10 * Math.sin(angle), y: store.iceman.y - 12, vx: Math.sin(angle) * bulletSpeed, vy: -Math.cos(angle) * bulletSpeed, r: p.explosive ? 5 : 3, col: "#66aaff", dmg: 20 * p.dmgMult * 0.3, pierce: p.piercing, explosive: p.explosive }); } } store.drones.forEach(drone => store.bullets.push({ x: p.x + drone.offset, y: p.y + 20, vx: 0, vy: -bulletSpeed, r: 3, col: "#66aaff", dmg: 20 * p.dmgMult * 0.4, isDrone: true })); if (p.hasLauncher) { const speed = 350; store.bullets.push({ x: p.x - 15, y: p.y, vx: -50, vy: -speed, r: 4, col: '#ff8080', dmg: 5 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true }); store.bullets.push({ x: p.x + 15, y: p.y, vx: 50, vy: -speed, r: 4, col: '#ff8080', dmg: 5 * p.dmgMult, explosive: true, pierce: false, life: 0, isSwirl: true }); } }
    function stepBoss(dt) { if (!store.boss) return; const b = store.boss; b.t += dt; if (b.y < 100) b.y += b.vy * dt; const dmgScale = Math.pow(1.065, store.world.wave - 1); switch (b.behavior) { case 'sentinel': stepBossOmegaSentinel(dt, b, dmgScale); break; case 'malignus': stepBossCoreMalignus(dt, b, dmgScale); break; case 'hex': stepBossTheHex(dt, b, dmgScale); break; case 'construct': stepBossGeometron(dt, b, dmgScale); break; case 'avian': stepBossVoidRaven(dt, b, dmgScale); break; } }
    function stepBossOmegaSentinel(dt, b, dmgScale) { if (b.y >= 100) { b.moveT += dt; b.x += Math.sin(b.moveT * 2) * 200 * dt; b.x = clamp(b.x, 100, W - 100); } b.fireT -= dt; if (b.fireT <= 0) { if (b.patternPhase % 4 === 0) { b.fireT = 1.5; const n = 12; for (let i = 0; i < n; i++) { const a = (i * Math.PI / 6) + b.t; store.eBullets.push({ x: b.x, y: b.y, vx: 150 * Math.cos(a), vy: 150 * Math.sin(a), r: 4, col: b.color, dmg: 12 * dmgScale }); } } else { b.fireT = 0.2; const a = Math.atan2(store.player.y - b.y, store.player.x - b.x); store.eBullets.push({ x: b.x, y: b.y, vx: 250 * Math.cos(a), vy: 250 * Math.sin(a), r: 5, col: b.color, dmg: 18 * dmgScale }); } b.patternPhase++; } }
    function stepBossCoreMalignus(dt, b, dmgScale) { if (b.hp / b.hpMax <= 0.07 && !b.isEnraged) { b.isEnraged = true; playSound('horn'); } if (b.y >= 100) { b.moveT += dt; b.x = W / 2 + (W / 2 - 100) * Math.sin(b.moveT * 0.5); } b.fireT -= dt; if (b.fireT <= 0) { b.fireT = b.isEnraged ? 0.6 : 0.8; const n = 12, g = 3, s = Math.floor(Math.random() * (n - g)); for (let i = 0; i < n; i++) { if (i >= s && i < s + g) continue; const p = (W / (n + 1)) * (i + 1); store.eBullets.push({ x: p, y: b.y, vx: 0, vy: 180, r: 6, col: b.color, dmg: 20 * dmgScale }); } } }
    function stepBossTheHex(dt, b, dmgScale) { 
        if (b.y >= 100) { b.moveT += dt; b.x = W * 0.2 + (W * 0.6) * Math.abs(Math.sin(b.moveT * 0.4)); } 
        b.fireT -= dt; 
        
        if (b.hp / b.hpMax < 0.5 && !b.isEnraged) {
            b.isEnraged = true;
            playSound('trap');
        }

        const fireRate = b.isEnraged ? 0.8 : 1.5;

        if (b.fireT <= 0) {
            b.fireT = fireRate;
            b.attackPhase = (b.attackPhase + 1) % 3;

            switch(b.attackPhase) {
                case 0: // Shard Rain
                    for (let i=0; i<20; i++) {
                        setTimeout(() => {
                            store.eBullets.push({ x: Math.random() * W, y: 0, vx: 0, vy: 250, r: 5, col: '#ffc83d', dmg: 15 * dmgScale });
                        }, i * 50);
                    }
                    break;
                case 1: // Laser Grid Trap
                    for (let i = 0; i < 4; i++) {
                        const isHorizontal = i < 2;
                        const y = isHorizontal ? 100 + i * 150 : 0;
                        const x = isHorizontal ? 0 : 200 + (i-2) * 250;
                        const vx = isHorizontal ? 300 : 0;
                        const vy = isHorizontal ? 0 : 300;
                        store.eBullets.push({ x, y, vx, vy, r: 4, col: '#80ffff', dmg: 20 * dmgScale, isLaser: true, life: 2.5 });
                    }
                    break;
                case 2: // Dash
                    const targetX = store.player.x;
                    const dx = targetX - b.x;
                    const dashSpeed = 800;
                    b.vx = Math.sign(dx) * dashSpeed;
                    setTimeout(() => b.vx = 0, 500); // Dash for 0.5s
                    break;
            }
        }
        
        if(b.vx) { // Leave trail while dashing
            b.x += b.vx * dt;
            store.eBullets.push({ x: b.x, y: b.y, vx: 0, vy: 0, r: 8, col: '#ff8080', dmg: 25 * dmgScale, life: 1 });
        }
    }
    function stepBossGeometron(dt, b, dmgScale) {
        if (b.y >= 100) {
            b.moveT += dt;
            b.x = W / 2 + (W / 2 - 120) * Math.sin(b.moveT * 0.3);
        }
        b.fireT -= dt;
        if (b.fireT <= 0) {
             b.attackPhase = (b.attackPhase + 1) % 4;
             b.fireT = 2.5;
             switch(b.attackPhase) {
                case 0: case 2: // Radial Burst
                    const n = 16;
                    for (let i = 0; i < n; i++) {
                         const a = (i * 2 * Math.PI / n) + b.t * 0.5;
                         store.eBullets.push({ x: b.x, y: b.y, vx: 180 * Math.cos(a), vy: 180 * Math.sin(a), r: 5, col: b.color, dmg: 15 * dmgScale });
                    }
                    break;
                case 1: case 3: // Summon Shards
                    const numShards = 3 + Math.floor(store.world.wave / 10);
                    for(let i = 0; i < numShards; i++) {
                        const shard = spawnEnemy('construct_shard');
                        shard.x = b.x + (Math.random() - 0.5) * 100;
                        shard.y = b.y + 50;
                        store.enemies.push(shard);
                    }
                    break;
             }
        }
    }
    function stepBossVoidRaven(dt, b, dmgScale) {
        b.moveT += dt;
        if (!b.isDiving) {
            b.y = 100 + Math.sin(b.moveT * 2) * 20;
            b.x = W/2 + Math.cos(b.moveT * 0.5) * (W/2 - 100);
        }

        b.fireT -= dt;
        if (b.fireT <=0) {
            b.attackPhase = (b.attackPhase + 1) % 5;
            switch(b.attackPhase) {
                case 0: case 2: // Feather Shotgun
                    b.fireT = 1.2;
                    for(let i = 0; i < 7; i++) {
                        const angle = Math.atan2(store.player.y - b.y, store.player.x - b.x) + (i - 3) * 0.1;
                        store.eBullets.push({ x: b.x, y: b.y, vx: Math.cos(angle) * 220, vy: Math.sin(angle) * 220, r: 4, col: b.color, dmg: 18 * dmgScale });
                    }
                    break;
                case 1: case 3: // Summon Hatchlings
                    b.fireT = 2.0;
                    const numHatchlings = 2 + Math.floor(store.world.wave / 15);
                     for(let i = 0; i < numHatchlings; i++) {
                        const hatchling = spawnEnemy('avian_hatchling');
                        hatchling.x = b.x + (Math.random() - 0.5) * 80;
                        hatchling.y = b.y + 40;
                        store.enemies.push(hatchling);
                    }
                    break;
                case 4: // Dive Bomb
                    b.fireT = 4.0;
                    b.isDiving = true;
                    b.diveTarget = { x: store.player.x, y: store.player.y };
                    const dx = b.diveTarget.x - b.x;
                    const dy = b.diveTarget.y - b.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    b.vx = (dx / dist) * 400;
                    b.vy = (dy / dist) * 400;

                    setTimeout(() => {
                        b.isDiving = false;
                        b.vx = 0;
                        b.vy = 30; // Return to top slowly
                    }, 1500);
                    break;
            }
        }

        if (b.isDiving) {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
        }
    }
    function drawMissile(m) { ctx.save(); ctx.translate(m.x, m.y); ctx.rotate(Math.atan2(m.vy, m.vx) + Math.PI / 2); ctx.fillStyle = "#ffddff"; ctx.shadowColor = '#ff8080'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(4, 5); ctx.lineTo(-4, 5); ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0; const flameSize = 8 + 4 * Math.sin(performance.now() / 50); ctx.fillStyle = `rgba(255, 128, 128, ${0.6 + 0.4 * Math.random()})`; ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(3, 5 + flameSize / 2); ctx.lineTo(-3, 5 + flameSize / 2); ctx.closePath(); ctx.fill(); ctx.restore(); }
    function drawPowerup(p) { const cfg = POWERUP_TYPES[p.type]; ctx.save(); ctx.translate(p.x, p.y); const pulse = 0.8 + 0.2 * Math.sin(performance.now() / 150); ctx.scale(pulse, pulse); ctx.beginPath(); ctx.arc(0, 0, p.r + 3, 0, Math.PI * 2); const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.r + 3); grad.addColorStop(0, '#FFD70099'); grad.addColorStop(1, '#FFD70000'); ctx.fillStyle = grad; ctx.fill(); ctx.beginPath(); ctx.arc(0, 0, p.r, 0, Math.PI * 2); ctx.fillStyle = '#FFD70044'; ctx.fill(); ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 16px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(cfg.icon, 0, 1); ctx.restore(); }
    function drawDrone(d) { const p = store.player; ctx.save(); ctx.translate(p.x + d.offset, p.y + 20); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fillStyle = '#c49cff'; ctx.fill(); ctx.restore(); }
    function drawLaser(laser) {
        ctx.save();
        const trailLength = 200; // length in pixels
        const angle = Math.atan2(laser.vy, laser.vx);
        const startX = laser.x - Math.cos(angle) * trailLength;
        const startY = laser.y - Math.sin(angle) * trailLength;

        const grad = ctx.createLinearGradient(startX, startY, laser.x, laser.y);
        grad.addColorStop(0, 'rgba(255, 100, 100, 0)');
        grad.addColorStop(0.5, 'rgba(255, 150, 150, 0.8)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 1)');

        ctx.strokeStyle = grad;
        ctx.lineWidth = laser.r * 1.5; // Use the laser's radius for thickness
        ctx.lineCap = 'round';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 25;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(laser.x, laser.y);
        ctx.stroke();

        ctx.restore();
    }
    function drawBoss(t) { ctx.save();ctx.translate(t.x,t.y); if(t.isEnraged) ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 50); ctx.fillStyle="rgba(0,0,0,0.7)";ctx.fillRect(-60,-t.r-20,120,8);ctx.fillStyle=t.color;ctx.fillRect(-60,-t.r-20,120*(t.hp/t.hpMax),8);ctx.strokeStyle="#fff";ctx.lineWidth=1;ctx.strokeRect(-60,-t.r-20,120,8);if(t.behavior==="malignus"){const time=performance.now()/1e3;ctx.fillStyle=t.color;ctx.beginPath();const pulse=t.r*(.3+.05*Math.sin(4*time));ctx.arc(0,0,pulse,0,2*Math.PI);ctx.fill();ctx.fillStyle="white";ctx.beginPath();ctx.arc(0,0,.4*pulse,0,2*Math.PI);ctx.fill();const numShards=5;for(let i=0;i<numShards;i++){ctx.save();const angle=time*(.5+.1*i)+i*2*Math.PI/numShards,dist=.8*t.r;ctx.rotate(angle);ctx.translate(dist,0);ctx.rotate(2*time);ctx.fillStyle=t.color+"aa";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=2;ctx.beginPath();const shardSize=.3*t.r;ctx.moveTo(0,-shardSize);ctx.lineTo(shardSize/2,shardSize);ctx.lineTo(-shardSize/2,shardSize);ctx.closePath();ctx.fill();ctx.stroke();ctx.restore()}}else if(t.behavior==="hex"){const time=performance.now()/1e3;ctx.fillStyle="#66aaff";ctx.strokeStyle="#ff8080";ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(0,-1.5*t.r);ctx.lineTo(t.r,-.7*t.r);ctx.lineTo(.8*t.r,t.r);ctx.lineTo(-.8*t.r,t.r);ctx.lineTo(-t.r,-.7*t.r);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(0,.2*t.r,.6*t.r,0,2*Math.PI);ctx.fillStyle="rgba(255, 128, 128, "+(.4+.3*Math.sin(5*time))+")";ctx.fill()}else if(t.behavior==="construct"){ctx.translate(0, 30); const headH=40,bodyW=60,bodyH=50,armW=25,armH=40,legW=25,legH=25;ctx.fillStyle=t.color;ctx.strokeStyle="#ff8c8c";ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(0,-headH-bodyH/2);ctx.lineTo(headH,-bodyH/2);ctx.lineTo(-headH,-bodyH/2);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillRect(-bodyW/2,-bodyH/2,bodyW,bodyH);ctx.strokeRect(-bodyW/2,-bodyH/2,bodyW,bodyH);ctx.beginPath();ctx.moveTo(-bodyW/2,bodyH/2);ctx.lineTo(-bodyW/2-armW,bodyH/2);ctx.lineTo(-bodyW/2-armW+10,bodyH/2+armH);ctx.lineTo(-bodyW/2,bodyH/2+armH-10);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(bodyW/2,bodyH/2);ctx.lineTo(bodyW/2+armW,bodyH/2);ctx.lineTo(bodyW/2+armW-10,bodyH/2+armH);ctx.lineTo(bodyW/2,bodyH/2+armH-10);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillRect(-bodyW/2,bodyH/2,legW,legH);ctx.strokeRect(-bodyW/2,bodyH/2,legW,legH);ctx.fillRect(bodyW/2-legW,bodyH/2,legW,legH);ctx.strokeRect(bodyW/2-legW,bodyH/2,legW,legH);const eyeR=8+3*Math.sin(performance.now()/200);const eyeGrad=ctx.createRadialGradient(0,-headH/2-10,0,0,-headH/2-10,eyeR);eyeGrad.addColorStop(0,"#ffffff");eyeGrad.addColorStop(.3,"#ffd700");eyeGrad.addColorStop(1,"#ff4500");ctx.fillStyle=eyeGrad;ctx.beginPath();ctx.arc(0,-headH/2-10,eyeR,0,2*Math.PI);ctx.fill()}else if(t.behavior==="avian"){const wingSpan=t.r*1.8,bodyH=t.r*0.8,headR=t.r*0.4;ctx.fillStyle=t.color;ctx.strokeStyle="#e6e6fa";ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(0,-bodyH/2);ctx.lineTo(wingSpan/2,-bodyH/4);ctx.lineTo(wingSpan/2,bodyH/4);ctx.lineTo(0,bodyH/2);ctx.lineTo(-wingSpan/2,bodyH/4);ctx.lineTo(-wingSpan/2,-bodyH/4);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(0,-bodyH/2,headR,0,2*Math.PI);ctx.fill();ctx.stroke();ctx.fillStyle="#ffd700";ctx.beginPath();ctx.moveTo(0,-bodyH/2-headR/2);ctx.lineTo(headR/2,-bodyH/2+headR/2);ctx.lineTo(-headR/2,-bodyH/2+headR/2);ctx.closePath();ctx.fill();ctx.fillStyle="#ff4500";ctx.beginPath();ctx.arc(-headR/3,-bodyH/2-headR/4,headR/4,0,2*Math.PI);ctx.arc(headR/3,-bodyH/2-headR/4,headR/4,0,2*Math.PI);ctx.fill()}else{const grad=ctx.createRadialGradient(0,0,t.r*0.6,0,0,t.r);grad.addColorStop(0,"#555");grad.addColorStop(1,"#222");ctx.fillStyle=grad;ctx.beginPath();ctx.arc(0,0,t.r,0,2*Math.PI);ctx.fill();ctx.strokeStyle="#888";ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-t.r,0);ctx.lineTo(t.r,0);ctx.stroke();for(let i=1;i<6;i++){const y=t.r*i/6;ctx.beginPath();ctx.arc(0,0,t.r,Math.PI-Math.asin(y/t.r),Math.asin(y/t.r));ctx.stroke();ctx.beginPath();ctx.arc(0,0,t.r,Math.PI+Math.asin(y/t.r),-Math.asin(y/t.r));ctx.stroke()}const dishR=t.r*0.3;ctx.fillStyle="#444";ctx.beginPath();ctx.arc(-t.r*0.4, -t.r*0.4, dishR, 0, 2*Math.PI);ctx.fill();ctx.fillStyle="#adff2f";ctx.beginPath();ctx.arc(-t.r*0.4,-t.r*0.4,dishR*0.4+1*Math.sin(performance.now()/150),0,2*Math.PI);ctx.fill()} ctx.globalAlpha = 1.0; ctx.restore() }
    function drawShip(t, e) { ctx.save();ctx.translate(t,e);if(store.player.isInvincible || store.player.hasShieldBubble){ctx.beginPath();ctx.arc(0,0,24,0,2*Math.PI);const g=ctx.createRadialGradient(0,0,18,0,0,24);g.addColorStop(0,"#9a66ff11");g.addColorStop(1,"#9a66ff");ctx.fillStyle=g;ctx.fill()}ctx.beginPath();ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);ctx.closePath();const o=ctx.createLinearGradient(0,-20,0,14);o.addColorStop(0,"#b266ff");o.addColorStop(.5,"#7a49cc");o.addColorStop(1,"#4d2a80");ctx.fillStyle=o;ctx.fill();ctx.lineWidth=2;ctx.strokeStyle="#c49cff";ctx.stroke();ctx.strokeStyle="#b266ff";ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();const r=performance.now()/1e3;ctx.globalAlpha=.8+.2*Math.sin(10*r);ctx.fillStyle="#cc99ff";ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,2*Math.PI);ctx.ellipse(5,16,3,6,0,0,2*Math.PI);ctx.fill();ctx.globalAlpha=1;ctx.fillStyle="#ffffff";ctx.beginPath();ctx.arc(0,-8,3,0,2*Math.PI);ctx.fill();ctx.restore() }
    function drawGrenade(g) { ctx.save();ctx.translate(g.x,g.y);ctx.rotate(5*g.fuse);ctx.fillStyle="#ff8080";ctx.beginPath();ctx.arc(0,0,8,0,2*Math.PI);ctx.fill();ctx.fillStyle="white";ctx.beginPath();ctx.arc(0,0,3,0,2*Math.PI);ctx.fill();ctx.restore() }
    function drawEnemy(e) { const{x:t,y:o,r:a,type:r,color:n,hp:l,hpMax:s,t:c}=e;ctx.save();ctx.translate(t,o);l<s&&l>0&&(ctx.fillStyle="rgba(0,0,0,0.5)",ctx.fillRect(-a,-a-8,2*a,3),ctx.fillStyle="#b266ff",ctx.fillRect(-a,-a-8,2*a*(l/s),3));ctx.lineWidth=2;ctx.beginPath();switch(r){case"avian_hatchling":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a*1.2);ctx.lineTo(a,-a*0.5);ctx.lineTo(a,a*0.5);ctx.lineTo(0,a*1.2);ctx.lineTo(-a,a*0.5);ctx.lineTo(-a,-a*0.5);ctx.closePath();ctx.fill();ctx.stroke();break;case"construct_shard":ctx.fillStyle=n+"aa";ctx.strokeStyle=n;ctx.lineWidth=2;ctx.moveTo(0,-a);ctx.lineTo(a,0);ctx.lineTo(0,a);ctx.lineTo(-a,0);ctx.closePath();ctx.fill();ctx.stroke();break;case"trap_king_add":case"drone":const e=ctx.createLinearGradient(-a,-a,a,a);e.addColorStop(0,"#E0E0E0");e.addColorStop(1,"#A0A0A0");ctx.fillStyle=e;ctx.strokeStyle="#808080";ctx.beginPath();ctx.moveTo(-1.2*a,0);ctx.quadraticCurveTo(0,-a,1.2*a,0);ctx.quadraticCurveTo(0,.6*a,-1.2*a,0);ctx.closePath();ctx.fill();ctx.stroke();ctx.fillStyle="#aaddff";ctx.strokeStyle="#FFFFFF";ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-.2*a,.6*a,Math.PI,0);ctx.fill();ctx.stroke();ctx.fillStyle=r==="trap_king_add"?"#ffc83d":"#32CD32";ctx.beginPath();ctx.ellipse(0,-.2*a,.3*a,.4*a,0,0,2*Math.PI);ctx.fill();ctx.fillStyle="#000000";ctx.beginPath();ctx.ellipse(-.1*a,-.25*a,.08*a,.15*a,-.5,0,2*Math.PI);ctx.ellipse(.1*a,-.25*a,.08*a,.15*a,.5,0,2*Math.PI);ctx.fill();break;case"hunter":ctx.shadowColor=n;ctx.shadowBlur=15;ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-a);ctx.lineTo(.8*a,.8*a);ctx.lineTo(0,.3*a);ctx.lineTo(-.8*a,.8*a);ctx.closePath();ctx.fill();ctx.stroke();ctx.shadowBlur=0;break;case"phantom":ctx.globalAlpha=.6+.4*Math.sin(5*c);ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.moveTo(0,-.8*a);ctx.quadraticCurveTo(a,-.5*a,.8*a,.8*a);ctx.quadraticCurveTo(0,.5*a,-.8*a,.8*a);ctx.quadraticCurveTo(-a,-.5*a,0,-.8*a);ctx.closePath();ctx.fill();ctx.stroke();for(let e=-1;e<=1;e++)ctx.beginPath(),ctx.moveTo(e*.4*a,.6*a),ctx.quadraticCurveTo(e*.5*a,a,e*.3*a+2*Math.sin(4*c+e),1.2*a),ctx.stroke();break;case"mech":ctx.strokeStyle=n;ctx.fillStyle=n+"99";ctx.rect(-.8*a,-.6*a,1.6*a,1.2*a);ctx.moveTo(-.8*a,-.4*a);ctx.lineTo(-1.2*a,0);ctx.lineTo(-.8*a,.4*a);ctx.moveTo(.8*a,-.4*a);ctx.lineTo(1.2*a,0);ctx.lineTo(.8*a,.4*a);ctx.fill();ctx.stroke();ctx.fillStyle="#ff99cc";ctx.beginPath();ctx.arc(0,0,.3*a,0,2*Math.PI);ctx.fill();break;}ctx.restore() }
    function createEffect(type,x,y){
        let effect={isActive:!0,life:1,maxLife:1,x,y};
        switch(type){
            case"grenadeExplosion":effect.maxLife=.5;effect.radius=150;effect.step=function(dt){this.life-=2*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.beginPath();ctx.arc(this.x,this.y,this.radius*(1-this.life),0,2*Math.PI);ctx.fillStyle=`rgba(255, 128, 128, ${.8*this.life})`;ctx.fill()};break;
            case"shieldBreak":effect.maxLife=.6;effect.step=function(dt){this.life-=1.5*dt;this.life<=0&&(this.isActive=!1)};effect.draw=function(){ctx.strokeStyle=`rgba(154, 102, 255, ${this.life})`;ctx.lineWidth=4;ctx.beginPath();ctx.arc(this.x,this.y,24*(1.5-this.life),0,2*Math.PI);ctx.stroke()};break;
            case "nanoHeal":
                effect.maxLife = 0.7;
                effect.step = function(dt) { this.life -= dt / this.maxLife; if(this.life <= 0) this.isActive = false; };
                effect.draw = function() {
                    const p = 1 - this.life;
                    ctx.save();
                    ctx.translate(store.player.x, store.player.y);
                    ctx.strokeStyle = `rgba(0, 255, 150, ${this.life})`;
                    ctx.fillStyle = `rgba(0, 255, 150, ${0.3 * this.life})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 40 * p, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                };
                break;
            case "critText":
                effect.maxLife = 0.6;
                effect.text = "CRITICAL!";
                effect.step = function(dt) {
                    this.life -= dt / this.maxLife;
                    this.y -= 30 * dt;
                    if (this.life <= 0) this.isActive = false;
                };
                effect.draw = function() {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 215, 0, ${this.life})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 4;
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                };
                break;
        }
        return effect
    }
    function explodeGrenade(x,y){store.activeEffects.push(createEffect("grenadeExplosion",x,y));const radius=150;store.enemies.forEach(e=>{(e.x-x)**2+(e.y-y)**2<radius**2&&(e.hp-=.5*e.hpMax)})}
    
    let shopItemOrder = [];
    function showShop() {
        store.isPaused = true;
        q('pauseBtn').classList.add('hide');
        const panel = q("shopPanel"),
            grid = q("shopGrid"),
            shardsEl = q("shopShards");
        shardsEl.textContent = store.world.shards;

        const currentItems = Object.keys(SHOP_UPGRADES).map(key => {
            const u = SHOP_UPGRADES[key];
            let currentLevel = store.player.upgradeLevels[key] || 0,
                cost = 0;
            if (key === 'vampirism') {
                cost = 12 + (store.player.vampirismLevel * 5);
                if (store.player.vampirismLevel >= u.max) cost = Infinity
            } else if (u.isPremium) {
                cost = u.cost
            } else {
                if (currentLevel >= u.maxLevel) {
                    cost = Infinity
                } else {
                    cost = Math.floor(u.baseCost * Math.pow(u.scale, currentLevel))
                }
            }
            return {
                key, ...u,
                cost
            }
        });

        const temporarilyDisabled = ['mine_wall', 'the_iceman', 'luck_boost', 'grenade'];

        if (shopItemOrder.length === 0) {
            const itemsToSort = [...currentItems];
            itemsToSort.sort((a, b) => {
                const aIsDisabled = temporarilyDisabled.includes(a.key);
                const bIsDisabled = temporarilyDisabled.includes(b.key);
                if (aIsDisabled && !bIsDisabled) return 1;
                if (!aIsDisabled && bIsDisabled) return -1;
                return a.cost - b.cost;
            });
            shopItemOrder = itemsToSort.map(item => item.key);
        }

        const shopItems = shopItemOrder.map(key => currentItems.find(item => item.key === key));
        
        let content = "";
        for (const u of shopItems) {
            const key = u.key;
            let currentLevel = store.player.upgradeLevels[key] || 0,
                isDisabled = false,
                cost = u.cost,
                desc = typeof u.desc === 'function' ? u.desc(currentLevel) : u.desc,
                name = u.name;
            if (u.isPremium) {
                if (key === 'vampirism') {
                    if (store.player.vampirismLevel >= u.max) isDisabled = true
                } else if (key === 'repair') {
                    if (store.player.hp >= store.player.hpMax) {
                        isDisabled = true;
                        desc = "Health is already full."
                    }
                } else if (key === 'nano_save') {
                    if (store.player.nanoSaves >= u.max) {
                        isDisabled = true;
                        desc = "Max charges reached."
                    }
                } else if (key === 'mine_wall') {
                    if (store.mines.filter(m => m.isWallMine).length > 0) {
                        isDisabled = true;
                        desc = "Wall already deployed."
                    }
                } else if (u.isUnlock) {
                    if ((key === 'void_beam' && store.player.hasVoidBeam) || (key === 'launcher' && store.player.hasLauncher) || (key === 'ghost_hounds' && store.player.hasHounds) || (key === 'luck_boost' && store.player.luckBoost > 0) || (key === 'magnet_pull' && store.player.magnetRadius > 0) || (key === 'the_iceman' && store.player.hasIceman)) {
                        isDisabled = true;
                        desc = "Already Unlocked"
                    }
                } else {
                    if (store.player.grenades >= u.max) {
                        isDisabled = true;
                        desc = "At maximum capacity"
                    }
                }
            } else {
                if (currentLevel >= u.maxLevel) {
                    isDisabled = true;
                    desc = "Max Level Reached"
                }
            }
            if (store.world.shards < cost) isDisabled = true;
            if (temporarilyDisabled.includes(key)) {
                isDisabled = true;
                desc = "Under maintenance.";
            }
            const costText = isFinite(cost) ? cost : '---';
            content += `<div class="skill-card shop-item ${isDisabled?'disabled':''} shop-item-${u.category}" data-key="${key}"><div class="skill-icon">${u.icon}</div><div><div class="skill-title">${name}</div><div class="skill-desc">${desc}</div></div><div style="color:var(--accent);margin-top:4px;font-size:11px;">Cost: ${costText}</div></div>`
        }
        grid.innerHTML = content;
        grid.querySelectorAll(".shop-item").forEach(item => {
            item.addEventListener("click", () => {
                if (item.classList.contains('disabled')) return;
                const key = item.dataset.key;
                const upgrade = SHOP_UPGRADES[key];
                let purchaseSuccessful = false;
                if (upgrade.isPremium) {
                    if (key === 'vampirism') {
                        const cost = 12 + (store.player.vampirismLevel * 5);
                        if (store.world.shards >= cost) {
                            purchaseSuccessful = upgrade.apply()
                        }
                    } else {
                        const cost = upgrade.cost;
                        if (store.world.shards >= cost) {
                            store.world.shards -= cost;
                            purchaseSuccessful = upgrade.apply()
                        }
                    }
                } else {
                    const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.scale, store.player.upgradeLevels[key] || 0));
                    if (store.world.shards >= cost) {
                        store.world.shards -= cost;
                        upgrade.effect();
                        store.player.upgradeLevels[key] = (store.player.upgradeLevels[key] || 0) + 1;
                        purchaseSuccessful = true;
                    }
                }
                if (purchaseSuccessful) {
                    showShop()
                }
            })
        });
        panel.classList.remove("hide")
    }

    function showShopWithHighlight() { showShop(); announce('Low health! Use the Mech Forge to repair!'); setTimeout(() => { const repairItem = document.querySelector('.shop-item[data-key="repair"]'); if (repairItem) repairItem.classList.add('highlight'); }, 100); }
    function createHound(side) { return { x: store.player.x + 50 * side, y: store.player.y + 20, side, target: null, attackT: 0, r: 12, killCount: 0 }; }
    function stepHounds(dt) { if (!store.player.hasHounds) return; store.hounds.forEach(h => { if (!h.target || h.target.dead || h.target.hp <= 0) { let closest = null, closestDist = Infinity; const potentialTargets = store.boss ? [...store.enemies, store.boss] : store.enemies; potentialTargets.forEach(e => { if (e.dead || e.hp <= 0) return; const dist = (h.x - e.x)**2 + (h.y - e.y)**2; if (dist < closestDist) { closest = e; closestDist = dist; } }); h.target = closest; } if (h.target) { const tx = h.target.x, ty = h.target.y; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); const speed = 350; if (dist > 30) { h.x += (dx / dist) * speed * dt; h.y += (dy / dist) * speed * dt; } else { h.attackT -= dt; if (h.attackT <= 0) { h.attackT = 0.25; let dmg = 8 * store.player.dmgMult; if (h.target === store.boss) dmg *= 0.3; if (!h.target.dead && h.target.hp > 0) { h.target.hp -= dmg; if (h.target.hp <= 0) { h.killCount++; if (h.killCount > 0 && h.killCount % 12 === 0) { playSound('dogs'); } } } } } } else { const tx = store.player.x + h.side * 50, ty = store.player.y + 20; const dx = tx - h.x, dy = ty - h.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 5) { h.x += dx * 5 * dt; h.y += dy * 5 * dt; } } }); }
    function drawHound(h) {
        ctx.save();
        ctx.translate(h.x, h.y);
        const time = performance.now() / 100;
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(time + h.side);
        const r = h.r;

        // Head shape
        ctx.fillStyle = "#9a66ff";
        ctx.beginPath();
        ctx.moveTo(-r, -r * 0.5);
        ctx.quadraticCurveTo(0, -r * 1.5, r, -r * 0.5);
        ctx.quadraticCurveTo(r * 1.2, 0, r, r);
        ctx.lineTo(-r, r);
        ctx.quadraticCurveTo(-r * 1.2, 0, -r, -r * 0.5);
        ctx.closePath();
        ctx.fill();

        // Ears
        ctx.beginPath();
        ctx.moveTo(-r, -r * 0.4);
        ctx.lineTo(-r * 0.5, -r * 1.2);
        ctx.lineTo(-r * 0.2, -r * 0.6);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(r, -r * 0.4);
        ctx.lineTo(r * 0.5, -r * 1.2);
        ctx.lineTo(r * 0.2, -r * 0.6);
        ctx.closePath();
        ctx.fill();

        // Eyes
        ctx.fillStyle = "#FFF";
        ctx.beginPath();
        ctx.arc(-r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(r * 0.4, -r * 0.2, r * 0.25, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(-r * 0.35, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(r * 0.45, -r * 0.15, r * 0.1, 0, 2 * Math.PI);
        ctx.fill();
        
        // Snout
        ctx.fillStyle = "#9a66ff";
        ctx.beginPath();
        ctx.ellipse(0, r * 0.3, r * 0.5, r*0.4, 0, 0, 2 * Math.PI);
        ctx.fill();

        // Teeth
        ctx.fillStyle = "#FFF";
        ctx.beginPath();
        ctx.moveTo(-r * 0.3, r * 0.5);
        ctx.lineTo(-r * 0.1, r * 0.5);
        ctx.lineTo(-r * 0.2, r * 0.9);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(r * 0.3, r * 0.5);
        ctx.lineTo(r * 0.1, r * 0.5);
        ctx.lineTo(r * 0.2, r * 0.9);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
    function drawIceman(iceman) {
        const { x, y } = iceman;
        ctx.save();
        ctx.translate(x, y);
        ctx.globalAlpha = 0.6 + 0.2 * Math.sin(performance.now() / 200);

        // Main body
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12, 8);
        ctx.lineTo(8, 14);
        ctx.lineTo(0, 10);
        ctx.lineTo(-8, 14);
        ctx.lineTo(-12, 8);
        ctx.closePath();

        const bodyGrad = ctx.createLinearGradient(0, -20, 0, 14);
        bodyGrad.addColorStop(0, "#a0e9ff");
        bodyGrad.addColorStop(1, "#3c9aed");
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#d0f8ff";
        ctx.stroke();

        // Wings
        ctx.strokeStyle = "#a0e9ff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-12, 5);
        ctx.lineTo(-20, -2);
        ctx.lineTo(-18, 8);
        ctx.moveTo(12, 5);
        ctx.lineTo(20, -2);
        ctx.lineTo(18, 8);
        ctx.stroke();

        // Cockpit
        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(0, -8, 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }
    function activateVoidBeam(){if(store.player.hasVoidBeam&&store.player.voidBeamCooldown<=0&&!store.isPaused){store.player.voidBeamCooldown=30;const angle=Math.random()*2*Math.PI,speed=800,p=store.player;store.lasers.push({x:p.x,y:p.y,prevX:p.x,prevY:p.y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:6,r:12,hitEnemies:new Set})}}
    function useGrenade(){if(store.player.grenades>0&&!store.isPaused){store.player.grenades--;store.grenades.push({x:store.player.x,y:store.player.y,vx:0,vy:-200,fuse:1.5,r:8})}}
    // --- EVENT LISTENERS & INITIALIZATION ---
    function ensureName(){if(!store.name){store.isPaused=true;q("namePanel").classList.remove("hide");q("nameInput").value="";setTimeout(()=>q("nameInput").focus(),50)}}
    
    q("restartBtn").addEventListener("click",resetGame);
    
    q("saveName").addEventListener("click",()=>{const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");store.isPaused=false}});
    
    const closeShopLogic = () => { q("shopPanel").classList.add('hide'); store.isPaused = false; q('pauseBtn').classList.remove('hide'); const highlighted = document.querySelector('.shop-item.highlight'); if (highlighted) highlighted.classList.remove('highlight'); };
    q("closeShop").addEventListener("click", closeShopLogic);
    q("closeShopTopBtn").addEventListener("click", closeShopLogic);

    q("shopBtn").addEventListener("click", () => {
        if (q('shopPanel').classList.contains('hide')) {
            showShop();
        } else {
            closeShopLogic();
        }
    });

    const closeScoresLogic = () => { store.isPaused=false; q('scorePanel').classList.add('hide'); q('pauseBtn').classList.remove('hide'); };
    q("closeScores").addEventListener("click", closeScoresLogic);
    
    q("menuBtn").addEventListener("click",()=>{
        if (q('scorePanel').classList.contains('hide')) {
            store.isPaused=true;
            q('scorePanel').classList.remove('hide');
            q('pauseBtn').classList.add('hide');
        } else {
            closeScoresLogic();
        }
    });

    q("fsEnterBtn").addEventListener('click',()=>{const r=document.documentElement;if(!document.fullscreenElement){if(r.requestFullscreen)r.requestFullscreen();else if(r.webkitRequestFullscreen)r.webkitRequestFullscreen();else if(r.msRequestFullscreen)r.msRequestFullscreen()}else{if(document.exitFullscreen)document.exitFullscreen()}});
    
    q('pauseBtn').addEventListener('click',()=>{if(!store.isGameOver&&q('shopPanel').classList.contains('hide')&&q('levelPanel').classList.contains('hide')&&q('namePanel').classList.contains('hide')&&q('scorePanel').classList.contains('hide')){store.isPaused=!store.isPaused;q('pauseBtn').textContent=store.isPaused?'RESUME':'PAUSE'}});
    
    q('grenadeBtnUI').addEventListener('click',useGrenade);
    
    q('voidBeamBtnUI').addEventListener('click',activateVoidBeam);
    
    q("nameInput").addEventListener("keydown",(e)=>{if(e.key==="Enter"){const t=(q("nameInput").value||"").slice(0,16).trim();if(t){store.name=t;q("namePanel").classList.add("hide");store.isPaused=false}}});

    q("namePanel").addEventListener("click", (e) => {
        if(e.target.id !== 'nameInput' && e.target.id !== 'saveName') {
            q('nameInput').blur();
        }
    });
    
    let cheatCodeBuffer = "";
    addEventListener("keydown",e=>{
        const key=e.key.toLowerCase();
        if(document.activeElement.tagName==="INPUT")return;
        
        if (/[a-z]/.test(key)) {
            cheatCodeBuffer += key;
            if (cheatCodeBuffer.length > 10) {
                cheatCodeBuffer = cheatCodeBuffer.substring(cheatCodeBuffer.length - 10);
            }

            if (cheatCodeBuffer.endsWith('power')) {
                store.cheatsUsed = true;
                announce('CHEAT: POWER UP!');
                resetGame();
                store.world.shards = 150;
                store.player.multishot = 3;
                initWave();
                cheatCodeBuffer = "";
            }
        } else {
             if (key !== ' ' && key !== 'b') {
                cheatCodeBuffer = "";
            }
        }
        
        if(key===' '){e.preventDefault();useGrenade()}if(key==='b'){activateVoidBeam()}});
    function frame(now){const dt=Math.min(.033,(now-store.last)/1e3);store.last=now;if(!store.isGameOver&&!store.isPaused){stepWorld(dt)}render(dt);q('fps').textContent=(1/dt).toFixed(0);requestAnimationFrame(frame)}
    try{initWave();refreshScoreList();ensureName();requestAnimationFrame(frame)}catch(error){console.error("Game initialization failed:",error);try{updateLeaderboard(null);ensureName();requestAnimationFrame(frame);console.log("Game started in offline mode")}catch(criticalError){console.error("Critical startup failure:",criticalError);alert("Game failed to start. Please refresh the page.")}}
    
})();
</script>
</body>
</html>

