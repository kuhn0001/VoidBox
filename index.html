<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Orbitron:wght@500;700&display=swap" rel="stylesheet" />
  <title>Void Skies</title>
  <style>
    :root {
      --bg:#050008; --fg:#ff99cc;
      --accent:#b266ff;          /* purple accent */
      --accent2:#9a66ff;          /* slightly different purple for bars */
      --edge:rgba(178,102,255,.35);
      --hud-text: clamp(9px, 1vw, 12px);
      --btn-text: clamp(12px, 1.3vw, 16px);
      --btn-pad-y: clamp(6px, 0.8vw, 10px);
      --btn-pad-x: clamp(10px, 1.5vw, 14px);
      --maxw: 95vw;
    }
    html,body{
      height:100%;margin:0;
      background:radial-gradient(1200px 800px at 50% 40%, #330044, var(--bg));
      color:var(--fg);
      font-family:'Audiowide', ui-sans-serif, system-ui;
    }
    #wrap{position:fixed;inset:0;display:grid;place-items:center;min-height:100svh;padding:
      calc(8px + env(safe-area-inset-top))
      calc(8px + env(safe-area-inset-right))
      calc(8px + env(safe-area-inset-bottom))
      calc(8px + env(safe-area-inset-left));}
    .stage{
      width:min(95vw, var(--maxw)); aspect-ratio:16/9; position:relative; display:grid; place-items:center;
      background:#000; border-radius:12px; overflow:hidden; box-shadow:0 0 60px rgba(255,0,255,.4);
      container-type:inline-size;
    }
    canvas{background:transparent; border-radius:16px; touch-action:none; cursor:none;}

    /* ===== Compact HUD ===== */
    #topBar{position:absolute; left:0; right:0; top:0; display:grid; place-items:center; padding:4px; pointer-events:none;}
    #hud{
      display:flex; gap:8px; pointer-events:none; font-size:var(--hud-text);
      justify-content:center; align-items:flex-start; width:auto; max-width:none; transform:translateY(2px);
    }
    .hud-card{
      pointer-events:none; border:1px solid var(--edge);
      background:linear-gradient(180deg, rgba(150,80,255,.12), rgba(150,80,255,.06));
      backdrop-filter:blur(8px); padding:6px 10px; border-radius:8px; width:auto; min-width:220px;
    }
    .hud-title{opacity:.85; font-weight:600; margin-bottom:4px; font-family:'Orbitron','Audiowide',ui-sans-serif; text-align:center; font-size:10px; color:#c49cff;}
    .bar{height:6px;width:120%;background:rgba(150,80,255,.12);border-radius:999px;overflow:hidden;border:1px solid var(--edge);margin-top:2px}
    .bar>span{display:block;height:120%;background:linear-gradient(90deg,var(--accent),var(--accent2))}

    #announce{position:absolute; left:50%; transform:translateX(-50%); top:40px; background:linear-gradient(180deg, rgba(150,80,255,.26), rgba(150,80,255,.1)); border:1px solid var(--accent); padding:6px 10px; border-radius:10px; font-weight:600; text-shadow:0 0 10px var(--accent); font-family:'Orbitron','Audiowide',ui-sans-serif; font-size:12px; color:#fff;}

    #diagBox{position:absolute; right:8px; bottom:8px; display:grid; gap:4px; pointer-events:none;}
    .chip{pointer-events:auto; background:rgba(0,0,0,.7); border:1px solid var(--edge); padding:4px 8px; border-radius:8px; font-size:10px; letter-spacing:.3px; font-family:'Orbitron','Audiowide',ui-sans-serif; text-align:right; color:#c49cff;}

    /* ===== NEW: Resource HUD (Bottom-Left) ===== */
    #resourceHud {
        position: absolute; left: 8px; bottom: 8px;
        display: grid; gap: 4px; pointer-events: none;
        font-family: 'Orbitron', 'Audiowide', ui-sans-serif;
        text-shadow: 0 0 5px var(--accent);
    }
    .resource-chip {
        background: rgba(0,0,0,.7); border: 1px solid var(--edge);
        padding: 4px 8px; border-radius: 8px; font-size: 11px;
        color: #c49cff;
    }

    .btn{background:#330044;color:#ffddff;border:1px solid var(--accent);border-radius:12px;padding:var(--btn-pad-y) var(--btn-pad-x);font-size:var(--btn-text);cursor:pointer;touch-action:manipulation;-webkit-user-select:none;user-select:none;transition:all 0.2s;}
    .btn:hover{background:#4c0e72;box-shadow:0 0 15px rgba(178,102,255,.5);}
    .panel{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(26,0,34,.95);border:1px solid var(--accent);border-radius:16px;padding:20px;width:min(900px,92vw);pointer-events:auto;backdrop-filter:blur(12px);color:#ffddff;box-shadow:0 0 40px rgba(178,102,255,.3);}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
    .hide{display:none!important}

    #belowBoard{width:min(95vw, var(--maxw)); margin:8px auto 0; padding:8px; display:grid; gap:8px;}
    #hsCard{border:1px solid var(--edge); background:linear-gradient(180deg, rgba(150,80,255,.12), rgba(150,80,255,.06)); backdrop-filter:blur(8px); padding:8px; border-radius:8px;}
    #hsCard h3{margin:0 0 6px 0; font-family:'Orbitron','Audiowide',ui-sans-serif; text-align:center; font-size:14px; color:#c49cff;}
    #hsList{list-style:decimal; margin:0; padding:0 0 0 1rem; line-height:1.4; font-size:12px; color:#ffddff;}

    .skill-card{background:rgba(51,0,68,.8);border:1px solid var(--accent);border-radius:8px;padding:10px;cursor:pointer;transition:all 0.2s;}
    .skill-card:hover{background:rgba(85,0,120,.9);box-shadow:0 0 20px rgba(178,102,255,.6);transform:scale(1.05);}
    .skill-title{font-weight:bold;color:#c49cff;margin-bottom:4px;}
    .skill-desc{font-size:11px;color:#ffddff;}

    #menuBtn{position:fixed; bottom:10px; right:10px; z-index:5; border-radius:10px; padding:10px 10px; background:rgba(150,80,255,.2); border:1px solid var(--accent); backdrop-filter:blur(8px); cursor:pointer; font-size:12px; color:#ffddff;}
    .input{width:120%; padding:10px 10px; border-radius:10px; background:#17001f; color:#ffddff; border:1px solid var(--accent); font-family:'Orbitron','Audiowide',ui-sans-serif;}

    @media (max-width: 820px){
      canvas{width:100vw;height:auto;max-height:75vh;border-radius:8px}
      .panel{width:min(700px,94vw)}
      .stage{width:98vw;}
      #belowBoard{width:98vw;}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div>
      <div class="stage" id="stage">
        <div id="topBar">
          <div id="hud">
            <div id="hudWaveContent" class="hud-card"></div>
            <div id="hudPilotContent" class="hud-card"></div>
            <div id="hudBossContent" class="hud-card hide"></div>
          </div>
          <div id="announce" class="hide" aria-live="polite"></div>
        </div>

        <canvas id="game" width="960" height="540"></canvas>

        <div id="resourceHud">
          <div class="resource-chip">SCORE: <span id="resScore">0</span></div>
          <div class="resource-chip">SHARDS: <span id="resShards">0</span></div>
        </div>

        <div id="diagBox">
          <div class="chip"> v2.2</div>
          <div class="chip">FPS <span id="fps">‚Äî</span></div>
        </div>
      </div>

      <div id="belowBoard">
        <div id="hsCard">
          <h3>‚ö° ACE PILOTS ‚ö°</h3>
          <ol id="hsList"></ol>
        </div>
      </div>
    </div>
  </div>

  <div id="ui">
    <div id="gameOverPanel" class="panel hide">
        <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">üöÄ PILOT LOST üöÄ</h2>
        <p style="text-align:center;font-size:1.2em;color:#ffddff;">FINAL SCORE: <span id="finalScore">0</span></p>
        <div class="row" style="justify-content:center;margin-top:20px;">
            <button id="restartBtn" class="btn" type="button">FLY AGAIN</button>
        </div>
    </div>

    <div id="namePanel" class="panel hide">
      <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">ü™™ CALLSIGN</h2>
      <p style="color:#ffddff;margin-top:0;">Enter your pilot callsign (max 16 chars).</p>
      <input id="nameInput" class="input" maxlength="16" placeholder="e.g. NIGHTWRAITH" />
      <div class="row" style="justify-content:flex-end;margin-top:12px;">
        <button id="saveName" class="btn" type="button">CONFIRM</button>
      </div>
    </div>

    <div id="scorePanel" class="panel hide">
      <h2 style="font-family:'Orbitron';color:var(--accent);margin-top:0;">üèÜ ACE PILOTS üèÜ</h2>
      <div style="max-height:60vh;overflow-y:auto;"><ol id="hsListPopup" style="line-height:1.6;color:#ffddff;"></ol></div>
      <div style="display:flex;justify-content:flex-end;margin-top:10px;"><button id="closeScores" class="btn" type="button">CLOSE</button></div>
    </div>

    <div id="levelPanel" class="panel hide">
      <h2 style="font-family:'Orbitron';color:var(--accent);">‚ö° AUGMENTATION PROTOCOL ‚ö°</h2>
      <p style="color:#ffddff;">Select your neural enhancement:</p>
      <div id="skillsGrid" class="grid"></div>
    </div>

    <div id="shopPanel" class="panel hide">
      <h2 style="font-family:'Orbitron';color:var(--accent);">üîß MECH FORGE üîß</h2>
      <p style="color:#ffddff;">Available Shards: <span id="shopParts">0</span> (Press 'B' to close)</p>
      <div id="shopGrid" class="grid"></div>
      <div class="row" style="justify-content:flex-end;margin-top:10px;">
        <button id="closeShop" class="btn" type="button">OKAY</button>
      </div>
    </div>
  </div>

  <button id="menuBtn" type="button">üèÜ TOP PILOTS</button>

<script>
(() => {
  // ---------- Constants ----------
  const W = 960, H = 540;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const collide = (a, b) => {
    const dx = a.x - b.x, dy = a.y - b.y;
    const rr = (a.r || 0) + (b.r || 0);
    return dx*dx + dy*dy < rr*rr;
  };

  // ---------- Server API ----------
  const API_BASE = "https://card-eau-sugar-opera.trycloudflare.com/api";

  const memoryStore = { scores: [], playerName: '', upgrades: {} };
  const LS = {
    load: (k, fallback) => memoryStore[k] !== undefined ? memoryStore[k] : fallback,
    save: (k, v) => (memoryStore[k] = v)
  };
  const q = (id) => document.getElementById(id);

  // ---------- Canvas setup ----------
  const cvs = q('game');
  const ctx = cvs.getContext('2d');
  const stage = q('stage');

  function resize() {
    const rect = stage.getBoundingClientRect();
    const cssW = Math.floor(rect.width);
    const cssH = Math.floor(rect.height);
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cvs.style.width = cssW + 'px'; cvs.style.height = cssH + 'px';
    cvs.width = Math.floor(cssW * dpr); cvs.height = Math.floor(cssH * dpr);
    ctx.setTransform(cvs.width / W, 0, 0, cvs.height / H, 0, 0);
  }
  new ResizeObserver(resize).observe(stage); resize();

  // ---------- Input ----------
  const mouse = { x: W / 2, y: H * 0.8 };
  function pointFromEvent(e) {
    const r = cvs.getBoundingClientRect();
    const cx = 'clientX' in e ? e.clientX : e.touches[0].clientX;
    const cy = 'clientY' in e ? e.clientY : e.touches[0].clientY;
    const scaleX = W / r.width, scaleY = H / r.height;
    return { x: (cx - r.left) * scaleX, y: (cy - r.top) * scaleY };
  }
  cvs.addEventListener('mousemove', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; });
  cvs.addEventListener('touchstart', (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive:false });
  cvs.addEventListener('touchmove',  (e) => { const p = pointFromEvent(e); mouse.x = p.x; mouse.y = p.y; e.preventDefault(); }, { passive:false });

  // ---------- Game State ----------
  const store = {
    frame: 0, last: performance.now(), isGameOver: false,
    world: { wave: 1, score: 0, parts: 0, xp: 0, level: 1, kills: 0, bosses: 0 },
    player: {
      x: W*0.5, y: H-60, r: 14, hp: 100, hpMax: 100,
      fireT: 0, speed: 380, dmgMult: 1, fireRate: 0.18, vampirism: 0,
      shield: 0, shieldMax: 0, multishot: 1, piercing: 0, explosive: false
    },
    boss: null, bullets: [], eBullets: [], enemies: [], particles: [],
    scores: LS.load('scores', []), name: LS.load('playerName', ''), upgrades: LS.load('upgrades', {}),
    _startTs: performance.now()
  };

  // ---------- Skills & Spawner ----------
  const SKILLS = [
    { id: 'dmg', name: 'PLASMA CORE', desc: '+25% damage', apply: () => store.player.dmgMult *= 1.25 },
    { id: 'speed', name: 'NEURAL BOOST', desc: '+15% speed', apply: () => store.player.speed *= 1.15 },
    { id: 'hp', name: 'BLOOD ARMOR', desc: '+10 max HP', apply: () => { store.player.hpMax += 10; store.player.hp += 10; } },
    { id: 'fire', name: 'OVERCLOCK', desc: '+25% fire rate', apply: () => store.player.fireRate *= 0.75 },
    { id: 'vamp', name: 'VAMPIRIC ROUNDS', desc: 'Heal .5% damage', apply: () => store.player.vampirism += 0.005 },
    { id: 'multi', name: 'SCATTER PROTOCOL', desc: '+1 projectile', apply: () => store.player.multishot += 1 },
    { id: 'pierce', name: 'PHASE ROUNDS', desc: 'Piercing bullets', apply: () => store.player.piercing = 1 },
    { id: 'shield', name: 'VOID SHIELD', desc: '+30 shield', apply: () => { store.player.shieldMax += 30; store.player.shield = store.player.shieldMax; } },
    { id: 'explode', name: 'NOVA WARHEADS', desc: 'Explosive rounds', apply: () => store.player.explosive = true }
  ];

  let spawnLeft = 8, spawnTimer = 0, spawnInterval = 0.8;
  function initWave() {
    const isBossWave = store.world.wave % 5 === 0;
    if (isBossWave) {
      spawnLeft = 0; store.boss = createBoss();
      announce(`‚ö° GUARDIAN: ${store.boss.name} ‚ö°`);
    } else {
      spawnLeft = 6 + Math.floor(store.world.wave * 1.5);
      spawnTimer = 0; spawnInterval = Math.max(0.25, 0.95 - store.world.wave * 0.05);
      announce(`‚ó¢ SECTOR ${store.world.wave} ‚ó£`);
    }
  }

  function createBoss() {
    const types = [
      { name: 'DONGULUS', hp: 800 }, { name: 'MECHANICUS', hp: 1000 }, { name: 'VOIDCREEPER', hp: 1200 }
    ];
    const type = types[Math.floor(store.world.wave / 5) % types.length];
    return { ...type, x: W/2, y: -80, r: 50, hpMax: type.hp, color:'#b266ff', hp: type.hp, t: 0, fireT: 0, moveT: 0, vx: 100, vy: 30 };
  }

  function stepSpawner(dt) {
    if (store.boss) return;
    spawnTimer += dt;
    if (spawnLeft > 0 && spawnTimer >= spawnInterval) {
      spawnTimer = 0; spawnLeft--;
      const types = ['drone', 'drone', 'hunter', 'phantom', 'mech'];
      store.enemies.push(spawnEnemy(types[Math.floor(Math.random() * types.length)]));
    }
    if (store.enemies.length === 0 && spawnLeft === 0) { store.world.wave++; initWave(); }
  }

  function spawnEnemy(type='drone') {
    const cfgs = {
      drone:  { r:10, v:80,  hp:20, color:'#c27cff', xp:5,  score: 50,  parts: 1 },
      hunter: { r:12, v:120, hp:30, color:'#b266ff', xp:8,  score: 80,  parts: 2 },
      phantom:{ r:14, v:100, hp:25, color:'#9a66ff', xp:10, score: 100, parts: 2 },
      mech:   { r:18, v:60,  hp:60, color:'#7a49cc', xp:15, score: 150, parts: 3 }
    };
    const c = cfgs[type];
    return { ...c, type, x:20+Math.random()*(W-40), y:-50-Math.random()*150, hpMax:c.hp, phase:!!c.phase, t:Math.random()*Math.PI*2 };
  }

  // ---------- Game Logic ----------
  function stepPlayer(dt) {
    const p = store.player, t = mouse;
    const vx = t.x - p.x, vy = t.y - p.y, d = Math.hypot(vx, vy);
    if (d > 1) {
      p.x = clamp(p.x + (vx/d)*p.speed*dt, 20, W-20);
      p.y = clamp(p.y + (vy/d)*p.speed*dt, 20, H-20);
    }
    p.fireT -= dt;
    if (p.fireT <= 0) { firePlayer(); p.fireT = p.fireRate; }
    if (p.shieldMax > 0 && p.shield < p.shieldMax) {
      p.shield = Math.min(p.shieldMax, p.shield + 10 * dt);
    }
  }

  function firePlayer() {
    const p = store.player, bspd = 420;
    const spread = p.multishot > 2 ? 15 : 10;
    for (let i = 0; i < p.multishot; i++) {
      const angle = (i - (p.multishot-1)/2) * spread * Math.PI/180;
      const vx = Math.sin(angle) * bspd, vy = -Math.cos(angle) * bspd;
      store.bullets.push({ x:p.x+Math.sin(angle)*10, y:p.y-12, vx, vy, r:p.explosive?5:3, col:p.explosive?'#cc99ff':'#b266ff', dmg:20*p.dmgMult, pierce:p.piercing, explosive:p.explosive });
    }
  }

  function takeDamage(dmg) {
    const p = store.player;
    const a = Math.min(p.shield, dmg); p.shield -= a; dmg -= a;
    p.hp = Math.max(0, p.hp - dmg);
  }

  function stepBoss(dt) {
    const b = store.boss; if (!b) return;
    b.t += dt;
    if (b.y < 100) b.y += b.vy*dt;
    else {
      b.moveT += dt;
      b.x = W/2 + Math.sin(b.moveT * 1.2) * 220;
      b.y = 100 + Math.sin(b.moveT * 2) * 60;
    }
    b.fireT += dt;
    if (b.fireT > 0.5) { b.fireT = 0; fireBoss(b); }
  }

  function fireBoss(b) {
    for (let i = 0; i < 8; i++) {
      const angle = (i * Math.PI / 4) + b.t * 2;
      store.eBullets.push({ x:b.x+Math.cos(angle)*30, y:b.y+Math.sin(angle)*30, vx:Math.cos(angle)*120, vy:Math.sin(angle)*120, r:5, col:b.color, dmg:15 });
    }
  }

  function stepWorld(dt) {
    stepPlayer(dt); stepSpawner(dt); stepBoss(dt);

    store.eBullets.forEach(b => {
      b.x += b.vx*dt; b.y += b.vy*dt;
      if (b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) b.dead = true;
      if (collide(b, store.player)) { takeDamage(b.dmg||10); b.dead = true; }
    });
    store.enemies.forEach(e => {
      e.t += dt; if (e.phase) e.x += Math.sin(e.t*3) * 50*dt;
      e.y += e.v * dt;
      if (e.y > H+30) e.dead = true;
      if (Math.random() < 0.004) store.eBullets.push({ x:e.x, y:e.y, vx:0, vy:150, r:3, col:e.color, dmg:8 });
      if (collide(e, store.player)) { takeDamage(15); e.dead = true; }
    });
    store.bullets.forEach(b => {
      b.x += b.vx*dt; b.y += b.vy*dt;
      if (b.x < -20 || b.x > W+20 || b.y < -20 || b.y > H+20) b.dead = true;
      store.enemies.forEach(e => { if (!e.dead && collide(b,e)) {
        const dmg = b.dmg || 20; e.hp -= dmg;
        if (e.hp <= 0) {
          e.dead = true; store.world.score += e.score || 50;
          store.world.parts += e.parts || 1; store.world.xp += e.xp || 5;
          store.world.kills++;
          if (store.player.vampirism > 0) store.player.hp = Math.min(store.player.hpMax, store.player.hp + dmg * store.player.vampirism);
        }
        if (b.explosive) explode(b.x,b.y);
        if (!b.pierce) b.dead = true;
      }});
      if (store.boss && collide(b, store.boss)) {
        const dmg = b.dmg || 20; store.boss.hp -= dmg;
        if (store.boss.hp <= 0) {
          store.world.score += 2000; store.world.parts += 25; store.world.xp += 100;
          store.world.bosses++; store.boss = null; announce('‚ö° GUARDIAN DEFEATED ‚ö°');
        }
        if (b.explosive) explode(b.x,b.y);
        if (!b.pierce) b.dead = true;
      }
    });

    store.bullets = store.bullets.filter(b => !b.dead);
    store.eBullets = store.eBullets.filter(b => !b.dead);
    store.enemies = store.enemies.filter(e => !e.dead);
    const xpNeeded = store.world.level * 100;
    if (store.world.xp >= xpNeeded) { store.world.xp -= xpNeeded; store.world.level++; levelUp(); }
    if (store.player.hp <= 0) handleGameOver();
  }

  function explode(x,y) { /* TODO */ }

  // ---------- Visuals ----------
  const starsA = Array.from({ length: 100 }, () => ({ x: Math.random()*W, y: Math.random()*H, r: Math.random()*1.5, pulse: Math.random()*10 }));
  const starsB = Array.from({ length: 80 }, () => ({ x: Math.random()*W, y: Math.random()*H, r: Math.random()*2, pulse: Math.random()*10 }));

  function render(dt) {
    const time = performance.now() * 0.001;
    ctx.fillStyle = '#050008'; ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 0.8;
    for (const s of starsA) {
      s.y += 30 * dt; if (s.y > H) s.y -= H;
      const pulse = 0.5 + 0.5 * Math.sin(time * 2 + s.pulse);
      ctx.fillStyle = `rgba(255,0,255,${pulse})`;
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 0.6;
    for (const s of starsB) {
      s.y += 60 * dt; if (s.y > H) s.y -= H;
      const pulse = 0.4 + 0.6 * Math.sin(time * 1.5 + s.pulse);
      ctx.fillStyle = `rgba(204,0,255,${pulse})`;
      ctx.beginPath(); ctx.arc(s.x, s.y, Math.max(0.1, s.r * pulse), 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
    for (const b of store.eBullets) { ctx.fillStyle = b.col; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); }
    for (const b of store.bullets) { ctx.fillStyle = b.col; ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); }
    for (const e of store.enemies) drawEnemy(e);
    if (store.boss) drawBoss(store.boss);
    drawShip(store.player.x, store.player.y);
    updateHUD(); updateFPS(dt);
  }

  function drawEnemy(e) { /* ... same as before ... */ }
  function drawBoss(b) { /* ... same as before ... */ }
  function drawShip(x, y) { /* ... same as before ... */ }
  // (Leaving drawing functions collapsed for brevity as they are unchanged)
  function drawEnemy(e){const{x,y,r,type,color,hp,hpMax}=e;ctx.save();ctx.translate(x,y);if(hp<hpMax){ctx.fillStyle='rgba(0,0,0,0.5)';ctx.fillRect(-r,-r-8,r*2,3);ctx.fillStyle='#b266ff';ctx.fillRect(-r,-r-8,r*2*(hp/hpMax),3)}
  ctx.strokeStyle=color;ctx.fillStyle=color+'99';ctx.lineWidth=2;if(type==='phantom'){ctx.globalAlpha=0.7+0.3*Math.sin(e.t*5);ctx.beginPath();for(let i=0;i<6;i++){const a=(i*Math.PI/3)+e.t,px=Math.cos(a)*r,py=Math.sin(a)*r;if(i===0)ctx.moveTo(px,py);else ctx.lineTo(px,py)}
  ctx.closePath()}else if(type==='mech'){ctx.fillRect(-r*0.8,-r*0.8,r*1.6,r*1.6);ctx.strokeRect(-r*0.8,-r*0.8,r*1.6,r*1.6);ctx.fillStyle=color;ctx.fillRect(-r*0.5,-r*0.5,r*0.3,r*0.3);ctx.fillRect(r*0.2,-r*0.5,r*0.3,r*0.3)}else if(type==='hunter'){ctx.beginPath();ctx.moveTo(0,-r);ctx.lineTo(r,r*0.5);ctx.lineTo(0,r);ctx.lineTo(-r,r*0.5);ctx.closePath()}else{ctx.beginPath();ctx.arc(0,0,r,0,Math.PI*2)}
  ctx.fill();ctx.stroke();ctx.restore()}
  function drawBoss(b){ctx.save();ctx.translate(b.x,b.y);ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillRect(-60,-b.r-20,120,8);ctx.fillStyle=b.color;ctx.fillRect(-60,-b.r-20,120*(b.hp/b.hpMax),8);ctx.strokeStyle='#ff00ff';ctx.lineWidth=1;ctx.strokeRect(-60,-b.r-20,120,8);ctx.strokeStyle=b.color;ctx.lineWidth=3;for(let i=0;i<3;i++){ctx.save();ctx.rotate(b.t*(1+i*0.5));ctx.beginPath();ctx.arc(0,0,b.r-i*10,0,Math.PI*2);ctx.stroke();ctx.restore()}
  const pulse=0.8+0.2*Math.sin(b.t*3);ctx.fillStyle=b.color+'aa';ctx.beginPath();ctx.arc(0,0,Math.max(1,b.r*0.3*pulse),0,Math.PI*2);ctx.fill();ctx.restore()}
  function drawShip(x,y){ctx.save();ctx.translate(x,y);ctx.beginPath();ctx.moveTo(0,-20);ctx.lineTo(12,8);ctx.lineTo(8,14);ctx.lineTo(0,10);ctx.lineTo(-8,14);ctx.lineTo(-12,8);ctx.closePath();const g=ctx.createLinearGradient(0,-20,0,14);g.addColorStop(0,'#b266ff');g.addColorStop(0.5,'#7a49cc');g.addColorStop(1,'#4d2a80');ctx.fillStyle=g;ctx.fill();ctx.lineWidth=2;ctx.strokeStyle='#c49cff';ctx.stroke();ctx.strokeStyle='#b266ff';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-12,5);ctx.lineTo(-20,-2);ctx.lineTo(-18,8);ctx.moveTo(12,5);ctx.lineTo(20,-2);ctx.lineTo(18,8);ctx.stroke();const time=performance.now()*0.001;ctx.globalAlpha=0.8+0.2*Math.sin(time*10);ctx.fillStyle='#cc99ff';ctx.beginPath();ctx.ellipse(-5,16,3,6,0,0,Math.PI*2);ctx.ellipse(5,16,3,6,0,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;ctx.fillStyle='#ffffff';ctx.beginPath();ctx.arc(0,-8,3,0,Math.PI*2);ctx.fill();ctx.restore()}

  // ---------- HUD ----------
  function escapeHtml(s){ s=String(s??''); return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function updateHUD() {
    q('hudWaveContent').innerHTML = `<div class="hud-title">‚ó¢ VOID SKIES ‚ó£</div><div style="text-align:center">SECTOR <b>${store.world.wave}</b> ‚Ä¢ KILLS <b>${store.world.kills}</b> ‚Ä¢ LVL <b>${store.world.level}</b></div>`;
    const p = store.player, hpPct = Math.round((p.hp / p.hpMax) * 100);
    const shieldPct = p.shieldMax > 0 ? Math.round((p.shield / p.shieldMax) * 100) : 0;
    q('hudPilotContent').innerHTML = `<div class="hud-title">${store.name ? ('‚ó¢ '+escapeHtml(store.name)+' ‚ó£') : '‚ó¢ UNIDENTIFIED ‚ó£'}</div><div style="text-align:center">HULL ${hpPct}% ${p.shieldMax>0?`‚Ä¢ SHIELD ${shieldPct}%`:''}</div><div class="bar"><span style="width:${hpPct}%"></span></div>${p.shieldMax>0?`<div class="bar" style="margin-top:2px;"><span style="width:${shieldPct}%;background:linear-gradient(90deg,#80ffff,#66aaff)"></span></div>`:''}`;
    if (store.boss) {
      q('hudBossContent').classList.remove('hide');
      q('hudBossContent').innerHTML = `<div class="hud-title">‚ö° ${store.boss.name} ‚ö°</div><div class="bar"><span style="width:${Math.round(store.boss.hp/store.boss.hpMax*100)}%"></span></div>`;
    } else { q('hudBossContent').classList.add('hide'); }
    // Update new resource HUD
    q('resScore').textContent = store.world.score;
    q('resShards').textContent = store.world.parts;
  }
  let fpsEMA=60; function updateFPS(dt){ if(!dt)return; fpsEMA=fpsEMA*.88+(1/dt)*.12; q('fps').textContent=String(Math.round(fpsEMA)); }
  function announce(text){ const el=q('announce'); el.textContent=text; el.classList.remove('hide'); clearTimeout(el._t); el._t=setTimeout(()=>el.classList.add('hide'), 2500); }

  // ---------- High Scores (SERVER-Backed) ----------
  async function refreshScoreList() { /* ... same as before ... */ }
  async function addScore(score) { /* ... same as before ... */ }
  async function refreshScoreList(){try{const res=await fetch(`${API_BASE}/leaderboard`,{cache:"no-store"});const data=await res.json();store.scores=data;q("hsList").innerHTML=(data||[]).map(s=>`<li>${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves??"?"})</li>`).join("")||`<li>NO DATA</li>`;q("hsListPopup").innerHTML=(data||[]).map((s,i)=>`<li>#${i+1} ${escapeHtml(s.name)} ‚Äî ${s.score} (Wave ${s.waves??"?"})</li>`).join("")||`<li>NO DATA</li>`}catch(err){console.error("Scores:",err)}}
  async function addScore(score){const name=(store.name||"ROGUE").slice(0,16);try{const nonceRes=await fetch(`${API_BASE}/session`,{method:"POST"});const{nonce}=await nonceRes.json();const msElapsed=Math.max(10_000,Math.floor(performance.now()-(store._startTs||performance.now())));const body={name,score:Math.floor(score)||0,waves:store.world.wave|0,kills:store.world.kills|0,bosses:store.world.bosses|0,ms:msElapsed,nonce};const res=await fetch(`${API_BASE}/submit`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(body)});const data=await res.json();if(data.ok){store.scores=data.top10;refreshScoreList()}else{console.warn("Score rejected:",data.err);announce(`Score rejected: ${data.err}`)}}catch(err){console.error("Submit:",err)}}

  // ---------- UI Panels (Level Up, Shop) ----------
  function levelUp() { /* ... same as before ... */ }
  function levelUp(){announce(`‚ö° LEVEL ${store.world.level}  REACHED ‚ö°`);const p=q('levelPanel'),g=q('skillsGrid');const avail=SKILLS.filter(s=>!store.upgrades[s.id]||store.upgrades[s.id]<5);const choices=[];for(let i=0;i<3&&avail.length>0;i++){const idx=Math.floor(Math.random()*avail.length);choices.push(avail.splice(idx,1)[0])}
  g.innerHTML=choices.map(s=>`<div class="skill-card" data-id="${s.id}"><div class="skill-title">${s.name}</div><div class="skill-desc">${s.desc}</div></div>`).join('');g.querySelectorAll('.skill-card').forEach(c=>{c.addEventListener('click',()=>{const id=c.dataset.id,skill=SKILLS.find(s=>s.id===id);if(skill){skill.apply();store.upgrades[id]=(store.upgrades[id]||0)+1;LS.save('upgrades',store.upgrades)}
  p.classList.add('hide')})});p.classList.remove('hide')}

  function showShop() {
    const panel = q('shopPanel'), grid = q('shopGrid'), parts = q('shopParts');
    parts.textContent = store.world.parts;
    const items = [
      { name: 'REPAIR NANOBOTS', cost: 20, desc: 'Restore 25 HP', buy: () => store.player.hp = Math.min(store.player.hpMax, store.player.hp + 25) },
      { name: 'SHIELD BOOSTER', cost: 30, desc: '+20 shield capacity', buy: () => { store.player.shieldMax += 20; store.player.shield += 20; } },
      { name: 'PLASMA UPGRADE', cost: 40, desc: '+15% damage', buy: () => store.player.dmgMult *= 1.15 },
      { name: 'SPEED DEMON', cost: 35, desc: '+10% move speed', buy: () => store.player.speed *= 1.1 }
    ];
    grid.innerHTML = items.map((item, i) => `
      <div class="skill-card shop-item" data-idx="${i}" style="${store.world.parts < item.cost ? 'opacity:0.5;pointer-events:none;' : ''}">
        <div class="skill-title">${item.name}</div>
        <div class="skill-desc">${item.desc}</div>
        <div style="color:var(--accent);margin-top:4px;">Cost: ${item.cost} shards</div>
      </div>`).join('');
    grid.querySelectorAll('.shop-item').forEach(card => {
      card.addEventListener('click', () => {
        const idx = parseInt(card.dataset.idx), item = items[idx];
        if (store.world.parts >= item.cost) {
          store.world.parts -= item.cost; item.buy();
          showShop(); // Refresh shop UI after purchase
        }
      });
    });
    panel.classList.remove('hide');
  }

  // ---------- Game Over & Reset ----------
  function handleGameOver() {
    if (store.isGameOver) return;
    store.isGameOver = true;
    addScore(store.world.score);
    announce('‚ó¢ NEXUS BREACH - PILOT LOST ‚ó£');
    q('finalScore').textContent = store.world.score;
    q('gameOverPanel').classList.remove('hide');
  }

  function resetGame() {
    store.player = {
        x: W*0.5, y: H-60, r: 14, hp: 100, hpMax: 100,
        fireT: 0, speed: 380, dmgMult: 1, fireRate: 0.18, vampirism: 0,
        shield: 0, shieldMax: 0, multishot: 1, piercing: 0, explosive: false
    };
    store.world = { wave: 1, score: 0, parts: 0, xp: 0, level: 1, kills: 0, bosses: 0 };
    store.boss = null; store.enemies.length = 0; store.bullets.length = 0;
    store.eBullets.length = 0; store.particles.length = 0;
    store.upgrades = {}; store._startTs = performance.now(); store.isGameOver = false;
    q('gameOverPanel').classList.add('hide');
    initWave();
  }

  // ---------- Loop ----------
  function frame(now) {
    const dt = Math.min(0.033, (now - store.last)/1000);
    store.last = now; store.frame++;
    if (!store.isGameOver) stepWorld(dt);
    render(dt);
    requestAnimationFrame(frame);
  }

  // ---------- Event Listeners ----------
  function ensureName() {
    if (!store.name) {
      q('namePanel').classList.remove('hide');
      q('nameInput').value = '';
      setTimeout(()=>q('nameInput').focus(), 50);
    }
  }
  q('saveName').addEventListener('click', () => {
    const v = (q('nameInput').value || '').slice(0,16).trim();
    if (v) { store.name = v; LS.save('playerName', v); q('namePanel').classList.add('hide'); }
  });

  addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (document.activeElement.tagName === 'INPUT') return;
    if (k === 'n') {
      q('nameInput').value = store.name || '';
      q('namePanel').classList.remove('hide');
    } else if (k === 'b') {
      const shop = q('shopPanel');
      if (shop.classList.contains('hide')) showShop();
      else shop.classList.add('hide');
    } else if (k === 'x') {
      store.player.hp = 0;
    }
  });

  q('restartBtn').addEventListener('click', resetGame);
  q('menuBtn').addEventListener('click', () => q('scorePanel').classList.remove('hide'));
  q('closeScores').addEventListener('click', () => q('scorePanel').classList.add('hide'));
  q('closeShop').addEventListener('click', () => q('shopPanel').classList.add('hide'));

  // ---------- Boot ----------
  refreshScoreList(); initWave(); ensureName(); requestAnimationFrame(frame);
})();
</script>
</body>
</html>
